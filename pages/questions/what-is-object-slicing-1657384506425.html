<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2eccd4d47c856f2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2eccd4d47c856f2b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/471-84c36aa98dd4107c.js" defer=""></script><script src="/_next/static/chunks/81-301f760ac8107464.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-76d2c3e2d98bb08b.js" defer=""></script><script src="/_next/static/6_hwtyf_oFlFS5l_S4CTe/_buildManifest.js" defer=""></script><script src="/_next/static/6_hwtyf_oFlFS5l_S4CTe/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.eZIPKL code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-c4b0431a-0"]{content:"eZIPKL,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="https://flowbite.com/docs/images/logo.svg" class="mr-3 h-6 sm:h-9" alt="Flowbite Logo"/><span class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Hunter</span></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/what-is-object-slicing-1657384506425#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-c4b0431a-0 eZIPKL flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-is-object-slicing-1657384506425">What is object slicing?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/inheritance">inheritance</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/object-slicing">object-slicing</a></div></div><div class="question-content mt-5">
                
<p>In c++ what is object slicing and when does it occur?</p>
    </div></div></div><div class="sc-c4b0431a-2 cRqwQe"><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>"Slicing" is where you assign an object of a derived class to an instance of a base class, thereby losing part of the information - some of it is "sliced" away.</p>

<p>For example, </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
   <span class="hljs-type">int</span> foo;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A {
   <span class="hljs-type">int</span> bar;
};
</code></pre>

<p>So an object of type <code>B</code> has two data members, <code>foo</code> and <code>bar</code>.</p>

<p>Then if you were to write this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">B b;

A a = b;
</code></pre>

<p>Then the information in <code>b</code> about member <code>bar</code> is lost in <code>a</code>.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Most answers here fail to explain what the actual problem with slicing is. They only explain the benign cases of slicing, not the treacherous ones. Assume, like the other answers, that you're dealing with two classes <code>A</code> and <code>B</code>, where <code>B</code> derives (publicly) from <code>A</code>.</p>

<p>In this situation, C++ lets you pass an instance of <code>B</code> to  <code>A</code>'s assignment operator (and also to the copy constructor). This works because an instance of <code>B</code> can be converted to a <code>const A&amp;</code>, which is what assignment operators and copy-constructors expect their arguments to be.</p>

<h3>The benign case</h3>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">B b;
A a = b;
</code></pre>

<p>Nothing bad happens there - you asked for an instance of <code>A</code> which is a copy of <code>B</code>, and that's exactly what you get. Sure, <code>a</code> won't contain some of <code>b</code>'s members, but how should it? It's an <code>A</code>, after all, not a <code>B</code>, so it hasn't even <em>heard</em> about these members, let alone would be able to store them.</p>

<h3>The treacherous case</h3>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">B b1;
B b2;
A&amp; a_ref = b2;
a_ref = b1;
<span class="hljs-comment">//b2 now contains a mixture of b1 and b2!</span>
</code></pre>

<p>You might think that <code>b2</code> will be a copy of <code>b1</code> afterward. But, alas, it's <strong>not</strong>! If you inspect it, you'll discover that <code>b2</code> is a Frankensteinian creature, made from some chunks of <code>b1</code> (the chunks that <code>B</code> inherits from <code>A</code>), and some chunks of <code>b2</code> (the chunks that only <code>B</code> contains). Ouch!</p>

<p>What happened? Well, C++ by default doesn't treat assignment operators as <code>virtual</code>. Thus, the line <code>a_ref = b1</code> will call the assignment operator of <code>A</code>, not that of <code>B</code>. This is because, for non-virtual functions, the <strong>declared</strong> (formally: <em>static</em>) type (which is <code>A&amp;</code>) determines which function is called, as opposed to the <strong>actual</strong> (formally: <em>dynamic</em>) type (which would be <code>B</code>, since <code>a_ref</code> references an instance of <code>B</code>). Now, <code>A</code>'s assignment operator obviously knows only about the members declared in <code>A</code>, so it will copy only those, leaving the members added in <code>B</code> unchanged.</p>

<h3>A solution</h3>

<p>Assigning only to parts of an object usually makes little sense, yet C++, unfortunately, provides no built-in way to forbid this. You can, however, roll your own. The first step is making the assignment operator <em>virtual</em>. This will guarantee that it's always the <strong>actual</strong> type's assignment operator which is called, not the <strong>declared</strong> type's. The second step is to use <code>dynamic_cast</code> to verify that the assigned object has a compatible type. The third step is to do the actual assignment in a (protected!) member <code>assign()</code>, since <code>B</code>'s <code>assign()</code> will probably want to use <code>A</code>'s <code>assign()</code> to copy <code>A</code>'s, members.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">virtual</span> A&amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> A&amp; a) {
    <span class="hljs-built_in">assign</span>(a);
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
  }

<span class="hljs-keyword">protected</span>:
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(<span class="hljs-type">const</span> A&amp; a)</span> </span>{
    <span class="hljs-comment">// copy members of A from a to this</span>
  }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A {
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">virtual</span> B&amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> A&amp; a) {
    <span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> B* b = <span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">const</span> B*&gt;(&amp;a))
      <span class="hljs-built_in">assign</span>(*b);
    <span class="hljs-keyword">else</span>
      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">bad_assignment</span>();
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
  }

<span class="hljs-keyword">protected</span>:
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(<span class="hljs-type">const</span> B&amp; b)</span> </span>{
    A::<span class="hljs-built_in">assign</span>(b); <span class="hljs-comment">// Let A's assign() copy members of A from b to this</span>
    <span class="hljs-comment">// copy members of B from b to this</span>
  }
};
</code></pre>

<p>Note that, for pure convenience, <code>B</code>'s <code>operator=</code> covariantly overrides the return type, since it <strong>knows</strong> that it's returning an instance of <code>B</code>.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If You have a base class <code>A</code> and a derived class <code>B</code>, then You can do the following.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wantAnA</span><span class="hljs-params">(A myA)</span>
</span>{
   <span class="hljs-comment">// work with myA</span>
}

B derived;
<span class="hljs-comment">// work with the object "derived"</span>
<span class="hljs-built_in">wantAnA</span>(derived);
</code></pre>

<p>Now the method <code>wantAnA</code> needs a copy of <code>derived</code>. However, the object <code>derived</code> cannot be copied completely, as the class <code>B</code> could invent additional member variables which are not in its base class <code>A</code>.</p>

<p>Therefore, to call <code>wantAnA</code>, the compiler will "slice off" all additional members of the derived class. The result might be an object you did not want to create, because</p>

<ul>
<li>it may be incomplete,</li>
<li>it behaves like an <code>A</code>-object (all special behaviour of the class <code>B</code> is lost).</li>
</ul>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>These are all good answers. I would just like to add an execution example when passing objects by value vs by reference:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-comment">// Base class</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">A</span>() {}
    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a) {
        cout &lt;&lt; <span class="hljs-string">"'A' copy constructor"</span> &lt;&lt; endl;
    }
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ cout &lt;&lt; <span class="hljs-string">"I am an 'A'"</span> &lt;&lt; endl; }
};

<span class="hljs-comment">// Derived class</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">B</span>():<span class="hljs-built_in">A</span>() {}
    <span class="hljs-built_in">B</span>(<span class="hljs-type">const</span> B&amp; a):<span class="hljs-built_in">A</span>(a) {
        cout &lt;&lt; <span class="hljs-string">"'B' copy constructor"</span> &lt;&lt; endl;
    }
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ cout &lt;&lt; <span class="hljs-string">"I am a 'B'"</span> &lt;&lt; endl; }
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">const</span> A &amp; a)</span> </span>{
    a.<span class="hljs-built_in">run</span>();
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-type">const</span> A a)</span> </span>{
    a.<span class="hljs-built_in">run</span>();
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    cout &lt;&lt; <span class="hljs-string">"Call by reference"</span> &lt;&lt; endl;
    <span class="hljs-built_in">g</span>(<span class="hljs-built_in">B</span>());
    cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">"Call by copy"</span> &lt;&lt; endl;
    <span class="hljs-built_in">h</span>(<span class="hljs-built_in">B</span>());
}
</code></pre>

<p>The output is:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">Call by reference
I am a <span class="hljs-string">'B'</span>

Call by copy
<span class="hljs-string">'A'</span> copy constructor
I am an <span class="hljs-string">'A'</span>
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Third match in google for "C++ slicing" gives me this Wikipedia article <a href="http://en.wikipedia.org/wiki/Object_slicing" rel="noreferrer">http://en.wikipedia.org/wiki/Object_slicing</a> and this (heated, but the first few posts define the problem) : <a href="http://bytes.com/forum/thread163565.html" rel="noreferrer">http://bytes.com/forum/thread163565.html</a></p>

<p>So it's when you assign an object of a subclass to the super class. The superclass knows nothing of the additional information in the subclass, and hasn't got room to store it, so the additional information gets "sliced off".</p>

<p>If those links don't give enough info for a "good answer" please edit your question to let us know what more you're looking for.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The slicing problem is serious because it can result in memory corruption, and it is very difficult to guarantee a program does not suffer from it. To design it out of the language, classes that support inheritance should be accessible by reference only (not by value). The D programming language has this property.</p>

<p>Consider class A, and class B derived from A. Memory corruption can happen if the A part has a pointer p, and a B instance that points p to B's additional data. Then, when the additional data gets sliced off, p is pointing to garbage.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In C++, a derived class object can be assigned to a base class object, but the other way is not possible.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> { <span class="hljs-type">int</span> x, y; };

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base { <span class="hljs-type">int</span> z, w; };

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> 
</span>{
    Derived d;
    Base b = d; <span class="hljs-comment">// Object Slicing,  z and w of d are sliced off</span>
}
</code></pre>

<p>Object slicing happens when a derived class object is assigned to a base class object, additional attributes of a derived class object are sliced off to form the base class object.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I see all the answers mention when object slicing happens when data members are sliced. Here I give an example that the methods are not overridden:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Say</span><span class="hljs-params">()</span></span>{
        std::cout&lt;&lt;<span class="hljs-string">"I am A"</span>&lt;&lt;std::endl;
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Say</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>{
        std::cout&lt;&lt;<span class="hljs-string">"I am B"</span>&lt;&lt;std::endl;
    }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
   B b;
   A a1;
   A a2=b;

   b.<span class="hljs-built_in">Say</span>(); <span class="hljs-comment">// I am B</span>
   a1.<span class="hljs-built_in">Say</span>(); <span class="hljs-comment">// I am A</span>
   a2.<span class="hljs-built_in">Say</span>(); <span class="hljs-comment">// I am A   why???</span>
}
</code></pre>
<p>B (object b) is derived from A (object a1 and a2). b and a1, as we expect, call their member function. But from polymorphism viewpoint we dont expect a2, which is assigned by b, to not be overridden. Basically, a2 only saves A-class part of b and that is object slicing in C++.</p>
<p>To solve this problem, a reference or pointer should be used</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"> A&amp; a2=b;
 a2.<span class="hljs-built_in">Say</span>(); <span class="hljs-comment">// I am B</span>
</code></pre>
<p>or</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">A* a2 = &amp;b;
a2-&gt;<span class="hljs-built_in">Say</span>(); <span class="hljs-comment">// I am B</span>
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>So ... Why is losing the derived information bad? ... because the author of the derived class may have changed the representation such that slicing off the extra information changes the value being represented by the object.  This can happen if the derived class if used to cache a representation that is more efficient for certain operations, but expensive to transform back to the base representation.</p>

<p>Also thought someone should also mention what you should do to avoid slicing...
Get a copy of C++ Coding Standards, 101 rules guidlines, and best practices.  Dealing with slicing is #54.</p>

<p>It suggests a somewhat sophisticated pattern to fully deal with the issue:  have a protected copy constructor, a protected pure virtual DoClone, and a public Clone with an assert which will tell you if a (further) derived class failed to implement DoClone correctly.  (The Clone method makes a proper deep copy of the polymorphic object.)</p>

<p>You can also mark the copy constructor on the base explicit which allows for explicit slicing if it is desired.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The slicing problem in C++ arises from the value semantics of its objects, which remained mostly due to compatibility with C structs. You need to use explicit reference or pointer syntax to achieve "normal" object behavior found in most other languages that do objects, i.e., objects are always passed around by reference.</p>

<p>The short answers is that you slice the object by assigning a derived object to a base object <em>by value</em>, i.e. the remaining object is only a part of the derived object. In order to preserve value semantics, slicing is a reasonable behavior and has its relatively rare uses, which doesn't exist in most other languages. Some people consider it a feature of C++, while many considered it one of the quirks/misfeatures of C++.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>1. THE DEFINITION OF SLICING PROBLEM</strong></p>

<p>If D is a derived class of the base class B, then you can assign an object of type Derived to a variable (or parameter) of type Base. </p>

<p><em>EXAMPLE</em></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pet</span>
{
 <span class="hljs-keyword">public</span>:
    string name;
};
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-keyword">public</span> Pet
{
<span class="hljs-keyword">public</span>:
    string breed;
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{   
    Dog dog;
    Pet pet;

    dog.name = <span class="hljs-string">"Tommy"</span>;
    dog.breed = <span class="hljs-string">"Kangal Dog"</span>;
    pet = dog;
    cout &lt;&lt; pet.breed; <span class="hljs-comment">//ERROR</span>
</code></pre>

<p>Although the above assignment is allowed, the value that is assigned to the variable pet loses its breed field. This is called the <strong>slicing problem</strong>.</p>

<p><strong>2. HOW TO FIX THE SLICING PROBLEM</strong></p>

<p>To defeat the problem, we use pointers to dynamic variables.</p>

<p><em>EXAMPLE</em></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">Pet *ptrP;
Dog *ptrD;
ptrD = <span class="hljs-keyword">new</span> Dog;         
ptrD-&gt;name = <span class="hljs-string">"Tommy"</span>;
ptrD-&gt;breed = <span class="hljs-string">"Kangal Dog"</span>;
ptrP = ptrD;
cout &lt;&lt; ((Dog *)ptrP)-&gt;breed; 
</code></pre>

<p>In this case, none of the data members or member functions of the dynamic variable
being pointed to by ptrD (descendant class object) will be lost. In addition,  if you need to use functions, the function must be a virtual function.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It seems to me, that slicing isn't so much a problem other than when your own classes and program are poorly architected/designed.</p>

<p>If I pass a subclass object in as a parameter to a method, which takes a parameter of type superclass, I should certainly be aware of that and know the internally, the called method will be working with the superclass (aka baseclass) object only.</p>

<p>It seems to me only the unreasonable expectation that providing a subclass where a baseclass is requested, would somehow result in subclass specific results, would cause slicing to be a problem.  Its either poor design in the use of the method or a poor subclass implementation.  I'm guessing its usually the result of sacrificing good OOP design in favor of expediency or performance gains.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>OK, I'll give it a try after reading many posts explaining object slicing but not how it becomes problematic. </p>

<p>The vicious scenario that can result in memory corruption is the following:</p>

<ul>
<li>Class provides (accidentally, possibly compiler-generated) assignment on a polymorphic base class.</li>
<li>Client copies and slices an instance of a derived class.</li>
<li>Client calls a virtual member function that accesses the sliced-off state.</li>
</ul>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Slicing means that the data added by a subclass are discarded when an object of the subclass is passed or returned by value or from a function expecting a base class object.    </p>

<p><strong>Explanation:</strong>
Consider the following class declaration:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">           <span class="hljs-keyword">class</span> <span class="hljs-title class_">baseclass</span>
          {
                 ...
                 baseclass &amp; <span class="hljs-keyword">operator</span> =(<span class="hljs-type">const</span> baseclass&amp;);
                 <span class="hljs-built_in">baseclass</span>(<span class="hljs-type">const</span> baseclass&amp;);
          }
          <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">( )</span>
          </span>{
                baseclass obj1=m;
                obj1=m;
          }
</code></pre>

<p>As baseclass copy functions don't know anything about the derived only the base part of the derived is copied. This is commonly referred to as slicing. </p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> 
{ 
    <span class="hljs-type">int</span> x; 
};  

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> 
{ 
    <span class="hljs-built_in">B</span>( ) : <span class="hljs-built_in">x</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">c</span>(<span class="hljs-string">'a'</span>) { } 
    <span class="hljs-type">int</span> x; 
    <span class="hljs-type">char</span> c; 
};  

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">( )</span> 
</span>{ 
    A a; 
    B b; 
    a = b;     <span class="hljs-comment">// b.c == 'a' is "sliced" off</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; 
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>when a derived class object is assigned to a base class object, additional attributes of a derived class object are sliced off (discard)  form the base class object.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> { 
<span class="hljs-type">int</span> x;
 };

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base { 
 <span class="hljs-type">int</span> z; 
 };

 <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> 
</span>{
Derived d;
Base b = d; <span class="hljs-comment">// Object Slicing,  z of d is sliced off</span>
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>When a Derived class Object is assigned to Base class Object, all the members of derived class object is copied to base class object except the members which are not present in the base class. These members are Sliced away by the compiler.
This is called Object Slicing.</p>

<p><strong>Here is an Example:</strong> </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>
{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-type">int</span> a;
        <span class="hljs-type">int</span> b;
        <span class="hljs-type">int</span> c;
        <span class="hljs-built_in">Base</span>()
        {
            a=<span class="hljs-number">10</span>;
            b=<span class="hljs-number">20</span>;
            c=<span class="hljs-number">30</span>;
        }
};
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base
{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-type">int</span> d;
        <span class="hljs-type">int</span> e;
        <span class="hljs-built_in">Derived</span>()
        {
            d=<span class="hljs-number">40</span>;
            e=<span class="hljs-number">50</span>;
        }
};
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Derived d;
    cout&lt;&lt;d.a&lt;&lt;<span class="hljs-string">"\n"</span>;
    cout&lt;&lt;d.b&lt;&lt;<span class="hljs-string">"\n"</span>;
    cout&lt;&lt;d.c&lt;&lt;<span class="hljs-string">"\n"</span>;
    cout&lt;&lt;d.d&lt;&lt;<span class="hljs-string">"\n"</span>;
    cout&lt;&lt;d.e&lt;&lt;<span class="hljs-string">"\n"</span>;


    Base b = d;
    cout&lt;&lt;b.a&lt;&lt;<span class="hljs-string">"\n"</span>;
    cout&lt;&lt;b.b&lt;&lt;<span class="hljs-string">"\n"</span>;
    cout&lt;&lt;b.c&lt;&lt;<span class="hljs-string">"\n"</span>;
    cout&lt;&lt;b.d&lt;&lt;<span class="hljs-string">"\n"</span>;
    cout&lt;&lt;b.e&lt;&lt;<span class="hljs-string">"\n"</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p><strong>It will generate:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">[Error] <span class="hljs-string">'class Base'</span> has no member named <span class="hljs-string">'d'</span>
[Error] <span class="hljs-string">'class Base'</span> has no member named <span class="hljs-string">'e'</span>
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 18</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I just ran across the slicing problem and promptly landed here. So let me add my two cents to this.</p>

<p>Let's have an example from "production code" (or something that comes kind of close):</p>

<hr>

<p>Let's say we have something that dispatches actions. A control center UI for example.<br>
This UI needs to get a list of things that are currently able to be dispatched. So we define a class that contains the dispatch-information. Let's call it <code>Action</code>. So an <code>Action</code> has some member variables. For simplicity we just have 2, being a <code>std::string name</code> and a <code>std::function&lt;void()&gt; f</code>. Then it has an <code>void activate()</code> which just executes the <code>f</code> member.</p>

<p>So the UI gets a <code>std::vector&lt;Action&gt;</code> supplied. Imagine some functions like:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(Action toAdd)</span></span>;
</code></pre>

<hr>

<p>Now we have established how it looks from the UI's perspective. No problem so far. But some other guy who works on this project suddenly decides that there are specialized actions that need more information in the <code>Action</code> object. For what reason ever. That could also be solved with lambda captures.  This example is not taken 1-1 from the code.</p>

<p>So the guy derives from <code>Action</code> to add his own flavour.<br>
He passes an instance of his home-brewed class to the <code>push_back</code> but then the program goes haywire.</p>

<p>So what happened?<br>
As you <em>might</em> have guessed: the object has been sliced.</p>

<p>The extra information from the instance has been lost, and <code>f</code> is now prone to undefined behaviour.</p>

<hr>

<p>I hope this example brings light about for those people who can't really imagine things when talking about <code>A</code>s and <code>B</code>s being derived in some manner.</p>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;\u0026quot;Slicing\u0026quot; is where you assign an object of a derived class to an instance of a base class, thereby losing part of the information - some of it is \u0026quot;sliced\u0026quot; away.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example, \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt; {\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; foo;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; A {\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; bar;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So an object of type \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; has two data members, \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;bar\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Then if you were to write this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;B b;\n\nA a = b;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Then the information in \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; about member \u0026lt;code\u0026gt;bar\u0026lt;/code\u0026gt; is lost in \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Most answers here fail to explain what the actual problem with slicing is. They only explain the benign cases of slicing, not the treacherous ones. Assume, like the other answers, that you\u0026apos;re dealing with two classes \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;, where \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; derives (publicly) from \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In this situation, C++ lets you pass an instance of \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; to  \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;\u0026apos;s assignment operator (and also to the copy constructor). This works because an instance of \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; can be converted to a \u0026lt;code\u0026gt;const A\u0026amp;amp;\u0026lt;/code\u0026gt;, which is what assignment operators and copy-constructors expect their arguments to be.\u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;The benign case\u0026lt;/h3\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;B b;\nA a = b;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Nothing bad happens there - you asked for an instance of \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; which is a copy of \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;, and that\u0026apos;s exactly what you get. Sure, \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; won\u0026apos;t contain some of \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt;\u0026apos;s members, but how should it? It\u0026apos;s an \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;, after all, not a \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;, so it hasn\u0026apos;t even \u0026lt;em\u0026gt;heard\u0026lt;/em\u0026gt; about these members, let alone would be able to store them.\u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;The treacherous case\u0026lt;/h3\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;B b1;\nB b2;\nA\u0026amp;amp; a_ref = b2;\na_ref = b1;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//b2 now contains a mixture of b1 and b2!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You might think that \u0026lt;code\u0026gt;b2\u0026lt;/code\u0026gt; will be a copy of \u0026lt;code\u0026gt;b1\u0026lt;/code\u0026gt; afterward. But, alas, it\u0026apos;s \u0026lt;strong\u0026gt;not\u0026lt;/strong\u0026gt;! If you inspect it, you\u0026apos;ll discover that \u0026lt;code\u0026gt;b2\u0026lt;/code\u0026gt; is a Frankensteinian creature, made from some chunks of \u0026lt;code\u0026gt;b1\u0026lt;/code\u0026gt; (the chunks that \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; inherits from \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;), and some chunks of \u0026lt;code\u0026gt;b2\u0026lt;/code\u0026gt; (the chunks that only \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; contains). Ouch!\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;What happened? Well, C++ by default doesn\u0026apos;t treat assignment operators as \u0026lt;code\u0026gt;virtual\u0026lt;/code\u0026gt;. Thus, the line \u0026lt;code\u0026gt;a_ref = b1\u0026lt;/code\u0026gt; will call the assignment operator of \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;, not that of \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;. This is because, for non-virtual functions, the \u0026lt;strong\u0026gt;declared\u0026lt;/strong\u0026gt; (formally: \u0026lt;em\u0026gt;static\u0026lt;/em\u0026gt;) type (which is \u0026lt;code\u0026gt;A\u0026amp;amp;\u0026lt;/code\u0026gt;) determines which function is called, as opposed to the \u0026lt;strong\u0026gt;actual\u0026lt;/strong\u0026gt; (formally: \u0026lt;em\u0026gt;dynamic\u0026lt;/em\u0026gt;) type (which would be \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;, since \u0026lt;code\u0026gt;a_ref\u0026lt;/code\u0026gt; references an instance of \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;). Now, \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;\u0026apos;s assignment operator obviously knows only about the members declared in \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;, so it will copy only those, leaving the members added in \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; unchanged.\u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;A solution\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;Assigning only to parts of an object usually makes little sense, yet C++, unfortunately, provides no built-in way to forbid this. You can, however, roll your own. The first step is making the assignment operator \u0026lt;em\u0026gt;virtual\u0026lt;/em\u0026gt;. This will guarantee that it\u0026apos;s always the \u0026lt;strong\u0026gt;actual\u0026lt;/strong\u0026gt; type\u0026apos;s assignment operator which is called, not the \u0026lt;strong\u0026gt;declared\u0026lt;/strong\u0026gt; type\u0026apos;s. The second step is to use \u0026lt;code\u0026gt;dynamic_cast\u0026lt;/code\u0026gt; to verify that the assigned object has a compatible type. The third step is to do the actual assignment in a (protected!) member \u0026lt;code\u0026gt;assign()\u0026lt;/code\u0026gt;, since \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;\u0026apos;s \u0026lt;code\u0026gt;assign()\u0026lt;/code\u0026gt; will probably want to use \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;\u0026apos;s \u0026lt;code\u0026gt;assign()\u0026lt;/code\u0026gt; to copy \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;\u0026apos;s, members.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt; {\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; A\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;= (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; A\u0026amp;amp; a) {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assign\u0026lt;/span\u0026gt;(a);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n  }\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;protected\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;assign\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; A\u0026amp;amp; a)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// copy members of A from a to this\u0026lt;/span\u0026gt;\n  }\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; A {\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; B\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;= (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; A\u0026amp;amp; a) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; B* b = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dynamic_cast\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; B*\u0026amp;gt;(\u0026amp;amp;a))\n      \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assign\u0026lt;/span\u0026gt;(*b);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;bad_assignment\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n  }\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;protected\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;assign\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; B\u0026amp;amp; b)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    A::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assign\u0026lt;/span\u0026gt;(b); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Let A\u0026apos;s assign() copy members of A from b to this\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// copy members of B from b to this\u0026lt;/span\u0026gt;\n  }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that, for pure convenience, \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;\u0026apos;s \u0026lt;code\u0026gt;operator=\u0026lt;/code\u0026gt; covariantly overrides the return type, since it \u0026lt;strong\u0026gt;knows\u0026lt;/strong\u0026gt; that it\u0026apos;s returning an instance of \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If You have a base class \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; and a derived class \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;, then You can do the following.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;wantAnA\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(A myA)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// work with myA\u0026lt;/span\u0026gt;\n}\n\nB derived;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// work with the object \u0026quot;derived\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wantAnA\u0026lt;/span\u0026gt;(derived);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now the method \u0026lt;code\u0026gt;wantAnA\u0026lt;/code\u0026gt; needs a copy of \u0026lt;code\u0026gt;derived\u0026lt;/code\u0026gt;. However, the object \u0026lt;code\u0026gt;derived\u0026lt;/code\u0026gt; cannot be copied completely, as the class \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; could invent additional member variables which are not in its base class \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Therefore, to call \u0026lt;code\u0026gt;wantAnA\u0026lt;/code\u0026gt;, the compiler will \u0026quot;slice off\u0026quot; all additional members of the derived class. The result might be an object you did not want to create, because\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;it may be incomplete,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;it behaves like an \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;-object (all special behaviour of the class \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; is lost).\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;These are all good answers. I would just like to add an execution example when passing objects by value vs by reference:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Base class\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt; {\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;() {}\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; A\u0026amp;amp; a) {\n        cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026apos;A\u0026apos; copy constructor\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl;\n    }\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;run\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;I am an \u0026apos;A\u0026apos;\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl; }\n};\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Derived class\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; A {\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;():\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;() {}\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; B\u0026amp;amp; a):\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;(a) {\n        cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026apos;B\u0026apos; copy constructor\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl;\n    }\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;run\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;I am a \u0026apos;B\u0026apos;\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl; }\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;g\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; A \u0026amp;amp; a)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    a.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;run\u0026lt;/span\u0026gt;();\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;h\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; A a)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    a.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;run\u0026lt;/span\u0026gt;();\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Call by reference\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;g\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;());\n    cout \u0026amp;lt;\u0026amp;lt; endl \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Call by copy\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;h\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;());\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The output is:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;Call by reference\nI am a \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;B\u0026apos;\u0026lt;/span\u0026gt;\n\nCall by copy\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;A\u0026apos;\u0026lt;/span\u0026gt; copy constructor\nI am an \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;A\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Third match in google for \u0026quot;C++ slicing\u0026quot; gives me this Wikipedia article \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Object_slicing\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://en.wikipedia.org/wiki/Object_slicing\u0026lt;/a\u0026gt; and this (heated, but the first few posts define the problem) : \u0026lt;a href=\u0026quot;http://bytes.com/forum/thread163565.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://bytes.com/forum/thread163565.html\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So it\u0026apos;s when you assign an object of a subclass to the super class. The superclass knows nothing of the additional information in the subclass, and hasn\u0026apos;t got room to store it, so the additional information gets \u0026quot;sliced off\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If those links don\u0026apos;t give enough info for a \u0026quot;good answer\u0026quot; please edit your question to let us know what more you\u0026apos;re looking for.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The slicing problem is serious because it can result in memory corruption, and it is very difficult to guarantee a program does not suffer from it. To design it out of the language, classes that support inheritance should be accessible by reference only (not by value). The D programming language has this property.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Consider class A, and class B derived from A. Memory corruption can happen if the A part has a pointer p, and a B instance that points p to B\u0026apos;s additional data. Then, when the additional data gets sliced off, p is pointing to garbage.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In C++, a derived class object can be assigned to a base class object, but the other way is not possible.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Base\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x, y; };\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Derived\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Base { \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; z, w; };\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \n\u0026lt;/span\u0026gt;{\n    Derived d;\n    Base b = d; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Object Slicing,  z and w of d are sliced off\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Object slicing happens when a derived class object is assigned to a base class object, additional attributes of a derived class object are sliced off to form the base class object.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I see all the answers mention when object slicing happens when data members are sliced. Here I give an example that the methods are not overridden:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Say\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{\n        std::cout\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;I am A\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;lt;std::endl;\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; A{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Say\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;override\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{\n        std::cout\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;I am B\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;lt;std::endl;\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{\n   B b;\n   A a1;\n   A a2=b;\n\n   b.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Say\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// I am B\u0026lt;/span\u0026gt;\n   a1.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Say\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// I am A\u0026lt;/span\u0026gt;\n   a2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Say\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// I am A   why???\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;B (object b) is derived from A (object a1 and a2). b and a1, as we expect, call their member function. But from polymorphism viewpoint we dont expect a2, which is assigned by b, to not be overridden. Basically, a2 only saves A-class part of b and that is object slicing in C++.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;To solve this problem, a reference or pointer should be used\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt; A\u0026amp;amp; a2=b;\n a2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Say\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// I am B\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;or\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;A* a2 = \u0026amp;amp;b;\na2-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Say\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// I am B\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;So ... Why is losing the derived information bad? ... because the author of the derived class may have changed the representation such that slicing off the extra information changes the value being represented by the object.  This can happen if the derived class if used to cache a representation that is more efficient for certain operations, but expensive to transform back to the base representation.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Also thought someone should also mention what you should do to avoid slicing...\nGet a copy of C++ Coding Standards, 101 rules guidlines, and best practices.  Dealing with slicing is #54.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It suggests a somewhat sophisticated pattern to fully deal with the issue:  have a protected copy constructor, a protected pure virtual DoClone, and a public Clone with an assert which will tell you if a (further) derived class failed to implement DoClone correctly.  (The Clone method makes a proper deep copy of the polymorphic object.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can also mark the copy constructor on the base explicit which allows for explicit slicing if it is desired.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The slicing problem in C++ arises from the value semantics of its objects, which remained mostly due to compatibility with C structs. You need to use explicit reference or pointer syntax to achieve \u0026quot;normal\u0026quot; object behavior found in most other languages that do objects, i.e., objects are always passed around by reference.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The short answers is that you slice the object by assigning a derived object to a base object \u0026lt;em\u0026gt;by value\u0026lt;/em\u0026gt;, i.e. the remaining object is only a part of the derived object. In order to preserve value semantics, slicing is a reasonable behavior and has its relatively rare uses, which doesn\u0026apos;t exist in most other languages. Some people consider it a feature of C++, while many considered it one of the quirks/misfeatures of C++.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;1. THE DEFINITION OF SLICING PROBLEM\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If D is a derived class of the base class B, then you can assign an object of type Derived to a variable (or parameter) of type Base. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;EXAMPLE\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Pet\u0026lt;/span\u0026gt;\n{\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    string name;\n};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Pet\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    string breed;\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{   \n    Dog dog;\n    Pet pet;\n\n    dog.name = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Tommy\u0026quot;\u0026lt;/span\u0026gt;;\n    dog.breed = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Kangal Dog\u0026quot;\u0026lt;/span\u0026gt;;\n    pet = dog;\n    cout \u0026amp;lt;\u0026amp;lt; pet.breed; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//ERROR\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Although the above assignment is allowed, the value that is assigned to the variable pet loses its breed field. This is called the \u0026lt;strong\u0026gt;slicing problem\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;2. HOW TO FIX THE SLICING PROBLEM\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To defeat the problem, we use pointers to dynamic variables.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;EXAMPLE\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;Pet *ptrP;\nDog *ptrD;\nptrD = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Dog;         \nptrD-\u0026amp;gt;name = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Tommy\u0026quot;\u0026lt;/span\u0026gt;;\nptrD-\u0026amp;gt;breed = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Kangal Dog\u0026quot;\u0026lt;/span\u0026gt;;\nptrP = ptrD;\ncout \u0026amp;lt;\u0026amp;lt; ((Dog *)ptrP)-\u0026amp;gt;breed; \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In this case, none of the data members or member functions of the dynamic variable\nbeing pointed to by ptrD (descendant class object) will be lost. In addition,  if you need to use functions, the function must be a virtual function.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It seems to me, that slicing isn\u0026apos;t so much a problem other than when your own classes and program are poorly architected/designed.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If I pass a subclass object in as a parameter to a method, which takes a parameter of type superclass, I should certainly be aware of that and know the internally, the called method will be working with the superclass (aka baseclass) object only.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It seems to me only the unreasonable expectation that providing a subclass where a baseclass is requested, would somehow result in subclass specific results, would cause slicing to be a problem.  Its either poor design in the use of the method or a poor subclass implementation.  I\u0026apos;m guessing its usually the result of sacrificing good OOP design in favor of expediency or performance gains.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;OK, I\u0026apos;ll give it a try after reading many posts explaining object slicing but not how it becomes problematic. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The vicious scenario that can result in memory corruption is the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Class provides (accidentally, possibly compiler-generated) assignment on a polymorphic base class.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Client copies and slices an instance of a derived class.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Client calls a virtual member function that accesses the sliced-off state.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Slicing means that the data added by a subclass are discarded when an object of the subclass is passed or returned by value or from a function expecting a base class object.    \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Explanation:\u0026lt;/strong\u0026gt;\nConsider the following class declaration:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;           \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;baseclass\u0026lt;/span\u0026gt;\n          {\n                 ...\n                 baseclass \u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; =(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; baseclass\u0026amp;amp;);\n                 \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;baseclass\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; baseclass\u0026amp;amp;);\n          }\n          \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( )\u0026lt;/span\u0026gt;\n          \u0026lt;/span\u0026gt;{\n                baseclass obj1=m;\n                obj1=m;\n          }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;As baseclass copy functions don\u0026apos;t know anything about the derived only the base part of the derived is copied. This is commonly referred to as slicing. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt; \n{ \n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x; \n};  \n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt; \n{ \n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;( ) : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;) { } \n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x; \n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; c; \n};  \n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( )\u0026lt;/span\u0026gt; \n\u0026lt;/span\u0026gt;{ \n    A a; \n    B b; \n    a = b;     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// b.c == \u0026apos;a\u0026apos; is \u0026quot;sliced\u0026quot; off\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; \n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;when a derived class object is assigned to a base class object, additional attributes of a derived class object are sliced off (discard)  form the base class object.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Base\u0026lt;/span\u0026gt; { \n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x;\n };\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Derived\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Base { \n \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; z; \n };\n\n \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \n\u0026lt;/span\u0026gt;{\nDerived d;\nBase b = d; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Object Slicing,  z of d is sliced off\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;When a Derived class Object is assigned to Base class Object, all the members of derived class object is copied to base class object except the members which are not present in the base class. These members are Sliced away by the compiler.\nThis is called Object Slicing.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Here is an Example:\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;bits/stdc++.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Base\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a;\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; b;\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; c;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Base\u0026lt;/span\u0026gt;()\n        {\n            a=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;;\n            b=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt;;\n            c=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;30\u0026lt;/span\u0026gt;;\n        }\n};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Derived\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Base\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; d;\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; e;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Derived\u0026lt;/span\u0026gt;()\n        {\n            d=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;40\u0026lt;/span\u0026gt;;\n            e=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;50\u0026lt;/span\u0026gt;;\n        }\n};\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    Derived d;\n    cout\u0026amp;lt;\u0026amp;lt;d.a\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    cout\u0026amp;lt;\u0026amp;lt;d.b\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    cout\u0026amp;lt;\u0026amp;lt;d.c\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    cout\u0026amp;lt;\u0026amp;lt;d.d\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    cout\u0026amp;lt;\u0026amp;lt;d.e\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n\n\n    Base b = d;\n    cout\u0026amp;lt;\u0026amp;lt;b.a\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    cout\u0026amp;lt;\u0026amp;lt;b.b\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    cout\u0026amp;lt;\u0026amp;lt;b.c\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    cout\u0026amp;lt;\u0026amp;lt;b.d\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    cout\u0026amp;lt;\u0026amp;lt;b.e\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;It will generate:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;[Error] \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;class Base\u0026apos;\u0026lt;/span\u0026gt; has no member named \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;d\u0026apos;\u0026lt;/span\u0026gt;\n[Error] \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;class Base\u0026apos;\u0026lt;/span\u0026gt; has no member named \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;e\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I just ran across the slicing problem and promptly landed here. So let me add my two cents to this.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Let\u0026apos;s have an example from \u0026quot;production code\u0026quot; (or something that comes kind of close):\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Let\u0026apos;s say we have something that dispatches actions. A control center UI for example.\u0026lt;br\u0026gt;\nThis UI needs to get a list of things that are currently able to be dispatched. So we define a class that contains the dispatch-information. Let\u0026apos;s call it \u0026lt;code\u0026gt;Action\u0026lt;/code\u0026gt;. So an \u0026lt;code\u0026gt;Action\u0026lt;/code\u0026gt; has some member variables. For simplicity we just have 2, being a \u0026lt;code\u0026gt;std::string name\u0026lt;/code\u0026gt; and a \u0026lt;code\u0026gt;std::function\u0026amp;lt;void()\u0026amp;gt; f\u0026lt;/code\u0026gt;. Then it has an \u0026lt;code\u0026gt;void activate()\u0026lt;/code\u0026gt; which just executes the \u0026lt;code\u0026gt;f\u0026lt;/code\u0026gt; member.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So the UI gets a \u0026lt;code\u0026gt;std::vector\u0026amp;lt;Action\u0026amp;gt;\u0026lt;/code\u0026gt; supplied. Imagine some functions like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Action toAdd)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Now we have established how it looks from the UI\u0026apos;s perspective. No problem so far. But some other guy who works on this project suddenly decides that there are specialized actions that need more information in the \u0026lt;code\u0026gt;Action\u0026lt;/code\u0026gt; object. For what reason ever. That could also be solved with lambda captures.  This example is not taken 1-1 from the code.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So the guy derives from \u0026lt;code\u0026gt;Action\u0026lt;/code\u0026gt; to add his own flavour.\u0026lt;br\u0026gt;\nHe passes an instance of his home-brewed class to the \u0026lt;code\u0026gt;push_back\u0026lt;/code\u0026gt; but then the program goes haywire.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So what happened?\u0026lt;br\u0026gt;\nAs you \u0026lt;em\u0026gt;might\u0026lt;/em\u0026gt; have guessed: the object has been sliced.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The extra information from the instance has been lost, and \u0026lt;code\u0026gt;f\u0026lt;/code\u0026gt; is now prone to undefined behaviour.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;I hope this example brings light about for those people who can\u0026apos;t really imagine things when talking about \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;s and \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;s being derived in some manner.\u0026lt;/p\u0026gt;\n    "],"id":78,"title":"What is object slicing?","content":"\n                \n\u0026lt;p\u0026gt;In c++ what is object slicing and when does it occur?\u0026lt;/p\u0026gt;\n    ","slug":"what-is-object-slicing-1657384506425","postType":"QUESTION","createdAt":"2022-07-09T16:35:06.000Z","updatedAt":"2022-07-09T16:35:06.000Z","tags":[{"id":285,"name":"inheritance","slug":"inheritance","createdAt":"2022-07-09T16:35:06.000Z","updatedAt":"2022-07-09T16:35:06.000Z","Questions_Tags":{"questionId":78,"tagId":285}},{"id":286,"name":"object-slicing","slug":"object-slicing","createdAt":"2022-07-09T16:35:06.000Z","updatedAt":"2022-07-09T16:35:06.000Z","Questions_Tags":{"questionId":78,"tagId":286}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"what-is-object-slicing-1657384506425"},"buildId":"6_hwtyf_oFlFS5l_S4CTe","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>