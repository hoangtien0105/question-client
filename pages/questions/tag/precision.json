{"pageProps":{"data":{"count":1,"rows":[{"answer":["\n&lt;p&gt;In most programming languages, floating point numbers are represented a lot like &lt;a href=&quot;http://en.wikipedia.org/wiki/Scientific_notation&quot; rel=&quot;noreferrer&quot;&gt;scientific notation&lt;/a&gt;: with an exponent and a mantissa (also called the significand). A very simple number, say &lt;code&gt;9.2&lt;/code&gt;, is actually this fraction:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;5179139571476070 * 2&lt;sup&gt; -49&lt;/sup&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Where the exponent is &lt;code&gt;-49&lt;/code&gt; and the mantissa is &lt;code&gt;5179139571476070&lt;/code&gt;. The reason it is impossible to represent &lt;em&gt;some&lt;/em&gt; decimal numbers this way is that both the exponent and the mantissa must be integers. In other words, all floats must be an &lt;em&gt;integer&lt;/em&gt; multiplied by an &lt;em&gt;integer power of 2&lt;/em&gt;. &lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;9.2&lt;/code&gt; may be simply &lt;code&gt;92/10&lt;/code&gt;, but &lt;strong&gt;10&lt;/strong&gt; cannot be expressed as &lt;strong&gt;2&lt;sup&gt;n&lt;/sup&gt;&lt;/strong&gt; if &lt;strong&gt;n&lt;/strong&gt; is limited to integer values.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;h1&gt;Seeing the Data&lt;/h1&gt;\n\n&lt;p&gt;First, a few functions to &lt;em&gt;see&lt;/em&gt; the components that make a 32- and 64-bit &lt;code&gt;float&lt;/code&gt;. Gloss over these if you only care about the output (example in Python):&lt;/p&gt;\n\n&lt;pre class=&quot;lang-python s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;float_to_bin_parts&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;number, bits=&lt;span class=&quot;hljs-number&quot;&gt;64&lt;/span&gt;&lt;/span&gt;):\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; bits == &lt;span class=&quot;hljs-number&quot;&gt;32&lt;/span&gt;:          &lt;span class=&quot;hljs-comment&quot;&gt;# single precision&lt;/span&gt;\n        int_pack      = &lt;span class=&quot;hljs-string&quot;&gt;&apos;I&apos;&lt;/span&gt;\n        float_pack    = &lt;span class=&quot;hljs-string&quot;&gt;&apos;f&apos;&lt;/span&gt;\n        exponent_bits = &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;\n        mantissa_bits = &lt;span class=&quot;hljs-number&quot;&gt;23&lt;/span&gt;\n        exponent_bias = &lt;span class=&quot;hljs-number&quot;&gt;127&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;elif&lt;/span&gt; bits == &lt;span class=&quot;hljs-number&quot;&gt;64&lt;/span&gt;:        &lt;span class=&quot;hljs-comment&quot;&gt;# double precision. all python floats are this&lt;/span&gt;\n        int_pack      = &lt;span class=&quot;hljs-string&quot;&gt;&apos;Q&apos;&lt;/span&gt;\n        float_pack    = &lt;span class=&quot;hljs-string&quot;&gt;&apos;d&apos;&lt;/span&gt;\n        exponent_bits = &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;\n        mantissa_bits = &lt;span class=&quot;hljs-number&quot;&gt;52&lt;/span&gt;\n        exponent_bias = &lt;span class=&quot;hljs-number&quot;&gt;1023&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:\n        &lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; ValueError, &lt;span class=&quot;hljs-string&quot;&gt;&apos;bits argument must be 32 or 64&apos;&lt;/span&gt;\n    bin_iter = &lt;span class=&quot;hljs-built_in&quot;&gt;iter&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;bin&lt;/span&gt;(struct.unpack(int_pack, struct.pack(float_pack, number))[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;])[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;:].rjust(bits, &lt;span class=&quot;hljs-string&quot;&gt;&apos;0&apos;&lt;/span&gt;))\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; [&lt;span class=&quot;hljs-string&quot;&gt;&apos;&apos;&lt;/span&gt;.join(islice(bin_iter, x)) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; (&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, exponent_bits, mantissa_bits)]\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;There&apos;s a lot of complexity behind that function, and it&apos;d be quite the tangent to explain, but if you&apos;re interested, the important resource for our purposes is the &lt;a href=&quot;http://docs.python.org/2/library/struct.html&quot; rel=&quot;noreferrer&quot;&gt;struct&lt;/a&gt; module.&lt;/p&gt;\n\n&lt;p&gt;Python&apos;s &lt;code&gt;float&lt;/code&gt; is a 64-bit, double-precision number. In other languages such as C, C++, Java and C#, double-precision has a separate type &lt;code&gt;double&lt;/code&gt;, which is often implemented as 64 bits.&lt;/p&gt;\n\n&lt;p&gt;When we call that function with our example, &lt;code&gt;9.2&lt;/code&gt;, here&apos;s what we get:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; float_to_bin_parts(9.2)\n[&apos;0&apos;, &apos;10000000010&apos;, &apos;0010011001100110011001100110011001100110011001100110&apos;]\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;hr&gt;\n\n&lt;h1&gt;Interpreting the Data&lt;/h1&gt;\n\n&lt;p&gt;You&apos;ll see I&apos;ve split the return value into three components. These components are:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Sign&lt;/li&gt;\n&lt;li&gt;Exponent&lt;/li&gt;\n&lt;li&gt;Mantissa (also called Significand, or Fraction)&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;h2&gt;Sign&lt;/h2&gt;\n\n&lt;p&gt;The sign is stored in the first component as a single bit. It&apos;s easy to explain: &lt;code&gt;0&lt;/code&gt; means the float is a positive number; &lt;code&gt;1&lt;/code&gt; means it&apos;s negative. Because &lt;code&gt;9.2&lt;/code&gt; is positive, our sign value is &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt;\n\n&lt;h2&gt;Exponent&lt;/h2&gt;\n\n&lt;p&gt;The exponent is stored in the middle component as 11 bits. In our case, &lt;code&gt;0b10000000010&lt;/code&gt;. In decimal, that represents the value &lt;code&gt;1026&lt;/code&gt;. A quirk of this component is that you must subtract a number equal to &lt;strong&gt;2&lt;sup&gt;(# of bits) - 1&lt;/sup&gt; - 1&lt;/strong&gt; to get the true exponent; in our case, that means subtracting  &lt;code&gt;0b1111111111&lt;/code&gt; (decimal number &lt;code&gt;1023&lt;/code&gt;) to get the true exponent, &lt;code&gt;0b00000000011&lt;/code&gt; (decimal number 3).&lt;/p&gt;\n\n&lt;h2&gt;Mantissa&lt;/h2&gt;\n\n&lt;p&gt;The mantissa is stored in the third component as 52 bits. However, there&apos;s a quirk to this component as well. To understand this quirk, consider a number in scientific notation, like this:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;6.0221413x10&lt;sup&gt;23&lt;/sup&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;The mantissa would be the &lt;code&gt;6.0221413&lt;/code&gt;. Recall that the mantissa in scientific notation always begins with a single non-zero digit. The same holds true for binary, except that binary only has two digits: &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;. So the binary mantissa &lt;em&gt;always&lt;/em&gt; starts with &lt;code&gt;1&lt;/code&gt;! When a float is stored, the &lt;code&gt;1&lt;/code&gt; at the front of the binary mantissa is omitted to save space; we have to place it back at the front of our third element to get the &lt;em&gt;true&lt;/em&gt; mantissa:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;1.0010011001100110011001100110011001100110011001100110&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;This involves more than just a simple addition, because the bits stored in our third component actually represent the &lt;em&gt;fractional&lt;/em&gt; part of the mantissa, to the right of the &lt;a href=&quot;http://en.wiktionary.org/wiki/radix_point&quot; rel=&quot;noreferrer&quot;&gt;radix point&lt;/a&gt;. &lt;/p&gt;\n\n&lt;p&gt;When dealing with decimal numbers, we &quot;move the decimal point&quot; by multiplying or dividing by powers of 10. In binary, we can do the same thing by multiplying or dividing by powers of 2. Since our third element has 52 bits, we divide it by &lt;strong&gt;2&lt;sup&gt;52&lt;/sup&gt;&lt;/strong&gt; to move it 52 places to the right:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;0.0010011001100110011001100110011001100110011001100110&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;In decimal notation, that&apos;s the same as dividing &lt;code&gt;675539944105574&lt;/code&gt; by &lt;code&gt;4503599627370496&lt;/code&gt; to get &lt;code&gt;0.1499999999999999&lt;/code&gt;. (This is one example of a ratio that can be expressed exactly in binary, but only approximately in decimal; for more detail, see: &lt;a href=&quot;http://www.wolframalpha.com/input/?i=675539944105574+%2F+4503599627370496&quot; rel=&quot;noreferrer&quot;&gt;675539944105574 / 4503599627370496&lt;/a&gt;.)&lt;/p&gt;\n\n&lt;p&gt;Now that we&apos;ve transformed the third component into a fractional number, adding &lt;code&gt;1&lt;/code&gt; gives the true mantissa.&lt;/p&gt;\n\n&lt;h2&gt;Recapping the Components&lt;/h2&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Sign (first component): &lt;code&gt;0&lt;/code&gt; for positive, &lt;code&gt;1&lt;/code&gt; for negative&lt;/li&gt;\n&lt;li&gt;Exponent (middle component): Subtract &lt;strong&gt;2&lt;sup&gt;(# of bits) - 1&lt;/sup&gt; - 1&lt;/strong&gt; to get the true exponent&lt;/li&gt;\n&lt;li&gt;Mantissa (last component): Divide by &lt;strong&gt;2&lt;sup&gt;(# of bits)&lt;/sup&gt;&lt;/strong&gt; and add &lt;code&gt;1&lt;/code&gt; to get the true mantissa&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;hr&gt;\n\n&lt;h1&gt;Calculating the Number&lt;/h1&gt;\n\n&lt;p&gt;Putting all three parts together, we&apos;re given this binary number:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;1.0010011001100110011001100110011001100110011001100110 x 10&lt;sup&gt;11&lt;/sup&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Which we can then convert from binary to decimal:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;1.1499999999999999 x 2&lt;sup&gt;3&lt;/sup&gt; (inexact!)&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;And multiply to reveal the final representation of the number we started with (&lt;code&gt;9.2&lt;/code&gt;) after being stored as a floating point value:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;9.1999999999999993&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;hr&gt;\n\n&lt;h1&gt;Representing as a Fraction&lt;/h1&gt;\n\n&lt;h2&gt;9.2&lt;/h2&gt;\n\n&lt;p&gt;Now that we&apos;ve built the number, it&apos;s possible to reconstruct it into a simple fraction:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;1.0010011001100110011001100110011001100110011001100110 x 10&lt;sup&gt;11&lt;/sup&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Shift mantissa to a whole number:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;10010011001100110011001100110011001100110011001100110 x 10&lt;sup&gt;11-110100&lt;/sup&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Convert to decimal:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;5179139571476070 x 2&lt;sup&gt;3-52&lt;/sup&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Subtract the exponent:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;5179139571476070 x 2&lt;sup&gt;-49&lt;/sup&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Turn negative exponent into division:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;5179139571476070 / 2&lt;sup&gt;49&lt;/sup&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Multiply exponent:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;5179139571476070 / 562949953421312&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Which equals:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;9.1999999999999993&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;h2&gt;9.5&lt;/h2&gt;\n\n&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; float_to_bin_parts(9.5)\n[&apos;0&apos;, &apos;10000000010&apos;, &apos;0011000000000000000000000000000000000000000000000000&apos;]\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Already you can see the mantissa is only 4 digits followed by a whole lot of zeroes. But let&apos;s go through the paces.&lt;/p&gt;\n\n&lt;p&gt;Assemble the binary scientific notation:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;1.0011 x 10&lt;sup&gt;11&lt;/sup&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Shift the decimal point:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;10011 x 10&lt;sup&gt;11-100&lt;/sup&gt;  &lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Subtract the exponent:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;10011 x 10&lt;sup&gt;-1&lt;/sup&gt;  &lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Binary to decimal:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;19 x 2&lt;sup&gt;-1&lt;/sup&gt;  &lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Negative exponent to division:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;19 / 2&lt;sup&gt;1&lt;/sup&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Multiply exponent:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;19 / 2&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Equals:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;9.5&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;hr&gt;\n\n&lt;hr&gt;\n\n&lt;h1&gt;Further reading&lt;/h1&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;http://floating-point-gui.de/&quot; rel=&quot;noreferrer&quot;&gt;The Floating-Point Guide: What Every Programmer Should Know About Floating-Point Arithmetic, or, Why dont my numbers add up?&lt;/a&gt; (floating-point-gui.de)&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://download.oracle.com/docs/cd/E19957-01/806-3568/ncg_goldberg.html&quot; rel=&quot;noreferrer&quot;&gt;What Every Computer Scientist Should Know About Floating-Point Arithmetic&lt;/a&gt; (Goldberg 1991)&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot; rel=&quot;noreferrer&quot;&gt;IEEE Double-precision floating-point format&lt;/a&gt; (Wikipedia)&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://docs.python.org/3.4/tutorial/floatingpoint.html&quot; rel=&quot;noreferrer&quot;&gt;Floating Point Arithmetic: Issues and Limitations&lt;/a&gt; (docs.python.org)&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://kipirvine.com/asm/workbook/floating_tut.htm&quot; rel=&quot;noreferrer&quot;&gt;Floating Point Binary&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;This isn&apos;t a full answer (&lt;a href=&quot;https://stackoverflow.com/a/21895757/1072468&quot;&gt;mhlester&lt;/a&gt; already covered a lot of good ground I won&apos;t duplicate), but I would like to stress how much the representation of a number depends on the base you are working in.&lt;/p&gt;\n&lt;h2&gt;Consider the fraction 2/3&lt;/h2&gt;\n&lt;p&gt;In good-ol&apos; base 10, we typically write it out as something like&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;0.666...&lt;/li&gt;\n&lt;li&gt;0.666&lt;/li&gt;\n&lt;li&gt;0.667&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;When we look at those representations, we tend to associate each of them with the fraction 2/3, even though only the first representation is mathematically equal to the fraction. The second and third representations/approximations have an error on the order of 0.001, which is actually much worse than the error between 9.2 and 9.1999999999999993. In fact, the second representation isn&apos;t even rounded correctly! &lt;em&gt;Nevertheless, we don&apos;t have a problem with 0.666 as an approximation of the number 2/3, &lt;strong&gt;so we shouldn&apos;t really have a problem with how 9.2 is approximated in most programs&lt;/strong&gt;.&lt;/em&gt; (Yes, in some programs it matters.)&lt;/p&gt;\n&lt;h2&gt;Number bases&lt;/h2&gt;\n&lt;p&gt;So here&apos;s where number bases are crucial. If we were trying to represent 2/3 in base 3, then&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;(2/3)&lt;sub&gt;10&lt;/sub&gt; = 0.2&lt;sub&gt;3&lt;/sub&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;In other words, we have an exact, finite representation for the same number by switching bases! The take-away is that even though you can convert any number to any base, &lt;em&gt;all rational numbers have exact finite representations in some bases but not in others&lt;/em&gt;.&lt;/p&gt;\n&lt;p&gt;To drive this point home, let&apos;s look at 1/2. It might surprise you that even though this perfectly simple number has an exact representation in base 10 and 2, it requires a repeating representation in base 3.&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;(1/2)&lt;sub&gt;10&lt;/sub&gt; = 0.5&lt;sub&gt;10&lt;/sub&gt; = 0.1&lt;sub&gt;2&lt;/sub&gt; = 0.1111...&lt;sub&gt;3&lt;/sub&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2&gt;Why are floating point numbers inaccurate?&lt;/h2&gt;\n&lt;p&gt;Because often-times, they are approximating rationals that cannot be represented finitely in base 2 (the digits repeat), and in general they are approximating real (possibly irrational) numbers which may not be representable in finitely many digits in &lt;em&gt;any&lt;/em&gt; base.&lt;/p&gt;\n    ","\n&lt;p&gt;While all of the other answers are good there is still one thing missing:&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;It is impossible to represent irrational numbers (e.g. Ï€, &lt;code&gt;sqrt(2)&lt;/code&gt;, &lt;code&gt;log(3)&lt;/code&gt;, etc.) precisely!&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;And that actually is why they are called irrational. No amount of bit storage in the world would be enough to hold even one of them. Only &lt;em&gt;symbolic&lt;/em&gt; arithmetic is able to preserve their precision.&lt;/p&gt;\n\n&lt;p&gt;Although if you would limit your math needs to rational numbers only the problem of precision becomes manageable. You would need to store a pair of (possibly very big) integers &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; to hold the number represented by the fraction &lt;code&gt;a/b&lt;/code&gt;. All your arithmetic would have to be done on fractions just like in highschool math (e.g. &lt;code&gt;a/b * c/d = ac/bd&lt;/code&gt;).&lt;/p&gt;\n\n&lt;p&gt;But of course you would still run into the same kind of trouble when &lt;code&gt;pi&lt;/code&gt;, &lt;code&gt;sqrt&lt;/code&gt;, &lt;code&gt;log&lt;/code&gt;, &lt;code&gt;sin&lt;/code&gt;, etc. are involved.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;For hardware accelerated arithmetic only a limited amount of rational numbers can be represented. Every not-representable number is approximated. Some numbers (i.e. irrational) can never be represented no matter the system.&lt;/p&gt;\n    ","\n&lt;p&gt;There are infinitely many real numbers (so many that you can&apos;t enumerate them), and there are infinitely many rational numbers (it is possible to enumerate them).&lt;/p&gt;\n\n&lt;p&gt;The floating-point representation is a finite one (like anything in a computer) so unavoidably many many many numbers are impossible to represent. In particular, 64 bits only allow you to distinguish among only 18,446,744,073,709,551,616 different values (which is nothing compared to infinity). With the standard convention, 9.2 is not one of them. Those that can are of the form m.2^e for some integers m and e.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;You might come up with a different numeration system, 10 based for instance, where 9.2 would have an exact representation. But other numbers, say 1/3, would still be impossible to represent.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;Also note that double-precision floating-points numbers are &lt;em&gt;extremely&lt;/em&gt; accurate. They can represent any number in a very wide range with as much as 15 exact digits. For daily life computations, 4 or 5 digits are more than enough. You will never really need those 15, unless you want to count every millisecond of your lifetime.&lt;/p&gt;\n    ","\n&lt;blockquote&gt;\n  &lt;p&gt;Why can we not represent 9.2 in binary floating point?&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Floating point numbers are (simplifying slightly) a positional numbering system with a restricted number of digits and a movable radix point.&lt;/p&gt;\n\n&lt;p&gt;A fraction can only be expressed exactly using a finite number of digits in a positional numbering system if the prime factors of the denominator (when the fraction is expressed in it&apos;s lowest terms) are factors of the base.&lt;/p&gt;\n\n&lt;p&gt;The prime factors of 10 are 5 and 2, so in base 10 we can represent any fraction of the form a/(2&lt;sup&gt;b&lt;/sup&gt;5&lt;sup&gt;c&lt;/sup&gt;). &lt;/p&gt;\n\n&lt;p&gt;On the other hand the only prime factor of 2 is 2, so in base 2 we can only represent fractions of the form a/(2&lt;sup&gt;b&lt;/sup&gt;)&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Why do computers use this representation?&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Because it&apos;s a simple format to work with and it is sufficiently accurate for most purposes. Basically the same reason scientists use &quot;scientific notation&quot; and round their results to a reasonable number of digits at each step.&lt;/p&gt;\n\n&lt;p&gt;It would certainly be possible to define a fraction format, with (for example) a 32-bit numerator and a 32-bit denominator. It would be able to represent numbers that IEEE double precision floating point could not, but equally there would be many numbers that can be represented in double precision floating point that could not be represented in such a fixed-size fraction format. &lt;/p&gt;\n\n&lt;p&gt;However the big problem is that such a format is a pain to do calculations on. For two reasons.&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;If you want to have exactly one representation of each number then after each calculation you need to reduce the fraction to it&apos;s lowest terms. That means that for every operation you basically need to do a greatest common divisor calculation.&lt;/li&gt;\n&lt;li&gt;If after your calculation you end up with an unrepresentable result because the numerator or denominator you need to find the closest representable result. This is non-trivil.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;Some Languages do offer fraction types, but usually they do it in combination with arbitary precision, this avoids needing to worry about approximating fractions but it creates it&apos;s own problem, when a number passes through a large number of calculation steps the size of the denominator and hence the storage needed for the fraction can explode.&lt;/p&gt;\n\n&lt;p&gt;Some languages also offer decimal floating point types, these are mainly used in scenarios where it is imporant that the results the computer gets match pre-existing rounding rules that were written with humans in mind (chiefly financial calculations). These are slightly more difficult to work with than binary floating point, but the biggest problem is that most computers don&apos;t offer hardware support for them.&lt;/p&gt;\n    "],"id":230,"title":"Why are floating point numbers inaccurate?","slug":"why-are-floating-point-numbers-inaccurate-1657387346111","postType":"QUESTION","createdAt":"2022-07-09T17:22:26.000Z","updatedAt":"2022-07-09T17:22:26.000Z","tags":[{"id":1552,"name":"precision","slug":"precision","createdAt":"2022-07-09T17:22:26.000Z","updatedAt":"2022-07-09T17:22:26.000Z","Questions_Tags":{"questionId":230,"tagId":1552}}]}]}},"__N_SSG":true}