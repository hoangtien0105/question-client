<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2eccd4d47c856f2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2eccd4d47c856f2b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/81-301f760ac8107464.js" defer=""></script><script src="/_next/static/chunks/pages/questions/tag/%5Bslug%5D-6802ea06aeddcbec.js" defer=""></script><script src="/_next/static/6_hwtyf_oFlFS5l_S4CTe/_buildManifest.js" defer=""></script><script src="/_next/static/6_hwtyf_oFlFS5l_S4CTe/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5"></style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="https://flowbite.com/docs/images/logo.svg" class="mr-3 h-6 sm:h-9" alt="Flowbite Logo"/><span class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Hunter</span></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/tag/c-strings#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="flex items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/why-do-i-get-a-segmentation-fault-when-writing-to-a-%22char-*s%22-initialized-with-a-string-literal-but-not-%22char-s%22-1657385511046">Why do I get a segmentation fault when writing to a &quot;char *s&quot; initialized with a string literal, but not &quot;char s[]&quot;?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/c-strings">c-strings</a></div></div><div class="mt-4 mb-6" style="height:100px;overflow:auto"><h4 class="font-semibold">Solution 1:</h4><div class="text-sm bg-green-100 text-neutral-600">
<p>See the C FAQ, <a href="http://c-faq.com/decl/strlitinit.html" rel="noreferrer">Question 1.32</a></p>

<blockquote>
  <p><strong>Q</strong>: What is the difference between these initializations?<br>
  <code>char a[] = "string literal";</code><br>
  <code>char *p  = "string literal";</code><br>
  My program crashes if I try to assign a new value to <code>p[i]</code>.</p>
  
  <p><strong>A</strong>: A string literal (the formal term
  for a double-quoted string in C
  source) can be used in two slightly
  different ways:</p>
  
  <ol>
  <li>As the initializer for an array of char, as in the declaration of <code>char a[]</code> , it specifies the initial values
  of the characters in that array (and,
  if necessary, its size).</li>
  <li>Anywhere else, it turns into an unnamed, static array of characters,
  and this unnamed array may be stored
  in read-only memory, and which
  therefore cannot necessarily be
  modified. In an expression context,
  the array is converted at once to a
  pointer, as usual (see section 6), so
  the second declaration initializes p
  to point to the unnamed array's first
  element. </li>
  </ol>
  
  <p>Some compilers have a switch
  controlling whether string literals
  are writable or not (for compiling old
  code), and some may have options to
  cause string literals to be formally
  treated as arrays of const char (for
  better error catching).</p>
</blockquote>
    </div></div><div><div class="flex items-center justify-between text-slate-500"><div class="flex space-x-4 md:space-x-8"><div class="flex cursor-pointer items-center transition hover:text-slate-600"><svg xmlns="http://www.w3.org/2000/svg" class="mr-1.5 h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M14 10h4.764a2 2 0 011.789 2.894l-3.5 7A2 2 0 0115.263 21h-4.017c-.163 0-.326-.02-.485-.06L7 20m7-10V5a2 2 0 00-2-2h-.095c-.5 0-.905.405-.905.905 0 .714-.211 1.412-.608 2.006L7 11v9m7-10h-2M7 20H5a2 2 0 01-2-2v-6a2 2 0 012-2h2.5"></path></svg><span>4</span></div></div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"count":1,"rows":[{"answer":["\n\u0026lt;p\u0026gt;See the C FAQ, \u0026lt;a href=\u0026quot;http://c-faq.com/decl/strlitinit.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Question 1.32\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Q\u0026lt;/strong\u0026gt;: What is the difference between these initializations?\u0026lt;br\u0026gt;\n  \u0026lt;code\u0026gt;char a[] = \u0026quot;string literal\u0026quot;;\u0026lt;/code\u0026gt;\u0026lt;br\u0026gt;\n  \u0026lt;code\u0026gt;char *p  = \u0026quot;string literal\u0026quot;;\u0026lt;/code\u0026gt;\u0026lt;br\u0026gt;\n  My program crashes if I try to assign a new value to \u0026lt;code\u0026gt;p[i]\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;A\u0026lt;/strong\u0026gt;: A string literal (the formal term\n  for a double-quoted string in C\n  source) can be used in two slightly\n  different ways:\u0026lt;/p\u0026gt;\n  \n  \u0026lt;ol\u0026gt;\n  \u0026lt;li\u0026gt;As the initializer for an array of char, as in the declaration of \u0026lt;code\u0026gt;char a[]\u0026lt;/code\u0026gt; , it specifies the initial values\n  of the characters in that array (and,\n  if necessary, its size).\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;Anywhere else, it turns into an unnamed, static array of characters,\n  and this unnamed array may be stored\n  in read-only memory, and which\n  therefore cannot necessarily be\n  modified. In an expression context,\n  the array is converted at once to a\n  pointer, as usual (see section 6), so\n  the second declaration initializes p\n  to point to the unnamed array\u0026apos;s first\n  element. \u0026lt;/li\u0026gt;\n  \u0026lt;/ol\u0026gt;\n  \n  \u0026lt;p\u0026gt;Some compilers have a switch\n  controlling whether string literals\n  are writable or not (for compiling old\n  code), and some may have options to\n  cause string literals to be formally\n  treated as arrays of const char (for\n  better error catching).\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Normally, string literals are stored in read-only memory when the program is run. This is to prevent you from accidentally changing a string constant. In your first example, \u0026lt;code\u0026gt;\u0026quot;string\u0026quot;\u0026lt;/code\u0026gt; is stored in read-only memory and \u0026lt;code\u0026gt;*str\u0026lt;/code\u0026gt; points to the first character. The segfault happens when you try to change the first character to \u0026lt;code\u0026gt;\u0026apos;z\u0026apos;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In the second example, the string \u0026lt;code\u0026gt;\u0026quot;string\u0026quot;\u0026lt;/code\u0026gt; is \u0026lt;em\u0026gt;copied\u0026lt;/em\u0026gt; by the compiler from its read-only home to the \u0026lt;code\u0026gt;str[]\u0026lt;/code\u0026gt; array. Then changing the first character is permitted. You can check this by printing the address of each:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%p\u0026quot;\u0026lt;/span\u0026gt;, str);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Also, printing the size of \u0026lt;code\u0026gt;str\u0026lt;/code\u0026gt; in the second example will show you that the compiler has allocated 7 bytes for it:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(str));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Most of these answers are correct, but just to add a little more clarity...\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026quot;read only memory\u0026quot; that people are referring to is the text segment in ASM terms. It\u0026apos;s the same place in memory where the instructions are loaded. This is read-only for obvious reasons like security. When you create a char* initialized to a string, the string data is compiled into the text segment and the program initializes the pointer to point into the text segment. So if you try to change it, kaboom. Segfault.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When written as an array, the compiler places the initialized string data in the data segment instead, which is the same place that your global variables and such live. This memory is mutable, since there are no instructions in the data segment. This time when the compiler initializes the character array (which is still just a char*) it\u0026apos;s pointing into the data segment rather than the text segment, which you can safely alter at run-time.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Why do I get a segmentation fault when writing to a string?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;C99 N1256 draft\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There are two different uses of character string literals:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Initialize \u0026lt;code\u0026gt;char[]\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; c[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;      \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This is \u0026quot;more magic\u0026quot;, and described at 6.7.8/14 \u0026quot;Initialization\u0026quot;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;An array of character type may be initialized by a character string literal, optionally\n  enclosed in braces. Successive characters of the character string literal (including the\n  terminating null character if there is room or if the array is of unknown size) initialize the\n  elements of the array.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;So this is just a shortcut for:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; c[] = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Like any other regular array, \u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt; can be modified.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Everywhere else: it generates an:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;unnamed\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;array of char \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/2245664/what-is-the-type-of-string-literals-in-c-c\u0026quot;\u0026gt;What is the type of string literals in C and C++?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;with static storage\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;that gives UB if modified\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;So when you write:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *c = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This is similar to:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* __unnamed is magic because modifying it gives UB. */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; __unnamed[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *c = __unnamed;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note the implicit cast from \u0026lt;code\u0026gt;char[]\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;char *\u0026lt;/code\u0026gt;, which is always legal.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Then if you modify \u0026lt;code\u0026gt;c[0]\u0026lt;/code\u0026gt;, you also modify \u0026lt;code\u0026gt;__unnamed\u0026lt;/code\u0026gt;, which is UB.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is documented at 6.4.5 \u0026quot;String literals\u0026quot;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;5 In translation phase 7, a byte or code of value zero is appended to each multibyte\n  character sequence that results from a string literal or literals. The multibyte character\n  sequence is then used to initialize an array of static storage duration and length just\n  sufficient to contain the sequence. For character string literals, the array elements have\n  type char, and are initialized with the individual bytes of the multibyte character\n  sequence [...]\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;6 It is unspecified whether these arrays are distinct provided their elements have the\n  appropriate values. If the program attempts to modify such an array, the behavior is\n  undefined.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;6.7.8/32 \u0026quot;Initialization\u0026quot; gives a direct example:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;EXAMPLE 8: The declaration\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;, t[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n  \n  \u0026lt;p\u0026gt;defines \u0026quot;plain\u0026quot; char array objects \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;t\u0026lt;/code\u0026gt; whose elements are initialized with character string literals.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;This declaration is identical to\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[] = { \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt; },\nt[] = { \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt; };\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n  \n  \u0026lt;p\u0026gt;The contents of the arrays are modifiable. On the other hand, the declaration\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *p = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n  \n  \u0026lt;p\u0026gt;defines \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt; with type \u0026quot;pointer to char\u0026quot; and initializes it to point to an object with type \u0026quot;array of char\u0026quot; with length 4 whose elements are initialized with a character string literal. If an attempt is made to use \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt; to modify the contents of the array, the behavior is undefined.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;GCC 4.8 x86-64 ELF implementation\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Program:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%s\\n\u0026quot;\u0026lt;/span\u0026gt;, s);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Compile and decompile:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;gcc -ggdb -\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;=c99 -c main.c\nobjdump -Sr main.o\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Output contains:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;:  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;48\u0026lt;/span\u0026gt; c7 \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;45\u0026lt;/span\u0026gt; f8 \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt;    movq   $\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-0x8\u0026lt;/span\u0026gt;(%rbp)\nf:  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt; \n        c: R_X86_64_32S .rodata\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Conclusion: GCC stores \u0026lt;code\u0026gt;char*\u0026lt;/code\u0026gt; it in \u0026lt;code\u0026gt;.rodata\u0026lt;/code\u0026gt; section, not in \u0026lt;code\u0026gt;.text\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If we do the same for \u0026lt;code\u0026gt;char[]\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;we obtain:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;17\u0026lt;/span\u0026gt;:   c7 \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;45\u0026lt;/span\u0026gt; f0 \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;61\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;62\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;63\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt;    movl   $\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x636261\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-0x10\u0026lt;/span\u0026gt;(%rbp)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;so it gets stored in the stack (relative to \u0026lt;code\u0026gt;%rbp\u0026lt;/code\u0026gt;).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note however that the default linker script puts \u0026lt;code\u0026gt;.rodata\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;.text\u0026lt;/code\u0026gt; in the same segment, which has execute but no write permission. This can be observed with:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;readelf -l a.out\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;which contains:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt; Section to Segment mapping:\n  Segment Sections...\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;02\u0026lt;/span\u0026gt;     .text .rodata\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In the first code, \u0026quot;string\u0026quot; is a string constant, and string constants should never be modified because they are often placed into read only memory.  \u0026quot;str\u0026quot; is a pointer being used to modify the constant.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In the second code, \u0026quot;string\u0026quot; is an array initializer, sort of short hand for\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; str[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;] =  { \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;s\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;t\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;r\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;i\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;n\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;g\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt; };\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026quot;str\u0026quot; is an array allocated on the stack and can be modified freely.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Because the type of \u0026lt;code\u0026gt;\u0026quot;whatever\u0026quot;\u0026lt;/code\u0026gt; in the context of the 1st example is \u0026lt;code\u0026gt;const char *\u0026lt;/code\u0026gt; (even if you assign it to a non-const char*), which means you shouldn\u0026apos;t try and write to it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The compiler has enforced this by putting the string in a read-only part of memory, hence writing to it generates a segfault.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *str = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;string\u0026quot;\u0026lt;/span\u0026gt;;  \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The above sets \u0026lt;code\u0026gt;str\u0026lt;/code\u0026gt; to point to the literal value \u0026lt;code\u0026gt;\u0026quot;string\u0026quot;\u0026lt;/code\u0026gt; which is hard-coded in the program\u0026apos;s binary image, which is probably flagged as read-only in memory.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So \u0026lt;code\u0026gt;str[0]=\u0026lt;/code\u0026gt; is attempting to write to the read-only code of the application.  I would guess this is probably compiler dependent though.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;To understand this error or problem you should first know difference b/w the pointer and array\nso here firstly i have explain you differences b/w them\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;string array\u0026lt;/h3\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; strarray[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In memory array is stored in continuous memory cells, stored as \u0026lt;code\u0026gt;[h][e][l][l][o][\\0] =\u0026amp;gt;[]\u0026lt;/code\u0026gt; is 1 char byte size memory cell ,and this continuous memory cells can be access by name named strarray here.so here string array \u0026lt;code\u0026gt;strarray\u0026lt;/code\u0026gt; itself containing all characters of string initialized to it.in this case here \u0026lt;code\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/code\u0026gt;\nso we can easily change its memory content by accessing each character by its index value\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;`strarray[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;m\u0026apos;\u0026lt;/span\u0026gt;` it access character at index \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; which is \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;h\u0026apos;\u0026lt;/span\u0026gt;in strarray\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;and its value changed to \u0026lt;code\u0026gt;\u0026apos;m\u0026apos;\u0026lt;/code\u0026gt; so strarray value changed to \u0026lt;code\u0026gt;\u0026quot;mello\u0026quot;\u0026lt;/code\u0026gt;;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;one point to note here that we can change the content of string array by changing character by character but can not initialized other string directly to it like \u0026lt;code\u0026gt;strarray=\u0026quot;new string\u0026quot;\u0026lt;/code\u0026gt; is invalid\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Pointer\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;As we all know  pointer points to memory location in memory ,\nuninitialized pointer points to random memory location so and after initialization points to particular memory location\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *ptr = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;here pointer ptr is initialized to string \u0026lt;code\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/code\u0026gt; which is  constant string stored in read only memory (ROM) so \u0026lt;code\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/code\u0026gt; can not be changed as it is stored in ROM\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;and ptr is stored in stack section and pointing to constant string \u0026lt;code\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;so ptr[0]=\u0026apos;m\u0026apos; is invalid since you can not access read only memory\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;But ptr can be initialised to other string value directly since it is just pointer so it can be point to any memory address of variable of its data type\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;ptr=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;new string\u0026quot;\u0026lt;/span\u0026gt;; is valid\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *str = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;string\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;allocates a pointer to a string literal, which the compiler is putting in a non-modifiable part of your executable;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; str[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;string\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;allocates and initializes a local array which is modifiable\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The C FAQ that @matli linked to mentions it, but no one else here has yet, so for clarification: if a string literal (double-quoted string in your source) is used anywhere \u0026lt;em\u0026gt;other than\u0026lt;/em\u0026gt; to initialize a character array (ie: @Mark\u0026apos;s second example, which works correctly), that string is stored by the compiler in a special \u0026lt;em\u0026gt;static string table\u0026lt;/em\u0026gt;, which is akin to creating a global static variable (read-only, of course) that is essentially anonymous (has no variable \u0026quot;name\u0026quot;). The \u0026lt;em\u0026gt;read-only\u0026lt;/em\u0026gt; part is the important part, and is why the @Mark\u0026apos;s first code example segfaults.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *str = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;string\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;line defines a pointer and points it to a literal string.  The literal string is not writable so when you do:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;  str[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;z\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;you get a seg fault.  On some platforms, the literal might be in writable memory so you won\u0026apos;t see a segfault, but it\u0026apos;s invalid code (resulting in undefined behavior) regardless.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The line:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; str[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;string\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;allocates an array of characters and \u0026lt;strong\u0026gt;copies\u0026lt;/strong\u0026gt; the literal string into that array, which is fully writable, so the subsequent update is no problem.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;String literals like \u0026quot;string\u0026quot; are probably allocated in your executable\u0026apos;s address space as read-only data (give or take your compiler).  When you go to touch it, it freaks out that you\u0026apos;re in its bathing suit area and lets you know with a seg fault.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In your first example, you\u0026apos;re getting a pointer to that const data.  In your second example, you\u0026apos;re initializing an array of 7 characters with a copy of the const data.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// create a string constant like this - will be read only\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *str_p;\nstr_p = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;String constant\u0026quot;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// create an array of characters like this \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *arr_p;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; arr[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;String in an array\u0026quot;\u0026lt;/span\u0026gt;;\narr_p = \u0026amp;amp;arr[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;];\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// now we try to change a character in the array first, this will work\u0026lt;/span\u0026gt;\n*arr_p = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;E\u0026apos;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// lets try to change the first character of the string contant\u0026lt;/span\u0026gt;\n*str_p = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;G\u0026apos;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// this will result in a segmentation fault. Comment it out to work.\u0026lt;/span\u0026gt;\n\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*-----------------------------------------------------------------------------\n *  String constants can\u0026apos;t be modified. A segmentation fault is the result,\n *  because most operating systems will not allow a write\n *  operation on read only memory.\n *-----------------------------------------------------------------------------*/\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//print both strings to see if they have changed\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%s\\n\u0026quot;\u0026lt;/span\u0026gt;, str_p); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//print the string without a variable\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%s\\n\u0026quot;\u0026lt;/span\u0026gt;, arr_p); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//print the string, which is in an array. \u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In the first place, \u0026lt;code\u0026gt;str\u0026lt;/code\u0026gt; is a pointer that points at \u0026lt;code\u0026gt;\u0026quot;string\u0026quot;\u0026lt;/code\u0026gt;.  The compiler is allowed to put string literals in places in memory that you cannot write to, but can only read.  (This really should have triggered a warning, since you\u0026apos;re assigning a \u0026lt;code\u0026gt;const char *\u0026lt;/code\u0026gt; to a \u0026lt;code\u0026gt;char *\u0026lt;/code\u0026gt;.  Did you have warnings disabled, or did you just ignore them?)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In the second place, you\u0026apos;re creating an array, which is memory that you\u0026apos;ve got full access to, and initializing it with \u0026lt;code\u0026gt;\u0026quot;string\u0026quot;\u0026lt;/code\u0026gt;.  You\u0026apos;re creating a \u0026lt;code\u0026gt;char[7]\u0026lt;/code\u0026gt; (six for the letters, one for the terminating \u0026apos;\\0\u0026apos;), and you do whatever you like with it.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Assume the strings are,\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; a[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;string literal copied to stack\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *p  = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;string literal referenced by p\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In the first case, the literal is to be copied when \u0026apos;a\u0026apos; comes into scope. Here \u0026apos;a\u0026apos; is an array defined on stack. It means the string will be created on the stack and its data is copied from code (text) memory, which is typically read-only (this is implementation specific, a compiler can place this read-only program data in read-writable memory also).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In the second case, p is a pointer defined on stack (local scope) and referring a string literal (program data or text) stored else where. Usually modifying such memory is not good practice nor encouraged.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h3\u0026gt;Constant memory\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Since string literals are read-only by design, they are stored in the \u0026lt;strong\u0026gt;Constant part\u0026lt;/strong\u0026gt; of memory. Data stored there is immutable, i.e., cannot be changed. Thus, all string literals defined in C code get a read-only memory address here.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Stack memory\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;The \u0026lt;strong\u0026gt;Stack part\u0026lt;/strong\u0026gt; of memory is where the addresses of local variables live, e.g., variables defined in functions.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;As @matli\u0026apos;s answer suggests, there are two ways of working with string these constant strings.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;1. Pointer to string literal\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;When we define a pointer to a string literal, we are creating a pointer variable living in \u0026lt;strong\u0026gt;Stack memory\u0026lt;/strong\u0026gt;. It points to the read-only address where the underlying string literal resides.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; {\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%p\\n\u0026quot;\u0026lt;/span\u0026gt;, \u0026amp;amp;s);  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Prints a read-only address, e.g. 0x7ffc8e224620\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;If we try to modify \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; by inserting\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;H\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;we get a \u0026lt;code\u0026gt;Segmentation fault (core dumped)\u0026lt;/code\u0026gt;. We are trying to access memory that we shouldn\u0026apos;t access. We are attempting to modify the value of a read-only address, \u0026lt;code\u0026gt;0x7ffc8e224620\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;2. Array of chars\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;For the sake of the example, suppose the string literal \u0026lt;code\u0026gt;\u0026quot;Hello\u0026quot;\u0026lt;/code\u0026gt; stored in constant memory has a read-only memory address identical to the one above, \u0026lt;code\u0026gt;0x7ffc8e224620\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; {\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// We create an array from a string literal with address 0x7ffc8e224620.\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// C initializes an array variable in the stack, let\u0026apos;s give it address\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 0x7ffc7a9a9db2.\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// C then copies the read-only value from 0x7ffc8e224620 into \u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 0x7ffc7a9a9db2 to give us a local copy we can mutate.\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; a[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;;\n\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// We can now mutate the local copy\u0026lt;/span\u0026gt;\n  a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;H\u0026apos;\u0026lt;/span\u0026gt;;\n\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%p\\n\u0026quot;\u0026lt;/span\u0026gt;, \u0026amp;amp;a);  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Prints the Stack address, e.g. 0x7ffc7a9a9db2\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%s\\n\u0026quot;\u0026lt;/span\u0026gt;, a);   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Prints \u0026quot;Hello\u0026quot;\u0026lt;/span\u0026gt;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Note:\u0026lt;/strong\u0026gt; When using pointers to string literals as in 1., best practice is to use the \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt; keyword, like \u0026lt;code\u0026gt;const *s = \u0026quot;hello\u0026quot;\u0026lt;/code\u0026gt;. This is more readable and the compiler will provide better help when it\u0026apos;s violated. It will then throw an error like \u0026lt;code\u0026gt;error: assignment of read-only location *s\u0026lt;/code\u0026gt; instead of the seg fault. Linters in editors will also likely pick up the error before you manually compile the code.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;First is one constant string which can\u0026apos;t be modified. Second is an array with initialized value, so it can be modified. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;Section 5.5 Character Pointers and Functions\u0026lt;/code\u0026gt; of \u0026lt;code\u0026gt;K\u0026amp;amp;R\u0026lt;/code\u0026gt; also discusses about this topic:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;There is an important difference between these definitions:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;char amessage[] = \u0026quot;now is the time\u0026quot;; /* an array */\u0026lt;/code\u0026gt;\u0026lt;br\u0026gt;\n\u0026lt;code\u0026gt;char *pmessage = \u0026quot;now is the time\u0026quot;; /* a pointer */\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;amessage\u0026lt;/code\u0026gt; is an array, just big enough to hold the sequence of characters and \u0026lt;code\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/code\u0026gt; that initializes it. Individual characters within the array may be changed but \u0026lt;code\u0026gt;amessage\u0026lt;/code\u0026gt; will always refer to the same storage. On the other hand, \u0026lt;code\u0026gt;pmessage\u0026lt;/code\u0026gt; is a pointer, initialized to point to a string constant; the pointer may subsequently be modified to point elsewhere, but the result is undefined if you try to modify the string contents.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Segmentation fault is caused when you try to access the memory which is inaccessible. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;char *str\u0026lt;/code\u0026gt; is a pointer to a string that is nonmodifiable(the reason for getting segfault).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;whereas \u0026lt;code\u0026gt;char str[]\u0026lt;/code\u0026gt; is an array and can be modifiable..\u0026lt;/p\u0026gt;\n    "],"id":209,"title":"Why do I get a segmentation fault when writing to a \"char *s\" initialized with a string literal, but not \"char s[]\"?","slug":"why-do-i-get-a-segmentation-fault-when-writing-to-a-\"char-*s\"-initialized-with-a-string-literal-but-not-\"char-s\"-1657385511046","postType":"QUESTION","createdAt":"2022-07-09T16:51:51.000Z","updatedAt":"2022-07-09T16:51:51.000Z","tags":[{"id":1467,"name":"c-strings","slug":"c-strings","createdAt":"2022-07-09T16:51:51.000Z","updatedAt":"2022-07-09T16:51:51.000Z","Questions_Tags":{"questionId":209,"tagId":1467}}]}]}},"__N_SSG":true},"page":"/questions/tag/[slug]","query":{"slug":"c-strings"},"buildId":"6_hwtyf_oFlFS5l_S4CTe","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>