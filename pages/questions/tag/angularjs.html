<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2eccd4d47c856f2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2eccd4d47c856f2b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/81-301f760ac8107464.js" defer=""></script><script src="/_next/static/chunks/pages/questions/tag/%5Bslug%5D-6802ea06aeddcbec.js" defer=""></script><script src="/_next/static/6_hwtyf_oFlFS5l_S4CTe/_buildManifest.js" defer=""></script><script src="/_next/static/6_hwtyf_oFlFS5l_S4CTe/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5"></style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="https://flowbite.com/docs/images/logo.svg" class="mr-3 h-6 sm:h-9" alt="Flowbite Logo"/><span class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Hunter</span></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/tag/angularjs#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="flex items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/%22thinking-in-angularjs%22-if-i-have-a-jquery-background-closed-1657384761159">&quot;Thinking in AngularJS&quot; if I have a jQuery background? [closed]</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/angularjs">angularjs</a></div></div><div class="mt-4 mb-6" style="height:100px;overflow:auto"><h4 class="font-semibold">Solution 1:</h4><div class="text-sm bg-green-100 text-neutral-600">
<h1>1. Don't design your page, and then change it with <a href="http://en.wikipedia.org/wiki/Document_Object_Model" rel="noreferrer">DOM</a> manipulations</h1>

<p>In jQuery, you design a page, and then you make it dynamic. This is because jQuery was designed for augmentation and has grown incredibly from that simple premise.</p>

<p>But in AngularJS, you must start from the ground up with your architecture in mind. Instead of starting by thinking "I have this piece of the DOM and I want to make it do X", you have to start with what you want to accomplish, then go about designing your application, and then finally go about designing your view.</p>

<h1>2. Don't augment jQuery with AngularJS</h1>

<p>Similarly, don't start with the idea that jQuery does X, Y, and Z, so I'll just add AngularJS on top of that for models and controllers. This is <em>really</em> tempting when you're just starting out, which is why I always recommend that new AngularJS developers don't use jQuery at all, at least until they get used to doing things the "Angular Way".</p>

<p>I've seen many developers here and on the mailing list create these elaborate solutions with jQuery plugins of 150 or 200 lines of code that they then glue into AngularJS with a collection of callbacks and <code>$apply</code>s that are confusing and convoluted; but they eventually get it working! The problem is that in <strong>most</strong> cases that jQuery plugin could be rewritten in AngularJS in a fraction of the code, where suddenly everything becomes comprehensible and straightforward.</p>

<p>The bottom line is this: when solutioning, first "think in AngularJS"; if you can't think of a solution, ask the community; if after all of that there is no easy solution, <em>then</em> feel free to reach for the jQuery. But don't let jQuery become a crutch or you'll never master AngularJS.</p>

<h1>3. Always think in terms of architecture</h1>

<p>First know that <a href="http://en.wikipedia.org/wiki/Single-page_application" rel="noreferrer">single-page applications</a> are <em>applications</em>. They're <em>not</em> webpages. So we need to think like a server-side developer <em>in addition</em> to thinking like a client-side developer. We have to think about how to divide our application into individual, extensible, testable components.</p>

<p>So then <em>how</em> do you do that? How do you "think in AngularJS"? Here are some general principles, contrasted with jQuery.</p>

<h2>The view is the "official record"</h2>

<p>In jQuery, we programmatically change the view. We could have a dropdown menu defined as a <code>ul</code> like so:</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"main-menu"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"active"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#/home"</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#/menu1"</span>&gt;</span>Menu 1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#/sm1"</span>&gt;</span>Submenu 1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#/sm2"</span>&gt;</span>Submenu 2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#/sm3"</span>&gt;</span>Submenu 3<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#/home"</span>&gt;</span>Menu 2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>

<p>In jQuery, in our application logic, we would activate it with something like:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">$(<span class="hljs-string">'.main-menu'</span>).<span class="hljs-title function_">dropdownMenu</span>();
</code></pre>

<p>When we just look at the view, it's not immediately obvious that there is any functionality here. For small applications, that's fine. But for non-trivial applications, things quickly get confusing and hard to maintain.</p>

<p>In AngularJS, though, the view is the official record of view-based functionality. Our <code>ul</code> declaration would look like this instead:</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"main-menu"</span> <span class="hljs-attr">dropdown-menu</span>&gt;</span>
    ...
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>

<p>These two do the same thing, but in the AngularJS version anyone looking at the template knows what's supposed to happen. Whenever a new member of the development team comes on board, she can look at this and then <em>know</em> that there is a directive called <code>dropdownMenu</code> operating on it; she doesn't need to intuit the right answer or sift through any code. The view told us what was supposed to happen. Much cleaner.</p>

<p>Developers new to AngularJS often ask a question like: how do I find all links of a specific kind and add a directive onto them. The developer is always flabbergasted when we reply: you don't. But the reason you don't do that is that this is like half-jQuery, half-AngularJS, and no good. The problem here is that the developer is trying to "do jQuery" in the context of AngularJS. That's never going to work well. The view <em>is</em> the official record. Outside of a directive (more on this below), you never, ever, <em>never</em> change the DOM. And directives are applied <em>in the view</em>, so intent is clear.</p>

<p>Remember: don't design, and then mark up. You must architect, and then design.</p>

<h2>Data binding</h2>

<p>This is by far one of the most awesome features of AngularJS and cuts out a lot of the need to do the kinds of DOM manipulations I mentioned in the previous section. AngularJS will automatically update your view so you don't have to! In jQuery, we respond to events and then update content. Something like:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">$.<span class="hljs-title function_">ajax</span>({
  <span class="hljs-attr">url</span>: <span class="hljs-string">'/myEndpoint.json'</span>,
  <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"> data, status </span>) {
    $(<span class="hljs-string">'ul#log'</span>).<span class="hljs-title function_">append</span>(<span class="hljs-string">'&lt;li&gt;Data Received!&lt;/li&gt;'</span>);
  }
});
</code></pre>

<p>For a view that looks like this:</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"messages"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"log"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>

<p>Apart from mixing concerns, we also have the same problems of signifying intent that I mentioned before. But more importantly, we had to manually reference and update a DOM node. And if we want to delete a log entry, we have to code against the DOM for that too. How do we test the logic apart from the DOM? And what if we want to change the presentation?</p>

<p>This a little messy and a trifle frail. But in AngularJS, we can do this:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">$http( <span class="hljs-string">'/myEndpoint.json'</span> ).<span class="hljs-title function_">then</span>( <span class="hljs-keyword">function</span> (<span class="hljs-params"> response </span>) {
    $scope.<span class="hljs-property">log</span>.<span class="hljs-title function_">push</span>( { <span class="hljs-attr">msg</span>: <span class="hljs-string">'Data Received!'</span> } );
});
</code></pre>

<p>And our view can look like this:</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"messages"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">ng-repeat</span>=<span class="hljs-string">"entry in log"</span>&gt;</span>{{ entry.msg }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>

<p>But for that matter, our view could look like this:</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"messages"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"alert"</span> <span class="hljs-attr">ng-repeat</span>=<span class="hljs-string">"entry in log"</span>&gt;</span>
        {{ entry.msg }}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>

<p>And now instead of using an unordered list, we're using Bootstrap alert boxes. And we never had to change the controller code! But more importantly, no matter <em>where</em> or <em>how</em> the log gets updated, the view will change too. Automatically. Neat!</p>

<p>Though I didn't show it here, the data binding is two-way. So those log messages could also be editable in the view just by doing this: <code>&lt;input ng-model="entry.msg" /&gt;</code>. And there was much rejoicing.</p>

<h2>Distinct model layer</h2>

<p>In jQuery, the DOM is kind of like the model. But in AngularJS, we have a separate model layer that we can manage in any way we want, completely independently from the view. This helps for the above data binding, maintains <a href="http://en.wikipedia.org/wiki/Separation_of_concerns" rel="noreferrer">separation of concerns</a>, and introduces far greater testability. Other answers mentioned this point, so I'll just leave it at that.</p>

<h2>Separation of concerns</h2>

<p>And all of the above tie into this over-arching theme: keep your concerns separate. Your view acts as the official record of what is supposed to happen (for the most part); your model represents your data; you have a service layer to perform reusable tasks; you do DOM manipulation and augment your view with directives; and you glue it all together with controllers. This was also mentioned in other answers, and the only thing I would add pertains to testability, which I discuss in another section below.</p>

<h2>Dependency injection</h2>

<p>To help us out with separation of concerns is <a href="http://en.wikipedia.org/wiki/Dependency_injection" rel="noreferrer">dependency injection</a> (DI). If you come from a server-side language (from <a href="http://en.wikipedia.org/wiki/Java_%28programming_language%29" rel="noreferrer">Java</a> to <a href="http://en.wikipedia.org/wiki/PHP" rel="noreferrer">PHP</a>) you're probably familiar with this concept already, but if you're a client-side guy coming from jQuery, this concept can seem anything from silly to superfluous to hipster. But it's not. :-)</p>

<p>From a broad perspective, DI means that you can declare components very freely and then from any other component, just ask for an instance of it and it will be granted. You don't have to know about loading order, or file locations, or anything like that. The power may not immediately be visible, but I'll provide just one (common) example: testing.</p>

<p>Let's say in our application, we require a service that implements server-side storage through a <a href="http://en.wikipedia.org/wiki/Representational_State_Transfer" rel="noreferrer">REST</a> API and, depending on application state, local storage as well. When running tests on our controllers, we don't want to have to communicate with the server - we're testing the <em>controller</em>, after all. We can just add a mock service of the same name as our original component, and the injector will ensure that our controller gets the fake one automatically - our controller doesn't and needn't know the difference.</p>

<p>Speaking of testing...</p>

<h1>4. Test-driven development - <em>always</em></h1>

<p>This is really part of section 3 on architecture, but it's so important that I'm putting it as its own top-level section.</p>

<p>Out of all of the many jQuery plugins you've seen, used, or written, how many of them had an accompanying test suite? Not very many because jQuery isn't very amenable to that. But AngularJS is.</p>

<p>In jQuery, the only way to test is often to create the component independently with a sample/demo page against which our tests can perform DOM manipulation. So then we have to develop a component separately and <em>then</em> integrate it into our application. How inconvenient! So much of the time, when developing with jQuery, we opt for iterative instead of test-driven development. And who could blame us?</p>

<p>But because we have separation of concerns, we can do test-driven development iteratively in AngularJS! For example, let's say we want a super-simple directive to indicate in our menu what our current route is. We can declare what we want in the view of our application:</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/hello"</span> <span class="hljs-attr">when-active</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
</code></pre>

<p>Okay, now we can write a test for the non-existent <code>when-active</code> directive:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-title function_">it</span>( <span class="hljs-string">'should add "active" when the route changes'</span>, <span class="hljs-title function_">inject</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> elm = $compile( <span class="hljs-string">'&lt;a href="/hello" when-active&gt;Hello&lt;/a&gt;'</span> )( $scope );

    $location.<span class="hljs-title function_">path</span>(<span class="hljs-string">'/not-matching'</span>);
    <span class="hljs-title function_">expect</span>( elm.<span class="hljs-title function_">hasClass</span>(<span class="hljs-string">'active'</span>) ).<span class="hljs-title function_">toBeFalsey</span>();

    $location.<span class="hljs-title function_">path</span>( <span class="hljs-string">'/hello'</span> );
    <span class="hljs-title function_">expect</span>( elm.<span class="hljs-title function_">hasClass</span>(<span class="hljs-string">'active'</span>) ).<span class="hljs-title function_">toBeTruthy</span>();
}));
</code></pre>

<p>And when we run our test, we can confirm that it fails. Only now should we create our directive:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">.<span class="hljs-title function_">directive</span>( <span class="hljs-string">'whenActive'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"> $location </span>) {
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">scope</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">link</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"> scope, element, attrs </span>) {
            scope.$on( <span class="hljs-string">'$routeChangeSuccess'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
                <span class="hljs-keyword">if</span> ( $location.<span class="hljs-title function_">path</span>() == element.<span class="hljs-title function_">attr</span>( <span class="hljs-string">'href'</span> ) ) {
                    element.<span class="hljs-title function_">addClass</span>( <span class="hljs-string">'active'</span> );
                }
                <span class="hljs-keyword">else</span> {
                    element.<span class="hljs-title function_">removeClass</span>( <span class="hljs-string">'active'</span> );
                }
            });
        }
    };
});
</code></pre>

<p>Our test now passes <em>and</em> our menu performs as requested. Our development is <em>both</em> iterative <em>and</em> test-driven. Wicked-cool.</p>

<h1>5. Conceptually, directives are <em>not</em> packaged jQuery</h1>

<p>You'll often hear "only do DOM manipulation in a directive". <strong>This is a necessity.</strong> Treat it with due deference!</p>

<p>But let's dive a little deeper...</p>

<p>Some directives just decorate what's already in the view (think <code>ngClass</code>) and therefore sometimes do DOM manipulation straight away and then are basically done. But if a directive is like a "widget" and has a template, it should <em>also</em> respect separation of concerns. That is, the template <em>too</em> should remain largely independent from its implementation in the link and controller functions.</p>

<p>AngularJS comes with an entire set of tools to make this very easy; with <code>ngClass</code> we can dynamically update the class; <code>ngModel</code> allows two-way data binding; <code>ngShow</code> and <code>ngHide</code> programmatically show or hide an element; and many more - including the ones we write ourselves. In other words, we can do all kinds of awesomeness <em>without</em> DOM manipulation. The less DOM manipulation, the easier directives are to test, the easier they are to style, the easier they are to change in the future, and the more re-usable and distributable they are.</p>

<p>I see lots of developers new to AngularJS using directives as the place to throw a bunch of jQuery. In other words, they think "since I can't do DOM manipulation in the controller, I'll take that code put it in a directive". While that certainly is much better, it's often <em>still wrong</em>.</p>

<p>Think of the logger we programmed in section 3. Even if we put that in a directive, we <em>still</em> want to do it the "Angular Way". It <em>still</em> doesn't take any DOM manipulation! There are lots of times when DOM manipulation is necessary, but it's a <em>lot</em> rarer than you think! Before doing DOM manipulation <em>anywhere</em> in your application, ask yourself if you really need to. There might be a better way.</p>

<p>Here's a quick example that shows the pattern I see most frequently. We want a toggleable button. (Note: this example is a little contrived and a skosh verbose to represent more complicated cases that are solved in exactly the same way.)</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">.<span class="hljs-title function_">directive</span>( <span class="hljs-string">'myDirective'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;a class="btn"&gt;Toggle me!&lt;/a&gt;'</span>,
        <span class="hljs-attr">link</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"> scope, element, attrs </span>) {
            <span class="hljs-keyword">var</span> on = <span class="hljs-literal">false</span>;

            $(element).<span class="hljs-title function_">click</span>( <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
                on = !on;
                $(element).<span class="hljs-title function_">toggleClass</span>(<span class="hljs-string">'active'</span>, on);
            });
        }
    };
});
</code></pre>

<p>There are a few things wrong with this:</p>

<ol>
<li>First, jQuery was never necessary. There's nothing we did here that needed jQuery at all!</li>
<li>Second, even if we already have jQuery on our page, there's no reason to use it here; we can simply use <code>angular.element</code> and our component will still work when dropped into a project that doesn't have jQuery.</li>
<li>Third, even assuming jQuery <em>was</em> required for this directive to work, jqLite (<code>angular.element</code>) will <em>always</em> use jQuery if it was loaded! So we needn't use the <code>$</code> - we can just use <code>angular.element</code>.</li>
<li>Fourth, closely related to the third, is that jqLite elements needn't be wrapped in <code>$</code> - the <code>element</code> that is passed to the <code>link</code> function would <em>already be</em> a jQuery element! </li>
<li>And fifth, which we've mentioned in previous sections, why are we mixing template stuff into our logic?</li>
</ol>

<p>This directive can be rewritten (even for very complicated cases!) much more simply like so:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">.<span class="hljs-title function_">directive</span>( <span class="hljs-string">'myDirective'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">scope</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;a class="btn" ng-class="{active: on}" ng-click="toggle()"&gt;Toggle me!&lt;/a&gt;'</span>,
        <span class="hljs-attr">link</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"> scope, element, attrs </span>) {
            scope.<span class="hljs-property">on</span> = <span class="hljs-literal">false</span>;

            scope.<span class="hljs-property">toggle</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
                scope.<span class="hljs-property">on</span> = !scope.<span class="hljs-property">on</span>;
            };
        }
    };
});
</code></pre>

<p>Again, the template stuff is in the template, so you (or your users) can easily swap it out for one that meets any style necessary, and the <strong>logic</strong> never had to be touched. Reusability - boom!</p>

<p>And there are still all those other benefits, like testing - it's easy! No matter what's in the template, the directive's internal API is never touched, so refactoring is easy. You can change the template as much as you want without touching the directive. And no matter what you change, your tests still pass.</p>

<p>w00t!</p>

<p>So if directives aren't just collections of jQuery-like functions, what are they? Directives are actually <strong>extensions of HTML</strong>. If HTML doesn't do something you need it to do, you write a directive to do it for you, and then use it just as if it was part of HTML.</p>

<p>Put another way, if AngularJS doesn't do something out of the box, think how the team would accomplish it to fit right in with <code>ngClick</code>, <code>ngClass</code>, et al.</p>

<h1>Summary</h1>

<p>Don't even use jQuery. Don't even include it. It will hold you back. And when you come to a problem that you think you know how to solve in jQuery already, before you reach for the <code>$</code>, try to think about how to do it within the confines the AngularJS. If you don't know, ask! 19 times out of 20, the best way to do it doesn't need jQuery and to try to solve it with jQuery results in more work for you.</p>
    </div></div><div><div class="flex items-center justify-between text-slate-500"><div class="flex space-x-4 md:space-x-8"><div class="flex cursor-pointer items-center transition hover:text-slate-600"><svg xmlns="http://www.w3.org/2000/svg" class="mr-1.5 h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M14 10h4.764a2 2 0 011.789 2.894l-3.5 7A2 2 0 0115.263 21h-4.017c-.163 0-.326-.02-.485-.06L7 20m7-10V5a2 2 0 00-2-2h-.095c-.5 0-.905.405-.905.905 0 .714-.211 1.412-.608 2.006L7 11v9m7-10h-2M7 20H5a2 2 0 01-2-2v-6a2 2 0 012-2h2.5"></path></svg><span>4</span></div></div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"count":1,"rows":[{"answer":["\n\u0026lt;h1\u0026gt;1. Don\u0026apos;t design your page, and then change it with \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Document_Object_Model\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;DOM\u0026lt;/a\u0026gt; manipulations\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;In jQuery, you design a page, and then you make it dynamic. This is because jQuery was designed for augmentation and has grown incredibly from that simple premise.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But in AngularJS, you must start from the ground up with your architecture in mind. Instead of starting by thinking \u0026quot;I have this piece of the DOM and I want to make it do X\u0026quot;, you have to start with what you want to accomplish, then go about designing your application, and then finally go about designing your view.\u0026lt;/p\u0026gt;\n\n\u0026lt;h1\u0026gt;2. Don\u0026apos;t augment jQuery with AngularJS\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;Similarly, don\u0026apos;t start with the idea that jQuery does X, Y, and Z, so I\u0026apos;ll just add AngularJS on top of that for models and controllers. This is \u0026lt;em\u0026gt;really\u0026lt;/em\u0026gt; tempting when you\u0026apos;re just starting out, which is why I always recommend that new AngularJS developers don\u0026apos;t use jQuery at all, at least until they get used to doing things the \u0026quot;Angular Way\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;ve seen many developers here and on the mailing list create these elaborate solutions with jQuery plugins of 150 or 200 lines of code that they then glue into AngularJS with a collection of callbacks and \u0026lt;code\u0026gt;$apply\u0026lt;/code\u0026gt;s that are confusing and convoluted; but they eventually get it working! The problem is that in \u0026lt;strong\u0026gt;most\u0026lt;/strong\u0026gt; cases that jQuery plugin could be rewritten in AngularJS in a fraction of the code, where suddenly everything becomes comprehensible and straightforward.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The bottom line is this: when solutioning, first \u0026quot;think in AngularJS\u0026quot;; if you can\u0026apos;t think of a solution, ask the community; if after all of that there is no easy solution, \u0026lt;em\u0026gt;then\u0026lt;/em\u0026gt; feel free to reach for the jQuery. But don\u0026apos;t let jQuery become a crutch or you\u0026apos;ll never master AngularJS.\u0026lt;/p\u0026gt;\n\n\u0026lt;h1\u0026gt;3. Always think in terms of architecture\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;First know that \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Single-page_application\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;single-page applications\u0026lt;/a\u0026gt; are \u0026lt;em\u0026gt;applications\u0026lt;/em\u0026gt;. They\u0026apos;re \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; webpages. So we need to think like a server-side developer \u0026lt;em\u0026gt;in addition\u0026lt;/em\u0026gt; to thinking like a client-side developer. We have to think about how to divide our application into individual, extensible, testable components.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So then \u0026lt;em\u0026gt;how\u0026lt;/em\u0026gt; do you do that? How do you \u0026quot;think in AngularJS\u0026quot;? Here are some general principles, contrasted with jQuery.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;The view is the \u0026quot;official record\u0026quot;\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;In jQuery, we programmatically change the view. We could have a dropdown menu defined as a \u0026lt;code\u0026gt;ul\u0026lt;/code\u0026gt; like so:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;main-menu\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;active\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;href\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;#/home\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;Home\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;href\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;#/menu1\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;Menu 1\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;href\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;#/sm1\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;Submenu 1\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;href\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;#/sm2\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;Submenu 2\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;href\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;#/sm3\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;Submenu 3\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;href\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;#/home\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;Menu 2\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In jQuery, in our application logic, we would activate it with something like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;$(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;.main-menu\u0026apos;\u0026lt;/span\u0026gt;).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;dropdownMenu\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;When we just look at the view, it\u0026apos;s not immediately obvious that there is any functionality here. For small applications, that\u0026apos;s fine. But for non-trivial applications, things quickly get confusing and hard to maintain.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In AngularJS, though, the view is the official record of view-based functionality. Our \u0026lt;code\u0026gt;ul\u0026lt;/code\u0026gt; declaration would look like this instead:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;main-menu\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;dropdown-menu\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n    ...\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;These two do the same thing, but in the AngularJS version anyone looking at the template knows what\u0026apos;s supposed to happen. Whenever a new member of the development team comes on board, she can look at this and then \u0026lt;em\u0026gt;know\u0026lt;/em\u0026gt; that there is a directive called \u0026lt;code\u0026gt;dropdownMenu\u0026lt;/code\u0026gt; operating on it; she doesn\u0026apos;t need to intuit the right answer or sift through any code. The view told us what was supposed to happen. Much cleaner.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Developers new to AngularJS often ask a question like: how do I find all links of a specific kind and add a directive onto them. The developer is always flabbergasted when we reply: you don\u0026apos;t. But the reason you don\u0026apos;t do that is that this is like half-jQuery, half-AngularJS, and no good. The problem here is that the developer is trying to \u0026quot;do jQuery\u0026quot; in the context of AngularJS. That\u0026apos;s never going to work well. The view \u0026lt;em\u0026gt;is\u0026lt;/em\u0026gt; the official record. Outside of a directive (more on this below), you never, ever, \u0026lt;em\u0026gt;never\u0026lt;/em\u0026gt; change the DOM. And directives are applied \u0026lt;em\u0026gt;in the view\u0026lt;/em\u0026gt;, so intent is clear.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Remember: don\u0026apos;t design, and then mark up. You must architect, and then design.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Data binding\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;This is by far one of the most awesome features of AngularJS and cuts out a lot of the need to do the kinds of DOM manipulations I mentioned in the previous section. AngularJS will automatically update your view so you don\u0026apos;t have to! In jQuery, we respond to events and then update content. Something like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;$.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;ajax\u0026lt;/span\u0026gt;({\n  \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;url\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;/myEndpoint.json\u0026apos;\u0026lt;/span\u0026gt;,\n  \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;success\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt; data, status \u0026lt;/span\u0026gt;) {\n    $(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;ul#log\u0026apos;\u0026lt;/span\u0026gt;).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;append\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026amp;lt;li\u0026amp;gt;Data Received!\u0026amp;lt;/li\u0026amp;gt;\u0026apos;\u0026lt;/span\u0026gt;);\n  }\n});\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;For a view that looks like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;messages\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;log\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Apart from mixing concerns, we also have the same problems of signifying intent that I mentioned before. But more importantly, we had to manually reference and update a DOM node. And if we want to delete a log entry, we have to code against the DOM for that too. How do we test the logic apart from the DOM? And what if we want to change the presentation?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This a little messy and a trifle frail. But in AngularJS, we can do this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;$http( \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;/myEndpoint.json\u0026apos;\u0026lt;/span\u0026gt; ).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt; response \u0026lt;/span\u0026gt;) {\n    $scope.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;push\u0026lt;/span\u0026gt;( { \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;msg\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Data Received!\u0026apos;\u0026lt;/span\u0026gt; } );\n});\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And our view can look like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;messages\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;ng-repeat\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;entry in log\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;{{ entry.msg }}\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;But for that matter, our view could look like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;messages\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;alert\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;ng-repeat\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;entry in log\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n        {{ entry.msg }}\n    \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And now instead of using an unordered list, we\u0026apos;re using Bootstrap alert boxes. And we never had to change the controller code! But more importantly, no matter \u0026lt;em\u0026gt;where\u0026lt;/em\u0026gt; or \u0026lt;em\u0026gt;how\u0026lt;/em\u0026gt; the log gets updated, the view will change too. Automatically. Neat!\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Though I didn\u0026apos;t show it here, the data binding is two-way. So those log messages could also be editable in the view just by doing this: \u0026lt;code\u0026gt;\u0026amp;lt;input ng-model=\u0026quot;entry.msg\u0026quot; /\u0026amp;gt;\u0026lt;/code\u0026gt;. And there was much rejoicing.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Distinct model layer\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;In jQuery, the DOM is kind of like the model. But in AngularJS, we have a separate model layer that we can manage in any way we want, completely independently from the view. This helps for the above data binding, maintains \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Separation_of_concerns\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;separation of concerns\u0026lt;/a\u0026gt;, and introduces far greater testability. Other answers mentioned this point, so I\u0026apos;ll just leave it at that.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Separation of concerns\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;And all of the above tie into this over-arching theme: keep your concerns separate. Your view acts as the official record of what is supposed to happen (for the most part); your model represents your data; you have a service layer to perform reusable tasks; you do DOM manipulation and augment your view with directives; and you glue it all together with controllers. This was also mentioned in other answers, and the only thing I would add pertains to testability, which I discuss in another section below.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Dependency injection\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;To help us out with separation of concerns is \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Dependency_injection\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;dependency injection\u0026lt;/a\u0026gt; (DI). If you come from a server-side language (from \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Java\u0026lt;/a\u0026gt; to \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/PHP\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;PHP\u0026lt;/a\u0026gt;) you\u0026apos;re probably familiar with this concept already, but if you\u0026apos;re a client-side guy coming from jQuery, this concept can seem anything from silly to superfluous to hipster. But it\u0026apos;s not. :-)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;From a broad perspective, DI means that you can declare components very freely and then from any other component, just ask for an instance of it and it will be granted. You don\u0026apos;t have to know about loading order, or file locations, or anything like that. The power may not immediately be visible, but I\u0026apos;ll provide just one (common) example: testing.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Let\u0026apos;s say in our application, we require a service that implements server-side storage through a \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Representational_State_Transfer\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;REST\u0026lt;/a\u0026gt; API and, depending on application state, local storage as well. When running tests on our controllers, we don\u0026apos;t want to have to communicate with the server - we\u0026apos;re testing the \u0026lt;em\u0026gt;controller\u0026lt;/em\u0026gt;, after all. We can just add a mock service of the same name as our original component, and the injector will ensure that our controller gets the fake one automatically - our controller doesn\u0026apos;t and needn\u0026apos;t know the difference.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Speaking of testing...\u0026lt;/p\u0026gt;\n\n\u0026lt;h1\u0026gt;4. Test-driven development - \u0026lt;em\u0026gt;always\u0026lt;/em\u0026gt;\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;This is really part of section 3 on architecture, but it\u0026apos;s so important that I\u0026apos;m putting it as its own top-level section.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Out of all of the many jQuery plugins you\u0026apos;ve seen, used, or written, how many of them had an accompanying test suite? Not very many because jQuery isn\u0026apos;t very amenable to that. But AngularJS is.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In jQuery, the only way to test is often to create the component independently with a sample/demo page against which our tests can perform DOM manipulation. So then we have to develop a component separately and \u0026lt;em\u0026gt;then\u0026lt;/em\u0026gt; integrate it into our application. How inconvenient! So much of the time, when developing with jQuery, we opt for iterative instead of test-driven development. And who could blame us?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But because we have separation of concerns, we can do test-driven development iteratively in AngularJS! For example, let\u0026apos;s say we want a super-simple directive to indicate in our menu what our current route is. We can declare what we want in the view of our application:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;href\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/hello\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;when-active\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;Hello\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Okay, now we can write a test for the non-existent \u0026lt;code\u0026gt;when-active\u0026lt;/code\u0026gt; directive:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;it\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;should add \u0026quot;active\u0026quot; when the route changes\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;inject\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; elm = $compile( \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026amp;lt;a href=\u0026quot;/hello\u0026quot; when-active\u0026amp;gt;Hello\u0026amp;lt;/a\u0026amp;gt;\u0026apos;\u0026lt;/span\u0026gt; )( $scope );\n\n    $location.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;path\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;/not-matching\u0026apos;\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;expect\u0026lt;/span\u0026gt;( elm.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;hasClass\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;active\u0026apos;\u0026lt;/span\u0026gt;) ).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;toBeFalsey\u0026lt;/span\u0026gt;();\n\n    $location.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;path\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;/hello\u0026apos;\u0026lt;/span\u0026gt; );\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;expect\u0026lt;/span\u0026gt;( elm.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;hasClass\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;active\u0026apos;\u0026lt;/span\u0026gt;) ).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;toBeTruthy\u0026lt;/span\u0026gt;();\n}));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And when we run our test, we can confirm that it fails. Only now should we create our directive:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;directive\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;whenActive\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt; $location \u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;scope\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;,\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;link\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt; scope, element, attrs \u0026lt;/span\u0026gt;) {\n            scope.$on( \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;$routeChangeSuccess\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ( $location.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;path\u0026lt;/span\u0026gt;() == element.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;attr\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;href\u0026apos;\u0026lt;/span\u0026gt; ) ) {\n                    element.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;addClass\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;active\u0026apos;\u0026lt;/span\u0026gt; );\n                }\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n                    element.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;removeClass\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;active\u0026apos;\u0026lt;/span\u0026gt; );\n                }\n            });\n        }\n    };\n});\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Our test now passes \u0026lt;em\u0026gt;and\u0026lt;/em\u0026gt; our menu performs as requested. Our development is \u0026lt;em\u0026gt;both\u0026lt;/em\u0026gt; iterative \u0026lt;em\u0026gt;and\u0026lt;/em\u0026gt; test-driven. Wicked-cool.\u0026lt;/p\u0026gt;\n\n\u0026lt;h1\u0026gt;5. Conceptually, directives are \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; packaged jQuery\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;You\u0026apos;ll often hear \u0026quot;only do DOM manipulation in a directive\u0026quot;. \u0026lt;strong\u0026gt;This is a necessity.\u0026lt;/strong\u0026gt; Treat it with due deference!\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But let\u0026apos;s dive a little deeper...\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Some directives just decorate what\u0026apos;s already in the view (think \u0026lt;code\u0026gt;ngClass\u0026lt;/code\u0026gt;) and therefore sometimes do DOM manipulation straight away and then are basically done. But if a directive is like a \u0026quot;widget\u0026quot; and has a template, it should \u0026lt;em\u0026gt;also\u0026lt;/em\u0026gt; respect separation of concerns. That is, the template \u0026lt;em\u0026gt;too\u0026lt;/em\u0026gt; should remain largely independent from its implementation in the link and controller functions.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;AngularJS comes with an entire set of tools to make this very easy; with \u0026lt;code\u0026gt;ngClass\u0026lt;/code\u0026gt; we can dynamically update the class; \u0026lt;code\u0026gt;ngModel\u0026lt;/code\u0026gt; allows two-way data binding; \u0026lt;code\u0026gt;ngShow\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;ngHide\u0026lt;/code\u0026gt; programmatically show or hide an element; and many more - including the ones we write ourselves. In other words, we can do all kinds of awesomeness \u0026lt;em\u0026gt;without\u0026lt;/em\u0026gt; DOM manipulation. The less DOM manipulation, the easier directives are to test, the easier they are to style, the easier they are to change in the future, and the more re-usable and distributable they are.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I see lots of developers new to AngularJS using directives as the place to throw a bunch of jQuery. In other words, they think \u0026quot;since I can\u0026apos;t do DOM manipulation in the controller, I\u0026apos;ll take that code put it in a directive\u0026quot;. While that certainly is much better, it\u0026apos;s often \u0026lt;em\u0026gt;still wrong\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Think of the logger we programmed in section 3. Even if we put that in a directive, we \u0026lt;em\u0026gt;still\u0026lt;/em\u0026gt; want to do it the \u0026quot;Angular Way\u0026quot;. It \u0026lt;em\u0026gt;still\u0026lt;/em\u0026gt; doesn\u0026apos;t take any DOM manipulation! There are lots of times when DOM manipulation is necessary, but it\u0026apos;s a \u0026lt;em\u0026gt;lot\u0026lt;/em\u0026gt; rarer than you think! Before doing DOM manipulation \u0026lt;em\u0026gt;anywhere\u0026lt;/em\u0026gt; in your application, ask yourself if you really need to. There might be a better way.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here\u0026apos;s a quick example that shows the pattern I see most frequently. We want a toggleable button. (Note: this example is a little contrived and a skosh verbose to represent more complicated cases that are solved in exactly the same way.)\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;directive\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;myDirective\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026amp;lt;a class=\u0026quot;btn\u0026quot;\u0026amp;gt;Toggle me!\u0026amp;lt;/a\u0026amp;gt;\u0026apos;\u0026lt;/span\u0026gt;,\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;link\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt; scope, element, attrs \u0026lt;/span\u0026gt;) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; on = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n\n            $(element).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;click\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n                on = !on;\n                $(element).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;toggleClass\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;active\u0026apos;\u0026lt;/span\u0026gt;, on);\n            });\n        }\n    };\n});\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;There are a few things wrong with this:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;First, jQuery was never necessary. There\u0026apos;s nothing we did here that needed jQuery at all!\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Second, even if we already have jQuery on our page, there\u0026apos;s no reason to use it here; we can simply use \u0026lt;code\u0026gt;angular.element\u0026lt;/code\u0026gt; and our component will still work when dropped into a project that doesn\u0026apos;t have jQuery.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Third, even assuming jQuery \u0026lt;em\u0026gt;was\u0026lt;/em\u0026gt; required for this directive to work, jqLite (\u0026lt;code\u0026gt;angular.element\u0026lt;/code\u0026gt;) will \u0026lt;em\u0026gt;always\u0026lt;/em\u0026gt; use jQuery if it was loaded! So we needn\u0026apos;t use the \u0026lt;code\u0026gt;$\u0026lt;/code\u0026gt; - we can just use \u0026lt;code\u0026gt;angular.element\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Fourth, closely related to the third, is that jqLite elements needn\u0026apos;t be wrapped in \u0026lt;code\u0026gt;$\u0026lt;/code\u0026gt; - the \u0026lt;code\u0026gt;element\u0026lt;/code\u0026gt; that is passed to the \u0026lt;code\u0026gt;link\u0026lt;/code\u0026gt; function would \u0026lt;em\u0026gt;already be\u0026lt;/em\u0026gt; a jQuery element! \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;And fifth, which we\u0026apos;ve mentioned in previous sections, why are we mixing template stuff into our logic?\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;This directive can be rewritten (even for very complicated cases!) much more simply like so:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;directive\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;myDirective\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;scope\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;,\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026amp;lt;a class=\u0026quot;btn\u0026quot; ng-class=\u0026quot;{active: on}\u0026quot; ng-click=\u0026quot;toggle()\u0026quot;\u0026amp;gt;Toggle me!\u0026amp;lt;/a\u0026amp;gt;\u0026apos;\u0026lt;/span\u0026gt;,\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;link\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt; scope, element, attrs \u0026lt;/span\u0026gt;) {\n            scope.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;on\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n\n            scope.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;toggle\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n                scope.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;on\u0026lt;/span\u0026gt; = !scope.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;on\u0026lt;/span\u0026gt;;\n            };\n        }\n    };\n});\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Again, the template stuff is in the template, so you (or your users) can easily swap it out for one that meets any style necessary, and the \u0026lt;strong\u0026gt;logic\u0026lt;/strong\u0026gt; never had to be touched. Reusability - boom!\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;And there are still all those other benefits, like testing - it\u0026apos;s easy! No matter what\u0026apos;s in the template, the directive\u0026apos;s internal API is never touched, so refactoring is easy. You can change the template as much as you want without touching the directive. And no matter what you change, your tests still pass.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;w00t!\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So if directives aren\u0026apos;t just collections of jQuery-like functions, what are they? Directives are actually \u0026lt;strong\u0026gt;extensions of HTML\u0026lt;/strong\u0026gt;. If HTML doesn\u0026apos;t do something you need it to do, you write a directive to do it for you, and then use it just as if it was part of HTML.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Put another way, if AngularJS doesn\u0026apos;t do something out of the box, think how the team would accomplish it to fit right in with \u0026lt;code\u0026gt;ngClick\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;ngClass\u0026lt;/code\u0026gt;, et al.\u0026lt;/p\u0026gt;\n\n\u0026lt;h1\u0026gt;Summary\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;Don\u0026apos;t even use jQuery. Don\u0026apos;t even include it. It will hold you back. And when you come to a problem that you think you know how to solve in jQuery already, before you reach for the \u0026lt;code\u0026gt;$\u0026lt;/code\u0026gt;, try to think about how to do it within the confines the AngularJS. If you don\u0026apos;t know, ask! 19 times out of 20, the best way to do it doesn\u0026apos;t need jQuery and to try to solve it with jQuery results in more work for you.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;Imperative  declarative\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;In jQuery, \u0026lt;em\u0026gt;selectors\u0026lt;/em\u0026gt; are used to find \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Document_Object_Model\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;DOM\u0026lt;/a\u0026gt; elements and then bind/register event handlers to them. When an event triggers, that (imperative) code executes to update/change the DOM.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In AngularJS, you want to think about \u0026lt;strong\u0026gt;views\u0026lt;/strong\u0026gt; rather than DOM elements. Views are (declarative) HTML that contain AngularJS \u0026lt;strong\u0026gt;directives\u0026lt;/strong\u0026gt;. Directives set up the event handlers behind the scenes for us and give us dynamic databinding. Selectors are rarely used, so the need for IDs (and some types of classes) is greatly diminished. Views are tied to \u0026lt;strong\u0026gt;models\u0026lt;/strong\u0026gt; (via scopes). Views are a projection of the model. Events change models (that is, data, scope properties), and the views that project those models update \u0026quot;automatically.\u0026quot;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In AngularJS, think about models, rather than jQuery-selected DOM elements that hold your data. Think about views as projections of those models, rather than registering callbacks to manipulate what the user sees.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Separation of concerns\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;jQuery employs \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Unobtrusive_JavaScript\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;unobtrusive JavaScript\u0026lt;/a\u0026gt; - behavior (JavaScript) is separated from the structure (HTML).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;AngularJS uses \u0026lt;strong\u0026gt;controllers\u0026lt;/strong\u0026gt; and directives (each of which can have their own controller, and/or compile and linking functions) to remove behavior from the view/structure (HTML).  Angular also has \u0026lt;strong\u0026gt;services\u0026lt;/strong\u0026gt; and \u0026lt;strong\u0026gt;filters\u0026lt;/strong\u0026gt; to help separate/organize your application.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;See also \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/14346528/215945\u0026quot;\u0026gt;https://stackoverflow.com/a/14346528/215945\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Application design\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;One approach to designing an AngularJS application:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Think about your models. Create services or your own JavaScript objects for those models.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Think about how you want to present your models -- your views. Create HTML templates for each view, using the necessary directives to get dynamic databinding.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Attach a controller to each view (using ng-view and routing, or ng-controller). Have the controller find/get only whatever model data the view needs to do its job. Make controllers as thin as possible.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;h2\u0026gt;Prototypal inheritance\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;You can do a lot with jQuery without knowing about how JavaScript prototypal inheritance works. When developing AngularJS applications, you will avoid some common pitfalls if you have a good understanding of JavaScript inheritance. Recommended reading: \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/14049480/what-are-the-nuances-of-scope-prototypal-prototypical-inheritance-in-angularjs\u0026quot;\u0026gt;What are the nuances of scope prototypal / prototypical inheritance in AngularJS?\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;AngularJS vs. jQuery\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;AngularJS and jQuery adopt very different ideologies. If you\u0026apos;re coming from jQuery you may find some of the differences surprising. Angular may make you angry.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is normal, you should push through. Angular is worth it.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;The big difference (TLDR)\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;jQuery gives you a toolkit for selecting arbitrary bits of the DOM and making ad-hoc changes to them. You can do pretty much anything you like piece by piece.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;AngularJS instead gives you a \u0026lt;strong\u0026gt;compiler\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;What this means is that AngularJS reads your entire DOM from top to bottom and treats it as code, literally as instructions to the compiler. As it traverses the DOM, It looks for specific \u0026lt;strong\u0026gt;directives\u0026lt;/strong\u0026gt; (compiler directives) that tell the AngularJS compiler how to behave and what to do. Directives are little objects full of JavaScript which can match against attributes, tags, classes or even comments. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When the Angular compiler determines that a piece of the DOM matches a particular directive, it calls the directive function, passing it the DOM element, any attributes, the current $scope (which is a local variable store), and some other useful bits. These attributes may contain expressions which can be interpreted by the Directive, and which tell it how to render, and when it should redraw itself.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Directives can then in turn pull in additional Angular components such as controllers, services, etc. What comes out the bottom of the compiler is a fully formed web application, wired up and ready to go.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;This means that Angular is Template Driven\u0026lt;/strong\u0026gt;. Your template drives the JavaScript, not the other way around. This is a radical reversal of roles, and the complete opposite of the unobtrusive JavaScript we have been writing for the last 10 years or so. This can take some getting used to.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If this sounds like it might be over-prescriptive and limiting, nothing could be farther from the truth. Because AngularJS treats your HTML as code, you get \u0026lt;strong\u0026gt;HTML level granularity in your web application\u0026lt;/strong\u0026gt;. Everything is possible, and most things are surprisingly easy once you make a few conceptual leaps.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Let\u0026apos;s get down to the nitty gritty.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;First up, Angular doesn\u0026apos;t replace jQuery\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Angular and jQuery do different things. AngularJS gives you a set of tools to produce web applications. jQuery mainly gives you tools for modifying the DOM. If jQuery is present on your page, AngularJS will use it automatically. If it isn\u0026apos;t, AngularJS ships with jQuery Lite, which is a cut down, but still perfectly usable version of jQuery.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Misko likes jQuery and doesn\u0026apos;t object to you using it. However you will find as you advance that you can get a pretty much all of your work done using a combination of scope, templates and directives, and you should prefer this workflow where possible because your code will be more discrete, more configurable, and more Angular.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you do use jQuery, you shouldn\u0026apos;t be sprinkling it all over the place. The correct place for DOM manipulation in AngularJS is in a directive. More on these later.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Unobtrusive JavaScript with Selectors vs. Declarative Templates\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;jQuery is typically applied unobtrusively. Your JavaScript code is linked in the header (or the footer), and this is the only place it is mentioned. We use selectors to pick out bits of the page and write plugins to modify those parts.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The JavaScript is in control. The HTML has a completely independent existence. Your HTML remains semantic even without JavaScript. Onclick attributes are very bad practice.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;One of the first things your will notice about AngularJS is that \u0026lt;strong\u0026gt;custom attributes are everywhere\u0026lt;/strong\u0026gt;. Your HTML will be littered with ng attributes, which are essentially onClick attributes on steroids. These are directives (compiler directives), and are one of the main ways in which the template is hooked to the model.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When you first see this you might be tempted to write AngularJS off as old school intrusive JavaScript (like I did at first). In fact, AngularJS does not play by those rules. In AngularJS, your HTML5 is a template. It is compiled by AngularJS to produce your web page.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is the first big difference. To jQuery, your web page is a DOM to be manipulated. To AngularJS, your HTML is code to be compiled. AngularJS reads in your whole web page and literally compiles it into a new web page using its built in compiler.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Your template should be declarative; its meaning should be clear simply by reading it. We use custom attributes with meaningful names. We make up new HTML elements, again with meaningful names. A designer with minimal HTML knowledge and no coding skill can read your AngularJS template and understand what it is doing. He or she can make modifications. \u0026lt;em\u0026gt;This is the Angular way.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;The template is in the driving seat.\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;One of the first questions I asked myself when starting AngularJS and running through the tutorials is \u0026lt;strong\u0026gt;\u0026quot;Where is my code?\u0026quot;\u0026lt;/strong\u0026gt;. I\u0026apos;ve written no JavaScript, and yet I have all this behaviour. The answer is obvious. Because AngularJS compiles the DOM, AngularJS is treating your HTML as code. For many simple cases it\u0026apos;s often sufficient to just write a template and let AngularJS compile it into an application for you.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Your template drives your application. It\u0026apos;s treated as a \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Domain-specific_language\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;DSL\u0026lt;/a\u0026gt;. You write AngularJS components, and AngularJS will take care of pulling them in and making them available at the right time based on the structure of your template. This is very different to a standard \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;MVC\u0026lt;/a\u0026gt; pattern, where the template is just for output.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It\u0026apos;s more similar to \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/XSLT\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;XSLT\u0026lt;/a\u0026gt; than \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Ruby_on_Rails\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Ruby on Rails\u0026lt;/a\u0026gt; for example.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is a radical inversion of control that takes some getting used to.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Stop trying to drive your application from your JavaScript. Let the template drive the application, and let AngularJS take care of wiring the components together. This also is the Angular way.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Semantic HTML vs. Semantic Models\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;With jQuery your HTML page should contain semantic meaningful content. If the JavaScript is turned off (by a user or search engine) your content remains accessible.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Because AngularJS treats your HTML page as a template. The template is not supposed to be semantic as your content is typically stored in your model which ultimately comes from your API. AngularJS compiles your DOM with the model to produce a semantic web page.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Your HTML source is no longer semantic, instead, your API and compiled DOM are semantic.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In AngularJS, meaning lives in the model, the HTML is just a template, for display only.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;At this point you likely have all sorts of questions concerning \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Search_engine_optimization\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;SEO\u0026lt;/a\u0026gt; and accessibility, and rightly so. There are open issues here. Most screen readers will now parse JavaScript. Search engines can also index \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Ajax_%28programming%29\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;AJAXed\u0026lt;/a\u0026gt; content. Nevertheless, you will want to make sure you are using pushstate URLs and you have a decent sitemap. See here for a discussion of the issue: \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/23245379/687677\u0026quot;\u0026gt;https://stackoverflow.com/a/23245379/687677\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Separation of concerns (SOC) vs. MVC\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Separation_of_concerns\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Separation of concerns\u0026lt;/a\u0026gt; (SOC) is a pattern that grew up over many years of web development for a variety of reasons including SEO, accessibility and browser incompatibility. It looks like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;HTML - Semantic meaning. The HTML should stand alone.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;CSS - Styling, without the CSS the page is still readable.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;JavaScript - Behaviour, without the script the content remains.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;Again, AngularJS does not play by their rules. In a stroke, \u0026lt;strong\u0026gt;AngularJS does away with a decade of received wisdom\u0026lt;/strong\u0026gt; and instead implements an MVC pattern in which the template is no longer semantic, not even a little bit.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It looks like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Model - your models contains your semantic data. Models are usually \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/JSON\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;JSON\u0026lt;/a\u0026gt; objects. Models exist as attributes of an object called $scope. You can also store handy utility functions on $scope which your templates can then access.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;View - Your views are written in HTML. The view is usually not semantic because your data lives in the model.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Controller - Your controller is a JavaScript function which hooks the view to the model. Its function is to initialise $scope. Depending on your application, you may or may not need to create a controller. You can have many controllers on a page.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;MVC and SOC are not on opposite ends of the same scale, they are on completely different axes. SOC makes no sense in an AngularJS context. You have to forget it and move on.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If, like me, you lived through the browser wars, you might find this idea quite offensive. Get over it, it\u0026apos;ll be worth it, I promise.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Plugins vs. Directives\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Plugins extend jQuery. AngularJS Directives extend the capabilities of your browser.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In jQuery we define plugins by adding functions to the jQuery.prototype. We then hook these into the DOM by selecting elements and calling the plugin on the result. The idea is to extend the capabilities of jQuery.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example, if you want a carousel on your page, you might define an unordered list of figures, perhaps wrapped in a nav element. You might then write some jQuery to select the list on the page and restyle it as a gallery with timeouts to do the sliding animation.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In AngularJS, we define directives. A directive is a function which returns a JSON object. This object tells AngularJS what DOM elements to look for, and what changes to make to them. Directives are hooked in to the template using either attributes or elements, which you invent. The idea is to extend the capabilities of HTML with new attributes and elements.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;The AngularJS way is to extend the capabilities of native looking HTML.\u0026lt;/em\u0026gt; You should write HTML that looks like HTML, extended with custom attributes and elements.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you want a carousel, just use a \u0026lt;code\u0026gt;\u0026amp;lt;carousel /\u0026amp;gt;\u0026lt;/code\u0026gt; element, then define a directive to pull in a template, and make that sucker work.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Lots of small directives vs. big plugins with configuration switches\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The tendency with jQuery is to write great big plugins like lightbox which we then configure by passing in numerous values and options.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is a mistake in AngularJS.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Take the example of a dropdown. When writing a dropdown plugin you might be tempted to code in click handlers, perhaps a function to add in a chevron which is either up or down, perhaps change the class of the unfolded element, show hide the menu, all helpful stuff.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Until you want to make a small change.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Say you have a menu that you want to unfold on hover. Well now we have a problem. Our plugin has wired in our click handler for us, we\u0026apos;re going to need to add a configuration option to make it behave differently in this specific case.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In AngularJS we write smaller directives. Our dropdown directive would be ridiculously small. It might maintain the folded state, and provide methods to fold(), unfold() or toggle(). These methods would simply update $scope.menu.visible which is a boolean holding the state.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now \u0026lt;strong\u0026gt;in our template\u0026lt;/strong\u0026gt; we can wire this up:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026amp;lt;a ng-click=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toggle()\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Menu\u0026lt;/span\u0026gt;\u0026amp;lt;/a\u0026amp;gt;\n\u0026lt;span class=\u0026quot;language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;ng-show\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;menu.visible\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n  ...\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Need to update on mouseover?\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026amp;lt;a ng-mouseenter=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;unfold()\u0026quot;\u0026lt;/span\u0026gt; ng-mouseleave=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;fold()\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Menu\u0026lt;/span\u0026gt;\u0026amp;lt;/a\u0026amp;gt;\n\u0026lt;span class=\u0026quot;language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;ng-show\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;menu.visible\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n  ...\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The template drives the application so we get HTML level granularity. If we want to make case by case exceptions, the template makes this easy.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Closure vs. $scope\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;JQuery plugins are created in a closure. Privacy is maintained within that closure. It\u0026apos;s up to you to maintain your scope chain within that closure. You only really have access to the set of DOM nodes passed in to the plugin by jQuery, plus any local variables defined in the closure and any globals you have defined. This means that plugins are quite self contained. This is a good thing, but can get restrictive when creating a whole application. Trying to pass data between sections of a dynamic page becomes a chore.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;AngularJS has $scope objects. These are special objects created and maintained by AngularJS in which you store your model. Certain directives will spawn a new $scope, which by default inherits from its wrapping $scope using JavaScript prototypical inheritance. The $scope object is accessible in the controller and the view.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is the clever part. Because the structure of $scope inheritance roughly follows the structure of the DOM, elements have access to their own scope, and any containing scopes seamlessly, all the way up to the global $scope (which is not the same as the global scope).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This makes it much easier to pass data around, and to store data at an appropriate level. If a dropdown is unfolded, only the dropdown $scope needs to know about it. If the user updates their preferences, you might want to update the global $scope, and any nested scopes listening to the user preferences would automatically be alerted.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This might sound complicated, in fact, once you relax into it, it\u0026apos;s like flying. You don\u0026apos;t need to create the $scope object, AngularJS instantiates and configures it for you, correctly and appropriately based on your template hierarchy. AngularJS then makes it available to your component using the magic of dependency injection (more on this later).\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Manual DOM changes vs. Data Binding\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;In jQuery you make all your DOM changes by hand. You construct new DOM elements programatically. If you have a JSON array and you want to put it to the DOM, you must write a function to generate the HTML and insert it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In AngularJS you can do this too, but you are encouraged to make use of data binding. Change your model, and because the DOM is bound to it via a template your DOM will automatically update, no intervention required.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Because data binding is done from the template, using either an attribute or the curly brace syntax, it\u0026apos;s super easy to do. There\u0026apos;s little cognitive overhead associated with it so you\u0026apos;ll find yourself doing it all the time.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026amp;lt;input ng-model=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;user.name\u0026quot;\u0026lt;/span\u0026gt; /\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Binds the input element to \u0026lt;code\u0026gt;$scope.user.name\u0026lt;/code\u0026gt;. Updating the input will update the value in your current scope, and vice-versa.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Likewise:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026amp;lt;p\u0026amp;gt;\n  {{user.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;}}\n\u0026amp;lt;/p\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;will output the user name in a paragraph. It\u0026apos;s a live binding, so if the \u0026lt;code\u0026gt;$scope.user.name\u0026lt;/code\u0026gt; value is updated, the template will update too.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Ajax all of the time\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;In jQuery making an Ajax call is fairly simple, but it\u0026apos;s still something you might think twice about. There\u0026apos;s the added complexity to think about, and a fair chunk of script to maintain.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In AngularJS, Ajax is your default go-to solution and it happens all the time, almost without you noticing. You can include templates with ng-include. You can apply a template with the simplest custom directive. You can wrap an Ajax call in a service and create yourself a \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/GitHub\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;GitHub\u0026lt;/a\u0026gt; service, or a \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Flickr\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Flickr\u0026lt;/a\u0026gt; service, which you can access with astonishing ease.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Service Objects vs Helper Functions\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;In jQuery, if we want to accomplish a small non-dom related task such as pulling a feed from an API, we might write a little function to do that in our closure. That\u0026apos;s a valid solution, but what if we  want to access that feed often? What if we want to reuse that code in another application?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;AngularJS gives us service objects.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Services are simple objects that contain functions and data. They are always singletons, meaning there can never be more than one of them. Say we want to access the Stack Overflow API, we might write a \u0026lt;code\u0026gt;StackOverflowService\u0026lt;/code\u0026gt; which defines methods for doing so.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Let\u0026apos;s say we have a shopping cart. We might define a ShoppingCartService which maintains our cart and contains methods for adding and removing items. Because the service is a singleton, and is shared by all other components, any object that needs to can write to the shopping cart and pull data from it. It\u0026apos;s always the same cart.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Service objects are self-contained AngularJS components which we can use and reuse as we see fit. They are simple JSON objects containing functions and Data. They are always singletons, so if you store data on a service in one place, you can get that data out somewhere else just by requesting the same service.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;\u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Dependency_injection\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Dependency injection\u0026lt;/a\u0026gt; (DI) vs. Instatiation - aka de-spaghettification\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;AngularJS manages your dependencies for you. If you want an object, simply refer to it and AngularJS will get it for you.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Until you start to use this, it\u0026apos;s hard to explain just what a massive time boon this is. Nothing like AngularJS DI exists inside jQuery.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;DI means that instead of writing your application and wiring it together, you instead define a library of components, each identified by a string.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Say I have a component called \u0026apos;FlickrService\u0026apos; which defines methods for pulling JSON feeds from Flickr. Now, if I want to write a controller that can access Flickr, I just need to refer to the \u0026apos;FlickrService\u0026apos; by name when I declare the controller. AngularJS will take care of instantiating the component and making it available to my controller.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example, here I define a service:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;myApp.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;service\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;FlickrService\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;getFeed\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// do something here }\u0026lt;/span\u0026gt;\n  }\n});\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now when I want to use that service I just refer to it by name like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;myApp.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;controller\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;myController\u0026apos;\u0026lt;/span\u0026gt;, [\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;FlickrService\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;FlickrService\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;FlickrService\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getFeed\u0026lt;/span\u0026gt;()\n}]);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;AngularJS will recognise that a FlickrService object is needed to instantiate the controller, and will provide one for us.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This makes wiring things together very easy, and pretty much eliminates any tendency towards spagettification. We have a flat list of components, and AngularJS hands them to us one by one as and when we need them.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Modular service architecture\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;jQuery says very little about how you should organise your code. AngularJS has opinions.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;AngularJS gives you modules into which you can place your code. If you\u0026apos;re writing a script that talks to Flickr for example, you might want to create a Flickr module to wrap all your Flickr related functions in. Modules can include other modules (DI). Your main application is usually a module, and this should include all the other modules your application will depend on.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You get simple code reuse, if you want to write another application based on Flickr, you can just include the Flickr module and voila, you have access to all your Flickr related functions in your new application.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Modules contain AngularJS components. \u0026lt;strong\u0026gt;When we include a module, all the components in that module become available to us as a simple list identified by their unique strings\u0026lt;/strong\u0026gt;. We can then inject those components into each other using AngularJS\u0026apos;s dependency injection mechanism.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;To sum up\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;AngularJS and jQuery are not enemies. It\u0026apos;s possible to use jQuery within AngularJS very nicely. If you\u0026apos;re using AngularJS well (templates, data-binding, $scope, directives, etc.) you will find you need a \u0026lt;strong\u0026gt;lot\u0026lt;/strong\u0026gt; less jQuery than you might otherwise require.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The main thing to realise is that your template drives your application. Stop trying to write big plugins that do everything. Instead write little directives that do one thing, then write a simple template to wire them together.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Think less about unobtrusive JavaScript, and instead think in terms of HTML extensions.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;My little book\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;I got so excited about AngularJS, I wrote a short book on it which you\u0026apos;re very welcome to read online \u0026lt;a href=\u0026quot;http://nicholasjohnson.com/angular-book/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;http://nicholasjohnson.com/angular-book/\u0026lt;/a\u0026gt;. I hope it\u0026apos;s helpful.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Can you describe the paradigm shift that is necessary?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Imperative vs Declarative\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;With \u0026lt;strong\u0026gt;jQuery\u0026lt;/strong\u0026gt; you tell the DOM what needs to happen, step by step. With \u0026lt;strong\u0026gt;\u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/AngularJS\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;AngularJS\u0026lt;/a\u0026gt;\u0026lt;/strong\u0026gt; you describe what results you want but not how to do it. More on this \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/1784664/what-is-the-difference-between-declarative-and-imperative-programming\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt;. Also, check out Mark Rajcok\u0026apos;s answer.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;How do I architect and design client-side web apps differently? \u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;AngularJS is an entire client-side framework that uses the \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;MVC\u0026lt;/a\u0026gt; pattern (check out their \u0026lt;a href=\u0026quot;http://docs.angularjs.org/guide/concepts\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;graphical representation\u0026lt;/a\u0026gt;). It greatly focuses on separation of concerns.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;What is the biggest difference? What should I stop doing/using; what should I start doing/using instead?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;jQuery\u0026lt;/strong\u0026gt; is a library \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;AngularJS\u0026lt;/strong\u0026gt; is a beautiful client-side framework, highly testable, that combines tons of cool stuff such as MVC, \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Dependency_injection\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;dependency injection\u0026lt;/a\u0026gt;, data binding and much more. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It focuses on \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Separation_of_concerns\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;separation of concerns\u0026lt;/a\u0026gt; and testing (\u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Unit_testing\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;unit testing\u0026lt;/a\u0026gt; and end-to-end testing), which facilitates test-driven development.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The best way to start is going through \u0026lt;a href=\u0026quot;http://docs.angularjs.org/tutorial/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;their awesome tutorial\u0026lt;/a\u0026gt;. You can go through the steps in a couple of hours; however, in case you want to master the concepts behind the scenes, they include a myriad of reference for further reading.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Are there any server-side considerations/restrictions?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;You may use it on existing applications where you are already using pure jQuery. However, if you want to fully take advantage of the AngularJS features you may consider coding the server side using a \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_services\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;RESTful\u0026lt;/a\u0026gt; approach.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Doing so will allow you to leverage their \u0026lt;a href=\u0026quot;http://docs.angularjs.org/api/ngResource.$resource\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;resource factory\u0026lt;/a\u0026gt;, which creates an abstraction of your server side RESTful \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Application_programming_interface\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;API\u0026lt;/a\u0026gt; and makes server-side calls (get, save, delete, etc.) incredibly easy.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;To describe the \u0026quot;paradigm shift\u0026quot;, I think a short answer can suffice.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;AngularJS changes the way you \u0026lt;em\u0026gt;find\u0026lt;/em\u0026gt; elements\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;In \u0026lt;strong\u0026gt;jQuery\u0026lt;/strong\u0026gt;, you typically  use \u0026lt;strong\u0026gt;selectors\u0026lt;/strong\u0026gt; to find elements, and then wire them up:\u0026lt;br\u0026gt;\n\u0026lt;code\u0026gt;$(\u0026apos;#id .class\u0026apos;).click(doStuff);\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In \u0026lt;strong\u0026gt;AngularJS\u0026lt;/strong\u0026gt;, you use \u0026lt;strong\u0026gt;directives\u0026lt;/strong\u0026gt; to mark the elements directly, to wire them up:\u0026lt;br\u0026gt;\n\u0026lt;code\u0026gt;\u0026amp;lt;a ng-click=\u0026quot;doStuff()\u0026quot;\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;AngularJS doesn\u0026apos;t need (or want) you to find elements using selectors - the primary difference between AngularJS\u0026apos;s \u0026lt;strong\u0026gt;jqLite\u0026lt;/strong\u0026gt; versus full-blown \u0026lt;strong\u0026gt;jQuery\u0026lt;/strong\u0026gt; is that \u0026lt;a href=\u0026quot;https://docs.angularjs.org/api/ng/function/angular.element\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;jqLite does not support selectors\u0026lt;/a\u0026gt;.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So when people say \u0026quot;don\u0026apos;t include jQuery at all\u0026quot;, it\u0026apos;s mainly because they don\u0026apos;t want you to use selectors; they want you to learn to use directives instead. Direct, not select!\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;jQuery\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;jQuery makes ridiculously long JavaScript commands like \u0026lt;code\u0026gt;getElementByHerpDerp\u0026lt;/code\u0026gt; shorter and cross-browser.\u0026lt;/p\u0026gt;\n\n\u0026lt;h1\u0026gt;AngularJS\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;AngularJS allows you to make your own HTML tags/attributes that do things which work well with dynamic web applications (since HTML was designed for static pages).\u0026lt;/p\u0026gt;\n\n\u0026lt;h1\u0026gt;Edit:\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;Saying \u0026quot;I have a jQuery background how do I think in AngularJS?\u0026quot; is like saying \u0026quot;I have an HTML background how do I think in JavaScript?\u0026quot; The fact that you\u0026apos;re asking the question shows you most likely don\u0026apos;t understand the fundamental purposes of these two resources. This is why I chose to answer the question by simply pointing out the fundamental difference rather than going through the list saying \u0026quot;AngularJS makes use of directives whereas jQuery uses CSS selectors to make a jQuery object which does this and that etc....\u0026quot;. This question does not require a lengthy answer.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;jQuery is a way to make programming JavaScript in the browser easier. Shorter, cross-browser commands, etc.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;AngularJS extends HTML, so you don\u0026apos;t have to put \u0026lt;code\u0026gt;\u0026amp;lt;div\u0026amp;gt;\u0026lt;/code\u0026gt; all over the place just to make an application. It makes HTML actually work for applications rather than what it was designed for, which is static, educational web pages. It accomplishes this in a roundabout way using JavaScript, but fundamentally it is an extension of HTML, not JavaScript.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;jQuery: you think a lot about \u0026apos;QUERYing the \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Document_Object_Model\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;DOM\u0026lt;/a\u0026gt;\u0026apos; for DOM elements and doing something.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;AngularJS: THE model is the truth, and you always think from that ANGLE.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example, when you get data from THE server which you intend to display in some format in the DOM, in jQuery, you need to \u0026apos;1. FIND\u0026apos; where in the DOM you want to place this data, the \u0026apos;2. UPDATE/APPEND\u0026apos; it there by creating a new node or just setting its \u0026lt;a href=\u0026quot;http://www.tizag.com/javascriptT/javascript-innerHTML.php\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;innerHTML\u0026lt;/a\u0026gt;. Then when you want to update this view, you then \u0026apos;3. FIND\u0026apos; the location and \u0026apos;4. UPDATE\u0026apos;. This cycle of find and update all done within the same context of getting and formatting data from server is gone in AngularJS.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;With AngularJS you have your model (JavaScript objects you are already used to) and the value of the model tells you about the model (obviously) and about the view, and an operation on the model automatically propagates to the view, so you don\u0026apos;t have to think about it. You will find yourself in AngularJS no longer finding things in the DOM.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To put in another way, in jQuery, you need to think about CSS selectors, that is, where is the \u0026lt;code\u0026gt;div\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;td\u0026lt;/code\u0026gt; that has a class or attribute, etc., so that I can get their HTML or color or value, but in AngularJS, you will find yourself thinking like this: what model am I dealing with, I will set the model\u0026apos;s value to true. You are not bothering yourself of whether the view reflecting this value is a checked box or resides in a \u0026lt;code\u0026gt;td\u0026lt;/code\u0026gt; element (details you would have often needed to think about in jQuery).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;And with DOM manipulation in AngularJS, you find yourself adding directives and filters, which you can think of as valid HTML extensions.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;One more thing you will experience in AngularJS: in jQuery you call the jQuery functions a lot, in AngularJS, AngularJS will call your functions, so AngularJS will \u0026apos;tell you how to do things\u0026apos;, but the benefits are worth it, so learning AngularJS usually means learning what AngularJS wants or the way AngularJS requires that you present your functions and it will call it accordingly. This is one of the things that makes AngularJS a framework rather than a library.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Those are some very nice, but lengthy answers.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To sum up my experiences:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Controllers and providers (services, factories, etc.) are for modifying the data model, NOT HTML.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;HTML and directives define the layout and binding to the model.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If you need to share data between controllers, create a service or factory - they are singletons that are shared across the application.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If you need an HTML widget, create a directive.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;If you have some data and are now trying to update HTML... STOP! update the model, and make sure your HTML is bound to the model.\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n    ","\n\u0026lt;p\u0026gt;jQuery is a DOM manipulation library.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;AngularJS is an MV* framework.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In fact, AngularJS is one of the few JavaScript MV* frameworks (many JavaScript MVC tools still fall under the category library).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Being a framework, it hosts your code and takes ownership of decisions about what to call and when!\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;AngularJS itself includes a jQuery-lite edition within it. So for some basic DOM selection/manipulation, you really don\u0026apos;t have to include the jQuery library (it saves many bytes to run on the network.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;AngularJS has the concept of \u0026quot;Directives\u0026quot; for DOM manipulation and designing reusable UI components, so you should use it whenever you feel the need of doing DOM manipulation related stuff (directives are only place where you should write jQuery code while using AngularJS).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;AngularJS involves some learning curve (more than jQuery :-).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;--\u0026amp;gt;For any developer coming from jQuery background, my first advice would be to \u0026quot;learn JavaScript as a first class language before jumping onto a rich framework like AngularJS!\u0026quot;\nI learned the above fact the hard way.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Good luck.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;They\u0026apos;re apples and oranges. You don\u0026apos;t want to compare them. They\u0026apos;re two different things. AngularJs has already jQuery lite built in which allows you to perform basic DOM manipulation without even including the full blown jQuery version. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;jQuery is all about DOM manipulation. It solves all the cross browser pain otherwise you will have to deal with but it\u0026apos;s not a framework that allows you to divide your app into components like AngularJS. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A nice thing about AngularJs is that it allows you to separate/isolate the DOM manipulation in the directives.  There are built-in directives ready for you to use such as ng-click. You can create your own custom directives that will contain all your view logic or DOM manipulation so you don\u0026apos;t end up mingle DOM manipulation code in the controllers or services that should take care of the business logic.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Angular breaks down your app into \n- Controllers\n- Services\n- Views\n- etc.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;and there is one more thing, that\u0026apos;s the directive. It\u0026apos;s an attribute  you can attach to any DOM element and you can go nuts with jQuery within it without worrying about your jQuery ever conflicts with AngularJs components or messes up with its architecture. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I heard from a meetup I attended, one of the founders of Angular said they worked really hard to separate out the DOM manipulation so do not try to include them back in. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Listen to the podcast \u0026lt;em\u0026gt;\u0026lt;a href=\u0026quot;http://javascriptjabber.com/032-jsj-angular-js/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;JavaScript Jabber: Episode #32\u0026lt;/a\u0026gt;\u0026lt;/em\u0026gt; that features the original creators of AngularJS: Misko Hevery \u0026amp;amp; Igor Minar. They talk a lot about what it\u0026apos;s like to come to AngularJS from other JavaScript backgrounds, especially jQuery.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;One of the points made in the podcast made a lot of things click for me with respects to your question:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;MISKO\u0026lt;/strong\u0026gt;: [...] one of the things we thought about very hardly in Angular is, how do we provide lots of escape hatches so that you can get out and basically figure out a way out of this. So to us, the answer is this thing called Directives. \u0026lt;strong\u0026gt;And with directives, you essentially become a regular little jQuery JavaScript, you can do whatever you want.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;IGOR\u0026lt;/strong\u0026gt;: So think of directive as the instruction to the compiler that tells it whenever you come across this certain element or this CSS in the template, and you keep this kind of code and that code is in charge of the element and everything below that element in the DOM tree.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;A transcript of the entire episode is available at the link provided above.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So, to directly answer your question: AngularJS is -very- opinionated and is a true MV* framework. However, you can still do all of the really cool stuff you know and love with jQuery inside of directives. It\u0026apos;s not a matter of \u0026quot;How do I do what I used to in jQuery?\u0026quot; as much as it\u0026apos;s a matter of \u0026quot;How do I supplement AngularJS with all of the stuff I used to do in jQuery?\u0026quot;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;It\u0026apos;s really two very different states of mind.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I find this question interesting, because my first serious exposure to JavaScript programming was \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Node.js\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Node.js\u0026lt;/a\u0026gt; and AngularJS. I never learned jQuery, and I guess that\u0026apos;s a good thing, because I don\u0026apos;t have to unlearn anything. In fact, I actively avoid jQuery solutions to my problems, and instead, solely look for an \u0026quot;AngularJS way\u0026quot; to solve them. So, I guess my answer to this question would essentially boil down to, \u0026quot;think like someone who never learned jQuery\u0026quot; and avoid any temptation to incorporate jQuery directly (obviously AngularJS uses it to some extent behind the scenes).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;AngularJS and jQuery:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;AngularJs and JQuery are completely different at every level except the JQLite functionality and you will see it once you start learning the AngularJs core features (I explained it below).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;AngularJs is a client side framework that offers to build the independent client side application. JQuery is a client side library that play around the DOM.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;AngularJs Cool Principle - If you want some changes on your UI think from model data change perspective. Change your data and UI will re-render itself. You need not to play around DOM each time unless and until it is hardly required and that should also be handled through Angular Directives.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To answer this question, I want to share my experience on the first enterprise application with AngularJS. These are the most awesome features that Angular provide where we start changing our jQuery mindset and we get the Angular like a framework and not the library.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Two-way data binding is amazing:\u0026lt;/strong\u0026gt; \nI had a grid with all functionality UPDATE, DELTE, INSERT. I have a data object that binds the grid\u0026apos;s model using ng-repeat. You only need to write a single line of simple JavaScript code for delete and insert and that\u0026apos;s it. grid automatically updates as the grid model changes instantly. Update functionality is real time, no code for it.\nYou feel amazing!!!\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Reusable directives are super:\u0026lt;/strong\u0026gt;\nWrite directives in one place and use it throughout the application. OMG!!! I used these directive for paging, regex, validations, etc. It is really cool!\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Routing is strong:\u0026lt;/strong\u0026gt;\nIt\u0026apos;s up to your implementation how you want to use it, but it requires very few lines of code to route the request to specify HTML and controller (JavaScript)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Controllers are great:\u0026lt;/strong\u0026gt;\nControllers take care of their own HTML, but this separation works well for common functionality well as. If you want to call the same function on the click of a button on master HTML, just write the same function name in each controller and write individual code.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Plugins:\u0026lt;/strong\u0026gt;\nThere are many other similar features like showing an overlay in your app. You don\u0026apos;t need to write code for it, just use an overlay plugin available as wc-overlay, and this will automatically take care of all \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/XMLHttpRequest\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;XMLHttpRequest\u0026lt;/a\u0026gt; (XHR) requests.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Ideal for \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_services\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;RESTful\u0026lt;/a\u0026gt; architecture:\u0026lt;/strong\u0026gt;\nBeing a complete frameworks makes AngularJS great to work with a RESTful architecture. To call REST CRUD APIs is very easier and \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Services\u0026lt;/strong\u0026gt;: Write common codes using services and less code in controllers. Sevices can be used to share common functionalities among the controllers.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Extensibility\u0026lt;/strong\u0026gt;: Angular has extended the HTML directives using angular directives. Write expressions inside html and evaluate them on runtime. Create your own directives and services and use them in another project without any extra effort.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As a JavaScript MV* beginner and purely focusing on the application architecture (not the server/client-side matters), I would certainly recommend the following resource (which I am surprised wasn\u0026apos;t mentioned yet): \u0026lt;a href=\u0026quot;http://addyosmani.com/resources/essentialjsdesignpatterns/book/\u0026quot;\u0026gt;JavaScript Design Patterns\u0026lt;/a\u0026gt;, by Addy Osmani, as an introduction to different \u0026lt;strong\u0026gt;JavaScript Design Patterns\u0026lt;/strong\u0026gt;. The terms used in this answer are taken from the linked document above. I\u0026apos;m not going to repeat what was worded really well in the accepted answer. Instead, this answer links back to the \u0026lt;strong\u0026gt;theoretical backgrounds\u0026lt;/strong\u0026gt; which power AngularJS (and other libraries).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Like me, you will quickly realize that AngularJS (or \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Ember.js\u0026quot;\u0026gt;Ember.js\u0026lt;/a\u0026gt;, Durandal, \u0026amp;amp; other MV* frameworks for that matter) is one complex framework assembling many of the different JavaScript design patterns.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I found it easier also, to test \u0026lt;strong\u0026gt;(1)\u0026lt;/strong\u0026gt; native JavaScript code and \u0026lt;strong\u0026gt;(2)\u0026lt;/strong\u0026gt; smaller libraries for each one of these patterns \u0026lt;strong\u0026gt;separately\u0026lt;/strong\u0026gt; before diving into one global framework. This allowed me to better understand which crucial issues a framework adresses (because you are personally faced with the problem).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://www.google.be/search?q=js+oop\u0026quot;\u0026gt;JavaScript Object-oriented Programming\u0026lt;/a\u0026gt; (this is a Google search link). It is not a library, but certainly a prerequisite to any application programming. It taught me the native implementations of the \u0026lt;strong\u0026gt;prototype, constructor, singleton \u0026amp;amp; decorator patterns\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://jquery.com\u0026quot;\u0026gt;jQuery\u0026lt;/a\u0026gt;/ \u0026lt;a href=\u0026quot;http://underscorejs.org\u0026quot;\u0026gt;Underscore\u0026lt;/a\u0026gt; for the \u0026lt;strong\u0026gt;facade pattern\u0026lt;/strong\u0026gt; (like WYSIWYG\u0026apos;s for manipulating the DOM)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://prototypejs.org\u0026quot;\u0026gt;Prototype.js\u0026lt;/a\u0026gt; for the \u0026lt;strong\u0026gt;prototype/ constructor/ mixin pattern\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://requirejs.org\u0026quot;\u0026gt;RequireJS\u0026lt;/a\u0026gt;/ \u0026lt;a href=\u0026quot;https://github.com/cujojs/curl\u0026quot;\u0026gt;Curl.js\u0026lt;/a\u0026gt; for the \u0026lt;strong\u0026gt;module pattern/ AMD\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://knockoutjs.com\u0026quot;\u0026gt;KnockoutJS\u0026lt;/a\u0026gt; for the \u0026lt;strong\u0026gt;observable, publish/subscribe pattern\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;NB: This list is not complete, nor \u0026apos;the best libraries\u0026apos;; they just happen to be the libraries I used. These libraries also include more patterns, the ones mentioned are just their main focuses or original intents. If you feel something is missing from this list, please do mention it in the comments, and I will be glad to add it.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Actually, if you\u0026apos;re using AngularJS, you don\u0026apos;t need jQuery anymore. AngularJS itself has the binding and directive, which is a very good \u0026quot;replacement\u0026quot; for most things you can do with jQuery.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I usually develop mobile applications using AngularJS and \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/PhoneGap\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Cordova\u0026lt;/a\u0026gt;. The ONLY thing from jQuery I needed is the Selector.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;By googling, I see that there is a standalone jQuery selector module out there. It\u0026apos;s Sizzle. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;And I decided to make a tiny code snippet that help me quickly start a website using AngularJS with the power of jQuery Selector (using Sizzle).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I shared my code here: \u0026lt;a href=\u0026quot;https://github.com/huytd/Sizzular\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://github.com/huytd/Sizzular\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    "],"id":147,"title":"\"Thinking in AngularJS\" if I have a jQuery background? [closed]","slug":"\"thinking-in-angularjs\"-if-i-have-a-jquery-background-closed-1657384761159","postType":"QUESTION","createdAt":"2022-07-09T16:39:21.000Z","updatedAt":"2022-07-09T16:39:21.000Z","tags":[{"id":535,"name":"angularjs","slug":"angularjs","createdAt":"2022-07-09T16:39:21.000Z","updatedAt":"2022-07-09T16:39:21.000Z","Questions_Tags":{"questionId":147,"tagId":535}}]}]}},"__N_SSG":true},"page":"/questions/tag/[slug]","query":{"slug":"angularjs"},"buildId":"6_hwtyf_oFlFS5l_S4CTe","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>