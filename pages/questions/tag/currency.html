<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2eccd4d47c856f2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2eccd4d47c856f2b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/81-301f760ac8107464.js" defer=""></script><script src="/_next/static/chunks/pages/questions/tag/%5Bslug%5D-6802ea06aeddcbec.js" defer=""></script><script src="/_next/static/6_hwtyf_oFlFS5l_S4CTe/_buildManifest.js" defer=""></script><script src="/_next/static/6_hwtyf_oFlFS5l_S4CTe/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5"></style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="https://flowbite.com/docs/images/logo.svg" class="mr-3 h-6 sm:h-9" alt="Flowbite Logo"/><span class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Hunter</span></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/tag/currency#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="flex items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/why-not-use-double-or-float-to-represent-currency-1657387417964">Why not use Double or Float to represent currency?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/currency">currency</a></div></div><div class="mt-4 mb-6" style="height:100px;overflow:auto"><h4 class="font-semibold">Solution 1:</h4><div class="text-sm bg-green-100 text-neutral-600">
<p>Because floats and doubles cannot accurately represent the base 10 multiples that we use for money. This issue isn't just for Java, it's for any programming language that uses base 2 floating-point types.</p>
<p>In base 10, you can write 10.25 as 1025 * 10<sup>-2</sup> (an integer times a power of 10). <a href="http://en.wikipedia.org/wiki/IEEE_floating_point" rel="noreferrer">IEEE-754 floating-point numbers</a> are different, but a very simple way to think about them is to multiply by a power of two instead. For instance, you could be looking at 164 * 2<sup>-4</sup> (an integer times a power of two), which is also equal to 10.25. That's not how the numbers are represented in memory, but the math implications are the same.</p>
<p>Even in base 10, this notation cannot accurately represent most simple fractions. For instance, you can't represent 1/3: the decimal representation is repeating (0.3333...), so there is no finite integer that you can multiply by a power of 10 to get 1/3. You could settle on a long sequence of 3's and a small exponent, like 333333333 * 10<sup>-10</sup>, but it is not accurate: if you multiply that by 3, you won't get&nbsp;1.</p>
<p>However, for the purpose of counting money, at least for countries whose money is valued within an order of magnitude of the US dollar, usually all you need is to be able to store multiples of 10<sup>-2</sup>, so it doesn't really matter that 1/3 can't be represented.</p>
<p>The problem with floats and doubles is that the <em>vast majority</em> of money-like numbers don't have an exact representation as an integer times a power of 2. In fact, the only multiples of 0.01 between 0 and 1 (which are significant when dealing with money because they're integer cents) that can be represented exactly as an IEEE-754 binary floating-point number are 0, 0.25, 0.5, 0.75 and 1. All the others are off by a small amount. As an analogy to the 0.333333 example, if you take the floating-point value for 0.01 and you multiply it by&nbsp;10, you won't get&nbsp;0.1. Instead you will get something like 0.099999999786...</p>
<p>Representing money as a <code>double</code> or <code>float</code> will probably look good at first as the software rounds off the tiny errors, but as you perform more additions, subtractions, multiplications and divisions on inexact numbers, errors will compound and you'll end up with values that are visibly not accurate. This makes floats and doubles inadequate for dealing with money, where perfect accuracy for multiples of base 10 powers is required.</p>
<p>A solution that works in just about any language is to use integers instead, and count cents. For instance, 1025 would be $10.25. Several languages also have built-in types to deal with money. Among others, Java  has the <a href="http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html" rel="noreferrer"><code>BigDecimal</code></a> class, and C# has the <a href="http://msdn.microsoft.com/en-us/library/364x0z75.aspx" rel="noreferrer"><code>decimal</code></a> type.</p>
    </div></div><div><div class="flex items-center justify-between text-slate-500"><div class="flex space-x-4 md:space-x-8"><div class="flex cursor-pointer items-center transition hover:text-slate-600"><svg xmlns="http://www.w3.org/2000/svg" class="mr-1.5 h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M14 10h4.764a2 2 0 011.789 2.894l-3.5 7A2 2 0 0115.263 21h-4.017c-.163 0-.326-.02-.485-.06L7 20m7-10V5a2 2 0 00-2-2h-.095c-.5 0-.905.405-.905.905 0 .714-.211 1.412-.608 2.006L7 11v9m7-10h-2M7 20H5a2 2 0 01-2-2v-6a2 2 0 012-2h2.5"></path></svg><span>4</span></div></div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"count":1,"rows":[{"answer":["\n\u0026lt;p\u0026gt;Because floats and doubles cannot accurately represent the base 10 multiples that we use for money. This issue isn\u0026apos;t just for Java, it\u0026apos;s for any programming language that uses base 2 floating-point types.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In base 10, you can write 10.25 as 1025 * 10\u0026lt;sup\u0026gt;-2\u0026lt;/sup\u0026gt; (an integer times a power of 10). \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/IEEE_floating_point\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;IEEE-754 floating-point numbers\u0026lt;/a\u0026gt; are different, but a very simple way to think about them is to multiply by a power of two instead. For instance, you could be looking at 164 * 2\u0026lt;sup\u0026gt;-4\u0026lt;/sup\u0026gt; (an integer times a power of two), which is also equal to 10.25. That\u0026apos;s not how the numbers are represented in memory, but the math implications are the same.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Even in base 10, this notation cannot accurately represent most simple fractions. For instance, you can\u0026apos;t represent 1/3: the decimal representation is repeating (0.3333...), so there is no finite integer that you can multiply by a power of 10 to get 1/3. You could settle on a long sequence of 3\u0026apos;s and a small exponent, like 333333333 * 10\u0026lt;sup\u0026gt;-10\u0026lt;/sup\u0026gt;, but it is not accurate: if you multiply that by 3, you won\u0026apos;t get\u0026amp;nbsp;1.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;However, for the purpose of counting money, at least for countries whose money is valued within an order of magnitude of the US dollar, usually all you need is to be able to store multiples of 10\u0026lt;sup\u0026gt;-2\u0026lt;/sup\u0026gt;, so it doesn\u0026apos;t really matter that 1/3 can\u0026apos;t be represented.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The problem with floats and doubles is that the \u0026lt;em\u0026gt;vast majority\u0026lt;/em\u0026gt; of money-like numbers don\u0026apos;t have an exact representation as an integer times a power of 2. In fact, the only multiples of 0.01 between 0 and 1 (which are significant when dealing with money because they\u0026apos;re integer cents) that can be represented exactly as an IEEE-754 binary floating-point number are 0, 0.25, 0.5, 0.75 and 1. All the others are off by a small amount. As an analogy to the 0.333333 example, if you take the floating-point value for 0.01 and you multiply it by\u0026amp;nbsp;10, you won\u0026apos;t get\u0026amp;nbsp;0.1. Instead you will get something like 0.099999999786...\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Representing money as a \u0026lt;code\u0026gt;double\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;float\u0026lt;/code\u0026gt; will probably look good at first as the software rounds off the tiny errors, but as you perform more additions, subtractions, multiplications and divisions on inexact numbers, errors will compound and you\u0026apos;ll end up with values that are visibly not accurate. This makes floats and doubles inadequate for dealing with money, where perfect accuracy for multiples of base 10 powers is required.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A solution that works in just about any language is to use integers instead, and count cents. For instance, 1025 would be $10.25. Several languages also have built-in types to deal with money. Among others, Java  has the \u0026lt;a href=\u0026quot;http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;BigDecimal\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; class, and C# has the \u0026lt;a href=\u0026quot;http://msdn.microsoft.com/en-us/library/364x0z75.aspx\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;decimal\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; type.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;From Bloch, J., Effective Java, (2nd ed, Item 48. 3rd ed, Item 60):\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;float\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;double\u0026lt;/code\u0026gt; types are\nparticularly ill-suited for monetary\ncalculations because it is impossible\nto represent 0.1 (or any other\nnegative power of ten) as a \u0026lt;code\u0026gt;float\u0026lt;/code\u0026gt; or\n\u0026lt;code\u0026gt;double\u0026lt;/code\u0026gt; exactly.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For example, suppose you have $1.03\nand you spend 42c. How much money do\nyou have left?\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;System.out.println(1.03 - .42);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;prints out \u0026lt;code\u0026gt;0.6100000000000001\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The right way to solve this problem is\nto use \u0026lt;code\u0026gt;BigDecimal\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;long\u0026lt;/code\u0026gt;\nfor monetary calculations.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Though \u0026lt;code\u0026gt;BigDecimal\u0026lt;/code\u0026gt; has some caveats (please see currently accepted answer).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is not a matter of accuracy, nor is it a matter of precision.  It is a matter of meeting the expectations of humans who use base 10 for calculations instead of base 2.  For example, using doubles for financial calculations does not produce answers that are \u0026quot;wrong\u0026quot; in a mathematical sense, but it can produce answers that are not what is expected in a financial sense.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Even if you round off your results at the last minute before output, you can still occasionally get a result using doubles that does not match expectations.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Using a calculator, or calculating results by hand, 1.40 * 165 = 231 exactly.  However, internally using doubles, on my compiler / operating system environment, it is stored as a binary number close to 230.99999... so if you truncate the number, you get 230 instead of 231.  You may reason that rounding instead of truncating would have given the desired result of 231.  That is true, but rounding always involves truncation.  Whatever rounding technique you use, there are still boundary conditions like this one that will round down when you expect it to round up.  They are rare enough that they often will not be found through casual testing or observation.  You may have to write some code to search for examples that illustrate outcomes that do not behave as expected.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Assume you want to round something to the nearest penny.  So you take your final result, multiply by 100, add 0.5, truncate, then divide the result by 100 to get back to pennies.  If the internal number you stored was 3.46499999.... instead of 3.465, you are going to get 3.46 instead 3.47 when you round the number to the nearest penny.  But your base 10 calculations may have indicated that the answer should be 3.465 exactly, which clearly should round up to 3.47, not down to 3.46.  These kinds of things happen occasionally in real life when you use doubles for financial calculations.  It is rare, so it often goes unnoticed as an issue, but it happens.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you use base 10 for your internal calculations instead of doubles, the answers are always exactly what is expected by humans, assuming no other bugs in your code.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I\u0026apos;m troubled by some of these responses.  I think doubles and floats have a place in financial calculations.  Certainly, when adding and subtracting non-fractional monetary amounts there will be no loss of precision when using integer classes or BigDecimal classes.  But when performing more complex operations, you often end up with results that go out several or many decimal places, no matter how you store the numbers.  The issue is how you present the result.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If your result is on the borderline between being rounded up and rounded down, and that last penny really matters, you should be probably be telling the viewer that the answer is nearly in the middle - by displaying more decimal places.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The problem with doubles, and more so with floats, is when they are used to combine large numbers and small numbers.  In java,\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;System.out.println(1000000.0f + 1.2f - 1000000.0f);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;results in\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;1.1875\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I\u0026apos;ll risk being downvoted, but I think the unsuitability of floating point numbers for currency calculations is overrated. As long as you make sure you do the cent-rounding correctly and have enough significant digits to work with in order to counter the binary-decimal representation mismatch explained by zneak, there will be no problem.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;People calculating with currency in Excel have always used double precision floats (there is no currency type in Excel) and I have yet to see anyone complaining about rounding errors.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Of course, you have to stay within reason; e.g. a simple webshop would probably never experience any problem with double precision floats, but if you do e.g. accounting or anything else that requires adding a large (unrestricted) amount of numbers, you wouldn\u0026apos;t want to touch floating point numbers with a ten foot pole.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Floats and doubles are approximate. If you create a BigDecimal and pass a float into the constructor you see what the float actually equals:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;groovy:000\u0026amp;gt; new BigDecimal(1.0F)\n===\u0026amp;gt; 1\ngroovy:000\u0026amp;gt; new BigDecimal(1.01F)\n===\u0026amp;gt; 1.0099999904632568359375\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;this probably isn\u0026apos;t how you want to represent $1.01.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The problem is that the IEEE spec doesn\u0026apos;t have a way to exactly represent all fractions, some of them end up as repeating fractions so you end up with approximation errors. Since accountants like things to come out exactly to the penny, and customers will be annoyed if they pay their bill and after the payment is processed they owe .01 and they get charged a fee or can\u0026apos;t close their account, it\u0026apos;s better to use exact types like decimal (in C#) or java.math.BigDecimal in Java.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It\u0026apos;s not that the error isn\u0026apos;t controllable if you round: \u0026lt;a href=\u0026quot;http://vanillajava.blogspot.com/2011/08/double-your-money-again.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;see this article by Peter Lawrey\u0026lt;/a\u0026gt;. It\u0026apos;s just easier not to have to round in the first place. Most applications that handle money don\u0026apos;t call for a lot of math, the operations consist of adding things or allocating amounts to different buckets. Introducing floating point and rounding just complicates things.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;While it\u0026apos;s true that floating point type can represent only approximatively decimal data, it\u0026apos;s also true that if one rounds numbers to the necessary precision before presenting them, one obtains the correct result. Usually.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Usually because the double type has a precision less than 16 figures. If you require better precision it\u0026apos;s not a suitable type. Also approximations can accumulate.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It must be said that even if you use fixed point arithmetic you still have to round numbers, were it not for the fact that BigInteger and BigDecimal give errors if you obtain periodic decimal numbers. So there is an approximation also here.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example COBOL, historically used for financial calculations, has a maximum precision of 18 figures. So there is often an implicit rounding.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Concluding, in my opinion the double is unsuitable mostly for its 16 digit precision, which can be insufficient, not because it is approximate.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Consider the following output of the subsequent program. It shows that after rounding double give the same result as BigDecimal up to precision 16.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;Precision 14\n------------------------------------------------------\nBigDecimalNoRound             : 56789.012345 / 1111111111 = Non-terminating decimal expansion; no exact representable decimal result.\nDoubleNoRound                 : 56789.012345 / 1111111111 = 5.111011111561101E-5\nBigDecimal                    : 56789.012345 / 1111111111 = 0.000051110111115611\nDouble                        : 56789.012345 / 1111111111 = 0.000051110111115611\n\nPrecision 15\n------------------------------------------------------\nBigDecimalNoRound             : 56789.012345 / 1111111111 = Non-terminating decimal expansion; no exact representable decimal result.\nDoubleNoRound                 : 56789.012345 / 1111111111 = 5.111011111561101E-5\nBigDecimal                    : 56789.012345 / 1111111111 = 0.0000511101111156110\nDouble                        : 56789.012345 / 1111111111 = 0.0000511101111156110\n\nPrecision 16\n------------------------------------------------------\nBigDecimalNoRound             : 56789.012345 / 1111111111 = Non-terminating decimal expansion; no exact representable decimal result.\nDoubleNoRound                 : 56789.012345 / 1111111111 = 5.111011111561101E-5\nBigDecimal                    : 56789.012345 / 1111111111 = 0.00005111011111561101\nDouble                        : 56789.012345 / 1111111111 = 0.00005111011111561101\n\nPrecision 17\n------------------------------------------------------\nBigDecimalNoRound             : 56789.012345 / 1111111111 = Non-terminating decimal expansion; no exact representable decimal result.\nDoubleNoRound                 : 56789.012345 / 1111111111 = 5.111011111561101E-5\nBigDecimal                    : 56789.012345 / 1111111111 = 0.000051110111115611011\nDouble                        : 56789.012345 / 1111111111 = 0.000051110111115611013\n\nPrecision 18\n------------------------------------------------------\nBigDecimalNoRound             : 56789.012345 / 1111111111 = Non-terminating decimal expansion; no exact representable decimal result.\nDoubleNoRound                 : 56789.012345 / 1111111111 = 5.111011111561101E-5\nBigDecimal                    : 56789.012345 / 1111111111 = 0.0000511101111156110111\nDouble                        : 56789.012345 / 1111111111 = 0.0000511101111156110125\n\nPrecision 19\n------------------------------------------------------\nBigDecimalNoRound             : 56789.012345 / 1111111111 = Non-terminating decimal expansion; no exact representable decimal result.\nDoubleNoRound                 : 56789.012345 / 1111111111 = 5.111011111561101E-5\nBigDecimal                    : 56789.012345 / 1111111111 = 0.00005111011111561101111\nDouble                        : 56789.012345 / 1111111111 = 0.00005111011111561101252\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;import java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.math.BigDecimal;\nimport java.math.MathContext;\n\npublic class Exercise {\n    public static void main(String[] args) throws IllegalArgumentException,\n            SecurityException, IllegalAccessException,\n            InvocationTargetException, NoSuchMethodException {\n        String amount = \u0026quot;56789.012345\u0026quot;;\n        String quantity = \u0026quot;1111111111\u0026quot;;\n        int [] precisions = new int [] {14, 15, 16, 17, 18, 19};\n        for (int i = 0; i \u0026amp;lt; precisions.length; i++) {\n            int precision = precisions[i];\n            System.out.println(String.format(\u0026quot;Precision %d\u0026quot;, precision));\n            System.out.println(\u0026quot;------------------------------------------------------\u0026quot;);\n            execute(\u0026quot;BigDecimalNoRound\u0026quot;, amount, quantity, precision);\n            execute(\u0026quot;DoubleNoRound\u0026quot;, amount, quantity, precision);\n            execute(\u0026quot;BigDecimal\u0026quot;, amount, quantity, precision);\n            execute(\u0026quot;Double\u0026quot;, amount, quantity, precision);\n            System.out.println();\n        }\n    }\n\n    private static void execute(String test, String amount, String quantity,\n            int precision) throws IllegalArgumentException, SecurityException,\n            IllegalAccessException, InvocationTargetException,\n            NoSuchMethodException {\n        Method impl = Exercise.class.getMethod(\u0026quot;divideUsing\u0026quot; + test, String.class,\n                String.class, int.class);\n        String price;\n        try {\n            price = (String) impl.invoke(null, amount, quantity, precision);\n        } catch (InvocationTargetException e) {\n            price = e.getTargetException().getMessage();\n        }\n        System.out.println(String.format(\u0026quot;%-30s: %s / %s = %s\u0026quot;, test, amount,\n                quantity, price));\n    }\n\n    public static String divideUsingDoubleNoRound(String amount,\n            String quantity, int precision) {\n        // acceptance\n        double amount0 = Double.parseDouble(amount);\n        double quantity0 = Double.parseDouble(quantity);\n\n        //calculation\n        double price0 = amount0 / quantity0;\n\n        // presentation\n        String price = Double.toString(price0);\n        return price;\n    }\n\n    public static String divideUsingDouble(String amount, String quantity,\n            int precision) {\n        // acceptance\n        double amount0 = Double.parseDouble(amount);\n        double quantity0 = Double.parseDouble(quantity);\n\n        //calculation\n        double price0 = amount0 / quantity0;\n\n        // presentation\n        MathContext precision0 = new MathContext(precision);\n        String price = new BigDecimal(price0, precision0)\n                .toString();\n        return price;\n    }\n\n    public static String divideUsingBigDecimal(String amount, String quantity,\n            int precision) {\n        // acceptance\n        BigDecimal amount0 = new BigDecimal(amount);\n        BigDecimal quantity0 = new BigDecimal(quantity);\n        MathContext precision0 = new MathContext(precision);\n\n        //calculation\n        BigDecimal price0 = amount0.divide(quantity0, precision0);\n\n        // presentation\n        String price = price0.toString();\n        return price;\n    }\n\n    public static String divideUsingBigDecimalNoRound(String amount, String quantity,\n            int precision) {\n        // acceptance\n        BigDecimal amount0 = new BigDecimal(amount);\n        BigDecimal quantity0 = new BigDecimal(quantity);\n\n        //calculation\n        BigDecimal price0 = amount0.divide(quantity0);\n\n        // presentation\n        String price = price0.toString();\n        return price;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The result of floating point number is not exact, which makes them unsuitable for any financial calculation which requires exact result and not approximation. float and double are designed for engineering and scientific calculation and many times doesnt produce exact result also result of floating point calculation may vary from JVM to JVM. Look at below example of BigDecimal and double primitive which is used to represent money value, its quite clear that floating point calculation may not be exact and one should use BigDecimal for financial calculations.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;    // floating point calculation\n    final double amount1 = 2.0;\n    final double amount2 = 1.1;\n    System.out.println(\u0026quot;difference between 2.0 and 1.1 using double is: \u0026quot; + (amount1 - amount2));\n\n    // Use BigDecimal for financial calculation\n    final BigDecimal amount3 = new BigDecimal(\u0026quot;2.0\u0026quot;);\n    final BigDecimal amount4 = new BigDecimal(\u0026quot;1.1\u0026quot;);\n    System.out.println(\u0026quot;difference between 2.0 and 1.1 using BigDecimal is: \u0026quot; + (amount3.subtract(amount4)));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Output:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;difference between 2.0 and 1.1 using double is: 0.8999999999999999\ndifference between 2.0 and 1.1 using BigDecimal is: 0.9\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As said earlier \u0026quot;Representing money as a double or float will probably look good at first as the software rounds off the tiny errors, but as you perform more additions, subtractions, multiplications and divisions on inexact numbers, youll lose more and more precision as the errors add up. This makes floats and doubles inadequate for dealing with money, where perfect accuracy for multiples of base 10 powers is required.\u0026quot;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Finally Java has a standard way to work with Currency And Money!\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;JSR 354: Money and Currency API\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;JSR 354 provides an API for representing, transporting, and performing comprehensive calculations with Money and Currency. You can download it from this link:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://jcp.org/en/jsr/detail?id=354\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;JSR 354: Money and Currency API Download\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;The specification consists of the following things:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;An API for handling e. g. monetary amounts and currencies\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;APIs to support interchangeable implementations\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Factories for creating instances of the implementation classes\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Functionality for calculations, conversion and formatting of monetary            amounts\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Java API for working with Money and Currencies, which is planned to be included in Java 9.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;All specification classes and interfaces are located in the javax.money.* package.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Sample Examples of JSR 354: Money and Currency API:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;An example of creating a MonetaryAmount and printing it to the console looks like this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;MonetaryAmountFactory\u0026amp;lt;?\u0026amp;gt; amountFactory = Monetary.getDefaultAmountFactory();\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MonetaryAmount\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;monetaryAmount\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; amountFactory.setCurrency(Monetary.getCurrency(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;EUR\u0026quot;\u0026lt;/span\u0026gt;)).setNumber(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12345.67\u0026lt;/span\u0026gt;).create();\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MonetaryAmountFormat\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;format\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; MonetaryFormats.getAmountFormat(Locale.getDefault());\nSystem.out.println(format.format(monetaryAmount));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;When using the reference implementation API, the necessary code is much simpler:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MonetaryAmount\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;monetaryAmount\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; Money.of(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12345.67\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;EUR\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MonetaryAmountFormat\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;format\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; MonetaryFormats.getAmountFormat(Locale.getDefault());\nSystem.out.println(format.format(monetaryAmount));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The API also supports calculations with MonetaryAmounts:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MonetaryAmount\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;monetaryAmount\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; Money.of(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12345.67\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;EUR\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MonetaryAmount\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;otherMonetaryAmount\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; monetaryAmount.divide(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;).add(Money.of(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;EUR\u0026quot;\u0026lt;/span\u0026gt;));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;CurrencyUnit and MonetaryAmount\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// getting CurrencyUnits by locale\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;CurrencyUnit\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;yen\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; MonetaryCurrencies.getCurrency(Locale.JAPAN);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;CurrencyUnit\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;canadianDollar\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; MonetaryCurrencies.getCurrency(Locale.CANADA);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;MonetaryAmount has various methods that allow accessing the assigned currency, the numeric amount, its precision and more:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MonetaryAmount\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;monetaryAmount\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; Money.of(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;123.45\u0026lt;/span\u0026gt;, euro);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;CurrencyUnit\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;currency\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; monetaryAmount.getCurrency();\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;NumberValue\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;numberValue\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; monetaryAmount.getNumber();\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;intValue\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; numberValue.intValue(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 123\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;doubleValue\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; numberValue.doubleValue(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 123.45\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;fractionDenominator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; numberValue.getAmountFractionDenominator(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 100\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;fractionNumerator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; numberValue.getAmountFractionNumerator(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 45\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;precision\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; numberValue.getPrecision(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 5\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// NumberValue extends java.lang.Number.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// So we assign numberValue to a variable of type Number\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Number\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;number\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; numberValue;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;MonetaryAmounts can be rounded using a rounding operator:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;CurrencyUnit\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;usd\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; MonetaryCurrencies.getCurrency(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;USD\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MonetaryAmount\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;dollars\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; Money.of(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12.34567\u0026lt;/span\u0026gt;, usd);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MonetaryOperator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;roundingOperator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; MonetaryRoundings.getRounding(usd);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MonetaryAmount\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;roundedDollars\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; dollars.with(roundingOperator); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// USD 12.35\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;When working with collections of MonetaryAmounts, some nice utility methods for filtering, sorting and grouping are available.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;List\u0026amp;lt;MonetaryAmount\u0026amp;gt; amounts = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;gt;();\namounts.add(Money.of(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;EUR\u0026quot;\u0026lt;/span\u0026gt;));\namounts.add(Money.of(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;USD\u0026quot;\u0026lt;/span\u0026gt;));\namounts.add(Money.of(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;USD\u0026quot;\u0026lt;/span\u0026gt;));\namounts.add(Money.of(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;13.37\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;JPY\u0026quot;\u0026lt;/span\u0026gt;));\namounts.add(Money.of(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;18\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;USD\u0026quot;\u0026lt;/span\u0026gt;));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Custom MonetaryAmount operations\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// A monetary operator that returns 10% of the input MonetaryAmount\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Implemented using Java 8 Lambdas\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MonetaryOperator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;tenPercentOperator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; (MonetaryAmount amount) -\u0026amp;gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;BigDecimal\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;baseAmount\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; amount.getNumber().numberValue(BigDecimal.class);\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;BigDecimal\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;tenPercent\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; baseAmount.multiply(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;BigDecimal\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0.1\u0026quot;\u0026lt;/span\u0026gt;));\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; Money.of(tenPercent, amount.getCurrency());\n};\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MonetaryAmount\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;dollars\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; Money.of(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12.34567\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;USD\u0026quot;\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// apply tenPercentOperator to MonetaryAmount\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MonetaryAmount\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;tenPercentDollars\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; dollars.with(tenPercentOperator); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// USD 1.234567\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Resources:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://blog.oio.de/2015/12/17/handling-money-and-currencies-in-java-with-jsr-354/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Handling money and currencies in Java with JSR 354\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://dzone.com/articles/looking-java-9-money-and\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Looking into the Java 9 Money and Currency API (JSR 354)\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;See Also: \u0026lt;a href=\u0026quot;http://javamoney.github.io/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;JSR 354 - Currency and Money\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Most answers have highlighted the reasons why one should not use doubles for money and currency calculations. And I totally agree with them. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It doesn\u0026apos;t mean though that doubles can never be used for that purpose. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I have worked on a number of projects with very low gc requirements, and having BigDecimal objects was a big contributor to that overhead. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It\u0026apos;s the lack of understanding about double representation and lack of experience in handling the accuracy and precision that brings about this wise suggestion.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can make it work if you are able to handle the precision and accuracy requirements of your project, which has to be done based on what range of double values is one dealing with.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can refer to guava\u0026apos;s FuzzyCompare method to get more idea. The parameter tolerance is the key. \nWe dealt with this problem for a securities trading application and we did an exhaustive research on what tolerances to use for different numerical values in different ranges.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Also, there might be situations when you\u0026apos;re tempted to use Double wrappers as a map key with hash map being the implementation. It is very risky because Double.equals and hash code for example values \u0026quot;0.5\u0026quot; \u0026amp;amp; \u0026quot;0.6 - 0.1\u0026quot; will cause a big mess.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If your computation involves various steps, arbitrary precision arithmetic won\u0026apos;t cover you 100%.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The only reliable way to use a perfect representation of results(Use a custom Fraction data type that will batch division operations to the last step) and only convert to decimal notation in the last step.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Arbitrary precision won\u0026apos;t help because there always can be numbers that has so many decimal places, or some results such as \u0026lt;code\u0026gt;0.6666666\u0026lt;/code\u0026gt;... No arbitrary representation will cover the last example. So you will have small errors in each step.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;These errors will add-up, may eventually become not easy to ignore anymore. This is called \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Propagation_of_uncertainty\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Error Propagation\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Many of the answers posted to this question discuss IEEE and the standards surrounding floating-point arithmetic.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Coming from a non-computer science background (physics and engineering), I tend to look at problems from a different perspective. For me, the reason why I wouldn\u0026apos;t use a double or float in a mathematical calculation is that I would lose too much information.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;What are the alternatives? There are many (and many more of which I am not aware!).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;BigDecimal in Java is native to the Java language.\nApfloat is another arbitrary-precision library for Java.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The decimal data type in C# is Microsoft\u0026apos;s .NET alternative for 28 significant figures.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;SciPy (Scientific Python) can probably also handle financial calculations (I haven\u0026apos;t tried, but I suspect so).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The GNU Multiple Precision Library (GMP) and the GNU MFPR Library are two free and open-source resources for C and C++.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There are also numerical precision libraries for JavaScript(!) and I think PHP which can handle financial calculations.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There are also proprietary (particularly, I think, for Fortran) and open-source solutions as well for many computer languages.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;m not a computer scientist by training. However, I tend to lean towards either BigDecimal in Java or decimal in C#. I haven\u0026apos;t tried the other solutions I\u0026apos;ve listed, but they are probably very good as well.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For me, I like BigDecimal because of the methods it supports. C#\u0026apos;s decimal is very nice, but I haven\u0026apos;t had the chance to work with it as much as I\u0026apos;d like. I do scientific calculations of interest to me in my spare time, and BigDecimal seems to work very well because I can set the precision of my floating point numbers. The disadvantage to BigDecimal? It can be slow at times, especially if you\u0026apos;re using the divide method.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You might, for speed, look into the free and proprietary libraries in C, C++, and Fortran.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;To add on previous answers, there is also the option of implementing \u0026lt;strong\u0026gt;Joda-Money\u0026lt;/strong\u0026gt; in Java, besides BigDecimal, when dealing with the problem addressed in the question. Java module name is org.joda.money.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;It requires Java SE 8 or later and has no dependencies.\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;To be more precise, there is a compile-time dependency but it is not\nrequired.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;\u0026amp;lt;dependency\u0026amp;gt;\n  \u0026amp;lt;groupId\u0026amp;gt;org.joda\u0026amp;lt;/groupId\u0026amp;gt;\n  \u0026amp;lt;artifactId\u0026amp;gt;joda-money\u0026amp;lt;/artifactId\u0026amp;gt;\n  \u0026amp;lt;version\u0026amp;gt;1.0.1\u0026amp;lt;/version\u0026amp;gt;\n\u0026amp;lt;/dependency\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Examples of using Joda Money:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;  // create a monetary value\n  Money money = Money.parse(\u0026quot;USD 23.87\u0026quot;);\n  \n  // add another amount with safe double conversion\n  CurrencyUnit usd = CurrencyUnit.of(\u0026quot;USD\u0026quot;);\n  money = money.plus(Money.of(usd, 12.43d));\n  \n  // subtracts an amount in dollars\n  money = money.minusMajor(2);\n  \n  // multiplies by 3.5 with rounding\n  money = money.multipliedBy(3.5d, RoundingMode.DOWN);\n  \n  // compare two amounts\n  boolean bigAmount = money.isGreaterThan(dailyWage);\n  \n  // convert to GBP using a supplied rate\n  BigDecimal conversionRate = ...;  // obtained from code outside Joda-Money\n  Money moneyGBP = money.convertedTo(CurrencyUnit.GBP, conversionRate, RoundingMode.HALF_UP);\n  \n  // use a BigMoney for more complex calculations where scale matters\n  BigMoney moneyCalc = money.toBigMoney();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Documentation:\n\u0026lt;a href=\u0026quot;http://joda-money.sourceforge.net/apidocs/org/joda/money/Money.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;http://joda-money.sourceforge.net/apidocs/org/joda/money/Money.html\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Implementation examples:\n\u0026lt;a href=\u0026quot;https://www.programcreek.com/java-api-examples/?api=org.joda.money.Money\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://www.programcreek.com/java-api-examples/?api=org.joda.money.Money\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Float is binary form of Decimal with different design; they are two different things. There are little errors between two types when converted to each other. Also, float is designed to represent infinite large number of values for scientific. That means it is designed to lost precision to extreme small and extreme large number with that fixed number of bytes. Decimal can\u0026apos;t represent infinite number of values, it bounds to just that number of decimal digits. So Float and Decimal are for different purpose.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There are some ways to manage the error for currency value:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Use long integer and count in cents instead.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Use double precision, keep your significant digits to 15 only so decimal can be exactly simulated. Round before presenting values; Round often when doing calculations.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Use a decimal library like Java BigDecimal so you don\u0026apos;t need to use double to simulate decimal.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;p.s. it is interesting to know that most brands of handheld scientific calculators works on decimal instead of float. So no one complaint float conversion errors.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Take a look at this simple example: it looks like logically correct, but in real world this can return unexpected results if not threated correctly:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;0.1 x 10 = 1   , so:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;double total = 0.0;\n\n// adds 10 cents, 10 times\nfor (int i = 0; i \u0026amp;lt; 10; i++) {\n    total += 0.1;  // adds 10 cents\n}\n\nLog.d(\u0026quot;result: \u0026quot;, \u0026quot;current total: \u0026quot; + total);\n\n// looks like total equals to 1.0, don\u0026apos;t?\n\n// now, do reverse\nfor (int i = 0; i \u0026amp;lt; 10; i++) {\n    total -= 0.1;  // removes 10 cents\n}\n\n// total should be equals to 0.0, right?\nLog.d(\u0026quot;result: \u0026quot;, \u0026quot;current total: \u0026quot; + total);\nif (total == 0.0) {\n    Log.d(\u0026quot;result: \u0026quot;, \u0026quot;is total equal to ZERO? YES, of course!!\u0026quot;);\n} else {\n    Log.d(\u0026quot;result: \u0026quot;, \u0026quot;is total equal to ZERO? No...\u0026quot;);\n    // so be careful comparing equality in this cases!!!\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;OUTPUT:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt; result: current total: 0.9999999999999999\n result: current total: 2.7755575615628914E-17   \n result: is total equal to ZERO? No... \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;American currency can easily be represented with dollar and cent amounts.  Integers are 100% precise, while floating point binary numbers do not exactly match floating point decimals.\u0026lt;/p\u0026gt;\n    "],"id":254,"title":"Why not use Double or Float to represent currency?","slug":"why-not-use-double-or-float-to-represent-currency-1657387417964","postType":"QUESTION","createdAt":"2022-07-09T17:23:37.000Z","updatedAt":"2022-07-09T17:23:37.000Z","tags":[{"id":1641,"name":"currency","slug":"currency","createdAt":"2022-07-09T17:23:38.000Z","updatedAt":"2022-07-09T17:23:38.000Z","Questions_Tags":{"questionId":254,"tagId":1641}}]}]}},"__N_SSG":true},"page":"/questions/tag/[slug]","query":{"slug":"currency"},"buildId":"6_hwtyf_oFlFS5l_S4CTe","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>