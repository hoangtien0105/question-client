<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2eccd4d47c856f2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2eccd4d47c856f2b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/81-301f760ac8107464.js" defer=""></script><script src="/_next/static/chunks/pages/questions/tag/%5Bslug%5D-6802ea06aeddcbec.js" defer=""></script><script src="/_next/static/6_hwtyf_oFlFS5l_S4CTe/_buildManifest.js" defer=""></script><script src="/_next/static/6_hwtyf_oFlFS5l_S4CTe/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5"></style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="https://flowbite.com/docs/images/logo.svg" class="mr-3 h-6 sm:h-9" alt="Flowbite Logo"/><span class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Hunter</span></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/tag/dependency-injection#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="flex items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-is-dependency-injection-1657387953056">What is dependency injection?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/dependency-injection">dependency-injection</a></div></div><div class="mt-4 mb-6" style="height:100px;overflow:auto"><h4 class="font-semibold">Solution 1:</h4><div class="text-sm bg-green-100 text-neutral-600">
<p>The best definition I've found so far is <a href="http://jamesshore.com/Blog/Dependency-Injection-Demystified.html" rel="noreferrer">one by James Shore</a>: </p>

<blockquote>
  <p>"Dependency Injection" is a 25-dollar
  term for a 5-cent concept. [...]
  Dependency injection means giving an
  object its instance variables. [...].</p>
</blockquote>

<p>There is <a href="http://martinfowler.com/articles/injection.html" rel="noreferrer">an article by Martin Fowler</a> that may prove useful, too.</p>

<p>Dependency injection is basically providing the objects that an object needs (its dependencies) instead of having it construct them itself. It's a very useful technique for testing, since it allows dependencies to be mocked or stubbed out.</p>

<p>Dependencies can be injected into objects by many means (such as constructor injection or setter injection). One can even use specialized dependency injection frameworks (e.g. Spring) to do that, but they certainly aren't required. You don't need those frameworks to have dependency injection. Instantiating and passing objects (dependencies) explicitly is just as good an injection as injection by framework.</p>
    </div></div><div><div class="flex items-center justify-between text-slate-500"><div class="flex space-x-4 md:space-x-8"><div class="flex cursor-pointer items-center transition hover:text-slate-600"><svg xmlns="http://www.w3.org/2000/svg" class="mr-1.5 h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M14 10h4.764a2 2 0 011.789 2.894l-3.5 7A2 2 0 0115.263 21h-4.017c-.163 0-.326-.02-.485-.06L7 20m7-10V5a2 2 0 00-2-2h-.095c-.5 0-.905.405-.905.905 0 .714-.211 1.412-.608 2.006L7 11v9m7-10h-2M7 20H5a2 2 0 01-2-2v-6a2 2 0 012-2h2.5"></path></svg><span>4</span></div></div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"count":1,"rows":[{"answer":["\n\u0026lt;p\u0026gt;The best definition I\u0026apos;ve found so far is \u0026lt;a href=\u0026quot;http://jamesshore.com/Blog/Dependency-Injection-Demystified.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;one by James Shore\u0026lt;/a\u0026gt;: \u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026quot;Dependency Injection\u0026quot; is a 25-dollar\n  term for a 5-cent concept. [...]\n  Dependency injection means giving an\n  object its instance variables. [...].\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;There is \u0026lt;a href=\u0026quot;http://martinfowler.com/articles/injection.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;an article by Martin Fowler\u0026lt;/a\u0026gt; that may prove useful, too.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Dependency injection is basically providing the objects that an object needs (its dependencies) instead of having it construct them itself. It\u0026apos;s a very useful technique for testing, since it allows dependencies to be mocked or stubbed out.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Dependencies can be injected into objects by many means (such as constructor injection or setter injection). One can even use specialized dependency injection frameworks (e.g. Spring) to do that, but they certainly aren\u0026apos;t required. You don\u0026apos;t need those frameworks to have dependency injection. Instantiating and passing objects (dependencies) explicitly is just as good an injection as injection by framework.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Dependency Injection\u0026lt;/strong\u0026gt; is passing dependency to other \u0026lt;strong\u0026gt;objects\u0026lt;/strong\u0026gt; or \u0026lt;strong\u0026gt;framework\u0026lt;/strong\u0026gt;( dependency injector).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Dependency injection makes testing easier. The injection can be done through \u0026lt;strong\u0026gt;constructor\u0026lt;/strong\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;SomeClass()\u0026lt;/code\u0026gt; has its constructor as following:\u0026lt;/p\u0026gt;\n\n\n\n\u0026lt;pre class=\u0026quot;lang-csh s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;public \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;SomeClass\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;() {\n    myObject = Factory.getObject();\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Problem\u0026lt;/strong\u0026gt;:\nIf \u0026lt;code\u0026gt;myObject\u0026lt;/code\u0026gt; involves complex tasks such as disk access or network access, it is \u0026lt;strong\u0026gt;hard\u0026lt;/strong\u0026gt; to do unit test on \u0026lt;code\u0026gt;SomeClass()\u0026lt;/code\u0026gt;. Programmers have to mock \u0026lt;code\u0026gt;myObject\u0026lt;/code\u0026gt; and might \u0026lt;strong\u0026gt;intercept\u0026lt;/strong\u0026gt; the factory call.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Alternative solution\u0026lt;/strong\u0026gt;: \u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Passing \u0026lt;code\u0026gt;myObject\u0026lt;/code\u0026gt; in as an argument to the constructor\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\n\n\u0026lt;pre class=\u0026quot;lang-csh s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;public SomeClass (MyClass myObject) {\n    this.myObject = myObject;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;myObject\u0026lt;/code\u0026gt; can be passed directly which makes testing easier. \u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;One common alternative is defining a \u0026lt;strong\u0026gt;do-nothing constructor\u0026lt;/strong\u0026gt;. Dependency injection can be done through setters. (h/t @MikeVella). \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://martinfowler.com/articles/injection.html#InterfaceInjection\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Martin Fowler\u0026lt;/a\u0026gt; documents a third alternative (h/t @MarcDix), where \u0026lt;strong\u0026gt;classes explicitly implement an interface\u0026lt;/strong\u0026gt; for the dependencies programmers wish injected.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;It is harder to isolate components in unit testing without dependency injection. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In 2013, when I wrote this answer, this was a major theme on the \u0026lt;a href=\u0026quot;http://googletesting.blogspot.com/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Google Testing Blog\u0026lt;/a\u0026gt;. It remains the biggest advantage to me, as programmers not always need the extra flexibility in their run-time design (for instance, for service locator or similar patterns). Programmers often need to isolate the classes during testing.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;I found this funny example in terms of \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Loose_coupling\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;loose coupling\u0026lt;/a\u0026gt;:\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Source: \u0026lt;em\u0026gt;\u0026lt;a href=\u0026quot;http://ganeshtiwaridotcomdotnp.blogspot.com/2011/05/understanding-dependency-injection-and.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Understanding dependency injection\u0026lt;/a\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Any application is composed of many objects that collaborate with each other to perform some useful stuff. Traditionally each object is responsible for obtaining its own references to the dependent objects (dependencies) it collaborate with. This leads to highly coupled classes and hard-to-test code.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For example, consider a \u0026lt;code\u0026gt;Car\u0026lt;/code\u0026gt; object.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A \u0026lt;code\u0026gt;Car\u0026lt;/code\u0026gt; depends on wheels, engine, fuel, battery, etc. to run. Traditionally we define the brand of such dependent objects along with the definition of the \u0026lt;code\u0026gt;Car\u0026lt;/code\u0026gt; object.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Without Dependency Injection (DI):\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Car\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Wheel\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;wh\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;NepaliRubberWheel\u0026lt;/span\u0026gt;();\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Battery\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;bt\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ExcideBattery\u0026lt;/span\u0026gt;();\n\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//The rest\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Here, the \u0026lt;code\u0026gt;Car\u0026lt;/code\u0026gt; object \u0026lt;em\u0026gt;is responsible for creating the dependent objects.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;What if we want to change the type of its dependent object - say \u0026lt;code\u0026gt;Wheel\u0026lt;/code\u0026gt; - after the initial \u0026lt;code\u0026gt;NepaliRubberWheel()\u0026lt;/code\u0026gt; punctures?\nWe need to recreate the Car object with its new dependency say \u0026lt;code\u0026gt;ChineseRubberWheel()\u0026lt;/code\u0026gt;, but only the \u0026lt;code\u0026gt;Car\u0026lt;/code\u0026gt; manufacturer can do that.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;Then what does the \u0026lt;code\u0026gt;Dependency Injection\u0026lt;/code\u0026gt; do for us...?\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;When using dependency injection, objects are given their dependencies \u0026lt;em\u0026gt;at run time rather than compile time (car manufacturing time)\u0026lt;/em\u0026gt;.\nSo that we can now change the \u0026lt;code\u0026gt;Wheel\u0026lt;/code\u0026gt; whenever we want. Here, the \u0026lt;code\u0026gt;dependency\u0026lt;/code\u0026gt; (\u0026lt;code\u0026gt;wheel\u0026lt;/code\u0026gt;) can be injected into \u0026lt;code\u0026gt;Car\u0026lt;/code\u0026gt; at run time.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;After using dependency injection:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Here, we are \u0026lt;strong\u0026gt;injecting\u0026lt;/strong\u0026gt; the \u0026lt;strong\u0026gt;dependencies\u0026lt;/strong\u0026gt; (Wheel and Battery) at runtime. Hence the term : \u0026lt;em\u0026gt;Dependency Injection.\u0026lt;/em\u0026gt; We normally rely on DI frameworks such as Spring, Guice, Weld to create the dependencies and inject where needed.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Car\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; Wheel wh; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Inject an Instance of Wheel (dependency of car) at runtime\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; Battery bt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Inject an Instance of Battery (dependency of car) at runtime\u0026lt;/span\u0026gt;\n  Car(Wheel wh,Battery bt) {\n      \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.wh = wh;\n      \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.bt = bt;\n  }\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Or we can have setters\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setWheel\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Wheel wh)\u0026lt;/span\u0026gt; {\n      \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.wh = wh;\n  }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;The advantages are:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;decoupling the creation of object (in other word, separate usage from the creation of object)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;ability to replace dependencies (eg: Wheel, Battery) without changing the class that uses it(Car)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;promotes \u0026quot;Code to interface not to implementation\u0026quot; principle\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;ability to create and use mock dependency during test (if we want to use a Mock of Wheel during test instead of a real instance.. we can create Mock Wheel object and let DI framework inject to Car)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Dependency Injection is a practice where objects are designed in a manner where they receive instances of the objects from other pieces of code, instead of constructing them internally. This means that any object implementing the interface which is required by the object can be substituted in without changing the code, which simplifies testing, and improves decoupling.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example, consider these clases:\u0026lt;/p\u0026gt;\n\n\n\n\u0026lt;pre class=\u0026quot;lang-csh s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;public class PersonService {\n  public void addManager( Person employee, Person newManager ) { ... }\n  public void removeManager( Person employee, Person oldManager ) { ... }\n  public Group getGroupByManager( Person manager ) { ... }\n}\n\npublic class \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;GroupMembershipService\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;() {\n  public void addPersonToGroup( Person person, Group group ) { ... }\n  public void removePersonFromGroup( Person person, Group group ) { ... }\n} \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In this example, the implementation of \u0026lt;code\u0026gt;PersonService::addManager\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;PersonService::removeManager\u0026lt;/code\u0026gt; would need an instance of the \u0026lt;code\u0026gt;GroupMembershipService\u0026lt;/code\u0026gt; in order to do its work. Without Dependency Injection, the traditional way of doing this would be to instantiate a new \u0026lt;code\u0026gt;GroupMembershipService\u0026lt;/code\u0026gt; in the constructor of \u0026lt;code\u0026gt;PersonService\u0026lt;/code\u0026gt; and use that instance attribute in both functions. However, if the constructor of \u0026lt;code\u0026gt;GroupMembershipService\u0026lt;/code\u0026gt; has multiple things it requires, or worse yet, there are some initialization \u0026quot;setters\u0026quot; that need to be called on the \u0026lt;code\u0026gt;GroupMembershipService\u0026lt;/code\u0026gt;, the code grows rather quickly, and the \u0026lt;code\u0026gt;PersonService\u0026lt;/code\u0026gt; now depends not only on the \u0026lt;code\u0026gt;GroupMembershipService\u0026lt;/code\u0026gt; but also everything else that \u0026lt;code\u0026gt;GroupMembershipService\u0026lt;/code\u0026gt; depends on. Furthermore, the linkage to \u0026lt;code\u0026gt;GroupMembershipService\u0026lt;/code\u0026gt; is hardcoded into the \u0026lt;code\u0026gt;PersonService\u0026lt;/code\u0026gt; which means that you can\u0026apos;t \u0026quot;dummy up\u0026quot; a \u0026lt;code\u0026gt;GroupMembershipService\u0026lt;/code\u0026gt; for testing purposes, or to use a strategy pattern in different parts of your application.   \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;With Dependency Injection, instead of instantiating the \u0026lt;code\u0026gt;GroupMembershipService\u0026lt;/code\u0026gt; within your \u0026lt;code\u0026gt;PersonService\u0026lt;/code\u0026gt;, you\u0026apos;d either pass it in to the \u0026lt;code\u0026gt;PersonService\u0026lt;/code\u0026gt; constructor, or else add a Property (getter and setter) to set a local instance of it. This means that your \u0026lt;code\u0026gt;PersonService\u0026lt;/code\u0026gt; no longer has to worry about how to create a \u0026lt;code\u0026gt;GroupMembershipService\u0026lt;/code\u0026gt;, it just accepts the ones it\u0026apos;s given, and works with them.  This also means that anything which is a subclass of \u0026lt;code\u0026gt;GroupMembershipService\u0026lt;/code\u0026gt;, or implements the \u0026lt;code\u0026gt;GroupMembershipService\u0026lt;/code\u0026gt; interface can be \u0026quot;injected\u0026quot; into the \u0026lt;code\u0026gt;PersonService\u0026lt;/code\u0026gt;, and the \u0026lt;code\u0026gt;PersonService\u0026lt;/code\u0026gt; doesn\u0026apos;t need to know about the change.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The accepted answer is a good one - but I would like to add to this that DI is very much like the classic avoiding of hardcoded constants in the code.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When you use some constant like a database name you\u0026apos;d quickly move it from the inside of the code to some config file and pass a variable containing that value to the place where it is needed.  The reason to do that is that these constants usually change more frequently than the rest of the code.  For example if you\u0026apos;d like to test the code in a test database.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;DI is analogous to this in the world of Object Oriented programming.  The values there instead of constant literals are whole objects - but the reason to move the code creating them out from the class code is similar - the objects change more frequently then the code that uses them.  One important case where such a change is needed is tests.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Let\u0026apos;s try simple example with \u0026lt;strong\u0026gt;Car\u0026lt;/strong\u0026gt; and \u0026lt;strong\u0026gt;Engine\u0026lt;/strong\u0026gt; classes, any car need an engine to go anywhere, at least for now. So below how code will look without dependency injection.\u0026lt;/p\u0026gt;\n\n\n\n\u0026lt;pre class=\u0026quot;lang-csh s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;public class Car\n{\n    public \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Car\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;()\n    {\n        GasEngine engine = new GasEngine();\n        engine.Start();\n    }\n}\n\npublic class GasEngine\n{\n    public void \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Start\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;()\n    {\n        Console.WriteLine(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;I use gas as my fuel!\u0026quot;\u0026lt;/span\u0026gt;);\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And to instantiate the Car class we will use next code:\u0026lt;/p\u0026gt;\n\n\n\n\u0026lt;pre class=\u0026quot;lang-csh s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;Car car = new Car();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The issue with this code that we tightly coupled to GasEngine and if we decide to change it to ElectricityEngine then we will need to rewrite Car class. And the bigger the application the more issues and headache we will have to add and use new type of engine. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In other words with this approach is that our high level Car class is dependent on the lower level GasEngine class which violate Dependency Inversion Principle(DIP) from SOLID. DIP suggests that we should depend on abstractions, not concrete classes. So to satisfy this we introduce IEngine interface and rewrite code like below:\u0026lt;/p\u0026gt;\n\n\n\n\u0026lt;pre class=\u0026quot;lang-csh s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;    public interface IEngine\n    {\n        void Start();\n    }\n\n    public class GasEngine : IEngine\n    {\n        public void \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Start\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;()\n        {\n            Console.WriteLine(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;I use gas as my fuel!\u0026quot;\u0026lt;/span\u0026gt;);\n        }\n    }\n\n    public class ElectricityEngine : IEngine\n    {\n        public void \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Start\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;()\n        {\n            Console.WriteLine(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;I am electrocar\u0026quot;\u0026lt;/span\u0026gt;);\n        }\n    }\n\n    public class Car\n    {\n        private \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;readonly\u0026lt;/span\u0026gt; IEngine _engine;\n        public Car(IEngine engine)\n        {\n            _engine = engine;\n        }\n\n        public void \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Run\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;()\n        {\n            _engine.Start();\n        }\n    }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now our Car class is dependent on only the IEngine interface, not a specific implementation of engine. \nNow, the only trick is how do we create an instance of the Car and give it an actual concrete Engine class like GasEngine or ElectricityEngine. That\u0026apos;s where \u0026lt;strong\u0026gt;Dependency Injection\u0026lt;/strong\u0026gt; comes in. \u0026lt;/p\u0026gt;\n\n\n\n\u0026lt;pre class=\u0026quot;lang-csh s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;   Car gasCar = new Car(new GasEngine());\n   gasCar.Run();\n   Car electroCar = new Car(new ElectricityEngine());\n   electroCar.Run();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here we basically inject(pass) our dependency(Engine instance) to Car constructor. So now our classes have loose coupling between objects and their dependencies, and we can easily add new types of engines without changing the Car class.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The main benefit of the \u0026lt;strong\u0026gt;Dependency Injection\u0026lt;/strong\u0026gt; that classes are more loosely coupled, because they do not have hard-coded dependencies. This follows the Dependency Inversion Principle, which was mentioned above. Instead of referencing specific implementations, classes request abstractions (usually \u0026lt;strong\u0026gt;interfaces\u0026lt;/strong\u0026gt;) which are provided to them when the class is constructed.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;So in the end \u0026lt;strong\u0026gt;Dependency injection\u0026lt;/strong\u0026gt; is just a technique for\n  achieving loose coupling between objects and their dependencies.\n  Rather than directly instantiating dependencies that class needs in\n  order to perform its actions, dependencies are provided to the class\n  (most often) via constructor injection.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Also when we have many dependencies it is very good practice to use Inversion of Control(IoC) containers which we can tell which interfaces should be mapped to which concrete implementations for all our dependencies and we can have it resolve those dependencies for us when it constructs our object. For example, we could specify in the mapping for the IoC container that the \u0026lt;strong\u0026gt;IEngine\u0026lt;/strong\u0026gt; dependency should be mapped to the \u0026lt;strong\u0026gt;GasEngine\u0026lt;/strong\u0026gt; class and when we ask the IoC container for an instance of our \u0026lt;strong\u0026gt;Car\u0026lt;/strong\u0026gt; class, it will automatically construct our \u0026lt;strong\u0026gt;Car\u0026lt;/strong\u0026gt; class with a \u0026lt;strong\u0026gt;GasEngine\u0026lt;/strong\u0026gt; dependency passed in. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;UPDATE:\u0026lt;/strong\u0026gt; Watched course about EF Core from Julie Lerman recently and also liked her short definition about DI.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Dependency injection is a pattern to allow your application to inject\n  objects on the fly to classes that need them, without forcing those\n  classes to be responsible for those objects. It allows your code to be\n  more loosely coupled, and Entity Framework Core plugs in to this same\n  system of services.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Let\u0026apos;s imagine that you want to go fishing:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Without dependency injection, you need to take care of everything yourself. You need to find a boat, to buy a fishing rod, to look for bait, etc. It\u0026apos;s possible, of course, but it puts a lot of responsibility on you. In software terms, it means that you have to perform a lookup for all these things.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;With dependency injection, someone else takes care of all the preparation and makes the required equipment available to you. You will receive (\u0026quot;be injected\u0026quot;) the boat, the fishing rod and the bait - all ready to use.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://php-di.org/doc/understanding-di.html\u0026quot;\u0026gt;This\u0026lt;/a\u0026gt; is the most simple explanation about \u0026lt;strong\u0026gt;Dependency Injection\u0026lt;/strong\u0026gt; and \u0026lt;strong\u0026gt;Dependency Injection Container\u0026lt;/strong\u0026gt; I have ever seen:\u0026lt;/p\u0026gt;\n\n\u0026lt;h1\u0026gt;Without Dependency Injection\u0026lt;/h1\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Application needs Foo (e.g. a controller), so:\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Application creates Foo\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Application calls Foo\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Foo needs Bar (e.g. a service), so:\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Foo creates Bar\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Foo calls Bar\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Bar needs Bim (a service, a repository,\n), so:\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Bar creates Bim\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Bar does something\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;h1\u0026gt;With Dependency Injection\u0026lt;/h1\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Application needs Foo, which needs Bar, which needs Bim, so:\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Application creates Bim\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Application creates Bar and gives it Bim\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Application creates Foo and gives it Bar\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Application calls Foo\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Foo calls Bar\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Bar does something\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;h1\u0026gt;Using a Dependency Injection Container\u0026lt;/h1\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Application needs Foo so:\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Application gets Foo from the Container, so:\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Container creates Bim\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Container creates Bar and gives it Bim\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Container creates Foo and gives it Bar\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Application calls Foo\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Foo calls Bar\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Bar does something\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Dependency Injection\u0026lt;/strong\u0026gt; and \u0026lt;strong\u0026gt;dependency Injection Containers\u0026lt;/strong\u0026gt; are different things:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Dependency Injection is a method for writing better code\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;a DI Container is a tool to help injecting dependencies\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;You don\u0026apos;t need a container to do dependency injection. However a container can help you.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Before going to the technical description first visualize it with a real-life example because you will find a lot of technical stuff to learn dependency injection but the majority of the people can\u0026apos;t get the core concept of it.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In the first picture,  assume that you have a \u0026lt;strong\u0026gt;car factory\u0026lt;/strong\u0026gt; with a lot of units. A car is actually built in the \u0026lt;strong\u0026gt;assembly unit\u0026lt;/strong\u0026gt; but it needs \u0026lt;strong\u0026gt;engine\u0026lt;/strong\u0026gt;, \u0026lt;strong\u0026gt;seats\u0026lt;/strong\u0026gt; as well as \u0026lt;strong\u0026gt;wheels\u0026lt;/strong\u0026gt;. So an \u0026lt;strong\u0026gt;assembly unit\u0026lt;/strong\u0026gt; is dependent on these all units and they are the \u0026lt;strong\u0026gt;dependencies\u0026lt;/strong\u0026gt; of the factory.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;You can feel that now it is too complicated to maintain all of the tasks in this factory because along with the main task (assembling a car in the Assembly unit) you have to also focus on \u0026lt;strong\u0026gt;other units\u0026lt;/strong\u0026gt;. It is now very costly to maintain and the factory building is huge so it takes your extra bucks for rent.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Now, look at the second picture. If you find some provider companies that will provide you with the \u0026lt;strong\u0026gt;wheel\u0026lt;/strong\u0026gt;, \u0026lt;strong\u0026gt;seat\u0026lt;/strong\u0026gt;, and \u0026lt;strong\u0026gt;engine\u0026lt;/strong\u0026gt; for cheaper than your self-production cost then now you don\u0026apos;t need to make them in your factory. You can rent a smaller building now just for your \u0026lt;strong\u0026gt;assembly unit\u0026lt;/strong\u0026gt; which will lessen your maintenance task and reduce your extra rental cost. Now you can also focus only on your main task (Car assembly).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Now we can say that all the \u0026lt;strong\u0026gt;dependencies\u0026lt;/strong\u0026gt; for assembling a car are \u0026lt;strong\u0026gt;injected\u0026lt;/strong\u0026gt; on the factory from the \u0026lt;strong\u0026gt;providers\u0026lt;/strong\u0026gt;. It is an example of a real-life \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;Dependency Injection (DI)\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Now in the technical word, dependency injection is a technique whereby one object (or static method) supplies the dependencies of another object. So, transferring the task of creating the object to someone else and directly using the dependency is called dependency injection.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://www.freecodecamp.org/news/a-quick-intro-to-dependency-injection-what-it-is-and-when-to-use-it-7578c84fa88f/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;This\u0026lt;/a\u0026gt; will help you now to learn DI with a technical explanation. \u0026lt;a href=\u0026quot;http://tutorials.jenkov.com/dependency-injection/when-to-use-dependency-injection.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;This\u0026lt;/a\u0026gt; will show when to use DI and when you should \u0026lt;a href=\u0026quot;https://softwareengineering.stackexchange.com/questions/135971/when-is-it-not-appropriate-to-use-the-dependency-injection-pattern\u0026quot;\u0026gt;not\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/E7OWM.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/E7OWM.png\u0026quot; alt=\u0026quot;All in one car factory\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/auqDX.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/auqDX.png\u0026quot; alt=\u0026quot;Simple car factory\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Doesn\u0026apos;t \u0026quot;dependency injection\u0026quot; just mean using parameterized constructors and public setters?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://www.jamesshore.com/Blog/Dependency-Injection-Demystified.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;James Shore\u0026apos;s article shows the following examples for comparison\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Constructor without dependency injection:\u0026lt;/p\u0026gt;\n  \n  \n\n\u0026lt;pre class=\u0026quot;lang-csh s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;public class Example { \n  private DatabaseThingie myDatabase; \n\n  public \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Example\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;() { \n    myDatabase = new DatabaseThingie(); \n  } \n\n  public void \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;doStuff\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;() { \n    ... \n    myDatabase.getData(); \n    ... \n  } \n} \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n  \n  \u0026lt;p\u0026gt;Constructor with dependency injection:\u0026lt;/p\u0026gt;\n  \n  \n\n\u0026lt;pre class=\u0026quot;lang-csh s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;public class Example { \n  private DatabaseThingie myDatabase; \n\n  public Example(DatabaseThingie useThisDatabaseInstead) { \n    myDatabase = useThisDatabaseInstead; \n  }\n\n  public void \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;doStuff\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;() { \n    ... \n    myDatabase.getData(); \n    ... \n  } \n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;To make Dependency Injection concept simple to understand. Let\u0026apos;s take an example of switch button to toggle(on/off) a bulb.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Without Dependency Injection\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Switch needs to know beforehand which bulb I am connected to (hard-coded dependency). So,\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Switch -\u0026amp;gt; PermanentBulb \u0026lt;em\u0026gt;//switch is directly connected to permanent bulb, testing not possible easily\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/cIt97.jpg\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/cIt97.jpg\u0026quot; alt=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;Switch(){\nPermanentBulb = new Bulb();\nPermanentBulb.Toggle();\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h2\u0026gt;With Dependency Injection\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Switch only knows I need to turn on/off whichever Bulb is passed to me. So,\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Switch -\u0026amp;gt; Bulb1 OR Bulb2 OR NightBulb (injected dependency)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/NrXaF.jpg\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/NrXaF.jpg\u0026quot; alt=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;Switch(AnyBulb){ //pass it whichever bulb you like\nAnyBulb.Toggle();\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Modifying \u0026lt;a href=\u0026quot;http://www.jamesshore.com/Blog/Dependency-Injection-Demystified.html\u0026quot;\u0026gt;James\u0026lt;/a\u0026gt; Example for Switch and Bulb:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;public class SwitchTest { \n  TestToggleBulb() { \n    MockBulb mockbulb = new MockBulb(); \n\n    // MockBulb is a subclass of Bulb, so we can \n    // \u0026quot;inject\u0026quot; it here: \n    Switch switch = new Switch(mockBulb); \n\n    switch.ToggleBulb(); \n    mockBulb.AssertToggleWasCalled(); \n  } \n}\n\npublic class Switch { \n  private Bulb myBulb; \n\n  public Switch() { \n    myBulb = new Bulb(); \n  } \n\n  public Switch(Bulb useThisBulbInstead) { \n    myBulb = useThisBulbInstead; \n  } \n\n  public void ToggleBulb() { \n    ... \n    myBulb.Toggle(); \n    ... \n  } \n}`\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;What is Dependency Injection (DI)?\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As others have said, \u0026lt;em\u0026gt;Dependency Injection(DI)\u0026lt;/em\u0026gt; removes the responsibility of direct creation, and management of the lifespan, of other object instances upon which our class of interest (consumer class) is dependent (in the \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Class_diagram#Dependency\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;UML sense\u0026lt;/a\u0026gt;). These instances are instead passed to our consumer class, typically as constructor parameters or via property setters (the management of the dependency object instancing and passing to the consumer class is usually performed by an \u0026lt;em\u0026gt;Inversion of Control (IoC)\u0026lt;/em\u0026gt; container, but that\u0026apos;s another topic).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;DI, DIP and SOLID\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Specifically, in the paradigm of Robert C Martin\u0026apos;s \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;SOLID principles of Object Oriented Design\u0026lt;/a\u0026gt;, \u0026lt;code\u0026gt;DI\u0026lt;/code\u0026gt; is one of the possible implementations of the \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Dependency_inversion_principle\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Dependency Inversion Principle (DIP)\u0026lt;/a\u0026gt;. The \u0026lt;a href=\u0026quot;https://stackoverflow.com/q/27978841/314291\u0026quot;\u0026gt;DIP is the \u0026lt;code\u0026gt;D\u0026lt;/code\u0026gt; of the \u0026lt;code\u0026gt;SOLID\u0026lt;/code\u0026gt; mantra\u0026lt;/a\u0026gt;  - other DIP implementations include the Service Locator, and Plugin patterns.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The objective of the DIP is to decouple tight, concrete dependencies between classes, and instead, to loosen the coupling by means of an abstraction, which can be achieved via an \u0026lt;code\u0026gt;interface\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;abstract class\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;pure virtual class\u0026lt;/code\u0026gt;, depending on the language and approach used.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Without the DIP, our code (I\u0026apos;ve called this \u0026apos;consuming class\u0026apos;) is directly coupled to a concrete dependency and is also often burdened with the responsibility of knowing how to obtain, and manage, an instance of this dependency, i.e. conceptually:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;\u0026quot;I need to create/use a Foo and invoke method `GetBar()`\u0026quot;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Whereas after application of the DIP, the requirement is loosened, and the concern of obtaining and managing the lifespan of the \u0026lt;code\u0026gt;Foo\u0026lt;/code\u0026gt; dependency has been removed:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;\u0026quot;I need to invoke something which offers `GetBar()`\u0026quot;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Why use DIP (and DI)?\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Decoupling dependencies between classes in this way allows for \u0026lt;em\u0026gt;easy substitution\u0026lt;/em\u0026gt; of these dependency classes with other implementations which also fulfil the prerequisites of the abstraction (e.g. the dependency can be switched with another implementation of the same interface). Moreover, as others have mentioned, possibly \u0026lt;em\u0026gt;the\u0026lt;/em\u0026gt; most common reason to decouple classes via the DIP is to allow a consuming class to be tested in isolation, as these same dependencies can now be stubbed and/or mocked.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;One consequence of DI is that the lifespan management of dependency object instances is no longer controlled by a consuming class, as the dependency object is now passed into the consuming class (via constructor or setter injection).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This can be viewed in different ways:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If lifespan control of dependencies by the consuming class needs to be retained, control can be re-established by injecting an (abstract) factory for creating the dependency class instances, into the consumer class. The consumer will be able to obtain instances via a \u0026lt;code\u0026gt;Create\u0026lt;/code\u0026gt; on the factory as needed, and dispose of these instances once complete.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Or, lifespan control of dependency instances can be relinquished to an IoC container (more about this below).\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;When to use DI?\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Where there likely will be a need to substitute a dependency for an equivalent implementation, \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Any time where you will need to unit test the methods of a class in isolation of its dependencies, \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Where uncertainty of the lifespan of a dependency may warrant experimentation (e.g. Hey, \u0026lt;code\u0026gt;MyDepClass\u0026lt;/code\u0026gt; is thread safe - what if we make it a singleton and inject the same instance into all consumers?)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Example\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here\u0026apos;s a simple C# implementation. Given the below Consuming class:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;public class MyLogger\n{\n   public void LogRecord(string somethingToLog)\n   {\n      Console.WriteLine(\u0026quot;{0:HH:mm:ss} - {1}\u0026quot;, DateTime.Now, somethingToLog);\n   }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Although seemingly innocuous, it has two \u0026lt;code\u0026gt;static\u0026lt;/code\u0026gt; dependencies on two other classes, \u0026lt;code\u0026gt;System.DateTime\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;System.Console\u0026lt;/code\u0026gt;, which not only limit the logging output options (logging to console will be worthless if no one is watching), but worse, it is difficult to automatically test given the dependency on a non-deterministic system clock.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;We can however apply \u0026lt;code\u0026gt;DIP\u0026lt;/code\u0026gt; to this class, by abstracting out the the concern of timestamping as a dependency, and coupling \u0026lt;code\u0026gt;MyLogger\u0026lt;/code\u0026gt; only to a simple interface:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;public interface IClock\n{\n    DateTime Now { get; }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;We can also loosen the dependency on \u0026lt;code\u0026gt;Console\u0026lt;/code\u0026gt; to an abstraction, such as a \u0026lt;code\u0026gt;TextWriter\u0026lt;/code\u0026gt;. Dependency Injection is typically implemented as either \u0026lt;code\u0026gt;constructor\u0026lt;/code\u0026gt; injection (passing an abstraction to a dependency as a parameter to the constructor of a consuming class) or \u0026lt;code\u0026gt;Setter Injection\u0026lt;/code\u0026gt; (passing the dependency via a \u0026lt;code\u0026gt;setXyz()\u0026lt;/code\u0026gt; setter or a .Net Property with \u0026lt;code\u0026gt;{set;}\u0026lt;/code\u0026gt; defined). Constructor Injection is preferred, as this guarantees the class will be in a correct state after construction, and allows the internal dependency fields to be marked as \u0026lt;code\u0026gt;readonly\u0026lt;/code\u0026gt; (C#) or \u0026lt;code\u0026gt;final\u0026lt;/code\u0026gt; (Java). So using constructor injection on the above example, this leaves us with:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;public class MyLogger : ILogger // Others will depend on our logger.\n{\n    private readonly TextWriter _output;\n    private readonly IClock _clock;\n\n    // Dependencies are injected through the constructor\n    public MyLogger(TextWriter stream, IClock clock)\n    {\n        _output = stream;\n        _clock = clock;\n    }\n\n    public void LogRecord(string somethingToLog)\n    {\n        // We can now use our dependencies through the abstraction \n        // and without knowledge of the lifespans of the dependencies\n        _output.Write(\u0026quot;{0:yyyy-MM-dd HH:mm:ss} - {1}\u0026quot;, _clock.Now, somethingToLog);\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;(A concrete \u0026lt;code\u0026gt;Clock\u0026lt;/code\u0026gt; needs to be provided, which of course could revert to \u0026lt;code\u0026gt;DateTime.Now\u0026lt;/code\u0026gt;, and the two dependencies need to be provided by an IoC container via constructor injection)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;An automated Unit Test can be built, which definitively proves that our logger is working correctly, as we now have control over the dependencies - the time, and we can spy on the written output:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;[Test]\npublic void LoggingMustRecordAllInformationAndStampTheTime()\n{\n    // Arrange\n    var mockClock = new Mock\u0026amp;lt;IClock\u0026amp;gt;();\n    mockClock.Setup(c =\u0026amp;gt; c.Now).Returns(new DateTime(2015, 4, 11, 12, 31, 45));\n    var fakeConsole = new StringWriter();\n\n    // Act\n    new MyLogger(fakeConsole, mockClock.Object)\n        .LogRecord(\u0026quot;Foo\u0026quot;);\n\n    // Assert\n    Assert.AreEqual(\u0026quot;2015-04-11 12:31:45 - Foo\u0026quot;, fakeConsole.ToString());\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Next Steps\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Dependency injection is invariably associated with an \u0026lt;a href=\u0026quot;http://martinfowler.com/articles/injection.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Inversion of Control container(IoC)\u0026lt;/a\u0026gt;, to inject (provide) the concrete dependency instances, and to manage lifespan instances. During the configuration / bootstrapping process, \u0026lt;code\u0026gt;IoC\u0026lt;/code\u0026gt; containers allow the following to be defined:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;mapping between each abstraction and the configured concrete implementation (e.g. \u0026lt;em\u0026gt;\u0026quot;any time a consumer requests an \u0026lt;code\u0026gt;IBar\u0026lt;/code\u0026gt;, return a \u0026lt;code\u0026gt;ConcreteBar\u0026lt;/code\u0026gt; instance\u0026quot;\u0026lt;/em\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;policies can be set up for the lifespan management of each dependency, e.g. to create a new object for each consumer instance, to share a singleton dependency instance across all consumers, to share the same dependency instance only across the same thread, etc.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;In .Net, IoC containers are aware of protocols such as \u0026lt;code\u0026gt;IDisposable\u0026lt;/code\u0026gt; and will take on the responsibility of \u0026lt;code\u0026gt;Disposing\u0026lt;/code\u0026gt; dependencies in line with the configured lifespan management.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Typically, once IoC containers have been configured / bootstrapped, they operate seamlessly in the background allowing the coder to focus on the code at hand rather than worrying about dependencies.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The key to DI-friendly code is to avoid static coupling of classes, and not to use new() for the creation of Dependencies\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;As per above example, decoupling of dependencies does require some design effort, and for the developer, there is a paradigm shift needed to break the habit of \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt;ing dependencies directly, and instead trusting the container to manage dependencies. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But the benefits are many, especially in the ability to thoroughly test your class of interest.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Note\u0026lt;/strong\u0026gt; : The creation / mapping / projection (via \u0026lt;code\u0026gt;new ..()\u0026lt;/code\u0026gt;) of POCO / POJO / Serialization DTOs / Entity Graphs / Anonymous JSON projections et al - i.e. \u0026quot;Data only\u0026quot; classes or records - used or returned from methods are \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; regarded as Dependencies (in the UML sense) and not subject to DI. Using \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; to project these is just fine.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The whole point of Dependency Injection (DI) is to keep application source code \u0026lt;strong\u0026gt;clean\u0026lt;/strong\u0026gt; and \u0026lt;strong\u0026gt;stable\u0026lt;/strong\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;clean\u0026lt;/strong\u0026gt; of dependency initialization code\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;stable\u0026lt;/strong\u0026gt; regardless of dependency used\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Practically, every design pattern separates concerns to make future changes affect minimum files.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The specific domain of DI is delegation of dependency configuration and initialization.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Example: DI with shell script\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;If you occasionally work outside of Java, recall how \u0026lt;code\u0026gt;source\u0026lt;/code\u0026gt; is often used in many scripting languages (Shell, Tcl, etc., or even \u0026lt;code\u0026gt;import\u0026lt;/code\u0026gt; in Python misused for this purpose).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Consider simple \u0026lt;code\u0026gt;dependent.sh\u0026lt;/code\u0026gt; script:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;#!/bin/sh\n# Dependent\ntouch         \u0026quot;one.txt\u0026quot; \u0026quot;two.txt\u0026quot;\narchive_files \u0026quot;one.txt\u0026quot; \u0026quot;two.txt\u0026quot;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The script is dependent: it won\u0026apos;t execute successfully on its own (\u0026lt;code\u0026gt;archive_files\u0026lt;/code\u0026gt; is not defined).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You define \u0026lt;code\u0026gt;archive_files\u0026lt;/code\u0026gt; in \u0026lt;code\u0026gt;archive_files_zip.sh\u0026lt;/code\u0026gt; implementation script (using \u0026lt;code\u0026gt;zip\u0026lt;/code\u0026gt; in this case):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;#!/bin/sh\n# Dependency\nfunction archive_files {\n    zip files.zip \u0026quot;$@\u0026quot;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Instead of \u0026lt;code\u0026gt;source\u0026lt;/code\u0026gt;-ing implementation script directly in the dependent one, you use an \u0026lt;code\u0026gt;injector.sh\u0026lt;/code\u0026gt; \u0026quot;container\u0026quot; which wraps both \u0026quot;components\u0026quot;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;#!/bin/sh \n# Injector\nsource ./archive_files_zip.sh\nsource ./dependent.sh\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;archive_files\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;dependency\u0026lt;/em\u0026gt; has just been \u0026lt;em\u0026gt;injected\u0026lt;/em\u0026gt; into \u0026lt;em\u0026gt;dependent\u0026lt;/em\u0026gt; script.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You could have injected dependency which implements \u0026lt;code\u0026gt;archive_files\u0026lt;/code\u0026gt; using \u0026lt;code\u0026gt;tar\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;xz\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Example: removing DI\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;If \u0026lt;code\u0026gt;dependent.sh\u0026lt;/code\u0026gt; script used dependencies directly, the approach would be called \u0026lt;em\u0026gt;dependency lookup\u0026lt;/em\u0026gt; (which is opposite to \u0026lt;em\u0026gt;dependency injection\u0026lt;/em\u0026gt;):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;#!/bin/sh\n# Dependent\n\n# dependency look-up\nsource ./archive_files_zip.sh\n\ntouch         \u0026quot;one.txt\u0026quot; \u0026quot;two.txt\u0026quot;\narchive_files \u0026quot;one.txt\u0026quot; \u0026quot;two.txt\u0026quot;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now the problem is that dependent \u0026quot;component\u0026quot; has to perform initialization itself.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026quot;component\u0026quot;\u0026apos;s source code is neither \u0026lt;strong\u0026gt;clean\u0026lt;/strong\u0026gt; nor \u0026lt;strong\u0026gt;stable\u0026lt;/strong\u0026gt; because every changes in initialization of dependencies requires new release for \u0026quot;components\u0026quot;\u0026apos;s source code file as well.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Last words\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;DI is not as largely emphasized and popularized as in Java frameworks.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But it\u0026apos;s a generic approach to split concerns of:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;application \u0026lt;strong\u0026gt;development\u0026lt;/strong\u0026gt; (\u0026lt;strong\u0026gt;single\u0026lt;/strong\u0026gt; source code release lifecycle)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;application \u0026lt;strong\u0026gt;deployment\u0026lt;/strong\u0026gt; (\u0026lt;strong\u0026gt;multiple\u0026lt;/strong\u0026gt; target environments with independent lifecycles)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Using configuration only with \u0026lt;em\u0026gt;dependency lookup\u0026lt;/em\u0026gt; does not help as number of configuration parameters may change per dependency (e.g. new authentication type) as well as number of supported types of dependencies (e.g. new database type).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;All the above answers are good, my aim is to explain the concept in a simple way so that anyone without a programming knowledge can also understand concept\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Dependency injection is one of the design pattern that help us to create complex systems in a simpler manner.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;We can see a wide variety of application of this pattern in our day to day life.\nSome of the examples are Tape recorder, VCD, CD Drive etc.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/Ubcrh.jpg\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/Ubcrh.jpg\u0026quot; alt=\u0026quot;Reel-to-reel portable tape recorder, mid-20th century.\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The above image is an image of Reel-to-reel portable tape recorder, mid-20th century. \u0026lt;a href=\u0026quot;https://www.britannica.com/technology/tape-recorder\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Source\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The primary intention of a tape recorder machine is to record or playback sound.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;While designing a system it require a reel to record or playback sound or music. There are two possibilities for designing this system\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;we can place the reel inside the machine\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;we can provide a hook for the reel where it can be placed.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;If we use the first one we need to open the machine to change the reel.\nif we opt for the second one, that is placing a hook for reel, we are getting an added benefit of playing any music by changing the reel. and also reducing the function only to playing whatever in the reel.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Like wise dependency injection is the  process of externalizing the dependencies to focus only on the specific functionality of the component so that independent components can be coupled together to form a complex system.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The main benefits we achieved by using dependency injection.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;High cohesion and loose coupling.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Externalizing dependency and looking only on responsibility.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Making things as components and to combine to form a large systems with high capabilities.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It helps to develop high quality components since they are independently developed they are properly tested.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It helps to replace the component with another if one fails.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Now a days these concept forms the basis of well known frameworks in programming world.\nThe Spring Angular etc are the well-known software frameworks built on the top of this concept\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Dependency injection is a pattern used to create instances of objects that other objects rely upon without knowing at compile time which class will be used to provide that functionality or simply the way of injecting properties to an object is called dependency injection.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Example for Dependency injection\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Previously we are writing code like this\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;Public MyClass{\n DependentClass dependentObject\n /*\n  At somewhere in our code we need to instantiate \n  the object with new operator  inorder to use it or perform some method.\n  */ \n  dependentObject= new DependentClass();\n  dependentObject.someMethod();\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;With Dependency injection, the dependency injector will take off the instantiation for us\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;Public MyClass{\n /* Dependency injector will instantiate object*/\n DependentClass dependentObject\n\n /*\n  At somewhere in our code we perform some method. \n  The process of  instantiation will be handled by the dependency injector\n */ \n   \n  dependentObject.someMethod();\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;You can also read\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/26884881/difference-between-inversion-of-control-dependency-injection/41519414#41519414\u0026quot;\u0026gt;Difference between Inversion of Control \u0026amp;amp; Dependency Injection\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Example, we have 2 class \u0026lt;code\u0026gt;Client\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;Service\u0026lt;/code\u0026gt;. \u0026lt;code\u0026gt;Client\u0026lt;/code\u0026gt; will use \u0026lt;code\u0026gt;Service\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;public class Service {\n    public void doSomeThingInService() {\n        // ...\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h2\u0026gt;Without Dependency Injection\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Way 1)\u0026lt;/strong\u0026gt;    \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;public class Client {\n    public void doSomeThingInClient() {\n        Service service = new Service();\n        service.doSomeThingInService();\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Way 2)\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;public class Client {\n    Service service = new Service();\n    public void doSomeThingInClient() {\n        service.doSomeThingInService();\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Way 3)\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;public class Client {\n    Service service;\n    public Client() {\n        service = new Service();\n    }\n    public void doSomeThingInClient() {\n        service.doSomeThingInService();\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;1) 2) 3) Using\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;Client client = new Client();\nclient.doSomeThingInService();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Advantages\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Simple\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Disadvantages\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Hard for test \u0026lt;code\u0026gt;Client\u0026lt;/code\u0026gt; class\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;When we change \u0026lt;code\u0026gt;Service\u0026lt;/code\u0026gt; constructor, we need to change code in all place create \u0026lt;code\u0026gt;Service\u0026lt;/code\u0026gt; object\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;h2\u0026gt;Use Dependency Injection\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Way 1)\u0026lt;/strong\u0026gt; Constructor injection\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;public class Client {\n    Service service;\n\n    Client(Service service) {\n        this.service = service;\n    }\n\n    // Example Client has 2 dependency \n    // Client(Service service, IDatabas database) {\n    //    this.service = service;\n    //    this.database = database;\n    // }\n\n    public void doSomeThingInClient() {\n        service.doSomeThingInService();\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Using\u0026lt;/em\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;Client client = new Client(new Service());\n// Client client = new Client(new Service(), new SqliteDatabase());\nclient.doSomeThingInClient();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Way 2)\u0026lt;/strong\u0026gt; Setter injection\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;public class Client {\n    Service service;\n\n    public void setService(Service service) {\n        this.service = service;\n    }\n\n    public void doSomeThingInClient() {\n        service.doSomeThingInService();\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Using\u0026lt;/em\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;Client client = new Client();\nclient.setService(new Service());\nclient.doSomeThingInClient();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Way 3)\u0026lt;/strong\u0026gt; Interface injection\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Check \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Dependency_injection\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://en.wikipedia.org/wiki/Dependency_injection\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;=== \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now, this code is already follow \u0026lt;code\u0026gt;Dependency Injection\u0026lt;/code\u0026gt; and it is easier for test \u0026lt;code\u0026gt;Client\u0026lt;/code\u0026gt; class.\u0026lt;br\u0026gt;\nHowever, we still use \u0026lt;code\u0026gt;new Service()\u0026lt;/code\u0026gt; many time and it is not good when change \u0026lt;code\u0026gt;Service\u0026lt;/code\u0026gt; constructor. To prevent it, we can use DI injector like\u0026lt;br\u0026gt;\n1) Simple manual \u0026lt;code\u0026gt;Injector\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;public class Injector {\n    public static Service provideService(){\n        return new Service();\n    }\n\n    public static IDatabase provideDatatBase(){\n        return new SqliteDatabase();\n    }\n    public static ObjectA provideObjectA(){\n        return new ObjectA(provideService(...));\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Using\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;Service service = Injector.provideService();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;2) Use library: For Android \u0026lt;a href=\u0026quot;https://github.com/google/dagger\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;dagger2\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Advantages\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Make test easier\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;When you change the \u0026lt;code\u0026gt;Service\u0026lt;/code\u0026gt;, you only need to change it in Injector class\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If you use use \u0026lt;code\u0026gt;Constructor Injection\u0026lt;/code\u0026gt;, when you look at constructor of \u0026lt;code\u0026gt;Client\u0026lt;/code\u0026gt;, you will see how many dependency of \u0026lt;code\u0026gt;Client\u0026lt;/code\u0026gt; class\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Disadvantages\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If you use use \u0026lt;code\u0026gt;Constructor Injection\u0026lt;/code\u0026gt;, the \u0026lt;code\u0026gt;Service\u0026lt;/code\u0026gt; object is created when \u0026lt;code\u0026gt;Client\u0026lt;/code\u0026gt; created, sometime we use function in \u0026lt;code\u0026gt;Client\u0026lt;/code\u0026gt; class without use \u0026lt;code\u0026gt;Service\u0026lt;/code\u0026gt; so created \u0026lt;code\u0026gt;Service\u0026lt;/code\u0026gt; is wasted\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;h3\u0026gt;Dependency Injection definition\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Dependency_injection\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://en.wikipedia.org/wiki/Dependency_injection\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;A dependency is an object that can be used (\u0026lt;code\u0026gt;Service\u0026lt;/code\u0026gt;)\u0026lt;br\u0026gt;\n  An injection is the passing of a dependency (\u0026lt;code\u0026gt;Service\u0026lt;/code\u0026gt;) to a dependent object (\u0026lt;code\u0026gt;Client\u0026lt;/code\u0026gt;) that would use it\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;What is dependency Injection?\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Dependency Injection(DI) means to decouple the objects which are dependent on each other. Say object A is dependent on Object B so the idea is to decouple these object from each other. We dont need to hard code the object using new keyword rather sharing dependencies to objects at runtime in spite of compile time.\nIf we talk about \u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;How Dependency Injection works in Spring:\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;We dont need to hard code the object using new keyword rather define the bean dependency in the configuration file. The spring container will be responsible for hooking up all.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Inversion of Control (IOC)\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;IOC is a general concept and it can be expressed in many different ways and Dependency Injection is one concrete example of IOC.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Two types of Dependency Injection:\u0026lt;/h2\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Constructor Injection\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Setter Injection\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;h2\u0026gt;1.    Constructor-based dependency injection:\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Constructor-based DI is accomplished when the container invokes a class constructor with a number of arguments, each representing a dependency on other class.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;public class Triangle {\n\nprivate String type;\n\npublic String getType(){\n    return type;\n }\n\npublic Triangle(String type){   //constructor injection\n    this.type=type;\n }\n}\n\u0026amp;lt;bean id=triangle\u0026quot; class =\u0026quot;com.test.dependencyInjection.Triangle\u0026quot;\u0026amp;gt;\n        \u0026amp;lt;constructor-arg value=\u0026quot;20\u0026quot;/\u0026amp;gt;\n  \u0026amp;lt;/bean\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h2\u0026gt;2.    Setter-based dependency injection:\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Setter-based DI is accomplished by the container calling setter methods on your beans after invoking a no-argument constructor or no-argument static factory method to instantiate your bean.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;public class Triangle{\n\n private String type;\n\n public String getType(){\n    return type;\n  }\n public void setType(String type){          //setter injection\n    this.type = type;\n  }\n }\n\n\u0026amp;lt;!-- setter injection --\u0026amp;gt;\n \u0026amp;lt;bean id=\u0026quot;triangle\u0026quot; class=\u0026quot;com.test.dependencyInjection.Triangle\u0026quot;\u0026amp;gt;\n        \u0026amp;lt;property name=\u0026quot;type\u0026quot; value=\u0026quot;equivialteral\u0026quot;/\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;NOTE:\nIt is a good rule of thumb to use constructor arguments for mandatory dependencies and setters for optional dependencies. Note that the if we use annotation based than @Required annotation on a setter can be used to make setters as a required dependencies.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The best analogy I can think of is the surgeon and his assistant(s) in an operation theater, where the surgeon is the main person and his assistant who provides the various surgical components when he needs it so that the surgeon can concentrate on the one thing he does best (surgery). Without the assistant the surgeon has to get the components himself every time he needs one.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;DI for short, is a technique to remove a common additional responsibility (burden) on components to fetch the dependent components, by providing them to it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;DI brings you closer to the Single Responsibility (SR) principle, like the \u0026lt;code\u0026gt;surgeon who can concentrate on surgery\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When to use DI : I would recommend using DI in almost all production projects ( small/big), particularly in ever changing business environments :)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Why : Because you want your code to be easily testable, mockable etc so that you can quickly test your changes and push it to the market. Besides why would you not when you there are lots of awesome free tools/frameworks to support you in your journey to a codebase where you have more control.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It means that objects should only have as many dependencies as is needed to do their job and the dependencies should be few. Furthermore, an objects dependencies should be on interfaces and not on concrete objects, when possible. (A concrete object is any object created with the keyword new.) Loose coupling promotes greater reusability, easier maintainability, and allows you to easily provide mock objects in place of expensive services.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The Dependency Injection (DI) is also known as Inversion of Control (IoC), can be used as a technique for encouraging this loose coupling.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There are two primary approaches to implementing DI:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Constructor injection \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Setter injection\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;h2\u0026gt;Constructor injection\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Its the technique of passing objects dependencies to its constructor.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note that the constructor accepts an interface and not concrete object. Also, note that an exception is thrown if the orderDao parameter is null. This emphasizes the importance of receiving a valid dependency. Constructor Injection is, in my opinion, the preferred mechanism for giving an object its dependencies. It is clear to the developer while invoking the object which dependencies need to be given to the Person object for proper execution.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Setter Injection\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;But consider the following example Suppose you have a class with ten methods that have no dependencies, but youre adding a new method that does have a dependency on IDAO. You could change the constructor to use Constructor Injection, but this may force you to changes to all constructor calls all over the place. Alternatively, you could just add a new constructor that takes the dependency, but then how does a developer easily know when to use one constructor over the other. Finally, if the dependency is very expensive to create, why should it be created and passed to the constructor when it may only be used rarely? Setter Injection is another DI technique that can be used in situations such as this.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Setter Injection does not force dependencies to be passed to the constructor. Instead, the dependencies are set onto public properties exposed by the object in need. As implied previously, the primary motivators for doing this include:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Supporting dependency injection without having to modify the constructor of a legacy class.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Allowing expensive resources or services to be created as late as possible and only when needed.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;Here is the example of how the above code would look like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;public class Person {\n    public Person() {}\n\n    public IDAO Address {\n        set { addressdao = value; }\n        get {\n            if (addressdao == null)\n              throw new MemberAccessException(\u0026quot;addressdao\u0026quot; +\n                             \u0026quot; has not been initialized\u0026quot;);\n            return addressdao;\n        }\n    }\n\n    public Address GetAddress() {\n       // ... code that uses the addressdao object\n       // to fetch address details from the datasource ...\n    }\n\n    // Should not be called directly;\n    // use the public property instead\n    private IDAO addressdao;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I know there are already many answers, but I found this very helpful: \u0026lt;a href=\u0026quot;http://tutorials.jenkov.com/dependency-injection/index.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;http://tutorials.jenkov.com/dependency-injection/index.html\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;No Dependency:\u0026lt;/h3\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MyDao\u0026lt;/span\u0026gt; {\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;protected\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;DataSource\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;dataSource\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;DataSourceImpl\u0026lt;/span\u0026gt;(\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;driver\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;url\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;user\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;password\u0026quot;\u0026lt;/span\u0026gt;);\n\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//data access methods...\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Person \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;readPerson\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; primaryKey)\u0026lt;/span\u0026gt; {...}     \n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h3\u0026gt;Dependency:\u0026lt;/h3\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MyDao\u0026lt;/span\u0026gt; {\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;protected\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;DataSource\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;dataSource\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;MyDao\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String driver, String url, String user, String password)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.dataSource = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;DataSourceImpl\u0026lt;/span\u0026gt;(driver, url, user, password);\n  }\n\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//data access methods...\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Person \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;readPerson\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; primaryKey)\u0026lt;/span\u0026gt; {...}\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Notice how the \u0026lt;code\u0026gt;DataSourceImpl\u0026lt;/code\u0026gt; instantiation is moved into a constructor. The constructor takes four parameters which are the four values needed by the \u0026lt;code\u0026gt;DataSourceImpl\u0026lt;/code\u0026gt;. Though the \u0026lt;code\u0026gt;MyDao\u0026lt;/code\u0026gt; class still depends on these four values, it no longer satisfies these dependencies itself. They are provided by whatever class creating a \u0026lt;code\u0026gt;MyDao\u0026lt;/code\u0026gt; instance.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I think since everyone has written for DI, let me ask a few questions..\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;When you have a configuration of DI where all the actual implementations(not interfaces) that are going to be injected into a class (for e.g services to a controller) why is that not some sort of hard-coding? \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;What if I want to change the object at runtime? For example, my config already says when I instantiate MyController, inject for FileLogger as ILogger. But I might want to inject DatabaseLogger. \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Every time I want to change what objects my AClass needs, I need to now look into two places - The class itself and the configuration file. How does that make life easier?\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If Aproperty of AClass is not injected, is it harder to mock it out? \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Going back to the first question. If using new object() is bad, how come we inject the implementation and not the interface? I think a lot of you are saying we\u0026apos;re in fact injecting the interface but the configuration makes you specify the implementation of that interface ..not at runtime .. it is hardcoded during compile time.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;This is based on the answer @Adam N posted.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Why does PersonService no longer have to worry about GroupMembershipService? You just mentioned GroupMembership has multiple things(objects/properties) it depends on. If GMService was required in PService, you\u0026apos;d have it as a property. You can mock that out regardless of whether you injected it or not. The only time I\u0026apos;d like it to be injected is if GMService had more specific child classes, which you wouldn\u0026apos;t know until runtime. Then you\u0026apos;d want to inject the subclass. Or if you wanted to use that as either singleton or prototype. To be honest, the configuration file has everything hardcoded as far as what subclass for a type (interface) it is going to inject during compile time.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;EDIT\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://dzone.com/articles/dependency-injection-makes\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;A nice comment by Jose Maria Arranz on DI\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;DI increases cohesion by removing any need to determine the direction of dependency and write any glue code.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;False. The direction of dependencies is in XML form or as annotations, your dependencies are written as XML code and annotations. XML and annotations ARE source code.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;DI reduces coupling by making all of your components modular (i.e. replaceable) and have well-defined interfaces to each other.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;False. You do not need a DI framework to build a modular code based on interfaces.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;About replaceable: with a very simple .properties archive and Class.forName you can define which classes can change. If ANY class of your code can be changed, Java is not for you, use an scripting language.  By the way: annotations cannot be changed without recompiling.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In my opinion there is one only reason for DI frameworks: boiler plate reduction. With a well done factory system you can do the same, more controlled and more predictable as your preferred DI framework, DI frameworks promise code reduction (XML and annotations are source code too). The problem is this boiler plate reduction is just real in very very simple cases (one instance-per class and similar), sometimes in the real world picking the appropriated service object is not as easy as mapping a class to a singleton object.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The popular answers are unhelpful, because they define dependency injection in a way that isn\u0026apos;t useful. Let\u0026apos;s agree that by \u0026quot;dependency\u0026quot; we mean some pre-existing other object that our object X needs. But we don\u0026apos;t say we\u0026apos;re doing \u0026quot;dependency injection\u0026quot; when we say\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;$foo = Foo-\u0026amp;gt;new($bar);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;We just call that passing parameters into the constructor. We\u0026apos;ve been doing that regularly ever since constructors were invented.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026quot;Dependency injection\u0026quot; is considered a type of \u0026quot;inversion of control\u0026quot;, which means that some logic is taken out of the caller. That isn\u0026apos;t the case when the caller passes in parameters, so if that were DI, DI would not imply inversion of control.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;DI means there is an intermediate level between the caller and the constructor which manages dependencies. A Makefile is a simple example of dependency injection. The \u0026quot;caller\u0026quot; is the person typing \u0026quot;make bar\u0026quot; on the command line, and the \u0026quot;constructor\u0026quot; is the compiler. The Makefile specifies that bar depends on foo, and it does a\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;gcc -c foo.cpp; gcc -c bar.cpp\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;before doing a\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;gcc foo.o bar.o -o bar\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The person typing \u0026quot;make bar\u0026quot; doesn\u0026apos;t need to know that bar depends on foo. The dependency was injected between \u0026quot;make bar\u0026quot; and gcc.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The main purpose of the intermediate level is not just to pass in the dependencies to the constructor, but to list all the dependencies in \u0026lt;em\u0026gt;just one place\u0026lt;/em\u0026gt;, and to hide them from the coder (not to make the coder provide them).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Usually the intermediate level provides factories for the constructed objects, which must provide a role that each requested object type must satisfy. That\u0026apos;s because by having an intermediate level that hides the details of construction, you\u0026apos;ve already incurred the abstraction penalty imposed by factories, so you might as well use factories.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Dependency_injection\u0026quot;\u0026gt;Dependency Injection\u0026lt;/a\u0026gt; means a way (actually \u0026lt;strong\u0026gt;any-way\u0026lt;/strong\u0026gt;) for one part of code (e.g a class) to have access to dependencies (other parts of code, e.g other classes, it depends upon) in a modular way without them being hardcoded (so they can change or be overriden freely, or even be loaded at another time, as needed)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;(and ps , yes it has become an overly-hyped 25$ name for a rather simple, concept)\u0026lt;/em\u0026gt;, my \u0026lt;code\u0026gt;.25\u0026lt;/code\u0026gt; cents\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;From the Book, \u0026apos;\u0026lt;a href=\u0026quot;https://rads.stackoverflow.com/amzn/click/com/1617290068\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Well-Grounded Java Developer: Vital techniques of Java 7 and polyglot programming\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;DI is a particular form of IoC, whereby the process of finding your dependencies is\n  outside the direct control of your currently executing code.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Dependency injection is one possible solution to what could generally be termed the \u0026quot;Dependency Obfuscation\u0026quot; requirement. Dependency Obfuscation is a method of taking the \u0026apos;obvious\u0026apos; nature out of the process of providing a dependency to a class that requires it and therefore obfuscating, in some way, the provision of said dependency to said class. This is not necessarily a bad thing. In fact, by obfuscating the manner by which a dependency is provided to a class then something outside the class is responsible for creating the dependency which means, in various scenarios, a different implementation of the dependency can be supplied to the class without making any changes to the class. This is great for switching between production and testing modes (eg., using a \u0026apos;mock\u0026apos; service dependency).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Unfortunately the bad part is that some people have assumed you need a specialized framework to do dependency obfuscation and that you are somehow a \u0026apos;lesser\u0026apos; programmer if you choose not to use a particular framework to do it. Another, extremely disturbing myth, believed by many, is that dependency injection is the only way of achieving dependency obfuscation. This is demonstrably and historically and obviously 100% wrong but you will have trouble convincing some people that there are alternatives to dependency injection for your dependency obfuscation requirements.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Programmers have understood the dependency obfuscation requirement for years and many alternative solutions have evolved both before and after dependency injection was conceived. There are Factory patterns but there are also many options using ThreadLocal where no injection to a particular instance is needed - the dependency is effectively injected into the thread which has the benefit of making the object available (via convenience static getter methods) to \u0026lt;em\u0026gt;any\u0026lt;/em\u0026gt; class that requires it without having to add annotations to the classes that require it and set up intricate XML \u0026apos;glue\u0026apos; to make it happen. When your dependencies are required for persistence (JPA/JDO or whatever) it allows you to achieve \u0026apos;tranaparent persistence\u0026apos; much easier and with domain model and business model classes made up purely of POJOs (i.e. no framework specific/locked in annotations).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Dependency Injection for 5 year olds.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When you go and get things out of the refrigerator for yourself, you can cause problems. You might leave the door open, you might get something Mommy or Daddy doesn\u0026apos;t want you to have. You might be even looking for something we don\u0026apos;t even have or which has expired.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;What you should be doing is stating a need, \u0026quot;I need something to drink with lunch,\u0026quot; and then we will make sure you have something when you sit down to eat.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In simple words dependency injection (DI) is the way to remove dependencies or tight coupling between different object. Dependency Injection gives a cohesive behavior to each object. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;DI is the implementation of IOC principal of Spring which says \u0026quot;Don\u0026apos;t call us we will call you\u0026quot;. Using dependency injection programmer doesn\u0026apos;t need to create object using the new keyword. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Objects are once loaded in Spring container and then we reuse them whenever we need them by fetching those objects from Spring container using getBean(String beanName) method.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;from Book \u0026lt;strong\u0026gt;Apress.Spring.Persistence.with.Hibernate.Oct.2010\u0026lt;/strong\u0026gt;\u0026lt;br\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The purpose of dependency injection is to decouple the work of\n  resolving external software components from your application business\n  logic.Without dependency injection, the details of how a component\n  accesses required services can get muddled in with the components\n  code. This not only increases the potential for errors, adds code\n  bloat, and magnifies maintenance complexities; it couples components\n  together more closely, making it difficult to modify dependencies when\n  refactoring or testing.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Dependency Injection (DI) is part of Dependency Inversion Principle (DIP) practice, which is also called Inversion of Control (IoC). Basically you need to do DIP because you want to make your code more modular and unit testable, instead of just one monolithic system. So you start identifying parts of the code that can be separated from the class and abstracted away. Now the implementation of the abstraction need to be injected from outside of the class. Normally this can be done via constructor. So you create a constructor that accepts the abstraction as a parameter, and this is called dependency injection (via constructor). For more explanation about DIP, DI, and IoC container you can read \u0026lt;a href=\u0026quot;http://kusnaditjung.blogspot.co.uk/2016/05/dependency-inversion-principle-dip.html\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;Here\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Dependency Injection (DI) is one from Design Patterns, which uses the basic feature of OOP - the relationship in one object with another object. While inheritance inherits one object to do more complex and specific another object, relationship or association simply creates a pointer to another object from one object using attribute. The power of DI is in combination with other features of OOP as are interfaces and hiding code.\nSuppose, we have a customer (subscriber) in the library, which can borrow only one book for simplicity.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Interface of book:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;package com.deepam.hidden;\n\npublic interface BookInterface {\n\npublic BookInterface setHeight(int height);\npublic BookInterface setPages(int pages);   \npublic int getHeight();\npublic int getPages();  \n\npublic String toString();\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Next we can have many kind of books; one of type is fiction:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;package com.deepam.hidden;\n\npublic class FictionBook implements BookInterface {\nint height = 0; // height in cm\nint pages = 0; // number of pages\n\n/** constructor */\npublic FictionBook() {\n    // TODO Auto-generated constructor stub\n}\n\n@Override\npublic FictionBook setHeight(int height) {\n  this.height = height;\n  return this;\n}\n\n@Override\npublic FictionBook setPages(int pages) {\n  this.pages = pages;\n  return this;      \n}\n\n@Override\npublic int getHeight() {\n    // TODO Auto-generated method stub\n    return height;\n}\n\n@Override\npublic int getPages() {\n    // TODO Auto-generated method stub\n    return pages;\n}\n\n@Override\npublic String toString(){\n    return (\u0026quot;height: \u0026quot; + height + \u0026quot;, \u0026quot; + \u0026quot;pages: \u0026quot; + pages);\n}\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now subscriber can have association to the book:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;package com.deepam.hidden;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\n\npublic class Subscriber {\nBookInterface book;\n\n/** constructor*/\npublic Subscriber() {\n    // TODO Auto-generated constructor stub\n}\n\n// injection I\npublic void setBook(BookInterface book) {\n    this.book = book;\n}\n\n// injection II\npublic BookInterface setBook(String bookName) {\n    try {\n        Class\u0026amp;lt;?\u0026amp;gt; cl = Class.forName(bookName);\n        Constructor\u0026amp;lt;?\u0026amp;gt; constructor = cl.getConstructor(); // use it for parameters in constructor\n        BookInterface book = (BookInterface) constructor.newInstance();\n        //book = (BookInterface) Class.forName(bookName).newInstance();\n    } catch (InstantiationException e) {\n        e.printStackTrace();\n    } catch (IllegalAccessException e) {\n        e.printStackTrace();\n    } catch (ClassNotFoundException e) {\n        e.printStackTrace();\n    } catch (NoSuchMethodException e) {\n        e.printStackTrace();\n    } catch (SecurityException e) {\n        e.printStackTrace();\n    } catch (IllegalArgumentException e) {\n        e.printStackTrace();\n    } catch (InvocationTargetException e) {\n        e.printStackTrace();\n    }\n    return book;\n}\n\npublic BookInterface getBook() {\n  return book;\n}\n\npublic static void main(String[] args) {\n\n}\n\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;All the three classes can be hidden for it\u0026apos;s own implementation. Now we can use this code for DI:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;package com.deepam.implement;\n\nimport com.deepam.hidden.Subscriber;\nimport com.deepam.hidden.FictionBook;\n\npublic class CallHiddenImplBook {\n\npublic CallHiddenImplBook() {\n    // TODO Auto-generated constructor stub\n}\n\npublic void doIt() {\n    Subscriber ab = new Subscriber();\n\n    // injection I\n    FictionBook bookI = new FictionBook();\n    bookI.setHeight(30); // cm\n    bookI.setPages(250);\n    ab.setBook(bookI); // inject\n    System.out.println(\u0026quot;injection I \u0026quot; + ab.getBook().toString());\n\n    // injection II\n    FictionBook bookII = ((FictionBook) ab.setBook(\u0026quot;com.deepam.hidden.FictionBook\u0026quot;)).setHeight(5).setPages(108); // inject and set\n    System.out.println(\u0026quot;injection II \u0026quot; + ab.getBook().toString());      \n}\n\npublic static void main(String[] args) {\n    CallHiddenImplBook kh = new CallHiddenImplBook();\n    kh.doIt();\n}\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;There are many different ways how to use dependency injection. It is possible to combine it with Singleton, etc., but still in basic it is only association realized by creating attribute of object type inside another object.\nThe usefulness is only and only in feature, that code, which we should write again and again is always prepared and done for us forward. This is why DI so closely binded with Inversion of Control (IoC) which means, that our program passes control another running module, which does injections of beans to our code. (Each object, which can be injected can be signed or considered as a Bean.) For example in Spring it is done by creating and initialization \u0026lt;em\u0026gt;ApplicationContext\u0026lt;/em\u0026gt; container, which does this work for us. We simply in our code create the Context and invoke initialization the beans. In that moment injection has been done automatically.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I would propose a slightly different, short and precise definition of what Dependency Injection is, focusing on the primary goal, not on the technical means (following along from \u0026lt;a href=\u0026quot;https://blog.softwaremill.com/what-is-dependency-injection-8c9e7805502f\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt;):\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Dependency Injection is the process of creating the static, stateless\n  graph of service objects, where each service is parametrised by its\n  dependencies.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;The objects that we create in our applications (regardless if we use Java, C# or other object-oriented language) usually fall into one of two categories: stateless, static and global service objects (modules), and stateful, dynamic and local data objects.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The module graph - the graph of service objects - is typically created on application startup. This can be done using a container, such as Spring, but can also be done manually, by passing parameters to object constructors. Both ways have their pros and cons, but a framework definitely isnt necessary to use DI in your application.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;One requirement is that the services must be parametrised by their dependencies. What this means exactly depends on the language and approach taken in a given system. Usually, this takes the form of constructor parameters, but using setters is also an option. This also means that the dependencies of a service are hidden (when invoking a service method) from the users of the service.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When to use? I would say whenever the application is large enough that encapsulating logic into separate modules, with a dependency graph between the modules gives a gain in readability and explorability of the code.\u0026lt;/p\u0026gt;\n    "],"id":428,"title":"What is dependency injection?","slug":"what-is-dependency-injection-1657387953056","postType":"QUESTION","createdAt":"2022-07-09T17:32:33.000Z","updatedAt":"2022-07-09T17:32:33.000Z","tags":[{"id":2249,"name":"dependency-injection","slug":"dependency-injection","createdAt":"2022-07-09T17:32:33.000Z","updatedAt":"2022-07-09T17:32:33.000Z","Questions_Tags":{"questionId":428,"tagId":2249}}]}]}},"__N_SSG":true},"page":"/questions/tag/[slug]","query":{"slug":"dependency-injection"},"buildId":"6_hwtyf_oFlFS5l_S4CTe","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>