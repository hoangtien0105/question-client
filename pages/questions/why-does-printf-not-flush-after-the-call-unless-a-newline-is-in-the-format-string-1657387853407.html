<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2eccd4d47c856f2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2eccd4d47c856f2b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/471-84c36aa98dd4107c.js" defer=""></script><script src="/_next/static/chunks/81-301f760ac8107464.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-76d2c3e2d98bb08b.js" defer=""></script><script src="/_next/static/6_hwtyf_oFlFS5l_S4CTe/_buildManifest.js" defer=""></script><script src="/_next/static/6_hwtyf_oFlFS5l_S4CTe/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.eZIPKL code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-c4b0431a-0"]{content:"eZIPKL,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="https://flowbite.com/docs/images/logo.svg" class="mr-3 h-6 sm:h-9" alt="Flowbite Logo"/><span class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Hunter</span></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/why-does-printf-not-flush-after-the-call-unless-a-newline-is-in-the-format-string-1657387853407#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-c4b0431a-0 eZIPKL flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/why-does-printf-not-flush-after-the-call-unless-a-newline-is-in-the-format-string-1657387853407">Why does printf not flush after the call unless a newline is in the format string?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/printf">printf</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/flush">flush</a></div></div><div class="question-content mt-5">
                
<p>Why does <code>printf</code> not flush after the call unless a newline is in the format string? Is this POSIX behavior? How might I have <code>printf</code> immediately flush every time?</p>
    </div></div></div><div class="sc-c4b0431a-2 cRqwQe"><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The <code>stdout</code> stream is line buffered by default, so will only display what's in the buffer after it reaches a newline (or when it's told to). You have a few options to print immediately:</p>
<ul>
<li><p>Print to <code>stderr</code>instead using <code>fprintf</code> (<code>stderr</code> is <a href="http://man7.org/linux/man-pages/man3/setbuf.3.html#DESCRIPTION" rel="nofollow noreferrer">unbuffered by default</a>):</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"I will be printed immediately"</span>);
</code></pre>
</li>
<li><p>Flush <code>stdout</code> whenever you need it to using <code>fflush</code>:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"Buffered, will be flushed"</span>);
fflush(<span class="hljs-built_in">stdout</span>); <span class="hljs-comment">// Will now print everything in the stdout buffer</span>
</code></pre>
</li>
<li><p>Disable buffering on stdout by using <code>setbuf</code>:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);
</code></pre>
</li>
<li><p>Or use the more flexible <a href="https://en.cppreference.com/w/c/io/setvbuf" rel="nofollow noreferrer"><code>setvbuf</code></a>:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>, _IONBF, <span class="hljs-number">0</span>); 
</code></pre>
</li>
</ul>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>No, it's not POSIX behaviour, it's ISO behaviour (well, it <em>is</em> POSIX behaviour but only insofar as they conform to ISO).</p>
<p>Standard output is line buffered if it can be detected to refer to an interactive device, otherwise it's fully buffered. So there are situations where <code>printf</code> won't flush, even if it gets a newline to send out, such as:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">myprog &gt;myfile.txt
</code></pre>
<p>This makes sense for efficiency since, if you're interacting with a user, they probably want to see every line. If you're sending the output to a file, it's most likely that there's not a user at the other end (though not impossible, they could be tailing the file). Now you <em>could</em> argue that the user wants to see every character but there are two problems with that.</p>
<p>The first is that it's not very efficient. The second is that the original ANSI C mandate was to primarily codify <em>existing</em> behaviour, rather than invent <em>new</em> behaviour, and those design decisions were made long before ANSI started the process. Even ISO nowadays treads very carefully when changing existing rules in the standards.</p>
<p>As to how to deal with that, if you <code>fflush (stdout)</code> after every output call that you want to see immediately, that will solve the problem.</p>
<p>Alternatively, you can use <code>setvbuf</code> before operating on <code>stdout</code>, to set it to unbuffered and you won't have to worry about adding all those <code>fflush</code> lines to your code:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">setvbuf (<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>, _IONBF, BUFSIZ);
</code></pre>
<p>Just keep in mind that may affect performance quite a bit if you <em>are</em> sending the output to a file. Also keep in mind that support for this is implementation-defined, not guaranteed by the standard.</p>
<p>ISO C99 section <code>7.19.3/3</code> is the relevant bit:</p>
<blockquote>
<p>When a stream is <em>unbuffered</em>, characters are intended to appear from the source or at the destination as soon as possible. Otherwise characters may be accumulated and transmitted to or from the host environment as a block.</p>
<p>When a stream is <em>fully buffered</em>, characters are intended to be transmitted to or from the host environment as a block when a buffer is filled.</p>
<p>When a stream is <em>line buffered</em>, characters are intended to be transmitted to or from the host environment as a block when a new-line character is encountered.</p>
<p>Furthermore, characters are intended to be transmitted as a block to the host environment when a buffer is filled, when input is requested on an unbuffered stream, or when input is requested on a line buffered stream that requires the transmission of characters from the host environment.</p>
<p>Support for these characteristics is implementation-defined, and may be affected via the <code>setbuf</code> and <code>setvbuf</code> functions.</p>
</blockquote>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>To immediately flush call <code>fflush(stdout)</code> or <code>fflush(NULL)</code> (<code>NULL</code> means flush everything).</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It's probably like that because of efficiency and because if you have multiple programs writing to a single TTY, this way you don't get characters on a line interlaced. So if program A and B are outputting, you'll usually get:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">program A output
program B output
program B output
program A output
program B output
</code></pre>

<p>This stinks, but it's better than</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">proprogrgraam m AB  ououtputputt
prproogrgram amB A  ououtputtput
program B output
</code></pre>

<p>Note that it isn't even guaranteed to flush on a newline, so you should flush explicitly if flushing matters to you.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Note: Microsoft runtime libraries do not support line buffering, so <code>printf("will print immediately to terminal")</code>:</p>

<p><a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/setvbuf" rel="nofollow noreferrer">https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/setvbuf</a></p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>stdout is buffered, so will only output after a newline is printed.</p>

<p>To get immediate output, either:</p>

<ol>
<li>Print to stderr.</li>
<li>Make stdout unbuffered.</li>
</ol>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>by default, stdout is line buffered, stderr is none buffered and file is completely buffered.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You can fprintf to stderr, which is unbuffered, instead.  Or you can flush stdout when you want to.  Or you can set stdout to unbuffered.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Use <code>setbuf(stdout, NULL);</code> to disable buffering.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There are generally 2 levels of buffering-</p>

<p><strong>1. Kernel buffer Cache (makes read/write faster)</strong></p>

<p><strong>2. Buffering in I/O library (reduces no. of system calls)</strong></p>

<p>Let's take example of <code>fprintf and write()</code>.</p>

<p>When you call <code>fprintf()</code>, it doesn't wirte directly to the file. It first goes to stdio buffer in the program's memory. From there it is written to the kernel buffer cache by using write system call. So one way to skip I/O buffer is directly using write(). Other ways are by using <code>setbuff(stream,NULL)</code>. This sets the buffering mode to no buffering and data is directly written to kernel buffer.
To forcefully make the data to be shifted to kernel buffer, we can use "\n", which in case of default buffering mode of 'line buffering', will flush I/O buffer.
Or we can use <code>fflush(FILE *stream)</code>.</p>

<p>Now we are in kernel buffer. Kernel(/OS) wants to minimise disk access time and hence it reads/writes only blocks of disk. So when a <code>read()</code> is issued, which is a system call and can be invoked directly or through <code>fscanf()</code>, kernel reads the disk block from disk and stores it in a buffer. After that data is copied from here to user space.</p>

<p>Similarly that <code>fprintf()</code> data recieved from I/O buffer is written to the disk by the kernel. This makes read() write() faster.</p>

<p>Now to force the kernel to initiate a <code>write()</code>, after which data transfer is controlled by hardware controllers, there are also some ways. We can use <code>O_SYNC</code> or similar flags during write calls. Or we could use other functions like <code>fsync(),fdatasync(),sync()</code> to make the kernel initiate writes as soon as data is available in the kernel buffer.</p>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;stdout\u0026lt;/code\u0026gt; stream is line buffered by default, so will only display what\u0026apos;s in the buffer after it reaches a newline (or when it\u0026apos;s told to). You have a few options to print immediately:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Print to \u0026lt;code\u0026gt;stderr\u0026lt;/code\u0026gt;instead using \u0026lt;code\u0026gt;fprintf\u0026lt;/code\u0026gt; (\u0026lt;code\u0026gt;stderr\u0026lt;/code\u0026gt; is \u0026lt;a href=\u0026quot;http://man7.org/linux/man-pages/man3/setbuf.3.html#DESCRIPTION\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;unbuffered by default\u0026lt;/a\u0026gt;):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fprintf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stderr\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;I will be printed immediately\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Flush \u0026lt;code\u0026gt;stdout\u0026lt;/code\u0026gt; whenever you need it to using \u0026lt;code\u0026gt;fflush\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Buffered, will be flushed\u0026quot;\u0026lt;/span\u0026gt;);\nfflush(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stdout\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Will now print everything in the stdout buffer\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Disable buffering on stdout by using \u0026lt;code\u0026gt;setbuf\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;setbuf(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stdout\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Or use the more flexible \u0026lt;a href=\u0026quot;https://en.cppreference.com/w/c/io/setvbuf\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;setvbuf\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;setvbuf(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stdout\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;, _IONBF, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;); \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;No, it\u0026apos;s not POSIX behaviour, it\u0026apos;s ISO behaviour (well, it \u0026lt;em\u0026gt;is\u0026lt;/em\u0026gt; POSIX behaviour but only insofar as they conform to ISO).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Standard output is line buffered if it can be detected to refer to an interactive device, otherwise it\u0026apos;s fully buffered. So there are situations where \u0026lt;code\u0026gt;printf\u0026lt;/code\u0026gt; won\u0026apos;t flush, even if it gets a newline to send out, such as:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;myprog \u0026amp;gt;myfile.txt\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This makes sense for efficiency since, if you\u0026apos;re interacting with a user, they probably want to see every line. If you\u0026apos;re sending the output to a file, it\u0026apos;s most likely that there\u0026apos;s not a user at the other end (though not impossible, they could be tailing the file). Now you \u0026lt;em\u0026gt;could\u0026lt;/em\u0026gt; argue that the user wants to see every character but there are two problems with that.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The first is that it\u0026apos;s not very efficient. The second is that the original ANSI C mandate was to primarily codify \u0026lt;em\u0026gt;existing\u0026lt;/em\u0026gt; behaviour, rather than invent \u0026lt;em\u0026gt;new\u0026lt;/em\u0026gt; behaviour, and those design decisions were made long before ANSI started the process. Even ISO nowadays treads very carefully when changing existing rules in the standards.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;As to how to deal with that, if you \u0026lt;code\u0026gt;fflush (stdout)\u0026lt;/code\u0026gt; after every output call that you want to see immediately, that will solve the problem.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Alternatively, you can use \u0026lt;code\u0026gt;setvbuf\u0026lt;/code\u0026gt; before operating on \u0026lt;code\u0026gt;stdout\u0026lt;/code\u0026gt;, to set it to unbuffered and you won\u0026apos;t have to worry about adding all those \u0026lt;code\u0026gt;fflush\u0026lt;/code\u0026gt; lines to your code:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;setvbuf (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stdout\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;, _IONBF, BUFSIZ);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Just keep in mind that may affect performance quite a bit if you \u0026lt;em\u0026gt;are\u0026lt;/em\u0026gt; sending the output to a file. Also keep in mind that support for this is implementation-defined, not guaranteed by the standard.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;ISO C99 section \u0026lt;code\u0026gt;7.19.3/3\u0026lt;/code\u0026gt; is the relevant bit:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;When a stream is \u0026lt;em\u0026gt;unbuffered\u0026lt;/em\u0026gt;, characters are intended to appear from the source or at the destination as soon as possible. Otherwise characters may be accumulated and transmitted to or from the host environment as a block.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;When a stream is \u0026lt;em\u0026gt;fully buffered\u0026lt;/em\u0026gt;, characters are intended to be transmitted to or from the host environment as a block when a buffer is filled.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;When a stream is \u0026lt;em\u0026gt;line buffered\u0026lt;/em\u0026gt;, characters are intended to be transmitted to or from the host environment as a block when a new-line character is encountered.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Furthermore, characters are intended to be transmitted as a block to the host environment when a buffer is filled, when input is requested on an unbuffered stream, or when input is requested on a line buffered stream that requires the transmission of characters from the host environment.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Support for these characteristics is implementation-defined, and may be affected via the \u0026lt;code\u0026gt;setbuf\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;setvbuf\u0026lt;/code\u0026gt; functions.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;To immediately flush call \u0026lt;code\u0026gt;fflush(stdout)\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;fflush(NULL)\u0026lt;/code\u0026gt; (\u0026lt;code\u0026gt;NULL\u0026lt;/code\u0026gt; means flush everything).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It\u0026apos;s probably like that because of efficiency and because if you have multiple programs writing to a single TTY, this way you don\u0026apos;t get characters on a line interlaced. So if program A and B are outputting, you\u0026apos;ll usually get:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;program A output\nprogram B output\nprogram B output\nprogram A output\nprogram B output\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This stinks, but it\u0026apos;s better than\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;proprogrgraam m AB  ououtputputt\nprproogrgram amB A  ououtputtput\nprogram B output\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that it isn\u0026apos;t even guaranteed to flush on a newline, so you should flush explicitly if flushing matters to you.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Note: Microsoft runtime libraries do not support line buffering, so \u0026lt;code\u0026gt;printf(\u0026quot;will print immediately to terminal\u0026quot;)\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/setvbuf\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/setvbuf\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;stdout is buffered, so will only output after a newline is printed.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To get immediate output, either:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Print to stderr.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Make stdout unbuffered.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n    ","\n\u0026lt;p\u0026gt;by default, stdout is line buffered, stderr is none buffered and file is completely buffered.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You can fprintf to stderr, which is unbuffered, instead.  Or you can flush stdout when you want to.  Or you can set stdout to unbuffered.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Use \u0026lt;code\u0026gt;setbuf(stdout, NULL);\u0026lt;/code\u0026gt; to disable buffering.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are generally 2 levels of buffering-\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;1. Kernel buffer Cache (makes read/write faster)\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;2. Buffering in I/O library (reduces no. of system calls)\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Let\u0026apos;s take example of \u0026lt;code\u0026gt;fprintf and write()\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When you call \u0026lt;code\u0026gt;fprintf()\u0026lt;/code\u0026gt;, it doesn\u0026apos;t wirte directly to the file. It first goes to stdio buffer in the program\u0026apos;s memory. From there it is written to the kernel buffer cache by using write system call. So one way to skip I/O buffer is directly using write(). Other ways are by using \u0026lt;code\u0026gt;setbuff(stream,NULL)\u0026lt;/code\u0026gt;. This sets the buffering mode to no buffering and data is directly written to kernel buffer.\nTo forcefully make the data to be shifted to kernel buffer, we can use \u0026quot;\\n\u0026quot;, which in case of default buffering mode of \u0026apos;line buffering\u0026apos;, will flush I/O buffer.\nOr we can use \u0026lt;code\u0026gt;fflush(FILE *stream)\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now we are in kernel buffer. Kernel(/OS) wants to minimise disk access time and hence it reads/writes only blocks of disk. So when a \u0026lt;code\u0026gt;read()\u0026lt;/code\u0026gt; is issued, which is a system call and can be invoked directly or through \u0026lt;code\u0026gt;fscanf()\u0026lt;/code\u0026gt;, kernel reads the disk block from disk and stores it in a buffer. After that data is copied from here to user space.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Similarly that \u0026lt;code\u0026gt;fprintf()\u0026lt;/code\u0026gt; data recieved from I/O buffer is written to the disk by the kernel. This makes read() write() faster.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now to force the kernel to initiate a \u0026lt;code\u0026gt;write()\u0026lt;/code\u0026gt;, after which data transfer is controlled by hardware controllers, there are also some ways. We can use \u0026lt;code\u0026gt;O_SYNC\u0026lt;/code\u0026gt; or similar flags during write calls. Or we could use other functions like \u0026lt;code\u0026gt;fsync(),fdatasync(),sync()\u0026lt;/code\u0026gt; to make the kernel initiate writes as soon as data is available in the kernel buffer.\u0026lt;/p\u0026gt;\n    "],"id":397,"title":"Why does printf not flush after the call unless a newline is in the format string?","content":"\n                \n\u0026lt;p\u0026gt;Why does \u0026lt;code\u0026gt;printf\u0026lt;/code\u0026gt; not flush after the call unless a newline is in the format string? Is this POSIX behavior? How might I have \u0026lt;code\u0026gt;printf\u0026lt;/code\u0026gt; immediately flush every time?\u0026lt;/p\u0026gt;\n    ","slug":"why-does-printf-not-flush-after-the-call-unless-a-newline-is-in-the-format-string-1657387853407","postType":"QUESTION","createdAt":"2022-07-09T17:30:53.000Z","updatedAt":"2022-07-09T17:30:53.000Z","tags":[{"id":2138,"name":"printf","slug":"printf","createdAt":"2022-07-09T17:30:53.000Z","updatedAt":"2022-07-09T17:30:53.000Z","Questions_Tags":{"questionId":397,"tagId":2138}},{"id":2140,"name":"flush","slug":"flush","createdAt":"2022-07-09T17:30:53.000Z","updatedAt":"2022-07-09T17:30:53.000Z","Questions_Tags":{"questionId":397,"tagId":2140}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"why-does-printf-not-flush-after-the-call-unless-a-newline-is-in-the-format-string-1657387853407"},"buildId":"6_hwtyf_oFlFS5l_S4CTe","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>