<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2eccd4d47c856f2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2eccd4d47c856f2b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/471-84c36aa98dd4107c.js" defer=""></script><script src="/_next/static/chunks/81-096e453de8a27667.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-e3d1b60e109d3ba1.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_buildManifest.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.hFcsiD code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-6e32c308-0"]{content:"hFcsiD,"}/*!sc*/
.ljvTUN .comment-item .comment-body .d-inline-flex.ai-center{text-align:right;}/*!sc*/
.ljvTUN .comment-item .comment-body .comment-date{float:right;}/*!sc*/
data-styled.g6[id="sc-6e32c308-1"]{content:"ljvTUN,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="https://flowbite.com/docs/images/logo.svg" class="mr-3 h-6 sm:h-9" alt="Flowbite Logo"/><span class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Hunter</span></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/why-are-floating-point-numbers-inaccurate-1657387346111#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-6e32c308-0 hFcsiD flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/why-are-floating-point-numbers-inaccurate-1657387346111">Why are floating point numbers inaccurate?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/precision">precision</a></div></div><div class="question-content mt-5">
                
<p>Why do some numbers lose accuracy when stored as floating point numbers?</p>

<p>For example, the decimal number <code>9.2</code> can be expressed exactly as a ratio of two decimal integers (<code>92/10</code>), both of which can be expressed exactly in binary (<code>0b1011100/0b1010</code>). However, the same ratio stored as a floating point number is never exactly equal to <code>9.2</code>:</p>

<pre><code>32-bit "single precision" float: 9.19999980926513671875
64-bit "double precision" float: 9.199999999999999289457264239899814128875732421875
</code></pre>

<p>How can such an apparently simple number be "too big" to express in <strong>64 bits</strong> of memory?</p>
    </div></div></div><div class="sc-6e32c308-1 ljvTUN flex text-xs pl-10 flex-col comment items-center justify-center"><h4 class="text-left mt-10 text-lg font-semibold">Comments</h4><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy"><a href="http://meta.stackoverflow.com/questions/260130/canonical-duplicate-for-floating-point-is-inaccurate">Discussion of this post on Meta</a></span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/811/shog9" title="152,454 reputation" class="comment-user">Shog9</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment37345579_21895756"><span title="2014-06-12 18:36:57Z, License: CC BY-SA 3.0" class="relativetime-clean">Jun 12, 2014 at 18:36</span></a></span>
            </div>
        </div><span class="divide-x-8 "></span><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy">Refer to <a href="https://stackoverflow.com/q/588004/6521116">is floating math broken</a></span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/6521116/lf00" title="24,937 reputation" class="comment-user">LF00</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment75279553_21895756"><span title="2017-05-23 09:12:39Z, License: CC BY-SA 3.0" class="relativetime-clean">May 23, 2017 at 9:12</span></a></span>
            </div>
        </div><span class="divide-x-8 "></span><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy"><a href="https://medium.com/swlh/why-floating-point-numbers-are-not-always-accurate-9a57e812ace1" rel="nofollow noreferrer">medium.com/swlh/</a></span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/12754117/rjhcnf" title="416 reputation" class="comment-user">rjhcnf</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment109592112_21895756"><span title="2020-05-22 19:42:58Z, License: CC BY-SA 4.0" class="relativetime-clean">May 22, 2020 at 19:42</span></a></span>
            </div>
        </div><span class="divide-x-8 "></span><button class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">See more</button></div><div class="sc-6e32c308-2 bFXWFO"><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In most programming languages, floating point numbers are represented a lot like <a href="http://en.wikipedia.org/wiki/Scientific_notation" rel="noreferrer">scientific notation</a>: with an exponent and a mantissa (also called the significand). A very simple number, say <code>9.2</code>, is actually this fraction:</p>

<blockquote>
  <p>5179139571476070 * 2<sup> -49</sup></p>
</blockquote>

<p>Where the exponent is <code>-49</code> and the mantissa is <code>5179139571476070</code>. The reason it is impossible to represent <em>some</em> decimal numbers this way is that both the exponent and the mantissa must be integers. In other words, all floats must be an <em>integer</em> multiplied by an <em>integer power of 2</em>. </p>

<p><code>9.2</code> may be simply <code>92/10</code>, but <strong>10</strong> cannot be expressed as <strong>2<sup>n</sup></strong> if <strong>n</strong> is limited to integer values.</p>

<hr>

<h1>Seeing the Data</h1>

<p>First, a few functions to <em>see</em> the components that make a 32- and 64-bit <code>float</code>. Gloss over these if you only care about the output (example in Python):</p>

<pre class="lang-python s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">float_to_bin_parts</span>(<span class="hljs-params">number, bits=<span class="hljs-number">64</span></span>):
    <span class="hljs-keyword">if</span> bits == <span class="hljs-number">32</span>:          <span class="hljs-comment"># single precision</span>
        int_pack      = <span class="hljs-string">'I'</span>
        float_pack    = <span class="hljs-string">'f'</span>
        exponent_bits = <span class="hljs-number">8</span>
        mantissa_bits = <span class="hljs-number">23</span>
        exponent_bias = <span class="hljs-number">127</span>
    <span class="hljs-keyword">elif</span> bits == <span class="hljs-number">64</span>:        <span class="hljs-comment"># double precision. all python floats are this</span>
        int_pack      = <span class="hljs-string">'Q'</span>
        float_pack    = <span class="hljs-string">'d'</span>
        exponent_bits = <span class="hljs-number">11</span>
        mantissa_bits = <span class="hljs-number">52</span>
        exponent_bias = <span class="hljs-number">1023</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">raise</span> ValueError, <span class="hljs-string">'bits argument must be 32 or 64'</span>
    bin_iter = <span class="hljs-built_in">iter</span>(<span class="hljs-built_in">bin</span>(struct.unpack(int_pack, struct.pack(float_pack, number))[<span class="hljs-number">0</span>])[<span class="hljs-number">2</span>:].rjust(bits, <span class="hljs-string">'0'</span>))
    <span class="hljs-keyword">return</span> [<span class="hljs-string">''</span>.join(islice(bin_iter, x)) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>, exponent_bits, mantissa_bits)]
</code></pre>

<p>There's a lot of complexity behind that function, and it'd be quite the tangent to explain, but if you're interested, the important resource for our purposes is the <a href="http://docs.python.org/2/library/struct.html" rel="noreferrer">struct</a> module.</p>

<p>Python's <code>float</code> is a 64-bit, double-precision number. In other languages such as C, C++, Java and C#, double-precision has a separate type <code>double</code>, which is often implemented as 64 bits.</p>

<p>When we call that function with our example, <code>9.2</code>, here's what we get:</p>

<pre><code>&gt;&gt;&gt; float_to_bin_parts(9.2)
['0', '10000000010', '0010011001100110011001100110011001100110011001100110']
</code></pre>

<hr>

<h1>Interpreting the Data</h1>

<p>You'll see I've split the return value into three components. These components are:</p>

<ul>
<li>Sign</li>
<li>Exponent</li>
<li>Mantissa (also called Significand, or Fraction)</li>
</ul>

<h2>Sign</h2>

<p>The sign is stored in the first component as a single bit. It's easy to explain: <code>0</code> means the float is a positive number; <code>1</code> means it's negative. Because <code>9.2</code> is positive, our sign value is <code>0</code>.</p>

<h2>Exponent</h2>

<p>The exponent is stored in the middle component as 11 bits. In our case, <code>0b10000000010</code>. In decimal, that represents the value <code>1026</code>. A quirk of this component is that you must subtract a number equal to <strong>2<sup>(# of bits) - 1</sup> - 1</strong> to get the true exponent; in our case, that means subtracting  <code>0b1111111111</code> (decimal number <code>1023</code>) to get the true exponent, <code>0b00000000011</code> (decimal number 3).</p>

<h2>Mantissa</h2>

<p>The mantissa is stored in the third component as 52 bits. However, there's a quirk to this component as well. To understand this quirk, consider a number in scientific notation, like this:</p>

<blockquote>
  <p>6.0221413x10<sup>23</sup></p>
</blockquote>

<p>The mantissa would be the <code>6.0221413</code>. Recall that the mantissa in scientific notation always begins with a single non-zero digit. The same holds true for binary, except that binary only has two digits: <code>0</code> and <code>1</code>. So the binary mantissa <em>always</em> starts with <code>1</code>! When a float is stored, the <code>1</code> at the front of the binary mantissa is omitted to save space; we have to place it back at the front of our third element to get the <em>true</em> mantissa:</p>

<blockquote>
  <p>1.0010011001100110011001100110011001100110011001100110</p>
</blockquote>

<p>This involves more than just a simple addition, because the bits stored in our third component actually represent the <em>fractional</em> part of the mantissa, to the right of the <a href="http://en.wiktionary.org/wiki/radix_point" rel="noreferrer">radix point</a>. </p>

<p>When dealing with decimal numbers, we "move the decimal point" by multiplying or dividing by powers of 10. In binary, we can do the same thing by multiplying or dividing by powers of 2. Since our third element has 52 bits, we divide it by <strong>2<sup>52</sup></strong> to move it 52 places to the right:</p>

<blockquote>
  <p>0.0010011001100110011001100110011001100110011001100110</p>
</blockquote>

<p>In decimal notation, that's the same as dividing <code>675539944105574</code> by <code>4503599627370496</code> to get <code>0.1499999999999999</code>. (This is one example of a ratio that can be expressed exactly in binary, but only approximately in decimal; for more detail, see: <a href="http://www.wolframalpha.com/input/?i=675539944105574+%2F+4503599627370496" rel="noreferrer">675539944105574 / 4503599627370496</a>.)</p>

<p>Now that we've transformed the third component into a fractional number, adding <code>1</code> gives the true mantissa.</p>

<h2>Recapping the Components</h2>

<ul>
<li>Sign (first component): <code>0</code> for positive, <code>1</code> for negative</li>
<li>Exponent (middle component): Subtract <strong>2<sup>(# of bits) - 1</sup> - 1</strong> to get the true exponent</li>
<li>Mantissa (last component): Divide by <strong>2<sup>(# of bits)</sup></strong> and add <code>1</code> to get the true mantissa</li>
</ul>

<hr>

<h1>Calculating the Number</h1>

<p>Putting all three parts together, we're given this binary number:</p>

<blockquote>
  <p>1.0010011001100110011001100110011001100110011001100110 x 10<sup>11</sup></p>
</blockquote>

<p>Which we can then convert from binary to decimal:</p>

<blockquote>
  <p>1.1499999999999999 x 2<sup>3</sup> (inexact!)</p>
</blockquote>

<p>And multiply to reveal the final representation of the number we started with (<code>9.2</code>) after being stored as a floating point value:</p>

<blockquote>
  <p>9.1999999999999993</p>
</blockquote>

<hr>

<h1>Representing as a Fraction</h1>

<h2>9.2</h2>

<p>Now that we've built the number, it's possible to reconstruct it into a simple fraction:</p>

<blockquote>
  <p>1.0010011001100110011001100110011001100110011001100110 x 10<sup>11</sup></p>
</blockquote>

<p>Shift mantissa to a whole number:</p>

<blockquote>
  <p>10010011001100110011001100110011001100110011001100110 x 10<sup>11-110100</sup></p>
</blockquote>

<p>Convert to decimal:</p>

<blockquote>
  <p>5179139571476070 x 2<sup>3-52</sup></p>
</blockquote>

<p>Subtract the exponent:</p>

<blockquote>
  <p>5179139571476070 x 2<sup>-49</sup></p>
</blockquote>

<p>Turn negative exponent into division:</p>

<blockquote>
  <p>5179139571476070 / 2<sup>49</sup></p>
</blockquote>

<p>Multiply exponent:</p>

<blockquote>
  <p>5179139571476070 / 562949953421312</p>
</blockquote>

<p>Which equals:</p>

<blockquote>
  <p>9.1999999999999993</p>
</blockquote>

<h2>9.5</h2>

<pre><code>&gt;&gt;&gt; float_to_bin_parts(9.5)
['0', '10000000010', '0011000000000000000000000000000000000000000000000000']
</code></pre>

<p>Already you can see the mantissa is only 4 digits followed by a whole lot of zeroes. But let's go through the paces.</p>

<p>Assemble the binary scientific notation:</p>

<blockquote>
  <p>1.0011 x 10<sup>11</sup></p>
</blockquote>

<p>Shift the decimal point:</p>

<blockquote>
  <p>10011 x 10<sup>11-100</sup>  </p>
</blockquote>

<p>Subtract the exponent:</p>

<blockquote>
  <p>10011 x 10<sup>-1</sup>  </p>
</blockquote>

<p>Binary to decimal:</p>

<blockquote>
  <p>19 x 2<sup>-1</sup>  </p>
</blockquote>

<p>Negative exponent to division:</p>

<blockquote>
  <p>19 / 2<sup>1</sup></p>
</blockquote>

<p>Multiply exponent:</p>

<blockquote>
  <p>19 / 2</p>
</blockquote>

<p>Equals:</p>

<blockquote>
  <p>9.5</p>
</blockquote>

<hr>

<hr>

<h1>Further reading</h1>

<ul>
<li><a href="http://floating-point-gui.de/" rel="noreferrer">The Floating-Point Guide: What Every Programmer Should Know About Floating-Point Arithmetic, or, Why dont my numbers add up?</a> (floating-point-gui.de)</li>
<li><a href="http://download.oracle.com/docs/cd/E19957-01/806-3568/ncg_goldberg.html" rel="noreferrer">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a> (Goldberg 1991)</li>
<li><a href="http://en.wikipedia.org/wiki/Double-precision_floating-point_format" rel="noreferrer">IEEE Double-precision floating-point format</a> (Wikipedia)</li>
<li><a href="http://docs.python.org/3.4/tutorial/floatingpoint.html" rel="noreferrer">Floating Point Arithmetic: Issues and Limitations</a> (docs.python.org)</li>
<li><a href="http://kipirvine.com/asm/workbook/floating_tut.htm" rel="noreferrer">Floating Point Binary</a></li>
</ul>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This isn't a full answer (<a href="https://stackoverflow.com/a/21895757/1072468">mhlester</a> already covered a lot of good ground I won't duplicate), but I would like to stress how much the representation of a number depends on the base you are working in.</p>
<h2>Consider the fraction 2/3</h2>
<p>In good-ol' base 10, we typically write it out as something like</p>
<ul>
<li>0.666...</li>
<li>0.666</li>
<li>0.667</li>
</ul>
<p>When we look at those representations, we tend to associate each of them with the fraction 2/3, even though only the first representation is mathematically equal to the fraction. The second and third representations/approximations have an error on the order of 0.001, which is actually much worse than the error between 9.2 and 9.1999999999999993. In fact, the second representation isn't even rounded correctly! <em>Nevertheless, we don't have a problem with 0.666 as an approximation of the number 2/3, <strong>so we shouldn't really have a problem with how 9.2 is approximated in most programs</strong>.</em> (Yes, in some programs it matters.)</p>
<h2>Number bases</h2>
<p>So here's where number bases are crucial. If we were trying to represent 2/3 in base 3, then</p>
<blockquote>
<p>(2/3)<sub>10</sub> = 0.2<sub>3</sub></p>
</blockquote>
<p>In other words, we have an exact, finite representation for the same number by switching bases! The take-away is that even though you can convert any number to any base, <em>all rational numbers have exact finite representations in some bases but not in others</em>.</p>
<p>To drive this point home, let's look at 1/2. It might surprise you that even though this perfectly simple number has an exact representation in base 10 and 2, it requires a repeating representation in base 3.</p>
<blockquote>
<p>(1/2)<sub>10</sub> = 0.5<sub>10</sub> = 0.1<sub>2</sub> = 0.1111...<sub>3</sub></p>
</blockquote>
<h2>Why are floating point numbers inaccurate?</h2>
<p>Because often-times, they are approximating rationals that cannot be represented finitely in base 2 (the digits repeat), and in general they are approximating real (possibly irrational) numbers which may not be representable in finitely many digits in <em>any</em> base.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>While all of the other answers are good there is still one thing missing:</p>

<p><strong>It is impossible to represent irrational numbers (e.g. π, <code>sqrt(2)</code>, <code>log(3)</code>, etc.) precisely!</strong></p>

<p>And that actually is why they are called irrational. No amount of bit storage in the world would be enough to hold even one of them. Only <em>symbolic</em> arithmetic is able to preserve their precision.</p>

<p>Although if you would limit your math needs to rational numbers only the problem of precision becomes manageable. You would need to store a pair of (possibly very big) integers <code>a</code> and <code>b</code> to hold the number represented by the fraction <code>a/b</code>. All your arithmetic would have to be done on fractions just like in highschool math (e.g. <code>a/b * c/d = ac/bd</code>).</p>

<p>But of course you would still run into the same kind of trouble when <code>pi</code>, <code>sqrt</code>, <code>log</code>, <code>sin</code>, etc. are involved.</p>

<p><strong>TL;DR</strong></p>

<p>For hardware accelerated arithmetic only a limited amount of rational numbers can be represented. Every not-representable number is approximated. Some numbers (i.e. irrational) can never be represented no matter the system.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There are infinitely many real numbers (so many that you can't enumerate them), and there are infinitely many rational numbers (it is possible to enumerate them).</p>

<p>The floating-point representation is a finite one (like anything in a computer) so unavoidably many many many numbers are impossible to represent. In particular, 64 bits only allow you to distinguish among only 18,446,744,073,709,551,616 different values (which is nothing compared to infinity). With the standard convention, 9.2 is not one of them. Those that can are of the form m.2^e for some integers m and e.</p>

<hr>

<p>You might come up with a different numeration system, 10 based for instance, where 9.2 would have an exact representation. But other numbers, say 1/3, would still be impossible to represent.</p>

<hr>

<p>Also note that double-precision floating-points numbers are <em>extremely</em> accurate. They can represent any number in a very wide range with as much as 15 exact digits. For daily life computations, 4 or 5 digits are more than enough. You will never really need those 15, unless you want to count every millisecond of your lifetime.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<blockquote>
  <p>Why can we not represent 9.2 in binary floating point?</p>
</blockquote>

<p>Floating point numbers are (simplifying slightly) a positional numbering system with a restricted number of digits and a movable radix point.</p>

<p>A fraction can only be expressed exactly using a finite number of digits in a positional numbering system if the prime factors of the denominator (when the fraction is expressed in it's lowest terms) are factors of the base.</p>

<p>The prime factors of 10 are 5 and 2, so in base 10 we can represent any fraction of the form a/(2<sup>b</sup>5<sup>c</sup>). </p>

<p>On the other hand the only prime factor of 2 is 2, so in base 2 we can only represent fractions of the form a/(2<sup>b</sup>)</p>

<blockquote>
  <p>Why do computers use this representation?</p>
</blockquote>

<p>Because it's a simple format to work with and it is sufficiently accurate for most purposes. Basically the same reason scientists use "scientific notation" and round their results to a reasonable number of digits at each step.</p>

<p>It would certainly be possible to define a fraction format, with (for example) a 32-bit numerator and a 32-bit denominator. It would be able to represent numbers that IEEE double precision floating point could not, but equally there would be many numbers that can be represented in double precision floating point that could not be represented in such a fixed-size fraction format. </p>

<p>However the big problem is that such a format is a pain to do calculations on. For two reasons.</p>

<ol>
<li>If you want to have exactly one representation of each number then after each calculation you need to reduce the fraction to it's lowest terms. That means that for every operation you basically need to do a greatest common divisor calculation.</li>
<li>If after your calculation you end up with an unrepresentable result because the numerator or denominator you need to find the closest representable result. This is non-trivil.</li>
</ol>

<p>Some Languages do offer fraction types, but usually they do it in combination with arbitary precision, this avoids needing to worry about approximating fractions but it creates it's own problem, when a number passes through a large number of calculation steps the size of the denominator and hence the storage needed for the fraction can explode.</p>

<p>Some languages also offer decimal floating point types, these are mainly used in scenarios where it is imporant that the results the computer gets match pre-existing rounding rules that were written with humans in mind (chiefly financial calculations). These are slightly more difficult to work with than binary floating point, but the biggest problem is that most computers don't offer hardware support for them.</p>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;In most programming languages, floating point numbers are represented a lot like \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Scientific_notation\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;scientific notation\u0026lt;/a\u0026gt;: with an exponent and a mantissa (also called the significand). A very simple number, say \u0026lt;code\u0026gt;9.2\u0026lt;/code\u0026gt;, is actually this fraction:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;5179139571476070 * 2\u0026lt;sup\u0026gt; -49\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Where the exponent is \u0026lt;code\u0026gt;-49\u0026lt;/code\u0026gt; and the mantissa is \u0026lt;code\u0026gt;5179139571476070\u0026lt;/code\u0026gt;. The reason it is impossible to represent \u0026lt;em\u0026gt;some\u0026lt;/em\u0026gt; decimal numbers this way is that both the exponent and the mantissa must be integers. In other words, all floats must be an \u0026lt;em\u0026gt;integer\u0026lt;/em\u0026gt; multiplied by an \u0026lt;em\u0026gt;integer power of 2\u0026lt;/em\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;9.2\u0026lt;/code\u0026gt; may be simply \u0026lt;code\u0026gt;92/10\u0026lt;/code\u0026gt;, but \u0026lt;strong\u0026gt;10\u0026lt;/strong\u0026gt; cannot be expressed as \u0026lt;strong\u0026gt;2\u0026lt;sup\u0026gt;n\u0026lt;/sup\u0026gt;\u0026lt;/strong\u0026gt; if \u0026lt;strong\u0026gt;n\u0026lt;/strong\u0026gt; is limited to integer values.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h1\u0026gt;Seeing the Data\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;First, a few functions to \u0026lt;em\u0026gt;see\u0026lt;/em\u0026gt; the components that make a 32- and 64-bit \u0026lt;code\u0026gt;float\u0026lt;/code\u0026gt;. Gloss over these if you only care about the output (example in Python):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-python s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;float_to_bin_parts\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;number, bits=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;64\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; bits == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;32\u0026lt;/span\u0026gt;:          \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# single precision\u0026lt;/span\u0026gt;\n        int_pack      = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;I\u0026apos;\u0026lt;/span\u0026gt;\n        float_pack    = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;f\u0026apos;\u0026lt;/span\u0026gt;\n        exponent_bits = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;\n        mantissa_bits = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;23\u0026lt;/span\u0026gt;\n        exponent_bias = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;127\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;elif\u0026lt;/span\u0026gt; bits == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;64\u0026lt;/span\u0026gt;:        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# double precision. all python floats are this\u0026lt;/span\u0026gt;\n        int_pack      = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Q\u0026apos;\u0026lt;/span\u0026gt;\n        float_pack    = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;d\u0026apos;\u0026lt;/span\u0026gt;\n        exponent_bits = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;\n        mantissa_bits = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;52\u0026lt;/span\u0026gt;\n        exponent_bias = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1023\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;raise\u0026lt;/span\u0026gt; ValueError, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;bits argument must be 32 or 64\u0026apos;\u0026lt;/span\u0026gt;\n    bin_iter = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;iter\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;bin\u0026lt;/span\u0026gt;(struct.unpack(int_pack, struct.pack(float_pack, number))[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;])[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;:].rjust(bits, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;0\u0026apos;\u0026lt;/span\u0026gt;))\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; [\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026apos;\u0026lt;/span\u0026gt;.join(islice(bin_iter, x)) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; x \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, exponent_bits, mantissa_bits)]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;There\u0026apos;s a lot of complexity behind that function, and it\u0026apos;d be quite the tangent to explain, but if you\u0026apos;re interested, the important resource for our purposes is the \u0026lt;a href=\u0026quot;http://docs.python.org/2/library/struct.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;struct\u0026lt;/a\u0026gt; module.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Python\u0026apos;s \u0026lt;code\u0026gt;float\u0026lt;/code\u0026gt; is a 64-bit, double-precision number. In other languages such as C, C++, Java and C#, double-precision has a separate type \u0026lt;code\u0026gt;double\u0026lt;/code\u0026gt;, which is often implemented as 64 bits.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When we call that function with our example, \u0026lt;code\u0026gt;9.2\u0026lt;/code\u0026gt;, here\u0026apos;s what we get:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; float_to_bin_parts(9.2)\n[\u0026apos;0\u0026apos;, \u0026apos;10000000010\u0026apos;, \u0026apos;0010011001100110011001100110011001100110011001100110\u0026apos;]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h1\u0026gt;Interpreting the Data\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;You\u0026apos;ll see I\u0026apos;ve split the return value into three components. These components are:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Sign\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Exponent\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Mantissa (also called Significand, or Fraction)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;h2\u0026gt;Sign\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The sign is stored in the first component as a single bit. It\u0026apos;s easy to explain: \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt; means the float is a positive number; \u0026lt;code\u0026gt;1\u0026lt;/code\u0026gt; means it\u0026apos;s negative. Because \u0026lt;code\u0026gt;9.2\u0026lt;/code\u0026gt; is positive, our sign value is \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Exponent\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The exponent is stored in the middle component as 11 bits. In our case, \u0026lt;code\u0026gt;0b10000000010\u0026lt;/code\u0026gt;. In decimal, that represents the value \u0026lt;code\u0026gt;1026\u0026lt;/code\u0026gt;. A quirk of this component is that you must subtract a number equal to \u0026lt;strong\u0026gt;2\u0026lt;sup\u0026gt;(# of bits) - 1\u0026lt;/sup\u0026gt; - 1\u0026lt;/strong\u0026gt; to get the true exponent; in our case, that means subtracting  \u0026lt;code\u0026gt;0b1111111111\u0026lt;/code\u0026gt; (decimal number \u0026lt;code\u0026gt;1023\u0026lt;/code\u0026gt;) to get the true exponent, \u0026lt;code\u0026gt;0b00000000011\u0026lt;/code\u0026gt; (decimal number 3).\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Mantissa\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The mantissa is stored in the third component as 52 bits. However, there\u0026apos;s a quirk to this component as well. To understand this quirk, consider a number in scientific notation, like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;6.0221413x10\u0026lt;sup\u0026gt;23\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;The mantissa would be the \u0026lt;code\u0026gt;6.0221413\u0026lt;/code\u0026gt;. Recall that the mantissa in scientific notation always begins with a single non-zero digit. The same holds true for binary, except that binary only has two digits: \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;1\u0026lt;/code\u0026gt;. So the binary mantissa \u0026lt;em\u0026gt;always\u0026lt;/em\u0026gt; starts with \u0026lt;code\u0026gt;1\u0026lt;/code\u0026gt;! When a float is stored, the \u0026lt;code\u0026gt;1\u0026lt;/code\u0026gt; at the front of the binary mantissa is omitted to save space; we have to place it back at the front of our third element to get the \u0026lt;em\u0026gt;true\u0026lt;/em\u0026gt; mantissa:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;1.0010011001100110011001100110011001100110011001100110\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;This involves more than just a simple addition, because the bits stored in our third component actually represent the \u0026lt;em\u0026gt;fractional\u0026lt;/em\u0026gt; part of the mantissa, to the right of the \u0026lt;a href=\u0026quot;http://en.wiktionary.org/wiki/radix_point\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;radix point\u0026lt;/a\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When dealing with decimal numbers, we \u0026quot;move the decimal point\u0026quot; by multiplying or dividing by powers of 10. In binary, we can do the same thing by multiplying or dividing by powers of 2. Since our third element has 52 bits, we divide it by \u0026lt;strong\u0026gt;2\u0026lt;sup\u0026gt;52\u0026lt;/sup\u0026gt;\u0026lt;/strong\u0026gt; to move it 52 places to the right:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;0.0010011001100110011001100110011001100110011001100110\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;In decimal notation, that\u0026apos;s the same as dividing \u0026lt;code\u0026gt;675539944105574\u0026lt;/code\u0026gt; by \u0026lt;code\u0026gt;4503599627370496\u0026lt;/code\u0026gt; to get \u0026lt;code\u0026gt;0.1499999999999999\u0026lt;/code\u0026gt;. (This is one example of a ratio that can be expressed exactly in binary, but only approximately in decimal; for more detail, see: \u0026lt;a href=\u0026quot;http://www.wolframalpha.com/input/?i=675539944105574+%2F+4503599627370496\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;675539944105574 / 4503599627370496\u0026lt;/a\u0026gt;.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now that we\u0026apos;ve transformed the third component into a fractional number, adding \u0026lt;code\u0026gt;1\u0026lt;/code\u0026gt; gives the true mantissa.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Recapping the Components\u0026lt;/h2\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Sign (first component): \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt; for positive, \u0026lt;code\u0026gt;1\u0026lt;/code\u0026gt; for negative\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Exponent (middle component): Subtract \u0026lt;strong\u0026gt;2\u0026lt;sup\u0026gt;(# of bits) - 1\u0026lt;/sup\u0026gt; - 1\u0026lt;/strong\u0026gt; to get the true exponent\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Mantissa (last component): Divide by \u0026lt;strong\u0026gt;2\u0026lt;sup\u0026gt;(# of bits)\u0026lt;/sup\u0026gt;\u0026lt;/strong\u0026gt; and add \u0026lt;code\u0026gt;1\u0026lt;/code\u0026gt; to get the true mantissa\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h1\u0026gt;Calculating the Number\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;Putting all three parts together, we\u0026apos;re given this binary number:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;1.0010011001100110011001100110011001100110011001100110 x 10\u0026lt;sup\u0026gt;11\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Which we can then convert from binary to decimal:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;1.1499999999999999 x 2\u0026lt;sup\u0026gt;3\u0026lt;/sup\u0026gt; (inexact!)\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;And multiply to reveal the final representation of the number we started with (\u0026lt;code\u0026gt;9.2\u0026lt;/code\u0026gt;) after being stored as a floating point value:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;9.1999999999999993\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h1\u0026gt;Representing as a Fraction\u0026lt;/h1\u0026gt;\n\n\u0026lt;h2\u0026gt;9.2\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Now that we\u0026apos;ve built the number, it\u0026apos;s possible to reconstruct it into a simple fraction:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;1.0010011001100110011001100110011001100110011001100110 x 10\u0026lt;sup\u0026gt;11\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Shift mantissa to a whole number:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;10010011001100110011001100110011001100110011001100110 x 10\u0026lt;sup\u0026gt;11-110100\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Convert to decimal:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;5179139571476070 x 2\u0026lt;sup\u0026gt;3-52\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Subtract the exponent:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;5179139571476070 x 2\u0026lt;sup\u0026gt;-49\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Turn negative exponent into division:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;5179139571476070 / 2\u0026lt;sup\u0026gt;49\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Multiply exponent:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;5179139571476070 / 562949953421312\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Which equals:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;9.1999999999999993\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;h2\u0026gt;9.5\u0026lt;/h2\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; float_to_bin_parts(9.5)\n[\u0026apos;0\u0026apos;, \u0026apos;10000000010\u0026apos;, \u0026apos;0011000000000000000000000000000000000000000000000000\u0026apos;]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Already you can see the mantissa is only 4 digits followed by a whole lot of zeroes. But let\u0026apos;s go through the paces.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Assemble the binary scientific notation:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;1.0011 x 10\u0026lt;sup\u0026gt;11\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Shift the decimal point:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;10011 x 10\u0026lt;sup\u0026gt;11-100\u0026lt;/sup\u0026gt;  \u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Subtract the exponent:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;10011 x 10\u0026lt;sup\u0026gt;-1\u0026lt;/sup\u0026gt;  \u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Binary to decimal:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;19 x 2\u0026lt;sup\u0026gt;-1\u0026lt;/sup\u0026gt;  \u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Negative exponent to division:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;19 / 2\u0026lt;sup\u0026gt;1\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Multiply exponent:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;19 / 2\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Equals:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;9.5\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h1\u0026gt;Further reading\u0026lt;/h1\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://floating-point-gui.de/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;The Floating-Point Guide: What Every Programmer Should Know About Floating-Point Arithmetic, or, Why dont my numbers add up?\u0026lt;/a\u0026gt; (floating-point-gui.de)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://download.oracle.com/docs/cd/E19957-01/806-3568/ncg_goldberg.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;What Every Computer Scientist Should Know About Floating-Point Arithmetic\u0026lt;/a\u0026gt; (Goldberg 1991)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Double-precision_floating-point_format\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;IEEE Double-precision floating-point format\u0026lt;/a\u0026gt; (Wikipedia)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://docs.python.org/3.4/tutorial/floatingpoint.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Floating Point Arithmetic: Issues and Limitations\u0026lt;/a\u0026gt; (docs.python.org)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://kipirvine.com/asm/workbook/floating_tut.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Floating Point Binary\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This isn\u0026apos;t a full answer (\u0026lt;a href=\u0026quot;https://stackoverflow.com/a/21895757/1072468\u0026quot;\u0026gt;mhlester\u0026lt;/a\u0026gt; already covered a lot of good ground I won\u0026apos;t duplicate), but I would like to stress how much the representation of a number depends on the base you are working in.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Consider the fraction 2/3\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;In good-ol\u0026apos; base 10, we typically write it out as something like\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;0.666...\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;0.666\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;0.667\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;When we look at those representations, we tend to associate each of them with the fraction 2/3, even though only the first representation is mathematically equal to the fraction. The second and third representations/approximations have an error on the order of 0.001, which is actually much worse than the error between 9.2 and 9.1999999999999993. In fact, the second representation isn\u0026apos;t even rounded correctly! \u0026lt;em\u0026gt;Nevertheless, we don\u0026apos;t have a problem with 0.666 as an approximation of the number 2/3, \u0026lt;strong\u0026gt;so we shouldn\u0026apos;t really have a problem with how 9.2 is approximated in most programs\u0026lt;/strong\u0026gt;.\u0026lt;/em\u0026gt; (Yes, in some programs it matters.)\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Number bases\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;So here\u0026apos;s where number bases are crucial. If we were trying to represent 2/3 in base 3, then\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;(2/3)\u0026lt;sub\u0026gt;10\u0026lt;/sub\u0026gt; = 0.2\u0026lt;sub\u0026gt;3\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;In other words, we have an exact, finite representation for the same number by switching bases! The take-away is that even though you can convert any number to any base, \u0026lt;em\u0026gt;all rational numbers have exact finite representations in some bases but not in others\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;To drive this point home, let\u0026apos;s look at 1/2. It might surprise you that even though this perfectly simple number has an exact representation in base 10 and 2, it requires a repeating representation in base 3.\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;(1/2)\u0026lt;sub\u0026gt;10\u0026lt;/sub\u0026gt; = 0.5\u0026lt;sub\u0026gt;10\u0026lt;/sub\u0026gt; = 0.1\u0026lt;sub\u0026gt;2\u0026lt;/sub\u0026gt; = 0.1111...\u0026lt;sub\u0026gt;3\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;h2\u0026gt;Why are floating point numbers inaccurate?\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Because often-times, they are approximating rationals that cannot be represented finitely in base 2 (the digits repeat), and in general they are approximating real (possibly irrational) numbers which may not be representable in finitely many digits in \u0026lt;em\u0026gt;any\u0026lt;/em\u0026gt; base.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;While all of the other answers are good there is still one thing missing:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;It is impossible to represent irrational numbers (e.g. π, \u0026lt;code\u0026gt;sqrt(2)\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;log(3)\u0026lt;/code\u0026gt;, etc.) precisely!\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;And that actually is why they are called irrational. No amount of bit storage in the world would be enough to hold even one of them. Only \u0026lt;em\u0026gt;symbolic\u0026lt;/em\u0026gt; arithmetic is able to preserve their precision.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Although if you would limit your math needs to rational numbers only the problem of precision becomes manageable. You would need to store a pair of (possibly very big) integers \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; to hold the number represented by the fraction \u0026lt;code\u0026gt;a/b\u0026lt;/code\u0026gt;. All your arithmetic would have to be done on fractions just like in highschool math (e.g. \u0026lt;code\u0026gt;a/b * c/d = ac/bd\u0026lt;/code\u0026gt;).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But of course you would still run into the same kind of trouble when \u0026lt;code\u0026gt;pi\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;sqrt\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;log\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;sin\u0026lt;/code\u0026gt;, etc. are involved.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;TL;DR\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For hardware accelerated arithmetic only a limited amount of rational numbers can be represented. Every not-representable number is approximated. Some numbers (i.e. irrational) can never be represented no matter the system.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are infinitely many real numbers (so many that you can\u0026apos;t enumerate them), and there are infinitely many rational numbers (it is possible to enumerate them).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The floating-point representation is a finite one (like anything in a computer) so unavoidably many many many numbers are impossible to represent. In particular, 64 bits only allow you to distinguish among only 18,446,744,073,709,551,616 different values (which is nothing compared to infinity). With the standard convention, 9.2 is not one of them. Those that can are of the form m.2^e for some integers m and e.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;You might come up with a different numeration system, 10 based for instance, where 9.2 would have an exact representation. But other numbers, say 1/3, would still be impossible to represent.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Also note that double-precision floating-points numbers are \u0026lt;em\u0026gt;extremely\u0026lt;/em\u0026gt; accurate. They can represent any number in a very wide range with as much as 15 exact digits. For daily life computations, 4 or 5 digits are more than enough. You will never really need those 15, unless you want to count every millisecond of your lifetime.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Why can we not represent 9.2 in binary floating point?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Floating point numbers are (simplifying slightly) a positional numbering system with a restricted number of digits and a movable radix point.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A fraction can only be expressed exactly using a finite number of digits in a positional numbering system if the prime factors of the denominator (when the fraction is expressed in it\u0026apos;s lowest terms) are factors of the base.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The prime factors of 10 are 5 and 2, so in base 10 we can represent any fraction of the form a/(2\u0026lt;sup\u0026gt;b\u0026lt;/sup\u0026gt;5\u0026lt;sup\u0026gt;c\u0026lt;/sup\u0026gt;). \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;On the other hand the only prime factor of 2 is 2, so in base 2 we can only represent fractions of the form a/(2\u0026lt;sup\u0026gt;b\u0026lt;/sup\u0026gt;)\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Why do computers use this representation?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Because it\u0026apos;s a simple format to work with and it is sufficiently accurate for most purposes. Basically the same reason scientists use \u0026quot;scientific notation\u0026quot; and round their results to a reasonable number of digits at each step.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It would certainly be possible to define a fraction format, with (for example) a 32-bit numerator and a 32-bit denominator. It would be able to represent numbers that IEEE double precision floating point could not, but equally there would be many numbers that can be represented in double precision floating point that could not be represented in such a fixed-size fraction format. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However the big problem is that such a format is a pain to do calculations on. For two reasons.\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;If you want to have exactly one representation of each number then after each calculation you need to reduce the fraction to it\u0026apos;s lowest terms. That means that for every operation you basically need to do a greatest common divisor calculation.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If after your calculation you end up with an unrepresentable result because the numerator or denominator you need to find the closest representable result. This is non-trivil.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;Some Languages do offer fraction types, but usually they do it in combination with arbitary precision, this avoids needing to worry about approximating fractions but it creates it\u0026apos;s own problem, when a number passes through a large number of calculation steps the size of the denominator and hence the storage needed for the fraction can explode.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Some languages also offer decimal floating point types, these are mainly used in scenarios where it is imporant that the results the computer gets match pre-existing rounding rules that were written with humans in mind (chiefly financial calculations). These are slightly more difficult to work with than binary floating point, but the biggest problem is that most computers don\u0026apos;t offer hardware support for them.\u0026lt;/p\u0026gt;\n    "],"comment":["\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026lt;a href=\u0026quot;http://meta.stackoverflow.com/questions/260130/canonical-duplicate-for-floating-point-is-inaccurate\u0026quot;\u0026gt;Discussion of this post on Meta\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/811/shog9\u0026quot; title=\u0026quot;152,454 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Shog9\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment37345579_21895756\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-06-12 18:36:57Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 12, 2014 at 18:36\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Refer to \u0026lt;a href=\u0026quot;https://stackoverflow.com/q/588004/6521116\u0026quot;\u0026gt;is floating math broken\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/6521116/lf00\u0026quot; title=\u0026quot;24,937 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;LF00\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment75279553_21895756\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-05-23 09:12:39Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 23, 2017 at 9:12\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026lt;a href=\u0026quot;https://medium.com/swlh/why-floating-point-numbers-are-not-always-accurate-9a57e812ace1\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;medium.com/swlh/\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/12754117/rjhcnf\u0026quot; title=\u0026quot;416 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;rjhcnf\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment109592112_21895756\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2020-05-22 19:42:58Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 22, 2020 at 19:42\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;There is also a \u0026lt;a href=\u0026quot;http://kipirvine.com/asm/workbook/floating_tut.htm\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;nice tutorial\u0026lt;/a\u0026gt; that shows how to go the other way - given a decimal representation of a number, how do you construct the floating point equivalent. The \u0026quot;long division\u0026quot; approach shows very clearly how you end up with a \u0026quot;remainder\u0026quot; after trying to represent the number. Should be added if you want to be truly \u0026quot;canonical\u0026quot; with your answer.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1967396/floris\u0026quot; title=\u0026quot;45,073 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Floris\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment33158483_21895757\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-02-20 00:53:21Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 20, 2014 at 0:53\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;If you\u0026apos;re talking about Python and floating-point, I\u0026apos;d suggest at least including the Python tutorial in your links: \u0026lt;a href=\u0026quot;http://docs.python.org/3.4/tutorial/floatingpoint.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;docs.python.org/3.4/tutorial/floatingpoint.html\u0026lt;/a\u0026gt;  That\u0026apos;s supposed to be the one-stop go-to resource for floating-point issues for Python programmers.  If it\u0026apos;s lacking in some way (and it almost surely is), please do open an issue on the Python bug tracker for updates or changes.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/270986/mark-dickinson\u0026quot; title=\u0026quot;27,327 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Mark Dickinson\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment33168849_21895757\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-02-20 08:27:00Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 20, 2014 at 8:27\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@mhlester If this gets turned into community wiki, feel free to incorporate my answer into yours.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1072468/nicu-stiurca\u0026quot; title=\u0026quot;8,379 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Nicu Stiurca\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment33195846_21895757\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-02-20 19:08:04Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 20, 2014 at 19:08\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;This answer should definitely also link to \u0026lt;a href=\u0026quot;http://floating-point-gui.de/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;floating-point-gui.de\u0026lt;/a\u0026gt;, as it\u0026apos;s probably the best introduction for beginners. IMO, it should even go above \u0026quot;What every computer scientist should know...\u0026quot; -- these days, people who can reasonably comprehend Goldberg\u0026apos;s paper usually are already well aware of it.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/128397/daniel-pryden\u0026quot; title=\u0026quot;57,465 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Daniel Pryden\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment37385055_21895757\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-06-13 18:39:19Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 13, 2014 at 18:39\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026quot;This is one example of a ratio that can be expressed exactly in binary, but only approximately in decimal\u0026quot;. This is not true. All of these \u0026apos;number over a power of two\u0026apos; ratios are exact in decimal. Any approximation is only to shorten the decimal number -- for convenience.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/100914/rick-regan\u0026quot; title=\u0026quot;3,349 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Rick Regan\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment56576826_21895757\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-12-22 14:19:12Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 22, 2015 at 14:19\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;So in other words, \u0026lt;b\u0026gt;base-3\u0026lt;/b\u0026gt; would be perfect for \u0026lt;code\u0026gt;1/3\u0026lt;/code\u0026gt; just as \u0026lt;b\u0026gt;base-10\u0026lt;/b\u0026gt; is perfect for \u0026lt;code\u0026gt;1/10\u0026lt;/code\u0026gt;. Neither fraction works in \u0026lt;b\u0026gt;base-2\u0026lt;/b\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3130539/mhlester\u0026quot; title=\u0026quot;22,112 reputation\u0026quot; class=\u0026quot;comment-user owner\u0026quot;\u0026gt;mhlester\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment33158883_21896128\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-02-20 01:19:09Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 20, 2014 at 1:19\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@mhlester Yes. And in general, \u0026lt;b\u0026gt;base-N\u0026lt;/b\u0026gt; is perfect for any fraction whose denominator is \u0026lt;code\u0026gt;N\u0026lt;/code\u0026gt; or a multiple thereof.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1072468/nicu-stiurca\u0026quot; title=\u0026quot;8,379 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Nicu Stiurca\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment33158908_21896128\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-02-20 01:20:35Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 20, 2014 at 1:20\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;And this is one reason why some numerical tool boxes keep track of \u0026quot;what was divided by what\u0026quot;, and in the process can keep \u0026quot;infinite accuracy\u0026quot; for all rational numbers. Just like physicists like to keep their equations symbolic until the last possible moment, in case factors of \u0026lt;code\u0026gt;π\u0026lt;/code\u0026gt; etc cancel out.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1967396/floris\u0026quot; title=\u0026quot;45,073 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Floris\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment33159229_21896128\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-02-20 01:39:53Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 20, 2014 at 1:39\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Floris I\u0026apos;ve also seen cases where an algorithm that only performs basic arithmetic (ie, preserves rationality of input), determine if the input was (likely) rational, perform the math using normal floating point arithmetic, then re-estimate a rational approximation at the end to fix any rounding errors. In particular Matlab\u0026apos;s \u0026lt;a href=\u0026quot;http://www.mathworks.com/help/matlab/ref/rref.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;reduced row echelon form\u0026lt;/a\u0026gt; algorithm does this, and it help numerical stability tremendously.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1072468/nicu-stiurca\u0026quot; title=\u0026quot;8,379 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Nicu Stiurca\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment33159513_21896128\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-02-20 01:54:43Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 20, 2014 at 1:54\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@SchighSchagh - interesting, I didn\u0026apos;t know that. I do know that numerical stability is something that is not taught sufficiently in these days of double double precision. Which means that many miss learning about the elegance of many beautiful algorithms. I really like algorithms that compute and correct their own errors.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1967396/floris\u0026quot; title=\u0026quot;45,073 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Floris\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment33159678_21896128\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-02-20 02:04:31Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 20, 2014 at 2:04\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Interestingly, irrational bases do exist. \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Golden_ratio_base\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Phinary\u0026lt;/a\u0026gt;, for example.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1763356/veedrac\u0026quot; title=\u0026quot;54,787 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Veedrac\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment37340950_22023918\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-06-12 16:18:38Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 12, 2014 at 16:18\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;irrational numbers can be (only) represented in their base. For example pi is 10 in base pi\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/995714/phuclv\u0026quot; title=\u0026quot;32,962 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;phuclv\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment37721585_22023918\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-06-24 14:21:33Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 24, 2014 at 14:21\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Point remains valid: \u0026lt;i\u0026gt;Some numbers can never be represented no matter the system.\u0026lt;/i\u0026gt; You don\u0026apos;t gain anything by changing your base because then some other numbers can not be represented anymore.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/642532/jonas-b%c3%b6tel\u0026quot; title=\u0026quot;4,402 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Jonas Bötel\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment37823527_22023918\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-06-27 04:10:17Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 27, 2014 at 4:10\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;All constructible real numbers* can be represented exactly given an appropriate base; the choice of base is in fact infinite for any particular number. Eg, pi is 10 in base-pi, and it is 100 in base-sqrt(pi). In general, x is 10 in base-x, and it is 100 in base-x^(1/2), 1000 in base-x^(1/3), etc. *Non-constructible reals, if you allow for them via your choice of axioms, uhhh yeah shit gets real weird and nobody cares about digits anymore anyway. \u0026lt;b\u0026gt;Regardless of all this\u0026lt;/b\u0026gt;, these esoteric bases are not really useful; and there are always irrational numbers regardless of your choice of base.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1072468/nicu-stiurca\u0026quot; title=\u0026quot;8,379 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Nicu Stiurca\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment121364094_22023918\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2021-08-05 21:08:25Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 5, 2021 at 21:08\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        "],"id":230,"title":"Why are floating point numbers inaccurate?","content":"\n                \n\u0026lt;p\u0026gt;Why do some numbers lose accuracy when stored as floating point numbers?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example, the decimal number \u0026lt;code\u0026gt;9.2\u0026lt;/code\u0026gt; can be expressed exactly as a ratio of two decimal integers (\u0026lt;code\u0026gt;92/10\u0026lt;/code\u0026gt;), both of which can be expressed exactly in binary (\u0026lt;code\u0026gt;0b1011100/0b1010\u0026lt;/code\u0026gt;). However, the same ratio stored as a floating point number is never exactly equal to \u0026lt;code\u0026gt;9.2\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;32-bit \u0026quot;single precision\u0026quot; float: 9.19999980926513671875\n64-bit \u0026quot;double precision\u0026quot; float: 9.199999999999999289457264239899814128875732421875\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;How can such an apparently simple number be \u0026quot;too big\u0026quot; to express in \u0026lt;strong\u0026gt;64 bits\u0026lt;/strong\u0026gt; of memory?\u0026lt;/p\u0026gt;\n    ","slug":"why-are-floating-point-numbers-inaccurate-1657387346111","postType":"QUESTION","createdAt":"2022-07-09T17:22:26.000Z","updatedAt":"2022-07-09T17:22:26.000Z","tags":[{"id":1552,"name":"precision","slug":"precision","createdAt":"2022-07-09T17:22:26.000Z","updatedAt":"2022-07-09T17:22:26.000Z","Questions_Tags":{"questionId":230,"tagId":1552}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"why-are-floating-point-numbers-inaccurate-1657387346111"},"buildId":"4Y8KGE-c2lolBeBmcum_I","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>