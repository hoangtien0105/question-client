{"pageProps":{"data":{"count":610,"rows":[{"id":315,"title":"Is there a RegExp.escape function in JavaScript?","slug":"is-there-a-regexp.escape-function-in-javascript-1657387606651","postType":"QUESTION","createdAt":"2022-07-09T17:26:46.000Z","updatedAt":"2022-07-09T17:26:46.000Z","tags":[]},{"id":314,"title":"Using fflush(stdin)","slug":"using-fflush(stdin)-1657387602771","postType":"QUESTION","createdAt":"2022-07-09T17:26:42.000Z","updatedAt":"2022-07-09T17:26:42.000Z","tags":[{"id":1849,"name":"stdin","slug":"stdin","createdAt":"2022-07-09T17:26:42.000Z","updatedAt":"2022-07-09T17:26:42.000Z","Questions_Tags":{"questionId":314,"tagId":1849}},{"id":1850,"name":"fflush","slug":"fflush","createdAt":"2022-07-09T17:26:42.000Z","updatedAt":"2022-07-09T17:26:42.000Z","Questions_Tags":{"questionId":314,"tagId":1850}}]},{"id":313,"title":"String.equals versus == [duplicate]","slug":"string.equals-versus-duplicate-1657387599972","postType":"QUESTION","createdAt":"2022-07-09T17:26:39.000Z","updatedAt":"2022-07-09T17:26:39.000Z","tags":[]},{"id":312,"title":"How to choose the right bean scope?","slug":"how-to-choose-the-right-bean-scope-1657387596513","postType":"QUESTION","createdAt":"2022-07-09T17:26:36.000Z","updatedAt":"2022-07-09T17:26:36.000Z","tags":[{"id":1845,"name":"managed-bean","slug":"managed-bean","createdAt":"2022-07-09T17:26:36.000Z","updatedAt":"2022-07-09T17:26:36.000Z","Questions_Tags":{"questionId":312,"tagId":1845}}]},{"id":311,"title":"How do I merge two dictionaries in a single expression?","slug":"how-do-i-merge-two-dictionaries-in-a-single-expression-1657387593160","postType":"QUESTION","createdAt":"2022-07-09T17:26:33.000Z","updatedAt":"2022-07-09T17:26:33.000Z","tags":[]}]},"answers":{"311":["\n&lt;h2&gt;How can I merge two Python dictionaries in a single expression?&lt;/h2&gt;\n&lt;p&gt;For dictionaries &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, their shallowly-merged dictionary &lt;code&gt;z&lt;/code&gt; takes values from &lt;code&gt;y&lt;/code&gt;, replacing those from &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;In Python 3.9.0 or greater (released 17 October 2020, &lt;a href=&quot;https://www.python.org/dev/peps/pep-0584/&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;PEP-584&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://bugs.python.org/issue36144&quot; rel=&quot;noreferrer&quot;&gt;discussed here&lt;/a&gt;):&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;z = x | y\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;In Python 3.5 or greater:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;z = {**x, **y}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;In Python 2, (or 3.4 or lower) write a function:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;merge_two_dicts&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;x, y&lt;/span&gt;):\n    z = x.copy()   &lt;span class=&quot;hljs-comment&quot;&gt;# start with keys and values of x&lt;/span&gt;\n    z.update(y)    &lt;span class=&quot;hljs-comment&quot;&gt;# modifies z with keys and values of y&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; z\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;and now:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;z = merge_two_dicts(x, y)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3&gt;Explanation&lt;/h3&gt;\n&lt;p&gt;Say you have two dictionaries and you want to merge them into a new dictionary without altering the original dictionaries:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;x = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;}\ny = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The desired result is to get a new dictionary (&lt;code&gt;z&lt;/code&gt;) with the values merged, and the second dictionary&apos;s values overwriting those from the first.&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;z\n{&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;A new syntax for this, proposed in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0448&quot; rel=&quot;noreferrer&quot;&gt;PEP 448&lt;/a&gt; and &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2015-February/138564.html&quot; rel=&quot;noreferrer&quot;&gt;available as of Python 3.5&lt;/a&gt;, is&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;z = {**x, **y}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;And it is indeed a single expression.&lt;/p&gt;\n&lt;p&gt;Note that we can merge in with literal notation as well:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;z = {**x, &lt;span class=&quot;hljs-string&quot;&gt;&apos;foo&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;bar&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, **y}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;and now:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;z\n{&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;foo&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;bar&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;It is now showing as implemented in the &lt;a href=&quot;https://www.python.org/dev/peps/pep-0478/#features-for-3-5&quot; rel=&quot;noreferrer&quot;&gt;release schedule for 3.5, PEP 478&lt;/a&gt;, and it has now made its way into the &lt;a href=&quot;https://docs.python.org/dev/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations&quot; rel=&quot;noreferrer&quot;&gt;What&apos;s New in Python 3.5&lt;/a&gt; document.&lt;/p&gt;\n&lt;p&gt;However, since many organizations are still on Python 2, you may wish to do this in a backward-compatible way. The classically Pythonic way, available in Python 2 and Python 3.0-3.4, is to do this as a two-step process:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;z = x.copy()\nz.update(y) &lt;span class=&quot;hljs-comment&quot;&gt;# which returns None since it mutates z&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In both approaches, &lt;code&gt;y&lt;/code&gt; will come second and its values will replace &lt;code&gt;x&lt;/code&gt;&apos;s values, thus &lt;code&gt;b&lt;/code&gt; will point to &lt;code&gt;3&lt;/code&gt; in our final result.&lt;/p&gt;\n&lt;h2&gt;Not yet on Python 3.5, but want a &lt;em&gt;single expression&lt;/em&gt;&lt;/h2&gt;\n&lt;p&gt;If you are not yet on Python 3.5 or need to write backward-compatible code, and you want this in a &lt;em&gt;single expression&lt;/em&gt;, the most performant while the correct approach is to put it in a function:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;merge_two_dicts&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;x, y&lt;/span&gt;):\n    &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;Given two dictionaries, merge them into a new dict as a shallow copy.&quot;&quot;&quot;&lt;/span&gt;\n    z = x.copy()\n    z.update(y)\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; z\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;and then you have a single expression:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;z = merge_two_dicts(x, y)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;You can also make a function to merge an arbitrary number of dictionaries, from zero to a very large number:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;merge_dicts&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;*dict_args&lt;/span&gt;):\n    &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;\n    Given any number of dictionaries, shallow copy and merge into a new dict,\n    precedence goes to key-value pairs in latter dictionaries.\n    &quot;&quot;&quot;&lt;/span&gt;\n    result = {}\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; dictionary &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; dict_args:\n        result.update(dictionary)\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; result\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This function will work in Python 2 and 3 for all dictionaries. e.g. given dictionaries &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;g&lt;/code&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;z = merge_dicts(a, b, c, d, e, f, g) \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;and key-value pairs in &lt;code&gt;g&lt;/code&gt; will take precedence over dictionaries &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;f&lt;/code&gt;, and so on.&lt;/p&gt;\n&lt;h2&gt;Critiques of Other Answers&lt;/h2&gt;\n&lt;p&gt;Don&apos;t use what you see in the formerly accepted answer:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;z = &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(x.items() + y.items())\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In Python 2, you create two lists in memory for each dict, create a third list in memory with length equal to the length of the first two put together, and then discard all three lists to create the dict. &lt;strong&gt;In Python 3, this will fail&lt;/strong&gt; because you&apos;re adding two &lt;code&gt;dict_items&lt;/code&gt; objects together, not two lists -&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;c = &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(a.items() + b.items())\nTraceback (most recent call last):\n  File &lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;stdin&amp;gt;&quot;&lt;/span&gt;, line &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;\nTypeError: unsupported operand &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;(s) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; +: &lt;span class=&quot;hljs-string&quot;&gt;&apos;dict_items&apos;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;dict_items&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;and you would have to explicitly create them as lists, e.g. &lt;code&gt;z = dict(list(x.items()) + list(y.items()))&lt;/code&gt;. This is a waste of resources and computation power.&lt;/p&gt;\n&lt;p&gt;Similarly, taking the union of &lt;code&gt;items()&lt;/code&gt; in Python 3 (&lt;code&gt;viewitems()&lt;/code&gt; in Python 2.7) will also fail when values are unhashable objects (like lists, for example). Even if your values are hashable, &lt;strong&gt;since sets are semantically unordered, the behavior is undefined in regards to precedence. So don&apos;t do this:&lt;/strong&gt;&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;c = &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(a.items() | b.items())\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This example demonstrates what happens when values are unhashable:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;x = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: []}\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;y = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: []}\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(x.items() | y.items())\nTraceback (most recent call last):\n  File &lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;stdin&amp;gt;&quot;&lt;/span&gt;, line &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;\nTypeError: unhashable &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;list&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Here&apos;s an example where &lt;code&gt;y&lt;/code&gt; should have precedence, but instead the value from &lt;code&gt;x&lt;/code&gt; is retained due to the arbitrary order of sets:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;x = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;}\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;y = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;}\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(x.items() | y.items())\n{&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Another hack you should not use:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;z = &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(x, **y)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This uses the &lt;code&gt;dict&lt;/code&gt; constructor and is very fast and memory-efficient (even slightly more so than our two-step process) but unless you know precisely what is happening here (that is, the second dict is being passed as keyword arguments to the dict constructor), it&apos;s difficult to read, it&apos;s not the intended usage, and so it is not Pythonic.&lt;/p&gt;\n&lt;p&gt;Here&apos;s an example of the usage being &lt;a href=&quot;https://code.djangoproject.com/attachment/ticket/13357/django-pypy.2.diff&quot; rel=&quot;noreferrer&quot;&gt;remediated in django&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;Dictionaries are intended to take hashable keys (e.g. &lt;code&gt;frozenset&lt;/code&gt;s or tuples), but &lt;strong&gt;this method fails in Python 3 when keys are not strings.&lt;/strong&gt;&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;c = &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(a, **b)\nTraceback (most recent call last):\n  File &lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;stdin&amp;gt;&quot;&lt;/span&gt;, line &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;\nTypeError: keyword arguments must be strings\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;From the &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2010-April/099459.html&quot; rel=&quot;noreferrer&quot;&gt;mailing list&lt;/a&gt;, Guido van Rossum, the creator of the language, wrote:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;I am fine with\ndeclaring dict({}, **{1:3}) illegal, since after all it is abuse of\nthe ** mechanism.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;and&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Apparently dict(x, **y) is going around as &quot;cool hack&quot; for &quot;call\nx.update(y) and return x&quot;. Personally, I find it more despicable than\ncool.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;It is my understanding (as well as the understanding of the &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2010-April/099485.html&quot; rel=&quot;noreferrer&quot;&gt;creator of the language&lt;/a&gt;) that the intended usage for &lt;code&gt;dict(**y)&lt;/code&gt; is for creating dictionaries for readability purposes, e.g.:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(a=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, b=&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, c=&lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;instead of&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;{&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2&gt;Response to comments&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Despite what Guido says, &lt;code&gt;dict(x, **y)&lt;/code&gt; is in line with the dict specification, which btw. works for both Python 2 and 3. The fact that this only works for string keys is a direct consequence of how keyword parameters work and not a short-coming of dict. Nor is using the ** operator in this place an abuse of the mechanism, in fact, ** was designed precisely to pass dictionaries as keywords.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Again, it doesn&apos;t work for 3 when keys are not strings. The implicit calling contract is that namespaces take ordinary dictionaries, while users must only pass keyword arguments that are strings. All other callables enforced it. &lt;code&gt;dict&lt;/code&gt; broke this consistency in Python 2:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;foo(**{(&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;): &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;})\nTraceback (most recent call last):\n  File &lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;stdin&amp;gt;&quot;&lt;/span&gt;, line &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;\nTypeError: foo() keywords must be strings\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(**{(&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;): &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;})\n{(&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;): &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This inconsistency was bad given other implementations of Python (PyPy, Jython, IronPython). Thus it was fixed in Python 3, as this usage could be a breaking change.&lt;/p&gt;\n&lt;p&gt;I submit to you that it is malicious incompetence to intentionally write code that only works in one version of a language or that only works given certain arbitrary constraints.&lt;/p&gt;\n&lt;p&gt;More comments:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;code&gt;dict(x.items() + y.items())&lt;/code&gt; is still the most readable solution for Python 2. Readability counts.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;My response: &lt;code&gt;merge_two_dicts(x, y)&lt;/code&gt; actually seems much clearer to me, if we&apos;re actually concerned about readability. And it is not forward compatible, as Python 2 is increasingly deprecated.&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;code&gt;{**x, **y}&lt;/code&gt; does not seem to handle nested dictionaries. the contents of nested keys are simply overwritten, not merged [...] I ended up being burnt by these answers that do not merge recursively and I was surprised no one mentioned it. In my interpretation of the word &quot;merging&quot; these answers describe &quot;updating one dict with another&quot;, and not merging.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Yes. I must refer you back to the question, which is asking for a &lt;em&gt;shallow&lt;/em&gt; merge of &lt;em&gt;&lt;strong&gt;two&lt;/strong&gt;&lt;/em&gt; dictionaries, with the first&apos;s values being overwritten by the second&apos;s - in a single expression.&lt;/p&gt;\n&lt;p&gt;Assuming two dictionaries of dictionaries, one might recursively merge them in a single function, but you should be careful not to modify the dictionaries from either source, and the surest way to avoid that is to make a copy when assigning values. As keys must be hashable and are usually therefore immutable, it is pointless to copy them:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; copy &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; deepcopy\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;dict_of_dicts_merge&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;x, y&lt;/span&gt;):\n    z = {}\n    overlapping_keys = x.keys() &amp;amp; y.keys()\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; key &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; overlapping_keys:\n        z[key] = dict_of_dicts_merge(x[key], y[key])\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; key &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; x.keys() - overlapping_keys:\n        z[key] = deepcopy(x[key])\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; key &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; y.keys() - overlapping_keys:\n        z[key] = deepcopy(y[key])\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; z\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Usage:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;x = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;:{&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;:{}}, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: {&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;:{}}}\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;y = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;:{&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;:{}}, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: {&lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;:{}}}\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;dict_of_dicts_merge(x, y)\n{&lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: {&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;: {}, &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;: {}}, &lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: {&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;: {}}, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: {&lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;: {}}}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Coming up with contingencies for other value types is far beyond the scope of this question, so I will point you at &lt;a href=&quot;https://stackoverflow.com/a/24088493/541136&quot;&gt;my answer to the canonical question on a &quot;Dictionaries of dictionaries merge&quot;&lt;/a&gt;.&lt;/p&gt;\n&lt;h2&gt;Less Performant But Correct Ad-hocs&lt;/h2&gt;\n&lt;p&gt;These approaches are less performant, but they will provide correct behavior.\nThey will be &lt;em&gt;much less&lt;/em&gt; performant than &lt;code&gt;copy&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; or the new unpacking because they iterate through each key-value pair at a higher level of abstraction, but they &lt;em&gt;do&lt;/em&gt; respect the order of precedence (latter dictionaries have precedence)&lt;/p&gt;\n&lt;p&gt;You can also chain the dictionaries manually inside a &lt;a href=&quot;https://www.python.org/dev/peps/pep-0274/&quot; rel=&quot;noreferrer&quot;&gt;dict comprehension&lt;/a&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;{k: v &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; d &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; dicts &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; k, v &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; d.items()} &lt;span class=&quot;hljs-comment&quot;&gt;# iteritems in Python 2.7&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;or in Python 2.6 (and perhaps as early as 2.4 when generator expressions were introduced):&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;((k, v) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; d &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; dicts &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; k, v &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; d.items()) &lt;span class=&quot;hljs-comment&quot;&gt;# iteritems in Python 2&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;itertools.chain&lt;/code&gt; will chain the iterators over the key-value pairs in the correct order:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; itertools &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; chain\nz = &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(chain(x.items(), y.items())) &lt;span class=&quot;hljs-comment&quot;&gt;# iteritems in Python 2&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2&gt;Performance Analysis&lt;/h2&gt;\n&lt;p&gt;I&apos;m only going to do the performance analysis of the usages known to behave correctly. (Self-contained so you can copy and paste yourself.)&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; timeit &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; repeat\n&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; itertools &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; chain\n\nx = &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;.fromkeys(&lt;span class=&quot;hljs-string&quot;&gt;&apos;abcdefg&apos;&lt;/span&gt;)\ny = &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;.fromkeys(&lt;span class=&quot;hljs-string&quot;&gt;&apos;efghijk&apos;&lt;/span&gt;)\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;merge_two_dicts&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;x, y&lt;/span&gt;):\n    z = x.copy()\n    z.update(y)\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; z\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;min&lt;/span&gt;(repeat(&lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt;: {**x, **y}))\n&lt;span class=&quot;hljs-built_in&quot;&gt;min&lt;/span&gt;(repeat(&lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt;: merge_two_dicts(x, y)))\n&lt;span class=&quot;hljs-built_in&quot;&gt;min&lt;/span&gt;(repeat(&lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt;: {k: v &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; d &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; (x, y) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; k, v &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; d.items()}))\n&lt;span class=&quot;hljs-built_in&quot;&gt;min&lt;/span&gt;(repeat(&lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt;: &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(chain(x.items(), y.items()))))\n&lt;span class=&quot;hljs-built_in&quot;&gt;min&lt;/span&gt;(repeat(&lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt;: &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(item &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; d &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; (x, y) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; item &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; d.items())))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In Python 3.8.1, NixOS:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;min&lt;/span&gt;(repeat(&lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt;: {**x, **y}))\n&lt;span class=&quot;hljs-number&quot;&gt;1.0804965235292912&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;min&lt;/span&gt;(repeat(&lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt;: merge_two_dicts(x, y)))\n&lt;span class=&quot;hljs-number&quot;&gt;1.636518670246005&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;min&lt;/span&gt;(repeat(&lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt;: {k: v &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; d &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; (x, y) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; k, v &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; d.items()}))\n&lt;span class=&quot;hljs-number&quot;&gt;3.1779992282390594&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;min&lt;/span&gt;(repeat(&lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt;: &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(chain(x.items(), y.items()))))\n&lt;span class=&quot;hljs-number&quot;&gt;2.740647904574871&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;min&lt;/span&gt;(repeat(&lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt;: &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(item &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; d &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; (x, y) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; item &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; d.items())))\n&lt;span class=&quot;hljs-number&quot;&gt;4.266070580109954&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre class=&quot;lang-sh s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;$ &lt;span class=&quot;hljs-built_in&quot;&gt;uname&lt;/span&gt; -a\nLinux nixos 4.19.113 &lt;span class=&quot;hljs-comment&quot;&gt;#1-NixOS SMP Wed Mar 25 07:06:15 UTC 2020 x86_64 GNU/Linux&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2&gt;Resources on Dictionaries&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/327311/how-are-pythons-built-in-dictionaries-implemented/44509302#44509302&quot;&gt;My explanation of Python&apos;s &lt;strong&gt;dictionary implementation&lt;/strong&gt;, updated for 3.6.&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1024847/add-new-keys-to-a-dictionary/27208535#27208535&quot;&gt;Answer on how to add new keys to a dictionary&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/209840/map-two-lists-into-a-dictionary-in-python/33737067#33737067&quot;&gt;Mapping two lists into a dictionary&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://docs.python.org/3/tutorial/datastructures.html#dictionaries&quot; rel=&quot;noreferrer&quot;&gt;The official Python docs on dictionaries&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=66P5FMkWoVU&quot; rel=&quot;noreferrer&quot;&gt;The Dictionary Even Mightier&lt;/a&gt; - talk by Brandon Rhodes at Pycon 2017&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=npw4s1QTmPg&quot; rel=&quot;noreferrer&quot;&gt;Modern Python Dictionaries, A Confluence of Great Ideas&lt;/a&gt; - talk by Raymond Hettinger at Pycon 2017&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;In your case, what you can do is:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;z = &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt;(x.items()) + &lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt;(y.items()))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This will, as you want it, put the final dict in &lt;code&gt;z&lt;/code&gt;, and make the value for key &lt;code&gt;b&lt;/code&gt; be properly overridden by the second (&lt;code&gt;y&lt;/code&gt;) dict&apos;s value:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;x = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;}\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;y = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;}\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;z = &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt;(x.items()) + &lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt;(y.items()))\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;z\n{&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;If you use Python 2, you can even remove the &lt;code&gt;list()&lt;/code&gt; calls. To create z:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;z = &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(x.items() + y.items())\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;z\n{&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;If you use Python version 3.9.0a4 or greater, then you can directly use:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;x = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;}\ny = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;}\nz = x | y\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(z)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;{&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;An alternative:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;z = x.copy()\nz.update(y)\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Another, more concise, option:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;z = &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(x, **y)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: this has become a popular answer, but it is important to point out that if &lt;code&gt;y&lt;/code&gt; has any non-string keys, the fact that this works at all is an abuse of a CPython implementation detail, and it does not work in Python 3, or in PyPy, IronPython, or Jython. Also, &lt;a href=&quot;http://mail.python.org/pipermail/python-dev/2010-April/099459.html&quot; rel=&quot;noreferrer&quot;&gt;Guido is not a fan&lt;/a&gt;. So I can&apos;t recommend this technique for forward-compatible or cross-implementation portable code, which really means it should be avoided entirely.&lt;/p&gt;\n    ","\n&lt;p&gt;This probably won&apos;t be a popular answer, but you almost certainly do not want to do this.  If you want a copy that&apos;s a merge, then use copy (or &lt;a href=&quot;https://docs.python.org/2/library/copy.html&quot; rel=&quot;noreferrer&quot;&gt;deepcopy&lt;/a&gt;, depending on what you want) and then update.  The two lines of code are much more readable - more Pythonic - than the single line creation with .items() + .items().  Explicit is better than implicit.&lt;/p&gt;\n\n&lt;p&gt;In addition, when you use .items() (pre Python 3.0), you&apos;re creating a new list that contains the items from the dict.  If your dictionaries are large, then that is quite a lot of overhead (two large lists that will be thrown away as soon as the merged dict is created).  update() can work more efficiently, because it can run through the second dict item-by-item.&lt;/p&gt;\n\n&lt;p&gt;In terms of &lt;a href=&quot;https://docs.python.org/2/library/timeit.html&quot; rel=&quot;noreferrer&quot;&gt;time&lt;/a&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;timeit.Timer(&lt;span class=&quot;hljs-string&quot;&gt;&quot;dict(x, **y)&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;x = dict(zip(range(1000), range(1000)))\\ny=dict(zip(range(1000,2000), range(1000,2000)))&quot;&lt;/span&gt;).timeit(&lt;span class=&quot;hljs-number&quot;&gt;100000&lt;/span&gt;)\n&lt;span class=&quot;hljs-number&quot;&gt;15.52571702003479&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;timeit.Timer(&lt;span class=&quot;hljs-string&quot;&gt;&quot;temp = x.copy()\\ntemp.update(y)&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;x = dict(zip(range(1000), range(1000)))\\ny=dict(zip(range(1000,2000), range(1000,2000)))&quot;&lt;/span&gt;).timeit(&lt;span class=&quot;hljs-number&quot;&gt;100000&lt;/span&gt;)\n&lt;span class=&quot;hljs-number&quot;&gt;15.694622993469238&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;timeit.Timer(&lt;span class=&quot;hljs-string&quot;&gt;&quot;dict(x.items() + y.items())&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;x = dict(zip(range(1000), range(1000)))\\ny=dict(zip(range(1000,2000), range(1000,2000)))&quot;&lt;/span&gt;).timeit(&lt;span class=&quot;hljs-number&quot;&gt;100000&lt;/span&gt;)\n&lt;span class=&quot;hljs-number&quot;&gt;41.484580039978027&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;IMO the tiny slowdown between the first two is worth it for the readability.  In addition, keyword arguments for dictionary creation was only added in Python 2.3, whereas copy() and update() will work in older versions.&lt;/p&gt;\n    ","\n&lt;p&gt;In a follow-up answer, you asked about the relative performance of these two alternatives:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;z1 = &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(x.items() + y.items())\nz2 = &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(x, **y)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;On my machine, at least (a fairly ordinary x86_64 running Python 2.5.2), alternative &lt;code&gt;z2&lt;/code&gt; is not only shorter and simpler but also significantly faster.  You can verify this for yourself using the &lt;code&gt;timeit&lt;/code&gt; module that comes with Python.&lt;/p&gt;\n\n&lt;p&gt;Example 1: identical dictionaries mapping 20 consecutive integers to themselves:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;% python -m timeit -s &lt;span class=&quot;hljs-string&quot;&gt;&apos;x=y=dict((i,i) for i in range(20))&apos;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;z1=dict(x.items() + y.items())&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;100000&lt;/span&gt; loops, best of &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;5.67&lt;/span&gt; usec per loop\n% python -m timeit -s &lt;span class=&quot;hljs-string&quot;&gt;&apos;x=y=dict((i,i) for i in range(20))&apos;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;z2=dict(x, **y)&apos;&lt;/span&gt; \n&lt;span class=&quot;hljs-number&quot;&gt;100000&lt;/span&gt; loops, best of &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1.53&lt;/span&gt; usec per loop\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;z2&lt;/code&gt; wins by a factor of 3.5 or so.  Different dictionaries seem to yield quite different results, but &lt;code&gt;z2&lt;/code&gt; always seems to come out ahead.  (If you get inconsistent results for the &lt;em&gt;same&lt;/em&gt; test, try passing in &lt;code&gt;-r&lt;/code&gt; with a number larger than the default 3.)&lt;/p&gt;\n\n&lt;p&gt;Example 2: non-overlapping dictionaries mapping 252 short strings to integers and vice versa:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;% python -m timeit -s &lt;span class=&quot;hljs-string&quot;&gt;&apos;from htmlentitydefs import codepoint2name as x, name2codepoint as y&apos;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;z1=dict(x.items() + y.items())&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt; loops, best of &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;260&lt;/span&gt; usec per loop\n% python -m timeit -s &lt;span class=&quot;hljs-string&quot;&gt;&apos;from htmlentitydefs import codepoint2name as x, name2codepoint as y&apos;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;z2=dict(x, **y)&apos;&lt;/span&gt;               \n&lt;span class=&quot;hljs-number&quot;&gt;10000&lt;/span&gt; loops, best of &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;26.9&lt;/span&gt; usec per loop\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;z2&lt;/code&gt; wins by about a factor of 10.  That&apos;s a pretty big win in my book!&lt;/p&gt;\n\n&lt;p&gt;After comparing those two, I wondered if &lt;code&gt;z1&lt;/code&gt;&apos;s poor performance could be attributed to the overhead of constructing the two item lists, which in turn led me to wonder if this variation might work better:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; itertools &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; chain\nz3 = &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(chain(x.iteritems(), y.iteritems()))\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;A few quick tests, e.g.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;% python -m timeit -s &lt;span class=&quot;hljs-string&quot;&gt;&apos;from itertools import chain; from htmlentitydefs import codepoint2name as x, name2codepoint as y&apos;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;z3=dict(chain(x.iteritems(), y.iteritems()))&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;10000&lt;/span&gt; loops, best of &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;66&lt;/span&gt; usec per loop\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;lead me to conclude that &lt;code&gt;z3&lt;/code&gt; is somewhat faster than &lt;code&gt;z1&lt;/code&gt;, but not nearly as fast as &lt;code&gt;z2&lt;/code&gt;.  Definitely not worth all the extra typing.&lt;/p&gt;\n\n&lt;p&gt;This discussion is still missing something important, which is a performance comparison of these alternatives with the &quot;obvious&quot; way of merging two lists: using the &lt;code&gt;update&lt;/code&gt; method.  To try to keep things on an equal footing with the expressions, none of which modify x or y, I&apos;m going to make a copy of x instead of modifying it in-place, as follows:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;z0 = &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(x)\nz0.update(y)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;A typical result:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;% python -m timeit -s &lt;span class=&quot;hljs-string&quot;&gt;&apos;from htmlentitydefs import codepoint2name as x, name2codepoint as y&apos;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;z0=dict(x); z0.update(y)&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;10000&lt;/span&gt; loops, best of &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;26.9&lt;/span&gt; usec per loop\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In other words, &lt;code&gt;z0&lt;/code&gt; and &lt;code&gt;z2&lt;/code&gt; seem to have essentially identical performance.  Do you think this might be a coincidence?  I don&apos;t....&lt;/p&gt;\n\n&lt;p&gt;In fact, I&apos;d go so far as to claim that it&apos;s impossible for pure Python code to do any better than this.  And if you can do significantly better in a C extension module, I imagine the Python folks might well be interested in incorporating your code (or a variation on your approach) into the Python core.  Python uses &lt;code&gt;dict&lt;/code&gt; in lots of places; optimizing its operations is a big deal.&lt;/p&gt;\n\n&lt;p&gt;You could also write this as&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;z0 = x.copy()\nz0.update(y)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;as Tony does, but (not surprisingly) the difference in notation turns out not to have any measurable effect on performance.  Use whichever looks right to you.  Of course, he&apos;s absolutely correct to point out that the two-statement version is much easier to understand.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;In Python 3.0 and later&lt;/strong&gt;, you can use &lt;a href=&quot;http://docs.python.org/3/library/collections.html#collections.ChainMap&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;collections.ChainMap&lt;/code&gt;&lt;/a&gt; which groups multiple dicts or other mappings together to create a single, updateable view:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; collections &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; ChainMap\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;x = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;}\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;y = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;}\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;z = &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(ChainMap({}, y, x))\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; k, v &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; z.items():\n        &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(k, &lt;span class=&quot;hljs-string&quot;&gt;&apos;--&amp;gt;&apos;&lt;/span&gt;, v)\n    \na --&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\nb --&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;\nc --&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;Update for Python 3.5 and later&lt;/strong&gt;: You can use &lt;a href=&quot;https://www.python.org/dev/peps/pep-0448/&quot; rel=&quot;noreferrer&quot;&gt;PEP 448&lt;/a&gt; extended dictionary packing and unpacking.  This is fast and easy:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;x = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;}\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;y = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;}\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;{**x, **y}\n{&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;Update for Python 3.9 and later&lt;/strong&gt;:  You can use the &lt;a href=&quot;https://www.python.org/dev/peps/pep-0584/&quot; rel=&quot;noreferrer&quot;&gt;PEP 584&lt;/a&gt; union operator:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;x = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;}\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;y = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;}\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;x | y\n{&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I wanted something similar, but with the ability to specify how the values on duplicate keys were merged, so I hacked this out (but did not heavily test it).  Obviously this is not a single expression, but it is a single function call.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;merge&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;d1, d2, merge_fn=&lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt; x,y:y&lt;/span&gt;):\n    &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;\n    Merges two dictionaries, non-destructively, combining \n    values on duplicate keys as defined by the optional merge\n    function.  The default behavior replaces the values in d1\n    with corresponding values in d2.  (There is no other generally\n    applicable merge strategy, but often you&apos;ll have homogeneous \n    types in your dicts, so specifying a merge technique can be \n    valuable.)\n\n    Examples:\n\n    &amp;gt;&amp;gt;&amp;gt; d1\n    {&apos;a&apos;: 1, &apos;c&apos;: 3, &apos;b&apos;: 2}\n    &amp;gt;&amp;gt;&amp;gt; merge(d1, d1)\n    {&apos;a&apos;: 1, &apos;c&apos;: 3, &apos;b&apos;: 2}\n    &amp;gt;&amp;gt;&amp;gt; merge(d1, d1, lambda x,y: x+y)\n    {&apos;a&apos;: 2, &apos;c&apos;: 6, &apos;b&apos;: 4}\n\n    &quot;&quot;&quot;&lt;/span&gt;\n    result = &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(d1)\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; k,v &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; d2.iteritems():\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; k &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; result:\n            result[k] = merge_fn(result[k], v)\n        &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:\n            result[k] = v\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; result\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;h1&gt;Recursively/deep update a dict&lt;/h1&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;deepupdate&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;original, update&lt;/span&gt;):\n    &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;\n    Recursively update a dict.\n    Subdict&apos;s won&apos;t be overwritten but also updated.\n    &quot;&quot;&quot;&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; key, value &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; original.iteritems(): \n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; key &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; update:\n            update[key] = value\n        &lt;span class=&quot;hljs-keyword&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;isinstance&lt;/span&gt;(value, &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;):\n            deepupdate(value, update[key]) \n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; update&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Demonstration:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;pluto_original = {\n    &lt;span class=&quot;hljs-string&quot;&gt;&apos;name&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;Pluto&apos;&lt;/span&gt;,\n    &lt;span class=&quot;hljs-string&quot;&gt;&apos;details&apos;&lt;/span&gt;: {\n        &lt;span class=&quot;hljs-string&quot;&gt;&apos;tail&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;,\n        &lt;span class=&quot;hljs-string&quot;&gt;&apos;color&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;orange&apos;&lt;/span&gt;\n    }\n}\n\npluto_update = {\n    &lt;span class=&quot;hljs-string&quot;&gt;&apos;name&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;Pluutoo&apos;&lt;/span&gt;,\n    &lt;span class=&quot;hljs-string&quot;&gt;&apos;details&apos;&lt;/span&gt;: {\n        &lt;span class=&quot;hljs-string&quot;&gt;&apos;color&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;blue&apos;&lt;/span&gt;\n    }\n}\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; deepupdate(pluto_original, pluto_update)&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Outputs:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;{\n    &lt;span class=&quot;hljs-string&quot;&gt;&apos;name&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;Pluutoo&apos;&lt;/span&gt;,\n    &lt;span class=&quot;hljs-string&quot;&gt;&apos;details&apos;&lt;/span&gt;: {\n        &lt;span class=&quot;hljs-string&quot;&gt;&apos;color&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;blue&apos;&lt;/span&gt;,\n        &lt;span class=&quot;hljs-string&quot;&gt;&apos;tail&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n    }\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Thanks rednaw for edits.&lt;/p&gt;\n    ","\n&lt;p&gt;Python 3.5 (PEP 448) allows a nicer syntax option:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;x = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;}\ny = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;}\nfinal = {**x, **y} \nfinal\n&lt;span class=&quot;hljs-comment&quot;&gt;# {&apos;a&apos;: 2, &apos;b&apos;: 1, &apos;c&apos;: 2}&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Or even &lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;final = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, **x, **y}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In Python 3.9 you also use | and |= with the below example from PEP 584&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;d = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;spam&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;eggs&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;cheese&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;}\ne = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;cheese&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;cheddar&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;aardvark&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;Ethel&apos;&lt;/span&gt;}\nd | e\n&lt;span class=&quot;hljs-comment&quot;&gt;# {&apos;spam&apos;: 1, &apos;eggs&apos;: 2, &apos;cheese&apos;: &apos;cheddar&apos;, &apos;aardvark&apos;: &apos;Ethel&apos;}&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;The best version I could think while not using copy would be:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; itertools &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; chain\nx = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;}\ny = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;}\n&lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(chain(x.iteritems(), y.iteritems()))\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It&apos;s faster than &lt;code&gt;dict(x.items() + y.items())&lt;/code&gt; but not as fast as &lt;code&gt;n = copy(a); n.update(b)&lt;/code&gt;, at least on CPython. This version also works in Python 3 if you change &lt;code&gt;iteritems()&lt;/code&gt; to &lt;code&gt;items()&lt;/code&gt;, which is automatically done by the 2to3 tool.&lt;/p&gt;\n\n&lt;p&gt;Personally I like this version best because it describes fairly good what I want in a single  functional syntax. The only minor problem is that it doesn&apos;t make completely obvious that values from y takes precedence over values from x, but I don&apos;t believe it&apos;s difficult to figure that out.&lt;/p&gt;\n    ","\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;x = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;}\ny = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;}\nz = &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(x.items() + y.items())\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; z\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;For items with keys in both dictionaries (&apos;b&apos;), you can control which one ends up in the output by putting that one last.&lt;/p&gt;\n    ","\n&lt;p&gt;While the question has already been answered several times,\nthis simple solution to the problem has not been listed yet.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;x = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;}\ny = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;}\nz4 = {}\nz4.update(x)\nz4.update(y)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It is as fast as z0 and the evil z2 mentioned above, but easy to understand and change.&lt;/p&gt;\n    ","\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;dict_merge&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;a, b&lt;/span&gt;):\n  c = a.copy()\n  c.update(b)\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; c\n\nnew = dict_merge(old, extras)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Among such shady and dubious answers, this shining example is the one and only good way to merge dicts in Python, endorsed by dictator for life &lt;em&gt;Guido van Rossum&lt;/em&gt; himself!  Someone else suggested half of this, but did not put it in a function.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; dict_merge(\n      {&lt;span class=&quot;hljs-string&quot;&gt;&apos;color&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-string&quot;&gt;&apos;red&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;model&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-string&quot;&gt;&apos;Mini&apos;&lt;/span&gt;},\n      {&lt;span class=&quot;hljs-string&quot;&gt;&apos;model&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-string&quot;&gt;&apos;Ferrari&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;owner&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-string&quot;&gt;&apos;Carl&apos;&lt;/span&gt;})\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;gives:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;{&lt;span class=&quot;hljs-string&quot;&gt;&apos;color&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;red&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;owner&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;Carl&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;model&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;Ferrari&apos;&lt;/span&gt;}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;If you think lambdas are evil then read no further.\nAs requested, you can write the fast and memory-efficient solution with one expression:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;x = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;}\ny = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;}\nz = (&lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt; a, b: (&lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt; a_copy: a_copy.update(b) &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; a_copy)(a.copy()))(x, y)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; z\n{&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;}\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; x\n{&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;As suggested above, using two lines or writing a function is probably a better way to go.&lt;/p&gt;\n    ","\n&lt;p&gt;Be pythonic. Use a &lt;a href=&quot;https://docs.python.org/2/tutorial/datastructures.html#dictionaries&quot; rel=&quot;nofollow noreferrer&quot;&gt;comprehension&lt;/a&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;z={k: v &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; d &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; [x,y] &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; k, v &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; d.items()}\n\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; z\n{&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;In python3, the &lt;code&gt;items&lt;/code&gt; method &lt;a href=&quot;http://docs.python.org/dev/whatsnew/3.0.html#views-and-iterators-instead-of-lists&quot; rel=&quot;noreferrer&quot;&gt;no longer returns a list&lt;/a&gt;, but rather a &lt;em&gt;view&lt;/em&gt;, which acts like a set. In this case you&apos;ll need to take the set union since concatenating with &lt;code&gt;+&lt;/code&gt; won&apos;t work:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(x.items() | y.items())\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;For python3-like behavior in version 2.7, the &lt;code&gt;viewitems&lt;/code&gt; method should work in place of &lt;code&gt;items&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(x.viewitems() | y.viewitems())\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I prefer this notation anyways since it seems more natural to think of it as a set union operation rather than concatenation (as the title shows).&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;A couple more points for python 3. First, note that the &lt;code&gt;dict(x, **y)&lt;/code&gt; trick won&apos;t work in python 3 unless the keys in &lt;code&gt;y&lt;/code&gt; are strings.&lt;/p&gt;\n\n&lt;p&gt;Also, Raymond Hettinger&apos;s Chainmap &lt;a href=&quot;https://stackoverflow.com/a/16259217/386279&quot;&gt;answer&lt;/a&gt; is pretty elegant, since it can take an arbitrary number of dicts as arguments, but &lt;a href=&quot;http://docs.python.org/dev/library/collections&quot; rel=&quot;noreferrer&quot;&gt;from the docs&lt;/a&gt; it looks like it sequentially looks through a list of all the dicts for each lookup:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Lookups search the underlying mappings successively until a key is found.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;This can slow you down if you have a lot of lookups in your application:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]: &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; collections &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; ChainMap\nIn [&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]: &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; string &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; ascii_uppercase &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; up, ascii_lowercase &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; lo; x = &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;zip&lt;/span&gt;(lo, up)); y = &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;zip&lt;/span&gt;(up, lo))\nIn [&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]: chainmap_dict = ChainMap(y, x)\nIn [&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;]: union_dict = &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(x.items() | y.items())\nIn [&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;]: timeit &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; k &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; union_dict: union_dict[k]\n&lt;span class=&quot;hljs-number&quot;&gt;100000&lt;/span&gt; loops, best of &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2.15&lt;/span&gt; µs per loop\nIn [&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;]: timeit &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; k &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; chainmap_dict: chainmap_dict[k]\n&lt;span class=&quot;hljs-number&quot;&gt;10000&lt;/span&gt; loops, best of &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;27.1&lt;/span&gt; µs per loop\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So about an order of magnitude slower for lookups. I&apos;m a fan of Chainmap, but looks less practical where there may be many lookups.&lt;/p&gt;\n    ","\n&lt;p&gt;I benchmarked the suggested with &lt;a href=&quot;https://github.com/nschloe/perfplot&quot; rel=&quot;noreferrer&quot;&gt;perfplot&lt;/a&gt; and found that the good old&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;temp = x.copy()\ntemp.update(y)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;is the fastest solution together with the new (Python 3.9+)&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;x | y\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/z8pG1.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/z8pG1.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;Code to reproduce the plot:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; collections &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; ChainMap\n&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; itertools &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; chain\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; perfplot\n\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;setup&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;n&lt;/span&gt;):\n    x = &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;zip&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;range&lt;/span&gt;(n), &lt;span class=&quot;hljs-built_in&quot;&gt;range&lt;/span&gt;(n)))\n    y = &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;zip&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;range&lt;/span&gt;(n, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; * n), &lt;span class=&quot;hljs-built_in&quot;&gt;range&lt;/span&gt;(n, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; * n)))\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; x, y\n\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;copy_update&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;data&lt;/span&gt;):\n    x, y = data\n    temp = x.copy()\n    temp.update(y)\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; temp\n\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;add_items&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;data&lt;/span&gt;):\n    x, y = data\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt;(x.items()) + &lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt;(y.items()))\n\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;curly_star&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;data&lt;/span&gt;):\n    x, y = data\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; {**x, **y}\n\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;chain_map&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;data&lt;/span&gt;):\n    x, y = data\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(ChainMap({}, y, x))\n\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;itertools_chain&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;data&lt;/span&gt;):\n    x, y = data\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(chain(x.items(), y.items()))\n\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;python39_concat&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;data&lt;/span&gt;):\n    x, y = data\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; x | y\n\n\nb = perfplot.bench(\n    setup=setup,\n    kernels=[\n        copy_update,\n        add_items,\n        curly_star,\n        chain_map,\n        itertools_chain,\n        python39_concat,\n    ],\n    labels=[\n        &lt;span class=&quot;hljs-string&quot;&gt;&quot;copy_update&quot;&lt;/span&gt;,\n        &lt;span class=&quot;hljs-string&quot;&gt;&quot;dict(list(x.items()) + list(y.items()))&quot;&lt;/span&gt;,\n        &lt;span class=&quot;hljs-string&quot;&gt;&quot;{**x, **y}&quot;&lt;/span&gt;,\n        &lt;span class=&quot;hljs-string&quot;&gt;&quot;chain_map&quot;&lt;/span&gt;,\n        &lt;span class=&quot;hljs-string&quot;&gt;&quot;itertools.chain&quot;&lt;/span&gt;,\n        &lt;span class=&quot;hljs-string&quot;&gt;&quot;x | y&quot;&lt;/span&gt;,\n    ],\n    n_range=[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; ** k &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; k &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;18&lt;/span&gt;)],\n    xlabel=&lt;span class=&quot;hljs-string&quot;&gt;&quot;len(x), len(y)&quot;&lt;/span&gt;,\n    equality_check=&lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;,\n)\nb.save(&lt;span class=&quot;hljs-string&quot;&gt;&quot;out.png&quot;&lt;/span&gt;)\nb.show()\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Two dictionaries&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;union2&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;dict1, dict2&lt;/span&gt;):\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt;(dict1.items()) + &lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt;(dict2.items()))\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;em&gt;n&lt;/em&gt; dictionaries&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;union&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;*dicts&lt;/span&gt;):\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(itertools.chain.from_iterable(dct.items() &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; dct &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; dicts))\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;sum&lt;/code&gt; has bad performance. See &lt;a href=&quot;https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/&quot; rel=&quot;noreferrer&quot;&gt;https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Simple solution using itertools that preserves order (latter dicts have precedence)&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# py2&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; itertools &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; chain, imap\nmerge = &lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt; *args: &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(chain.from_iterable(imap(&lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;.iteritems, args)))\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# py3&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; itertools &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; chain\nmerge = &lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt; *args: &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(chain.from_iterable(&lt;span class=&quot;hljs-built_in&quot;&gt;map&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;.items, args)))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;And it&apos;s usage:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;x = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;}\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;y = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;}\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;merge(x, y)\n{&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;}\n\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;z = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;d&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;}\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;merge(x, y, z)\n{&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;d&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Abuse leading to a one-expression solution for &lt;a href=&quot;https://stackoverflow.com/a/39437/15055&quot;&gt;Matthew&apos;s answer&lt;/a&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;x = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;}\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;y = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;}\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;z = (&lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt; f=x.copy(): (f.update(y), f)[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;])()\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;z\n{&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You said you wanted one expression, so I abused &lt;code&gt;lambda&lt;/code&gt; to bind a name, and tuples to override lambda&apos;s one-expression limit. Feel free to cringe.&lt;/p&gt;\n\n&lt;p&gt;You could also do this of course if you don&apos;t care about copying it:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;x = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;}\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;y = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;}\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;z = (x.update(y), x)[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;z\n{&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;If you don&apos;t mind mutating &lt;code&gt;x&lt;/code&gt;,&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;x.update(y) &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; x\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Simple, readable, performant. You &lt;em&gt;know&lt;/em&gt; &lt;code&gt;update()&lt;/code&gt; always returns &lt;code&gt;None&lt;/code&gt;, which is a false value. So the above expression will always evaluate to &lt;code&gt;x&lt;/code&gt;, after updating it.&lt;/p&gt;\n&lt;p&gt;Most mutating methods in the standard library (like &lt;code&gt;.update()&lt;/code&gt;) return &lt;code&gt;None&lt;/code&gt; by convention, so this kind of pattern will work on those too. However, if you&apos;re using a dict subclass or some other method that doesn&apos;t follow this convention, then &lt;code&gt;or&lt;/code&gt; may return its left operand, which may not be what you want. Instead, you can use a tuple display and index, which works regardless of what the first element evaluates to (although it&apos;s not quite as pretty):&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;(x.update(y), x)[-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;If you don&apos;t have &lt;code&gt;x&lt;/code&gt; in a variable yet, you can use &lt;code&gt;lambda&lt;/code&gt; to make a local without using an assignment statement. This amounts to using &lt;code&gt;lambda&lt;/code&gt; as a &lt;em&gt;let expression&lt;/em&gt;, which is a common technique in functional languages, but is maybe unpythonic.&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt; x: x.update(y) &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; x)({&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Although it&apos;s not that different from the following use of the new walrus operator (Python 3.8+ only),&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;(x := {&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;}).update(y) &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; x\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;especially if you use a default argument:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt; x={&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;}: x.update(y) &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; x)()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;If you do want a copy, &lt;a href=&quot;https://www.python.org/dev/peps/pep-0584/&quot; rel=&quot;noreferrer&quot;&gt;PEP 584&lt;/a&gt; style &lt;code&gt;x | y&lt;/code&gt; is the most Pythonic on 3.9+. If you must support older versions, &lt;a href=&quot;https://www.python.org/dev/peps/pep-0448/&quot; rel=&quot;noreferrer&quot;&gt;PEP 448&lt;/a&gt; style &lt;code&gt;{**x, **y}&lt;/code&gt; is easiest for 3.5+. But if that&apos;s not available in your (even older) Python version, the &lt;em&gt;let expression&lt;/em&gt; pattern works here too.&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt; z=x.copy(): z.update(y) &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; z)()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;(That is, of course, nearly equivalent to &lt;code&gt;(z := x.copy()).update(y) or z&lt;/code&gt;, but if your Python version is new enough for that, then the PEP 448 style will be available.)&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.python.org/dev/peps/pep-0584/#specification&quot; rel=&quot;noreferrer&quot;&gt;New&lt;/a&gt; in Python 3.9:&lt;/strong&gt; Use the union operator (&lt;code&gt;|&lt;/code&gt;) to merge &lt;code&gt;dict&lt;/code&gt;s similar to &lt;code&gt;set&lt;/code&gt;s:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;d = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;}\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;e = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;}\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;d | e\n{&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;For matching keys, the &lt;strong&gt;right &lt;code&gt;dict&lt;/code&gt; takes precedence&lt;/strong&gt;.&lt;/p&gt;\n&lt;p&gt;This also works for &lt;code&gt;|=&lt;/code&gt; to modify a &lt;code&gt;dict&lt;/code&gt; in-place:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;e |= d    &lt;span class=&quot;hljs-comment&quot;&gt;# e = e | d&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;e\n{&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Drawing on ideas here and elsewhere I&apos;ve comprehended a function:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;merge&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;*dicts, **kv&lt;/span&gt;): \n      &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; { k:v &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; d &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt;(dicts) + [kv] &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; k,v &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; d.items() }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Usage (tested in python 3):&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;assert&lt;/span&gt; (merge({&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-string&quot;&gt;&apos;aaa&apos;&lt;/span&gt;},{&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;99&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-string&quot;&gt;&apos;bbb&apos;&lt;/span&gt;},foo=&lt;span class=&quot;hljs-string&quot;&gt;&apos;bar&apos;&lt;/span&gt;)==\\\n    {&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;99&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;foo&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;bar&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;bbb&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;aaa&apos;&lt;/span&gt;})\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;assert&lt;/span&gt; (merge(foo=&lt;span class=&quot;hljs-string&quot;&gt;&apos;bar&apos;&lt;/span&gt;)=={&lt;span class=&quot;hljs-string&quot;&gt;&apos;foo&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;bar&apos;&lt;/span&gt;})\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;assert&lt;/span&gt; (merge({&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;},{&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;99&lt;/span&gt;},foo=&lt;span class=&quot;hljs-string&quot;&gt;&apos;bar&apos;&lt;/span&gt;,baz=&lt;span class=&quot;hljs-string&quot;&gt;&apos;quux&apos;&lt;/span&gt;)==\\\n    {&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;99&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;foo&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;bar&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;baz&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-string&quot;&gt;&apos;quux&apos;&lt;/span&gt;})\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;assert&lt;/span&gt; (merge({&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;},{&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;99&lt;/span&gt;})=={&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;99&lt;/span&gt;})\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You could use a lambda instead.&lt;/p&gt;\n    ","\n&lt;p&gt;It&apos;s so silly that &lt;code&gt;.update&lt;/code&gt; returns nothing.&lt;br&gt;\nI just use a simple helper function to solve the problem:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;merge&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;dict1,*dicts&lt;/span&gt;):\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; dict2 &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; dicts:\n        dict1.update(dict2)\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; dict1\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Examples:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;merge(dict1,dict2)\nmerge(dict1,dict2,dict3)\nmerge(dict1,dict2,dict3,dict4)\nmerge({},dict1,dict2)  &lt;span class=&quot;hljs-comment&quot;&gt;# this one returns a new copy&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;(For Python2.7* only; there are simpler solutions for Python3*.)&lt;/p&gt;\n\n&lt;p&gt;If you&apos;re not averse to importing a standard library module, you can do&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; functools &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; reduce\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;merge_dicts&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;*dicts&lt;/span&gt;):\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; reduce(&lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt; a, d: a.update(d) &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; a, dicts, {})\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;(The &lt;code&gt;or a&lt;/code&gt; bit in the &lt;code&gt;lambda&lt;/code&gt; is necessary because &lt;code&gt;dict.update&lt;/code&gt; always returns &lt;code&gt;None&lt;/code&gt; on success.)&lt;/p&gt;\n    ","\n&lt;p&gt;The problem I have with solutions listed to date is that, in the merged dictionary, the value for key &quot;b&quot; is 10 but, to my way of thinking, it should be 12.\nIn that light, I present the following:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; timeit\n\nn=&lt;span class=&quot;hljs-number&quot;&gt;100000&lt;/span&gt;\nsu = &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;\nx = {&apos;a&apos;:1, &apos;b&apos;: 2}\ny = {&apos;b&apos;:10, &apos;c&apos;: 11}\n&quot;&quot;&quot;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;timeMerge&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;f,su,niter&lt;/span&gt;):\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;{:4f} sec for: {:30s}&quot;&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;format&lt;/span&gt;(timeit.Timer(f,setup=su).timeit(n),f)\n\ntimeMerge(&lt;span class=&quot;hljs-string&quot;&gt;&quot;dict(x, **y)&quot;&lt;/span&gt;,su,n)\ntimeMerge(&lt;span class=&quot;hljs-string&quot;&gt;&quot;x.update(y)&quot;&lt;/span&gt;,su,n)\ntimeMerge(&lt;span class=&quot;hljs-string&quot;&gt;&quot;dict(x.items() + y.items())&quot;&lt;/span&gt;,su,n)\ntimeMerge(&lt;span class=&quot;hljs-string&quot;&gt;&quot;for k in y.keys(): x[k] = k in x and x[k]+y[k] or y[k] &quot;&lt;/span&gt;,su,n)\n\n&lt;span class=&quot;hljs-comment&quot;&gt;#confirm for loop adds b entries together&lt;/span&gt;\nx = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;}\ny = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;}\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; k &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; y.keys(): x[k] = k &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; x &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; x[k]+y[k] &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; y[k]\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;confirm b elements are added:&quot;&lt;/span&gt;,x\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h1&gt;Results:&lt;/h1&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;0.049465&lt;/span&gt; sec &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;: &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(x, **y)\n&lt;span class=&quot;hljs-number&quot;&gt;0.033729&lt;/span&gt; sec &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;: x.update(y)                   \n&lt;span class=&quot;hljs-number&quot;&gt;0.150380&lt;/span&gt; sec &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;: &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(x.items() + y.items())   \n&lt;span class=&quot;hljs-number&quot;&gt;0.083120&lt;/span&gt; sec &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;: &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; k &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; y.keys(): x[k] = k &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; x &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; x[k]+y[k] &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; y[k]\n\nconfirm b elements are added: {&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;There will be a new option when Python 3.8 releases (&lt;a href=&quot;https://www.python.org/dev/peps/pep-0569/#release-schedule&quot; rel=&quot;noreferrer&quot;&gt;scheduled for 20 October, 2019&lt;/a&gt;), thanks to &lt;a href=&quot;https://www.python.org/dev/peps/pep-0572/&quot; rel=&quot;noreferrer&quot;&gt;PEP 572: Assignment Expressions&lt;/a&gt;. The new assignment expression operator &lt;code&gt;:=&lt;/code&gt; allows you to assign the result of the &lt;code&gt;copy&lt;/code&gt; and still use it to call &lt;code&gt;update&lt;/code&gt;, leaving the combined code a single expression, rather than two statements, changing:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;newdict = dict1.copy()\nnewdict.update(dict2)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;to:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;(newdict := dict1.copy()).update(dict2)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;while behaving identically in every way. If you must also return the resulting &lt;code&gt;dict&lt;/code&gt; (you asked for an expression returning the &lt;code&gt;dict&lt;/code&gt;; the above creates and assigns to &lt;code&gt;newdict&lt;/code&gt;, but doesn&apos;t return it, so you couldn&apos;t use it to pass an argument to a function as is, a la &lt;code&gt;myfunc((newdict := dict1.copy()).update(dict2))&lt;/code&gt;), then just add &lt;code&gt;or newdict&lt;/code&gt; to the end (since &lt;code&gt;update&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;, which is falsy, it will then evaluate and return &lt;code&gt;newdict&lt;/code&gt; as the result of the expression):&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;(newdict := dict1.copy()).update(dict2) &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; newdict\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;Important caveat:&lt;/strong&gt; In general, I&apos;d discourage this approach in favor of:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;newdict = {**dict1, **dict2}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The unpacking approach is clearer (to anyone who knows about generalized unpacking in the first place, &lt;a href=&quot;https://www.python.org/dev/peps/pep-0448/&quot; rel=&quot;noreferrer&quot;&gt;which you should&lt;/a&gt;), doesn&apos;t require a name for the result at all (so it&apos;s much more concise when constructing a temporary that is immediately passed to a function or included in a &lt;code&gt;list&lt;/code&gt;/&lt;code&gt;tuple&lt;/code&gt; literal or the like), and is almost certainly faster as well, being (on CPython) roughly equivalent to:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;newdict = {}\nnewdict.update(dict1)\nnewdict.update(dict2)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;but done at the C layer, using the concrete &lt;code&gt;dict&lt;/code&gt; API, so no dynamic method lookup/binding or function call dispatch overhead is involved (where &lt;code&gt;(newdict := dict1.copy()).update(dict2)&lt;/code&gt; is unavoidably identical to the original two-liner in behavior, performing the work in discrete steps, with dynamic lookup/binding/invocation of methods.&lt;/p&gt;\n\n&lt;p&gt;It&apos;s also more extensible, as merging three &lt;code&gt;dict&lt;/code&gt;s is obvious:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt; newdict = {**dict1, **dict2, **dict3}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;where using assignment expressions won&apos;t scale like that; the closest you could get would be:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt; (newdict := dict1.copy()).update(dict2), newdict.update(dict3)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or without the temporary tuple of &lt;code&gt;None&lt;/code&gt;s, but with truthiness testing of each &lt;code&gt;None&lt;/code&gt; result:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt; (newdict := dict1.copy()).update(dict2) &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; newdict.update(dict3)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;either of which is obviously much uglier, and includes further inefficiencies (either a wasted temporary &lt;code&gt;tuple&lt;/code&gt; of &lt;code&gt;None&lt;/code&gt;s for comma separation, or pointless truthiness testing of each &lt;code&gt;update&lt;/code&gt;&apos;s &lt;code&gt;None&lt;/code&gt; return for &lt;code&gt;or&lt;/code&gt; separation).&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;The only real advantage to the assignment expression approach occurs if:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;strong&gt;You have generic code that needs handle both &lt;code&gt;set&lt;/code&gt;s and &lt;code&gt;dict&lt;/code&gt;s&lt;/strong&gt; (both of them support &lt;code&gt;copy&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt;, so the code works roughly as you&apos;d expect it to)&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;You expect to receive arbitrary dict-like objects&lt;/strong&gt;, not just &lt;code&gt;dict&lt;/code&gt; itself, &lt;strong&gt;and must preserve the type and semantics of the left hand side&lt;/strong&gt; (rather than ending up with a plain &lt;code&gt;dict&lt;/code&gt;). While &lt;code&gt;myspecialdict({**speciala, **specialb})&lt;/code&gt; might work, it would involve an extra temporary &lt;code&gt;dict&lt;/code&gt;, and if &lt;code&gt;myspecialdict&lt;/code&gt; has features plain &lt;code&gt;dict&lt;/code&gt; can&apos;t preserve (e.g. regular &lt;code&gt;dict&lt;/code&gt;s now preserve order based on the first appearance of a key, and value based on the last appearance of a key; you might want one that preserves order based on the &lt;em&gt;last&lt;/em&gt; appearance of a key so updating a value also moves it to the end), then the semantics would be wrong. Since the assignment expression version uses the named methods (which are presumably overloaded to behave appropriately), it never creates a &lt;code&gt;dict&lt;/code&gt; at all (unless &lt;code&gt;dict1&lt;/code&gt; was already a &lt;code&gt;dict&lt;/code&gt;), preserving the original type (and original type&apos;s semantics), all while avoiding any temporaries.&lt;/li&gt;\n&lt;/ol&gt;\n    ","\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; collections &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; Counter\ndict1 = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;}\ndict2 = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;}\nresult = &lt;span class=&quot;hljs-built_in&quot;&gt;dict&lt;/span&gt;(Counter(dict1) + Counter(dict2))\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This should solve your problem.&lt;/p&gt;\n    ","\n&lt;p&gt;This can be done with a single dict comprehension:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;x = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;}\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;y = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;}\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;{ key: y[key] &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; key &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; y &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; x[key]\n      &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; key &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;set&lt;/span&gt;(x) + &lt;span class=&quot;hljs-built_in&quot;&gt;set&lt;/span&gt;(y)\n    }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In my view the best answer for the &apos;single expression&apos; part as no extra functions are needed, and it is short.&lt;/p&gt;\n    "],"312":["\n&lt;h2&gt;Introduction&lt;/h2&gt;\n&lt;p&gt;It represents the scope (the lifetime) of the bean. This is easier to understand if you are familiar with &quot;under the covers&quot; working of a basic servlet web application: &lt;a href=&quot;https://stackoverflow.com/questions/3106452/how-do-servlets-work-instantiation-session-variables-and-multithreading&quot;&gt;How do servlets work? Instantiation, sessions, shared variables and multithreading&lt;/a&gt;.&lt;/p&gt;\n&lt;hr&gt;\n&lt;h2&gt;&lt;code&gt;@Request/View/Flow/Session/ApplicationScoped&lt;/code&gt;&lt;/h2&gt;\n&lt;p&gt;A &lt;a href=&quot;https://docs.oracle.com/javaee/7/api/javax/enterprise/context/RequestScoped.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;@RequestScoped&lt;/code&gt;&lt;/a&gt; bean lives as long as a single HTTP request-response cycle (note that an Ajax request counts as a single HTTP request too). A &lt;a href=&quot;https://docs.oracle.com/javaee/7/api/javax/faces/view/ViewScoped.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;@ViewScoped&lt;/code&gt;&lt;/a&gt; bean lives as long as you&apos;re interacting with the same JSF view by postbacks which call action methods returning &lt;code&gt;null&lt;/code&gt;/&lt;code&gt;void&lt;/code&gt; without any navigation/redirect. A &lt;a href=&quot;http://docs.oracle.com/javaee/7/api/javax/faces/flow/FlowScoped.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;@FlowScoped&lt;/code&gt;&lt;/a&gt; bean lives as long as you&apos;re navigating through the specified collection of views registered in the flow configuration file. A &lt;a href=&quot;https://docs.oracle.com/javaee/7/api/javax/enterprise/context/SessionScoped.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;@SessionScoped&lt;/code&gt;&lt;/a&gt; bean lives as long as the established HTTP session. An &lt;a href=&quot;https://docs.oracle.com/javaee/7/api/javax/enterprise/context/ApplicationScoped.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;@ApplicationScoped&lt;/code&gt;&lt;/a&gt; bean lives as long as the web application runs. Note that the CDI &lt;code&gt;@Model&lt;/code&gt; is basically a &lt;a href=&quot;https://docs.oracle.com/javaee/7/api/javax/enterprise/inject/Model.html&quot; rel=&quot;noreferrer&quot;&gt;stereotype&lt;/a&gt; for &lt;code&gt;@Named @RequestScoped&lt;/code&gt;, so same rules apply.&lt;/p&gt;\n&lt;p&gt;Which scope to choose depends solely on the data (the state) the bean holds and represents. Use &lt;code&gt;@RequestScoped&lt;/code&gt; for simple and non-ajax forms/presentations. Use &lt;code&gt;@ViewScoped&lt;/code&gt; for rich ajax-enabled dynamic views (ajaxbased validation, rendering, dialogs, etc). Use &lt;code&gt;@FlowScoped&lt;/code&gt; for the &quot;wizard&quot; (&quot;questionnaire&quot;) pattern of collecting input data spread over multiple pages. Use &lt;code&gt;@SessionScoped&lt;/code&gt; for client specific data, such as the logged-in user and user preferences (language, etc). Use &lt;code&gt;@ApplicationScoped&lt;/code&gt; for application wide data/constants, such as dropdown lists which are the same for everyone, or managed beans without any instance variables and having only methods.&lt;/p&gt;\n&lt;p&gt;Abusing an &lt;code&gt;@ApplicationScoped&lt;/code&gt; bean for session/view/request scoped data would make it to be shared among all users, so anyone else can see each other&apos;s data which is just plain wrong. Abusing a &lt;code&gt;@SessionScoped&lt;/code&gt; bean for view/request scoped data would make it to be shared among all tabs/windows in a single browser session, so the enduser may experience inconsitenties when interacting with every view after switching between tabs which is bad for user experience. Abusing a &lt;code&gt;@RequestScoped&lt;/code&gt; bean for view scoped data would make view scoped data to be reinitialized to default on every single (ajax) postback, causing possibly non-working forms (&lt;a href=&quot;https://stackoverflow.com/a/2120183/157882&quot;&gt;see also points 4 and 5 here&lt;/a&gt;). Abusing a &lt;code&gt;@ViewScoped&lt;/code&gt; bean for request, session or application scoped data, and abusing a &lt;code&gt;@SessionScoped&lt;/code&gt; bean for application scoped data doesn&apos;t affect the client, but it unnecessarily occupies server memory and is plain inefficient.&lt;/p&gt;\n&lt;p&gt;Note that the scope should rather not be chosen based on performance implications, unless you &lt;em&gt;really&lt;/em&gt; have a low memory footprint and want to go completely stateless; you&apos;d need to use exclusively &lt;code&gt;@RequestScoped&lt;/code&gt; beans and fiddle with request parameters to maintain the client&apos;s state. Also note that when you have a single JSF page with differently scoped data, then it&apos;s perfectly valid to put them in separate backing beans in a scope matching the data&apos;s scope. The beans can just access each other via &lt;code&gt;@ManagedProperty&lt;/code&gt; in case of JSF managed beans or &lt;code&gt;@Inject&lt;/code&gt; in case of CDI managed beans.&lt;/p&gt;\n&lt;h3&gt;See also:&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/6025998/difference-between-view-and-request-scope-in-managed-beans/&quot;&gt;Difference between View and Request scope in managed beans&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/28240734/advantages-of-using-jsf-faces-flow-instead-of-the-normal-navigation-system/&quot;&gt;Advantages of using JSF Faces Flow instead of the normal navigation system&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://balusc.blogspot.com/2011/09/communication-in-jsf-20.html#ManagedBeanScopes&quot; rel=&quot;noreferrer&quot;&gt;Communication in JSF2 - Managed bean scopes&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;h2&gt;&lt;code&gt;@CustomScoped/NoneScoped/Dependent&lt;/code&gt;&lt;/h2&gt;\n&lt;p&gt;It&apos;s not mentioned in your question, but (legacy) JSF also supports &lt;a href=&quot;https://docs.oracle.com/javaee/7/api/javax/faces/bean/CustomScoped.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;@CustomScoped&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.oracle.com/javaee/7/api/javax/faces/bean/NoneScoped.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;@NoneScoped&lt;/code&gt;&lt;/a&gt;, which are rarely used in real world. The &lt;code&gt;@CustomScoped&lt;/code&gt; must refer a custom &lt;code&gt;Map&amp;lt;K, Bean&amp;gt;&lt;/code&gt; implementation in some broader scope which has overridden &lt;code&gt;Map#put()&lt;/code&gt; and/or &lt;code&gt;Map#get()&lt;/code&gt; in order to have more fine grained control over bean creation and/or destroy.&lt;/p&gt;\n&lt;p&gt;The JSF &lt;code&gt;@NoneScoped&lt;/code&gt; and CDI &lt;a href=&quot;http://docs.oracle.com/javaee/7/api/javax/enterprise/context/Dependent.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;@Dependent&lt;/code&gt;&lt;/a&gt; basically lives as long as a single EL-evaluation on the bean. Imagine a login form with two input fields referring a bean property and a command button referring a bean action, thus with in total three EL expressions, then effectively three instances will be created. One with the username set, one with the password set and one on which the action is invoked. You normally want to use this scope only on beans which should live as long as the bean where it&apos;s being injected. So if a &lt;code&gt;@NoneScoped&lt;/code&gt; or &lt;code&gt;@Dependent&lt;/code&gt; is injected in a &lt;code&gt;@SessionScoped&lt;/code&gt;, then it will live as long as the &lt;code&gt;@SessionScoped&lt;/code&gt; bean.&lt;/p&gt;\n&lt;h3&gt;See also:&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/30748724/expire-specific-managed-bean-instance-after-time-interval/&quot;&gt;Expire specific managed bean instance after time interval&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3086896/what-is-none-scope-bean-and-when-to-use-it/&quot;&gt;what is none scope bean and when to use it?&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/19322364/what-is-the-default-managed-bean-scope-in-a-jsf-2-application-in-netbeans/&quot;&gt;What is the default Managed Bean Scope in a JSF 2 application?&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;h2&gt;Flash scope&lt;/h2&gt;\n&lt;p&gt;As last, JSF also supports the flash scope. It is backed by a short living cookie which is associated with a data entry in the session scope. Before the redirect, a cookie will be set on the HTTP response with a value which is uniquely associated with the data entry in the session scope. After the redirect, the presence of the flash scope cookie will be checked and the data entry associated with the cookie will be removed from the session scope and be put in the request scope of the redirected request. Finally the cookie will be removed from the HTTP response. This way the redirected request has access to request scoped data which was been prepared in the initial request.&lt;/p&gt;\n&lt;p&gt;This is actually not available as a managed bean scope, i.e. there&apos;s no such thing as &lt;code&gt;@FlashScoped&lt;/code&gt;. The flash scope is only available as a map via &lt;a href=&quot;http://docs.oracle.com/javaee/7/api/javax/faces/context/ExternalContext.html#getFlash--&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;ExternalContext#getFlash()&lt;/code&gt;&lt;/a&gt; in managed beans and &lt;code&gt;#{flash}&lt;/code&gt; in EL.&lt;/p&gt;\n&lt;h3&gt;See also:&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/13685633/how-to-show-faces-message-in-the-redirected-page/&quot;&gt;How to show faces message in the redirected page&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/25694423/pass-an-object-between-viewscoped-beans-without-using-get-params&quot;&gt;Pass an object between @ViewScoped beans without using GET params&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/7812985/cdi-missing-viewscoped-and-flashscoped/&quot;&gt;CDI missing @ViewScoped and @FlashScoped&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;Since JSF 2.3 all the bean scopes defined in package &lt;code&gt;javax.faces.bean&lt;/code&gt; package have been deprecated to align the scopes with CDI. Moreover they&apos;re only applicable if your bean is using &lt;code&gt;@ManagedBean&lt;/code&gt; annotation. If you are using JSF versions below 2.3 refer to the legacy answer at the end.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;From JSF 2.3 here are scopes that can be used on JSF Backing Beans:&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;1. &lt;code&gt;@javax.enterprise.context.ApplicationScoped&lt;/code&gt;&lt;/strong&gt;: The application scope persists for the entire duration of the web application. That scope is shared among all requests and all sessions. This is useful when you have data for whole application.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;2. &lt;code&gt;@javax.enterprise.context.SessionScoped&lt;/code&gt;&lt;/strong&gt;: The session scope persists from the time that a session is established until session termination. The session context is shared between all requests that occur in the same HTTP session. This is useful when you wont to save data for a specific client for a particular session.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;3. &lt;code&gt;@javax.enterprise.context.ConversationScoped&lt;/code&gt;&lt;/strong&gt;: The conversation scope persists as log as the bean lives. The scope provides 2 methods: &lt;code&gt;Conversation.begin()&lt;/code&gt; and &lt;code&gt;Conversation.end()&lt;/code&gt;. These methods should called explicitly, either to start or end the life of a bean.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;4. &lt;code&gt;@javax.enterprise.context.RequestScoped&lt;/code&gt;&lt;/strong&gt;: The request scope is short-lived. It starts when an HTTP request is submitted and ends after the response is sent back to the client. If you place a managed bean into request scope, a new instance is created with each request. It is worth considering request scope if you are concerned about the cost of session scope storage.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;5. &lt;code&gt;@javax.faces.flow.FlowScoped&lt;/code&gt;&lt;/strong&gt;: The Flow scope persists as long as the Flow lives. A flow may be defined as a contained set of pages (or views) that define a unit of work. Flow scoped been is active as long as user navigates with in the Flow. &lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;6. &lt;code&gt;@javax.faces.view.ViewScoped&lt;/code&gt;&lt;/strong&gt;: A bean in view scope persists while the same JSF page is redisplayed. As soon as the user navigates to a different page, the bean goes out of scope.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;The following legacy answer applies JSF version before 2.3&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;As of JSF 2.x there are 4 Bean Scopes:    &lt;/p&gt;\n  \n  &lt;ul&gt;\n  &lt;li&gt;@SessionScoped &lt;/li&gt;\n  &lt;li&gt;@RequestScoped&lt;/li&gt;\n  &lt;li&gt;@ApplicationScoped&lt;/li&gt;\n  &lt;li&gt;@ViewScoped   &lt;/li&gt;\n  &lt;/ul&gt;\n  \n  &lt;p&gt;&lt;strong&gt;Session Scope:&lt;/strong&gt;    The session scope persists from the time that a session is established until session termination. A session terminates\n  if the web application invokes the invalidate method on the\n  HttpSession object, or if it times out.&lt;/p&gt;\n  \n  &lt;p&gt;&lt;strong&gt;RequestScope:&lt;/strong&gt;   The request scope is short-lived. It starts when an HTTP request is submitted and ends after the response is sent back\n  to the client. If you place a managed bean into request scope, a new\n  instance is created with each request. It is worth considering request\n  scope if you are concerned about the cost of session scope storage.&lt;/p&gt;\n  \n  &lt;p&gt;&lt;strong&gt;ApplicationScope:&lt;/strong&gt;    The application scope persists for the entire duration of the web application. That scope is shared among all\n  requests and all sessions. You place managed beans into the\n  application scope if a single bean should be shared among all\n  instances of a web application. The bean is constructed when it is\n  first requested by any user of the application, and it stays alive\n  until the web application is removed from the application server.&lt;/p&gt;\n  \n  &lt;p&gt;&lt;strong&gt;ViewScope:&lt;/strong&gt;      View scope was added in JSF 2.0. A bean in view scope persists while the same JSF page is redisplayed. (The JSF\n  specification uses the term view for a JSF page.) As soon as the user\n  navigates to a different page, the bean goes out of scope.&lt;/p&gt;\n  \n  &lt;p&gt;Choose the scope you based on your requirement.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;&lt;strong&gt;Source:&lt;/strong&gt; &lt;a href=&quot;http://horstmann.com/corejsf/&quot; rel=&quot;noreferrer&quot;&gt;Core Java Server Faces 3rd Edition&lt;/a&gt; by David Geary &amp;amp; Cay Horstmann [Page no. 51 - 54]\n&lt;img src=&quot;https://i.stack.imgur.com/ZXZCU.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/p&gt;\n    "],"313":["\n&lt;p&gt;Use the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#equals-java.lang.Object-&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;string.equals(Object other)&lt;/code&gt;&lt;/a&gt; function to compare strings, not the &lt;code&gt;==&lt;/code&gt; operator.&lt;/p&gt;\n\n&lt;p&gt;The function checks the actual contents of the string, the &lt;code&gt;==&lt;/code&gt; operator checks whether the references to the objects are equal.  Note that string constants are usually &quot;interned&quot; such that two constants with the same value can actually be compared with &lt;code&gt;==&lt;/code&gt;, but it&apos;s better not to rely on that.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (usuario.equals(datos[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;])) {\n    ...\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;NB: the compare is done on &apos;usuario&apos; because that&apos;s guaranteed non-null in your code, although you should still check that you&apos;ve actually got some tokens in the &lt;code&gt;datos&lt;/code&gt; array otherwise you&apos;ll get an array-out-of-bounds exception.&lt;/p&gt;\n    ","\n&lt;h2&gt;Meet Jorman&lt;/h2&gt;\n\n&lt;p&gt;Jorman is a successful businessman and has 2 houses. &lt;/p&gt;\n\n&lt;p&gt;&lt;img src=&quot;https://i.stack.imgur.com/xLcfG.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/p&gt;\n\n&lt;p&gt;But others don&apos;t know that.&lt;/p&gt;\n\n&lt;h2&gt;Is it the same Jorman?&lt;/h2&gt;\n\n&lt;p&gt;When you ask neighbours from either Madison or Burke streets, this is the only thing they can say:&lt;/p&gt;\n\n&lt;p&gt;&lt;img src=&quot;https://i.stack.imgur.com/ZjMlG.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/p&gt;\n\n&lt;p&gt;Using the residence alone, it&apos;s tough to confirm that it&apos;s the same Jorman. Since they&apos;re 2 different addresses, it&apos;s just natural to assume that those are 2 different persons.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;That&apos;s how the operator &lt;code&gt;==&lt;/code&gt; behaves.&lt;/strong&gt; So it will say that &lt;code&gt;datos[0]==usuario&lt;/code&gt; is false, because it only &lt;em&gt;compares the addresses&lt;/em&gt;.&lt;/p&gt;\n\n&lt;h2&gt;An Investigator to the Rescue&lt;/h2&gt;\n\n&lt;p&gt;What if we sent an investigator? We know that it&apos;s the same Jorman, but we need to prove it. Our detective will look closely at all physical aspects. With thorough inquiry, the agent will be able to conclude whether it&apos;s the same person or not. Let&apos;s see it happen in Java terms.&lt;/p&gt;\n\n&lt;p&gt;Here&apos;s the source code of String&apos;s &lt;code&gt;equals()&lt;/code&gt; method:&lt;/p&gt;\n\n&lt;p&gt;&lt;img src=&quot;https://i.stack.imgur.com/6MYZy.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/p&gt;\n\n&lt;p&gt;It compares the Strings character by character, in order to come to a conclusion that they are indeed equal.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;That&apos;s how the String &lt;code&gt;equals&lt;/code&gt; method behaves.&lt;/strong&gt; So &lt;code&gt;datos[0].equals(usuario)&lt;/code&gt; will return true, because it performs a &lt;em&gt;logical comparison&lt;/em&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;It&apos;s good to notice that &lt;strong&gt;in some cases use of &quot;==&quot; operator can lead to the expected result, because the way how java handles strings&lt;/strong&gt; - string literals are interned  (see &lt;code&gt;String.intern()&lt;/code&gt;) during compilation - so when you write for example &lt;code&gt;&quot;hello world&quot;&lt;/code&gt; in two classes and compare those strings with &quot;==&quot; you could get result: true, which is expected according to &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.10.5&quot; rel=&quot;noreferrer&quot;&gt;specification&lt;/a&gt;; when you compare same strings (if they have same value) when the first one is string literal (ie. defined through &lt;code&gt;&quot;i am string literal&quot;&lt;/code&gt;) and second is constructed during runtime ie. with &quot;new&quot; keyword like &lt;code&gt;new String(&quot;i am string literal&quot;)&lt;/code&gt;, the &lt;code&gt;==&lt;/code&gt; (equality) operator returns false, because both of them are different instances of the &lt;code&gt;String&lt;/code&gt; class. &lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Only right way is using &lt;code&gt;.equals()&lt;/code&gt; -&amp;gt; &lt;code&gt;datos[0].equals(usuario)&lt;/code&gt;.&lt;/strong&gt; &lt;code&gt;==&lt;/code&gt; says only if two objects are the same instance of object (ie. have same memory address)&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;: 01.04.2013 I updated this post due comments below which are somehow right. Originally I declared that interning (String.intern) is side effect of JVM optimization. Although it certainly save memory resources (which was what i meant by &quot;optimization&quot;) it is mainly feature of language&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;code&gt;equals()&lt;/code&gt; function is a method of &lt;code&gt;Object&lt;/code&gt; class which should be overridden by programmer. &lt;code&gt;String&lt;/code&gt; class overrides it to check if two strings are equal i.e. in content and not reference. &lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;==&lt;/code&gt; operator checks if the references of both the objects are the same. &lt;/p&gt;\n\n&lt;p&gt;Consider the programs&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;abc&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Awesome&quot;&lt;/span&gt; ;\n&lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;xyz&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt;  abc;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(abc == xyz)\n     System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Refers to same string&quot;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here the &lt;code&gt;abc&lt;/code&gt; and &lt;code&gt;xyz&lt;/code&gt;, both refer to same &lt;code&gt;String&lt;/code&gt; &lt;code&gt;&quot;Awesome&quot;&lt;/code&gt;. Hence the expression &lt;code&gt;(abc == xyz)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;abc&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;xyz&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(abc == xyz)\n    System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Refers to same string&quot;&lt;/span&gt;);\n&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;\n    System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Refers to different strings&quot;&lt;/span&gt;);\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(abc.equals(xyz))\n     System.out.prinln(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Contents of both strings are same&quot;&lt;/span&gt;);\n&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;\n     System.out.prinln(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Contents of strings are different&quot;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here &lt;code&gt;abc&lt;/code&gt; and &lt;code&gt;xyz&lt;/code&gt; are two different strings with the same content &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt;. Hence here the expression &lt;code&gt;(abc == xyz)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; where as &lt;code&gt;(abc.equals(xyz))&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;Hope you understood the difference between &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;&amp;lt;Object&amp;gt;.equals()&lt;/code&gt; &lt;/p&gt;\n\n&lt;p&gt;Thanks.&lt;/p&gt;\n    ","\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;The == operator checks &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; the two references point to the same object or not.\n.equals() checks &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; the actual string &lt;span class=&quot;hljs-title function_&quot;&gt;content&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(value)&lt;/span&gt;.\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Note that the .equals() method belongs to class Object (super class of all classes). You need to override it as per you class requirement, but for String it is already implemented and it checks whether two strings have the same value or not.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;Case1)\n&lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;s1&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Stack Overflow&quot;&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;s2&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Stack Overflow&quot;&lt;/span&gt;;\ns1 == s1;      &lt;span class=&quot;hljs-comment&quot;&gt;// true&lt;/span&gt;\ns1.equals(s2); &lt;span class=&quot;hljs-comment&quot;&gt;// true&lt;/span&gt;\nReason: String literals created without &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt; are stored in the string pool in the permgen area of the heap. So both s1 and s2 point to the same object in the pool.\nCase2)\n&lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;s1&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Stack Overflow&quot;&lt;/span&gt;);\n&lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;s2&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Stack Overflow&quot;&lt;/span&gt;);\ns1 == s2;      &lt;span class=&quot;hljs-comment&quot;&gt;// false&lt;/span&gt;\ns1.equals(s2); &lt;span class=&quot;hljs-comment&quot;&gt;// true&lt;/span&gt;\nReason: If you create a String object using the `&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt;` keyword a separate space is allocated to it on the heap.\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Instead of&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;datos[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] == usuario\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;use &lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;datos[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;].equals(usuario)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;==&lt;/code&gt; compares the reference of the variable where &lt;code&gt;.equals()&lt;/code&gt; compares the values which is what you want.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;code&gt;==&lt;/code&gt; tests for reference equality.&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;.equals()&lt;/code&gt; tests for value equality.&lt;/p&gt;\n\n&lt;p&gt;Consequently, if you actually want to test whether two strings have the same value you should use &lt;code&gt;.equals()&lt;/code&gt; (except in a few situations where you can guarantee that two strings with the same value will be represented by the same object eg: &lt;code&gt;String&lt;/code&gt; interning).&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;==&lt;/code&gt; is for testing whether two strings are the same &lt;code&gt;Object&lt;/code&gt;.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// These two have the same value&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt;).equals(&lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt;) ==&amp;gt; &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt; \n\n&lt;span class=&quot;hljs-comment&quot;&gt;// ... but they are not the same object&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt;) == &lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt; ==&amp;gt; &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt; \n\n&lt;span class=&quot;hljs-comment&quot;&gt;// ... neither are these&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt;) == &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt;) ==&amp;gt; &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt; \n\n&lt;span class=&quot;hljs-comment&quot;&gt;// ... but these are because literals are interned by &lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// the compiler and thus refer to the same object&lt;/span&gt;\n&lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt; == &lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt; ==&amp;gt; &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt; \n\n&lt;span class=&quot;hljs-comment&quot;&gt;// concatenation of string literals happens at compile time resulting in same objects&lt;/span&gt;\n&lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt; == &lt;span class=&quot;hljs-string&quot;&gt;&quot;te&quot;&lt;/span&gt; + &lt;span class=&quot;hljs-string&quot;&gt;&quot;st&quot;&lt;/span&gt;  ==&amp;gt; &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// but .substring() is invoked at runtime, generating distinct objects&lt;/span&gt;\n&lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt; == &lt;span class=&quot;hljs-string&quot;&gt;&quot;!test&quot;&lt;/span&gt;.substring(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) ==&amp;gt; &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It is important to note that &lt;code&gt;==&lt;/code&gt; is much cheaper than &lt;code&gt;equals()&lt;/code&gt; (a single pointer comparision instead of a loop), thus, in situations where it is applicable (i.e. you can guarantee that you are only dealing with interned strings) it can present an important performance improvement. However, these situations are rare.&lt;/p&gt;\n    ","\n&lt;p&gt;Let&apos;s analyze the following Java, to understand the identity and equality of Strings:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;testEquality&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;str1&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello world.&quot;&lt;/span&gt;;\n    &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;str2&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello world.&quot;&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (str1 == str2)\n        System.out.print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;str1 == str2\\n&quot;&lt;/span&gt;);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;\n        System.out.print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;str1 != str2\\n&quot;&lt;/span&gt;);\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(str1.equals(str2))\n        System.out.print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;str1 equals to str2\\n&quot;&lt;/span&gt;);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;\n        System.out.print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;str1 doesn&apos;t equal to str2\\n&quot;&lt;/span&gt;);\n\n    &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;str3&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello world.&quot;&lt;/span&gt;);\n    &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;str4&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello world.&quot;&lt;/span&gt;);\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (str3 == str4)\n        System.out.print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;str3 == str4\\n&quot;&lt;/span&gt;);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;\n        System.out.print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;str3 != str4\\n&quot;&lt;/span&gt;);\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(str3.equals(str4))\n        System.out.print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;str3 equals to str4\\n&quot;&lt;/span&gt;);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;\n        System.out.print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;str3 doesn&apos;t equal to str4\\n&quot;&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;When the first line of code &lt;code&gt;String str1 = &quot;Hello world.&quot;&lt;/code&gt; executes, a string &lt;code&gt;\\Hello world.&quot;&lt;/code&gt;\nis created, and the variable &lt;code&gt;str1&lt;/code&gt; refers to it. Another string &lt;code&gt;&quot;Hello world.&quot;&lt;/code&gt; will not be created again when the next line of code executes because of optimization. The variable &lt;code&gt;str2&lt;/code&gt; also refers to the existing &lt;code&gt;&quot;&quot;Hello world.&quot;&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;The operator &lt;code&gt;==&lt;/code&gt; checks identity of two objects (whether two variables refer to same object). Since &lt;code&gt;str1&lt;/code&gt; and &lt;code&gt;str2&lt;/code&gt; refer to same string in memory, they are identical to each other. The method &lt;code&gt;equals&lt;/code&gt; checks equality of two objects (whether two objects have same content). Of course, the content of &lt;code&gt;str1&lt;/code&gt; and &lt;code&gt;str2&lt;/code&gt; are same.&lt;/p&gt;\n\n&lt;p&gt;When code &lt;code&gt;String str3 = new String(&quot;Hello world.&quot;)&lt;/code&gt; executes, a new instance of string with content &lt;code&gt;&quot;Hello world.&quot;&lt;/code&gt; is created, and it is referred to by the variable &lt;code&gt;str3&lt;/code&gt;. And then another instance of string with content &lt;code&gt;&quot;Hello world.&quot;&lt;/code&gt; is created again, and referred to by\n&lt;code&gt;str4&lt;/code&gt;. Since &lt;code&gt;str3&lt;/code&gt; and &lt;code&gt;str4&lt;/code&gt; refer to two different instances, they are not identical, but their\ncontent are same.&lt;/p&gt;\n\n&lt;p&gt;Therefore, the output contains four lines:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;Str1 == str2\n\nStr1 equals str2\n\nStr3! = str4\n\nStr3 equals str4\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;You should use &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#equals(java.lang.Object)&quot; rel=&quot;noreferrer&quot;&gt;string equals&lt;/a&gt; to compare two strings for equality, not operator == which just compares the references.&lt;/p&gt;\n    ","\n&lt;p&gt;It will also work if you call &lt;code&gt;intern()&lt;/code&gt; on the string before inserting it into the array.\nInterned strings are reference-equal (&lt;code&gt;==&lt;/code&gt;) if and only if they are value-equal (&lt;code&gt;equals()&lt;/code&gt;.)&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(String... aArguments)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; IOException {\n\n&lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;usuario&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Jorman&quot;&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;password&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;14988611&quot;&lt;/span&gt;;\n\nString strDatos=&lt;span class=&quot;hljs-string&quot;&gt;&quot;Jorman 14988611&quot;&lt;/span&gt;;\nStringTokenizer tokens=&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;StringTokenizer&lt;/span&gt;(strDatos, &lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt;);\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; nDatos=tokens.countTokens();\nString[] datos=&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;[nDatos];\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(tokens.hasMoreTokens()) {\n    String str=tokens.nextToken();\n    datos[i]= str.intern();            \n    i++;\n}\n\n&lt;span class=&quot;hljs-comment&quot;&gt;//System.out.println (usuario);&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(datos[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]==usuario) {  \n     System.out.println (&lt;span class=&quot;hljs-string&quot;&gt;&quot;WORKING&quot;&lt;/span&gt;);    \n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Generally &lt;code&gt;.equals&lt;/code&gt; is used for &lt;code&gt;Object&lt;/code&gt; comparison, where you want to verify if two &lt;code&gt;Objects&lt;/code&gt; have an identical value.&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;==&lt;/code&gt; for reference comparison (are the two &lt;code&gt;Objects&lt;/code&gt; the same &lt;code&gt;Object&lt;/code&gt; on the heap) &amp;amp; to check if the &lt;code&gt;Object&lt;/code&gt; is null. It is also used to compare the values of primitive types.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;code&gt;==&lt;/code&gt; operator compares the reference of an object in Java. You can use string&apos;s &lt;code&gt;equals&lt;/code&gt; method .&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Test&quot;&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(s.equals(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Test&quot;&lt;/span&gt;))\n{\n    System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Equal&quot;&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;If you are going to compare any assigned value of the string i.e. primitive string, both &quot;==&quot; and .equals will work, but for the new string object you should use only .equals, and here &quot;==&quot; will not work.&lt;/p&gt;\n\n&lt;p&gt;Example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;if(a == b)&lt;/code&gt;  and &lt;code&gt;(a.equals(b))&lt;/code&gt; will return true.&lt;/p&gt;\n\n&lt;p&gt;But&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;a&quot;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In this case &lt;code&gt;if(a == b)&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;So it&apos;s better to use the &lt;code&gt;.equals&lt;/code&gt; operator...&lt;/p&gt;\n    ","\n&lt;p&gt;The == operator is a simple comparison of values.&lt;br&gt;\nFor object references the (values) are the (references). So x == y returns true if x and y reference the same object.&lt;/p&gt;\n    ","\n&lt;p&gt;I know this is an old question but here&apos;s how I look at it (I find very useful):&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;Technical explanations&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;In Java, all variables are either &lt;strong&gt;primitive types&lt;/strong&gt; or &lt;strong&gt;references&lt;/strong&gt;.&lt;/p&gt;\n\n&lt;p&gt;(If you need to know what a reference is: &quot;Object variables&quot; are just &lt;em&gt;pointers to objects.&lt;/em&gt; So with &lt;code&gt;Object something = ...&lt;/code&gt;, something is really an address in memory (a number).)&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;==&lt;/code&gt; compares the exact values. So it compares if the primitive values are the same, or if the references (addresses) are the same. That&apos;s why &lt;code&gt;==&lt;/code&gt; often doesn&apos;t work on Strings; Strings are objects, and doing &lt;code&gt;==&lt;/code&gt; on two string variables just compares if the address is same in memory, as others have pointed out. &lt;code&gt;.equals()&lt;/code&gt; calls the comparison method of objects, which will compare the actual objects pointed by the references. In the case of Strings, it compares each character to see if they&apos;re equal.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;The interesting part&lt;/strong&gt;:&lt;/p&gt;\n\n&lt;p&gt;So why does &lt;code&gt;==&lt;/code&gt; sometimes return true for Strings? Note that Strings are immutable. In your code, if you do&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;hi&quot;&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;hi&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Since strings are immutable (when you call &lt;code&gt;.trim()&lt;/code&gt; or something, it produces a new string, not modifying the original object pointed to in memory), you don&apos;t really need two different &lt;code&gt;String(&quot;hi&quot;)&lt;/code&gt; objects. If the compiler is smart, the bytecode will read to only generate one &lt;code&gt;String(&quot;hi&quot;)&lt;/code&gt; object. So if you do &lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (foo == bar) ...\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;right after, they&apos;re pointing to the same object, and will return true. But you rarely intend this. Instead, you&apos;re asking for user input, which is creating new strings at different parts of memory, etc. etc.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: If you do something like &lt;code&gt;baz = new String(bar)&lt;/code&gt; the compiler may still figure out they&apos;re the same thing. But the main point is when the compiler sees literal strings, it can easily optimize same strings.&lt;/p&gt;\n\n&lt;p&gt;I don&apos;t know how it works in runtime, but I assume the JVM doesn&apos;t keep a list of &quot;live strings&quot; and check if a same string exists. (eg if you read a line of input twice, and the user enters the same input twice, it won&apos;t check if the second input string is the same as the first, and point them to the same memory). It&apos;d save a bit of heap memory, but it&apos;s so negligible the overhead isn&apos;t worth it. Again, the point is it&apos;s easy for the compiler to optimize literal strings.&lt;/p&gt;\n\n&lt;p&gt;There you have it... a gritty explanation for &lt;code&gt;==&lt;/code&gt; vs. &lt;code&gt;.equals()&lt;/code&gt; and why it seems random.&lt;/p&gt;\n    ","\n&lt;p&gt;@Melkhiah66 You can use equals method instead of &apos;==&apos; method to check the equality.\nIf you use intern() then it checks whether the object is in pool if present then returns\nequal else unequal. equals method internally uses hashcode and gets you the required result.\n&lt;code&gt;&lt;/code&gt;&lt;/p&gt;&lt;code&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Demo&lt;/span&gt;\n{\n  &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt;\n  {\n              &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;str1&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Jorman 14988611&quot;&lt;/span&gt;;\n    &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;str2&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;StringBuffer&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Jorman&quot;&lt;/span&gt;).append(&lt;span class=&quot;hljs-string&quot;&gt;&quot; 14988611&quot;&lt;/span&gt;).toString();\n    &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;str3&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; str2.intern();\n    System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;str1 == str2 &quot;&lt;/span&gt; + (str1 == str2));           &lt;span class=&quot;hljs-comment&quot;&gt;//gives false&lt;/span&gt;\n    System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;str1 == str3 &quot;&lt;/span&gt; + (str1 == str3));           &lt;span class=&quot;hljs-comment&quot;&gt;//gives true&lt;/span&gt;\n    System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;str1 equals str2 &quot;&lt;/span&gt; + (str1.equals(str2)));  &lt;span class=&quot;hljs-comment&quot;&gt;//gives true&lt;/span&gt;\n    System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;str1 equals str3 &quot;&lt;/span&gt; + (str1.equals(str3)));  &lt;span class=&quot;hljs-comment&quot;&gt;//gives true&lt;/span&gt;\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;/code&gt;&lt;p&gt;&lt;code&gt;&lt;/code&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;The &lt;code&gt;.equals()&lt;/code&gt; will check if the two strings have the same value and return the &lt;code&gt;boolean&lt;/code&gt; value where as the &lt;code&gt;==&lt;/code&gt; operator checks to see if the two strings are the same object.&lt;/p&gt;\n    ","\n&lt;p&gt;Someone said on a post higher up that  == is used for int and for checking nulls.\nIt may also be used to check for Boolean operations and char types.&lt;/p&gt;\n\n&lt;p&gt;Be very careful though and double check that you are using a char and not a String.\nfor example &lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;    &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;strType&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;a&quot;&lt;/span&gt;;\n    &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;charType&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;for strings you would then check\nThis would be correct&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(strType.equals(&lt;span class=&quot;hljs-string&quot;&gt;&quot;a&quot;&lt;/span&gt;)\n        &lt;span class=&quot;hljs-keyword&quot;&gt;do&lt;/span&gt; something\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;but &lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(charType.equals(&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;)\n        &lt;span class=&quot;hljs-keyword&quot;&gt;do&lt;/span&gt; something &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;would be incorrect, you would need to do the following&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(charType == &lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;)\n         &lt;span class=&quot;hljs-keyword&quot;&gt;do&lt;/span&gt; something &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;&lt;code&gt;a==b&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;Compares references, not values. The use of &lt;code&gt;==&lt;/code&gt; with object references is generally limited to the following:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;Comparing to see if a reference is &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Comparing two enum values. This works because there is only one object for each &lt;code&gt;enum&lt;/code&gt; constant.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;You want to know if two references are to the same object&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;&lt;code&gt;&quot;a&quot;.equals(&quot;b&quot;)&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;Compares values for equality. Because this method is defined in the &lt;code&gt;Object&lt;/code&gt; class, from which all other classes are derived, it&apos;s automatically defined for every class. However, it doesn&apos;t perform an intelligent comparison for most classes unless the class overrides it. It has been defined in a meaningful way for most Java core classes. If it&apos;s not defined for a (user) class, it behaves the same as &lt;code&gt;==&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;Use Split rather than tokenizer,it will surely provide u exact output\nfor E.g:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;string name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;Harry&quot;&lt;/span&gt;;\nstring salary=&lt;span class=&quot;hljs-string&quot;&gt;&quot;25000&quot;&lt;/span&gt;;\nstring namsal=&lt;span class=&quot;hljs-string&quot;&gt;&quot;Harry 25000&quot;&lt;/span&gt;;\nstring[] s=namsal.split(&lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt;);\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;i&amp;lt;s.length;i++)\n{\nSystem.out.println(s[i]);\n}\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(s[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;].equals(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Harry&quot;&lt;/span&gt;))\n{\nSystem.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Task Complete&quot;&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;After this I am sure you will get better results.....&lt;/p&gt;\n    "],"314":["\n&lt;p&gt;Simple: this is undefined behavior, since &lt;code&gt;fflush&lt;/code&gt; is meant to be called on an output stream. This is an excerpt from the C standard:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;int fflush(FILE *ostream);&lt;/p&gt;\n&lt;p&gt;ostream points to an output stream or\nan update stream in which the most\nrecent operation was not input, the\nfflush function causes any unwritten\ndata for that stream to be delivered\nto the host environment to be written\nto the file; otherwise, the behavior\nis undefined.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;So it&apos;s not a question of &quot;how bad&quot; this is. &lt;code&gt;fflush(stdin)&lt;/code&gt; is simply not portable, so you should not use it if you want your code to be portable between compilers.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;sup&gt;&lt;em&gt;Converting comments into an answer.&lt;/em&gt;&lt;/sup&gt;&lt;/p&gt;\n&lt;h1&gt;TL;DR  &lt;em&gt;&lt;strong&gt;Portable code doesn&apos;t use &lt;code&gt;fflush(stdin)&lt;/code&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/h1&gt;\n&lt;p&gt;The rest of this answer explains why portable code does not use &lt;code&gt;fflush(stdin)&lt;/code&gt;.  It is tempting to add &quot;reliable code doesn&apos;t use &lt;code&gt;fflush(stdin)&lt;/code&gt;&quot;, which is also generally true.&lt;/p&gt;\n&lt;h2&gt;Standard C and POSIX leave &lt;code&gt;fflush(stdin)&lt;/code&gt; as undefined behaviour&lt;/h2&gt;\n&lt;p&gt;The &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fflush.html&quot; rel=&quot;noreferrer&quot;&gt;POSIX&lt;/a&gt;, C and C++ standards for &lt;code&gt;fflush()&lt;/code&gt; explicitly state that the behaviour is undefined (because &lt;code&gt;stdin&lt;/code&gt; is an input stream), but none of them prevent a system from defining it.&lt;/p&gt;\n&lt;p&gt;ISO/IEC 9899:2011 &amp;nbsp;the C11 Standard  says:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;h3&gt;&lt;a href=&quot;http://port70.net/%7Ensz/c/c11/n1570.html#7.21.5.2&quot; rel=&quot;noreferrer&quot;&gt;§7.21.5.2 The fflush function&lt;/a&gt;&lt;/h3&gt;\n&lt;p&gt;¶2 If &lt;code&gt;stream&lt;/code&gt; points to an output stream or an update stream in which the most recent operation was not input, the &lt;code&gt;fflush&lt;/code&gt; function causes any unwritten data for that stream to be delivered to the host environment to be written to the file; otherwise, the behavior is undefined.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;POSIX mostly defers to the C standard but it does mark this text as a C extension.&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;[CX]  For a stream open for reading, if the file is not already at EOF, and the file is one capable of seeking, the file offset of the underlying open file description shall be set to the file position of the stream, and any characters pushed back onto the stream by &lt;code&gt;ungetc()&lt;/code&gt; or &lt;code&gt;ungetwc()&lt;/code&gt; that have not subsequently been read from the stream shall be discarded (without further changing the file offset). &lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Note that terminals are not capable of seeking; neither are pipes or sockets.&lt;/p&gt;\n&lt;h2&gt;Microsoft defines the behaviour of &lt;code&gt;fflush(stdin)&lt;/code&gt;&lt;/h2&gt;\n&lt;p&gt;In 2015, &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/9yky46tz.aspx&quot; rel=&quot;noreferrer&quot;&gt;Microsoft&lt;/a&gt; and the Visual Studio runtime used to define the behaviour of &lt;code&gt;fflush()&lt;/code&gt; on an input stream like this (but the link leads to different text in 2021):&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;If the stream is open for input, &lt;code&gt;fflush&lt;/code&gt; clears the contents of the buffer.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/users/1505939/m-m&quot;&gt;M.M&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/questions/2979209/using-fflushstdin#comment40866432_2979209&quot;&gt;notes&lt;/a&gt;:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Cygwin is an example of a fairly common platform on which &lt;code&gt;fflush(stdin)&lt;/code&gt; does not clear the input.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;This is why this answer version of my &lt;a href=&quot;https://stackoverflow.com/questions/2979209/using-fflushstdin#comment31066899_2979209&quot;&gt;comment&lt;/a&gt; notes &apos;Microsoft and the Visual Studio runtime&apos;  if you use a non-Microsoft C runtime library, the behaviour you see depends on that library.&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/users/4142924/weather-vane&quot;&gt;Weather Vane&lt;/a&gt; pointed out to me in a comment to another question that, at some time before June 2021, Microsoft changed its description of &lt;a href=&quot;https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fflush?view=msvc-160&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;fflush()&lt;/code&gt;&lt;/a&gt; compared with what was originally specified when this answer was written in 2015.  It now says:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;If the stream was opened in read mode, or if the stream has no buffer, the call to &lt;code&gt;fflush&lt;/code&gt; has no effect, and any buffer is retained. A call to &lt;code&gt;fflush&lt;/code&gt; negates the effect of any prior call to &lt;code&gt;ungetc&lt;/code&gt; for the stream.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;a href=&quot;https://en.wiktionary.org/wiki/caveat_lector&quot; rel=&quot;noreferrer&quot;&gt;&lt;em&gt;Caveat Lector:&lt;/em&gt;&lt;/a&gt; it is probably best not to rely on &lt;code&gt;fflush(stdin)&lt;/code&gt; on any platform.&lt;/p&gt;\n&lt;h2&gt;Linux documentation and practice seem to contradict each other&lt;/h2&gt;\n&lt;p&gt;Surprisingly, &lt;a href=&quot;http://linux.die.net/man/3/fflush&quot; rel=&quot;noreferrer&quot;&gt;Linux&lt;/a&gt; nominally documents the behaviour of &lt;code&gt;fflush(stdin)&lt;/code&gt; too, and even defines it the same way (miracle of miracles).  This quote is from 2015.&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;For input streams, &lt;code&gt;fflush()&lt;/code&gt; discards any buffered data that has been fetched from the underlying file, but has not been consumed by the application.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;In 2021, the quote changes to:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;For input streams, &lt;code&gt;fflush()&lt;/code&gt; discards any buffered data that has been fetched from the underlying file, but has not been consumed by the application. The open status of the stream is unaffected.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;And another source for &lt;a href=&quot;http://man7.org/linux/man-pages/man3/fflush.3.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;fflush(3)&lt;/code&gt;&lt;/a&gt; on Linux agrees (give or take paragraph breaks):&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;For input streams associated with seekable files (e.g., disk files, but not pipes or terminals), &lt;code&gt;fflush()&lt;/code&gt; discards any buffered data that has been fetched from the underlying file, but has not been consumed by the application.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Neither of these explicitly addresses the points made by the POSIX specification about &lt;code&gt;ungetc()&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;In 2021, &lt;a href=&quot;https://stackoverflow.com/users/388520/zwol&quot;&gt;zwol&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/questions/2979209/using-fflushstdin/34247021?noredirect=1#comment120026978_34247021&quot;&gt;commented&lt;/a&gt; that the Linux documentation has been improved.\nIt seems to me that there is still room for improvement.&lt;/p&gt;\n&lt;p&gt;In 2015, I was a bit puzzled and surprised at the Linux documentation saying that &lt;code&gt;fflush(stdin)&lt;/code&gt; will work.\nDespite that suggestion, it most usually does not work on Linux.  I just checked the documentation on Ubuntu 14.04 LTS; it says what is quoted above, but empirically, it does not work &amp;nbsp;at least when the input stream is a non-seekable device such as a terminal.&lt;/p&gt;\n&lt;h3&gt;&lt;code&gt;demo-fflush.c&lt;/code&gt;&lt;/h3&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; c;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ((c = getchar()) != EOF)\n    {\n        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Got %c; enter some new data\\n&quot;&lt;/span&gt;, c);\n        fflush(&lt;span class=&quot;hljs-built_in&quot;&gt;stdin&lt;/span&gt;);\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ((c = getchar()) != EOF)\n        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Got %c\\n&quot;&lt;/span&gt;, c);\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;Example output&lt;/h3&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;$ ./demo-fflush\nAlliteration\nGot A; enter some new data\nGot l\n$\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This output was obtained on both Ubuntu 14.04 LTS and Mac OS X 10.11.2.  To my understanding, it contradicts what the Linux manual says.  If the &lt;code&gt;fflush(stdin)&lt;/code&gt; operation worked, I would have to type a new line of text to get information for the second &lt;code&gt;getchar()&lt;/code&gt; to read.&lt;/p&gt;\n&lt;p&gt;Given what the POSIX standard says, maybe a better demonstration is needed, and the Linux documentation should be clarified.&lt;/p&gt;\n&lt;h3&gt;&lt;code&gt;demo-fflush2.c&lt;/code&gt;&lt;/h3&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; c;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ((c = getchar()) != EOF)\n    {\n        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Got %c\\n&quot;&lt;/span&gt;, c);\n        ungetc(&lt;span class=&quot;hljs-string&quot;&gt;&apos;B&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-built_in&quot;&gt;stdin&lt;/span&gt;);\n        ungetc(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Z&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-built_in&quot;&gt;stdin&lt;/span&gt;);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ((c = getchar()) == EOF)\n        {\n            &lt;span class=&quot;hljs-built_in&quot;&gt;fprintf&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;stderr&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Huh?!\\n&quot;&lt;/span&gt;);\n            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n        }\n        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Got %c after ungetc()\\n&quot;&lt;/span&gt;, c);\n        fflush(&lt;span class=&quot;hljs-built_in&quot;&gt;stdin&lt;/span&gt;);\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ((c = getchar()) != EOF)\n        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Got %c\\n&quot;&lt;/span&gt;, c);\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;Example output&lt;/h3&gt;\n&lt;p&gt;Note that &lt;code&gt;/etc/passwd&lt;/code&gt; is a seekable file.  On Ubuntu, the first line looks like:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;root:x:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;:root:/root:/bin/bash\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;On Mac OS X, the first 4 lines look like:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;##\n# User Database\n# \n# Note that this file is consulted directly only when the system is running\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In other words, there is commentary at the top of the Mac OS X &lt;code&gt;/etc/passwd&lt;/code&gt; file.  The non-comment lines conform to the normal layout, so the &lt;code&gt;root&lt;/code&gt; entry is:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;root:*:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;:System Administrator:/var/root:/bin/sh\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Ubuntu 14.04 LTS:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;$ ./demo-fflush2 &amp;lt; /etc/passwd\nGot r\nGot Z after &lt;span class=&quot;hljs-title function_&quot;&gt;ungetc&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\nGot o\n$ ./demo-fflush2\nAllotrope\nGot A\nGot Z after &lt;span class=&quot;hljs-title function_&quot;&gt;ungetc&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\nGot B\n$\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Mac OS X 10.11.2:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;$ ./demo-fflush2 &amp;lt; /etc/passwd\nGot #\nGot Z after &lt;span class=&quot;hljs-title function_&quot;&gt;ungetc&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\nGot B\n$\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The Mac OS X behaviour ignores (or at least seems to ignore) the &lt;code&gt;fflush(stdin)&lt;/code&gt; (thus not following POSIX on this issue).  The Linux behaviour corresponds to the documented POSIX behaviour, but the POSIX specification is far more careful in what it says  it specifies a file capable of seeking, but terminals, of course, do not support seeking.  It is also much less useful than the Microsoft specification.&lt;/p&gt;\n&lt;h2&gt;Summary&lt;/h2&gt;\n&lt;p&gt;Microsoft documents the behaviour of &lt;code&gt;fflush(stdin)&lt;/code&gt;, but that behaviour has changed between 2015 and 2021.  Apparently, it works as documented on the Windows platform, using the native Windows compiler and C runtime support libraries.&lt;/p&gt;\n&lt;p&gt;Despite documentation to the contrary, it does not work on Linux when the standard input is a terminal, but it seems to follow the POSIX specification which is far more carefully worded.  According to the C standard, the behaviour of &lt;code&gt;fflush(stdin)&lt;/code&gt; is undefined.  POSIX adds the qualifier &apos;unless the input file is seekable&apos;, which a terminal is not.  The behaviour is not the same as Microsoft&apos;s.&lt;/p&gt;\n&lt;p&gt;Consequently, &lt;em&gt;&lt;strong&gt;portable code does not use &lt;code&gt;fflush(stdin)&lt;/code&gt;&lt;/strong&gt;&lt;/em&gt;.  Code that is tied to Microsoft&apos;s platform may use it and it may work as expected, but beware of the portability issues.&lt;/p&gt;\n&lt;h3&gt;POSIX way to discard unread terminal input from a file descriptor&lt;/h3&gt;\n&lt;p&gt;The POSIX standard way to discard unread information from a terminal file descriptor (as opposed to a file stream like &lt;code&gt;stdin&lt;/code&gt;) is illustrated at &lt;a href=&quot;https://stackoverflow.com/questions/10938882/how-can-i-flush-unread-data-from-a-tty-input-queue-on-a-unix-system&quot;&gt;How can I flush unread data from a tty input queue on a Unix system&lt;/a&gt;.  However, that is operating below the standard I/O library level.&lt;/p&gt;\n    ","\n&lt;p&gt;According to the standard, &lt;code&gt;fflush&lt;/code&gt; can only be used with output buffers, and obviously &lt;code&gt;stdin&lt;/code&gt; isn&apos;t one. However, &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/9yky46tz.aspx&quot; rel=&quot;nofollow noreferrer&quot;&gt;some&lt;/a&gt; standard C libraries provide the use of &lt;code&gt;fflush(stdin)&lt;/code&gt; as an extension. In that case you can use it, but it will affect portability, so you will no longer be able to use any standards-compliant standard C library on earth and expect the same results.&lt;/p&gt;\n    ","\n&lt;p&gt;I believe that you should never call &lt;code&gt;fflush(stdin)&lt;/code&gt;, and for the simple reason that you should never even find it necessary to try to flush input in the first place.  Realistically, there is only one reason you might think you had to flush input, and that is: to get past some bad input that &lt;code&gt;scanf&lt;/code&gt; is stuck on.&lt;/p&gt;\n&lt;p&gt;For example, you might have a program that is sitting in a loop reading integers using &lt;code&gt;scanf(&quot;%d&quot;, &amp;amp;n)&lt;/code&gt;.  Soon enough you&apos;ll discover that the first time the user types a non-digit character like &lt;code&gt;&apos;x&apos;&lt;/code&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/1716013/why-is-scanf-causing-infinite-loop-in-this-code&quot;&gt;the program goes into an infinite loop&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;When faced with this situation, I believe you basically have three choices:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Flush the input somehow (if not by using &lt;code&gt;fflush(stdin)&lt;/code&gt;, then by calling &lt;code&gt;getchar&lt;/code&gt; in a loop to read characters until &lt;code&gt;\\n&lt;/code&gt;, as is often recommended).&lt;/li&gt;\n&lt;li&gt;Tell the user not to type non-digit characters when digits are expected.&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/58403537/what-can-i-use-to-parse-input-instead-of-scanf&quot;&gt;Use something other than &lt;code&gt;scanf&lt;/code&gt; to read input&lt;/a&gt;.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;Now, if you&apos;re a beginner, &lt;code&gt;scanf&lt;/code&gt; &lt;em&gt;seems&lt;/em&gt; like the easiest way to read input, and so choice #3 looks scary and difficult.  But #2 seems like a real cop-out, because everyone knows that user-unfriendly computer programs are a problem, so it&apos;d be nice to do better.  So all too many beginning programmers get painted into a corner, feeling that they have no choice but to do #1.  They more or less have to do input using &lt;code&gt;scanf&lt;/code&gt;, meaning that it will get stuck on bad input, meaning that they have to figure out a way to flush the bad input, meaning that they&apos;re sorely tempted to use &lt;code&gt;fflush(stdin)&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;I would like to encourage all beginning C programmers out there to make a different set of tradeoffs:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;During the earliest stages of your C programming career, before you&apos;re comfortable using anything other than &lt;code&gt;scanf&lt;/code&gt;, just &lt;em&gt;don&apos;t worry about bad input&lt;/em&gt;.  Really.  Go ahead and use cop-out #2 above.  Think about it like this: You&apos;re a beginner, there are lots of things you don&apos;t know how to do yet, and one of the things you don&apos;t know how to do yet is: deal gracefully with unexpected input.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;As soon as you can, &lt;a href=&quot;https://stackoverflow.com/questions/58403537/what-can-i-use-to-parse-input-instead-of-scanf&quot;&gt;learn how to do input using functions other than &lt;code&gt;scanf&lt;/code&gt;&lt;/a&gt;.  At that point, you can start dealing gracefully with bad input, and you&apos;ll have many more, much better techniques available to you, that won&apos;t require trying to &quot;flush the bad input&quot; at all.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;Or, in other words, beginners who are still stuck using &lt;code&gt;scanf&lt;/code&gt; should feel free to use cop-out #2, and when they&apos;re ready they should graduate from there to technique #3, and nobody should be using technique #1 to try to flush input at all -- and certainly not with &lt;code&gt;fflush(stdin)&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;Using &lt;code&gt;fflush(stdin)&lt;/code&gt; to flush input is kind of like &lt;a href=&quot;https://en.wikipedia.org/wiki/Dowsing&quot; rel=&quot;nofollow noreferrer&quot;&gt;dowsing for water&lt;/a&gt; using a stick shaped like the letter &quot;S&quot;.&lt;/p&gt;\n&lt;p&gt;And helping people to flush input in some &quot;better&quot; way is kind of like rushing up to an S-stick dowser and saying &quot;No, no, you&apos;re doing it wrong,\nyou need to use a Y-shaped stick!&quot;.&lt;/p&gt;\n&lt;p&gt;In other words, the real problem isn&apos;t that &lt;code&gt;fflush(stdin)&lt;/code&gt; doesn&apos;t work.  Calling &lt;code&gt;fflush(stdin)&lt;/code&gt; is a symptom of an underlying problem.  Why are you having to &quot;flush&quot; input at all?  &lt;em&gt;That&apos;s&lt;/em&gt; your problem.&lt;/p&gt;\n&lt;p&gt;And, usually, that underlying problem is that you&apos;re using &lt;code&gt;scanf&lt;/code&gt;, in one of its many unhelpful modes that unexpectedly leaves newlines or other &quot;unwanted&quot; text on the input.  The best long-term solution, therefore, is to &lt;a href=&quot;https://stackoverflow.com/questions/58403537/what-can-i-use-for-input-conversion-instead-of-scanf&quot;&gt;learn how to do input using better techniques than &lt;code&gt;scanf&lt;/code&gt;&lt;/a&gt;, so that you don&apos;t have to deal with its unhandled input and other idiosyncrasies at all.&lt;/p&gt;\n    ","\n&lt;p&gt;None of the existing answers point out a key aspect of the issue.&lt;/p&gt;\n&lt;p&gt;If you find yourself &lt;em&gt;wanting&lt;/em&gt; to &quot;clear the input buffer&quot;, you&apos;re probably writing a command-line interactive program, and it would be more accurate to say that what you want is to &lt;em&gt;discard characters from the current &lt;strong&gt;line&lt;/strong&gt; of input that you haven&apos;t already read.&lt;/em&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;This is not what &lt;code&gt;fflush(stdin)&lt;/code&gt; does.&lt;/strong&gt;  The C libraries that support using &lt;code&gt;fflush&lt;/code&gt; on an input stream, document it as either doing &lt;em&gt;nothing,&lt;/em&gt; or as discarding &lt;em&gt;buffered data that has been read from the underlying file but not passed to the application&lt;/em&gt;.  That can easily be either &lt;em&gt;more&lt;/em&gt; or &lt;em&gt;less&lt;/em&gt; input than the rest of the current line.  It probably does work by accident in a lot of cases, because the terminal driver (in its default mode) supplies input to a command-line interactive program one line at a time.  However, the moment you try to feed input to your program from an actual file on disk (perhaps for automated testing), the kernel and C library will switch over to buffering data in large &quot;blocks&quot; (often 4 to 8 kB) with no relationship to line boundaries, and you&apos;ll be wondering why your program is processing the first line of the file and then skipping several dozen lines and picking up in the &lt;em&gt;middle&lt;/em&gt; of some apparently random line below.  Or, if you decide to test your program on a very &lt;em&gt;long&lt;/em&gt; line typed by hand, then the terminal driver won&apos;t be able to give the program the whole line at once and &lt;code&gt;fflush(stdin)&lt;/code&gt; won&apos;t skip all of it.&lt;/p&gt;\n&lt;p&gt;So what should you do instead?  The approach that I prefer is, if you&apos;re processing input one line at a time, then &lt;em&gt;read an entire line all at once&lt;/em&gt;.  The C library has functions specifically for this: &lt;code&gt;fgets&lt;/code&gt; (in C90, so fully portable, but does still make you process very long lines in chunks) and &lt;code&gt;getline&lt;/code&gt; (POSIX-specific, but will manage a &lt;code&gt;malloc&lt;/code&gt;ed buffer for you so you can process long lines all at once no matter how long they get).  There&apos;s usually a direct translation from code that processes &quot;the current line&quot; directly from stdin to code that processes a string containing &quot;the current line&quot;.&lt;/p&gt;\n    ","\n&lt;p&gt;Quote from &lt;a href=&quot;https://www.unix.com/man-page/posix/3P/fflush/&quot; rel=&quot;nofollow noreferrer&quot; title=&quot;POSIX&quot;&gt;POSIX&lt;/a&gt;:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;For  a  stream  open  for  reading, if the file is not already at EOF, and the file is one\ncapable of seeking, the file offset of the underlying open file description shall  be  set\nto  the   file  position  of  the stream, and any characters pushed back onto the stream by\nungetc() or ungetwc() that have not subsequently been read from the stream shall  be  dis-\ncarded (without further changing the file offset).&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Note that terminal is not capable of seeking.&lt;/p&gt;\n    "],"315":["\n&lt;p&gt;The function linked in another answer is insufficient. It fails to escape &lt;code&gt;^&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt; (start and end of string), or &lt;code&gt;-&lt;/code&gt;, which in a character group is used for ranges.&lt;/p&gt;\n&lt;p&gt;Use this function:&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;escapeRegex&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;string&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; string.&lt;span class=&quot;hljs-title function_&quot;&gt;replace&lt;/span&gt;(&lt;span class=&quot;hljs-regexp&quot;&gt;/[-\\/\\\\^$*+?.()|[\\]{}]/g&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\\\$&amp;amp;&apos;&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;While it may seem unnecessary at first glance, escaping &lt;code&gt;-&lt;/code&gt; (as well as &lt;code&gt;^&lt;/code&gt;) makes the function suitable for escaping characters to be inserted into a character class as well as the body of the regex.&lt;/p&gt;\n&lt;p&gt;Escaping &lt;code&gt;/&lt;/code&gt; makes the function suitable for escaping characters to be used in a JavaScript regex literal for later evaluation.&lt;/p&gt;\n&lt;p&gt;As there is no downside to escaping either of them, it makes sense to escape to cover wider use cases.&lt;/p&gt;\n&lt;p&gt;And yes, it is a disappointing failing that this is not part of standard JavaScript.&lt;/p&gt;\n    ","\n&lt;p&gt;For anyone using Lodash, &lt;a href=&quot;https://github.com/lodash/lodash/wiki/Changelog#v300&quot; rel=&quot;noreferrer&quot;&gt;since v3.0.0&lt;/a&gt; a &lt;a href=&quot;https://lodash.com/docs#escapeRegExp&quot; rel=&quot;noreferrer&quot;&gt;_.escapeRegExp&lt;/a&gt; function is built-in:&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;_.escapeRegExp(&lt;span class=&quot;hljs-string&quot;&gt;&apos;[lodash](https://lodash.com/)&apos;&lt;/span&gt;);\n&lt;span class=&quot;hljs-comment&quot;&gt;//  &apos;\\[lodash\\]\\(https:\\/\\/lodash\\.com\\/\\)&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;And, in the event that you don&apos;t want to require the full Lodash library, you may require &lt;a href=&quot;https://www.npmjs.com/package/lodash.escaperegexp&quot; rel=&quot;noreferrer&quot;&gt;just that function&lt;/a&gt;!&lt;/p&gt;\n    ","\n&lt;p&gt;Most of the expressions here solve single specific use cases.&lt;/p&gt;\n\n&lt;p&gt;That&apos;s okay, but I prefer an &quot;always works&quot; approach.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;regExpEscape&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;literal_string&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; literal_string.&lt;span class=&quot;hljs-title function_&quot;&gt;replace&lt;/span&gt;(&lt;span class=&quot;hljs-regexp&quot;&gt;/[-[\\]{}()*+!&amp;lt;=:?.\\/\\\\^$|#\\s,]/g&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\\\$&amp;amp;&apos;&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This will &quot;fully escape&quot; a literal string for any of the following uses in regular expressions:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Insertion in a regular expression. E.g. &lt;code&gt;new RegExp(regExpEscape(str))&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;Insertion in a character class. E.g. &lt;code&gt;new RegExp(&apos;[&apos; + regExpEscape(str) + &apos;]&apos;)&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;Insertion in integer count specifier. E.g. &lt;code&gt;new RegExp(&apos;x{1,&apos; + regExpEscape(str) + &apos;}&apos;)&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;Execution in non-JavaScript regular expression engines.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Special Characters Covered:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;-&lt;/code&gt;: Creates a character range in a character class.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;[&lt;/code&gt; / &lt;code&gt;]&lt;/code&gt;: Starts / ends a character class.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;{&lt;/code&gt; / &lt;code&gt;}&lt;/code&gt;: Starts / ends a numeration specifier.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;(&lt;/code&gt; / &lt;code&gt;)&lt;/code&gt;: Starts / ends a group.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;*&lt;/code&gt; / &lt;code&gt;+&lt;/code&gt; / &lt;code&gt;?&lt;/code&gt;: Specifies repetition type.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;.&lt;/code&gt;: Matches any character.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;\\&lt;/code&gt;: Escapes characters, and starts entities.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;^&lt;/code&gt;: Specifies start of matching zone, and negates matching in a character class.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;$&lt;/code&gt;: Specifies end of matching zone.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;|&lt;/code&gt;: Specifies alternation.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;#&lt;/code&gt;: Specifies comment in free spacing mode.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;\\s&lt;/code&gt;: Ignored in free spacing mode.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;,&lt;/code&gt;: Separates values in numeration specifier.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;/&lt;/code&gt;: Starts or ends expression.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;:&lt;/code&gt;: Completes special group types, and part of Perl-style character classes.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;!&lt;/code&gt;: Negates zero-width group.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; / &lt;code&gt;=&lt;/code&gt;: Part of zero-width group specifications.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Notes:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;/&lt;/code&gt; is not strictly necessary in any flavor of regular expression. However, it protects in case someone &lt;em&gt;(shudder)&lt;/em&gt; does &lt;code&gt;eval(&quot;/&quot; + pattern + &quot;/&quot;);&lt;/code&gt;.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;,&lt;/code&gt; ensures that if the string is meant to be an integer in the numerical specifier, it will properly cause a RegExp compiling error instead of silently compiling wrong.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;#&lt;/code&gt;, and &lt;code&gt;\\s&lt;/code&gt; do not need to be escaped in JavaScript, but do in many other flavors. They are escaped here in case the regular expression will later be passed to another program.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;If you also need to future-proof the regular expression against potential additions to the JavaScript regex engine capabilities, I recommend using the more paranoid:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;regExpEscapeFuture&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;literal_string&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; literal_string.&lt;span class=&quot;hljs-title function_&quot;&gt;replace&lt;/span&gt;(&lt;span class=&quot;hljs-regexp&quot;&gt;/[^A-Za-z0-9_]/g&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\\\$&amp;amp;&apos;&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This function escapes every character except those explicitly guaranteed not be used for syntax in future regular expression flavors.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;For the truly sanitation-keen, consider this edge case:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; s = &lt;span class=&quot;hljs-string&quot;&gt;&apos;&apos;&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;RegExp&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;(choice1|choice2|&apos;&lt;/span&gt; + &lt;span class=&quot;hljs-title function_&quot;&gt;regExpEscape&lt;/span&gt;(s) + &lt;span class=&quot;hljs-string&quot;&gt;&apos;)&apos;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This &lt;em&gt;should&lt;/em&gt; compile fine in JavaScript, but will not in some other flavors. If intending to pass to another flavor, the null case of &lt;code&gt;s === &apos;&apos;&lt;/code&gt; should be independently checked, like so:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; s = &lt;span class=&quot;hljs-string&quot;&gt;&apos;&apos;&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;RegExp&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;(choice1|choice2&apos;&lt;/span&gt; + (s ? &lt;span class=&quot;hljs-string&quot;&gt;&apos;|&apos;&lt;/span&gt; + &lt;span class=&quot;hljs-title function_&quot;&gt;regExpEscape&lt;/span&gt;(s) : &lt;span class=&quot;hljs-string&quot;&gt;&apos;&apos;&lt;/span&gt;) + &lt;span class=&quot;hljs-string&quot;&gt;&apos;)&apos;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping&quot; rel=&quot;noreferrer&quot;&gt;Mozilla Developer Network&apos;s Guide to Regular Expressions&lt;/a&gt; provides this escaping function:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;escapeRegExp&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;string&lt;/span&gt;) {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; string.&lt;span class=&quot;hljs-title function_&quot;&gt;replace&lt;/span&gt;(&lt;span class=&quot;hljs-regexp&quot;&gt;/[.*+?^${}()|[\\]\\\\]/g&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\\\$&amp;amp;&apos;&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;// $&amp;amp; means the whole matched string&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;In jQuery UI&apos;s autocomplete widget (version 1.9.1) they use a slightly different regular expression (line 6753), here&apos;s the regular expression combined with &lt;a href=&quot;https://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript/3561711#3561711&quot;&gt;bobince&apos;s approach&lt;/a&gt;.&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-title class_&quot;&gt;RegExp&lt;/span&gt;.&lt;span class=&quot;hljs-property&quot;&gt;escape&lt;/span&gt; = &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt; value &lt;/span&gt;) {\n     &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; value.&lt;span class=&quot;hljs-title function_&quot;&gt;replace&lt;/span&gt;(&lt;span class=&quot;hljs-regexp&quot;&gt;/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\\\$&amp;amp;&quot;&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Nothing should prevent you from just escaping every non-alphanumeric character:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;usersString.&lt;span class=&quot;hljs-title function_&quot;&gt;replace&lt;/span&gt;(&lt;span class=&quot;hljs-regexp&quot;&gt;/(?=\\W)/g&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\\\&apos;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You lose a certain degree of readability when doing &lt;code&gt;re.toString()&lt;/code&gt; but you win a great deal of simplicity (and security).&lt;/p&gt;\n\n&lt;p&gt;According to ECMA-262, on the one hand, regular expression &quot;syntax characters&quot; are always non-alphanumeric, such that the result is secure, and special escape sequences (&lt;code&gt;\\d&lt;/code&gt;, &lt;code&gt;\\w&lt;/code&gt;, &lt;code&gt;\\n&lt;/code&gt;) are always alphanumeric such that no false control escapes will be produced.&lt;/p&gt;\n    ","\n&lt;p&gt;There is an &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#7th_Edition_-_ECMAScript_2016&quot; rel=&quot;nofollow noreferrer&quot;&gt;ES7&lt;/a&gt; proposal for RegExp.escape at &lt;a href=&quot;https://github.com/benjamingr/RexExp.escape/&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://github.com/benjamingr/RexExp.escape/&lt;/a&gt;, with a polyfill available at &lt;a href=&quot;https://github.com/ljharb/regexp.escape&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://github.com/ljharb/regexp.escape&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;Another (much safer) approach is to escape all the characters (and not just a few special ones that we currently know) using the unicode escape format &lt;code&gt;\\u{code}&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;escapeRegExp&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;text&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Array&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;from&lt;/span&gt;(text)\n           .&lt;span class=&quot;hljs-title function_&quot;&gt;map&lt;/span&gt;(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;char&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;`\\\\u{&lt;span class=&quot;hljs-subst&quot;&gt;${char.charCodeAt(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;).toString(&lt;span class=&quot;hljs-number&quot;&gt;16&lt;/span&gt;)}&lt;/span&gt;}`&lt;/span&gt;)\n           .&lt;span class=&quot;hljs-title function_&quot;&gt;join&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;&apos;&lt;/span&gt;);\n}\n\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(escapeRegExp(&lt;span class=&quot;hljs-string&quot;&gt;&apos;a.b&apos;&lt;/span&gt;)); &lt;span class=&quot;hljs-comment&quot;&gt;// &apos;\\u{61}\\u{2e}\\u{62}&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Please note that you need to pass the &lt;code&gt;u&lt;/code&gt; flag for this method to work:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; expression = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;RegExp&lt;/span&gt;(escapeRegExp(usersString), &lt;span class=&quot;hljs-string&quot;&gt;&apos;u&apos;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;This is a shorter version.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-title class_&quot;&gt;RegExp&lt;/span&gt;.&lt;span class=&quot;hljs-property&quot;&gt;escape&lt;/span&gt; = &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;s&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; s.&lt;span class=&quot;hljs-title function_&quot;&gt;replace&lt;/span&gt;(&lt;span class=&quot;hljs-regexp&quot;&gt;/[$-\\/?[-^{|}]/g&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\\\$&amp;amp;&apos;&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This includes the non-meta characters of &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;&apos;&lt;/code&gt;, and &lt;code&gt;,&lt;/code&gt;, but the JavaScript RegExp specification allows this.&lt;/p&gt;\n    ","\n&lt;p&gt;There is an ES7 proposal for RegExp.escape at &lt;a href=&quot;https://github.com/benjamingr/RexExp.escape/&quot; rel=&quot;noreferrer&quot;&gt;https://github.com/benjamingr/RexExp.escape/&lt;/a&gt;, with a polyfill available at &lt;a href=&quot;https://github.com/ljharb/regexp.escape&quot; rel=&quot;noreferrer&quot;&gt;https://github.com/ljharb/regexp.escape&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;An example based on the rejected ES proposal, includes checks if the property already exists, in the case that TC39 backtracks on their decision.&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;Code:&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;hljs-title class_&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;hljs-property&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;prototype&lt;/span&gt;&lt;/span&gt;.&lt;span class=&quot;hljs-property&quot;&gt;hasOwnProperty&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;call&lt;/span&gt;(&lt;span class=&quot;hljs-title class_&quot;&gt;RegExp&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;escape&apos;&lt;/span&gt;)) {\n  &lt;span class=&quot;hljs-title class_&quot;&gt;RegExp&lt;/span&gt;.&lt;span class=&quot;hljs-property&quot;&gt;escape&lt;/span&gt; = &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;string&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-comment&quot;&gt;// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// https://github.com/benjamingr/RegExp.escape/issues/37&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; string.&lt;span class=&quot;hljs-title function_&quot;&gt;replace&lt;/span&gt;(&lt;span class=&quot;hljs-regexp&quot;&gt;/[.*+\\-?^${}()|[\\]\\\\]/g&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\\\$&amp;amp;&apos;&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;// $&amp;amp; means the whole matched string&lt;/span&gt;\n  };\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Code Minified:&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-title class_&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;hljs-property&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;prototype&lt;/span&gt;&lt;/span&gt;.&lt;span class=&quot;hljs-property&quot;&gt;hasOwnProperty&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;call&lt;/span&gt;(&lt;span class=&quot;hljs-title class_&quot;&gt;RegExp&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;escape&quot;&lt;/span&gt;)||(&lt;span class=&quot;hljs-title class_&quot;&gt;RegExp&lt;/span&gt;.&lt;span class=&quot;hljs-property&quot;&gt;escape&lt;/span&gt;=&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;e&lt;/span&gt;){&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; e.&lt;span class=&quot;hljs-title function_&quot;&gt;replace&lt;/span&gt;(&lt;span class=&quot;hljs-regexp&quot;&gt;/[.*+\\-?^${}()|[\\]\\\\]/g&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;\\\\$&amp;amp;&quot;&lt;/span&gt;)});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;hr&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; assert = &lt;span class=&quot;hljs-built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;assert&apos;&lt;/span&gt;);\n \n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; str = &lt;span class=&quot;hljs-string&quot;&gt;&apos;hello. how are you?&apos;&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; regex = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;RegExp&lt;/span&gt;(&lt;span class=&quot;hljs-title class_&quot;&gt;RegExp&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;escape&lt;/span&gt;(str), &lt;span class=&quot;hljs-string&quot;&gt;&apos;g&apos;&lt;/span&gt;);\nassert.&lt;span class=&quot;hljs-title function_&quot;&gt;equal&lt;/span&gt;(&lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;(regex), &lt;span class=&quot;hljs-string&quot;&gt;&apos;/hello\\. how are you\\?/g&apos;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;hr&gt;\n&lt;p&gt;There is also an &lt;code&gt;npm&lt;/code&gt; module at:\n&lt;a href=&quot;https://www.npmjs.com/package/regexp.escape&quot; rel=&quot;noreferrer&quot;&gt;https://www.npmjs.com/package/regexp.escape&lt;/a&gt;&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;One can install this and use it as so:&lt;/p&gt;\n&lt;hr&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;npm install regexp.&lt;span class=&quot;hljs-property&quot;&gt;escape&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;or&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;yarn add regexp.&lt;span class=&quot;hljs-property&quot;&gt;escape&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;hr&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;escape&lt;/span&gt; = &lt;span class=&quot;hljs-built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;regexp.escape&apos;&lt;/span&gt;);\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; assert = &lt;span class=&quot;hljs-built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;assert&apos;&lt;/span&gt;);\n \n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; str = &lt;span class=&quot;hljs-string&quot;&gt;&apos;hello. how are you?&apos;&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; regex = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;RegExp&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;escape&lt;/span&gt;(str), &lt;span class=&quot;hljs-string&quot;&gt;&apos;g&apos;&lt;/span&gt;);\nassert.&lt;span class=&quot;hljs-title function_&quot;&gt;equal&lt;/span&gt;(&lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;(regex), &lt;span class=&quot;hljs-string&quot;&gt;&apos;/hello\\. how are you\\?/g&apos;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In the GitHub &amp;amp;&amp;amp; NPM page are descriptions of how to use the shim/polyfill for this option, as well. That logic is based on &lt;code&gt;return RegExp.escape || implementation;&lt;/code&gt;, where implementation contains the regexp used above.&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;The NPM module is an extra dependency, but it also make it easier for an external contributor to identify logical parts added to the code. ¯\\&lt;em&gt;()&lt;/em&gt;/¯&lt;/p&gt;\n    ","\n&lt;p&gt;XRegExp has an escape function:&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;XRegExp.escape(&apos;Escaped? &amp;lt;.&amp;gt;&apos;);\n// -&amp;gt; &apos;Escaped\\?\\ &amp;lt;\\.&amp;gt;&apos;\n&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;More on: &lt;a href=&quot;http://xregexp.com/api/#escape&quot; rel=&quot;nofollow noreferrer&quot;&gt;http://xregexp.com/api/#escape&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;escapeRegExp = &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;str&lt;/span&gt;) {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (str == &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;&apos;&lt;/span&gt;;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;(str).&lt;span class=&quot;hljs-title function_&quot;&gt;replace&lt;/span&gt;(&lt;span class=&quot;hljs-regexp&quot;&gt;/([.*+?^=!:${}()|[\\]\\/\\\\])/g&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\\\$1&apos;&lt;/span&gt;);\n};\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Rather than only escaping characters which will cause issues in your regular expression (e.g.: a blacklist), consider using a whitelist instead. This way each character is considered tainted unless it matches.&lt;/p&gt;\n&lt;p&gt;For this example, assume the following expression:&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-title class_&quot;&gt;RegExp&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;escape&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;be || ! be&apos;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This whitelists letters, number and spaces:&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-title class_&quot;&gt;RegExp&lt;/span&gt;.&lt;span class=&quot;hljs-property&quot;&gt;escape&lt;/span&gt; = &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;string&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; string.&lt;span class=&quot;hljs-title function_&quot;&gt;replace&lt;/span&gt;(&lt;span class=&quot;hljs-regexp&quot;&gt;/([^\\w\\d\\s])/gi&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\\\$1&apos;&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Returns:&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;be \\|\\| \\! be&quot;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This may escape characters which do not need to be escaped, but this doesn&apos;t hinder your expression (maybe some minor time penalties - but it&apos;s worth it for safety).&lt;/p&gt;\n    ","\n&lt;p&gt;The functions in the other answers are overkill for escaping entire regular expressions (they may be useful for escaping &lt;em&gt;parts&lt;/em&gt; of regular expressions that will later be concatenated into bigger regexps).&lt;/p&gt;\n\n&lt;p&gt;If you escape an entire regexp and are done with it, quoting the metacharacters that are either standalone (&lt;code&gt;.&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;$&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;\\&lt;/code&gt;) or start something (&lt;code&gt;(&lt;/code&gt;, &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;{&lt;/code&gt;) is all you need:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;.&lt;span class=&quot;hljs-property&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;prototype&lt;/span&gt;&lt;/span&gt;.&lt;span class=&quot;hljs-property&quot;&gt;regexEscape&lt;/span&gt; = &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;regexEscape&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-variable language_&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;replace&lt;/span&gt;(&lt;span class=&quot;hljs-regexp&quot;&gt;/[.?+*^$|({[\\\\]/g&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\\\$&amp;amp;&apos;&lt;/span&gt;);\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And yes, it&apos;s disappointing that JavaScript doesn&apos;t have a function like this built-in.&lt;/p&gt;\n    ","\n&lt;p&gt;There has only ever been and ever will be 12 meta characters that need to be escaped\nto be considered a literal.&lt;/p&gt;\n&lt;p&gt;It doesn&apos;t matter what is done with the escaped string, inserted into a balanced regex wrapper or appended. It doesn&apos;t matter.&lt;/p&gt;\n&lt;p&gt;Do a string replace using this&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; escaped_string = oldstring.&lt;span class=&quot;hljs-title function_&quot;&gt;replace&lt;/span&gt;(&lt;span class=&quot;hljs-regexp&quot;&gt;/[\\\\^$.|?*+()[{]/g&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\\\$&amp;amp;&apos;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I borrowed bobince&apos;s &lt;a href=&quot;https://stackoverflow.com/a/3561711/3120446&quot;&gt;answer above&lt;/a&gt; and created a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates&quot; rel=&quot;nofollow noreferrer&quot;&gt;tagged template function&lt;/a&gt; for creating a &lt;code&gt;RegExp&lt;/code&gt; where part of the value is escaped and part isn&apos;t.&lt;/p&gt;\n&lt;h3&gt;regex-escaped.js&lt;/h3&gt;\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-title class_&quot;&gt;RegExp&lt;/span&gt;.&lt;span class=&quot;hljs-property&quot;&gt;escape&lt;/span&gt; = &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;text&lt;/span&gt; =&amp;gt;&lt;/span&gt; text.&lt;span class=&quot;hljs-title function_&quot;&gt;replace&lt;/span&gt;(&lt;span class=&quot;hljs-regexp&quot;&gt;/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\\\$&amp;amp;&apos;&lt;/span&gt;);\n\n&lt;span class=&quot;hljs-title class_&quot;&gt;RegExp&lt;/span&gt;.&lt;span class=&quot;hljs-property&quot;&gt;escaped&lt;/span&gt; = &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;flags&lt;/span&gt; =&amp;gt;&lt;/span&gt;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;regexStrings, ...escaped&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; source = regexStrings\n      .&lt;span class=&quot;hljs-title function_&quot;&gt;map&lt;/span&gt;(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;s, i&lt;/span&gt;) =&amp;gt;&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;// escaped[i] will be undefined for the last value of s&lt;/span&gt;\n        escaped[i] === &lt;span class=&quot;hljs-literal&quot;&gt;undefined&lt;/span&gt;\n          ? s\n          : s + &lt;span class=&quot;hljs-title class_&quot;&gt;RegExp&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;escape&lt;/span&gt;(escaped[i].&lt;span class=&quot;hljs-title function_&quot;&gt;toString&lt;/span&gt;())\n      )\n      .&lt;span class=&quot;hljs-title function_&quot;&gt;join&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;&apos;&lt;/span&gt;);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;RegExp&lt;/span&gt;(source, flags);\n  };\n  \n&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;capitalizeFirstUserInputCaseInsensitiveMatch&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;text, userInput&lt;/span&gt;) {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; [, before, match, after ] =\n    &lt;span class=&quot;hljs-title class_&quot;&gt;RegExp&lt;/span&gt;.escaped(&lt;span class=&quot;hljs-string&quot;&gt;&apos;i&apos;&lt;/span&gt;)&lt;span class=&quot;hljs-string&quot;&gt;`^((?:(?!&lt;span class=&quot;hljs-subst&quot;&gt;${userInput}&lt;/span&gt;).)*)(&lt;span class=&quot;hljs-subst&quot;&gt;${userInput}&lt;/span&gt;)?(.*)$`&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;exec&lt;/span&gt;(text);\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;`&lt;span class=&quot;hljs-subst&quot;&gt;${before}&lt;/span&gt;&lt;span class=&quot;hljs-subst&quot;&gt;${match.toUpperCase()}&lt;/span&gt;&lt;span class=&quot;hljs-subst&quot;&gt;${after}&lt;/span&gt;`&lt;/span&gt;;\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; text = &lt;span class=&quot;hljs-string&quot;&gt;&apos;hello (world)&apos;&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; userInput = &lt;span class=&quot;hljs-string&quot;&gt;&apos;lo (wor&apos;&lt;/span&gt;;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-title function_&quot;&gt;capitalizeFirstUserInputCaseInsensitiveMatch&lt;/span&gt;(text, userInput));&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif1&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;For our TypeScript fans...&lt;/p&gt;\n&lt;h3&gt;global.d.ts&lt;/h3&gt;\n&lt;pre class=&quot;lang-ts s-code-block&quot;&gt;&lt;code class=&quot;hljs language-typescript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;RegExpConstructor&lt;/span&gt; {\n  &lt;span class=&quot;hljs-comment&quot;&gt;/** Escapes a string so that it can be used as a literal within a `RegExp`. */&lt;/span&gt;\n  &lt;span class=&quot;hljs-built_in&quot;&gt;escape&lt;/span&gt;(&lt;span class=&quot;hljs-attr&quot;&gt;text&lt;/span&gt;: &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;): &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;;\n\n  &lt;span class=&quot;hljs-comment&quot;&gt;/**\n   * Returns a tagged template function that creates `RegExp` with its template values escaped.\n   *\n   * This can be useful when using a `RegExp` to search with user input.\n   *\n   * &lt;span class=&quot;hljs-doctag&quot;&gt;@param&lt;/span&gt; flags The flags to apply to the `RegExp`.\n   *\n   * &lt;span class=&quot;hljs-doctag&quot;&gt;@example&lt;/span&gt;\n   *\n   * function capitalizeFirstUserInputCaseInsensitiveMatch(text: string, userInput: string) {\n   *   const [, before, match, after ] =\n   *     RegExp.escaped(&apos;i&apos;)`^((?:(?!${userInput}).)*)(${userInput})?(.*)$`.exec(text);\n   *\n   *   return `${before}${match.toUpperCase()}${after}`;\n   * }\n   */&lt;/span&gt;\n  escaped(flags?: &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;): &lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;regexStrings: TemplateStringsArray, ...escapedVals: &lt;span class=&quot;hljs-built_in&quot;&gt;Array&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; | &lt;span class=&quot;hljs-built_in&quot;&gt;number&lt;/span&gt;&amp;gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;RegExp&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    "]},"page":"60","randomQuestions":[{"title":"What are the rules for JavaScript's automatic semicolon insertion (ASI)?","slug":"what-are-the-rules-for-javascript's-automatic-semicolon-insertion-(asi)-1657387472789"},{"title":"Using regular expressions to parse HTML: why not?","slug":"using-regular-expressions-to-parse-html:-why-not-1657387543969"},{"title":"How do I convert an existing callback API to promises?","slug":"how-do-i-convert-an-existing-callback-api-to-promises-1657384694006"},{"title":"Where can I find documentation on formatting a date in JavaScript?","slug":"where-can-i-find-documentation-on-formatting-a-date-in-javascript-1657384878157"},{"title":"Ways to deal with #document under iframe","slug":"ways-to-deal-with-document-under-iframe-1657388403345"},{"title":"How do I return the response from an Observable/http/async call in angular?","slug":"how-do-i-return-the-response-from-an-observablehttpasync-call-in-angular-1657387335024"},{"title":"PHP parse/syntax errors; and how to solve them","slug":"php-parsesyntax-errors-and-how-to-solve-them-1657384264713"},{"title":"Syntax error due to using a reserved word as a table or column name in MySQL","slug":"syntax-error-due-to-using-a-reserved-word-as-a-table-or-column-name-in-mysql-1657384689274"},{"title":"Why is using the JavaScript eval function a bad idea?","slug":"why-is-using-the-javascript-eval-function-a-bad-idea-1657387485165"},{"title":"How does the Java 'for each' loop work?","slug":"how-does-the-java-'for-each'-loop-work-1657388423749"},{"title":"What is DOM Event delegation?","slug":"what-is-dom-event-delegation-1657387625599"},{"title":"What do lambda function closures capture? [duplicate]","slug":"what-do-lambda-function-closures-capture-duplicate-1657388161827"},{"title":"What does the comma operator , do?","slug":"what-does-the-comma-operator-do-1657388258021"},{"title":"What is a lambda expression in C++11?","slug":"what-is-a-lambda-expression-in-c++11-1657387999252"},{"title":"How do I use reflection to call a generic method?","slug":"how-do-i-use-reflection-to-call-a-generic-method-1657387256751"},{"title":"Why are these numbers not equal?","slug":"why-are-these-numbers-not-equal-1657384729559"},{"title":"How do you remove duplicates from a list whilst preserving order?","slug":"how-do-you-remove-duplicates-from-a-list-whilst-preserving-order-1657387877978"},{"title":"Calling a function of a module by using its name (a string)","slug":"calling-a-function-of-a-module-by-using-its-name-(a-string)-1657388565656"},{"title":"Simulating group_concat MySQL function in Microsoft SQL Server 2005?","slug":"simulating-group_concat-mysql-function-in-microsoft-sql-server-2005-1657384832169"},{"title":"The Definitive C++ Book Guide and List","slug":"the-definitive-c++-book-guide-and-list-1657384247395"}]},"__N_SSG":true}