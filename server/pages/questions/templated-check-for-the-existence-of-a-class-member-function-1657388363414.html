<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2eccd4d47c856f2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2eccd4d47c856f2b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/471-84c36aa98dd4107c.js" defer=""></script><script src="/_next/static/chunks/81-096e453de8a27667.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-e3d1b60e109d3ba1.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_buildManifest.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.hFcsiD code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-6e32c308-0"]{content:"hFcsiD,"}/*!sc*/
.ljvTUN .comment-item .comment-body .d-inline-flex.ai-center{text-align:right;}/*!sc*/
.ljvTUN .comment-item .comment-body .comment-date{float:right;}/*!sc*/
data-styled.g6[id="sc-6e32c308-1"]{content:"ljvTUN,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="https://flowbite.com/docs/images/logo.svg" class="mr-3 h-6 sm:h-9" alt="Flowbite Logo"/><span class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Hunter</span></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/templated-check-for-the-existence-of-a-class-member-function-1657388363414#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-6e32c308-0 hFcsiD flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/templated-check-for-the-existence-of-a-class-member-function-1657388363414">Templated check for the existence of a class member function?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/sfinae">sfinae</a></div></div><div class="question-content mt-5">
                
<p>Is it possible to write a template that changes behavior depending on if a certain member function is defined on a class?</p>

<p>Here's a simple example of what I would want to write:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
std::string <span class="hljs-title">optionalToString</span><span class="hljs-params">(T* obj)</span>
</span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">FUNCTION_EXISTS</span>(T-&gt;toString))
        <span class="hljs-keyword">return</span> obj-&gt;<span class="hljs-built_in">toString</span>();
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"toString not defined"</span>;
}
</code></pre>

<p>So, if <code>class T</code> has <code>toString()</code> defined, then it uses it; otherwise, it doesn't. The magical part that I don't know how to do is the "FUNCTION_EXISTS" part.</p>
    </div></div></div><div class="sc-6e32c308-1 ljvTUN flex text-xs pl-10 flex-col comment items-center justify-center"><h4 class="text-left mt-10 text-lg font-semibold">Comments</h4><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy">Of course it goes without saying that the template answer(s) below only work with compile-time information, i.e. T must have toString. If you pass in a subclass of T that <i>does</i> define toString, but T does <i>not</i>, you will be told toString is not defined.</span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/125663/alice-purcell" title="12,114 reputation" class="comment-user">Alice Purcell</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment3808746_257288"><span title="2010-09-02 09:50:53Z, License: CC BY-SA 2.5" class="relativetime-clean">Sep 2, 2010 at 9:50</span></a></span>
            </div>
        </div><span class="divide-x-8 "></span><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy">Possible Duplicate <a href="http://stackoverflow.com/q/36079170/514235">How to check if a member name (variable or function) exists in a class, with or without specifying type?</a>, as it covers broader problem with C++03 to C++1y.</span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/514235/iammilind" title="65,402 reputation" class="comment-user">iammilind</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment59805126_257288"><span title="2016-03-18 09:13:11Z, License: CC BY-SA 3.0" class="relativetime-clean">Mar 18, 2016 at 9:13</span></a></span>
            </div>
        </div><span class="divide-x-8 "></span><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy">Note that C++20 now permits to do that with concepts. See <a href="https://stackoverflow.com/questions/58394556/c-concepts-can-i-have-a-constraint-requiring-a-function-be-present-in-a-clas" title="c concepts can i have a constraint requiring a function be present in a clas">stackoverflow.com/questions/58394556/</a> and <a href="https://en.cppreference.com/w/cpp/language/constraints" rel="nofollow noreferrer">en.cppreference.com/w/cpp/language/constraints</a></span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/806286/etham" title="2,720 reputation" class="comment-user">etham</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment124106522_257288"><span title="2021-12-02 21:07:33Z, License: CC BY-SA 4.0" class="relativetime-clean">Dec 2, 2021 at 21:07</span></a></span>
            </div>
        </div><span class="divide-x-8 "></span><button class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">See more</button></div><div class="sc-6e32c308-2 bFXWFO"><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Yes, with SFINAE you can check if a given class does provide a certain method. Here's the working code:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Hello</span>
{
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">helloworld</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; }
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Generic</span> {};    

<span class="hljs-comment">// SFINAE test</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">has_helloworld</span>
{
    <span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> one;
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">two</span> { <span class="hljs-type">char</span> x[<span class="hljs-number">2</span>]; };

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> C&gt; <span class="hljs-function"><span class="hljs-type">static</span> one <span class="hljs-title">test</span><span class="hljs-params">( <span class="hljs-keyword">decltype</span>(&amp;C::helloworld) )</span> </span>;
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> C&gt; <span class="hljs-function"><span class="hljs-type">static</span> two <span class="hljs-title">test</span><span class="hljs-params">(...)</span></span>;    

<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">enum</span> { value = <span class="hljs-built_in">sizeof</span>(<span class="hljs-built_in">test</span>&lt;T&gt;(<span class="hljs-number">0</span>)) == <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) };
};
    
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>
</span>{
    std::cout &lt;&lt; has_helloworld&lt;Hello&gt;::value &lt;&lt; std::endl;
    std::cout &lt;&lt; has_helloworld&lt;Generic&gt;::value &lt;&lt; std::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>I've just tested it with Linux and gcc 4.1/4.3. I don't know if it's portable to other platforms running different compilers.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This question is old, but with C++11 we got a new way to check for a functions existence (or existence of any non-type member, really), relying on SFINAE again:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
<span class="hljs-keyword">auto</span> <span class="hljs-title">serialize_imp</span><span class="hljs-params">(std::ostream&amp; os, T <span class="hljs-type">const</span>&amp; obj, <span class="hljs-type">int</span>)</span>
    -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(os &lt;&lt; obj, <span class="hljs-type">void</span>())</span>
</span>{
  os &lt;&lt; obj;
}

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
<span class="hljs-keyword">auto</span> <span class="hljs-title">serialize_imp</span><span class="hljs-params">(std::ostream&amp; os, T <span class="hljs-type">const</span>&amp; obj, <span class="hljs-type">long</span>)</span>
    -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(obj.stream(os), <span class="hljs-type">void</span>())</span>
</span>{
  obj.<span class="hljs-built_in">stream</span>(os);
}

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
<span class="hljs-keyword">auto</span> <span class="hljs-title">serialize</span><span class="hljs-params">(std::ostream&amp; os, T <span class="hljs-type">const</span>&amp; obj)</span>
    -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(serialize_imp(os, obj, <span class="hljs-number">0</span>), <span class="hljs-type">void</span>())</span>
</span>{
  <span class="hljs-built_in">serialize_imp</span>(os, obj, <span class="hljs-number">0</span>);
}
</code></pre>

<p>Now onto some explanations. First thing, I use <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2634.html" rel="noreferrer">expression SFINAE</a> to exclude the <code>serialize(_imp)</code> functions from overload resolution, if the first expression inside <code>decltype</code> isn't valid (aka, the function doesn't exist).</p>

<p>The <code>void()</code> is used to make the return type of all those functions <code>void</code>.</p>

<p>The <code>0</code> argument is used to prefer the <code>os &lt;&lt; obj</code> overload if both are available (literal <code>0</code> is of type <code>int</code> and as such the first overload is a better match).</p>

<hr>

<p>Now, you probably want a trait to check if a function exists. Luckily, it's easy to write that. Note, though, that you need to write a trait <em>yourself</em> for every different function name you might want.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span>&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">sfinae_true</span> : std::true_type{};

<span class="hljs-keyword">namespace</span> detail{
  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T, <span class="hljs-keyword">class</span> A0&gt;
  <span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">test_stream</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>
      -&gt; sfinae_true&lt;<span class="hljs-title">decltype</span><span class="hljs-params">(std::declval&lt;T&gt;().stream(std::declval&lt;A0&gt;()))</span>&gt;</span>;
  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span>, <span class="hljs-keyword">class</span> A0&gt;
  <span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">test_stream</span><span class="hljs-params">(<span class="hljs-type">long</span>)</span> -&gt; std::false_type</span>;
} <span class="hljs-comment">// detail::</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Arg</span>&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">has_stream</span> : <span class="hljs-keyword">decltype</span>(detail::<span class="hljs-built_in">test_stream</span>&lt;T, Arg&gt;(<span class="hljs-number">0</span>)){};
</code></pre>

<p><a href="http://coliru.stacked-crooked.com/a/cd139d95d214c5c3" rel="noreferrer">Live example.</a></p>

<p>And on to explanations. First, <code>sfinae_true</code> is a helper type, and it basically amounts to the same as writing <code>decltype(void(std::declval&lt;T&gt;().stream(a0)), std::true_type{})</code>. The advantage is simply that it's shorter.<br>
Next, the <code>struct has_stream : decltype(...)</code> inherits from either <code>std::true_type</code> or <code>std::false_type</code> in the end, depending on whether the <code>decltype</code> check in <code>test_stream</code> fails or not.<br>
Last, <code>std::declval</code> gives you a "value" of whatever type you pass, without you needing to know how you can construct it. Note that this is only possible inside an unevaluated context, such as <code>decltype</code>, <code>sizeof</code> and others.</p>

<hr>

<p>Note that <code>decltype</code> is not necessarily needed, as <code>sizeof</code> (and all unevaluated contexts) got that enhancement. It's just that <code>decltype</code> already delivers a type and as such is just cleaner. Here's a <code>sizeof</code> version of one of the overloads:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
<span class="hljs-type">void</span> <span class="hljs-title">serialize_imp</span><span class="hljs-params">(std::ostream&amp; os, T <span class="hljs-type">const</span>&amp; obj, <span class="hljs-type">int</span>,
    <span class="hljs-type">int</span>(*)[<span class="hljs-keyword">sizeof</span>((os &lt;&lt; obj),<span class="hljs-number">0</span>)] = <span class="hljs-number">0</span>)</span>
</span>{
  os &lt;&lt; obj;
}
</code></pre>

<p>The <code>int</code> and <code>long</code> parameters are still there for the same reason. The array pointer is used to provide a context where <code>sizeof</code> can be used.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>C++ allows <a href="http://en.wikipedia.org/wiki/SFINAE" rel="nofollow noreferrer">SFINAE</a> to be used for this (notice that with C++11 features this is simplier because it supports extended SFINAE on nearly arbitrary expressions - the below was crafted to work with common C++03 compilers):</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> HAS_MEM_FUNC(func, name)                                        \
    template<span class="hljs-string">&lt;typename T, typename Sign&gt;</span>                                 \
    struct name {                                                       \
        typedef char yes[1];                                            \
        typedef char no [2];                                            \
        template <span class="hljs-string">&lt;typename U, U&gt;</span> struct type_check;                     \
        template <span class="hljs-string">&lt;typename _1&gt;</span> static yes &amp;chk(type_check<span class="hljs-string">&lt;Sign, &amp;_1::func &gt;</span> *); \
        template <span class="hljs-string">&lt;typename   &gt;</span> static no  &amp;chk(...);                    \
        static bool const value = sizeof(chk<span class="hljs-string">&lt;T&gt;</span>(0)) == sizeof(yes);     \
    }</span>
</code></pre>
<p>The above template and macro tries to instantiate a template, giving it a member function pointer type, and the actual member function pointer. If the types do not fit, SFINAE causes the template to be ignored. Usage like this:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-built_in">HAS_MEM_FUNC</span>(toString, has_to_string);

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">void</span>
<span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-keyword">if</span>(has_to_string&lt;T, std::<span class="hljs-built_in">string</span>(T::*)()&gt;::value) {
      ...
   } <span class="hljs-keyword">else</span> {
      ...
   }
}
</code></pre>
<p>But note that you cannot just call that <code>toString</code> function in that <code>if</code> branch. Since the compiler will check for validity in both branches, that would fail for cases the function doesn't exist. One way is to use SFINAE once again (<code>enable_if</code> can be obtained from boost, too):</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">bool</span> C, <span class="hljs-keyword">typename</span> T = <span class="hljs-type">void</span>&gt;
<span class="hljs-keyword">struct</span> enable_if {
  <span class="hljs-keyword">typedef</span> T type;
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">enable_if</span>&lt;<span class="hljs-literal">false</span>, T&gt; { };

<span class="hljs-built_in">HAS_MEM_FUNC</span>(toString, has_to_string);

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; 
<span class="hljs-keyword">typename</span> enable_if&lt;has_to_string&lt;T, 
                   std::<span class="hljs-built_in">string</span>(T::*)()&gt;::value, std::string&gt;::<span class="hljs-function">type
<span class="hljs-title">doSomething</span><span class="hljs-params">(T * t)</span> </span>{
   <span class="hljs-comment">/* something when T has toString ... */</span>
   <span class="hljs-keyword">return</span> t-&gt;<span class="hljs-built_in">toString</span>();
}

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; 
<span class="hljs-keyword">typename</span> enable_if&lt;!has_to_string&lt;T, 
                   std::<span class="hljs-built_in">string</span>(T::*)()&gt;::value, std::string&gt;::<span class="hljs-function">type
<span class="hljs-title">doSomething</span><span class="hljs-params">(T * t)</span> </span>{
   <span class="hljs-comment">/* something when T doesnt have toString ... */</span>
   <span class="hljs-keyword">return</span> <span class="hljs-string">"T::toString() does not exist."</span>;
}
</code></pre>
<p>Have fun using it. The advantage of it is that it also works for overloaded member functions, and also for <code>const</code> member functions (remember using  <code>std::string(T::*)() const</code> as the member function pointer type then!).</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2>C++20 - <code>requires</code> expressions</h2>
<p>With C++20 come concepts and assorted tools such as <a href="https://en.cppreference.com/w/cpp/language/constraints" rel="noreferrer"><code>requires</code> expressions</a> which are a built-in way to check for a function existence. With them you could rewrite your <code>optionalToString</code> function as follows:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
std::string <span class="hljs-title">optionalToString</span><span class="hljs-params">(T* obj)</span>
</span>{
    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> has_toString = <span class="hljs-built_in">requires</span>(<span class="hljs-type">const</span> T&amp; t) {
        t.<span class="hljs-built_in">toString</span>();
    };

    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(has_toString)</span>
        <span class="hljs-keyword">return</span> obj-&gt;<span class="hljs-title">toString</span><span class="hljs-params">()</span></span>;
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"toString not defined"</span>;
}
</code></pre>
<h2>Pre-C++20 - Detection toolkit</h2>
<p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf" rel="noreferrer">N4502</a> proposes a detection toolkit for inclusion into the C++17 standard library that eventually made it into the library fundamentals TS v2. It most likely won't ever get into the standard because it has been subsumed by <code>requires</code> expressions since, but it still solves the problem in a somewhat elegant manner. The toolkit introduces some metafunctions, including <a href="http://en.cppreference.com/w/cpp/experimental/is_detected" rel="noreferrer"><code>std::is_detected</code></a> which can be used to easily write type or function detection metafunctions on the top of it. Here is how you could use it:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> toString_t = <span class="hljs-keyword">decltype</span>( std::<span class="hljs-built_in">declval</span>&lt;T&amp;&gt;().<span class="hljs-built_in">toString</span>() );

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> has_toString = std::is_detected_v&lt;toString_t, T&gt;;
</code></pre>
<p>Note that the example above is untested. The detection toolkit is not available in standard libraries yet but the proposal contains a full implementation that you can easily copy if you really need it. It plays nice with the C++17 feature <code>if constexpr</code>:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
std::string <span class="hljs-title">optionalToString</span><span class="hljs-params">(T* obj)</span>
</span>{
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(has_toString&lt;T&gt;)</span>
        <span class="hljs-keyword">return</span> obj-&gt;<span class="hljs-title">toString</span><span class="hljs-params">()</span></span>;
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"toString not defined"</span>;
}
</code></pre>
<h2>C++14 - Boost.Hana</h2>
<p>Boost.Hana apparently builds upon this specific example and provides a solution for C++14 in its documentation, so I'm going to quote it directly:</p>
<blockquote>
<p>[...] Hana provides a <code>is_valid</code> function that can be combined with C++14 generic lambdas to obtain a much cleaner implementation of the same thing:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">auto</span> has_toString = hana::<span class="hljs-built_in">is_valid</span>([](<span class="hljs-keyword">auto</span>&amp;&amp; obj) -&gt; <span class="hljs-keyword">decltype</span>(obj.<span class="hljs-built_in">toString</span>()) { });
</code></pre>
<p>This leaves us with a function object <code>has_toString</code> which returns whether the given expression is valid on the argument we pass to it. The result is returned as an <code>IntegralConstant</code>, so constexpr-ness is not an issue here because the result of the function is represented as a type anyway. Now, in addition to being less verbose (that's a one liner!), the intent is much clearer. Other benefits are the fact that <code>has_toString</code> can be passed to higher order algorithms and it can also be defined at function scope, so there is no need to pollute the namespace scope with implementation details.</p>
</blockquote>
<h2>Boost.TTI</h2>
<p>Another somewhat idiomatic toolkit to perform such a check - even though less elegant - is <a href="http://www.boost.org/doc/libs/1_55_0/libs/tti/doc/html/index.html" rel="noreferrer">Boost.TTI</a>, introduced in Boost 1.54.0. For your example, you would have to use the macro <code>BOOST_TTI_HAS_MEMBER_FUNCTION</code>. Here is how you could use it:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/tti/has_member_function.hpp&gt;</span></span>

<span class="hljs-comment">// Generate the metafunction</span>
<span class="hljs-built_in">BOOST_TTI_HAS_MEMBER_FUNCTION</span>(toString)

<span class="hljs-comment">// Check whether T has a member function toString</span>
<span class="hljs-comment">// which takes no parameter and returns a std::string</span>
<span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> foo = has_member_function_toString&lt;T, std::string&gt;::value;
</code></pre>
<p>Then, you could use the <code>bool</code> to create a SFINAE check.</p>
<p><em>Explanation</em></p>
<p>The macro <code>BOOST_TTI_HAS_MEMBER_FUNCTION</code> generates the metafunction <code>has_member_function_toString</code> which takes the checked type as its first template parameter. The second template parameter corresponds to the return type of the member function, and the following parameters correspond to the types of the function's parameters. The member <code>value</code> contains <code>true</code> if the class <code>T</code> has a member function <code>std::string toString()</code>.</p>
<p>Alternatively, <code>has_member_function_toString</code> can take a member function pointer as a template parameter. Therefore, it is possible to replace <code>has_member_function_toString&lt;T, std::string&gt;::value</code> by <code>has_member_function_toString&lt;std::string T::* ()&gt;::value</code>.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Though this question is two years old, I'll dare to add my answer. Hopefully it will clarify the previous, indisputably excellent, solution. I took the very helpful answers of Nicola Bonelli and Johannes Schaub and merged them into a solution that is, IMHO, more readable, clear and does not require the <code>typeof</code> extension:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeHasToString</span>
{
    <span class="hljs-comment">// This type won't compile if the second template parameter isn't of type T,</span>
    <span class="hljs-comment">// so I can put a function pointer type in the first parameter and the function</span>
    <span class="hljs-comment">// itself in the second thus checking that the function has a specific signature.</span>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TypeCheck</span>;

    <span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> Yes;
    <span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> No;

    <span class="hljs-comment">// A helper struct to hold the declaration of the function pointer.</span>
    <span class="hljs-comment">// Change it if the function signature changes.</span>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ToString</span>
    {
        <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(T::*fptr)</span><span class="hljs-params">()</span></span>;
    };

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">static</span> Yes <span class="hljs-title">HasToString</span><span class="hljs-params">(TypeCheck&lt; <span class="hljs-keyword">typename</span> ToString&lt;T&gt;::fptr, &amp;T::toString &gt;*)</span></span>;
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">static</span> No  <span class="hljs-title">HasToString</span><span class="hljs-params">(...)</span></span>;

<span class="hljs-keyword">public</span>:
    <span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-type">const</span> value = (<span class="hljs-built_in">sizeof</span>(<span class="hljs-built_in">HasToString</span>&lt;Type&gt;(<span class="hljs-number">0</span>)) == <span class="hljs-built_in">sizeof</span>(Yes));
};
</code></pre>

<p>I checked it with gcc 4.1.2.
The credit goes mainly to Nicola Bonelli and Johannes Schaub, so give them a vote up if my answer helps you :)</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A simple solution for C++11:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
<span class="hljs-keyword">auto</span> <span class="hljs-title">optionalToString</span><span class="hljs-params">(T* obj)</span>
 -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(  obj-&gt;toString()  )</span>
</span>{
    <span class="hljs-keyword">return</span>     obj-&gt;<span class="hljs-built_in">toString</span>();
}
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">optionalToString</span><span class="hljs-params">(...)</span> -&gt; string
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">"toString not defined"</span>;
}
</code></pre>

<p>Update, 3 years later: (and this is untested). To test for the existence, I think this will work:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">test_has_toString_method</span><span class="hljs-params">(T* obj)</span>
 -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(  obj-&gt;toString() , std::true_type{} )</span>
</span>{
    <span class="hljs-keyword">return</span>     obj-&gt;<span class="hljs-built_in">toString</span>();
}
<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">test_has_toString_method</span><span class="hljs-params">(...)</span> -&gt; std::false_type
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">"toString not defined"</span>;
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Well, this question has a long list of answers already, but I would like to emphasize the comment from Morwenn: there is a proposal for C++17 that makes it really much simpler.  See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf" rel="noreferrer" title="Proposing Standard Library Support for the C++ Detection Idiom, v2">N4502</a> for details, but as a self-contained example consider the following.</p>

<p>This part is the constant part, put it in a header.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// See http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf.</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>...&gt;
<span class="hljs-keyword">using</span> <span class="hljs-type">void_t</span> = <span class="hljs-type">void</span>;

<span class="hljs-comment">// Primary template handles all types not supporting the operation.</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>, <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">class</span>, <span class="hljs-keyword">typename</span> = <span class="hljs-type">void_t</span>&lt;&gt;&gt;
<span class="hljs-keyword">struct</span> detect : std::false_type {};

<span class="hljs-comment">// Specialization recognizes/validates only types supporting the archetype.</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Op</span>&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">detect</span>&lt;T, Op, <span class="hljs-type">void_t</span>&lt;Op&lt;T&gt;&gt;&gt; : std::true_type {};
</code></pre>

<p>then there is the variable part, where you specify what you are looking for (a type, a member type, a function, a member function etc.).  In the case of the OP:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> toString_t = <span class="hljs-keyword">decltype</span>(std::<span class="hljs-built_in">declval</span>&lt;T&gt;().<span class="hljs-built_in">toString</span>());

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> has_toString = detect&lt;T, toString_t&gt;;
</code></pre>

<p>The following example, taken from <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf" rel="noreferrer" title="Proposing Standard Library Support for the C++ Detection Idiom, v2">N4502</a>, shows a more elaborate probe:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// Archetypal expression for assignment operation.</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> <span class="hljs-type">assign_t</span> = <span class="hljs-keyword">decltype</span>(std::<span class="hljs-built_in">declval</span>&lt;T&amp;&gt;() = std::<span class="hljs-built_in">declval</span>&lt;T <span class="hljs-type">const</span> &amp;&gt;())

<span class="hljs-comment">// Trait corresponding to that archetype.</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> is_assignable = detect&lt;T, <span class="hljs-type">assign_t</span>&gt;;
</code></pre>

<p>Compared to the other implementations described above, this one is fairly simple: a reduced set of tools (<code>void_t</code> and <code>detect</code>) suffices, no need for hairy macros.  Besides, it was reported (see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf" rel="noreferrer" title="Proposing Standard Library Support for the C++ Detection Idiom, v2">N4502</a>) that it is measurably more efficient (compile-time and compiler memory consumption) than previous approaches.</p>

<p>Here is a <a href="http://coliru.stacked-crooked.com/a/7eae9c76232a2d20" rel="noreferrer" title="Detection idiom">live example</a>.  It works fine with Clang, but unfortunately, GCC versions before 5.1 followed a different interpretation of the C++11 standard which caused <code>void_t</code> to not work as expected.  Yakk already provided the work-around: use the following definition of <code>void_t</code> (<a href="https://stackoverflow.com/questions/28967003/void-t-in-parameter-list-works-but-not-as-return-type/28967049#28967049">void_t in parameter list works but not as return type</a>):</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">if</span> __GNUC__ &lt; 5 &amp;&amp; ! defined __clang__</span>
<span class="hljs-comment">// https://stackoverflow.com/a/28967049/1353549</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>...&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">voider</span>
{
  <span class="hljs-keyword">using</span> type = <span class="hljs-type">void</span>;
};
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>...Ts&gt;
<span class="hljs-keyword">using</span> <span class="hljs-type">void_t</span> = <span class="hljs-keyword">typename</span> voider&lt;Ts...&gt;::type;
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>...&gt;
<span class="hljs-keyword">using</span> <span class="hljs-type">void_t</span> = <span class="hljs-type">void</span>;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This is what type traits are there for. Unfortunately, they have to be defined manually. In your case, imagine the following:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">response_trait</span> {
    <span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-type">const</span> has_tostring = <span class="hljs-literal">false</span>;
};

<span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">response_trait</span>&lt;your_type_with_tostring&gt; {
    <span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-type">const</span> has_tostring = <span class="hljs-literal">true</span>;
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This is a C++11 solution for the general problem if "If I did X, would it compile?"</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">type_sink</span> { <span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span> type; }; <span class="hljs-comment">// consumes a type, and makes it `void`</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">using</span> <span class="hljs-type">type_sink_t</span> = <span class="hljs-keyword">typename</span> type_sink&lt;T&gt;::type;
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span>=<span class="hljs-type">void</span>&gt; <span class="hljs-keyword">struct</span> has_to_string : std::false_type {}; \
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">has_to_string</span>&lt;
  T,
  <span class="hljs-type">type_sink_t</span>&lt; <span class="hljs-keyword">decltype</span>( std::<span class="hljs-built_in">declval</span>&lt;T&gt;().<span class="hljs-built_in">toString</span>() ) &gt;
&gt;: std::true_type {};
</code></pre>

<p>Trait <code>has_to_string</code> such that <code>has_to_string&lt;T&gt;::value</code> is <code>true</code> if and only if <code>T</code> has a method <code>.toString</code> that can be invoked with 0 arguments in this context.</p>

<p>Next, I'd use tag dispatching:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">namespace</span> details {
  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
  std::string <span class="hljs-title">optionalToString_helper</span><span class="hljs-params">(T* obj, std::true_type <span class="hljs-comment">/*has_to_string*/</span>)</span> </span>{
    <span class="hljs-keyword">return</span> obj-&gt;<span class="hljs-built_in">toString</span>();
  }
  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
  std::string <span class="hljs-title">optionalToString_helper</span><span class="hljs-params">(T* obj, std::false_type <span class="hljs-comment">/*has_to_string*/</span>)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">"toString not defined"</span>;
  }
}
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
std::string <span class="hljs-title">optionalToString</span><span class="hljs-params">(T* obj)</span> </span>{
  <span class="hljs-keyword">return</span> details::<span class="hljs-built_in">optionalToString_helper</span>( obj, has_to_string&lt;T&gt;{} );
}
</code></pre>

<p>which tends to be more maintainable than complex SFINAE expressions.</p>

<p>You can write these traits with a macro if you find yourself doing it alot, but they are relatively simple (a few lines each) so maybe not worth it:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAKE_CODE_TRAIT( TRAIT_NAME, ... ) \
template<span class="hljs-string">&lt;class T, class=void&gt;</span> struct TRAIT_NAME : std::false_type {}; \
template<span class="hljs-string">&lt;class T&gt;</span> struct TRAIT_NAME<span class="hljs-string">&lt; T, type_sink_t&lt; decltype( __VA_ARGS__ ) &gt;</span> &gt;: std::true_type {};</span>
</code></pre>

<p>what the above does is create a macro <code>MAKE_CODE_TRAIT</code>.  You pass it the name of the trait you want, and some code that can test the type <code>T</code>.  Thus:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-built_in">MAKE_CODE_TRAIT</span>( has_to_string, std::<span class="hljs-built_in">declval</span>&lt;T&gt;().<span class="hljs-built_in">toString</span>() )
</code></pre>

<p>creates the above traits class.</p>

<p>As an aside, the above technique is part of what MS calls "expression SFINAE", and their 2013 compiler fails pretty hard.</p>

<p>Note that in C++1y the following syntax is possible:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
std::string <span class="hljs-title">optionalToString</span><span class="hljs-params">(T* obj)</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">compiled_if</span>&lt; has_to_string &gt;(*obj, [&amp;](<span class="hljs-keyword">auto</span>&amp;&amp; obj) {
    <span class="hljs-keyword">return</span> obj.<span class="hljs-built_in">toString</span>();
  }) *<span class="hljs-built_in">compiled_else</span> ([&amp;]{ 
    <span class="hljs-keyword">return</span> <span class="hljs-string">"toString not defined"</span>;
  });
}
</code></pre>

<p>which is an inline compilation conditional branch that abuses lots of C++ features.  Doing so is probably not worth it, as the benefit (of code being inline) is not worth the cost (of next to nobody understanding how it works), but the existence of that above solution may be of interest.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>With C++ 20 you can write the following:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> has_toString = <span class="hljs-built_in">requires</span>(<span class="hljs-type">const</span> T&amp; t) {
    t.<span class="hljs-built_in">toString</span>();
};

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
std::string <span class="hljs-title">optionalToString</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; obj)</span>
</span>{
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(has_toString&lt;T&gt;)</span>
        <span class="hljs-keyword">return</span> obj.<span class="hljs-title">toString</span><span class="hljs-params">()</span></span>;
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"toString not defined"</span>;
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here are some usage snippets:
*The guts for all this are farther down</p>

<p><strong>Check for member <code>x</code> in a given class.  Could be var, func, class, union, or enum:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-built_in">CREATE_MEMBER_CHECK</span>(x);
<span class="hljs-type">bool</span> has_x = has_member_x&lt;class_to_check_for_x&gt;::value;
</code></pre>

<p><strong>Check for member function <code>void x()</code>:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">//Func signature MUST have T as template variable here... simpler this way :\
CREATE_MEMBER_FUNC_SIG_CHECK(x, void (T::*)(), void__x);</span>
<span class="hljs-type">bool</span> has_func_sig_void__x = has_member_func_void__x&lt;class_to_check_for_x&gt;::value;
</code></pre>

<p><strong>Check for member variable <code>x</code>:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-built_in">CREATE_MEMBER_VAR_CHECK</span>(x);
<span class="hljs-type">bool</span> has_var_x = has_member_var_x&lt;class_to_check_for_x&gt;::value;
</code></pre>

<p><strong>Check for member class <code>x</code>:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-built_in">CREATE_MEMBER_CLASS_CHECK</span>(x);
<span class="hljs-type">bool</span> has_class_x = has_member_class_x&lt;class_to_check_for_x&gt;::value;
</code></pre>

<p><strong>Check for member union <code>x</code>:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-built_in">CREATE_MEMBER_UNION_CHECK</span>(x);
<span class="hljs-type">bool</span> has_union_x = has_member_union_x&lt;class_to_check_for_x&gt;::value;
</code></pre>

<p><strong>Check for member enum <code>x</code>:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-built_in">CREATE_MEMBER_ENUM_CHECK</span>(x);
<span class="hljs-type">bool</span> has_enum_x = has_member_enum_x&lt;class_to_check_for_x&gt;::value;
</code></pre>

<p><strong>Check for any member function <code>x</code> regardless of signature:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-built_in">CREATE_MEMBER_CHECK</span>(x);
<span class="hljs-built_in">CREATE_MEMBER_VAR_CHECK</span>(x);
<span class="hljs-built_in">CREATE_MEMBER_CLASS_CHECK</span>(x);
<span class="hljs-built_in">CREATE_MEMBER_UNION_CHECK</span>(x);
<span class="hljs-built_in">CREATE_MEMBER_ENUM_CHECK</span>(x);
<span class="hljs-built_in">CREATE_MEMBER_FUNC_CHECK</span>(x);
<span class="hljs-type">bool</span> has_any_func_x = has_member_func_x&lt;class_to_check_for_x&gt;::value;
</code></pre>

<p>OR</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-built_in">CREATE_MEMBER_CHECKS</span>(x);  <span class="hljs-comment">//Just stamps out the same macro calls as above.</span>
<span class="hljs-type">bool</span> has_any_func_x = has_member_func_x&lt;class_to_check_for_x&gt;::value;
</code></pre>

<p><strong>Details and core:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">/*
    - Multiple inheritance forces ambiguity of member names.
    - SFINAE is used to make aliases to member names.
    - Expression SFINAE is used in just one generic has_member that can accept
      any alias we pass it.
*/</span>

<span class="hljs-comment">//Variadic to force ambiguity of class members.  C++11 and up.</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Args&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ambiguate</span> : <span class="hljs-keyword">public</span> Args... {};

<span class="hljs-comment">//Non-variadic version of the line above.</span>
<span class="hljs-comment">//template &lt;typename A, typename B&gt; struct ambiguate : public A, public B {};</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> A, <span class="hljs-keyword">typename</span> = <span class="hljs-type">void</span>&gt;
<span class="hljs-keyword">struct</span> got_type : std::false_type {};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> A&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">got_type</span>&lt;A&gt; : std::true_type {
    <span class="hljs-keyword">typedef</span> A type;
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">sig_check</span> : std::true_type {};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Alias, <span class="hljs-keyword">typename</span> AmbiguitySeed&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">has_member</span> {
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt; <span class="hljs-type">static</span> <span class="hljs-title">char</span> <span class="hljs-params">((&amp;f(<span class="hljs-keyword">decltype</span>(&amp;C::value))))</span>[1]</span>;
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt; <span class="hljs-type">static</span> <span class="hljs-title">char</span> <span class="hljs-params">((&amp;f(...)))</span>[2]</span>;

    <span class="hljs-comment">//Make sure the member name is consistently spelled the same.</span>
    <span class="hljs-built_in">static_assert</span>(
        (<span class="hljs-built_in">sizeof</span>(<span class="hljs-built_in">f</span>&lt;AmbiguitySeed&gt;(<span class="hljs-number">0</span>)) == <span class="hljs-number">1</span>)
        , <span class="hljs-string">"Member name specified in AmbiguitySeed is different from member name specified in Alias, or wrong Alias/AmbiguitySeed has been specified."</span>
    );

    <span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-type">const</span> value = <span class="hljs-built_in">sizeof</span>(<span class="hljs-built_in">f</span>&lt;Alias&gt;(<span class="hljs-number">0</span>)) == <span class="hljs-number">2</span>;
};
</code></pre>

<p><em><strong>Macros (El Diablo!):</strong></em></p>

<p><strong>CREATE_MEMBER_CHECK:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">//Check for any member with given name, whether var, func, class, union, enum.</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CREATE_MEMBER_CHECK(member)                                         \
                                                                            \
template<span class="hljs-string">&lt;typename T, typename = std::true_type&gt;</span>                             \
struct Alias_##member;                                                      \
                                                                            \
template<span class="hljs-string">&lt;typename T&gt;</span>                                                        \
struct Alias_##member &lt;                                                     \
    T, std::integral_constant<span class="hljs-string">&lt;bool, got_type&lt;decltype(&amp;T::member)&gt;</span>::value&gt;  \
&gt; { static const decltype(&amp;T::member) value; };                             \
                                                                            \
struct AmbiguitySeed_##member { char member; };                             \
                                                                            \
template<span class="hljs-string">&lt;typename T&gt;</span>                                                        \
struct has_member_##member {                                                \
    static const bool value                                                 \
        = has_member&lt;                                                       \
            Alias_##member<span class="hljs-string">&lt;ambiguate&lt;T, AmbiguitySeed_##member&gt;</span>&gt;            \
            , Alias_##member<span class="hljs-string">&lt;AmbiguitySeed_##member&gt;</span>                        \
        &gt;::value                                                            \
    ;                                                                       \
}</span>
</code></pre>

<p><strong>CREATE_MEMBER_VAR_CHECK:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">//Check for member variable with given name.</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CREATE_MEMBER_VAR_CHECK(var_name)                                   \
                                                                            \
template<span class="hljs-string">&lt;typename T, typename = std::true_type&gt;</span>                             \
struct has_member_var_##var_name : std::false_type {};                      \
                                                                            \
template<span class="hljs-string">&lt;typename T&gt;</span>                                                        \
struct has_member_var_##var_name&lt;                                           \
    T                                                                       \
    , std::integral_constant&lt;                                               \
        bool                                                                \
        , !std::is_member_function_pointer<span class="hljs-string">&lt;decltype(&amp;T::var_name)&gt;</span>::value   \
    &gt;                                                                       \
&gt; : std::true_type {}</span>
</code></pre>

<p><strong>CREATE_MEMBER_FUNC_SIG_CHECK:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">//Check for member function with given name AND signature.</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CREATE_MEMBER_FUNC_SIG_CHECK(func_name, func_sig, templ_postfix)    \
                                                                            \
template<span class="hljs-string">&lt;typename T, typename = std::true_type&gt;</span>                             \
struct has_member_func_##templ_postfix : std::false_type {};                \
                                                                            \
template<span class="hljs-string">&lt;typename T&gt;</span>                                                        \
struct has_member_func_##templ_postfix&lt;                                     \
    T, std::integral_constant&lt;                                              \
        bool                                                                \
        , sig_check<span class="hljs-string">&lt;func_sig, &amp;T::func_name&gt;</span>::value                         \
    &gt;                                                                       \
&gt; : std::true_type {}</span>
</code></pre>

<p><strong>CREATE_MEMBER_CLASS_CHECK:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">//Check for member class with given name.</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CREATE_MEMBER_CLASS_CHECK(class_name)               \
                                                            \
template<span class="hljs-string">&lt;typename T, typename = std::true_type&gt;</span>             \
struct has_member_class_##class_name : std::false_type {};  \
                                                            \
template<span class="hljs-string">&lt;typename T&gt;</span>                                        \
struct has_member_class_##class_name&lt;                       \
    T                                                       \
    , std::integral_constant&lt;                               \
        bool                                                \
        , std::is_class&lt;                                    \
            typename got_type<span class="hljs-string">&lt;typename T::class_name&gt;</span>::type \
        &gt;::value                                            \
    &gt;                                                       \
&gt; : std::true_type {}</span>
</code></pre>

<p><strong>CREATE_MEMBER_UNION_CHECK:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">//Check for member union with given name.</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CREATE_MEMBER_UNION_CHECK(union_name)               \
                                                            \
template<span class="hljs-string">&lt;typename T, typename = std::true_type&gt;</span>             \
struct has_member_union_##union_name : std::false_type {};  \
                                                            \
template<span class="hljs-string">&lt;typename T&gt;</span>                                        \
struct has_member_union_##union_name&lt;                       \
    T                                                       \
    , std::integral_constant&lt;                               \
        bool                                                \
        , std::is_union&lt;                                    \
            typename got_type<span class="hljs-string">&lt;typename T::union_name&gt;</span>::type \
        &gt;::value                                            \
    &gt;                                                       \
&gt; : std::true_type {}</span>
</code></pre>

<p><strong>CREATE_MEMBER_ENUM_CHECK:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">//Check for member enum with given name.</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CREATE_MEMBER_ENUM_CHECK(enum_name)                 \
                                                            \
template<span class="hljs-string">&lt;typename T, typename = std::true_type&gt;</span>             \
struct has_member_enum_##enum_name : std::false_type {};    \
                                                            \
template<span class="hljs-string">&lt;typename T&gt;</span>                                        \
struct has_member_enum_##enum_name&lt;                         \
    T                                                       \
    , std::integral_constant&lt;                               \
        bool                                                \
        , std::is_enum&lt;                                     \
            typename got_type<span class="hljs-string">&lt;typename T::enum_name&gt;</span>::type  \
        &gt;::value                                            \
    &gt;                                                       \
&gt; : std::true_type {}</span>
</code></pre>

<p><strong>CREATE_MEMBER_FUNC_CHECK:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">//Check for function with given name, any signature.</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CREATE_MEMBER_FUNC_CHECK(func)          \
template<span class="hljs-string">&lt;typename T&gt;</span>                            \
struct has_member_func_##func {                 \
    static const bool value                     \
        = has_member_##func<span class="hljs-string">&lt;T&gt;</span>::value           \
        &amp;&amp; !has_member_var_##func<span class="hljs-string">&lt;T&gt;</span>::value     \
        &amp;&amp; !has_member_class_##func<span class="hljs-string">&lt;T&gt;</span>::value   \
        &amp;&amp; !has_member_union_##func<span class="hljs-string">&lt;T&gt;</span>::value   \
        &amp;&amp; !has_member_enum_##func<span class="hljs-string">&lt;T&gt;</span>::value    \
    ;                                           \
}</span>
</code></pre>

<p><strong>CREATE_MEMBER_CHECKS:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">//Create all the checks for one member.  Does NOT include func sig checks.</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CREATE_MEMBER_CHECKS(member)    \
CREATE_MEMBER_CHECK(member);            \
CREATE_MEMBER_VAR_CHECK(member);        \
CREATE_MEMBER_CLASS_CHECK(member);      \
CREATE_MEMBER_UNION_CHECK(member);      \
CREATE_MEMBER_ENUM_CHECK(member);       \
CREATE_MEMBER_FUNC_CHECK(member)</span>
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Yet another way to do it in C++17 (inspired by <code>boost:hana</code>).</p>
<p>This solution does not require <code>has_something&lt;T&gt;</code> SFINAE type traits classes.</p>
<h3>Solution</h3>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">////////////////////////////////////////////</span>
<span class="hljs-comment">// has_member implementation</span>
<span class="hljs-comment">////////////////////////////////////////////</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> F&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">has_member_impl</span><span class="hljs-params">(F&amp;&amp; f)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(f(std::declval&lt;T&gt;()), <span class="hljs-literal">true</span>)</span>
</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-title">has_member_impl</span><span class="hljs-params">(...)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; }

<span class="hljs-meta">#<span class="hljs-keyword">define</span> has_member(T, EXPR) \
 has_member_impl<span class="hljs-string">&lt;T&gt;</span>( [](auto&amp;&amp; obj)-&gt;decltype(obj.EXPR){} )</span>

</code></pre>
<h3>Test</h3>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">////////////////////////////////////////////</span>
<span class="hljs-comment">// Test</span>
<span class="hljs-comment">////////////////////////////////////////////</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Example</span> {
    <span class="hljs-type">int</span> Foo;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Bar</span><span class="hljs-params">()</span> </span>{}
    <span class="hljs-function">std::string <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello from Example::toString()!"</span>; }
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Example2</span> {
    <span class="hljs-type">int</span> X;
};

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
std::string <span class="hljs-title">optionalToString</span><span class="hljs-params">(T* obj)</span>
</span>{
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(has_member(T, toString()))</span>
        <span class="hljs-keyword">return</span> obj-&gt;<span class="hljs-title">toString</span><span class="hljs-params">()</span></span>;
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"toString not defined"</span>;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">has_member</span>(Example, Foo), 
                  <span class="hljs-string">"Example class must have Foo member"</span>);
    <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">has_member</span>(Example, <span class="hljs-built_in">Bar</span>()), 
                  <span class="hljs-string">"Example class must have Bar() member function"</span>);
    <span class="hljs-built_in">static_assert</span>(!<span class="hljs-built_in">has_member</span>(Example, ZFoo), 
                  <span class="hljs-string">"Example class must not have ZFoo member."</span>);
    <span class="hljs-built_in">static_assert</span>(!<span class="hljs-built_in">has_member</span>(Example, <span class="hljs-built_in">ZBar</span>()), 
                  <span class="hljs-string">"Example class must not have ZBar() member function"</span>);

    Example e1;
    Example2 e2;

    std::cout &lt;&lt; <span class="hljs-string">"e1: "</span> &lt;&lt; <span class="hljs-built_in">optionalToString</span>(&amp;e1) &lt;&lt; <span class="hljs-string">"\n"</span>;
    std::cout &lt;&lt; <span class="hljs-string">"e1: "</span> &lt;&lt; <span class="hljs-built_in">optionalToString</span>(&amp;e2) &lt;&lt; <span class="hljs-string">"\n"</span>;
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I wrote an answer to this in another thread that (unlike the solutions above) also checks inherited member functions:</p>

<p><a href="https://stackoverflow.com/questions/1966362/sfinae-to-check-for-inherited-member-functions/8752988#8752988">SFINAE to check for inherited member functions</a></p>

<p>Here are some example from that solution:</p>

<h2>Example1:</h2>

<p>We are checking for a member with the following signature: 
<code>T::const_iterator begin() const</code></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">has_const_begin</span>
{
    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">char</span> <span class="hljs-params">(&amp;Yes)</span>[1]</span>;
    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">char</span> <span class="hljs-params">(&amp;No)</span>[2]</span>;

    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> U&gt; 
    <span class="hljs-type">static</span> Yes <span class="hljs-title">test</span><span class="hljs-params">(U <span class="hljs-type">const</span> * data, 
                    <span class="hljs-keyword">typename</span> std::enable_if&lt;std::is_same&lt;
                             <span class="hljs-keyword">typename</span> U::const_iterator, 
                             <span class="hljs-keyword">decltype</span>(data-&gt;begin())
                    &gt;::value&gt;::type * = <span class="hljs-number">0</span>)</span></span>;
    <span class="hljs-function"><span class="hljs-type">static</span> No <span class="hljs-title">test</span><span class="hljs-params">(...)</span></span>;
    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">bool</span> value = <span class="hljs-built_in">sizeof</span>(Yes) == <span class="hljs-built_in">sizeof</span>(has_const_begin::<span class="hljs-built_in">test</span>((<span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::type*)<span class="hljs-number">0</span>));
};
</code></pre>

<p>Please notice that it even checks the constness of the method, and works with primitive types, as well. (I mean <code>has_const_begin&lt;int&gt;::value</code> is false and doesn't cause a compile-time error.) </p>

<h2>Example 2</h2>

<p>Now we are looking for the signature: <code>void foo(MyClass&amp;, unsigned)</code></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">has_foo</span>
{
    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">char</span> <span class="hljs-params">(&amp;Yes)</span>[1]</span>;
    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">char</span> <span class="hljs-params">(&amp;No)</span>[2]</span>;

    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> U&gt;
    <span class="hljs-type">static</span> Yes <span class="hljs-title">test</span><span class="hljs-params">(U * data, MyClass* arg1 = <span class="hljs-number">0</span>,
                    <span class="hljs-keyword">typename</span> std::enable_if&lt;std::is_void&lt;
                             <span class="hljs-keyword">decltype</span>(data-&gt;foo(*arg1, <span class="hljs-number">1u</span>))
                    &gt;::value&gt;::type * = <span class="hljs-number">0</span>)</span></span>;
    <span class="hljs-function"><span class="hljs-type">static</span> No <span class="hljs-title">test</span><span class="hljs-params">(...)</span></span>;
    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">bool</span> value = <span class="hljs-built_in">sizeof</span>(Yes) == <span class="hljs-built_in">sizeof</span>(has_foo::<span class="hljs-built_in">test</span>((<span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::type*)<span class="hljs-number">0</span>));
};
</code></pre>

<p>Please notice that MyClass doesn't has to be default constructible or to satisfy any special concept. The technique works with template members, as well.</p>

<p>I am eagerly waiting opinions regarding this.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is the most concise way I found in C++20, which is very close from your question:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
std::string <span class="hljs-title">optionalToString</span><span class="hljs-params">(T* obj)</span>
</span>{
  <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-keyword">requires</span> { obj-&gt;toString(); })</span>
    <span class="hljs-keyword">return</span> obj-&gt;<span class="hljs-title">toString</span><span class="hljs-params">()</span></span>;
  <span class="hljs-keyword">else</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">"toString not defined"</span>;
}
</code></pre>
<p>See it live on godbolt: <a href="https://gcc.godbolt.org/z/5jb1d93Ms" rel="noreferrer">https://gcc.godbolt.org/z/5jb1d93Ms</a></p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The standard C++ solution presented here by litb will not work as expected if the method happens to be defined in a base class. </p>

<p>For a solution that handles this situation refer to :</p>

<p>In Russian :
<a href="http://www.rsdn.ru/forum/message/2759773.1.aspx" rel="noreferrer">http://www.rsdn.ru/forum/message/2759773.1.aspx</a> </p>

<p>English Translation by Roman.Perepelitsa : 
<a href="http://groups.google.com/group/comp.lang.c++.moderated/tree/browse_frm/thread/4f7c7a96f9afbe44/c95a7b4c645e449f?pli=1" rel="noreferrer">http://groups.google.com/group/comp.lang.c++.moderated/tree/browse_frm/thread/4f7c7a96f9afbe44/c95a7b4c645e449f?pli=1</a> </p>

<p>It is insanely clever. However one issue with this solutiion is that gives compiler errors if the type being tested is one that cannot be used as a base class (e.g. primitive types)</p>

<p>In Visual Studio, I noticed that if working with method having no arguments, an extra pair of redundant ( )  needs to be inserted around the argments to deduce( )  in the sizeof expression.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Now this was a <em>nice</em> little puzzle - great question!</p>

<p>Here's an alternative to <a href="https://stackoverflow.com/questions/257288/possible-for-c-template-to-check-for-a-functions-existence#257382">Nicola Bonelli's solution</a> that does not rely on the non-standard <code>typeof</code> operator.</p>

<p>Unfortunately, it does not work on GCC (MinGW) 3.4.5 or Digital Mars 8.42n, but it does work on all versions of MSVC (including VC6) and on Comeau C++.</p>

<p>The longer comment block has the details on how it works (or is supposed to work).  As it says, I'm not sure which behavior is standards compliant - I'd welcome commentary on that.</p>

<hr>

<p>update - 7 Nov 2008:</p>

<p>It looks like while this code is syntactically correct, the behavior that MSVC and Comeau C++ show does not follow the standard (thanks to <a href="https://stackoverflow.com/users/4727/leon-timmermans">Leon Timmermans</a> and <a href="https://stackoverflow.com/users/34509/litb">litb</a> for pointing me in the right direction).  The C++03 standard says the following:</p>

<blockquote>
  <p>14.6.2 Dependent names [temp.dep]</p>
  
  <p>Paragraph 3</p>
  
  <p>In the definition of a class template
  or a member of a class template, if a
  base class of the class template
  depends on a template-parameter, the
  base class scope is not examined
  during unqualified name lookup either
  at the point of definition of the
  class template or member or during an
  instantiation of the class template or
  member.</p>
</blockquote>

<p>So, it looks like that when MSVC or Comeau consider the <code>toString()</code> member function of <code>T</code> performing name lookup at the call site in <code>doToString()</code> when the template is instantiated, that is incorrect (even though it's actually the behavior I was looking for in this case).</p>

<p>The behavior of GCC and Digital Mars looks to be correct - in both cases the non-member <code>toString()</code> function is bound to the call.</p>

<p>Rats - I thought I might have found a clever solution, instead I uncovered a couple compiler bugs...</p>

<hr>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Hello</span>
{
    <span class="hljs-function">std::string <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello"</span>;
    }
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Generic</span> {};


<span class="hljs-comment">// the following namespace keeps the toString() method out of</span>
<span class="hljs-comment">//  most everything - except the other stuff in this</span>
<span class="hljs-comment">//  compilation unit</span>

<span class="hljs-keyword">namespace</span> {
    <span class="hljs-function">std::string <span class="hljs-title">toString</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"toString not defined"</span>;
    }

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">optionalToStringImpl</span> : <span class="hljs-keyword">public</span> T
    {
    <span class="hljs-keyword">public</span>:
        <span class="hljs-function">std::string <span class="hljs-title">doToString</span><span class="hljs-params">()</span> </span>{

            <span class="hljs-comment">// in theory, the name lookup for this call to </span>
            <span class="hljs-comment">//  toString() should find the toString() in </span>
            <span class="hljs-comment">//  the base class T if one exists, but if one </span>
            <span class="hljs-comment">//  doesn't exist in the base class, it'll </span>
            <span class="hljs-comment">//  find the free toString() function in </span>
            <span class="hljs-comment">//  the private namespace.</span>
            <span class="hljs-comment">//</span>
            <span class="hljs-comment">// This theory works for MSVC (all versions</span>
            <span class="hljs-comment">//  from VC6 to VC9) and Comeau C++, but</span>
            <span class="hljs-comment">//  does not work with MinGW 3.4.5 or </span>
            <span class="hljs-comment">//  Digital Mars 8.42n</span>
            <span class="hljs-comment">//</span>
            <span class="hljs-comment">// I'm honestly not sure what the standard says </span>
            <span class="hljs-comment">//  is the correct behavior here - it's sort </span>
            <span class="hljs-comment">//  of like ADL (Argument Dependent Lookup - </span>
            <span class="hljs-comment">//  also known as Koenig Lookup) but without</span>
            <span class="hljs-comment">//  arguments (except the implied "this" pointer)</span>

            <span class="hljs-keyword">return</span> <span class="hljs-built_in">toString</span>();
        }
    };
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function">std::string <span class="hljs-title">optionalToString</span><span class="hljs-params">(T &amp; obj)</span>
</span>{
    <span class="hljs-comment">// ugly, hacky cast...</span>
    optionalToStringImpl&lt;T&gt;* temp = <span class="hljs-keyword">reinterpret_cast</span>&lt;optionalToStringImpl&lt;T&gt;*&gt;( &amp;obj);

    <span class="hljs-keyword">return</span> temp-&gt;<span class="hljs-built_in">doToString</span>();
}



<span class="hljs-function"><span class="hljs-type">int</span>
<span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>
</span>{
    Hello helloObj;
    Generic genericObj;

    std::cout &lt;&lt; <span class="hljs-built_in">optionalToString</span>( helloObj) &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-built_in">optionalToString</span>( genericObj) &lt;&lt; std::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>An example using SFINAE and template partial specialization, by writing a <code>Has_foo</code> concept check: </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>{};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span>{ <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span>{<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span>{<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">E</span>: <span class="hljs-keyword">public</span> B{};

<span class="hljs-comment">// available in C++17 onwards as part of &lt;type_traits&gt;</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>...&gt;
<span class="hljs-keyword">using</span> <span class="hljs-type">void_t</span> = <span class="hljs-type">void</span>;

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> = <span class="hljs-type">void</span>&gt; <span class="hljs-keyword">struct</span> Has_foo: std::false_type{};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; 
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Has_foo</span>&lt;T, <span class="hljs-type">void_t</span>&lt;
    std::<span class="hljs-type">enable_if_t</span>&lt;
        std::is_same&lt;
            <span class="hljs-type">int</span>, 
            <span class="hljs-keyword">decltype</span>(std::<span class="hljs-built_in">declval</span>&lt;T&gt;().<span class="hljs-built_in">foo</span>((<span class="hljs-type">int</span>)<span class="hljs-number">0</span>, (<span class="hljs-type">int</span>)<span class="hljs-number">0</span>))
        &gt;::value
    &gt;
&gt;&gt;: std::true_type{};


<span class="hljs-built_in">static_assert</span>(<span class="hljs-keyword">not</span> Has_foo&lt;A&gt;::value, <span class="hljs-string">"A does not have a foo"</span>);
<span class="hljs-built_in">static_assert</span>(Has_foo&lt;B&gt;::value, <span class="hljs-string">"B has a foo"</span>);
<span class="hljs-built_in">static_assert</span>(<span class="hljs-keyword">not</span> Has_foo&lt;C&gt;::value, <span class="hljs-string">"C has a foo with the wrong return. "</span>);
<span class="hljs-built_in">static_assert</span>(<span class="hljs-keyword">not</span> Has_foo&lt;D&gt;::value, <span class="hljs-string">"D has a foo with the wrong arguments. "</span>);
<span class="hljs-built_in">static_assert</span>(Has_foo&lt;E&gt;::value, <span class="hljs-string">"E has a foo since it inherits from B"</span>);
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 18</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>MSVC has the __if_exists and __if_not_exists keywords (<a href="http://msdn.microsoft.com/en-us/library/x7wy9xh3(VS.80).aspx" rel="noreferrer">Doc</a>). Together with the typeof-SFINAE approach of Nicola I could create a check for GCC and MSVC like the OP looked for.</p>

<p><strong>Update:</strong> Source can be found <a href="https://github.com/nob13/sfserialization/blob/master/sfserialization/isdefault.h" rel="noreferrer">Here</a></p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 19</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I modified the solution provided in <a href="https://stackoverflow.com/a/264088/2712152">https://stackoverflow.com/a/264088/2712152</a> to make it a bit more general. Also since it doesn't use any of the new C++11 features we can use it with old compilers and should also work with msvc. But the compilers should enable C99 to use this since it uses variadic macros.</p>

<p>The following macro can be used to check if a particular class has a particular typedef or not.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">/** 
 * @class      : HAS_TYPEDEF
 * @brief      : This macro will be used to check if a class has a particular
 * typedef or not.
 * @param typedef_name : Name of Typedef
 * @param name  : Name of struct which is going to be run the test for
 * the given particular typedef specified in typedef_name
 */</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> HAS_TYPEDEF(typedef_name, name)                           \
   template <span class="hljs-string">&lt;typename T&gt;</span>                                          \
   struct name {                                                  \
      typedef char yes[1];                                        \
      typedef char no[2];                                         \
      template <span class="hljs-string">&lt;typename U&gt;</span>                                       \
      struct type_check;                                          \
      template <span class="hljs-string">&lt;typename _1&gt;</span>                                      \
      static yes&amp; chk(type_check<span class="hljs-string">&lt;typename _1::typedef_name&gt;</span>*);    \
      template <span class="hljs-string">&lt;typename&gt;</span>                                         \
      static no&amp; chk(...);                                        \
      static bool const value = sizeof(chk<span class="hljs-string">&lt;T&gt;</span>(0)) == sizeof(yes); \
   }</span>
</code></pre>

<p>The following macro can be used to check if a particular class has a particular member function or not with any given number of arguments.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">/** 
 * @class      : HAS_MEM_FUNC
 * @brief      : This macro will be used to check if a class has a particular
 * member function implemented in the public section or not. 
 * @param func : Name of Member Function
 * @param name : Name of struct which is going to be run the test for
 * the given particular member function name specified in func
 * @param return_type: Return type of the member function
 * @param ellipsis(...) : Since this is macro should provide test case for every
 * possible member function we use variadic macros to cover all possibilities
 */</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> HAS_MEM_FUNC(func, name, return_type, ...)                \
   template <span class="hljs-string">&lt;typename T&gt;</span>                                          \
   struct name {                                                  \
      typedef return_type (T::*Sign)(__VA_ARGS__);                \
      typedef char yes[1];                                        \
      typedef char no[2];                                         \
      template <span class="hljs-string">&lt;typename U, U&gt;</span>                                    \
      struct type_check;                                          \
      template <span class="hljs-string">&lt;typename _1&gt;</span>                                      \
      static yes&amp; chk(type_check<span class="hljs-string">&lt;Sign, &amp;_1::func&gt;</span>*);              \
      template <span class="hljs-string">&lt;typename&gt;</span>                                         \
      static no&amp; chk(...);                                        \
      static bool const value = sizeof(chk<span class="hljs-string">&lt;T&gt;</span>(0)) == sizeof(yes); \
   }</span>
</code></pre>

<p>We can use the above 2 macros to perform the checks for has_typedef and has_mem_func as:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> check;
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check_function</span><span class="hljs-params">()</span> </span>{}
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> {
<span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">double</span> b)</span> </span>{}
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>{}
};

<span class="hljs-built_in">HAS_MEM_FUNC</span>(check_function, has_check_function, <span class="hljs-type">void</span>, <span class="hljs-type">void</span>);
<span class="hljs-built_in">HAS_MEM_FUNC</span>(hello, hello_check, <span class="hljs-type">void</span>, <span class="hljs-type">int</span>, <span class="hljs-type">double</span>);
<span class="hljs-built_in">HAS_MEM_FUNC</span>(hello, hello_void_check, <span class="hljs-type">void</span>, <span class="hljs-type">void</span>);
<span class="hljs-built_in">HAS_TYPEDEF</span>(check, has_typedef_check);

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  std::cout &lt;&lt; <span class="hljs-string">"Check Function A:"</span> &lt;&lt; has_check_function&lt;A&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; <span class="hljs-string">"Check Function B:"</span> &lt;&lt; has_check_function&lt;B&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; <span class="hljs-string">"Hello Function A:"</span> &lt;&lt; hello_check&lt;A&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; <span class="hljs-string">"Hello Function B:"</span> &lt;&lt; hello_check&lt;B&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; <span class="hljs-string">"Hello void Function A:"</span> &lt;&lt; hello_void_check&lt;A&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; <span class="hljs-string">"Hello void Function B:"</span> &lt;&lt; hello_void_check&lt;B&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; <span class="hljs-string">"Check Typedef A:"</span> &lt;&lt; has_typedef_check&lt;A&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; <span class="hljs-string">"Check Typedef B:"</span> &lt;&lt; has_typedef_check&lt;B&gt;::value &lt;&lt; std::endl;
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 20</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Strange nobody suggested the following nice trick I saw once on this very site :</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">has_foo</span>
{
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span> { <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(...)</span></span>; };
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">derived</span> : S, T {};

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> V, V&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">W</span> {};

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X&gt;
    <span class="hljs-built_in">char</span> (&amp;<span class="hljs-built_in">test</span>(W&lt;<span class="hljs-built_in">void</span> (X::*)(), &amp;X::foo&gt; *))[<span class="hljs-number">1</span>];

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>&gt;
    <span class="hljs-built_in">char</span> (&amp;<span class="hljs-built_in">test</span>(...))[<span class="hljs-number">2</span>];

    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">bool</span> value = <span class="hljs-built_in">sizeof</span>(<span class="hljs-built_in">test</span>&lt;derived&gt;(<span class="hljs-number">0</span>)) == <span class="hljs-number">1</span>;
};
</code></pre>

<p>You have to make sure T is a class. It seems that ambiguity in the lookup of foo is a substitution failure. I made it work on gcc, not sure if it is standard though.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 21</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The generic template that can be used for checking if some "feature" is supported by the type:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeChecker</span>, <span class="hljs-keyword">typename</span> Type&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_supported</span>
{
    <span class="hljs-comment">// these structs are used to recognize which version</span>
    <span class="hljs-comment">// of the two functions was chosen during overload resolution</span>
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">supported</span> {};
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">not_supported</span> {};

    <span class="hljs-comment">// this overload of chk will be ignored by SFINAE principle</span>
    <span class="hljs-comment">// if TypeChecker&lt;Type_&gt; is invalid type</span>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type_&gt;
    <span class="hljs-function"><span class="hljs-type">static</span> supported <span class="hljs-title">chk</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> std::decay&lt;TypeChecker&lt;Type_&gt;&gt;::type *)</span></span>;

    <span class="hljs-comment">// ellipsis has the lowest conversion rank, so this overload will be</span>
    <span class="hljs-comment">// chosen during overload resolution only if the template overload above is ignored</span>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type_&gt;
    <span class="hljs-function"><span class="hljs-type">static</span> not_supported <span class="hljs-title">chk</span><span class="hljs-params">(...)</span></span>;

    <span class="hljs-comment">// if the template overload of chk is chosen during</span>
    <span class="hljs-comment">// overload resolution then the feature is supported</span>
    <span class="hljs-comment">// if the ellipses overload is chosen the the feature is not supported</span>
    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> value = std::is_same&lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">chk</span>&lt;Type&gt;(<span class="hljs-literal">nullptr</span>)),supported&gt;::value;
};
</code></pre>

<p>The template that checks whether there is a method <code>foo</code> that is compatible with signature <code>double(const char*)</code></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// if T doesn't have foo method with the signature that allows to compile the bellow</span>
<span class="hljs-comment">// expression then instantiating this template is Substitution Failure (SF)</span>
<span class="hljs-comment">// which Is Not An Error (INAE) if this happens during overload resolution</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> has_foo = <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">double</span>(std::<span class="hljs-built_in">declval</span>&lt;T&gt;().<span class="hljs-built_in">foo</span>(std::<span class="hljs-built_in">declval</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;())));
</code></pre>

<p>Examples</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// types that support has_foo</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct1</span> { <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span></span>; };            <span class="hljs-comment">// exact signature match</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct2</span> { <span class="hljs-function"><span class="hljs-type">int</span>    <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;str)</span></span>; }; <span class="hljs-comment">// compatible signature</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct3</span> { <span class="hljs-function"><span class="hljs-type">float</span>  <span class="hljs-title">foo</span><span class="hljs-params">(...)</span></span>; };                    <span class="hljs-comment">// compatible ellipsis signature</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct4</span> { <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
                 <span class="hljs-function"><span class="hljs-type">int</span>    <span class="hljs-title">foo</span><span class="hljs-params">(T t)</span></span>; };                    <span class="hljs-comment">// compatible template signature</span>

<span class="hljs-comment">// types that do not support has_foo</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct5</span> { <span class="hljs-function"><span class="hljs-type">void</span>        <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span></span>; }; <span class="hljs-comment">// returns void</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct6</span> { <span class="hljs-function">std::string <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span></span>; }; <span class="hljs-comment">// std::string can't be converted to double</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct7</span> { <span class="hljs-function"><span class="hljs-type">double</span>      <span class="hljs-title">foo</span><span class="hljs-params">(      <span class="hljs-type">int</span> *)</span></span>; }; <span class="hljs-comment">// const char* can't be converted to int*</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct8</span> { <span class="hljs-function"><span class="hljs-type">double</span>      <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span></span>; }; <span class="hljs-comment">// there is no foo method</span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    std::cout &lt;&lt; std::boolalpha;

    std::cout &lt;&lt; is_supported&lt;has_foo, <span class="hljs-type">int</span>    &gt;::value &lt;&lt; std::endl; <span class="hljs-comment">// false</span>
    std::cout &lt;&lt; is_supported&lt;has_foo, <span class="hljs-type">double</span> &gt;::value &lt;&lt; std::endl; <span class="hljs-comment">// false</span>

    std::cout &lt;&lt; is_supported&lt;has_foo, struct1&gt;::value &lt;&lt; std::endl; <span class="hljs-comment">// true</span>
    std::cout &lt;&lt; is_supported&lt;has_foo, struct2&gt;::value &lt;&lt; std::endl; <span class="hljs-comment">// true</span>
    std::cout &lt;&lt; is_supported&lt;has_foo, struct3&gt;::value &lt;&lt; std::endl; <span class="hljs-comment">// true</span>
    std::cout &lt;&lt; is_supported&lt;has_foo, struct4&gt;::value &lt;&lt; std::endl; <span class="hljs-comment">// true</span>

    std::cout &lt;&lt; is_supported&lt;has_foo, struct5&gt;::value &lt;&lt; std::endl; <span class="hljs-comment">// false</span>
    std::cout &lt;&lt; is_supported&lt;has_foo, struct6&gt;::value &lt;&lt; std::endl; <span class="hljs-comment">// false</span>
    std::cout &lt;&lt; is_supported&lt;has_foo, struct7&gt;::value &lt;&lt; std::endl; <span class="hljs-comment">// false</span>
    std::cout &lt;&lt; is_supported&lt;has_foo, struct8&gt;::value &lt;&lt; std::endl; <span class="hljs-comment">// false</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p><a href="http://coliru.stacked-crooked.com/a/83c6a631ed42cea4" rel="nofollow">http://coliru.stacked-crooked.com/a/83c6a631ed42cea4</a></p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 22</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I know that this question is years old, but I think it would useful for people like me to have a more complete updated answer that also works for <code>const</code> overloaded methods such as <code>std::vector&lt;&gt;::begin</code>.</p>
<p>Based on that <a href="https://stackoverflow.com/a/257382/4602726">answer</a> and that <a href="https://stackoverflow.com/a/63818399/4602726">answer</a> from my follow up question, here's a more complete answer. Note that this will only work with C++11 and higher.</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">EmptyClass</span>{};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">has_begin</span>
{
    <span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">has_begin</span>() = <span class="hljs-keyword">delete</span>;
    
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">one</span> { <span class="hljs-type">char</span> x[<span class="hljs-number">1</span>]; };
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">two</span> { <span class="hljs-type">char</span> x[<span class="hljs-number">2</span>]; };

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> C&gt; <span class="hljs-function"><span class="hljs-type">static</span> one <span class="hljs-title">test</span><span class="hljs-params">( <span class="hljs-keyword">decltype</span>(<span class="hljs-type">void</span>(std::declval&lt;C &amp;&gt;().begin())) * )</span> </span>;
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> C&gt; <span class="hljs-function"><span class="hljs-type">static</span> two <span class="hljs-title">test</span><span class="hljs-params">(...)</span></span>;    

<span class="hljs-keyword">public</span>:
    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> value = <span class="hljs-built_in">sizeof</span>(<span class="hljs-built_in">test</span>&lt;T&gt;(<span class="hljs-number">0</span>)) == <span class="hljs-built_in">sizeof</span>(one);
};
    
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>
</span>{
    std::cout &lt;&lt; std::boolalpha;
    std::cout &lt;&lt; <span class="hljs-string">"vector&lt;int&gt;::begin() exists: "</span> &lt;&lt; has_begin&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;::value &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-string">"EmptyClass::begin() exists: "</span> &lt;&lt; has_begin&lt;EmptyClass&gt;::value &lt;&lt; std::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>Or the shorter version:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">EmptyClass</span>{};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> = <span class="hljs-type">void</span>&gt;
<span class="hljs-keyword">struct</span> has_begin : std::false_type {};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">has_begin</span>&lt;T, <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">void</span>(std::<span class="hljs-built_in">declval</span>&lt;T &amp;&gt;().<span class="hljs-built_in">begin</span>()))&gt; : std::true_type {};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>
</span>{
    std::cout &lt;&lt; std::boolalpha;
    std::cout &lt;&lt; <span class="hljs-string">"vector&lt;int&gt;::begin() exists: "</span> &lt;&lt; has_begin&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;::value &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-string">"EmptyClass exists: "</span> &lt;&lt; has_begin&lt;EmptyClass&gt;::value &lt;&lt; std::endl;
}
</code></pre>
<p>Note that here a complete sample call must be provided. This means that if we tested for the <code>resize</code> method's existence then we would have put <code>resize(0)</code>.</p>
<p><strong>Deep magic explanation</strong>:</p>
<p>The first answer posted of this question used <code>test( decltype(&amp;C::helloworld) )</code>; however this is problematic when the method it is testing is ambiguous due const overloading, thus making the substitution attempt fail.</p>
<p>To solve this ambiguity we use a void statement which can take any parameters because it is always translated into a <code>noop</code> and thus the ambiguity is nullified and the call is valid as long as the method exists:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">has_begin&lt;T, <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">void</span>(std::<span class="hljs-built_in">declval</span>&lt;T &amp;&gt;().<span class="hljs-built_in">begin</span>()))&gt;
</code></pre>
<p>Here's what's happening in order:
We use <code>std::declval&lt;T &amp;&gt;()</code> to create a callable value for which <code>begin</code> can then be called. After that the value of <code>begin</code> is passed as a parameter to a void statement. We then retrieve the type of that void expression using the builtin <code>decltype</code> so that it can be used as a template type argument. If <code>begin</code> doesn't exist then the substitution is invalid and as per SFINAE the other declaration is used instead.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 23</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>How about this solution?</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U, <span class="hljs-keyword">typename</span> = <span class="hljs-type">void</span>&gt; <span class="hljs-keyword">struct</span> hasToString : std::false_type { };

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">hasToString</span>&lt;U,
  <span class="hljs-keyword">typename</span> std::enable_if&lt;<span class="hljs-built_in">bool</span>(<span class="hljs-built_in">sizeof</span>(&amp;U::toString))&gt;::type
&gt; : std::true_type { };
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 24</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There are a lot of answers here, but I failed, to find a version, that performs <em>real</em> method resolution ordering, while not using any of the newer c++ features (only using c++98 features).<br>
Note: This version is tested and working with vc++2013, g++ 5.2.0 and the onlline compiler.<br></p>

<p>So I came up with a version, that only uses sizeof():</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; T <span class="hljs-title">declval</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">fake_void</span> { };
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; T &amp;<span class="hljs-keyword">operator</span>,(T &amp;,fake_void);
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; T <span class="hljs-type">const</span> &amp;<span class="hljs-keyword">operator</span>,(T <span class="hljs-type">const</span> &amp;,fake_void);
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; T <span class="hljs-keyword">volatile</span> &amp;<span class="hljs-keyword">operator</span>,(T <span class="hljs-keyword">volatile</span> &amp;,fake_void);
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; T <span class="hljs-type">const</span> <span class="hljs-keyword">volatile</span> &amp;<span class="hljs-keyword">operator</span>,(T <span class="hljs-type">const</span> <span class="hljs-keyword">volatile</span> &amp;,fake_void);

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">yes</span> { <span class="hljs-type">char</span> v[<span class="hljs-number">1</span>]; };
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">no</span>  { <span class="hljs-type">char</span> v[<span class="hljs-number">2</span>]; };
<span class="hljs-keyword">template</span>&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">yes_no</span>:yes{};
<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">yes_no</span>&lt;<span class="hljs-literal">false</span>&gt;:no{};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">has_awesome_member</span> {
 <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt; <span class="hljs-type">static</span> yes_no&lt;(<span class="hljs-built_in">sizeof</span>((
   <span class="hljs-built_in">declval</span>&lt;U&gt;().<span class="hljs-built_in">awesome_member</span>(),<span class="hljs-built_in">fake_void</span>()
  ))!=<span class="hljs-number">0</span>)&gt; <span class="hljs-built_in">check</span>(<span class="hljs-type">int</span>);
 <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-type">static</span> no <span class="hljs-title">check</span><span class="hljs-params">(...)</span></span>;
 <span class="hljs-keyword">enum</span>{value=<span class="hljs-built_in">sizeof</span>(<span class="hljs-built_in">check</span>&lt;T&gt;(<span class="hljs-number">0</span>)) == <span class="hljs-built_in">sizeof</span>(yes)};
};


<span class="hljs-keyword">struct</span> <span class="hljs-title class_">foo</span> { <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">awesome_member</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>; };
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">bar</span> { };
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">foo_void</span> { <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">awesome_member</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>; };
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">wrong_params</span> { <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">awesome_member</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>; };

<span class="hljs-built_in">static_assert</span>(has_awesome_member&lt;foo&gt;::value,<span class="hljs-string">""</span>);
<span class="hljs-built_in">static_assert</span>(!has_awesome_member&lt;bar&gt;::value,<span class="hljs-string">""</span>);
<span class="hljs-built_in">static_assert</span>(has_awesome_member&lt;foo_void&gt;::value,<span class="hljs-string">""</span>);
<span class="hljs-built_in">static_assert</span>(!has_awesome_member&lt;wrong_params&gt;::value,<span class="hljs-string">""</span>);
</code></pre>

<p>Live demo (with extended return type checking and vc++2010 workaround): <a href="http://cpp.sh/5b2vs" rel="nofollow noreferrer">http://cpp.sh/5b2vs</a></p>

<p>No source, as I came up with it myself.</p>

<p>When running the Live demo on the g++ compiler, please note that array sizes of 0 are allowed, meaning that the static_assert used will not trigger a compiler error, even when it fails.<br>
A commonly used work-around is to replace the 'typedef' in the macro with 'extern'.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 25</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>My take: to universally determine if something is callable without making verbose type traits for each and every one, or using experimental features, or long code:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Callable, <span class="hljs-keyword">typename</span>... Args, <span class="hljs-keyword">typename</span> = <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">declval</span>&lt;Callable&gt;()(<span class="hljs-built_in">declval</span>&lt;Args&gt;()...))&gt;
std::true_type <span class="hljs-built_in">isCallableImpl</span>(Callable, Args...) { <span class="hljs-keyword">return</span> {}; }

<span class="hljs-function">std::false_type <span class="hljs-title">isCallableImpl</span><span class="hljs-params">(...)</span> </span>{ <span class="hljs-keyword">return</span> {}; }

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args, <span class="hljs-keyword">typename</span> Callable&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-title">isCallable</span><span class="hljs-params">(Callable callable)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">isCallableImpl</span>(callable, <span class="hljs-built_in">declval</span>&lt;Args&gt;()...)){};
}
</code></pre>
<p>Usage:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> TO_STRING_TEST = [](<span class="hljs-keyword">auto</span> in) -&gt; <span class="hljs-keyword">decltype</span>(in.<span class="hljs-built_in">toString</span>()) { <span class="hljs-keyword">return</span> {}; };
<span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> TO_STRING_WORKS = <span class="hljs-built_in">isCallable</span>&lt;T&gt;(TO_STRING_TEST);
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 26</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is my version that handles all possible member function overloads with arbitrary arity, including template member functions, possibly with default arguments. It distinguishes 3 mutually exclusive scenarios when making a member function call to some class type, with given arg types: (1) valid, or (2) ambiguous, or (3) non-viable. Example usage:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>

<span class="hljs-built_in">HAS_MEM</span>(bar)
<span class="hljs-built_in">HAS_MEM_FUN_CALL</span>(bar)

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">test</span>
{
   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;
   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;
   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">double</span>)</span></span>;

   <span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">typename</span> T &gt;
   <span class="hljs-keyword">typename</span> std::enable_if&lt; <span class="hljs-keyword">not</span> std::is_integral&lt;T&gt;::value &gt;::<span class="hljs-function">type
   <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp;, <span class="hljs-type">int</span>=<span class="hljs-number">0</span>)</span></span>{}

   <span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">typename</span> T &gt;
   <span class="hljs-keyword">typename</span> std::enable_if&lt; std::is_integral&lt;T&gt;::value &gt;::<span class="hljs-function">type
   <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;T&gt;&amp;, T*)</span></span>{}

   <span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">typename</span> T &gt;
   <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp;, <span class="hljs-type">int</span>)</span></span>{}
};
</code></pre>

<p>Now you can use it like this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * argv[])</span>
</span>{
   <span class="hljs-built_in">static_assert</span>( has_mem_bar&lt;test&gt;::value , <span class="hljs-string">""</span>);

   <span class="hljs-built_in">static_assert</span>( has_valid_mem_fun_call_bar&lt;<span class="hljs-built_in">test</span>(<span class="hljs-type">char</span> <span class="hljs-type">const</span>*,<span class="hljs-type">long</span>)&gt;::value , <span class="hljs-string">""</span>);
   <span class="hljs-built_in">static_assert</span>( has_valid_mem_fun_call_bar&lt;<span class="hljs-built_in">test</span>(std::string&amp;,<span class="hljs-type">long</span>)&gt;::value , <span class="hljs-string">""</span>);

   <span class="hljs-built_in">static_assert</span>( has_valid_mem_fun_call_bar&lt;<span class="hljs-built_in">test</span>(std::vector&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-type">int</span>*)&gt;::value , <span class="hljs-string">""</span>);
   <span class="hljs-built_in">static_assert</span>( has_no_viable_mem_fun_call_bar&lt;<span class="hljs-built_in">test</span>(std::vector&lt;<span class="hljs-type">double</span>&gt;, <span class="hljs-type">double</span>*)&gt;::value , <span class="hljs-string">""</span>);

   <span class="hljs-built_in">static_assert</span>( has_valid_mem_fun_call_bar&lt;<span class="hljs-built_in">test</span>(<span class="hljs-type">int</span>)&gt;::value , <span class="hljs-string">""</span>);
   <span class="hljs-built_in">static_assert</span>( std::is_same&lt;<span class="hljs-type">void</span>,result_of_mem_fun_call_bar&lt;<span class="hljs-built_in">test</span>(<span class="hljs-type">int</span>)&gt;::type&gt;::value , <span class="hljs-string">""</span>);

   <span class="hljs-built_in">static_assert</span>( has_valid_mem_fun_call_bar&lt;<span class="hljs-built_in">test</span>(<span class="hljs-type">int</span>,<span class="hljs-type">double</span>)&gt;::value , <span class="hljs-string">""</span>);
   <span class="hljs-built_in">static_assert</span>( <span class="hljs-keyword">not</span> has_valid_mem_fun_call_bar&lt;<span class="hljs-built_in">test</span>(<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,<span class="hljs-type">int</span>)&gt;::value , <span class="hljs-string">""</span>);

   <span class="hljs-built_in">static_assert</span>( <span class="hljs-keyword">not</span> has_ambiguous_mem_fun_call_bar&lt;<span class="hljs-built_in">test</span>(<span class="hljs-type">double</span>)&gt;::value , <span class="hljs-string">""</span>);
   <span class="hljs-built_in">static_assert</span>( has_ambiguous_mem_fun_call_bar&lt;<span class="hljs-built_in">test</span>(<span class="hljs-type">unsigned</span>)&gt;::value , <span class="hljs-string">""</span>);

   <span class="hljs-built_in">static_assert</span>( has_viable_mem_fun_call_bar&lt;<span class="hljs-built_in">test</span>(<span class="hljs-type">unsigned</span>)&gt;::value , <span class="hljs-string">""</span>);
   <span class="hljs-built_in">static_assert</span>( has_viable_mem_fun_call_bar&lt;<span class="hljs-built_in">test</span>(<span class="hljs-type">int</span>)&gt;::value , <span class="hljs-string">""</span>);

   <span class="hljs-built_in">static_assert</span>( has_no_viable_mem_fun_call_bar&lt;<span class="hljs-built_in">test</span>(<span class="hljs-type">void</span>)&gt;::value , <span class="hljs-string">""</span>);

   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>Here is the code, written in c++11, however, you can easily port it (with minor tweaks) to non-c++11 that has typeof extensions (e.g. gcc). You can replace the HAS_MEM macro with your own.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span>

<span class="hljs-meta">#<span class="hljs-keyword">if</span> __cplusplus &gt;= 201103</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> HAS_MEM(mem)                                                                                     \
                                                                                                     \
template <span class="hljs-string">&lt; typename T &gt;</span>                                                                               \
struct has_mem_##mem                                                                                  \
{                                                                                                     \
  struct yes {};                                                                                     \
  struct no  {};                                                                                     \
                                                                                                     \
  struct ambiguate_seed { char mem; };                                                               \
  template <span class="hljs-string">&lt; typename U &gt;</span> struct ambiguate : U, ambiguate_seed {};                                   \
                                                                                                     \
  template <span class="hljs-string">&lt; typename U, typename = decltype(&amp;U::mem) &gt;</span> static constexpr no  test(int);              \
  template <span class="hljs-string">&lt; typename                                 &gt;</span> static constexpr yes test(...);              \
                                                                                                     \
  static bool constexpr value = std::is_same<span class="hljs-string">&lt;decltype(test&lt; ambiguate&lt;T&gt;</span> &gt;(0)),yes&gt;::value ;         \
  typedef std::integral_constant<span class="hljs-string">&lt;bool,value&gt;</span>    type;                                                \
};</span>


<span class="hljs-meta">#<span class="hljs-keyword">define</span> HAS_MEM_FUN_CALL(memfun)                                                                         \
                                                                                                     \
template <span class="hljs-string">&lt; typename Signature &gt;</span>                                                                       \
struct has_valid_mem_fun_call_##memfun;                                                               \
                                                                                                     \
template <span class="hljs-string">&lt; typename T, typename... Args &gt;</span>                                                             \
struct has_valid_mem_fun_call_##memfun<span class="hljs-string">&lt; T(Args...) &gt;</span>                                                  \
{                                                                                                     \
  struct yes {};                                                                                     \
  struct no  {};                                                                                     \
                                                                                                     \
  template <span class="hljs-string">&lt; typename U, bool = has_mem_##memfun&lt;U&gt;</span>::value &gt;                                         \
  struct impl                                                                                        \
  {                                                                                                  \
     template <span class="hljs-string">&lt; typename V, typename = decltype(std::declval&lt;V&gt;</span>().memfun(std::declval<span class="hljs-string">&lt;Args&gt;</span>()...)) &gt; \
     struct test_result { using type = yes; };                                                       \
                                                                                                     \
     template <span class="hljs-string">&lt; typename V &gt;</span> static constexpr typename test_result<span class="hljs-string">&lt;V&gt;</span>::type test(int);               \
     template <span class="hljs-string">&lt; typename   &gt;</span> static constexpr                            no test(...);               \
                                                                                                     \
     static constexpr bool value = std::is_same<span class="hljs-string">&lt;decltype(test&lt;U&gt;</span>(0)),yes&gt;::value;                    \
     using type = std::integral_constant<span class="hljs-string">&lt;bool, value&gt;</span>;                                               \
  };                                                                                                 \
                                                                                                     \
  template <span class="hljs-string">&lt; typename U &gt;</span>                                                                            \
  struct impl<span class="hljs-string">&lt;U,false&gt;</span> : std::false_type {};                                                         \
                                                                                                     \
  static constexpr bool value = impl<span class="hljs-string">&lt;T&gt;</span>::value;                                                      \
  using type = std::integral_constant<span class="hljs-string">&lt;bool, value&gt;</span>;                                                  \
};                                                                                                    \
                                                                                                     \
template <span class="hljs-string">&lt; typename Signature &gt;</span>                                                                       \
struct has_ambiguous_mem_fun_call_##memfun;                                                           \
                                                                                                     \
template <span class="hljs-string">&lt; typename T, typename... Args &gt;</span>                                                             \
struct has_ambiguous_mem_fun_call_##memfun<span class="hljs-string">&lt; T(Args...) &gt;</span>                                              \
{                                                                                                     \
  struct ambiguate_seed { void memfun(...); };                                                       \
                                                                                                     \
  template <span class="hljs-string">&lt; class U, bool = has_mem_##memfun&lt;U&gt;</span>::value &gt;                                            \
  struct ambiguate : U, ambiguate_seed                                                               \
  {                                                                                                  \
    using ambiguate_seed::memfun;                                                                    \
    using U::memfun;                                                                                 \
  };                                                                                                 \
                                                                                                     \
  template <span class="hljs-string">&lt; class U &gt;</span>                                                                               \
  struct ambiguate<span class="hljs-string">&lt;U,false&gt;</span> : ambiguate_seed {};                                                     \
                                                                                                     \
  static constexpr bool value = not has_valid_mem_fun_call_##memfun<span class="hljs-string">&lt; ambiguate&lt;T&gt;</span>(Args...) &gt;::value; \
  using type = std::integral_constant<span class="hljs-string">&lt;bool, value&gt;</span>;                                                  \
};                                                                                                    \
                                                                                                     \
template <span class="hljs-string">&lt; typename Signature &gt;</span>                                                                       \
struct has_viable_mem_fun_call_##memfun;                                                              \
                                                                                                     \
template <span class="hljs-string">&lt; typename T, typename... Args &gt;</span>                                                             \
struct has_viable_mem_fun_call_##memfun<span class="hljs-string">&lt; T(Args...) &gt;</span>                                                 \
{                                                                                                     \
  static constexpr bool value = has_valid_mem_fun_call_##memfun<span class="hljs-string">&lt;T(Args...)&gt;</span>::value                   \
                             or has_ambiguous_mem_fun_call_##memfun<span class="hljs-string">&lt;T(Args...)&gt;</span>::value;              \
  using type = std::integral_constant<span class="hljs-string">&lt;bool, value&gt;</span>;                                                  \
};                                                                                                    \
                                                                                                     \
template <span class="hljs-string">&lt; typename Signature &gt;</span>                                                                       \
struct has_no_viable_mem_fun_call_##memfun;                                                           \
                                                                                                     \
template <span class="hljs-string">&lt; typename T, typename... Args &gt;</span>                                                             \
struct has_no_viable_mem_fun_call_##memfun <span class="hljs-string">&lt; T(Args...) &gt;</span>                                             \
{                                                                                                     \
  static constexpr bool value = not has_viable_mem_fun_call_##memfun<span class="hljs-string">&lt;T(Args...)&gt;</span>::value;             \
  using type = std::integral_constant<span class="hljs-string">&lt;bool, value&gt;</span>;                                                  \
};                                                                                                    \
                                                                                                     \
template <span class="hljs-string">&lt; typename Signature &gt;</span>                                                                       \
struct result_of_mem_fun_call_##memfun;                                                               \
                                                                                                     \
template <span class="hljs-string">&lt; typename T, typename... Args &gt;</span>                                                             \
struct result_of_mem_fun_call_##memfun<span class="hljs-string">&lt; T(Args...) &gt;</span>                                                  \
{                                                                                                     \
  using type = decltype(std::declval<span class="hljs-string">&lt;T&gt;</span>().memfun(std::declval<span class="hljs-string">&lt;Args&gt;</span>()...));                          \
};</span>

<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>

<hr>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 27</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You can skip all the metaprogramming in C++14, and just write this using <a href="http://fit.readthedocs.io/en/latest/include/fit/conditional.html" rel="nofollow noreferrer"><code>fit::conditional</code></a> from the <a href="https://github.com/pfultz2/Fit" rel="nofollow noreferrer">Fit</a> library:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
std::string <span class="hljs-title">optionalToString</span><span class="hljs-params">(T* x)</span>
</span>{
    <span class="hljs-keyword">return</span> fit::<span class="hljs-built_in">conditional</span>(
        [](<span class="hljs-keyword">auto</span>* obj) -&gt; <span class="hljs-keyword">decltype</span>(obj-&gt;<span class="hljs-built_in">toString</span>()) { <span class="hljs-keyword">return</span> obj-&gt;<span class="hljs-built_in">toString</span>(); },
        [](<span class="hljs-keyword">auto</span>*) { <span class="hljs-keyword">return</span> <span class="hljs-string">"toString not defined"</span>; }
    )(x);
}
</code></pre>

<p>You can also create the function directly from the lambdas as well:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-built_in">FIT_STATIC_LAMBDA_FUNCTION</span>(optionalToString) = fit::<span class="hljs-built_in">conditional</span>(
    [](<span class="hljs-keyword">auto</span>* obj) -&gt; <span class="hljs-keyword">decltype</span>(obj-&gt;<span class="hljs-built_in">toString</span>(), std::<span class="hljs-built_in">string</span>()) { <span class="hljs-keyword">return</span> obj-&gt;<span class="hljs-built_in">toString</span>(); },
    [](<span class="hljs-keyword">auto</span>*) -&gt; std::string { <span class="hljs-keyword">return</span> <span class="hljs-string">"toString not defined"</span>; }
);
</code></pre>

<p>However, if you are using a compiler that doesn't support generic lambdas, you will have to write separate function objects:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">withToString</span>
{
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
    <span class="hljs-keyword">auto</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T* obj)</span> <span class="hljs-type">const</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(obj-&gt;toString(), std::string())</span>
    </span>{
        <span class="hljs-keyword">return</span> obj-&gt;<span class="hljs-built_in">toString</span>();
    }
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">withoutToString</span>
{
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
    std::string <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T*)</span> <span class="hljs-type">const</span>
    </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"toString not defined"</span>;
    }
};

<span class="hljs-built_in">FIT_STATIC_FUNCTION</span>(optionalToString) = fit::<span class="hljs-built_in">conditional</span>(
    <span class="hljs-built_in">withToString</span>(),
    <span class="hljs-built_in">withoutToString</span>()
);
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 28</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Probably not as good as other examples, but this is what I came up with for C++11. This works for picking overloaded methods.</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Args&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pack</span> {};

<span class="hljs-meta">#<span class="hljs-keyword">define</span> Proxy(T) ((T &amp;)(*(int *)(nullptr)))</span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Class, <span class="hljs-keyword">typename</span> ArgPack, <span class="hljs-keyword">typename</span> = <span class="hljs-type">nullptr_t</span>&gt;
<span class="hljs-keyword">struct</span> HasFoo
{
    <span class="hljs-keyword">enum</span> { value = <span class="hljs-literal">false</span> };
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Class, <span class="hljs-keyword">typename</span>... Args&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">HasFoo</span>&lt;
    Class,
    Pack&lt;Args...&gt;,
    <span class="hljs-keyword">decltype</span>((<span class="hljs-type">void</span>)(<span class="hljs-built_in">Proxy</span>(Class).<span class="hljs-built_in">foo</span>(<span class="hljs-built_in">Proxy</span>(Args)...)), <span class="hljs-literal">nullptr</span>)&gt;
{
    <span class="hljs-keyword">enum</span> { value = <span class="hljs-literal">true</span> };
};
</code></pre>
<p>Example usage</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Object</span>
{
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>         </span>{ <span class="hljs-keyword">return</span> n; }
<span class="hljs-meta">#<span class="hljs-keyword">if</span> SOME_CONDITION</span>
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> c)</span> </span>{ <span class="hljs-keyword">return</span> n + c; }
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-type">bool</span> has_foo_int_char&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dispatcher</span>;

<span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dispatcher</span>&lt;<span class="hljs-literal">false</span>&gt;
{
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Object&gt;
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">exec</span><span class="hljs-params">(Object &amp;object, <span class="hljs-type">int</span> n, <span class="hljs-type">char</span> c)</span>
    </span>{
        <span class="hljs-keyword">return</span> object.<span class="hljs-built_in">foo</span>(n) + c;
    }
};

<span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dispatcher</span>&lt;<span class="hljs-literal">true</span>&gt;
{
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Object&gt;
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">exec</span><span class="hljs-params">(Object &amp;object, <span class="hljs-type">int</span> n, <span class="hljs-type">char</span> c)</span>
    </span>{
        <span class="hljs-keyword">return</span> object.<span class="hljs-built_in">foo</span>(n, c);
    }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">runExample</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> Args = Pack&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt;;
    <span class="hljs-keyword">enum</span> { has_overload = HasFoo&lt;Object, Args&gt;::value };
    Object object;
    <span class="hljs-keyword">return</span> Dispatcher&lt;has_overload&gt;::<span class="hljs-built_in">exec</span>(object, <span class="hljs-number">100</span>, <span class="hljs-string">'a'</span>);
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 29</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is an example of the working code.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> toStringFn = <span class="hljs-keyword">decltype</span>(std::<span class="hljs-built_in">declval</span>&lt;<span class="hljs-type">const</span> T&gt;().<span class="hljs-built_in">toString</span>());

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, toStringFn&lt;T&gt;* = <span class="hljs-literal">nullptr</span>&gt;
std::string <span class="hljs-built_in">optionalToString</span>(<span class="hljs-type">const</span> T* obj, <span class="hljs-type">int</span>)
{
    <span class="hljs-keyword">return</span> obj-&gt;<span class="hljs-built_in">toString</span>();
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-function">std::string <span class="hljs-title">optionalToString</span><span class="hljs-params">(<span class="hljs-type">const</span> T* obj, <span class="hljs-type">long</span>)</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">"toString not defined"</span>;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    A* a;
    B* b;

    std::cout &lt;&lt; <span class="hljs-built_in">optionalToString</span>(a, <span class="hljs-number">0</span>) &lt;&lt; std::endl; <span class="hljs-comment">// This is A</span>
    std::cout &lt;&lt; <span class="hljs-built_in">optionalToString</span>(b, <span class="hljs-number">0</span>) &lt;&lt; std::endl; <span class="hljs-comment">// toString not defined</span>
}
</code></pre>

<p><code>toStringFn&lt;T&gt;* = nullptr</code> will enable the function which takes extra <code>int</code> argument which has a priority over function which takes <code>long</code> when called with <code>0</code>.</p>

<p>You can use the same principle for the functions which returns <code>true</code> if function is implemented.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-title">toStringExists</span><span class="hljs-params">(<span class="hljs-type">long</span>)</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, toStringFn&lt;T&gt;* = <span class="hljs-literal">nullptr</span>&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-built_in">toStringExists</span>(<span class="hljs-type">int</span>)
{
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}


<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    A* a;
    B* b;

    std::cout &lt;&lt; <span class="hljs-built_in">toStringExists</span>&lt;A&gt;(<span class="hljs-number">0</span>) &lt;&lt; std::endl; <span class="hljs-comment">// true</span>
    std::cout &lt;&lt; <span class="hljs-built_in">toStringExists</span>&lt;B&gt;(<span class="hljs-number">0</span>) &lt;&lt; std::endl; <span class="hljs-comment">// false</span>
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 30</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I had a similar problem:</p>

<p>A template class that may be derived from few base classes, some that have a certain member and others that do not.</p>

<p>I solved it similarly to the "typeof" (Nicola Bonelli's) answer, but with decltype so it compiles and runs correctly on MSVS:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Generic</span> {};    
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">HasMember</span> 
{
  <span class="hljs-built_in">HasMember</span>() : _a(<span class="hljs-number">1</span>) {};
  <span class="hljs-type">int</span> _a;
};    

<span class="hljs-comment">// SFINAE test</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">S</span> : <span class="hljs-keyword">public</span> T
{
<span class="hljs-keyword">public</span>:
  <span class="hljs-function">std::string <span class="hljs-title">foo</span> <span class="hljs-params">(std::string b)</span>
  </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">foo2</span>&lt;T&gt;(b,<span class="hljs-number">0</span>);
  }

<span class="hljs-keyword">protected</span>:
  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function">std::string <span class="hljs-title">foo2</span> <span class="hljs-params">(std::string b, <span class="hljs-keyword">decltype</span> (T::_a))</span>
  </span>{
    <span class="hljs-keyword">return</span> b + std::<span class="hljs-built_in">to_string</span>(T::_a);
  }
  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function">std::string <span class="hljs-title">foo2</span> <span class="hljs-params">(std::string b, ...)</span>
  </span>{
    <span class="hljs-keyword">return</span> b + <span class="hljs-string">"No"</span>;
  }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>
</span>{
  S&lt;HasMember&gt; d1;
  S&lt;Generic&gt; d2;

  std::cout &lt;&lt; d1.<span class="hljs-built_in">foo</span>(<span class="hljs-string">"HasMember: "</span>) &lt;&lt; std::endl;
  std::cout &lt;&lt; d2.<span class="hljs-built_in">foo</span>(<span class="hljs-string">"Generic: "</span>) &lt;&lt; std::endl;
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;Yes, with SFINAE you can check if a given class does provide a certain method. Here\u0026apos;s the working code:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Hello\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;helloworld\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; }\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Generic\u0026lt;/span\u0026gt; {};    \n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// SFINAE test\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;has_helloworld\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; one;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;two\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; x[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;]; };\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; C\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; one \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(\u0026amp;amp;C::helloworld) )\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; C\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; two \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(...)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;    \n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { value = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)) == \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;) };\n};\n    \n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *argv[])\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    std::cout \u0026amp;lt;\u0026amp;lt; has_helloworld\u0026amp;lt;Hello\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl;\n    std::cout \u0026amp;lt;\u0026amp;lt; has_helloworld\u0026amp;lt;Generic\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;I\u0026apos;ve just tested it with Linux and gcc 4.1/4.3. I don\u0026apos;t know if it\u0026apos;s portable to other platforms running different compilers.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This question is old, but with C++11 we got a new way to check for a functions existence (or existence of any non-type member, really), relying on SFINAE again:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;serialize_imp\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::ostream\u0026amp;amp; os, T \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp; obj, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(os \u0026amp;lt;\u0026amp;lt; obj, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;())\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  os \u0026amp;lt;\u0026amp;lt; obj;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;serialize_imp\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::ostream\u0026amp;amp; os, T \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp; obj, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(obj.stream(os), \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;())\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  obj.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stream\u0026lt;/span\u0026gt;(os);\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;serialize\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::ostream\u0026amp;amp; os, T \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp; obj)\u0026lt;/span\u0026gt;\n    -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(serialize_imp(os, obj, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;), \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;())\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;serialize_imp\u0026lt;/span\u0026gt;(os, obj, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now onto some explanations. First thing, I use \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2634.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;expression SFINAE\u0026lt;/a\u0026gt; to exclude the \u0026lt;code\u0026gt;serialize(_imp)\u0026lt;/code\u0026gt; functions from overload resolution, if the first expression inside \u0026lt;code\u0026gt;decltype\u0026lt;/code\u0026gt; isn\u0026apos;t valid (aka, the function doesn\u0026apos;t exist).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;void()\u0026lt;/code\u0026gt; is used to make the return type of all those functions \u0026lt;code\u0026gt;void\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt; argument is used to prefer the \u0026lt;code\u0026gt;os \u0026amp;lt;\u0026amp;lt; obj\u0026lt;/code\u0026gt; overload if both are available (literal \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt; is of type \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; and as such the first overload is a better match).\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Now, you probably want a trait to check if a function exists. Luckily, it\u0026apos;s easy to write that. Note, though, that you need to write a trait \u0026lt;em\u0026gt;yourself\u0026lt;/em\u0026gt; for every different function name you might want.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;type_traits\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;sfinae_true\u0026lt;/span\u0026gt; : std::true_type{};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; detail{\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; A0\u0026amp;gt;\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test_stream\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n      -\u0026amp;gt; sfinae_true\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::declval\u0026amp;lt;T\u0026amp;gt;().stream(std::declval\u0026amp;lt;A0\u0026amp;gt;()))\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; A0\u0026amp;gt;\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test_stream\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; -\u0026amp;gt; std::false_type\u0026lt;/span\u0026gt;;\n} \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// detail::\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Arg\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;has_stream\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(detail::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test_stream\u0026lt;/span\u0026gt;\u0026amp;lt;T, Arg\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)){};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://coliru.stacked-crooked.com/a/cd139d95d214c5c3\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Live example.\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;And on to explanations. First, \u0026lt;code\u0026gt;sfinae_true\u0026lt;/code\u0026gt; is a helper type, and it basically amounts to the same as writing \u0026lt;code\u0026gt;decltype(void(std::declval\u0026amp;lt;T\u0026amp;gt;().stream(a0)), std::true_type{})\u0026lt;/code\u0026gt;. The advantage is simply that it\u0026apos;s shorter.\u0026lt;br\u0026gt;\nNext, the \u0026lt;code\u0026gt;struct has_stream : decltype(...)\u0026lt;/code\u0026gt; inherits from either \u0026lt;code\u0026gt;std::true_type\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;std::false_type\u0026lt;/code\u0026gt; in the end, depending on whether the \u0026lt;code\u0026gt;decltype\u0026lt;/code\u0026gt; check in \u0026lt;code\u0026gt;test_stream\u0026lt;/code\u0026gt; fails or not.\u0026lt;br\u0026gt;\nLast, \u0026lt;code\u0026gt;std::declval\u0026lt;/code\u0026gt; gives you a \u0026quot;value\u0026quot; of whatever type you pass, without you needing to know how you can construct it. Note that this is only possible inside an unevaluated context, such as \u0026lt;code\u0026gt;decltype\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt; and others.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Note that \u0026lt;code\u0026gt;decltype\u0026lt;/code\u0026gt; is not necessarily needed, as \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt; (and all unevaluated contexts) got that enhancement. It\u0026apos;s just that \u0026lt;code\u0026gt;decltype\u0026lt;/code\u0026gt; already delivers a type and as such is just cleaner. Here\u0026apos;s a \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt; version of one of the overloads:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;serialize_imp\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::ostream\u0026amp;amp; os, T \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp; obj, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;,\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;(*)[\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;((os \u0026amp;lt;\u0026amp;lt; obj),\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  os \u0026amp;lt;\u0026amp;lt; obj;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;long\u0026lt;/code\u0026gt; parameters are still there for the same reason. The array pointer is used to provide a context where \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt; can be used.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;C++ allows \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/SFINAE\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;SFINAE\u0026lt;/a\u0026gt; to be used for this (notice that with C++11 features this is simplier because it supports extended SFINAE on nearly arbitrary expressions - the below was crafted to work with common C++03 compilers):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; HAS_MEM_FUNC(func, name)                                        \\\n    template\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T, typename Sign\u0026amp;gt;\u0026lt;/span\u0026gt;                                 \\\n    struct name {                                                       \\\n        typedef char yes[1];                                            \\\n        typedef char no [2];                                            \\\n        template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename U, U\u0026amp;gt;\u0026lt;/span\u0026gt; struct type_check;                     \\\n        template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename _1\u0026amp;gt;\u0026lt;/span\u0026gt; static yes \u0026amp;amp;chk(type_check\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;Sign, \u0026amp;amp;_1::func \u0026amp;gt;\u0026lt;/span\u0026gt; *); \\\n        template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename   \u0026amp;gt;\u0026lt;/span\u0026gt; static no  \u0026amp;amp;chk(...);                    \\\n        static bool const value = sizeof(chk\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;T\u0026amp;gt;\u0026lt;/span\u0026gt;(0)) == sizeof(yes);     \\\n    }\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The above template and macro tries to instantiate a template, giving it a member function pointer type, and the actual member function pointer. If the types do not fit, SFINAE causes the template to be ignored. Usage like this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;HAS_MEM_FUNC\u0026lt;/span\u0026gt;(toString, has_to_string);\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;doSomething\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(has_to_string\u0026amp;lt;T, std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;(T::*)()\u0026amp;gt;::value) {\n      ...\n   } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n      ...\n   }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;But note that you cannot just call that \u0026lt;code\u0026gt;toString\u0026lt;/code\u0026gt; function in that \u0026lt;code\u0026gt;if\u0026lt;/code\u0026gt; branch. Since the compiler will check for validity in both branches, that would fail for cases the function doesn\u0026apos;t exist. One way is to use SFINAE once again (\u0026lt;code\u0026gt;enable_if\u0026lt;/code\u0026gt; can be obtained from boost, too):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; C, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T = \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; enable_if {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; T type;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;enable_if\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;, T\u0026amp;gt; { };\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;HAS_MEM_FUNC\u0026lt;/span\u0026gt;(toString, has_to_string);\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; enable_if\u0026amp;lt;has_to_string\u0026amp;lt;T, \n                   std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;(T::*)()\u0026amp;gt;::value, std::string\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;type\n\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;doSomething\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T * t)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* something when T has toString ... */\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; t-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;();\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; enable_if\u0026amp;lt;!has_to_string\u0026amp;lt;T, \n                   std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;(T::*)()\u0026amp;gt;::value, std::string\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;type\n\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;doSomething\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T * t)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* something when T doesnt have toString ... */\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;T::toString() does not exist.\u0026quot;\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Have fun using it. The advantage of it is that it also works for overloaded member functions, and also for \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt; member functions (remember using  \u0026lt;code\u0026gt;std::string(T::*)() const\u0026lt;/code\u0026gt; as the member function pointer type then!).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;C++20 - \u0026lt;code\u0026gt;requires\u0026lt;/code\u0026gt; expressions\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;With C++20 come concepts and assorted tools such as \u0026lt;a href=\u0026quot;https://en.cppreference.com/w/cpp/language/constraints\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;requires\u0026lt;/code\u0026gt; expressions\u0026lt;/a\u0026gt; which are a built-in way to check for a function existence. With them you could rewrite your \u0026lt;code\u0026gt;optionalToString\u0026lt;/code\u0026gt; function as follows:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\nstd::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T* obj)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; has_toString = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;requires\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T\u0026amp;amp; t) {\n        t.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;();\n    };\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(has_toString)\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; obj-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toString not defined\u0026quot;\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h2\u0026gt;Pre-C++20 - Detection toolkit\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;N4502\u0026lt;/a\u0026gt; proposes a detection toolkit for inclusion into the C++17 standard library that eventually made it into the library fundamentals TS v2. It most likely won\u0026apos;t ever get into the standard because it has been subsumed by \u0026lt;code\u0026gt;requires\u0026lt;/code\u0026gt; expressions since, but it still solves the problem in a somewhat elegant manner. The toolkit introduces some metafunctions, including \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/experimental/is_detected\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::is_detected\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; which can be used to easily write type or function detection metafunctions on the top of it. Here is how you could use it:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; toString_t = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;( std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;amp;\u0026amp;gt;().\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;() );\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; has_toString = std::is_detected_v\u0026amp;lt;toString_t, T\u0026amp;gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Note that the example above is untested. The detection toolkit is not available in standard libraries yet but the proposal contains a full implementation that you can easily copy if you really need it. It plays nice with the C++17 feature \u0026lt;code\u0026gt;if constexpr\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\nstd::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T* obj)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(has_toString\u0026amp;lt;T\u0026amp;gt;)\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; obj-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toString not defined\u0026quot;\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h2\u0026gt;C++14 - Boost.Hana\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Boost.Hana apparently builds upon this specific example and provides a solution for C++14 in its documentation, so I\u0026apos;m going to quote it directly:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;[...] Hana provides a \u0026lt;code\u0026gt;is_valid\u0026lt;/code\u0026gt; function that can be combined with C++14 generic lambdas to obtain a much cleaner implementation of the same thing:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; has_toString = hana::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;is_valid\u0026lt;/span\u0026gt;([](\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt;\u0026amp;amp;\u0026amp;amp; obj) -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(obj.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;()) { });\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This leaves us with a function object \u0026lt;code\u0026gt;has_toString\u0026lt;/code\u0026gt; which returns whether the given expression is valid on the argument we pass to it. The result is returned as an \u0026lt;code\u0026gt;IntegralConstant\u0026lt;/code\u0026gt;, so constexpr-ness is not an issue here because the result of the function is represented as a type anyway. Now, in addition to being less verbose (that\u0026apos;s a one liner!), the intent is much clearer. Other benefits are the fact that \u0026lt;code\u0026gt;has_toString\u0026lt;/code\u0026gt; can be passed to higher order algorithms and it can also be defined at function scope, so there is no need to pollute the namespace scope with implementation details.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;h2\u0026gt;Boost.TTI\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Another somewhat idiomatic toolkit to perform such a check - even though less elegant - is \u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/1_55_0/libs/tti/doc/html/index.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Boost.TTI\u0026lt;/a\u0026gt;, introduced in Boost 1.54.0. For your example, you would have to use the macro \u0026lt;code\u0026gt;BOOST_TTI_HAS_MEMBER_FUNCTION\u0026lt;/code\u0026gt;. Here is how you could use it:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;boost/tti/has_member_function.hpp\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Generate the metafunction\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;BOOST_TTI_HAS_MEMBER_FUNCTION\u0026lt;/span\u0026gt;(toString)\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Check whether T has a member function toString\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// which takes no parameter and returns a std::string\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; foo = has_member_function_toString\u0026amp;lt;T, std::string\u0026amp;gt;::value;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Then, you could use the \u0026lt;code\u0026gt;bool\u0026lt;/code\u0026gt; to create a SFINAE check.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Explanation\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The macro \u0026lt;code\u0026gt;BOOST_TTI_HAS_MEMBER_FUNCTION\u0026lt;/code\u0026gt; generates the metafunction \u0026lt;code\u0026gt;has_member_function_toString\u0026lt;/code\u0026gt; which takes the checked type as its first template parameter. The second template parameter corresponds to the return type of the member function, and the following parameters correspond to the types of the function\u0026apos;s parameters. The member \u0026lt;code\u0026gt;value\u0026lt;/code\u0026gt; contains \u0026lt;code\u0026gt;true\u0026lt;/code\u0026gt; if the class \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; has a member function \u0026lt;code\u0026gt;std::string toString()\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Alternatively, \u0026lt;code\u0026gt;has_member_function_toString\u0026lt;/code\u0026gt; can take a member function pointer as a template parameter. Therefore, it is possible to replace \u0026lt;code\u0026gt;has_member_function_toString\u0026amp;lt;T, std::string\u0026amp;gt;::value\u0026lt;/code\u0026gt; by \u0026lt;code\u0026gt;has_member_function_toString\u0026amp;lt;std::string T::* ()\u0026amp;gt;::value\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Though this question is two years old, I\u0026apos;ll dare to add my answer. Hopefully it will clarify the previous, indisputably excellent, solution. I took the very helpful answers of Nicola Bonelli and Johannes Schaub and merged them into a solution that is, IMHO, more readable, clear and does not require the \u0026lt;code\u0026gt;typeof\u0026lt;/code\u0026gt; extension:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Type\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;TypeHasToString\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This type won\u0026apos;t compile if the second template parameter isn\u0026apos;t of type T,\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// so I can put a function pointer type in the first parameter and the function\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// itself in the second thus checking that the function has a specific signature.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T, T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;TypeCheck\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; Yes;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; No;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// A helper struct to hold the declaration of the function pointer.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Change it if the function signature changes.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ToString\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T::*fptr)\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    };\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; Yes \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;HasToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(TypeCheck\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; ToString\u0026amp;lt;T\u0026amp;gt;::fptr, \u0026amp;amp;T::toString \u0026amp;gt;*)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; No  \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;HasToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(...)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; value = (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;HasToString\u0026lt;/span\u0026gt;\u0026amp;lt;Type\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)) == \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(Yes));\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I checked it with gcc 4.1.2.\nThe credit goes mainly to Nicola Bonelli and Johannes Schaub, so give them a vote up if my answer helps you :)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A simple solution for C++11:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T* obj)\u0026lt;/span\u0026gt;\n -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(  obj-\u0026amp;gt;toString()  )\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;     obj-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;();\n}\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(...)\u0026lt;/span\u0026gt; -\u0026amp;gt; string\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toString not defined\u0026quot;\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Update, 3 years later: (and this is untested). To test for the existence, I think this will work:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test_has_toString_method\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T* obj)\u0026lt;/span\u0026gt;\n -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(  obj-\u0026amp;gt;toString() , std::true_type{} )\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;     obj-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;();\n}\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test_has_toString_method\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(...)\u0026lt;/span\u0026gt; -\u0026amp;gt; std::false_type\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toString not defined\u0026quot;\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Well, this question has a long list of answers already, but I would like to emphasize the comment from Morwenn: there is a proposal for C++17 that makes it really much simpler.  See \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot; title=\u0026quot;Proposing Standard Library Support for the C++ Detection Idiom, v2\u0026quot;\u0026gt;N4502\u0026lt;/a\u0026gt; for details, but as a self-contained example consider the following.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This part is the constant part, put it in a header.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// See http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;...\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void_t\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Primary template handles all types not supporting the operation.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void_t\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; detect : std::false_type {};\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Specialization recognizes/validates only types supporting the archetype.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Op\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;detect\u0026lt;/span\u0026gt;\u0026amp;lt;T, Op, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void_t\u0026lt;/span\u0026gt;\u0026amp;lt;Op\u0026amp;lt;T\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; : std::true_type {};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;then there is the variable part, where you specify what you are looking for (a type, a member type, a function, a member function etc.).  In the case of the OP:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; toString_t = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;().\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;());\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; has_toString = detect\u0026amp;lt;T, toString_t\u0026amp;gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The following example, taken from \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot; title=\u0026quot;Proposing Standard Library Support for the C++ Detection Idiom, v2\u0026quot;\u0026gt;N4502\u0026lt;/a\u0026gt;, shows a more elaborate probe:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Archetypal expression for assignment operation.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;assign_t\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;amp;\u0026amp;gt;() = std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;T \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;gt;())\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Trait corresponding to that archetype.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; is_assignable = detect\u0026amp;lt;T, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;assign_t\u0026lt;/span\u0026gt;\u0026amp;gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Compared to the other implementations described above, this one is fairly simple: a reduced set of tools (\u0026lt;code\u0026gt;void_t\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;detect\u0026lt;/code\u0026gt;) suffices, no need for hairy macros.  Besides, it was reported (see \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot; title=\u0026quot;Proposing Standard Library Support for the C++ Detection Idiom, v2\u0026quot;\u0026gt;N4502\u0026lt;/a\u0026gt;) that it is measurably more efficient (compile-time and compiler memory consumption) than previous approaches.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here is a \u0026lt;a href=\u0026quot;http://coliru.stacked-crooked.com/a/7eae9c76232a2d20\u0026quot; rel=\u0026quot;noreferrer\u0026quot; title=\u0026quot;Detection idiom\u0026quot;\u0026gt;live example\u0026lt;/a\u0026gt;.  It works fine with Clang, but unfortunately, GCC versions before 5.1 followed a different interpretation of the C++11 standard which caused \u0026lt;code\u0026gt;void_t\u0026lt;/code\u0026gt; to not work as expected.  Yakk already provided the work-around: use the following definition of \u0026lt;code\u0026gt;void_t\u0026lt;/code\u0026gt; (\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/28967003/void-t-in-parameter-list-works-but-not-as-return-type/28967049#28967049\u0026quot;\u0026gt;void_t in parameter list works but not as return type\u0026lt;/a\u0026gt;):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __GNUC__ \u0026amp;lt; 5 \u0026amp;amp;\u0026amp;amp; ! defined __clang__\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// https://stackoverflow.com/a/28967049/1353549\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;...\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;voider\u0026lt;/span\u0026gt;\n{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; type = \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;;\n};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;...Ts\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void_t\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; voider\u0026amp;lt;Ts...\u0026amp;gt;::type;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;...\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void_t\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;endif\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is what type traits are there for. Unfortunately, they have to be defined manually. In your case, imagine the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;response_trait\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; has_tostring = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;response_trait\u0026lt;/span\u0026gt;\u0026amp;lt;your_type_with_tostring\u0026amp;gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; has_tostring = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is a C++11 solution for the general problem if \u0026quot;If I did X, would it compile?\u0026quot;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;type_sink\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; type; }; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// consumes a type, and makes it `void`\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;type_sink_t\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; type_sink\u0026amp;lt;T\u0026amp;gt;::type;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; has_to_string : std::false_type {}; \\\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;has_to_string\u0026lt;/span\u0026gt;\u0026amp;lt;\n  T,\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;type_sink_t\u0026lt;/span\u0026gt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;( std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;().\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;() ) \u0026amp;gt;\n\u0026amp;gt;: std::true_type {};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Trait \u0026lt;code\u0026gt;has_to_string\u0026lt;/code\u0026gt; such that \u0026lt;code\u0026gt;has_to_string\u0026amp;lt;T\u0026amp;gt;::value\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;true\u0026lt;/code\u0026gt; if and only if \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; has a method \u0026lt;code\u0026gt;.toString\u0026lt;/code\u0026gt; that can be invoked with 0 arguments in this context.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Next, I\u0026apos;d use tag dispatching:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; details {\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\n  std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;optionalToString_helper\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T* obj, std::true_type \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*has_to_string*/\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; obj-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;();\n  }\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\n  std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;optionalToString_helper\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T* obj, std::false_type \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*has_to_string*/\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toString not defined\u0026quot;\u0026lt;/span\u0026gt;;\n  }\n}\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\nstd::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T* obj)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; details::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;optionalToString_helper\u0026lt;/span\u0026gt;( obj, has_to_string\u0026amp;lt;T\u0026amp;gt;{} );\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;which tends to be more maintainable than complex SFINAE expressions.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can write these traits with a macro if you find yourself doing it alot, but they are relatively simple (a few lines each) so maybe not worth it:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; MAKE_CODE_TRAIT( TRAIT_NAME, ... ) \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;class T, class=void\u0026amp;gt;\u0026lt;/span\u0026gt; struct TRAIT_NAME : std::false_type {}; \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;class T\u0026amp;gt;\u0026lt;/span\u0026gt; struct TRAIT_NAME\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; T, type_sink_t\u0026amp;lt; decltype( __VA_ARGS__ ) \u0026amp;gt;\u0026lt;/span\u0026gt; \u0026amp;gt;: std::true_type {};\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;what the above does is create a macro \u0026lt;code\u0026gt;MAKE_CODE_TRAIT\u0026lt;/code\u0026gt;.  You pass it the name of the trait you want, and some code that can test the type \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt;.  Thus:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;MAKE_CODE_TRAIT\u0026lt;/span\u0026gt;( has_to_string, std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;().\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;() )\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;creates the above traits class.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As an aside, the above technique is part of what MS calls \u0026quot;expression SFINAE\u0026quot;, and their 2013 compiler fails pretty hard.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note that in C++1y the following syntax is possible:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\nstd::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T* obj)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;compiled_if\u0026lt;/span\u0026gt;\u0026amp;lt; has_to_string \u0026amp;gt;(*obj, [\u0026amp;amp;](\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt;\u0026amp;amp;\u0026amp;amp; obj) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; obj.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;();\n  }) *\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;compiled_else\u0026lt;/span\u0026gt; ([\u0026amp;amp;]{ \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toString not defined\u0026quot;\u0026lt;/span\u0026gt;;\n  });\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;which is an inline compilation conditional branch that abuses lots of C++ features.  Doing so is probably not worth it, as the benefit (of code being inline) is not worth the cost (of next to nobody understanding how it works), but the existence of that above solution may be of interest.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;With C++ 20 you can write the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;concept\u0026lt;/span\u0026gt; has_toString = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;requires\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T\u0026amp;amp; t) {\n    t.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;();\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\nstd::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T\u0026amp;amp; obj)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(has_toString\u0026amp;lt;T\u0026amp;gt;)\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; obj.\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toString not defined\u0026quot;\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here are some usage snippets:\n*The guts for all this are farther down\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Check for member \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; in a given class.  Could be var, func, class, union, or enum:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CREATE_MEMBER_CHECK\u0026lt;/span\u0026gt;(x);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; has_x = has_member_x\u0026amp;lt;class_to_check_for_x\u0026amp;gt;::value;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Check for member function \u0026lt;code\u0026gt;void x()\u0026lt;/code\u0026gt;:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Func signature MUST have T as template variable here... simpler this way :\\\nCREATE_MEMBER_FUNC_SIG_CHECK(x, void (T::*)(), void__x);\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; has_func_sig_void__x = has_member_func_void__x\u0026amp;lt;class_to_check_for_x\u0026amp;gt;::value;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Check for member variable \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CREATE_MEMBER_VAR_CHECK\u0026lt;/span\u0026gt;(x);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; has_var_x = has_member_var_x\u0026amp;lt;class_to_check_for_x\u0026amp;gt;::value;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Check for member class \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CREATE_MEMBER_CLASS_CHECK\u0026lt;/span\u0026gt;(x);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; has_class_x = has_member_class_x\u0026amp;lt;class_to_check_for_x\u0026amp;gt;::value;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Check for member union \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CREATE_MEMBER_UNION_CHECK\u0026lt;/span\u0026gt;(x);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; has_union_x = has_member_union_x\u0026amp;lt;class_to_check_for_x\u0026amp;gt;::value;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Check for member enum \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CREATE_MEMBER_ENUM_CHECK\u0026lt;/span\u0026gt;(x);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; has_enum_x = has_member_enum_x\u0026amp;lt;class_to_check_for_x\u0026amp;gt;::value;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Check for any member function \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; regardless of signature:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CREATE_MEMBER_CHECK\u0026lt;/span\u0026gt;(x);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CREATE_MEMBER_VAR_CHECK\u0026lt;/span\u0026gt;(x);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CREATE_MEMBER_CLASS_CHECK\u0026lt;/span\u0026gt;(x);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CREATE_MEMBER_UNION_CHECK\u0026lt;/span\u0026gt;(x);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CREATE_MEMBER_ENUM_CHECK\u0026lt;/span\u0026gt;(x);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CREATE_MEMBER_FUNC_CHECK\u0026lt;/span\u0026gt;(x);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; has_any_func_x = has_member_func_x\u0026amp;lt;class_to_check_for_x\u0026amp;gt;::value;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;OR\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CREATE_MEMBER_CHECKS\u0026lt;/span\u0026gt;(x);  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Just stamps out the same macro calls as above.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; has_any_func_x = has_member_func_x\u0026amp;lt;class_to_check_for_x\u0026amp;gt;::value;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Details and core:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*\n    - Multiple inheritance forces ambiguity of member names.\n    - SFINAE is used to make aliases to member names.\n    - Expression SFINAE is used in just one generic has_member that can accept\n      any alias we pass it.\n*/\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Variadic to force ambiguity of class members.  C++11 and up.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;... Args\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ambiguate\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Args... {};\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Non-variadic version of the line above.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//template \u0026amp;lt;typename A, typename B\u0026amp;gt; struct ambiguate : public A, public B {};\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; A, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; got_type : std::false_type {};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; A\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;got_type\u0026lt;/span\u0026gt;\u0026amp;lt;A\u0026amp;gt; : std::true_type {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; A type;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T, T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;sig_check\u0026lt;/span\u0026gt; : std::true_type {};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Alias, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; AmbiguitySeed\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;has_member\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; C\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;((\u0026amp;amp;f(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(\u0026amp;amp;C::value))))\u0026lt;/span\u0026gt;[1]\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; C\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;((\u0026amp;amp;f(...)))\u0026lt;/span\u0026gt;[2]\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Make sure the member name is consistently spelled the same.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(\n        (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026amp;lt;AmbiguitySeed\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)) == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n        , \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Member name specified in AmbiguitySeed is different from member name specified in Alias, or wrong Alias/AmbiguitySeed has been specified.\u0026quot;\u0026lt;/span\u0026gt;\n    );\n\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; value = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026amp;lt;Alias\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)) == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;Macros (El Diablo!):\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;CREATE_MEMBER_CHECK:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Check for any member with given name, whether var, func, class, union, enum.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; CREATE_MEMBER_CHECK(member)                                         \\\n                                                                            \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T, typename = std::true_type\u0026amp;gt;\u0026lt;/span\u0026gt;                             \\\nstruct Alias_##member;                                                      \\\n                                                                            \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T\u0026amp;gt;\u0026lt;/span\u0026gt;                                                        \\\nstruct Alias_##member \u0026amp;lt;                                                     \\\n    T, std::integral_constant\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;bool, got_type\u0026amp;lt;decltype(\u0026amp;amp;T::member)\u0026amp;gt;\u0026lt;/span\u0026gt;::value\u0026amp;gt;  \\\n\u0026amp;gt; { static const decltype(\u0026amp;amp;T::member) value; };                             \\\n                                                                            \\\nstruct AmbiguitySeed_##member { char member; };                             \\\n                                                                            \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T\u0026amp;gt;\u0026lt;/span\u0026gt;                                                        \\\nstruct has_member_##member {                                                \\\n    static const bool value                                                 \\\n        = has_member\u0026amp;lt;                                                       \\\n            Alias_##member\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;ambiguate\u0026amp;lt;T, AmbiguitySeed_##member\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026amp;gt;            \\\n            , Alias_##member\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;AmbiguitySeed_##member\u0026amp;gt;\u0026lt;/span\u0026gt;                        \\\n        \u0026amp;gt;::value                                                            \\\n    ;                                                                       \\\n}\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;CREATE_MEMBER_VAR_CHECK:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Check for member variable with given name.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; CREATE_MEMBER_VAR_CHECK(var_name)                                   \\\n                                                                            \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T, typename = std::true_type\u0026amp;gt;\u0026lt;/span\u0026gt;                             \\\nstruct has_member_var_##var_name : std::false_type {};                      \\\n                                                                            \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T\u0026amp;gt;\u0026lt;/span\u0026gt;                                                        \\\nstruct has_member_var_##var_name\u0026amp;lt;                                           \\\n    T                                                                       \\\n    , std::integral_constant\u0026amp;lt;                                               \\\n        bool                                                                \\\n        , !std::is_member_function_pointer\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;decltype(\u0026amp;amp;T::var_name)\u0026amp;gt;\u0026lt;/span\u0026gt;::value   \\\n    \u0026amp;gt;                                                                       \\\n\u0026amp;gt; : std::true_type {}\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;CREATE_MEMBER_FUNC_SIG_CHECK:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Check for member function with given name AND signature.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; CREATE_MEMBER_FUNC_SIG_CHECK(func_name, func_sig, templ_postfix)    \\\n                                                                            \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T, typename = std::true_type\u0026amp;gt;\u0026lt;/span\u0026gt;                             \\\nstruct has_member_func_##templ_postfix : std::false_type {};                \\\n                                                                            \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T\u0026amp;gt;\u0026lt;/span\u0026gt;                                                        \\\nstruct has_member_func_##templ_postfix\u0026amp;lt;                                     \\\n    T, std::integral_constant\u0026amp;lt;                                              \\\n        bool                                                                \\\n        , sig_check\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;func_sig, \u0026amp;amp;T::func_name\u0026amp;gt;\u0026lt;/span\u0026gt;::value                         \\\n    \u0026amp;gt;                                                                       \\\n\u0026amp;gt; : std::true_type {}\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;CREATE_MEMBER_CLASS_CHECK:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Check for member class with given name.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; CREATE_MEMBER_CLASS_CHECK(class_name)               \\\n                                                            \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T, typename = std::true_type\u0026amp;gt;\u0026lt;/span\u0026gt;             \\\nstruct has_member_class_##class_name : std::false_type {};  \\\n                                                            \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T\u0026amp;gt;\u0026lt;/span\u0026gt;                                        \\\nstruct has_member_class_##class_name\u0026amp;lt;                       \\\n    T                                                       \\\n    , std::integral_constant\u0026amp;lt;                               \\\n        bool                                                \\\n        , std::is_class\u0026amp;lt;                                    \\\n            typename got_type\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T::class_name\u0026amp;gt;\u0026lt;/span\u0026gt;::type \\\n        \u0026amp;gt;::value                                            \\\n    \u0026amp;gt;                                                       \\\n\u0026amp;gt; : std::true_type {}\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;CREATE_MEMBER_UNION_CHECK:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Check for member union with given name.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; CREATE_MEMBER_UNION_CHECK(union_name)               \\\n                                                            \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T, typename = std::true_type\u0026amp;gt;\u0026lt;/span\u0026gt;             \\\nstruct has_member_union_##union_name : std::false_type {};  \\\n                                                            \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T\u0026amp;gt;\u0026lt;/span\u0026gt;                                        \\\nstruct has_member_union_##union_name\u0026amp;lt;                       \\\n    T                                                       \\\n    , std::integral_constant\u0026amp;lt;                               \\\n        bool                                                \\\n        , std::is_union\u0026amp;lt;                                    \\\n            typename got_type\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T::union_name\u0026amp;gt;\u0026lt;/span\u0026gt;::type \\\n        \u0026amp;gt;::value                                            \\\n    \u0026amp;gt;                                                       \\\n\u0026amp;gt; : std::true_type {}\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;CREATE_MEMBER_ENUM_CHECK:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Check for member enum with given name.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; CREATE_MEMBER_ENUM_CHECK(enum_name)                 \\\n                                                            \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T, typename = std::true_type\u0026amp;gt;\u0026lt;/span\u0026gt;             \\\nstruct has_member_enum_##enum_name : std::false_type {};    \\\n                                                            \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T\u0026amp;gt;\u0026lt;/span\u0026gt;                                        \\\nstruct has_member_enum_##enum_name\u0026amp;lt;                         \\\n    T                                                       \\\n    , std::integral_constant\u0026amp;lt;                               \\\n        bool                                                \\\n        , std::is_enum\u0026amp;lt;                                     \\\n            typename got_type\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T::enum_name\u0026amp;gt;\u0026lt;/span\u0026gt;::type  \\\n        \u0026amp;gt;::value                                            \\\n    \u0026amp;gt;                                                       \\\n\u0026amp;gt; : std::true_type {}\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;CREATE_MEMBER_FUNC_CHECK:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Check for function with given name, any signature.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; CREATE_MEMBER_FUNC_CHECK(func)          \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T\u0026amp;gt;\u0026lt;/span\u0026gt;                            \\\nstruct has_member_func_##func {                 \\\n    static const bool value                     \\\n        = has_member_##func\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;T\u0026amp;gt;\u0026lt;/span\u0026gt;::value           \\\n        \u0026amp;amp;\u0026amp;amp; !has_member_var_##func\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;T\u0026amp;gt;\u0026lt;/span\u0026gt;::value     \\\n        \u0026amp;amp;\u0026amp;amp; !has_member_class_##func\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;T\u0026amp;gt;\u0026lt;/span\u0026gt;::value   \\\n        \u0026amp;amp;\u0026amp;amp; !has_member_union_##func\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;T\u0026amp;gt;\u0026lt;/span\u0026gt;::value   \\\n        \u0026amp;amp;\u0026amp;amp; !has_member_enum_##func\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;T\u0026amp;gt;\u0026lt;/span\u0026gt;::value    \\\n    ;                                           \\\n}\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;CREATE_MEMBER_CHECKS:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Create all the checks for one member.  Does NOT include func sig checks.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; CREATE_MEMBER_CHECKS(member)    \\\nCREATE_MEMBER_CHECK(member);            \\\nCREATE_MEMBER_VAR_CHECK(member);        \\\nCREATE_MEMBER_CLASS_CHECK(member);      \\\nCREATE_MEMBER_UNION_CHECK(member);      \\\nCREATE_MEMBER_ENUM_CHECK(member);       \\\nCREATE_MEMBER_FUNC_CHECK(member)\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Yet another way to do it in C++17 (inspired by \u0026lt;code\u0026gt;boost:hana\u0026lt;/code\u0026gt;).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This solution does not require \u0026lt;code\u0026gt;has_something\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; SFINAE type traits classes.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Solution\u0026lt;/h3\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;////////////////////////////////////////////\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// has_member implementation\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;////////////////////////////////////////////\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;type_traits\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; F\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;has_member_impl\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(F\u0026amp;amp;\u0026amp;amp; f)\u0026lt;/span\u0026gt; -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(f(std::declval\u0026amp;lt;T\u0026amp;gt;()), \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;has_member_impl\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(...)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;; }\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; has_member(T, EXPR) \\\n has_member_impl\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;T\u0026amp;gt;\u0026lt;/span\u0026gt;( [](auto\u0026amp;amp;\u0026amp;amp; obj)-\u0026amp;gt;decltype(obj.EXPR){} )\u0026lt;/span\u0026gt;\n\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h3\u0026gt;Test\u0026lt;/h3\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;////////////////////////////////////////////\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Test\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;////////////////////////////////////////////\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Example\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; Foo;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Bar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{}\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello from Example::toString()!\u0026quot;\u0026lt;/span\u0026gt;; }\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Example2\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; X;\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\nstd::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T* obj)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(has_member(T, toString()))\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; obj-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toString not defined\u0026quot;\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;has_member\u0026lt;/span\u0026gt;(Example, Foo), \n                  \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Example class must have Foo member\u0026quot;\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;has_member\u0026lt;/span\u0026gt;(Example, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Bar\u0026lt;/span\u0026gt;()), \n                  \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Example class must have Bar() member function\u0026quot;\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(!\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;has_member\u0026lt;/span\u0026gt;(Example, ZFoo), \n                  \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Example class must not have ZFoo member.\u0026quot;\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(!\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;has_member\u0026lt;/span\u0026gt;(Example, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ZBar\u0026lt;/span\u0026gt;()), \n                  \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Example class must not have ZBar() member function\u0026quot;\u0026lt;/span\u0026gt;);\n\n    Example e1;\n    Example2 e2;\n\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;e1: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;(\u0026amp;amp;e1) \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;e1: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;(\u0026amp;amp;e2) \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I wrote an answer to this in another thread that (unlike the solutions above) also checks inherited member functions:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/1966362/sfinae-to-check-for-inherited-member-functions/8752988#8752988\u0026quot;\u0026gt;SFINAE to check for inherited member functions\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here are some example from that solution:\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Example1:\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;We are checking for a member with the following signature: \n\u0026lt;code\u0026gt;T::const_iterator begin() const\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;has_const_begin\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026amp;amp;Yes)\u0026lt;/span\u0026gt;[1]\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026amp;amp;No)\u0026lt;/span\u0026gt;[2]\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; U\u0026amp;gt; \n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; Yes \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(U \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; * data, \n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; std::enable_if\u0026amp;lt;std::is_same\u0026amp;lt;\n                             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; U::const_iterator, \n                             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(data-\u0026amp;gt;begin())\n                    \u0026amp;gt;::value\u0026amp;gt;::type * = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; No \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(...)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; value = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(Yes) == \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(has_const_begin::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;((\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; std::remove_reference\u0026amp;lt;T\u0026amp;gt;::type*)\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;));\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Please notice that it even checks the constness of the method, and works with primitive types, as well. (I mean \u0026lt;code\u0026gt;has_const_begin\u0026amp;lt;int\u0026amp;gt;::value\u0026lt;/code\u0026gt; is false and doesn\u0026apos;t cause a compile-time error.) \u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Example 2\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Now we are looking for the signature: \u0026lt;code\u0026gt;void foo(MyClass\u0026amp;amp;, unsigned)\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;has_foo\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026amp;amp;Yes)\u0026lt;/span\u0026gt;[1]\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026amp;amp;No)\u0026lt;/span\u0026gt;[2]\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; U\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; Yes \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(U * data, MyClass* arg1 = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; std::enable_if\u0026amp;lt;std::is_void\u0026amp;lt;\n                             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(data-\u0026amp;gt;foo(*arg1, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1u\u0026lt;/span\u0026gt;))\n                    \u0026amp;gt;::value\u0026amp;gt;::type * = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; No \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(...)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; value = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(Yes) == \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(has_foo::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;((\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; std::remove_reference\u0026amp;lt;T\u0026amp;gt;::type*)\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;));\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Please notice that MyClass doesn\u0026apos;t has to be default constructible or to satisfy any special concept. The technique works with template members, as well.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I am eagerly waiting opinions regarding this.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is the most concise way I found in C++20, which is very close from your question:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\nstd::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T* obj)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;requires\u0026lt;/span\u0026gt; { obj-\u0026amp;gt;toString(); })\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; obj-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toString not defined\u0026quot;\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;See it live on godbolt: \u0026lt;a href=\u0026quot;https://gcc.godbolt.org/z/5jb1d93Ms\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://gcc.godbolt.org/z/5jb1d93Ms\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The standard C++ solution presented here by litb will not work as expected if the method happens to be defined in a base class. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For a solution that handles this situation refer to :\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In Russian :\n\u0026lt;a href=\u0026quot;http://www.rsdn.ru/forum/message/2759773.1.aspx\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://www.rsdn.ru/forum/message/2759773.1.aspx\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;English Translation by Roman.Perepelitsa : \n\u0026lt;a href=\u0026quot;http://groups.google.com/group/comp.lang.c++.moderated/tree/browse_frm/thread/4f7c7a96f9afbe44/c95a7b4c645e449f?pli=1\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://groups.google.com/group/comp.lang.c++.moderated/tree/browse_frm/thread/4f7c7a96f9afbe44/c95a7b4c645e449f?pli=1\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It is insanely clever. However one issue with this solutiion is that gives compiler errors if the type being tested is one that cannot be used as a base class (e.g. primitive types)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In Visual Studio, I noticed that if working with method having no arguments, an extra pair of redundant ( )  needs to be inserted around the argments to deduce( )  in the sizeof expression.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Now this was a \u0026lt;em\u0026gt;nice\u0026lt;/em\u0026gt; little puzzle - great question!\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here\u0026apos;s an alternative to \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/257288/possible-for-c-template-to-check-for-a-functions-existence#257382\u0026quot;\u0026gt;Nicola Bonelli\u0026apos;s solution\u0026lt;/a\u0026gt; that does not rely on the non-standard \u0026lt;code\u0026gt;typeof\u0026lt;/code\u0026gt; operator.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Unfortunately, it does not work on GCC (MinGW) 3.4.5 or Digital Mars 8.42n, but it does work on all versions of MSVC (including VC6) and on Comeau C++.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The longer comment block has the details on how it works (or is supposed to work).  As it says, I\u0026apos;m not sure which behavior is standards compliant - I\u0026apos;d welcome commentary on that.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;update - 7 Nov 2008:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It looks like while this code is syntactically correct, the behavior that MSVC and Comeau C++ show does not follow the standard (thanks to \u0026lt;a href=\u0026quot;https://stackoverflow.com/users/4727/leon-timmermans\u0026quot;\u0026gt;Leon Timmermans\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;https://stackoverflow.com/users/34509/litb\u0026quot;\u0026gt;litb\u0026lt;/a\u0026gt; for pointing me in the right direction).  The C++03 standard says the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;14.6.2 Dependent names [temp.dep]\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;Paragraph 3\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;In the definition of a class template\n  or a member of a class template, if a\n  base class of the class template\n  depends on a template-parameter, the\n  base class scope is not examined\n  during unqualified name lookup either\n  at the point of definition of the\n  class template or member or during an\n  instantiation of the class template or\n  member.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;So, it looks like that when MSVC or Comeau consider the \u0026lt;code\u0026gt;toString()\u0026lt;/code\u0026gt; member function of \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; performing name lookup at the call site in \u0026lt;code\u0026gt;doToString()\u0026lt;/code\u0026gt; when the template is instantiated, that is incorrect (even though it\u0026apos;s actually the behavior I was looking for in this case).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The behavior of GCC and Digital Mars looks to be correct - in both cases the non-member \u0026lt;code\u0026gt;toString()\u0026lt;/code\u0026gt; function is bound to the call.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Rats - I thought I might have found a clever solution, instead I uncovered a couple compiler bugs...\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Hello\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Generic\u0026lt;/span\u0026gt; {};\n\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// the following namespace keeps the toString() method out of\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  most everything - except the other stuff in this\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  compilation unit\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n    \u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toString not defined\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;optionalToStringImpl\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; T\n    {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;doToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// in theory, the name lookup for this call to \u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  toString() should find the toString() in \u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  the base class T if one exists, but if one \u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  doesn\u0026apos;t exist in the base class, it\u0026apos;ll \u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  find the free toString() function in \u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  the private namespace.\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This theory works for MSVC (all versions\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  from VC6 to VC9) and Comeau C++, but\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  does not work with MinGW 3.4.5 or \u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  Digital Mars 8.42n\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// I\u0026apos;m honestly not sure what the standard says \u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  is the correct behavior here - it\u0026apos;s sort \u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  of like ADL (Argument Dependent Lookup - \u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  also known as Koenig Lookup) but without\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  arguments (except the implied \u0026quot;this\u0026quot; pointer)\u0026lt;/span\u0026gt;\n\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;();\n        }\n    };\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T \u0026amp;amp; obj)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ugly, hacky cast...\u0026lt;/span\u0026gt;\n    optionalToStringImpl\u0026amp;lt;T\u0026amp;gt;* temp = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;reinterpret_cast\u0026lt;/span\u0026gt;\u0026amp;lt;optionalToStringImpl\u0026amp;lt;T\u0026amp;gt;*\u0026amp;gt;( \u0026amp;amp;obj);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; temp-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;doToString\u0026lt;/span\u0026gt;();\n}\n\n\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *argv[])\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    Hello helloObj;\n    Generic genericObj;\n\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;( helloObj) \u0026amp;lt;\u0026amp;lt; std::endl;\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;( genericObj) \u0026amp;lt;\u0026amp;lt; std::endl;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;An example using SFINAE and template partial specialization, by writing a \u0026lt;code\u0026gt;Has_foo\u0026lt;/code\u0026gt; concept check: \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;type_traits\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;{};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; b)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;C\u0026lt;/span\u0026gt;{\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; b)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;D\u0026lt;/span\u0026gt;{\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;E\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; B{};\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// available in C++17 onwards as part of \u0026amp;lt;type_traits\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;...\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void_t\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; Has_foo: std::false_type{};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Has_foo\u0026lt;/span\u0026gt;\u0026amp;lt;T, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void_t\u0026lt;/span\u0026gt;\u0026amp;lt;\n    std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;enable_if_t\u0026lt;/span\u0026gt;\u0026amp;lt;\n        std::is_same\u0026amp;lt;\n            \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;, \n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;().\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;((\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;))\n        \u0026amp;gt;::value\n    \u0026amp;gt;\n\u0026amp;gt;\u0026amp;gt;: std::true_type{};\n\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; Has_foo\u0026amp;lt;A\u0026amp;gt;::value, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;A does not have a foo\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(Has_foo\u0026amp;lt;B\u0026amp;gt;::value, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;B has a foo\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; Has_foo\u0026amp;lt;C\u0026amp;gt;::value, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;C has a foo with the wrong return. \u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; Has_foo\u0026amp;lt;D\u0026amp;gt;::value, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;D has a foo with the wrong arguments. \u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(Has_foo\u0026amp;lt;E\u0026amp;gt;::value, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;E has a foo since it inherits from B\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;MSVC has the __if_exists and __if_not_exists keywords (\u0026lt;a href=\u0026quot;http://msdn.microsoft.com/en-us/library/x7wy9xh3(VS.80).aspx\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Doc\u0026lt;/a\u0026gt;). Together with the typeof-SFINAE approach of Nicola I could create a check for GCC and MSVC like the OP looked for.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Update:\u0026lt;/strong\u0026gt; Source can be found \u0026lt;a href=\u0026quot;https://github.com/nob13/sfserialization/blob/master/sfserialization/isdefault.h\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Here\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I modified the solution provided in \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/264088/2712152\u0026quot;\u0026gt;https://stackoverflow.com/a/264088/2712152\u0026lt;/a\u0026gt; to make it a bit more general. Also since it doesn\u0026apos;t use any of the new C++11 features we can use it with old compilers and should also work with msvc. But the compilers should enable C99 to use this since it uses variadic macros.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The following macro can be used to check if a particular class has a particular typedef or not.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/** \n * @class      : HAS_TYPEDEF\n * @brief      : This macro will be used to check if a class has a particular\n * typedef or not.\n * @param typedef_name : Name of Typedef\n * @param name  : Name of struct which is going to be run the test for\n * the given particular typedef specified in typedef_name\n */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; HAS_TYPEDEF(typedef_name, name)                           \\\n   template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T\u0026amp;gt;\u0026lt;/span\u0026gt;                                          \\\n   struct name {                                                  \\\n      typedef char yes[1];                                        \\\n      typedef char no[2];                                         \\\n      template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename U\u0026amp;gt;\u0026lt;/span\u0026gt;                                       \\\n      struct type_check;                                          \\\n      template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename _1\u0026amp;gt;\u0026lt;/span\u0026gt;                                      \\\n      static yes\u0026amp;amp; chk(type_check\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename _1::typedef_name\u0026amp;gt;\u0026lt;/span\u0026gt;*);    \\\n      template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename\u0026amp;gt;\u0026lt;/span\u0026gt;                                         \\\n      static no\u0026amp;amp; chk(...);                                        \\\n      static bool const value = sizeof(chk\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;T\u0026amp;gt;\u0026lt;/span\u0026gt;(0)) == sizeof(yes); \\\n   }\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The following macro can be used to check if a particular class has a particular member function or not with any given number of arguments.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/** \n * @class      : HAS_MEM_FUNC\n * @brief      : This macro will be used to check if a class has a particular\n * member function implemented in the public section or not. \n * @param func : Name of Member Function\n * @param name : Name of struct which is going to be run the test for\n * the given particular member function name specified in func\n * @param return_type: Return type of the member function\n * @param ellipsis(...) : Since this is macro should provide test case for every\n * possible member function we use variadic macros to cover all possibilities\n */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; HAS_MEM_FUNC(func, name, return_type, ...)                \\\n   template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T\u0026amp;gt;\u0026lt;/span\u0026gt;                                          \\\n   struct name {                                                  \\\n      typedef return_type (T::*Sign)(__VA_ARGS__);                \\\n      typedef char yes[1];                                        \\\n      typedef char no[2];                                         \\\n      template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename U, U\u0026amp;gt;\u0026lt;/span\u0026gt;                                    \\\n      struct type_check;                                          \\\n      template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename _1\u0026amp;gt;\u0026lt;/span\u0026gt;                                      \\\n      static yes\u0026amp;amp; chk(type_check\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;Sign, \u0026amp;amp;_1::func\u0026amp;gt;\u0026lt;/span\u0026gt;*);              \\\n      template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename\u0026amp;gt;\u0026lt;/span\u0026gt;                                         \\\n      static no\u0026amp;amp; chk(...);                                        \\\n      static bool const value = sizeof(chk\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;T\u0026amp;gt;\u0026lt;/span\u0026gt;(0)) == sizeof(yes); \\\n   }\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;We can use the above 2 macros to perform the checks for has_typedef and has_mem_func as:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt; {\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; check;\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;check_function\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{}\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt; {\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;hello\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; b)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{}\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;hello\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{}\n};\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;HAS_MEM_FUNC\u0026lt;/span\u0026gt;(check_function, has_check_function, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;HAS_MEM_FUNC\u0026lt;/span\u0026gt;(hello, hello_check, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;HAS_MEM_FUNC\u0026lt;/span\u0026gt;(hello, hello_void_check, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;HAS_TYPEDEF\u0026lt;/span\u0026gt;(check, has_typedef_check);\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n  std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Check Function A:\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; has_check_function\u0026amp;lt;A\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl;\n  std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Check Function B:\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; has_check_function\u0026amp;lt;B\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl;\n  std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello Function A:\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; hello_check\u0026amp;lt;A\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl;\n  std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello Function B:\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; hello_check\u0026amp;lt;B\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl;\n  std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello void Function A:\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; hello_void_check\u0026amp;lt;A\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl;\n  std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello void Function B:\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; hello_void_check\u0026amp;lt;B\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl;\n  std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Check Typedef A:\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; has_typedef_check\u0026amp;lt;A\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl;\n  std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Check Typedef B:\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; has_typedef_check\u0026amp;lt;B\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Strange nobody suggested the following nice trick I saw once on this very site :\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;has_foo\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;S\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(...)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; };\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;derived\u0026lt;/span\u0026gt; : S, T {};\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; V, V\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;W\u0026lt;/span\u0026gt; {};\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; X\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; (\u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(W\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; (X::*)(), \u0026amp;amp;X::foo\u0026amp;gt; *))[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;];\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; (\u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(...))[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;];\n\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; value = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;\u0026amp;lt;derived\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)) == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You have to make sure T is a class. It seems that ambiguity in the lookup of foo is a substitution failure. I made it work on gcc, not sure if it is standard though.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The generic template that can be used for checking if some \u0026quot;feature\u0026quot; is supported by the type:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;type_traits\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;TypeChecker\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Type\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_supported\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// these structs are used to recognize which version\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// of the two functions was chosen during overload resolution\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;supported\u0026lt;/span\u0026gt; {};\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;not_supported\u0026lt;/span\u0026gt; {};\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// this overload of chk will be ignored by SFINAE principle\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// if TypeChecker\u0026amp;lt;Type_\u0026amp;gt; is invalid type\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Type_\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; supported \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;chk\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; std::decay\u0026amp;lt;TypeChecker\u0026amp;lt;Type_\u0026amp;gt;\u0026amp;gt;::type *)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ellipsis has the lowest conversion rank, so this overload will be\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// chosen during overload resolution only if the template overload above is ignored\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Type_\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; not_supported \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;chk\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(...)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// if the template overload of chk is chosen during\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// overload resolution then the feature is supported\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// if the ellipses overload is chosen the the feature is not supported\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; value = std::is_same\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;chk\u0026lt;/span\u0026gt;\u0026amp;lt;Type\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;)),supported\u0026amp;gt;::value;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The template that checks whether there is a method \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; that is compatible with signature \u0026lt;code\u0026gt;double(const char*)\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// if T doesn\u0026apos;t have foo method with the signature that allows to compile the bellow\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// expression then instantiating this template is Substitution Failure (SF)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// which Is Not An Error (INAE) if this happens during overload resolution\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; has_foo = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;().\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*\u0026amp;gt;())));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Examples\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// types that support has_foo\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;struct1\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; };            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// exact signature match\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;struct2\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string \u0026amp;amp;str)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; }; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// compatible signature\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;struct3\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(...)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; };                    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// compatible ellipsis signature\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;struct4\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n                 \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T t)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; };                    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// compatible template signature\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// types that do not support has_foo\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;struct5\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;        \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; }; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// returns void\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;struct6\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; }; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// std::string can\u0026apos;t be converted to double\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;struct7\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;      \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(      \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; }; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// const char* can\u0026apos;t be converted to int*\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;struct8\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;      \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; }; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// there is no foo method\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    std::cout \u0026amp;lt;\u0026amp;lt; std::boolalpha;\n\n    std::cout \u0026amp;lt;\u0026amp;lt; is_supported\u0026amp;lt;has_foo, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;    \u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false\u0026lt;/span\u0026gt;\n    std::cout \u0026amp;lt;\u0026amp;lt; is_supported\u0026amp;lt;has_foo, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; \u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false\u0026lt;/span\u0026gt;\n\n    std::cout \u0026amp;lt;\u0026amp;lt; is_supported\u0026amp;lt;has_foo, struct1\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n    std::cout \u0026amp;lt;\u0026amp;lt; is_supported\u0026amp;lt;has_foo, struct2\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n    std::cout \u0026amp;lt;\u0026amp;lt; is_supported\u0026amp;lt;has_foo, struct3\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n    std::cout \u0026amp;lt;\u0026amp;lt; is_supported\u0026amp;lt;has_foo, struct4\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n\n    std::cout \u0026amp;lt;\u0026amp;lt; is_supported\u0026amp;lt;has_foo, struct5\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false\u0026lt;/span\u0026gt;\n    std::cout \u0026amp;lt;\u0026amp;lt; is_supported\u0026amp;lt;has_foo, struct6\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false\u0026lt;/span\u0026gt;\n    std::cout \u0026amp;lt;\u0026amp;lt; is_supported\u0026amp;lt;has_foo, struct7\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false\u0026lt;/span\u0026gt;\n    std::cout \u0026amp;lt;\u0026amp;lt; is_supported\u0026amp;lt;has_foo, struct8\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://coliru.stacked-crooked.com/a/83c6a631ed42cea4\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;http://coliru.stacked-crooked.com/a/83c6a631ed42cea4\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I know that this question is years old, but I think it would useful for people like me to have a more complete updated answer that also works for \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt; overloaded methods such as \u0026lt;code\u0026gt;std::vector\u0026amp;lt;\u0026amp;gt;::begin\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Based on that \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/257382/4602726\u0026quot;\u0026gt;answer\u0026lt;/a\u0026gt; and that \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/63818399/4602726\u0026quot;\u0026gt;answer\u0026lt;/a\u0026gt; from my follow up question, here\u0026apos;s a more complete answer. Note that this will only work with C++11 and higher.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;EmptyClass\u0026lt;/span\u0026gt;{};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;has_begin\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;has_begin\u0026lt;/span\u0026gt;() = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;;\n    \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;one\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; x[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]; };\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;two\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; x[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;]; };\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; C\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; one \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;(std::declval\u0026amp;lt;C \u0026amp;amp;\u0026amp;gt;().begin())) * )\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; C\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; two \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(...)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;    \n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; value = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)) == \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(one);\n};\n    \n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *argv[])\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    std::cout \u0026amp;lt;\u0026amp;lt; std::boolalpha;\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;vector\u0026amp;lt;int\u0026amp;gt;::begin() exists: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; has_begin\u0026amp;lt;std::vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl;\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;EmptyClass::begin() exists: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; has_begin\u0026amp;lt;EmptyClass\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Or the shorter version:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;EmptyClass\u0026lt;/span\u0026gt;{};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; has_begin : std::false_type {};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;has_begin\u0026lt;/span\u0026gt;\u0026amp;lt;T, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;T \u0026amp;amp;\u0026amp;gt;().\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;()))\u0026amp;gt; : std::true_type {};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *argv[])\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    std::cout \u0026amp;lt;\u0026amp;lt; std::boolalpha;\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;vector\u0026amp;lt;int\u0026amp;gt;::begin() exists: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; has_begin\u0026amp;lt;std::vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl;\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;EmptyClass exists: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; has_begin\u0026amp;lt;EmptyClass\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Note that here a complete sample call must be provided. This means that if we tested for the \u0026lt;code\u0026gt;resize\u0026lt;/code\u0026gt; method\u0026apos;s existence then we would have put \u0026lt;code\u0026gt;resize(0)\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Deep magic explanation\u0026lt;/strong\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The first answer posted of this question used \u0026lt;code\u0026gt;test( decltype(\u0026amp;amp;C::helloworld) )\u0026lt;/code\u0026gt;; however this is problematic when the method it is testing is ambiguous due const overloading, thus making the substitution attempt fail.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;To solve this ambiguity we use a void statement which can take any parameters because it is always translated into a \u0026lt;code\u0026gt;noop\u0026lt;/code\u0026gt; and thus the ambiguity is nullified and the call is valid as long as the method exists:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;has_begin\u0026amp;lt;T, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;T \u0026amp;amp;\u0026amp;gt;().\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;()))\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Here\u0026apos;s what\u0026apos;s happening in order:\nWe use \u0026lt;code\u0026gt;std::declval\u0026amp;lt;T \u0026amp;amp;\u0026amp;gt;()\u0026lt;/code\u0026gt; to create a callable value for which \u0026lt;code\u0026gt;begin\u0026lt;/code\u0026gt; can then be called. After that the value of \u0026lt;code\u0026gt;begin\u0026lt;/code\u0026gt; is passed as a parameter to a void statement. We then retrieve the type of that void expression using the builtin \u0026lt;code\u0026gt;decltype\u0026lt;/code\u0026gt; so that it can be used as a template type argument. If \u0026lt;code\u0026gt;begin\u0026lt;/code\u0026gt; doesn\u0026apos;t exist then the substitution is invalid and as per SFINAE the other declaration is used instead.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;How about this solution?\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;type_traits\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; U, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; hasToString : std::false_type { };\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; U\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;hasToString\u0026lt;/span\u0026gt;\u0026amp;lt;U,\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; std::enable_if\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026amp;amp;U::toString))\u0026amp;gt;::type\n\u0026amp;gt; : std::true_type { };\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are a lot of answers here, but I failed, to find a version, that performs \u0026lt;em\u0026gt;real\u0026lt;/em\u0026gt; method resolution ordering, while not using any of the newer c++ features (only using c++98 features).\u0026lt;br\u0026gt;\nNote: This version is tested and working with vc++2013, g++ 5.2.0 and the onlline compiler.\u0026lt;br\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So I came up with a version, that only uses sizeof():\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; T \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;fake_void\u0026lt;/span\u0026gt; { };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; T \u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;,(T \u0026amp;amp;,fake_void);\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; T \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;,(T \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026amp;amp;,fake_void);\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; T \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;volatile\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;,(T \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;volatile\u0026lt;/span\u0026gt; \u0026amp;amp;,fake_void);\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; T \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;volatile\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;,(T \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;volatile\u0026lt;/span\u0026gt; \u0026amp;amp;,fake_void);\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;yes\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; v[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;no\u0026lt;/span\u0026gt;  { \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; v[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;]; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;yes_no\u0026lt;/span\u0026gt;:yes{};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;yes_no\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;\u0026amp;gt;:no{};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;has_awesome_member\u0026lt;/span\u0026gt; {\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; U\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; yes_no\u0026amp;lt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;((\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;U\u0026amp;gt;().\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;awesome_member\u0026lt;/span\u0026gt;(),\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fake_void\u0026lt;/span\u0026gt;()\n  ))!=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;check\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;);\n \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; no \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;check\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(...)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt;{value=\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;check\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)) == \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(yes)};\n};\n\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;awesome_member\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt; { };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;foo_void\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;awesome_member\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;wrong_params\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;awesome_member\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; };\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(has_awesome_member\u0026amp;lt;foo\u0026amp;gt;::value,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(!has_awesome_member\u0026amp;lt;bar\u0026amp;gt;::value,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(has_awesome_member\u0026amp;lt;foo_void\u0026amp;gt;::value,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(!has_awesome_member\u0026amp;lt;wrong_params\u0026amp;gt;::value,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Live demo (with extended return type checking and vc++2010 workaround): \u0026lt;a href=\u0026quot;http://cpp.sh/5b2vs\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;http://cpp.sh/5b2vs\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;No source, as I came up with it myself.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When running the Live demo on the g++ compiler, please note that array sizes of 0 are allowed, meaning that the static_assert used will not trigger a compiler error, even when it fails.\u0026lt;br\u0026gt;\nA commonly used work-around is to replace the \u0026apos;typedef\u0026apos; in the macro with \u0026apos;extern\u0026apos;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;My take: to universally determine if something is callable without making verbose type traits for each and every one, or using experimental features, or long code:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Callable, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;... Args, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;Callable\u0026amp;gt;()(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;Args\u0026amp;gt;()...))\u0026amp;gt;\nstd::true_type \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;isCallableImpl\u0026lt;/span\u0026gt;(Callable, Args...) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; {}; }\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::false_type \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;isCallableImpl\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(...)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; {}; }\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;... Args, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Callable\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;isCallable\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Callable callable)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;isCallableImpl\u0026lt;/span\u0026gt;(callable, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;Args\u0026amp;gt;()...)){};\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Usage:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; TO_STRING_TEST = [](\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; in) -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;()) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; {}; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; TO_STRING_WORKS = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;isCallable\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;(TO_STRING_TEST);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is my version that handles all possible member function overloads with arbitrary arity, including template member functions, possibly with default arguments. It distinguishes 3 mutually exclusive scenarios when making a member function call to some class type, with given arg types: (1) valid, or (2) ambiguous, or (3) non-viable. Example usage:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;HAS_MEM\u0026lt;/span\u0026gt;(bar)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;HAS_MEM_FUN_CALL\u0026lt;/span\u0026gt;(bar)\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;\n{\n   \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n   \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n   \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T \u0026amp;gt;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; std::enable_if\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; std::is_integral\u0026amp;lt;T\u0026amp;gt;::value \u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;type\n   \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T\u0026amp;amp;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{}\n\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T \u0026amp;gt;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; std::enable_if\u0026amp;lt; std::is_integral\u0026amp;lt;T\u0026amp;gt;::value \u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;type\n   \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::vector\u0026amp;lt;T\u0026amp;gt;\u0026amp;amp;, T*)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{}\n\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T \u0026amp;gt;\n   \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string\u0026amp;amp;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{}\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now you can use it like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; * argv[])\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;( has_mem_bar\u0026amp;lt;test\u0026amp;gt;::value , \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;( has_valid_mem_fun_call_bar\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;*,\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt;)\u0026amp;gt;::value , \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;( has_valid_mem_fun_call_bar\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(std::string\u0026amp;amp;,\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt;)\u0026amp;gt;::value , \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;( has_valid_mem_fun_call_bar\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(std::vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;*)\u0026amp;gt;::value , \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;( has_no_viable_mem_fun_call_bar\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(std::vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;\u0026amp;gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;*)\u0026amp;gt;::value , \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;( has_valid_mem_fun_call_bar\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026amp;gt;::value , \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;( std::is_same\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;,result_of_mem_fun_call_bar\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026amp;gt;::type\u0026amp;gt;::value , \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;( has_valid_mem_fun_call_bar\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;)\u0026amp;gt;::value , \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; has_valid_mem_fun_call_bar\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026amp;gt;::value , \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; has_ambiguous_mem_fun_call_bar\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;)\u0026amp;gt;::value , \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;( has_ambiguous_mem_fun_call_bar\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt;)\u0026amp;gt;::value , \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;( has_viable_mem_fun_call_bar\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt;)\u0026amp;gt;::value , \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;( has_viable_mem_fun_call_bar\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026amp;gt;::value , \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;( has_no_viable_mem_fun_call_bar\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026amp;gt;::value , \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here is the code, written in c++11, however, you can easily port it (with minor tweaks) to non-c++11 that has typeof extensions (e.g. gcc). You can replace the HAS_MEM macro with your own.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;pragma\u0026lt;/span\u0026gt; once\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __cplusplus \u0026amp;gt;= 201103\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;utility\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;type_traits\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; HAS_MEM(mem)                                                                                     \\\n                                                                                                     \\\ntemplate \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename T \u0026amp;gt;\u0026lt;/span\u0026gt;                                                                               \\\nstruct has_mem_##mem                                                                                  \\\n{                                                                                                     \\\n  struct yes {};                                                                                     \\\n  struct no  {};                                                                                     \\\n                                                                                                     \\\n  struct ambiguate_seed { char mem; };                                                               \\\n  template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename U \u0026amp;gt;\u0026lt;/span\u0026gt; struct ambiguate : U, ambiguate_seed {};                                   \\\n                                                                                                     \\\n  template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename U, typename = decltype(\u0026amp;amp;U::mem) \u0026amp;gt;\u0026lt;/span\u0026gt; static constexpr no  test(int);              \\\n  template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename                                 \u0026amp;gt;\u0026lt;/span\u0026gt; static constexpr yes test(...);              \\\n                                                                                                     \\\n  static bool constexpr value = std::is_same\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;decltype(test\u0026amp;lt; ambiguate\u0026amp;lt;T\u0026amp;gt;\u0026lt;/span\u0026gt; \u0026amp;gt;(0)),yes\u0026amp;gt;::value ;         \\\n  typedef std::integral_constant\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;bool,value\u0026amp;gt;\u0026lt;/span\u0026gt;    type;                                                \\\n};\u0026lt;/span\u0026gt;\n\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; HAS_MEM_FUN_CALL(memfun)                                                                         \\\n                                                                                                     \\\ntemplate \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename Signature \u0026amp;gt;\u0026lt;/span\u0026gt;                                                                       \\\nstruct has_valid_mem_fun_call_##memfun;                                                               \\\n                                                                                                     \\\ntemplate \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename T, typename... Args \u0026amp;gt;\u0026lt;/span\u0026gt;                                                             \\\nstruct has_valid_mem_fun_call_##memfun\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; T(Args...) \u0026amp;gt;\u0026lt;/span\u0026gt;                                                  \\\n{                                                                                                     \\\n  struct yes {};                                                                                     \\\n  struct no  {};                                                                                     \\\n                                                                                                     \\\n  template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename U, bool = has_mem_##memfun\u0026amp;lt;U\u0026amp;gt;\u0026lt;/span\u0026gt;::value \u0026amp;gt;                                         \\\n  struct impl                                                                                        \\\n  {                                                                                                  \\\n     template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename V, typename = decltype(std::declval\u0026amp;lt;V\u0026amp;gt;\u0026lt;/span\u0026gt;().memfun(std::declval\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;Args\u0026amp;gt;\u0026lt;/span\u0026gt;()...)) \u0026amp;gt; \\\n     struct test_result { using type = yes; };                                                       \\\n                                                                                                     \\\n     template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename V \u0026amp;gt;\u0026lt;/span\u0026gt; static constexpr typename test_result\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;V\u0026amp;gt;\u0026lt;/span\u0026gt;::type test(int);               \\\n     template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename   \u0026amp;gt;\u0026lt;/span\u0026gt; static constexpr                            no test(...);               \\\n                                                                                                     \\\n     static constexpr bool value = std::is_same\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;decltype(test\u0026amp;lt;U\u0026amp;gt;\u0026lt;/span\u0026gt;(0)),yes\u0026amp;gt;::value;                    \\\n     using type = std::integral_constant\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;bool, value\u0026amp;gt;\u0026lt;/span\u0026gt;;                                               \\\n  };                                                                                                 \\\n                                                                                                     \\\n  template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename U \u0026amp;gt;\u0026lt;/span\u0026gt;                                                                            \\\n  struct impl\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;U,false\u0026amp;gt;\u0026lt;/span\u0026gt; : std::false_type {};                                                         \\\n                                                                                                     \\\n  static constexpr bool value = impl\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;T\u0026amp;gt;\u0026lt;/span\u0026gt;::value;                                                      \\\n  using type = std::integral_constant\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;bool, value\u0026amp;gt;\u0026lt;/span\u0026gt;;                                                  \\\n};                                                                                                    \\\n                                                                                                     \\\ntemplate \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename Signature \u0026amp;gt;\u0026lt;/span\u0026gt;                                                                       \\\nstruct has_ambiguous_mem_fun_call_##memfun;                                                           \\\n                                                                                                     \\\ntemplate \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename T, typename... Args \u0026amp;gt;\u0026lt;/span\u0026gt;                                                             \\\nstruct has_ambiguous_mem_fun_call_##memfun\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; T(Args...) \u0026amp;gt;\u0026lt;/span\u0026gt;                                              \\\n{                                                                                                     \\\n  struct ambiguate_seed { void memfun(...); };                                                       \\\n                                                                                                     \\\n  template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; class U, bool = has_mem_##memfun\u0026amp;lt;U\u0026amp;gt;\u0026lt;/span\u0026gt;::value \u0026amp;gt;                                            \\\n  struct ambiguate : U, ambiguate_seed                                                               \\\n  {                                                                                                  \\\n    using ambiguate_seed::memfun;                                                                    \\\n    using U::memfun;                                                                                 \\\n  };                                                                                                 \\\n                                                                                                     \\\n  template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; class U \u0026amp;gt;\u0026lt;/span\u0026gt;                                                                               \\\n  struct ambiguate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;U,false\u0026amp;gt;\u0026lt;/span\u0026gt; : ambiguate_seed {};                                                     \\\n                                                                                                     \\\n  static constexpr bool value = not has_valid_mem_fun_call_##memfun\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; ambiguate\u0026amp;lt;T\u0026amp;gt;\u0026lt;/span\u0026gt;(Args...) \u0026amp;gt;::value; \\\n  using type = std::integral_constant\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;bool, value\u0026amp;gt;\u0026lt;/span\u0026gt;;                                                  \\\n};                                                                                                    \\\n                                                                                                     \\\ntemplate \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename Signature \u0026amp;gt;\u0026lt;/span\u0026gt;                                                                       \\\nstruct has_viable_mem_fun_call_##memfun;                                                              \\\n                                                                                                     \\\ntemplate \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename T, typename... Args \u0026amp;gt;\u0026lt;/span\u0026gt;                                                             \\\nstruct has_viable_mem_fun_call_##memfun\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; T(Args...) \u0026amp;gt;\u0026lt;/span\u0026gt;                                                 \\\n{                                                                                                     \\\n  static constexpr bool value = has_valid_mem_fun_call_##memfun\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;T(Args...)\u0026amp;gt;\u0026lt;/span\u0026gt;::value                   \\\n                             or has_ambiguous_mem_fun_call_##memfun\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;T(Args...)\u0026amp;gt;\u0026lt;/span\u0026gt;::value;              \\\n  using type = std::integral_constant\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;bool, value\u0026amp;gt;\u0026lt;/span\u0026gt;;                                                  \\\n};                                                                                                    \\\n                                                                                                     \\\ntemplate \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename Signature \u0026amp;gt;\u0026lt;/span\u0026gt;                                                                       \\\nstruct has_no_viable_mem_fun_call_##memfun;                                                           \\\n                                                                                                     \\\ntemplate \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename T, typename... Args \u0026amp;gt;\u0026lt;/span\u0026gt;                                                             \\\nstruct has_no_viable_mem_fun_call_##memfun \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; T(Args...) \u0026amp;gt;\u0026lt;/span\u0026gt;                                             \\\n{                                                                                                     \\\n  static constexpr bool value = not has_viable_mem_fun_call_##memfun\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;T(Args...)\u0026amp;gt;\u0026lt;/span\u0026gt;::value;             \\\n  using type = std::integral_constant\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;bool, value\u0026amp;gt;\u0026lt;/span\u0026gt;;                                                  \\\n};                                                                                                    \\\n                                                                                                     \\\ntemplate \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename Signature \u0026amp;gt;\u0026lt;/span\u0026gt;                                                                       \\\nstruct result_of_mem_fun_call_##memfun;                                                               \\\n                                                                                                     \\\ntemplate \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename T, typename... Args \u0026amp;gt;\u0026lt;/span\u0026gt;                                                             \\\nstruct result_of_mem_fun_call_##memfun\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; T(Args...) \u0026amp;gt;\u0026lt;/span\u0026gt;                                                  \\\n{                                                                                                     \\\n  using type = decltype(std::declval\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;T\u0026amp;gt;\u0026lt;/span\u0026gt;().memfun(std::declval\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;Args\u0026amp;gt;\u0026lt;/span\u0026gt;()...));                          \\\n};\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;endif\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You can skip all the metaprogramming in C++14, and just write this using \u0026lt;a href=\u0026quot;http://fit.readthedocs.io/en/latest/include/fit/conditional.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;fit::conditional\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; from the \u0026lt;a href=\u0026quot;https://github.com/pfultz2/Fit\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Fit\u0026lt;/a\u0026gt; library:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\nstd::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T* x)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; fit::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;conditional\u0026lt;/span\u0026gt;(\n        [](\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt;* obj) -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(obj-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;()) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; obj-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;(); },\n        [](\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt;*) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toString not defined\u0026quot;\u0026lt;/span\u0026gt;; }\n    )(x);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You can also create the function directly from the lambdas as well:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;FIT_STATIC_LAMBDA_FUNCTION\u0026lt;/span\u0026gt;(optionalToString) = fit::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;conditional\u0026lt;/span\u0026gt;(\n    [](\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt;* obj) -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(obj-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;(), std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;()) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; obj-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;(); },\n    [](\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt;*) -\u0026amp;gt; std::string { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toString not defined\u0026quot;\u0026lt;/span\u0026gt;; }\n);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;However, if you are using a compiler that doesn\u0026apos;t support generic lambdas, you will have to write separate function objects:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;withToString\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T* obj)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(obj-\u0026amp;gt;toString(), std::string())\u0026lt;/span\u0026gt;\n    \u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; obj-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;();\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;withoutToString\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\n    std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T*)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\n    \u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toString not defined\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;FIT_STATIC_FUNCTION\u0026lt;/span\u0026gt;(optionalToString) = fit::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;conditional\u0026lt;/span\u0026gt;(\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;withToString\u0026lt;/span\u0026gt;(),\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;withoutToString\u0026lt;/span\u0026gt;()\n);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Probably not as good as other examples, but this is what I came up with for C++11. This works for picking overloaded methods.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;... Args\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Pack\u0026lt;/span\u0026gt; {};\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; Proxy(T) ((T \u0026amp;amp;)(*(int *)(nullptr)))\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Class, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; ArgPack, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;nullptr_t\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; HasFoo\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { value = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt; };\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Class, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;... Args\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;HasFoo\u0026lt;/span\u0026gt;\u0026amp;lt;\n    Class,\n    Pack\u0026amp;lt;Args...\u0026amp;gt;,\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;((\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Proxy\u0026lt;/span\u0026gt;(Class).\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Proxy\u0026lt;/span\u0026gt;(Args)...)), \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;)\u0026amp;gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { value = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt; };\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Example usage\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n)\u0026lt;/span\u0026gt;         \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; n; }\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; SOME_CONDITION\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; c)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; n + c; }\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;endif\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; has_foo_int_char\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dispatcher\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dispatcher\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;\u0026amp;gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Object\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;exec\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Object \u0026amp;amp;object, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; c)\u0026lt;/span\u0026gt;\n    \u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; object.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(n) + c;\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dispatcher\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;\u0026amp;gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Object\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;exec\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Object \u0026amp;amp;object, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; c)\u0026lt;/span\u0026gt;\n    \u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; object.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(n, c);\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;runExample\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; Args = Pack\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;\u0026amp;gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { has_overload = HasFoo\u0026amp;lt;Object, Args\u0026amp;gt;::value };\n    Object object;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; Dispatcher\u0026amp;lt;has_overload\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;exec\u0026lt;/span\u0026gt;(object, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is an example of the working code.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; toStringFn = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T\u0026amp;gt;().\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;());\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;, toStringFn\u0026amp;lt;T\u0026amp;gt;* = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;\u0026amp;gt;\nstd::string \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T* obj, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; obj-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;();\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T* obj, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toString not defined\u0026quot;\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    A* a;\n    B* b;\n\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;(a, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) \u0026amp;lt;\u0026amp;lt; std::endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This is A\u0026lt;/span\u0026gt;\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;(b, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) \u0026amp;lt;\u0026amp;lt; std::endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// toString not defined\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;toStringFn\u0026amp;lt;T\u0026amp;gt;* = nullptr\u0026lt;/code\u0026gt; will enable the function which takes extra \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; argument which has a priority over function which takes \u0026lt;code\u0026gt;long\u0026lt;/code\u0026gt; when called with \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can use the same principle for the functions which returns \u0026lt;code\u0026gt;true\u0026lt;/code\u0026gt; if function is implemented.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;toStringExists\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T, toStringFn\u0026amp;lt;T\u0026amp;gt;* = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toStringExists\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\n}\n\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    A* a;\n    B* b;\n\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toStringExists\u0026lt;/span\u0026gt;\u0026amp;lt;A\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) \u0026amp;lt;\u0026amp;lt; std::endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toStringExists\u0026lt;/span\u0026gt;\u0026amp;lt;B\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) \u0026amp;lt;\u0026amp;lt; std::endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I had a similar problem:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A template class that may be derived from few base classes, some that have a certain member and others that do not.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I solved it similarly to the \u0026quot;typeof\u0026quot; (Nicola Bonelli\u0026apos;s) answer, but with decltype so it compiles and runs correctly on MSVS:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Generic\u0026lt;/span\u0026gt; {};    \n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;HasMember\u0026lt;/span\u0026gt; \n{\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;HasMember\u0026lt;/span\u0026gt;() : _a(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) {};\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; _a;\n};    \n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// SFINAE test\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;S\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; T\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::string b)\u0026lt;/span\u0026gt;\n  \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo2\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;(b,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n  }\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;protected\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo2\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::string b, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt; (T::_a))\u0026lt;/span\u0026gt;\n  \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; b + std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;to_string\u0026lt;/span\u0026gt;(T::_a);\n  }\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo2\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::string b, ...)\u0026lt;/span\u0026gt;\n  \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; b + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;No\u0026quot;\u0026lt;/span\u0026gt;;\n  }\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *argv[])\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  S\u0026amp;lt;HasMember\u0026amp;gt; d1;\n  S\u0026amp;lt;Generic\u0026amp;gt; d2;\n\n  std::cout \u0026amp;lt;\u0026amp;lt; d1.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;HasMember: \u0026quot;\u0026lt;/span\u0026gt;) \u0026amp;lt;\u0026amp;lt; std::endl;\n  std::cout \u0026amp;lt;\u0026amp;lt; d2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Generic: \u0026quot;\u0026lt;/span\u0026gt;) \u0026amp;lt;\u0026amp;lt; std::endl;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    "],"comment":["\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Of course it goes without saying that the template answer(s) below only work with compile-time information, i.e. T must have toString. If you pass in a subclass of T that \u0026lt;i\u0026gt;does\u0026lt;/i\u0026gt; define toString, but T does \u0026lt;i\u0026gt;not\u0026lt;/i\u0026gt;, you will be told toString is not defined.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/125663/alice-purcell\u0026quot; title=\u0026quot;12,114 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Alice Purcell\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment3808746_257288\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-09-02 09:50:53Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 2, 2010 at 9:50\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Possible Duplicate \u0026lt;a href=\u0026quot;http://stackoverflow.com/q/36079170/514235\u0026quot;\u0026gt;How to check if a member name (variable or function) exists in a class, with or without specifying type?\u0026lt;/a\u0026gt;, as it covers broader problem with C++03 to C++1y.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/514235/iammilind\u0026quot; title=\u0026quot;65,402 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;iammilind\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment59805126_257288\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-03-18 09:13:11Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 18, 2016 at 9:13\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Note that C++20 now permits to do that with concepts. See \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/58394556/c-concepts-can-i-have-a-constraint-requiring-a-function-be-present-in-a-clas\u0026quot; title=\u0026quot;c concepts can i have a constraint requiring a function be present in a clas\u0026quot;\u0026gt;stackoverflow.com/questions/58394556/\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;https://en.cppreference.com/w/cpp/language/constraints\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;en.cppreference.com/w/cpp/language/constraints\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/806286/etham\u0026quot; title=\u0026quot;2,720 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;etham\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment124106522_257288\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2021-12-02 21:07:33Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 2, 2021 at 21:07\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Although, I used the following for \u0026apos;one\u0026apos; and \u0026apos;two\u0026apos;:  typedef char Small; class Big{char dummy[2];}  to ensure no ambiguity about platform dependent variable size.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/23167/user23167\u0026quot; title=\u0026quot;485 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;user23167\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment116137_257382\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2008-11-02 21:40:21Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 2, 2008 at 21:40\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I doubt it exists on earth a platform with the sizeof(char) == sizeof(long)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/19630/nicola-bonelli\u0026quot; title=\u0026quot;7,973 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Nicola Bonelli\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment116141_257382\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2008-11-02 21:46:31Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 2, 2008 at 21:46\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I\u0026apos;m not entirely sure, but I don\u0026apos;t think this is portable. typeof is a GCC extension, this will not work on other compilers.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/4727/leon-timmermans\u0026quot; title=\u0026quot;29,808 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Leon Timmermans\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment116149_257382\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2008-11-02 21:52:31Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 2, 2008 at 21:52\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;typeof isn\u0026apos;t needed - char[sizeof(\u0026amp;amp;C::helloworld)] works as well. And to avoid sizeof(long)==sizeof(char), use a struct { char[2] };. It must have a size \u0026amp;gt;=2\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/15416/msalters\u0026quot; title=\u0026quot;168,160 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;MSalters\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment317655_257382\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-02-02 09:03:30Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 2, 2009 at 9:03\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Trivial, but took me a while to figure out:  replace \u0026lt;code\u0026gt;typeof\u0026lt;/code\u0026gt; by \u0026lt;code\u0026gt;decltype\u0026lt;/code\u0026gt; when using \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/C%2B%2B0x\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;C++0x\u0026lt;/a\u0026gt;, e.g., via -std=c++0x.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/680410/hrr\u0026quot; title=\u0026quot;1,767 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;hrr\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment7373012_257382\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-06-10 16:46:40Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 10, 2011 at 16:46\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;The advantage of \u0026lt;code\u0026gt;decltype\u0026lt;/code\u0026gt; over \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt; is also that a temporary is not introduced by specially crafted rules for function calls (so you don\u0026apos;t have to have access rights to the destructor of the return type and won\u0026apos;t cause an implicit instantiation if the return type is a class template instantiation).\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/34509/johannes-schaub-litb\u0026quot; title=\u0026quot;482,727 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Johannes Schaub - litb\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment35162960_9154394\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-04-11 17:29:52Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 11, 2014 at 17:29\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 3 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Microsoft has not implemented Expression SFINAE in it\u0026apos;s C++ compiler yet. Just figure I might help save some people time, as I was confused why this wasn\u0026apos;t working for me. Nice solution though, can\u0026apos;t wait to use it in Visual Studio!\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1917447/jonathan\u0026quot; title=\u0026quot;742 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Jonathan\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment44662879_9154394\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-01-26 06:22:51Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 26, 2015 at 6:22\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;It has to be said, that \u0026lt;code\u0026gt;static_assert(has_stream\u0026amp;lt;X, char\u0026amp;gt;() == true, \u0026quot;fail X\u0026quot;);\u0026lt;/code\u0026gt; will compile and not assert because char is convertable to int, so if that behavior is not wanted and want that all argument types match i dont know how that can be achieved?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/293195/gabriel\u0026quot; title=\u0026quot;8,201 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Gabriel\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment53694200_9154394\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-10-04 14:10:14Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 4, 2015 at 14:10\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;If you are as puzzled as I was on the two arguments to decltype: decltype really only takes one; the comma is an operator here. See \u0026lt;a href=\u0026quot;http://stackoverflow.com/questions/16044514/what-is-decltype-with-two-arguments\u0026quot; title=\u0026quot;what is decltype with two arguments\u0026quot;\u0026gt;stackoverflow.com/questions/16044514/\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2151404/andr%c3%a9\u0026quot; title=\u0026quot;520 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;André\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment71737008_9154394\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-02-17 06:06:36Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 17, 2017 at 6:06\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;This works perfectly in situations that require complete types, but in situations that don\u0026apos;t this will give false negatives for incomplete (forward declared) types.  I added a \u0026lt;code\u0026gt;sfinae_false\u0026lt;/code\u0026gt; counterpart and used a return type on the \u0026lt;code\u0026gt;long\u0026lt;/code\u0026gt; override that detected for the presence of a destructor.  This excluded types that were still incomplete or didn\u0026apos;t have public destructors.  Excluding non-public destructors was acceptable for me.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1735922/john\u0026quot; title=\u0026quot;7,164 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;John\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment75258501_9154394\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-05-22 18:23:10Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 22, 2017 at 18:23\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I like how \u0026lt;code\u0026gt;type_check\u0026lt;/code\u0026gt; is used to ensure that the signatures agree exactly.  Is there a way to make it so that it will match any method which could be called in the manner that a method with signature \u0026lt;code\u0026gt;Sign\u0026lt;/code\u0026gt; could be called?  (E.g. if \u0026lt;code\u0026gt;Sign\u0026lt;/code\u0026gt; = \u0026lt;code\u0026gt;std::string(T::*)()\u0026lt;/code\u0026gt;, allow \u0026lt;code\u0026gt;std::string T::toString(int default = 42, ...)\u0026lt;/code\u0026gt; to match.)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/47984/j-random-hacker\u0026quot; title=\u0026quot;49,399 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;j_random_hacker\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment4541687_264088\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-11-17 01:37:18Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 17, 2010 at 1:37\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I just figures something out about this that wasn\u0026apos;t immediate obvious to me, so in case it helps others: chk isn\u0026apos;t and needn\u0026apos;t be defined! The sizeof operator determines the size of the output of chk without chk ever needing to be called.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/4928/scfrench\u0026quot; title=\u0026quot;8,114 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;SCFrench\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment5286295_264088\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-01-23 17:24:49Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 23, 2011 at 17:24\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@deek0146: Yes, \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; must not be a primitive type, because the pointer-to-method-of-T declaration is not subject to SFINAE and will error out for any non-class T. IMO the easiest solution is to combine with \u0026lt;code\u0026gt;is_class\u0026lt;/code\u0026gt; check from boost.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/201725/jan-hudec\u0026quot; title=\u0026quot;69,812 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Jan Hudec\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment13893435_264088\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-05-22 12:04:36Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 22, 2012 at 12:04\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;How can I make this work if my \u0026lt;code\u0026gt;toString\u0026lt;/code\u0026gt; is a templated function?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/60628/frank\u0026quot; title=\u0026quot;61,449 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Frank\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment16058983_264088\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-08-20 02:00:56Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 20, 2012 at 2:00\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Is this (or anything equivalent) in Boost?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/368896/dan-nissenbaum\u0026quot; title=\u0026quot;12,985 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Dan Nissenbaum\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment22291601_264088\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-03-29 06:24:08Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 29, 2013 at 6:24\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;more concise than 03\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3701358/zfy\u0026quot; title=\u0026quot;125 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;ZFY\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment107338648_22014784\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2020-03-13 11:20:57Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 13, 2020 at 11:20\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@ZFY I think that Boost.TTI works with C++03 too, but it\u0026apos;s the least elegant solution of the lot.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1364752/morwenn\u0026quot; title=\u0026quot;20,468 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Morwenn\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment107342945_22014784\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2020-03-13 14:01:10Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 13, 2020 at 14:01\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Is the C++20 solution really valid? I would like it - but it is refused by g++ and msvc - only accepted by clang.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/9099261/bernd\u0026quot; title=\u0026quot;1,969 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Bernd\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment107977844_22014784\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2020-04-04 20:17:06Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 4, 2020 at 20:17\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;at cppreference you can read: If a requires-expression contains invalid types or expressions in its requirements, and it does not appear within the declaration of a templated entity, then the program is ill-formed.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/9099261/bernd\u0026quot; title=\u0026quot;1,969 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Bernd\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment107978242_22014784\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2020-04-04 20:36:50Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 4, 2020 at 20:36\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@BerndBaumanns Really? I got it to work with GCC trunk: \u0026lt;a href=\u0026quot;https://godbolt.org/z/CBwZdE\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;godbolt.org/z/CBwZdE\u0026lt;/a\u0026gt; Maybe you\u0026apos;re right, I only checked that it worked but didn\u0026apos;t check whether it was legal according to the standard wording.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1364752/morwenn\u0026quot; title=\u0026quot;20,468 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Morwenn\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment107991035_22014784\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2020-04-05 11:51:45Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 5, 2020 at 11:51\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Just wondering, does this do anything that Konrad Rudolph\u0026apos;s solution below does not do?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2067682/alastair-irvine\u0026quot; title=\u0026quot;1,116 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Alastair Irvine\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment30724847_3627243\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-12-12 14:52:58Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 12, 2013 at 14:52\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@AlastairIrvine, this solution hides all the logic inside, Konrad\u0026apos;s puts some of the burden on the user. Although short and much more readable, Konrad\u0026apos;s solution requires a separate template specialization for each class that has \u0026lt;code\u0026gt;toString\u0026lt;/code\u0026gt;. If you write a generic library, that wishes to work with any class out there (think of something like boost), then requiring the user to define additional specializations of some obscure templates might be unacceptable. Sometimes it\u0026apos;s preferable to write a very complicated code to keep the public interface as simple as it can be.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/102834/fireaphis\u0026quot; title=\u0026quot;6,470 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;FireAphis\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment30803728_3627243\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-12-14 23:37:25Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 14, 2013 at 23:37\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;This is simple and elegant, but strictly speaking does not answer OP\u0026apos;s question: you don\u0026apos;t enable the caller to \u0026lt;i\u0026gt;check\u0026lt;/i\u0026gt; for a function\u0026apos;s existence, you always \u0026lt;i\u0026gt;provide\u0026lt;/i\u0026gt; it. But nice anyway.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2311167/adrian-w\u0026quot; title=\u0026quot;4,078 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Adrian W\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment88689902_31860104\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-06-13 17:38:46Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 13, 2018 at 17:38\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@AdrianW, good point. I\u0026apos;ve updated my answer. I haven\u0026apos;t tested it though\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/146041/aaron-mcdaid\u0026quot; title=\u0026quot;25,537 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Aaron McDaid\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment88764646_31860104\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-06-15 18:49:51Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 15, 2018 at 18:49\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;In case it helps someone else, I couldn\u0026apos;t make this work without \u0026lt;code\u0026gt;template\u0026amp;lt;typename\u0026amp;gt;\u0026lt;/code\u0026gt; before the variadic overload: it was not getting considered for resolution.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/9926122/aponza\u0026quot; title=\u0026quot;492 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;aPonza\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment94608759_31860104\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-12-21 07:55:30Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 21, 2018 at 7:55\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Again, this is invalid C++11.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/4858640/peter\u0026quot; title=\u0026quot;2,779 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Peter\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment103028351_31860104\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-10-11 07:05:03Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 11, 2019 at 7:05\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Is it possible to extend it to detect non-member functions?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2430597/plasmacel\u0026quot; title=\u0026quot;7,849 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;plasmacel\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment69128596_30848101\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-12-04 14:31:50Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 4, 2016 at 14:31\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Yes, sure.  Look carefully at the examples: you basically provide an expression and check whether it\u0026apos;s valid.  Nothing requires this expression to be only about a member function call.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1353549/akim\u0026quot; title=\u0026quot;7,692 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;akim\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment69133427_30848101\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-12-04 18:36:50Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 4, 2016 at 18:36\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;N4502 (\u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf\u0026lt;/a\u0026gt;) is the way of the future... I was looking for a neat way of detecting things on types and N4502 is the way to go.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2812117/tlonuk\u0026quot; title=\u0026quot;395 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;tlonuk\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment72591446_30848101\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-03-11 15:04:52Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 11, 2017 at 15:04\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;you should prefer enum for traits instead of static constants : \u0026quot; Static constant members are lvalues,which forces the compiler to instantiate and allocate the definition for the static member. As a result, the computation is no longer limited to a pure \u0026quot;compile-time\u0026quot; effect.\u0026quot;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/12652/%c3%96zg%c3%bcr\u0026quot; title=\u0026quot;7,842 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Özgür\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment478900_257315\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-03-20 09:28:03Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 20, 2009 at 9:28\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026quot;Enumeration values aren\u0026apos;t lvalues(that is,they don\u0026apos;t have an address).So, when you pass them \u0026quot;by reference,\u0026quot; no static memory is used. It\u0026apos;s almost exactly as if you passed the computed value as a literal. These considerations motivate us to use enumeration values\u0026quot; C++ Templates:The Complete Guide\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/12652/%c3%96zg%c3%bcr\u0026quot; title=\u0026quot;7,842 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Özgür\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment478907_257315\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-03-20 09:29:28Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 20, 2009 at 9:29\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Comptrol: no, the cited passage doesn\u0026apos;t apply here since integer type static constants are a special case! They behave \u0026lt;i\u0026gt;exactly\u0026lt;/i\u0026gt; like an enum here and are the preferred way. The old enum hack was only necessary on compilers that didn\u0026apos;t follow the C++ standard.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1968/konrad-rudolph\u0026quot; title=\u0026quot;508,410 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Konrad Rudolph\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment486208_257315\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-03-23 09:07:01Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 23, 2009 at 9:07\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Roger Pate: Not quite. used in the program here is apparently synonymous with referenced. The prevailing reading of this passage, and the one implemented by all modern C++ compilers, is that you can take the \u0026lt;i\u0026gt;value\u0026lt;/i\u0026gt; of a static constant without needing to declare it (the previous sentence says this:  the member can appear in integral constant expressions ). You \u0026lt;i\u0026gt;only\u0026lt;/i\u0026gt; need to define it if you take its address (explicitly via \u0026lt;code\u0026gt;\u0026amp;amp;T::x\u0026lt;/code\u0026gt; or implicitly by binding it to a reference).\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1968/konrad-rudolph\u0026quot; title=\u0026quot;508,410 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Konrad Rudolph\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment2839421_257315\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-05-10 10:44:17Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 10, 2010 at 10:44\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026lt;a href=\u0026quot;http://stackoverflow.com/questions/13787490/how-do-you-use-type-traits-to-do-conditional-compilation/13787531\u0026quot;\u0026gt;Here is an example of how to use \u0026lt;code\u0026gt;type traits\u0026lt;/code\u0026gt; for conditional compilation in C++11\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/111307/bobobobo\u0026quot; title=\u0026quot;61,811 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;bobobobo\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment18960617_257315\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-12-09 13:04:14Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 9, 2012 at 13:04\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Does this handle private cases?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1559666/tower120\u0026quot; title=\u0026quot;4,637 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;tower120\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment37657264_23996349\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-06-22 19:17:12Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 22, 2014 at 19:17\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@tower120 I would have to experiment: how templates interact with private/public/protected is a bit obscure to me.  It will not matter where you invoke \u0026lt;code\u0026gt;has_to_string\u0026lt;/code\u0026gt; however.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1774667/yakk-adam-nevraumont\u0026quot; title=\u0026quot;251,284 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Yakk - Adam Nevraumont\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment37657364_23996349\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-06-22 19:22:42Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 22, 2014 at 19:22\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;but you know, if look from the other side... We can reach protected members from the Derived class. Maybe if put all this stuff INSIDE class, and convert from structs to constexpr functions...\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1559666/tower120\u0026quot; title=\u0026quot;4,637 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;tower120\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment37657635_23996349\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-06-22 19:38:43Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 22, 2014 at 19:38\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Here, look at this \u0026lt;a href=\u0026quot;http://coliru.stacked-crooked.com/a/ee94d16e7c07e093\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;coliru.stacked-crooked.com/a/ee94d16e7c07e093\u0026lt;/a\u0026gt; I just can\u0026apos;t make it constexpr\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1559666/tower120\u0026quot; title=\u0026quot;4,637 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;tower120\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment37657854_23996349\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-06-22 19:48:43Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 22, 2014 at 19:48\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@tower120 C++1y makes it work: \u0026lt;a href=\u0026quot;http://coliru.stacked-crooked.com/a/d8cdfff24a171394\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;coliru.stacked-crooked.com/a/d8cdfff24a171394\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1774667/yakk-adam-nevraumont\u0026quot; title=\u0026quot;251,284 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Yakk - Adam Nevraumont\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment38385805_23996349\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-07-14 18:23:58Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 14, 2014 at 18:23\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;do you have any idea why if we change \u0026lt;code\u0026gt;sig_check\u0026amp;lt;func_sig, \u0026amp;amp;T::func_name\u0026amp;gt;\u0026lt;/code\u0026gt; to free function checking : \u0026lt;code\u0026gt;sig_check\u0026amp;lt;func_sig, \u0026amp;amp;func_name\u0026amp;gt;\u0026lt;/code\u0026gt; it fails to build with \u0026quot;undeclared identifier\u0026quot; mentioning the name of the function we want to check ? because I would expect SFINAE to make it NOT an error, it does just that for members, why not for free functions ?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/893406/v-oddou\u0026quot; title=\u0026quot;6,218 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;v.oddou\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment46047338_6324863\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-03-06 06:40:26Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 6, 2015 at 6:40\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I assume it would have something to do with the fact that a free function isn\u0026apos;t a class or struct.  This technique of deducing the presence of a member really centers on the multiple inheritance mechanism in C++ forcing ambiguity between a stub class that only exists for the purpose of hosting the member you\u0026apos;re checking for vs the class you\u0026apos;re actually checking for the member in.  That\u0026apos;s an interesting question though, hadn\u0026apos;t thought about it.  You might check around for other C++11/14 member-check techniques, I\u0026apos;ve seen some clever things in the new standard.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/376331/brett-rossier\u0026quot; title=\u0026quot;3,350 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Brett Rossier\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment46081876_6324863\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-03-07 05:01:51Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 7, 2015 at 5:01\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Thanks for your answer, I think I might have to check more in depth that intel you give about inheritance, because until now I didn\u0026apos;t see any correlation between simply relying on SFINAE to make an expression that wouldn\u0026apos;t be correct expressing access to a member in a template type parameter, and multiple inheritance. But I completely believe that in C++ even distant concepts can bleed on each other. Now for free functions this question is interesting: \u0026lt;a href=\u0026quot;http://stackoverflow.com/questions/26744589/\u0026quot;\u0026gt;stackoverflow.com/questions/26744589\u0026lt;/a\u0026gt; T.C answer seems to use a trick of declaring a dummy to avoid the \u0026quot;undeclared identifier\u0026quot;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/893406/v-oddou\u0026quot; title=\u0026quot;6,218 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;v.oddou\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment46123828_6324863\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-03-09 01:39:49Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 9, 2015 at 1:39\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Is it possible to detect a private member?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1292791/prehistoricpenguin\u0026quot; title=\u0026quot;5,875 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;prehistoricpenguin\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment120381013_62292282\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2021-06-24 06:41:20Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 24, 2021 at 6:41\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@prehistoricpenguin It depends on where do you use \u0026lt;code\u0026gt;has_member\u0026lt;/code\u0026gt; macro. If you use it inside the class to check the private member existence, then yes, it does work. If you use that macro outside of class, for example in some function, then macro does not work. But, if you add this function to the \u0026lt;code\u0026gt;friend\u0026lt;/code\u0026gt; list, then it works.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1145526/dmytro-ovdiienko\u0026quot; title=\u0026quot;618 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Dmytro Ovdiienko\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment120387616_62292282\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2021-06-24 11:05:58Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 24, 2021 at 11:05\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Hmm, having developed my own version using that posts ideas, i found the idea has some other drawbacks so i removed the code from my answer again. One is that all functions have to be public in the target type. So you cannot check for a \u0026quot;f\u0026quot; function in this: \u0026lt;code\u0026gt;struct g { void f(); private: void f(int); };\u0026lt;/code\u0026gt; because one of the functions is private (this is because the code does \u0026lt;code\u0026gt;using g::f;\u0026lt;/code\u0026gt;, which makes it fail if any \u0026lt;code\u0026gt;f\u0026lt;/code\u0026gt; is not accessible).\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/34509/johannes-schaub-litb\u0026quot; title=\u0026quot;482,727 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Johannes Schaub - litb\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment914957_502552\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-07-08 19:56:32Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 8, 2009 at 19:56\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;No, it\u0026apos;s not standards compliant, though I think it will work in GCC if you turn on the -fpermissive option.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/4727/leon-timmermans\u0026quot; title=\u0026quot;29,808 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Leon Timmermans\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment120118_261262\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2008-11-04 22:50:27Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 4, 2008 at 22:50\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I know the comments don\u0026apos;t give a lot of room, but could you point to information on why it\u0026apos;s not standards compliant?  (I\u0026apos;m not arguing - I\u0026apos;m curious)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/12711/michael-burr\u0026quot; title=\u0026quot;322,355 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Michael Burr\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment120532_261262\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2008-11-05 05:30:55Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 5, 2008 at 5:30\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Mike B: the standard says in 3.10 p15: \u0026quot;If a program attempts to access the stored value of an object through an lvalue of other than one of the following types the behavior is undefined\u0026quot; and that list indeed doesn\u0026apos;t include the case you do.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/34509/johannes-schaub-litb\u0026quot; title=\u0026quot;482,727 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Johannes Schaub - litb\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment125393_261262\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2008-11-07 08:17:26Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 7, 2008 at 8:17\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;i\u0026apos;m not sure why it doesnt add another comment of me: your toString call is unqualified. so it will always call the free function and never the one in the base, since the baseclass is dependant on a template type parameter.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/34509/johannes-schaub-litb\u0026quot; title=\u0026quot;482,727 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Johannes Schaub - litb\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment125405_261262\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2008-11-07 08:27:13Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 7, 2008 at 8:27\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;hold on, i\u0026apos;ve got the explicit quote from the standard about this: 9.3.1/1: \u0026quot;If a nonstatic member function of a class X is called for an object that is not of type X, or of a type derived from X, the behavior is undefined.\u0026quot; This was just luck, someone cited it, and told me where he has it from :)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/34509/johannes-schaub-litb\u0026quot; title=\u0026quot;482,727 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Johannes Schaub - litb\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment140761_261262\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2008-11-15 18:18:08Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 15, 2008 at 18:18\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;If we default the second \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; with \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; then we can do \u0026lt;code\u0026gt;Has_foo\u0026amp;lt;T, decltype(std::declval\u0026amp;lt;T\u0026amp;gt;().foo(0, 0))\u0026amp;gt; : std::true_type {};\u0026lt;/code\u0026gt; (\u0026lt;a href=\u0026quot;https://godbolt.org/z/qM466Mzrr\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;godbolt\u0026lt;/a\u0026gt;)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/8658157/elliott\u0026quot; title=\u0026quot;2,106 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Elliott\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment123020097_48384508\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2021-10-16 20:17:27Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 16, 2021 at 20:17\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;You can improve this to support member functions with template arguments.  Change template \u0026amp;lt;typename T\u0026amp;gt; to template \u0026amp;lt;typename T, typename ... Args\u0026amp;gt;, then you can use \u0026quot;Args...\u0026quot; in your macro elipsis to create a check struct with variadic template args. eg. Detect \u0026quot;void onNext(const T \u0026amp;amp;)\u0026quot; method \u0026lt;code\u0026gt;HAS_MEM_FUNC( onNext, has_memberfn_onNext, void, Args... );\u0026lt;/code\u0026gt;     ... \u0026lt;code\u0026gt;template \u0026amp;lt;typename V\u0026amp;gt;     struct Foo { \tvoid onNext(const V \u0026amp;amp;);         static_assert\u0026amp;lt; has_memberfn_onNext\u0026amp;lt;Foo\u0026amp;lt;V\u0026amp;gt;,const V \u0026amp;amp;\u0026amp;gt;::value, \u0026quot;API fail\u0026quot; );     };\u0026lt;/code\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/220481/acyclic\u0026quot; title=\u0026quot;5,434 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;ACyclic\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment65890330_19815793\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-09-01 17:45:03Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 1, 2016 at 17:45\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 5 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Is there way to inline the \u0026lt;code\u0026gt;has_foo\u0026lt;/code\u0026gt; into the template call of \u0026lt;code\u0026gt;is_supported\u0026lt;/code\u0026gt;. What I would like is to call something like: \u0026lt;code\u0026gt;std::cout \u0026amp;lt;\u0026amp;lt; is_supported\u0026amp;lt;magic.foo(), struct1\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl;\u0026lt;/code\u0026gt;. The reason for this, I want to define a \u0026lt;code\u0026gt;has_foo\u0026lt;/code\u0026gt; for each different function signature that I want to check before I can check for the function?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/991000/cjcombrink\u0026quot; title=\u0026quot;3,496 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;CJCombrink\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment77079541_37142300\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-07-12 09:01:46Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 12, 2017 at 9:01\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I\u0026apos;m trying to understand why we need the \u0026lt;code\u0026gt;void(...)\u0026lt;/code\u0026gt; part. I would\u0026apos;ve thought that this would work: \u0026lt;code\u0026gt;template \u0026amp;lt;auto\u0026amp;gt; using v_to_void = void;\u0026lt;/code\u0026gt; ... \u0026lt;code\u0026gt;v_to_void\u0026amp;lt;std::declval\u0026amp;lt;T\u0026amp;amp;\u0026amp;gt;().begin()\u0026amp;gt;\u0026lt;/code\u0026gt; (avoiding \u0026lt;code\u0026gt;decltype\u0026lt;/code\u0026gt;). Any idea why it doesn\u0026apos;t?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/8658157/elliott\u0026quot; title=\u0026quot;2,106 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Elliott\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment123019714_63823318\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2021-10-16 19:50:09Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 16, 2021 at 19:50\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Fails if \u0026lt;code\u0026gt;toString\u0026lt;/code\u0026gt; is overloaded, as \u0026lt;code\u0026gt;\u0026amp;amp;U::toString\u0026lt;/code\u0026gt; is ambiguous.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1774667/yakk-adam-nevraumont\u0026quot; title=\u0026quot;251,284 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Yakk - Adam Nevraumont\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment36979063_17534399\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-06-02 13:40:18Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 2, 2014 at 13:40\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Yakk I think a cast can fix this problem.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1095108/user1095108\u0026quot; title=\u0026quot;13,370 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;user1095108\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment36990147_17534399\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-06-02 19:06:37Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 2, 2014 at 19:06\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Your static asserts do not work. You need to use array size -1 instead of 0 (try putting \u0026lt;code\u0026gt;static_assert(false);\u0026lt;/code\u0026gt;). I was using this in connection with CRTP where I want to determine whether the derived class has a particular function--which turns out not to work, yet your asserts always passed. I lost some hair to that one.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1140976/the-swine\u0026quot; title=\u0026quot;10,423 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;the swine\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment68310192_33328621\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-11-10 19:12:52Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 10, 2016 at 19:12\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I\u0026apos;m assuming you\u0026apos;re using g++. Please note, that gcc/g++ have an extension that allows for zero-sized array (\u0026lt;a href=\u0026quot;https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;gcc.gnu.org/onlinedocs/gcc/Zero-Length.html\u0026lt;/a\u0026gt;)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3296587/user3296587\u0026quot; title=\u0026quot;101 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;user3296587\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment69232861_33328621\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-12-07 08:36:37Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 7, 2016 at 8:36\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Could you possibly rewrite this so as not to overload operator, ? e.g. choose another operator? Also, avoid pollution of the namespace with anything other than has_awesome_member?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1593077/einpoklum\u0026quot; title=\u0026quot;103,988 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;einpoklum\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment94350106_33328621\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-12-12 17:58:45Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 12, 2018 at 17:58\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I\u0026apos;m sorry, but it has to be \u0026lt;code\u0026gt;operator ,\u0026lt;/code\u0026gt; since this is the only operator that\u0026apos;s implemented by the builtin void-type (you can write \u0026lt;code\u0026gt;((void)0, foo())\u0026lt;/code\u0026gt;, but any other operator like in \u0026lt;code\u0026gt;((void)0 + foo())\u0026lt;/code\u0026gt; would always cause a compiler error and cannot be overridden), meaning that this is required for being able to dectect functions with a void return type. - As for namespace pollution: Sure you could just put everything (except for \u0026lt;code\u0026gt;operator ,()\u0026lt;/code\u0026gt;, which has to remain visible as a global operator) into some namespace and adjust \u0026lt;code\u0026gt;has_awesome_member\u0026lt;/code\u0026gt; to simply make use of that namespace.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3296587/user3296587\u0026quot; title=\u0026quot;101 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;user3296587\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment100964075_33328621\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-07-27 08:15:29Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 27, 2019 at 8:15\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;How easy is it to write this so as not to have to depend on \u0026lt;code\u0026gt;fit\u0026lt;/code\u0026gt; or any library other than the standard?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1593077/einpoklum\u0026quot; title=\u0026quot;103,988 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;einpoklum\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment94350054_34801904\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-12-12 17:57:17Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 12, 2018 at 17:57\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        "],"id":540,"title":"Templated check for the existence of a class member function?","content":"\n                \n\u0026lt;p\u0026gt;Is it possible to write a template that changes behavior depending on if a certain member function is defined on a class?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here\u0026apos;s a simple example of what I would want to write:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\nstd::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T* obj)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;FUNCTION_EXISTS\u0026lt;/span\u0026gt;(T-\u0026amp;gt;toString))\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; obj-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toString not defined\u0026quot;\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So, if \u0026lt;code\u0026gt;class T\u0026lt;/code\u0026gt; has \u0026lt;code\u0026gt;toString()\u0026lt;/code\u0026gt; defined, then it uses it; otherwise, it doesn\u0026apos;t. The magical part that I don\u0026apos;t know how to do is the \u0026quot;FUNCTION_EXISTS\u0026quot; part.\u0026lt;/p\u0026gt;\n    ","slug":"templated-check-for-the-existence-of-a-class-member-function-1657388363414","postType":"QUESTION","createdAt":"2022-07-09T17:39:23.000Z","updatedAt":"2022-07-09T17:39:23.000Z","tags":[{"id":2640,"name":"template-meta-programming","slug":"template-meta-programming","createdAt":"2022-07-09T17:39:23.000Z","updatedAt":"2022-07-09T17:39:23.000Z","Questions_Tags":{"questionId":540,"tagId":2640}},{"id":2641,"name":"sfinae","slug":"sfinae","createdAt":"2022-07-09T17:39:23.000Z","updatedAt":"2022-07-09T17:39:23.000Z","Questions_Tags":{"questionId":540,"tagId":2641}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"templated-check-for-the-existence-of-a-class-member-function-1657388363414"},"buildId":"4Y8KGE-c2lolBeBmcum_I","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>