<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2eccd4d47c856f2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2eccd4d47c856f2b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/471-84c36aa98dd4107c.js" defer=""></script><script src="/_next/static/chunks/81-301f760ac8107464.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-76d2c3e2d98bb08b.js" defer=""></script><script src="/_next/static/B9ZMQqRLGvIP-RcWN9dT2/_buildManifest.js" defer=""></script><script src="/_next/static/B9ZMQqRLGvIP-RcWN9dT2/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.eZIPKL code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-c4b0431a-0"]{content:"eZIPKL,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="https://flowbite.com/docs/images/logo.svg" class="mr-3 h-6 sm:h-9" alt="Flowbite Logo"/><span class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Hunter</span></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/when-should-i-wrap-quotes-around-a-shell-variable-1657384659265#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-c4b0431a-0 eZIPKL flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/when-should-i-wrap-quotes-around-a-shell-variable-1657384659265">When should I wrap quotes around a shell variable?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/bash">bash</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/shell">shell</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/unix">unix</a></div></div><div class="question-content mt-5">
                
<p>Should or should I not wrap quotes around variables in a shell script?</p>
<p>For example, is the following correct:</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash">xdg-open <span class="hljs-variable">$URL</span>
[ $? -eq 2 ]
</code></pre>
<p>or</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash">xdg-open <span class="hljs-string">"<span class="hljs-variable">$URL</span>"</span>
[ <span class="hljs-string">"$?"</span> -eq <span class="hljs-string">"2"</span> ]
</code></pre>
<p>And if so, why?</p>
    </div></div></div><div class="sc-c4b0431a-2 cRqwQe"><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>General rule: quote it if it can either be empty or contain spaces (or any whitespace really) or special characters (wildcards). Not quoting strings with spaces often leads to the shell breaking apart a single argument into many.</p>

<p><code>$?</code> doesn't need quotes since it's a numeric value. Whether <code>$URL</code> needs it depends on what you allow in there and whether you still want an argument if it's empty.</p>

<p>I tend to always quote strings just out of habit since it's safer that way.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In short, quote everything where you do not require the shell to perform word splitting and wildcard expansion.</p>
<p>Single quotes protect the text between them verbatim.  It is the proper tool when you need to ensure that the shell does not touch the string at all.  Typically, it is the quoting mechanism of choice when you do not require variable interpolation.</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">'Nothing \t in here $will change'</span>
Nothing \t <span class="hljs-keyword">in</span> here <span class="hljs-variable">$will</span> change

$ grep -F <span class="hljs-string">'@&amp;$*!!'</span> file /dev/null
file:I can<span class="hljs-string">'t get this @&amp;$*!! quoting right.
</span></code></pre>
<p>Double quotes are suitable when variable interpolation is required.  With suitable adaptations, it is also a good workaround when you need single quotes in the string.  (There is no straightforward way to escape a single quote between single quotes, because there is no escape mechanism inside single quotes -- if there was, they would not quote completely verbatim.)</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">"There is no place like '<span class="hljs-variable">$HOME</span>'"</span>
There is no place like <span class="hljs-string">'/home/me'</span>
</code></pre>
<p>No quotes are suitable when you specifically require the shell to perform word splitting and/or wildcard expansion.</p>
<p><a href="https://www.gnu.org/software/bash/manual/html_node/Word-Splitting.html" rel="noreferrer">Word splitting</a> (aka token splitting);</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash"> $ words=<span class="hljs-string">"foo bar baz"</span>
 $ <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> <span class="hljs-variable">$words</span>; <span class="hljs-keyword">do</span>
 &gt;   <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$word</span>"</span>
 &gt; <span class="hljs-keyword">done</span>
 foo
 bar
 baz
</code></pre>
<p>By contrast:</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash"> $ <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> <span class="hljs-string">"<span class="hljs-variable">$words</span>"</span>; <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$word</span>"</span>; <span class="hljs-keyword">done</span>
 foo bar baz
</code></pre>
<p>(The loop only runs once, over the single, quoted string.)</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash"> $ <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> <span class="hljs-string">'$words'</span>; <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$word</span>"</span>; <span class="hljs-keyword">done</span>
 <span class="hljs-variable">$words</span>
</code></pre>
<p>(The loop only runs once, over the literal single-quoted string.)</p>
<p>Wildcard expansion:</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash">$ pattern=<span class="hljs-string">'file*.txt'</span>
$ <span class="hljs-built_in">ls</span> <span class="hljs-variable">$pattern</span>
file1.txt      file_other.txt
</code></pre>
<p>By contrast:</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash">$ <span class="hljs-built_in">ls</span> <span class="hljs-string">"<span class="hljs-variable">$pattern</span>"</span>
<span class="hljs-built_in">ls</span>: cannot access file*.txt: No such file or directory
</code></pre>
<p>(There is no file named literally <code>file*.txt</code>.)</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash">$ <span class="hljs-built_in">ls</span> <span class="hljs-string">'$pattern'</span>
<span class="hljs-built_in">ls</span>: cannot access <span class="hljs-variable">$pattern</span>: No such file or directory
</code></pre>
<p>(There is no file named <code>$pattern</code>, either!)</p>
<p>In more concrete terms, anything containing a filename should usually be quoted (because filenames can contain whitespace and other shell metacharacters).  Anything containing a URL should usually be quoted (because many URLs contain shell metacharacters like <code>?</code> and <code>&amp;</code>).  Anything containing a regex should usually be quoted (ditto ditto).  Anything containing significant whitespace other than single spaces between non-whitespace characters needs to be quoted (because otherwise, the shell will munge the whitespace into, effectively, single spaces, and trim any leading or trailing whitespace).</p>
<p>When you know that a variable can only contain a value which contains no shell metacharacters, quoting is optional.  Thus, an unquoted <code>$?</code> is basically fine, because this variable can only ever contain a single number.  However, <code>"$?"</code> is also correct, and recommended for general consistency and correctness (though this is my personal recommendation, not a widely recognized policy).</p>
<p>Values which are not variables basically follow the same rules, though you could then also escape any metacharacters instead of quoting them. For a common example, a URL with a <code>&amp;</code> in it will be parsed by the shell as a background command unless the metacharacter is escaped or quoted:</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash">$ wget http://example.com/q&amp;uack
[1] wget http://example.com/q
-bash: uack: <span class="hljs-built_in">command</span> not found
</code></pre>
<p>(Of course, this also happens if the URL is in an unquoted variable.) For a static string, single quotes make the most sense, although any form of quoting or escaping works here.</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash">wget <span class="hljs-string">'http://example.com/q&amp;uack'</span>  <span class="hljs-comment"># Single quotes preferred for a static string</span>
wget <span class="hljs-string">"http://example.com/q&amp;uack"</span>  <span class="hljs-comment"># Double quotes work here, too (no $ or ` in the value)</span>
wget http://example.com/q\&amp;uack   <span class="hljs-comment"># Backslash escape</span>
wget http://example.com/q<span class="hljs-string">'&amp;'</span>uack  <span class="hljs-comment"># Only the metacharacter really needs quoting</span>
</code></pre>
<p>The last example also suggests another useful concept, which I like to call "seesaw quoting". If you need to mix single and double quotes, you can use them adjacent to each other. For example, the following quoted strings</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash"><span class="hljs-string">'$HOME '</span>
<span class="hljs-string">"isn't"</span>
<span class="hljs-string">' where `&lt;3'</span>
<span class="hljs-string">"' is."</span>
</code></pre>
<p>can be pasted together back to back, forming a single long string after tokenization and quote removal.</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash">$&nbsp;<span class="hljs-built_in">echo</span> <span class="hljs-string">'$HOME '</span><span class="hljs-string">"isn't"</span><span class="hljs-string">' where `&lt;3'</span><span class="hljs-string">"' is."</span>
<span class="hljs-variable">$HOME</span> isn<span class="hljs-string">'t where `&lt;3'</span> is.
</code></pre>
<p>This isn't awfully legible, but it's a common technique and thus good to know.</p>
<p>As an aside, scripts <a href="http://mywiki.wooledge.org/ParsingLs" rel="noreferrer">should usually not use <code>ls</code> for anything.</a>  To expand a wildcard, just ... use it.</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash">$ <span class="hljs-built_in">printf</span> <span class="hljs-string">'%s\n'</span> <span class="hljs-variable">$pattern</span>   <span class="hljs-comment"># not ``ls -1 $pattern''</span>
file1.txt
file_other.txt

$ <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> <span class="hljs-variable">$pattern</span>; <span class="hljs-keyword">do</span>  <span class="hljs-comment"># definitely, definitely not ``for file in $(ls $pattern)''</span>
&gt;  <span class="hljs-built_in">printf</span> <span class="hljs-string">'Found file: %s\n'</span> <span class="hljs-string">"<span class="hljs-variable">$file</span>"</span>
&gt; <span class="hljs-keyword">done</span>
Found file: file1.txt
Found file: file_other.txt
</code></pre>
<p>(The loop is completely superfluous in the latter example; <code>printf</code> specifically works fine with multiple arguments. <code>stat</code> too.  But looping over a wildcard match is a common problem, and frequently done incorrectly.)</p>
<p>A variable containing a list of tokens to loop over or a wildcard to expand is less frequently seen, so we sometimes abbreviate to "quote everything unless you know precisely what you are doing".</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is a three-point formula for quotes in general:</p>

<p><strong>Double quotes</strong></p>

<p>In contexts where we want to suppress word splitting and globbing. Also in contexts where we want the literal to be treated as a string, not a regex.</p>

<p><strong>Single quotes</strong></p>

<p>In string literals where we want to suppress interpolation and special treatment of backslashes. In other words, situations where using double quotes would be inappropriate.</p>

<p><strong>No quotes</strong></p>

<p>In contexts where we are absolutely sure that there are no word splitting or globbing issues or we <em>do want word splitting and globbing</em>.</p>

<hr>

<p><strong>Examples</strong></p>

<p><strong>Double quotes</strong></p>

<ul>
<li>literal strings with whitespace (<code>"StackOverflow rocks!"</code>, <code>"Steve's Apple"</code>)</li>
<li>variable expansions (<code>"$var"</code>, <code>"${arr[@]}"</code>)</li>
<li>command substitutions (<code>"$(ls)"</code>, <code>"`ls`"</code>)</li>
<li>globs where directory path or file name part includes spaces (<code>"/my dir/"*</code>)</li>
<li>to protect single quotes (<code>"single'quote'delimited'string"</code>)</li>
<li>Bash parameter expansion (<code>"${filename##*/}"</code>)</li>
</ul>

<p><strong>Single quotes</strong></p>

<ul>
<li>command names and arguments that have whitespace in them</li>
<li>literal strings that need interpolation to be suppressed ( <code>'Really costs $$!'</code>, <code>'just a backslash followed by a t: \t'</code>)</li>
<li>to protect double quotes (<code>'The "crux"'</code>)</li>
<li>regex literals that need interpolation to be suppressed</li>
<li>use shell quoting for literals involving special characters (<code>$'\n\t'</code>)</li>
<li>use shell quoting where we need to protect several single and double quotes (<code>$'{"table": "users", "where": "first_name"=\'Steve\'}'</code>)</li>
</ul>

<p><strong>No quotes</strong></p>

<ul>
<li>around standard numeric variables (<code>$$</code>, <code>$?</code>, <code>$#</code> etc.)</li>
<li>in arithmetic contexts like <code>((count++))</code>, <code>"${arr[idx]}"</code>, <code>"${string:start:length}"</code></li>
<li>inside <code>[[ ]]</code> expression which is free from word splitting and globbing issues (this is a matter of style and opinions can vary widely)</li>
<li>where we want word splitting (<code>for word in $words</code>)</li>
<li>where we want globbing (<code>for txtfile in *.txt; do ...</code>)</li>
<li>where we want <code>~</code> to be interpreted as <code>$HOME</code> (<code>~/"some dir"</code> but not <code>"~/some dir"</code>)</li>
</ul>

<hr>

<p>See also:</p>

<ul>
<li><a href="https://stackoverflow.com/a/42082956/6862601">Difference between single and double quotes in Bash</a></li>
<li><a href="https://stackoverflow.com/q/5163144/6862601">What are the special dollar sign shell variables?</a></li>
<li><a href="http://wiki.bash-hackers.org/syntax/quoting" rel="noreferrer">Quotes and escaping - Bash Hackers' Wiki</a></li>
<li><a href="https://unix.stackexchange.com/q/68694/201820">When is double quoting necessary?</a></li>
</ul>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I generally use quoted like <code>"$var"</code> for safe, unless I am sure that <code>$var</code> does not contain space.</p>

<p>I do use <code>$var</code> as a simple way to join lines:</p>

<pre class="lang-bash s-code-block"><code class="hljs language-bash">lines=<span class="hljs-string">"`cat multi-lines-text-file.txt`"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$lines</span>"</span>                             <span class="hljs-comment">## multiple lines</span>
<span class="hljs-built_in">echo</span> <span class="hljs-variable">$lines</span>                               <span class="hljs-comment">## all spaces (including newlines) are zapped</span>
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Whenever the <a href="https://www.shellcheck.net/" rel="nofollow noreferrer">https://www.shellcheck.net/</a> plugin for your editor tells you to.</p>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;General rule: quote it if it can either be empty or contain spaces (or any whitespace really) or special characters (wildcards). Not quoting strings with spaces often leads to the shell breaking apart a single argument into many.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;$?\u0026lt;/code\u0026gt; doesn\u0026apos;t need quotes since it\u0026apos;s a numeric value. Whether \u0026lt;code\u0026gt;$URL\u0026lt;/code\u0026gt; needs it depends on what you allow in there and whether you still want an argument if it\u0026apos;s empty.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I tend to always quote strings just out of habit since it\u0026apos;s safer that way.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In short, quote everything where you do not require the shell to perform word splitting and wildcard expansion.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Single quotes protect the text between them verbatim.  It is the proper tool when you need to ensure that the shell does not touch the string at all.  Typically, it is the quoting mechanism of choice when you do not require variable interpolation.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;$ \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Nothing \\t in here $will change\u0026apos;\u0026lt;/span\u0026gt;\nNothing \\t \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; here \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$will\u0026lt;/span\u0026gt; change\n\n$ grep -F \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;@\u0026amp;amp;$*!!\u0026apos;\u0026lt;/span\u0026gt; file /dev/null\nfile:I can\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;t get this @\u0026amp;amp;$*!! quoting right.\n\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Double quotes are suitable when variable interpolation is required.  With suitable adaptations, it is also a good workaround when you need single quotes in the string.  (There is no straightforward way to escape a single quote between single quotes, because there is no escape mechanism inside single quotes -- if there was, they would not quote completely verbatim.)\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;$ \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;There is no place like \u0026apos;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$HOME\u0026lt;/span\u0026gt;\u0026apos;\u0026quot;\u0026lt;/span\u0026gt;\nThere is no place like \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;/home/me\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;No quotes are suitable when you specifically require the shell to perform word splitting and/or wildcard expansion.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://www.gnu.org/software/bash/manual/html_node/Word-Splitting.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Word splitting\u0026lt;/a\u0026gt; (aka token splitting);\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt; $ words=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;foo bar baz\u0026quot;\u0026lt;/span\u0026gt;\n $ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; word \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$words\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;do\u0026lt;/span\u0026gt;\n \u0026amp;gt;   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$word\u0026lt;/span\u0026gt;\u0026quot;\u0026lt;/span\u0026gt;\n \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;done\u0026lt;/span\u0026gt;\n foo\n bar\n baz\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;By contrast:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt; $ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; word \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$words\u0026lt;/span\u0026gt;\u0026quot;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;do\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$word\u0026lt;/span\u0026gt;\u0026quot;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;done\u0026lt;/span\u0026gt;\n foo bar baz\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;(The loop only runs once, over the single, quoted string.)\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt; $ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; word \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;$words\u0026apos;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;do\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$word\u0026lt;/span\u0026gt;\u0026quot;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;done\u0026lt;/span\u0026gt;\n \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$words\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;(The loop only runs once, over the literal single-quoted string.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Wildcard expansion:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;$ pattern=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;file*.txt\u0026apos;\u0026lt;/span\u0026gt;\n$ \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ls\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$pattern\u0026lt;/span\u0026gt;\nfile1.txt      file_other.txt\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;By contrast:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;$ \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ls\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$pattern\u0026lt;/span\u0026gt;\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ls\u0026lt;/span\u0026gt;: cannot access file*.txt: No such file or directory\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;(There is no file named literally \u0026lt;code\u0026gt;file*.txt\u0026lt;/code\u0026gt;.)\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;$ \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ls\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;$pattern\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ls\u0026lt;/span\u0026gt;: cannot access \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$pattern\u0026lt;/span\u0026gt;: No such file or directory\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;(There is no file named \u0026lt;code\u0026gt;$pattern\u0026lt;/code\u0026gt;, either!)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In more concrete terms, anything containing a filename should usually be quoted (because filenames can contain whitespace and other shell metacharacters).  Anything containing a URL should usually be quoted (because many URLs contain shell metacharacters like \u0026lt;code\u0026gt;?\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt;).  Anything containing a regex should usually be quoted (ditto ditto).  Anything containing significant whitespace other than single spaces between non-whitespace characters needs to be quoted (because otherwise, the shell will munge the whitespace into, effectively, single spaces, and trim any leading or trailing whitespace).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;When you know that a variable can only contain a value which contains no shell metacharacters, quoting is optional.  Thus, an unquoted \u0026lt;code\u0026gt;$?\u0026lt;/code\u0026gt; is basically fine, because this variable can only ever contain a single number.  However, \u0026lt;code\u0026gt;\u0026quot;$?\u0026quot;\u0026lt;/code\u0026gt; is also correct, and recommended for general consistency and correctness (though this is my personal recommendation, not a widely recognized policy).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Values which are not variables basically follow the same rules, though you could then also escape any metacharacters instead of quoting them. For a common example, a URL with a \u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt; in it will be parsed by the shell as a background command unless the metacharacter is escaped or quoted:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;$ wget http://example.com/q\u0026amp;amp;uack\n[1] wget http://example.com/q\n-bash: uack: \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;command\u0026lt;/span\u0026gt; not found\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;(Of course, this also happens if the URL is in an unquoted variable.) For a static string, single quotes make the most sense, although any form of quoting or escaping works here.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;wget \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;http://example.com/q\u0026amp;amp;uack\u0026apos;\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Single quotes preferred for a static string\u0026lt;/span\u0026gt;\nwget \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;http://example.com/q\u0026amp;amp;uack\u0026quot;\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Double quotes work here, too (no $ or ` in the value)\u0026lt;/span\u0026gt;\nwget http://example.com/q\\\u0026amp;amp;uack   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Backslash escape\u0026lt;/span\u0026gt;\nwget http://example.com/q\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026amp;amp;\u0026apos;\u0026lt;/span\u0026gt;uack  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Only the metacharacter really needs quoting\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The last example also suggests another useful concept, which I like to call \u0026quot;seesaw quoting\u0026quot;. If you need to mix single and double quotes, you can use them adjacent to each other. For example, the following quoted strings\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;$HOME \u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;isn\u0026apos;t\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos; where `\u0026amp;lt;3\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026apos; is.\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;can be pasted together back to back, forming a single long string after tokenization and quote removal.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;$\u0026amp;nbsp;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;$HOME \u0026apos;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;isn\u0026apos;t\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos; where `\u0026amp;lt;3\u0026apos;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026apos; is.\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$HOME\u0026lt;/span\u0026gt; isn\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;t where `\u0026amp;lt;3\u0026apos;\u0026lt;/span\u0026gt; is.\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This isn\u0026apos;t awfully legible, but it\u0026apos;s a common technique and thus good to know.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;As an aside, scripts \u0026lt;a href=\u0026quot;http://mywiki.wooledge.org/ParsingLs\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;should usually not use \u0026lt;code\u0026gt;ls\u0026lt;/code\u0026gt; for anything.\u0026lt;/a\u0026gt;  To expand a wildcard, just ... use it.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;$ \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;%s\\n\u0026apos;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$pattern\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# not ``ls -1 $pattern\u0026apos;\u0026apos;\u0026lt;/span\u0026gt;\nfile1.txt\nfile_other.txt\n\n$ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; file \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$pattern\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;do\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# definitely, definitely not ``for file in $(ls $pattern)\u0026apos;\u0026apos;\u0026lt;/span\u0026gt;\n\u0026amp;gt;  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Found file: %s\\n\u0026apos;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$file\u0026lt;/span\u0026gt;\u0026quot;\u0026lt;/span\u0026gt;\n\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;done\u0026lt;/span\u0026gt;\nFound file: file1.txt\nFound file: file_other.txt\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;(The loop is completely superfluous in the latter example; \u0026lt;code\u0026gt;printf\u0026lt;/code\u0026gt; specifically works fine with multiple arguments. \u0026lt;code\u0026gt;stat\u0026lt;/code\u0026gt; too.  But looping over a wildcard match is a common problem, and frequently done incorrectly.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A variable containing a list of tokens to loop over or a wildcard to expand is less frequently seen, so we sometimes abbreviate to \u0026quot;quote everything unless you know precisely what you are doing\u0026quot;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is a three-point formula for quotes in general:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Double quotes\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In contexts where we want to suppress word splitting and globbing. Also in contexts where we want the literal to be treated as a string, not a regex.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Single quotes\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In string literals where we want to suppress interpolation and special treatment of backslashes. In other words, situations where using double quotes would be inappropriate.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;No quotes\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In contexts where we are absolutely sure that there are no word splitting or globbing issues or we \u0026lt;em\u0026gt;do want word splitting and globbing\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Examples\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Double quotes\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;literal strings with whitespace (\u0026lt;code\u0026gt;\u0026quot;StackOverflow rocks!\u0026quot;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026quot;Steve\u0026apos;s Apple\u0026quot;\u0026lt;/code\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;variable expansions (\u0026lt;code\u0026gt;\u0026quot;$var\u0026quot;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026quot;${arr[@]}\u0026quot;\u0026lt;/code\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;command substitutions (\u0026lt;code\u0026gt;\u0026quot;$(ls)\u0026quot;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026quot;`ls`\u0026quot;\u0026lt;/code\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;globs where directory path or file name part includes spaces (\u0026lt;code\u0026gt;\u0026quot;/my dir/\u0026quot;*\u0026lt;/code\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;to protect single quotes (\u0026lt;code\u0026gt;\u0026quot;single\u0026apos;quote\u0026apos;delimited\u0026apos;string\u0026quot;\u0026lt;/code\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Bash parameter expansion (\u0026lt;code\u0026gt;\u0026quot;${filename##*/}\u0026quot;\u0026lt;/code\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Single quotes\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;command names and arguments that have whitespace in them\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;literal strings that need interpolation to be suppressed ( \u0026lt;code\u0026gt;\u0026apos;Really costs $$!\u0026apos;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026apos;just a backslash followed by a t: \\t\u0026apos;\u0026lt;/code\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;to protect double quotes (\u0026lt;code\u0026gt;\u0026apos;The \u0026quot;crux\u0026quot;\u0026apos;\u0026lt;/code\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;regex literals that need interpolation to be suppressed\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;use shell quoting for literals involving special characters (\u0026lt;code\u0026gt;$\u0026apos;\\n\\t\u0026apos;\u0026lt;/code\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;use shell quoting where we need to protect several single and double quotes (\u0026lt;code\u0026gt;$\u0026apos;{\u0026quot;table\u0026quot;: \u0026quot;users\u0026quot;, \u0026quot;where\u0026quot;: \u0026quot;first_name\u0026quot;=\\\u0026apos;Steve\\\u0026apos;}\u0026apos;\u0026lt;/code\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;No quotes\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;around standard numeric variables (\u0026lt;code\u0026gt;$$\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;$?\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;$#\u0026lt;/code\u0026gt; etc.)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;in arithmetic contexts like \u0026lt;code\u0026gt;((count++))\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026quot;${arr[idx]}\u0026quot;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026quot;${string:start:length}\u0026quot;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;inside \u0026lt;code\u0026gt;[[ ]]\u0026lt;/code\u0026gt; expression which is free from word splitting and globbing issues (this is a matter of style and opinions can vary widely)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;where we want word splitting (\u0026lt;code\u0026gt;for word in $words\u0026lt;/code\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;where we want globbing (\u0026lt;code\u0026gt;for txtfile in *.txt; do ...\u0026lt;/code\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;where we want \u0026lt;code\u0026gt;~\u0026lt;/code\u0026gt; to be interpreted as \u0026lt;code\u0026gt;$HOME\u0026lt;/code\u0026gt; (\u0026lt;code\u0026gt;~/\u0026quot;some dir\u0026quot;\u0026lt;/code\u0026gt; but not \u0026lt;code\u0026gt;\u0026quot;~/some dir\u0026quot;\u0026lt;/code\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;See also:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/a/42082956/6862601\u0026quot;\u0026gt;Difference between single and double quotes in Bash\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/q/5163144/6862601\u0026quot;\u0026gt;What are the special dollar sign shell variables?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://wiki.bash-hackers.org/syntax/quoting\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Quotes and escaping - Bash Hackers\u0026apos; Wiki\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://unix.stackexchange.com/q/68694/201820\u0026quot;\u0026gt;When is double quoting necessary?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I generally use quoted like \u0026lt;code\u0026gt;\u0026quot;$var\u0026quot;\u0026lt;/code\u0026gt; for safe, unless I am sure that \u0026lt;code\u0026gt;$var\u0026lt;/code\u0026gt; does not contain space.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I do use \u0026lt;code\u0026gt;$var\u0026lt;/code\u0026gt; as a simple way to join lines:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;lines=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;`cat multi-lines-text-file.txt`\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$lines\u0026lt;/span\u0026gt;\u0026quot;\u0026lt;/span\u0026gt;                             \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;## multiple lines\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$lines\u0026lt;/span\u0026gt;                               \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;## all spaces (including newlines) are zapped\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Whenever the \u0026lt;a href=\u0026quot;https://www.shellcheck.net/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://www.shellcheck.net/\u0026lt;/a\u0026gt; plugin for your editor tells you to.\u0026lt;/p\u0026gt;\n    "],"id":115,"title":"When should I wrap quotes around a shell variable?","content":"\n                \n\u0026lt;p\u0026gt;Should or should I not wrap quotes around variables in a shell script?\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For example, is the following correct:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;xdg-open \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$URL\u0026lt;/span\u0026gt;\n[ $? -eq 2 ]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;or\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;xdg-open \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$URL\u0026lt;/span\u0026gt;\u0026quot;\u0026lt;/span\u0026gt;\n[ \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;$?\u0026quot;\u0026lt;/span\u0026gt; -eq \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;2\u0026quot;\u0026lt;/span\u0026gt; ]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;And if so, why?\u0026lt;/p\u0026gt;\n    ","slug":"when-should-i-wrap-quotes-around-a-shell-variable-1657384659265","postType":"QUESTION","createdAt":"2022-07-09T16:37:39.000Z","updatedAt":"2022-07-09T16:37:39.000Z","tags":[{"id":419,"name":"bash","slug":"bash","createdAt":"2022-07-09T16:37:39.000Z","updatedAt":"2022-07-09T16:37:39.000Z","Questions_Tags":{"questionId":115,"tagId":419}},{"id":420,"name":"shell","slug":"shell","createdAt":"2022-07-09T16:37:39.000Z","updatedAt":"2022-07-09T16:37:39.000Z","Questions_Tags":{"questionId":115,"tagId":420}},{"id":421,"name":"unix","slug":"unix","createdAt":"2022-07-09T16:37:39.000Z","updatedAt":"2022-07-09T16:37:39.000Z","Questions_Tags":{"questionId":115,"tagId":421}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"when-should-i-wrap-quotes-around-a-shell-variable-1657384659265"},"buildId":"B9ZMQqRLGvIP-RcWN9dT2","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>