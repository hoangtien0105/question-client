{"pageProps":{"data":{"answer":["\n&lt;p&gt;Jackson has partially &lt;a href=&quot;https://stackoverflow.com/a/28135120/473961&quot;&gt;answered this&lt;/a&gt; in a similar question:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Implicit return, but only if there is no block.&lt;/p&gt;\n  \n  &lt;ul&gt;\n  &lt;li&gt;This will result in errors when a one-liner expands to multiple lines and the programmer forgets to add a &lt;code&gt;return&lt;/code&gt;.&lt;/li&gt;\n  &lt;li&gt;Implicit return is syntactically ambiguous. &lt;code&gt;(name) =&amp;gt; {id: name}&lt;/code&gt;returns the object &lt;code&gt;{id: name}&lt;/code&gt;... right? Wrong. It returns &lt;code&gt;undefined&lt;/code&gt;. Those braces are an explicit block. &lt;code&gt;id:&lt;/code&gt; is a label.&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;I would add to this the definition of a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block&quot; rel=&quot;noreferrer&quot;&gt;block&lt;/a&gt;:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;A block statement (or compound statement in other languages) is used to group zero or more statements. The block is delimited by a pair of curly brackets.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;&lt;strong&gt;Examples&lt;/strong&gt;:\n&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// returns: undefined&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// explanation: an empty block with an implicit return&lt;/span&gt;\n(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {})() \n\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: &apos;Hi Jess&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// explanation: no block means implicit return&lt;/span&gt;\n(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;Hi &apos;&lt;/span&gt; + name)(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jess&apos;&lt;/span&gt;)\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: undefined&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// explanation: explicit return required inside block, but is missing.&lt;/span&gt;\n(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;span class=&quot;hljs-string&quot;&gt;&apos;Hi &apos;&lt;/span&gt; + name})(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jess&apos;&lt;/span&gt;)\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: &apos;Hi Jess&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// explanation: explicit return in block exists&lt;/span&gt;\n(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;Hi &apos;&lt;/span&gt; + name})(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jess&apos;&lt;/span&gt;) \n\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: undefined&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// explanation: a block containing a single label. No explicit return.&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// more: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label&lt;/span&gt;\n(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;span class=&quot;hljs-attr&quot;&gt;id&lt;/span&gt;: name})(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jess&apos;&lt;/span&gt;) \n\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: {id: &apos;Jess&apos;}&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// explanation: implicit return of expression ( ) which evaluates to an object&lt;/span&gt;\n(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; ({&lt;span class=&quot;hljs-attr&quot;&gt;id&lt;/span&gt;: name}))(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jess&apos;&lt;/span&gt;) \n\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: {id: &apos;Jess&apos;}&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// explanation: explicit return inside block returns object&lt;/span&gt;\n(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; {&lt;span class=&quot;hljs-attr&quot;&gt;id&lt;/span&gt;: name}})(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Jess&apos;&lt;/span&gt;) \n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I understand this rule-of-thumb ... &lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;For functions that are effectively transforms (one-line-manipulations of arguments), return is implicit. &lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Candidates are:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// square-root &lt;/span&gt;\nvalue =&amp;gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Math&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;sqrt&lt;/span&gt;(value)\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// sum&lt;/span&gt;\n(a,b) =&amp;gt; a+b\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;For other operations (more than one-liners that require a block, return has to be explicit&lt;/p&gt;\n    ","\n&lt;p&gt;There&apos;s another case here.&lt;/p&gt;\n\n&lt;p&gt;When writing a functional component in React, you can use parentheses to wrap implicitly returned JSX.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;FunctionalComponent&lt;/span&gt; = (&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) =&amp;gt; (\n  &lt;span class=&quot;language-xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;OtherComponent&lt;/span&gt; /&amp;gt;&lt;/span&gt;\n  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;\n);\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Here&apos;s another case that gave me some trouble. &lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// the &quot;tricky&quot; way&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;wrap&lt;/span&gt; = (&lt;span class=&quot;hljs-params&quot;&gt;foo&lt;/span&gt;) =&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;bar&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (foo === &lt;span class=&quot;hljs-string&quot;&gt;&apos;foo&apos;&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; foo + &lt;span class=&quot;hljs-string&quot;&gt;&apos; &apos;&lt;/span&gt; + bar;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;nofoo &apos;&lt;/span&gt; + bar;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here we define a function returning an anonymous function.The &quot;tricky&quot; bit is that the function body for the outer function (the part begining with (bar) =&amp;gt; ...) visually looks like a &quot;block&quot;, but it&apos;s not. Since it&apos;s not, implicit return kicks in.&lt;/p&gt;\n\n&lt;p&gt;Here&apos;s how wrap would execute:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// use wrap() to create a function withfoo()&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; withfoo = &lt;span class=&quot;hljs-title function_&quot;&gt;wrap&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;foo&apos;&lt;/span&gt;);\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: foo bar&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-title function_&quot;&gt;withfoo&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;bar&apos;&lt;/span&gt;));\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// use wrap() to create a function withoutfoo()&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; withoutfoo = &lt;span class=&quot;hljs-title function_&quot;&gt;wrap&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;bar&apos;&lt;/span&gt;);\n&lt;span class=&quot;hljs-comment&quot;&gt;// returns: nofoo bar&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-title function_&quot;&gt;withoutfoo&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;bar&apos;&lt;/span&gt;));\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The way I unpacked this to make sure I understood it was to &quot;unarrowify&quot; the functions.&lt;/p&gt;\n\n&lt;p&gt;Here&apos;s the semantic equivalent of the first code block, simply making the body of wrap() do an explicit return. This definition produces the same results as above.  This is where the dots connect. Compare the first code block above with the one below, and it&apos;s clear that an arrow function itself is treated as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#Function_body&quot; rel=&quot;noreferrer&quot;&gt;an expression, not a block, and has the implied return&lt;/a&gt;.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// the explicit return way&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;wrap&lt;/span&gt; = (&lt;span class=&quot;hljs-params&quot;&gt;foo&lt;/span&gt;) =&amp;gt; {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;bar&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (foo === &lt;span class=&quot;hljs-string&quot;&gt;&apos;foo&apos;&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; foo + &lt;span class=&quot;hljs-string&quot;&gt;&apos; &apos;&lt;/span&gt; + bar;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;nofoo &apos;&lt;/span&gt; + bar;\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The fully unarrowified version of wrap would be like this, which while not as compact as the fat arrowed up version, seems a lot easier to comprehend.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// the &quot;no arrow functions&quot; way&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; wrap = &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;foo&lt;/span&gt;) {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;bar&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (foo === &lt;span class=&quot;hljs-string&quot;&gt;&apos;foo&apos;&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; foo + &lt;span class=&quot;hljs-string&quot;&gt;&apos; &apos;&lt;/span&gt; + bar;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;nofoo &apos;&lt;/span&gt; + bar;\n  };\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In the end, for others that may have to read my code, and future me, I think I&apos;d prefer to go the non arrow version which can be comprehended visually at first glance, rather than the arrow one which takes a fair bit of thought (and in my case experimentation) to grok.&lt;/p&gt;\n    ","\n&lt;p&gt;Arrow functions allow you to have an implicit return: values are returned without having to use the &lt;code&gt;return&lt;/code&gt; keyword.&lt;/p&gt;\n\n&lt;p&gt;It works when there is a on-line statement in the function body:&lt;/p&gt;\n\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;myFunction&lt;/span&gt; = (&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) =&amp;gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;test&apos;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-title function_&quot;&gt;myFunction&lt;/span&gt;()) &lt;span class=&quot;hljs-comment&quot;&gt;//&apos;test&apos;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif1&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n\n&lt;p&gt;Another example, returning an object (remember to wrap the curly brackets in parentheses to avoid it being considered the wrapping function body brackets):&lt;/p&gt;\n\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;myFunction&lt;/span&gt; = (&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) =&amp;gt; ({&lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;test&apos;&lt;/span&gt;})\n\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-title function_&quot;&gt;myFunction&lt;/span&gt;()) &lt;span class=&quot;hljs-comment&quot;&gt;//{value: &apos;test&apos;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif2&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Omitting the brackets {} and return keyword from an arrow function are ok if:\n(1) You wouldn&apos;t have any code (e.g. assignment statements) before the return statement and\n(2) You would be returning a single entity [Note: The single entity can be multiple lines.  If so, then all you need are regular parentheses() like the example below:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;posts.&lt;span class=&quot;hljs-title function_&quot;&gt;map&lt;/span&gt;(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;post&lt;/span&gt; =&amp;gt;&lt;/span&gt; (\n  &lt;span class=&quot;language-xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;li&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;key&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;{post.id}&lt;/span&gt;&amp;gt;&lt;/span&gt;\n    {post.title}\n  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;\n))\n&lt;/code&gt;&lt;/pre&gt;\n    "],"id":578,"title":"When should I use a return statement in ES6 arrow functions","content":"\n                \n&lt;p&gt;The new &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot; rel=&quot;noreferrer&quot;&gt;ES6 arrow functions&lt;/a&gt; say &lt;code&gt;return&lt;/code&gt; is implicit under some circumstances:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;The expression is also the implicit return value of that function.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;In what cases do I need to use &lt;code&gt;return&lt;/code&gt; with ES6 arrow functions?&lt;/p&gt;\n    ","slug":"when-should-i-use-a-return-statement-in-es6-arrow-functions-1657388472113","postType":"QUESTION","createdAt":"2022-07-09T17:41:12.000Z","updatedAt":"2022-07-09T17:41:12.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"input() error - NameError: name '...' is not defined","slug":"input()-error-nameerror:-name-'...'-is-not-defined-1657388497243"},{"title":"Why are these constructs using pre and post-increment undefined behavior?","slug":"why-are-these-constructs-using-pre-and-post-increment-undefined-behavior-1657384520109"},{"title":"Use a content script to access the page context variables and functions","slug":"use-a-content-script-to-access-the-page-context-variables-and-functions-1657384842444"},{"title":"Scanner is skipping nextLine() after using next() or nextFoo()?","slug":"scanner-is-skipping-nextline()-after-using-next()-or-nextfoo()-1657384379697"},{"title":"Why is the command bound to a Button or event executed when declared?","slug":"why-is-the-command-bound-to-a-button-or-event-executed-when-declared-1657384872054"},{"title":"How to deal with mysqli problems? mysqli_fetch_array(): Argument #1 must be of type mysqli_result","slug":"how-to-deal-with-mysqli-problems-mysqli_fetch_array():-argument-1-must-be-of-type-mysqli_result-1657384360922"},{"title":"Does JavaScript guarantee object property order?","slug":"does-javascript-guarantee-object-property-order-1657384822587"},{"title":"How do I pass JavaScript variables to PHP?","slug":"how-do-i-pass-javascript-variables-to-php-1657388157033"},{"title":"How do you parse and process HTML/XML in PHP?","slug":"how-do-you-parse-and-process-htmlxml-in-php-1657384351267"},{"title":"Why use getters and setters/accessors?","slug":"why-use-getters-and-settersaccessors-1657387343971"},{"title":"Persist variables between page loads","slug":"persist-variables-between-page-loads-1657388558452"},{"title":"Undefined, unspecified and implementation-defined behavior","slug":"undefined-unspecified-and-implementation-defined-behavior-1657384516085"},{"title":"When should static_cast, dynamic_cast, const_cast, and reinterpret_cast be used?","slug":"when-should-static_cast-dynamic_cast-const_cast-and-reinterpret_cast-be-used-1657388406205"},{"title":"How do function pointers in C work?","slug":"how-do-function-pointers-in-c-work-1657388332074"},{"title":"What is a plain English explanation of \"Big O\" notation?","slug":"what-is-a-plain-english-explanation-of-\"big-o\"-notation-1657387641953"},{"title":"What is move semantics?","slug":"what-is-move-semantics-1657387702625"},{"title":"How can I fix 'android.os.NetworkOnMainThreadException'?","slug":"how-can-i-fix-'android.os.networkonmainthreadexception'-1657384454963"},{"title":"Identifying and solving javax.el.PropertyNotFoundException: Target Unreachable","slug":"identifying-and-solving-javax.el.propertynotfoundexception:-target-unreachable-1657388164753"},{"title":"How do I set, clear, and toggle a single bit?","slug":"how-do-i-set-clear-and-toggle-a-single-bit-1657388227052"},{"title":"The Use of Multiple JFrames: Good or Bad Practice? [closed]","slug":"the-use-of-multiple-jframes:-good-or-bad-practice-closed-1657384478184"}]},"__N_SSG":true}