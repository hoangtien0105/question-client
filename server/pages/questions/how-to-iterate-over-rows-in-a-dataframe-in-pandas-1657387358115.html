<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>How to iterate over rows in a DataFrame in Pandas | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="I have a pandas dataframe, df:
   c1   c2
0  10  100
1  11  110
2  12  120

How do I iterate over the rows of this dataframe? For every row, I want to be able to access its elements (values in cells) by the name of the columns. For example:
for row in df.rows:
   print(row[&#x27;c1&#x27;], row[&#x27;c2&#x27;])


I found a similar question which suggests using either of these:
for date, row in df.T.iteritems():


for row in df.iterrows():

But I do not understand what the row object is and how I can work with it.
    "/><meta property="og:title" content="How to iterate over rows in a DataFrame in Pandas | Solutions Checker"/><meta property="og:description" content="I have a pandas dataframe, df:
   c1   c2
0  10  100
1  11  110
2  12  120

How do I iterate over the rows of this dataframe? For every row, I want to be able to access its elements (values in cells) by the name of the columns. For example:
for row in df.rows:
   print(row[&#x27;c1&#x27;], row[&#x27;c2&#x27;])


I found a similar question which suggests using either of these:
for date, row in df.T.iteritems():


for row in df.iterrows():

But I do not understand what the row object is and how I can work with it.
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"How to iterate over rows in a DataFrame in Pandas","text":"I have a pandas dataframe, df:\n   c1   c2\n0  10  100\n1  11  110\n2  12  120\n\nHow do I iterate over the rows of this dataframe? For every row, I want to be able to access its elements (values in cells) by the name of the columns. For example:\nfor row in df.rows:\n   print(row[&apos;c1&apos;], row[&apos;c2&apos;])\n\n\nI found a similar question which suggests using either of these:\nfor date, row in df.T.iteritems():\n\n\nfor row in df.iterrows():\n\nBut I do not understand what the row object is and how I can work with it.\n    ","answerCount":30,"upVoteCount":500,"suggestedAnswer":[{"text":"DataFrame.iterrows is a generator which yields both the index and row (as a Series):\nimport pandas as pd\n\ndf = pd.DataFrame({&apos;c1&apos;: [10, 11, 12], &apos;c2&apos;: [100, 110, 120]})\ndf = df.reset_index()  # make sure indexes pair with number of rows\n\nfor index, row in df.iterrows():\n    print(row[&apos;c1&apos;], row[&apos;c2&apos;])\n\n\n10 100\n11 110\n12 120\n\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"\nHow to iterate over rows in a DataFrame in Pandas?\n\nAnswer: DON&apos;T*!\nIteration in Pandas is an anti-pattern and is something you should only do when you have exhausted every other option. You should not use any function with &quot;iter&quot; in its name for more than a few thousand rows or you will have to get used to a lot of waiting.\nDo you want to print a DataFrame? Use DataFrame.to_string().\nDo you want to compute something? In that case, search for methods in this order (list modified from here):\n\nVectorization\nCython routines\nList Comprehensions (vanilla for loop)\nDataFrame.apply(): i)  Reductions that can be performed in Cython, ii) Iteration in Python space\nDataFrame.itertuples() and iteritems()\nDataFrame.iterrows()\n\niterrows and itertuples (both receiving many votes in answers to this question) should be used in very rare circumstances, such as generating row objects/nametuples for sequential processing, which is really the only thing these functions are useful for.\nAppeal to Authority\nThe documentation page on iteration has a huge red warning box that says:\n\nIterating through pandas objects is generally slow. In many cases, iterating manually over the rows is not needed [...].\n\n* It&apos;s actually a little more complicated than &quot;don&apos;t&quot;. df.iterrows() is the correct answer to this question, but &quot;vectorize your ops&quot; is the better one. I will concede that there are circumstances where iteration cannot be avoided (for example, some operations where the result depends on the value computed for the previous row). However, it takes some familiarity with the library to know when. If you&apos;re not sure whether you need an iterative solution, you probably don&apos;t. PS: To know more about my rationale for writing this answer, skip to the very bottom.\n\nFaster than Looping: Vectorization, Cython\nA good number of basic operations and computations are &quot;vectorised&quot; by pandas (either through NumPy, or through Cythonized functions). This includes arithmetic, comparisons, (most) reductions, reshaping (such as pivoting), joins, and groupby operations. Look through the documentation on Essential Basic Functionality to find a suitable vectorised method for your problem.\nIf none exists, feel free to write your own using custom Cython extensions.\n\nNext Best Thing: List Comprehensions*\nList comprehensions should be your next port of call if 1) there is no vectorized solution available, 2) performance is important, but not important enough to go through the hassle of cythonizing your code, and 3) you&apos;re trying to perform elementwise transformation on your code. There is a good amount of evidence to suggest that list comprehensions are sufficiently fast (and even sometimes faster) for many common Pandas tasks.\nThe formula is simple,\n# Iterating over one column - `f` is some function that processes your data\nresult = [f(x) for x in df[&apos;col&apos;]]\n# Iterating over two columns, use `zip`\nresult = [f(x, y) for x, y in zip(df[&apos;col1&apos;], df[&apos;col2&apos;])]\n# Iterating over multiple columns - same data type\nresult = [f(row[0], ..., row[n]) for row in df[[&apos;col1&apos;, ...,&apos;coln&apos;]].to_numpy()]\n# Iterating over multiple columns - differing data type\nresult = [f(row[0], ..., row[n]) for row in zip(df[&apos;col1&apos;], ..., df[&apos;coln&apos;])]\n\nIf you can encapsulate your business logic into a function, you can use a list comprehension that calls it. You can make arbitrarily complex things work through the simplicity and speed of raw Python code.\nCaveats\nList comprehensions assume that your data is easy to work with - what that means is your data types are consistent and you don&apos;t have NaNs, but this cannot always be guaranteed.\n\nThe first one is more obvious, but when dealing with NaNs, prefer in-built pandas methods if they exist (because they have much better corner-case handling logic), or ensure your business logic includes appropriate NaN handling logic.\nWhen dealing with mixed data types you should iterate over zip(df[&apos;A&apos;], df[&apos;B&apos;], ...) instead of df[[&apos;A&apos;, &apos;B&apos;]].to_numpy() as the latter implicitly upcasts data to the most common type. As an example if A is numeric and B is string, to_numpy() will cast the entire array to string, which may not be what you want. Fortunately zipping your columns together is the most straightforward workaround to this.\n\n*Your mileage may vary for the reasons outlined in the Caveats section above.\n\nAn Obvious Example\nLet&apos;s demonstrate the difference with a simple example of adding two pandas columns A + B. This is a vectorizable operaton, so it will be easy to contrast the performance of the methods discussed above.\n\nBenchmarking code, for your reference. The line at the bottom measures a function written in numpandas, a style of Pandas that mixes heavily with NumPy to squeeze out maximum performance. Writing numpandas code should be avoided unless you know what you&apos;re doing. Stick to the API where you can (i.e., prefer vec over vec_numpy).\nI should mention, however, that it isn&apos;t always this cut and dry. Sometimes the answer to &quot;what is the best method for an operation&quot; is &quot;it depends on your data&quot;. My advice is to test out different approaches on your data before settling on one.\n\nMy Personal Opinion *\nMost of the analyses performed on the various alternatives to the iter family has been through the lens of performance. However, in most situations you will typically be working on a reasonably sized dataset (nothing beyond a few thousand or 100K rows) and performance will come second to simplicity/readability of the solution.\nHere is my personal preference when selecting a method to use for a problem.\nFor the novice:\n\nVectorization (when possible); apply(); List Comprehensions; itertuples()/iteritems(); iterrows(); Cython\n\nFor the more experienced:\n\nVectorization (when possible); apply(); List Comprehensions; Cython; itertuples()/iteritems(); iterrows()\n\nVectorization prevails as the most idiomatic method for any problem that can be vectorized. Always seek to vectorize! When in doubt, consult the docs, or look on Stack Overflow for an existing question on your particular task.\nI do tend to go on about how bad apply is in a lot of my posts, but I do concede it is easier for a beginner to wrap their head around what it&apos;s doing. Additionally, there are quite a few use cases for apply has explained in this post of mine.\nCython ranks lower down on the list because it takes more time and effort to pull off correctly. You will usually never need to write code with pandas that demands this level of performance that even a list comprehension cannot satisfy.\n* As with any personal opinion, please take with heaps of salt!\n\nFurther Reading\n\n10 Minutes to pandas, and Essential Basic Functionality - Useful links that introduce you to Pandas and its library of vectorized*/cythonized functions.\n\nEnhancing Performance - A primer from the documentation on enhancing standard Pandas operations\n\nAre for-loops in pandas really bad? When should I care? - a detailed writeup by me on list comprehensions and their suitability for various operations (mainly ones involving non-numeric data)\n\nWhen should I (not) want to use pandas apply() in my code? - apply is slow (but not as slow as the iter* family. There are, however, situations where one can (or should) consider apply as a serious alternative, especially in some GroupBy operations).\n\n\n* Pandas string methods are &quot;vectorized&quot; in the sense that they are specified on the series but operate on each element. The underlying mechanisms are still iterative, because string operations are inherently hard to vectorize.\n\nWhy I Wrote this Answer\nA common trend I notice from new users is to ask questions of the form &quot;How can I iterate over my df to do X?&quot;. Showing code that calls iterrows() while doing something inside a for loop. Here is why. A new user to the library who has not been introduced to the concept of vectorization will likely envision the code that solves their problem as iterating over their data to do something. Not knowing how to iterate over a DataFrame, the first thing they do is Google it and end up here, at this question. They then see the accepted answer telling them how to, and they close their eyes and run this code without ever first questioning if iteration is the right thing to do.\nThe aim of this answer is to help new users understand that iteration is not necessarily the solution to every problem, and that better, faster and more idiomatic solutions could exist, and that it is worth investing time in exploring them. I&apos;m not trying to start a war of iteration vs. vectorization, but I want new users to be informed when developing solutions to their problems with this library.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"First consider if you really need to iterate over rows in a DataFrame. See this answer for alternatives.\nIf you still need to iterate over rows, you can use methods below. Note some  important caveats which are not mentioned in any of the other answers.\n\nDataFrame.iterrows()\n  for index, row in df.iterrows():\n      print(row[&quot;c1&quot;], row[&quot;c2&quot;])\n\n\nDataFrame.itertuples()\n  for row in df.itertuples(index=True, name=&apos;Pandas&apos;):\n      print(row.c1, row.c2)\n\n\n\nitertuples() is supposed to be faster than iterrows()\nBut be aware, according to the docs (pandas 0.24.2 at the moment):\n\niterrows: dtype might not match from row to row\n\n\nBecause iterrows returns a Series for each row, it does not preserve dtypes across the rows (dtypes are preserved across columns for DataFrames). To preserve dtypes while iterating over the rows, it is better to use itertuples() which returns namedtuples of the values and which is generally much faster than iterrows()\n\n\niterrows: Do not modify rows\n\n\nYou should never modify something you are iterating over. This is not guaranteed to work in all cases. Depending on the data types, the iterator returns a copy and not a view, and writing to it will have no effect.\n\nUse DataFrame.apply() instead:\n    new_df = df.apply(lambda x: x * 2, axis = 1)\n\n\nitertuples:\n\n\nThe column names will be renamed to positional names if they are invalid Python identifiers, repeated, or start with an underscore. With a large number of columns (&gt;255), regular tuples are returned.\n\nSee pandas docs on iteration for more details.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"You should use df.iterrows(). Though iterating row-by-row is not especially efficient since Series objects have to be created.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"While iterrows() is a good option, sometimes itertuples() can be much faster:\n\ndf = pd.DataFrame({&apos;a&apos;: randn(1000), &apos;b&apos;: randn(1000),&apos;N&apos;: randint(100, 1000, (1000)), &apos;x&apos;: &apos;x&apos;})\n\n%timeit [row.a * 2 for idx, row in df.iterrows()]\n# =&gt; 10 loops, best of 3: 50.3 ms per loop\n\n%timeit [row[1] * 2 for row in df.itertuples()]\n# =&gt; 1000 loops, best of 3: 541 µs per loop\n\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"You can use the df.iloc function as follows:\nfor i in range(0, len(df)):\n    print(df.iloc[i][&apos;c1&apos;], df.iloc[i][&apos;c2&apos;])\n\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"You can also use df.apply() to iterate over rows and access multiple columns for a function.\n\ndocs: DataFrame.apply()\n\ndef valuation_formula(x, y):\n    return x * y * 0.5\n\ndf[&apos;price&apos;] = df.apply(lambda row: valuation_formula(row[&apos;x&apos;], row[&apos;y&apos;]), axis=1)\n\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"How to iterate efficiently\n\nIf you really have to iterate a Pandas dataframe, you will probably want to avoid using iterrows(). There are different methods and the usual iterrows() is far from being the best. itertuples() can be 100 times faster.\n\nIn short:\n\n\nAs a general rule, use df.itertuples(name=None). In particular, when you have a fixed number columns and less than 255 columns. See point (3)\nOtherwise, use df.itertuples() except if your columns have special characters such as spaces or &apos;-&apos;. See point (2)\nIt is possible to use itertuples() even if your dataframe has strange columns by using the last example. See point (4)\nOnly use iterrows() if you cannot the previous solutions. See point (1)\n\n\nDifferent methods to iterate over rows in a Pandas dataframe:\n\nGenerate a random dataframe with a million rows and 4 columns:\n\n    df = pd.DataFrame(np.random.randint(0, 100, size=(1000000, 4)), columns=list(&apos;ABCD&apos;))\n    print(df)\n\n\n1) The usual iterrows() is convenient, but damn slow:\n\nstart_time = time.clock()\nresult = 0\nfor _, row in df.iterrows():\n    result += max(row[&apos;B&apos;], row[&apos;C&apos;])\n\ntotal_elapsed_time = round(time.clock() - start_time, 2)\nprint(&quot;1. Iterrows done in {} seconds, result = {}&quot;.format(total_elapsed_time, result))\n\n\n2) The default itertuples() is already much faster, but it doesn&apos;t work with column names such as My Col-Name is very Strange (you should avoid this method if your columns are repeated or if a column name cannot be simply converted to a Python variable name).:\n\nstart_time = time.clock()\nresult = 0\nfor row in df.itertuples(index=False):\n    result += max(row.B, row.C)\n\ntotal_elapsed_time = round(time.clock() - start_time, 2)\nprint(&quot;2. Named Itertuples done in {} seconds, result = {}&quot;.format(total_elapsed_time, result))\n\n\n3) The default itertuples() using name=None is even faster but not really convenient as you have to define a variable per column.\n\nstart_time = time.clock()\nresult = 0\nfor(_, col1, col2, col3, col4) in df.itertuples(name=None):\n    result += max(col2, col3)\n\ntotal_elapsed_time = round(time.clock() - start_time, 2)\nprint(&quot;3. Itertuples done in {} seconds, result = {}&quot;.format(total_elapsed_time, result))\n\n\n4) Finally, the named itertuples() is slower than the previous point, but you do not have to define a variable per column and it works with column names such as My Col-Name is very Strange.\n\nstart_time = time.clock()\nresult = 0\nfor row in df.itertuples(index=False):\n    result += max(row[df.columns.get_loc(&apos;B&apos;)], row[df.columns.get_loc(&apos;C&apos;)])\n\ntotal_elapsed_time = round(time.clock() - start_time, 2)\nprint(&quot;4. Polyvalent Itertuples working even with special characters in the column name done in {} seconds, result = {}&quot;.format(total_elapsed_time, result))\n\n\nOutput:\n\n         A   B   C   D\n0       41  63  42  23\n1       54   9  24  65\n2       15  34  10   9\n3       39  94  82  97\n4        4  88  79  54\n...     ..  ..  ..  ..\n999995  48  27   4  25\n999996  16  51  34  28\n999997   1  39  61  14\n999998  66  51  27  70\n999999  51  53  47  99\n\n[1000000 rows x 4 columns]\n\n1. Iterrows done in 104.96 seconds, result = 66151519\n2. Named Itertuples done in 1.26 seconds, result = 66151519\n3. Itertuples done in 0.94 seconds, result = 66151519\n4. Polyvalent Itertuples working even with special characters in the column name done in 2.94 seconds, result = 66151519\n\n\nThis article is a very interesting comparison between iterrows and itertuples\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"I was looking for How to iterate on rows and columns and ended here so:\n\nfor i, row in df.iterrows():\n    for j, column in row.iteritems():\n        print(column)\n\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"You can write your own iterator that implements namedtuple\n\nfrom collections import namedtuple\n\ndef myiter(d, cols=None):\n    if cols is None:\n        v = d.values.tolist()\n        cols = d.columns.values.tolist()\n    else:\n        j = [d.columns.get_loc(c) for c in cols]\n        v = d.values[:, j].tolist()\n\n    n = namedtuple(&apos;MyTuple&apos;, cols)\n\n    for line in iter(v):\n        yield n(*line)\n\n\nThis is directly comparable to pd.DataFrame.itertuples.  I&apos;m aiming at performing the same task with more efficiency.\n\n\n\nFor the given dataframe with my function:\n\nlist(myiter(df))\n\n[MyTuple(c1=10, c2=100), MyTuple(c1=11, c2=110), MyTuple(c1=12, c2=120)]\n\n\nOr with pd.DataFrame.itertuples:\n\nlist(df.itertuples(index=False))\n\n[Pandas(c1=10, c2=100), Pandas(c1=11, c2=110), Pandas(c1=12, c2=120)]\n\n\n\n\nA comprehensive test\nWe test making all columns available and subsetting the columns.  \n\ndef iterfullA(d):\n    return list(myiter(d))\n\ndef iterfullB(d):\n    return list(d.itertuples(index=False))\n\ndef itersubA(d):\n    return list(myiter(d, [&apos;col3&apos;, &apos;col4&apos;, &apos;col5&apos;, &apos;col6&apos;, &apos;col7&apos;]))\n\ndef itersubB(d):\n    return list(d[[&apos;col3&apos;, &apos;col4&apos;, &apos;col5&apos;, &apos;col6&apos;, &apos;col7&apos;]].itertuples(index=False))\n\nres = pd.DataFrame(\n    index=[10, 30, 100, 300, 1000, 3000, 10000, 30000],\n    columns=&apos;iterfullA iterfullB itersubA itersubB&apos;.split(),\n    dtype=float\n)\n\nfor i in res.index:\n    d = pd.DataFrame(np.random.randint(10, size=(i, 10))).add_prefix(&apos;col&apos;)\n    for j in res.columns:\n        stmt = &apos;{}(d)&apos;.format(j)\n        setp = &apos;from __main__ import d, {}&apos;.format(j)\n        res.at[i, j] = timeit(stmt, setp, number=100)\n\nres.groupby(res.columns.str[4:-1], axis=1).plot(loglog=True);\n\n\n\n\n\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"To loop all rows in a dataframe you can use:\n\nfor x in range(len(date_example.index)):\n    print date_example[&apos;Date&apos;].iloc[x]\n\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":" for ind in df.index:\n     print df[&apos;c1&apos;][ind], df[&apos;c2&apos;][ind]\n\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"We have multiple options to do the same, lots of folks have shared their answers.\nI found below two methods easy and efficient to do :\n\nDataFrame.iterrows()\nDataFrame.itertuples()\n\nExample:\n import pandas as pd\n inp = [{&apos;c1&apos;:10, &apos;c2&apos;:100}, {&apos;c1&apos;:11,&apos;c2&apos;:110}, {&apos;c1&apos;:12,&apos;c2&apos;:120}]\n df = pd.DataFrame(inp)\n print (df)\n\n #With iterrows method \n\n for index, row in df.iterrows():\n     print(row[&quot;c1&quot;], row[&quot;c2&quot;])\n\n #With itertuples method\n\n for row in df.itertuples(index=True, name=&apos;Pandas&apos;):\n     print(row.c1, row.c2)\n\nNote: itertuples() is supposed to be faster than iterrows()\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"Sometimes a useful pattern is:\n\n# Borrowing @KutalmisB df example\ndf = pd.DataFrame({&apos;col1&apos;: [1, 2], &apos;col2&apos;: [0.1, 0.2]}, index=[&apos;a&apos;, &apos;b&apos;])\n# The to_dict call results in a list of dicts\n# where each row_dict is a dictionary with k:v pairs of columns:value for that row\nfor row_dict in df.to_dict(orient=&apos;records&apos;):\n    print(row_dict)\n\n\nWhich results in:\n\n{&apos;col1&apos;:1.0, &apos;col2&apos;:0.1}\n{&apos;col1&apos;:2.0, &apos;col2&apos;:0.2}\n\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"Update: cs95 has updated his answer to include plain numpy vectorization. You can simply refer to his answer.\n\ncs95 shows that Pandas vectorization far outperforms other Pandas methods for computing stuff with dataframes.\nI wanted to add that if you first convert the dataframe to a NumPy array and then use vectorization, it&apos;s even faster than Pandas dataframe vectorization, (and that includes the time to turn it back into a dataframe series).\nIf you add the following functions to cs95&apos;s benchmark code, this becomes pretty evident:\ndef np_vectorization(df):\n    np_arr = df.to_numpy()\n    return pd.Series(np_arr[:,0] + np_arr[:,1], index=df.index)\n\ndef just_np_vectorization(df):\n    np_arr = df.to_numpy()\n    return np_arr[:,0] + np_arr[:,1]\n\n\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"In short\n\nUse vectorization if possible\nIf an operation can&apos;t be vectorized - use list comprehensions\nIf you need a single object representing the entire row - use itertuples\nIf the above is too slow - try swifter.apply\nIf it&apos;s still too slow - try a Cython routine\n\nBenchmark\n\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"To loop all rows in a dataframe and use values of each row conveniently, namedtuples can be converted to ndarrays. For example:\n\ndf = pd.DataFrame({&apos;col1&apos;: [1, 2], &apos;col2&apos;: [0.1, 0.2]}, index=[&apos;a&apos;, &apos;b&apos;])\n\n\nIterating over the rows:\n\nfor row in df.itertuples(index=False, name=&apos;Pandas&apos;):\n    print np.asarray(row)\n\n\nresults in:\n\n[ 1.   0.1]\n[ 2.   0.2]\n\n\nPlease note that if index=True, the index is added as the first element of the tuple, which may be undesirable for some applications.\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"There is a way to iterate throw rows while getting a DataFrame in return, and not a Series. I don&apos;t see anyone mentioning that you can pass index as a list for the row to be returned as a DataFrame:\n\nfor i in range(len(df)):\n    row = df.iloc[[i]]\n\n\nNote the usage of double brackets. This returns a DataFrame with a single row.\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0},{"text":"For both viewing and modifying values, I would use iterrows(). In a for loop and by using tuple unpacking (see the example: i, row), I use the row for only viewing the value and use i with the loc method when I want to modify values. As stated in previous answers, here you should not modify something you are iterating over.\n\nfor i, row in df.iterrows():\n    df_column_A = df.loc[i, &apos;A&apos;]\n    if df_column_A == &apos;Old_Value&apos;:\n        df_column_A = &apos;New_value&apos;  \n\n\nHere the row in the loop is a copy of that row, and not a view of it. Therefore, you should NOT write something like row[&apos;A&apos;] = &apos;New_Value&apos;, it will not modify the DataFrame. However, you can use i and loc and specify the DataFrame to do the work.\n    ","url":"/questions/[slug]#solution19","@type":"Answer","upvoteCount":0},{"text":"There are so many ways to iterate over the rows in Pandas dataframe. One very simple and intuitive way is:\n\ndf = pd.DataFrame({&apos;A&apos;:[1, 2, 3], &apos;B&apos;:[4, 5, 6], &apos;C&apos;:[7, 8, 9]})\nprint(df)\nfor i in range(df.shape[0]):\n    # For printing the second column\n    print(df.iloc[i, 1])\n\n    # For printing more than one columns\n    print(df.iloc[i, [0, 2]])\n\n    ","url":"/questions/[slug]#solution20","@type":"Answer","upvoteCount":0},{"text":"The easiest way, use the apply function\ndef print_row(row):\n   print row[&apos;c1&apos;], row[&apos;c2&apos;]\n\ndf.apply(lambda row: print_row(row), axis=1)\n\n    ","url":"/questions/[slug]#solution21","@type":"Answer","upvoteCount":0},{"text":"As many answers here correctly and clearly point out, you should not generally attempt to loop in Pandas, but rather should write vectorized code.  But the question remains if you should ever write loops in Pandas, and if so the best way to loop in those situations.\nI believe there is at least one general situation where loops are appropriate: when you need to calculate some function that depends on values in other rows in a somewhat complex manner.  In this case, the looping code is often simpler, more readable, and less error prone than vectorized code.  The looping code might even be faster, too.\nI will attempt to show this with an example.  Suppose you want to take a cumulative sum of a column, but reset it whenever some other column equals zero:\nimport pandas as pd\nimport numpy as np\n\ndf = pd.DataFrame( { &apos;x&apos;:[1,2,3,4,5,6], &apos;y&apos;:[1,1,1,0,1,1]  } )\n\n#   x  y  desired_result\n#0  1  1               1\n#1  2  1               3\n#2  3  1               6\n#3  4  0               4\n#4  5  1               9\n#5  6  1              15\n\nThis is a good example where you could certainly write one line of Pandas to achieve this, although it&apos;s not especially readable, especially if you aren&apos;t fairly experienced with Pandas already:\ndf.groupby( (df.y==0).cumsum() )[&apos;x&apos;].cumsum()\n\nThat&apos;s going to be fast enough for most situations, although you could also write faster code by avoiding the groupby, but it will likely be even less readable.\nAlternatively, what if we write this as a loop?  You could do something like the following with NumPy:\nimport numba as nb\n\n@nb.jit(nopython=True)  # Optional\ndef custom_sum(x,y):\n    x_sum = x.copy()\n    for i in range(1,len(df)):\n        if y[i] &gt; 0: x_sum[i] = x_sum[i-1] + x[i]\n    return x_sum\n\ndf[&apos;desired_result&apos;] = custom_sum( df.x.to_numpy(), df.y.to_numpy() )\n\nAdmittedly, there&apos;s a bit of overhead there required to convert DataFrame columns to NumPy arrays, but the core piece of code is just one line of code that you could read even if you didn&apos;t know anything about Pandas or NumPy:\nif y[i] &gt; 0: x_sum[i] = x_sum[i-1] + x[i]\n\nAnd this code is actually faster than the vectorized code.  In some quick tests with 100,000 rows, the above is about 10x faster than the groupby approach.  Note that one key to the speed there is numba, which is optional.  Without the &quot;@nb.jit&quot; line, the looping code is actually about 10x slower than the groupby approach.\nClearly this example is simple enough that you would likely prefer the one line of pandas to writing a loop with its associated overhead.  However, there are more complex versions of this problem for which the readability or speed of the NumPy/numba loop approach likely makes sense.\n    ","url":"/questions/[slug]#solution22","@type":"Answer","upvoteCount":0},{"text":"df.iterrows() returns tuple(a, b) where a is the index and b is the row.\n    ","url":"/questions/[slug]#solution23","@type":"Answer","upvoteCount":0},{"text":"You can also do NumPy indexing for even greater speed ups. It&apos;s not really iterating but works much better than iteration for certain applications.\n\nsubset = row[&apos;c1&apos;][0:5]\nall = row[&apos;c1&apos;][:]\n\n\nYou may also want to cast it to an array. These indexes/selections are supposed to act like NumPy arrays already, but I ran into issues and needed to cast\n\nnp.asarray(all)\nimgs[:] = cv2.resize(imgs[:], (224,224) ) # Resize every image in an hdf5 file\n\n    ","url":"/questions/[slug]#solution24","@type":"Answer","upvoteCount":0},{"text":"Disclaimer: Although here are so many answers which recommend not using an iterative (loop) approach (and I mostly agree), I would still see it as a reasonable approach for the following situation:\nExtend dataframe with data from API\nLet&apos;s say you have a large dataframe which contains incomplete user data. Now you have to extend this data with additional columns, for example the user&apos;s age and gender.\nBoth values have to be fetched from a backend API. I&apos;m assuming the API doesn&apos;t provide a &quot;batch&quot; endpoint (which would accept multiple user IDs at once). Otherwise, you should rather call the API only once.\nThe costs (waiting time) for the network request surpass the iteration of the dataframe by far. We&apos;re talking about network roundtrip times of hundreds of milliseconds compared to the negligibly small gains in using alternative approaches to iterations.\n1 expensive network request for each row\nSo in this case, I would absolutely prefer using an iterative approach. Although the network request is expensive, it is guaranteed being triggered only once for each row in the dataframe. Here is an example using DataFrame.iterrows:\nExample\nfor index, row in users_df.iterrows():\n  user_id = row[&apos;user_id&apos;]\n  # trigger expensive network request once for each row\n  response_dict = backend_api.get(f&apos;/api/user-data/{user_id}&apos;)\n  # extend dataframe with multiple data from response\n  users_df.at[index, &apos;age&apos;] = response_dict.get(&apos;age&apos;)\n  users_df.at[index, &apos;gender&apos;] = response_dict.get(&apos;gender&apos;)\n\n    ","url":"/questions/[slug]#solution25","@type":"Answer","upvoteCount":0},{"text":"This example uses iloc to isolate each digit in the data frame. \n\nimport pandas as pd\n\n a = [1, 2, 3, 4]\n b = [5, 6, 7, 8]\n\n mjr = pd.DataFrame({&apos;a&apos;:a, &apos;b&apos;:b})\n\n size = mjr.shape\n\n for i in range(size[0]):\n     for j in range(size[1]):\n         print(mjr.iloc[i, j])\n\n    ","url":"/questions/[slug]#solution26","@type":"Answer","upvoteCount":0},{"text":"Some libraries (e.g. a Java interop library that I use) require values to be passed in a row at a time, for example, if streaming data. To replicate the streaming nature, I &apos;stream&apos; my dataframe values one by one, I wrote the below, which comes in handy from time to time.\n\nclass DataFrameReader:\n  def __init__(self, df):\n    self._df = df\n    self._row = None\n    self._columns = df.columns.tolist()\n    self.reset()\n    self.row_index = 0\n\n  def __getattr__(self, key):\n    return self.__getitem__(key)\n\n  def read(self) -&gt; bool:\n    self._row = next(self._iterator, None)\n    self.row_index += 1\n    return self._row is not None\n\n  def columns(self):\n    return self._columns\n\n  def reset(self) -&gt; None:\n    self._iterator = self._df.itertuples()\n\n  def get_index(self):\n    return self._row[0]\n\n  def index(self):\n    return self._row[0]\n\n  def to_dict(self, columns: List[str] = None):\n    return self.row(columns=columns)\n\n  def tolist(self, cols) -&gt; List[object]:\n    return [self.__getitem__(c) for c in cols]\n\n  def row(self, columns: List[str] = None) -&gt; Dict[str, object]:\n    cols = set(self._columns if columns is None else columns)\n    return {c : self.__getitem__(c) for c in self._columns if c in cols}\n\n  def __getitem__(self, key) -&gt; object:\n    # the df index of the row is at index 0\n    try:\n        if type(key) is list:\n            ix = [self._columns.index(key) + 1 for k in key]\n        else:\n            ix = self._columns.index(key) + 1\n        return self._row[ix]\n    except BaseException as e:\n        return None\n\n  def __next__(self) -&gt; &apos;DataFrameReader&apos;:\n    if self.read():\n        return self\n    else:\n        raise StopIteration\n\n  def __iter__(self) -&gt; &apos;DataFrameReader&apos;:\n    return self\n\n\nWhich can be used:\n\nfor row in DataFrameReader(df):\n  print(row.my_column_name)\n  print(row.to_dict())\n  print(row[&apos;my_column_name&apos;])\n  print(row.tolist())\n\n\nAnd preserves the values/ name mapping for the rows being iterated. Obviously, is a lot slower than using apply and Cython as indicated above, but is necessary in some circumstances.\n    ","url":"/questions/[slug]#solution27","@type":"Answer","upvoteCount":0},{"text":"Along with the great answers in this post I am going to propose Divide and Conquer approach, I am not writing this answer to abolish the other great answers but to fulfill them with another approach which was working efficiently for me. It has two steps of splitting and merging the pandas dataframe:\nPROS of Divide and Conquer:\n\nYou don&apos;t need to use vectorization or any other methods to cast the type of your dataframe into another type\nYou don&apos;t need to Cythonize your code which normally takes extra time from you\nBoth iterrows() and itertuples() in my case were having the same performance over entire dataframe\nDepends on your choice of slicing index, you will be able to exponentially quicken the iteration. The higher index, the quicker your iteration process.\n\nCONS of Divide and Conquer:\n\nYou shouldn&apos;t have dependency over the iteration process to the same dataframe and different slice. Meaning if you want to read or write from other slice, it maybe difficult to do that.\n\n===================    Divide and Conquer Approach    =================\nStep 1: Splitting/Slicing\nIn this step, we are going to divide the iteration over the entire dataframe. Think that you are going to read a csv file into pandas df then iterate over it. In may case I have 5,000,000 records and I am going to split it into 100,000 records.\nNOTE: I need to reiterate as other runtime analysis explained in the other solutions in this page, &quot;number of records&quot; has exponential proportion of &quot;runtime&quot; on search on the df. Based on the benchmark on my data here are the results:\nNumber of records | Iteration per second\n========================================\n100,000           | 500 it/s\n500,000           | 200 it/s\n1,000,000         | 50 it/s\n5,000,000         | 20 it/s\n\nStep 2: Merging\nThis is going to be an easy step, just merge all the written csv files into one dataframe and write it into a bigger csv file.\nHere is the sample code:\n# Step 1 (Splitting/Slicing)\nimport pandas as pd\ndf_all = pd.read_csv(&apos;C:/KtV.csv&apos;)\ndf_index = 100000\ndf_len = len(df)\nfor i in range(df_len // df_index + 1):\n    lower_bound = i * df_index \n    higher_bound = min(lower_bound + df_index, df_len)\n    # splitting/slicing df (make sure to copy() otherwise it will be a view\n    df = df_all[lower_bound:higher_bound].copy()\n    &apos;&apos;&apos;\n    write your iteration over the sliced df here\n    using iterrows() or intertuples() or ...\n    &apos;&apos;&apos;\n    # writing into csv files\n    df.to_csv(&apos;C:/KtV_prep_&apos;+str(i)+&apos;.csv&apos;)\n\n\n\n# Step 2 (Merging)\nfilename=&apos;C:/KtV_prep_&apos;\ndf = (pd.read_csv(f) for f in [filename+str(i)+&apos;.csv&apos; for i in range(ktv_len // ktv_index + 1)])\ndf_prep_all = pd.concat(df)\ndf_prep_all.to_csv(&apos;C:/KtV_prep_all.csv&apos;)\n\nReference:\nEfficient way of iteration over datafreame\nConcatenate csv files into one Pandas Dataframe\n    ","url":"/questions/[slug]#solution28","@type":"Answer","upvoteCount":0},{"text":"As the accepted answer states, the fastest way to apply a function over rows is to use a vectorized function, the so-called NumPy ufuncs (universal functions).\nBut what should you do when the function you want to apply isn&apos;t already implemented in NumPy?\nWell, using the vectorize decorator from numba, you can easily create ufuncs directly in Python like this:\nfrom numba import vectorize, float64\n\n@vectorize([float64(float64)])\ndef f(x):\n    #x is your line, do something with it, and return a float\n\nThe documentation for this function is here: Creating NumPy universal functions\n    ","url":"/questions/[slug]#solution29","@type":"Answer","upvoteCount":0},{"text":"Probably the most elegant solution (but certainly not the most efficient):\nfor row in df.values:\n    c2 = row[1]\n    print(row)\n    # ...\n\nfor c1, c2 in df.values:\n    # ...\n\nNote that:\n\nthe documentation explicitly recommends to use .to_numpy() instead\nthe produced NumPy array will have a dtype that fits all columns, in the worst case object\nthere are good reasons not to use a loop in the first place\n\nStill, I think this option should be included here, as a straight-forward solution to a (one should think) trivial problem.\n    ","url":"/questions/[slug]#solution30","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-12e9794e898cd5f3.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-928c5d1eb8fb0bba.js" defer=""></script><script src="/_next/static/BnkbnjkWYxefPXjTJLVVv/_buildManifest.js" defer=""></script><script src="/_next/static/BnkbnjkWYxefPXjTJLVVv/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/how-to-iterate-over-rows-in-a-dataframe-in-pandas-1657387358115#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/how-to-iterate-over-rows-in-a-dataframe-in-pandas-1657387358115"><h1>How to iterate over rows in a DataFrame in Pandas</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"></div></div><div class="question-content mt-5">
                
<p>I have a pandas dataframe, <code>df</code>:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">   c1   c2
<span class="hljs-number">0</span>  <span class="hljs-number">10</span>  <span class="hljs-number">100</span>
<span class="hljs-number">1</span>  <span class="hljs-number">11</span>  <span class="hljs-number">110</span>
<span class="hljs-number">2</span>  <span class="hljs-number">12</span>  <span class="hljs-number">120</span>
</code></pre>
<p>How do I iterate over the rows of this dataframe? For every row, I want to be able to access its elements (values in cells) by the name of the columns. For example:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> df.rows:
   <span class="hljs-built_in">print</span>(row[<span class="hljs-string">'c1'</span>], row[<span class="hljs-string">'c2'</span>])
</code></pre>
<hr>
<p>I found a <a href="https://stackoverflow.com/questions/7837722/what-is-the-most-efficient-way-to-loop-through-dataframes-with-pandas">similar question</a> which suggests using either of these:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">for</span> date, row <span class="hljs-keyword">in</span> df.T.iteritems():
</code></pre>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> df.iterrows():
</code></pre>
<p>But I do not understand what the <code>row</code> object is and how I can work with it.</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li><li class="pagination-solution-item"><span data-id="#solution19" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">19</span></li><li class="pagination-solution-item"><span data-id="#solution20" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">20</span></li><li class="pagination-solution-item"><span data-id="#solution21" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">21</span></li><li class="pagination-solution-item"><span data-id="#solution22" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">22</span></li><li class="pagination-solution-item"><span data-id="#solution23" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">23</span></li><li class="pagination-solution-item"><span data-id="#solution24" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">24</span></li><li class="pagination-solution-item"><span data-id="#solution25" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">25</span></li><li class="pagination-solution-item"><span data-id="#solution26" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">26</span></li><li class="pagination-solution-item"><span data-id="#solution27" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">27</span></li><li class="pagination-solution-item"><span data-id="#solution28" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">28</span></li><li class="pagination-solution-item"><span data-id="#solution29" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">29</span></li><li class="pagination-solution-item"><span data-id="#solution30" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">30</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iterrows.html#pandas-dataframe-iterrows" rel="noreferrer"><code>DataFrame.iterrows</code></a> is a generator which yields both the index and row (as a Series):</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd

df = pd.DataFrame({<span class="hljs-string">'c1'</span>: [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>], <span class="hljs-string">'c2'</span>: [<span class="hljs-number">100</span>, <span class="hljs-number">110</span>, <span class="hljs-number">120</span>]})
df = df.reset_index()  <span class="hljs-comment"># make sure indexes pair with number of rows</span>

<span class="hljs-keyword">for</span> index, row <span class="hljs-keyword">in</span> df.iterrows():
    <span class="hljs-built_in">print</span>(row[<span class="hljs-string">'c1'</span>], row[<span class="hljs-string">'c2'</span>])
</code></pre>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-number">10</span> <span class="hljs-number">100</span>
<span class="hljs-number">11</span> <span class="hljs-number">110</span>
<span class="hljs-number">12</span> <span class="hljs-number">120</span>
</code></pre>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<blockquote>
<h2>How to iterate over rows in a DataFrame in Pandas?</h2>
</blockquote>
<h1>Answer: DON'T<sup>*</sup>!</h1>
<p>Iteration in Pandas is an anti-pattern and is something you should only do when you have exhausted every other option. You should not use any function with "<code>iter</code>" in its name for more than a few thousand rows or you will have to get used to a <strong>lot</strong> of waiting.</p>
<p>Do you want to print a DataFrame? Use <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_string.html" rel="noreferrer"><strong><code>DataFrame.to_string()</code></strong></a>.</p>
<p>Do you want to compute something? In that case, search for methods in this order (list modified from <a href="https://stackoverflow.com/questions/24870953/does-iterrows-have-performance-issues">here</a>):</p>
<ol>
<li>Vectorization</li>
<li><a href="https://en.wikipedia.org/wiki/Cython" rel="noreferrer">Cython</a> routines</li>
<li>List Comprehensions (vanilla <code>for</code> loop)</li>
<li><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.apply.html" rel="noreferrer"><strong><code>DataFrame.apply()</code></strong></a>: i) &nbsp;Reductions that can be performed in Cython, ii) Iteration in Python space</li>
<li><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.itertuples.html" rel="noreferrer"><strong><code>DataFrame.itertuples()</code></strong></a> and <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iteritems.html#pandas.DataFrame.iteritems" rel="noreferrer"><strong><code>iteritems()</code></strong></a></li>
<li><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows" rel="noreferrer"><strong><code>DataFrame.iterrows()</code></strong></a></li>
</ol>
<p><code>iterrows</code> and <code>itertuples</code> (both receiving many votes in answers to this question) should be used in very rare circumstances, such as generating row objects/nametuples for sequential processing, which is really the only thing these functions are useful for.</p>
<p><strong>Appeal to Authority</strong></p>
<p><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/basics.html#iteration" rel="noreferrer">The documentation page</a> on iteration has a huge red warning box that says:</p>
<blockquote>
<p>Iterating through pandas objects is generally slow. In many cases, iterating manually over the rows is not needed [...].</p>
</blockquote>
<p><sub>* It's actually a little more complicated than "don't". <code>df.iterrows()</code> is the correct answer to this question, but "vectorize your ops" is the better one. I will concede that there are circumstances where iteration cannot be avoided (for example, some operations where the result depends on the value computed for the previous row). However, it takes some familiarity with the library to know when. If you're not sure whether you need an iterative solution, you probably don't. PS: To know more about my rationale for writing this answer, skip to the very bottom.</sub></p>
<hr>
<h2>Faster than Looping: <a href="https://stackoverflow.com/questions/1422149/what-is-vectorization">Vectorization</a>, <a href="https://cython.org" rel="noreferrer">Cython</a></h2>
<p>A good number of basic operations and computations are "vectorised" by pandas (either through NumPy, or through Cythonized functions). This includes arithmetic, comparisons, (most) reductions, reshaping (such as pivoting), joins, and groupby operations. Look through the documentation on <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/basics.html#essential-basic-functionality" rel="noreferrer">Essential Basic Functionality</a> to find a suitable vectorised method for your problem.</p>
<p>If none exists, feel free to write your own using custom <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/enhancingperf.html#cython-writing-c-extensions-for-pandas" rel="noreferrer">Cython extensions</a>.</p>
<hr>
<h2>Next Best Thing: <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="noreferrer">List Comprehensions</a><sup>*</sup></h2>
<p>List comprehensions should be your next port of call if 1) there is no vectorized solution available, 2) performance is important, but not important enough to go through the hassle of cythonizing your code, and 3) you're trying to perform elementwise transformation on your code. There is a <a href="https://stackoverflow.com/questions/54028199/for-loops-with-pandas-when-should-i-care">good amount of evidence</a> to suggest that list comprehensions are sufficiently fast (and even sometimes faster) for many common Pandas tasks.</p>
<p>The formula is simple,</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment"># Iterating over one column - `f` is some function that processes your data</span>
result = [f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> df[<span class="hljs-string">'col'</span>]]
<span class="hljs-comment"># Iterating over two columns, use `zip`</span>
result = [f(x, y) <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(df[<span class="hljs-string">'col1'</span>], df[<span class="hljs-string">'col2'</span>])]
<span class="hljs-comment"># Iterating over multiple columns - same data type</span>
result = [f(row[<span class="hljs-number">0</span>], ..., row[n]) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> df[[<span class="hljs-string">'col1'</span>, ...,<span class="hljs-string">'coln'</span>]].to_numpy()]
<span class="hljs-comment"># Iterating over multiple columns - differing data type</span>
result = [f(row[<span class="hljs-number">0</span>], ..., row[n]) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(df[<span class="hljs-string">'col1'</span>], ..., df[<span class="hljs-string">'coln'</span>])]
</code></pre>
<p>If you can encapsulate your business logic into a function, you can use a list comprehension that calls it. You can make arbitrarily complex things work through the simplicity and speed of raw Python code.</p>
<p><strong>Caveats</strong></p>
<p>List comprehensions assume that your data is easy to work with - what that means is your data types are consistent and you don't have NaNs, but this cannot always be guaranteed.</p>
<ol>
<li>The first one is more obvious, but when dealing with NaNs, prefer in-built pandas methods if they exist (because they have much better corner-case handling logic), or ensure your business logic includes appropriate NaN handling logic.</li>
<li>When dealing with mixed data types you should iterate over <code>zip(df['A'], df['B'], ...)</code> instead of <code>df[['A', 'B']].to_numpy()</code> as the latter implicitly upcasts data to the most common type. As an example if A is numeric and B is string, <code>to_numpy()</code> will cast the entire array to string, which may not be what you want. Fortunately <code>zip</code>ping your columns together is the most straightforward workaround to this.</li>
</ol>
<p><sub>*Your mileage may vary for the reasons outlined in the <strong>Caveats</strong> section above.</sub></p>
<hr>
<h2>An Obvious Example</h2>
<p>Let's demonstrate the difference with a simple example of adding two pandas columns <code>A + B</code>. This is a vectorizable operaton, so it will be easy to contrast the performance of the methods discussed above.</p>
<img src="https://i.stack.imgur.com/y44RJ.png" width="600">
<p><a href="https://gist.github.com/Coldsp33d/948f96b384ca5bdf6e8ce203ac97c9a0" rel="noreferrer">Benchmarking code, for your reference</a>. The line at the bottom measures a function written in numpandas, a style of Pandas that mixes heavily with NumPy to squeeze out maximum performance. Writing numpandas code should be avoided unless you know what you're doing. Stick to the API where you can (i.e., prefer <code>vec</code> over <code>vec_numpy</code>).</p>
<p>I should mention, however, that it isn't always this cut and dry. Sometimes the answer to "what is the best method for an operation" is "it depends on your data". My advice is to test out different approaches on your data before settling on one.</p>
<hr>
<h2>My Personal Opinion <sup>*</sup></h2>
<p>Most of the analyses performed on the various alternatives to the iter family has been through the lens of performance. However, in most situations you will typically be working on a reasonably sized dataset (nothing beyond a few thousand or 100K rows) and performance will come second to simplicity/readability of the solution.</p>
<p>Here is my personal preference when selecting a method to use for a problem.</p>
<p>For the novice:</p>
<blockquote>
<p><em>Vectorization</em> (when possible)<em>; <code>apply()</code>; List Comprehensions; <code>itertuples()</code>/<code>iteritems()</code>; <code>iterrows()</code>; Cython</em></p>
</blockquote>
<p>For the more experienced:</p>
<blockquote>
<p><em>Vectorization</em> (when possible)<em>; <code>apply()</code>; List Comprehensions; Cython; <code>itertuples()</code>/<code>iteritems()</code>; <code>iterrows()</code></em></p>
</blockquote>
<p>Vectorization prevails as the most idiomatic method for any problem that can be vectorized. Always seek to vectorize! When in doubt, consult the docs, or look on Stack Overflow for an existing question on your particular task.</p>
<p>I do tend to go on about how bad <code>apply</code> is in a lot of my posts, but I do concede it is easier for a beginner to wrap their head around what it's doing. Additionally, there are quite a few use cases for <code>apply</code> has explained in <a href="https://stackoverflow.com/questions/54432583/when-should-i-not-want-to-use-pandas-apply-in-my-code">this post of mine</a>.</p>
<p>Cython ranks lower down on the list because it takes more time and effort to pull off correctly. You will usually never need to write code with pandas that demands this level of performance that even a list comprehension cannot satisfy.</p>
<p><sub>* As with any personal opinion, please take with heaps of salt!</sub></p>
<hr>
<h2>Further Reading</h2>
<ul>
<li><p><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/10min.html" rel="noreferrer">10 Minutes to pandas</a>, and <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/basics.html" rel="noreferrer">Essential Basic Functionality</a> - Useful links that introduce you to Pandas and its library of vectorized*/cythonized functions.</p>
</li>
<li><p><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/enhancingperf.html" rel="noreferrer">Enhancing Performance</a> - A primer from the documentation on enhancing standard Pandas operations</p>
</li>
<li><p><em><a href="https://stackoverflow.com/questions/54028199/for-loops-with-pandas-when-should-i-care">Are for-loops in pandas really bad? When should I care?</a></em> - a detailed writeup by me on list comprehensions and their suitability for various operations (mainly ones involving non-numeric data)</p>
</li>
<li><p><em><a href="https://stackoverflow.com/questions/54432583/when-should-i-ever-want-to-use-pandas-apply-in-my-code">When should I (not) want to use pandas apply() in my code?</a></em> - <code>apply</code> is slow (but not as slow as the <code>iter*</code> family. There are, however, situations where one can (or should) consider <code>apply</code> as a serious alternative, especially in some <code>GroupBy</code> operations).</p>
</li>
</ul>
<p><sub>* Pandas string methods are "vectorized" in the sense that they are specified on the series but operate on each element. The underlying mechanisms are still iterative, because string operations are inherently hard to vectorize.</sub></p>
<hr>
<h2>Why I Wrote this Answer</h2>
<p>A common trend I notice from new users is to ask questions of the form "How can I iterate over my df to do X?". Showing code that calls <code>iterrows()</code> while doing something inside a <code>for</code> loop. Here is why. A new user to the library who has not been introduced to the concept of vectorization will likely envision the code that solves their problem as iterating over their data to do something. Not knowing how to iterate over a DataFrame, the first thing they do is Google it and end up here, at this question. They then see the accepted answer telling them how to, and they close their eyes and run this code without ever first questioning if iteration is the right thing to do.</p>
<p>The aim of this answer is to help new users understand that iteration is not necessarily the solution to every problem, and that better, faster and more idiomatic solutions could exist, and that it is worth investing time in exploring them. I'm not trying to start a war of iteration vs. vectorization, but I want new users to be informed when developing solutions to their problems with this library.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>First consider if you really need to <em>iterate</em> over rows in a DataFrame. See <a href="https://stackoverflow.com/a/55557758/3844376">this answer</a> for alternatives.</p>
<p>If you still need to iterate over rows, you can use methods below. Note some  <strong>important caveats</strong> which are not mentioned in any of the other answers.</p>
<ul>
<li><p><a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.iterrows.html" rel="noreferrer">DataFrame.iterrows()</a></p>
<pre class="lang-py s-code-block"><code class="hljs language-python">  <span class="hljs-keyword">for</span> index, row <span class="hljs-keyword">in</span> df.iterrows():
      <span class="hljs-built_in">print</span>(row[<span class="hljs-string">"c1"</span>], row[<span class="hljs-string">"c2"</span>])
</code></pre>
</li>
<li><p><a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.itertuples.html" rel="noreferrer">DataFrame.itertuples()</a></p>
<pre class="lang-py s-code-block"><code class="hljs language-python">  <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> df.itertuples(index=<span class="hljs-literal">True</span>, name=<span class="hljs-string">'Pandas'</span>):
      <span class="hljs-built_in">print</span>(row.c1, row.c2)
</code></pre>
</li>
</ul>
<p><code>itertuples()</code> is supposed to be faster than <code>iterrows()</code></p>
<p>But be aware, according to the docs (pandas 0.24.2 at the moment):</p>
<ul>
<li>iterrows: <code>dtype</code> might not match from row to row</li>
</ul>
<blockquote>
<p>Because iterrows returns a Series for each row, it <strong>does not preserve</strong> dtypes across the rows (dtypes are preserved across columns for DataFrames). To preserve dtypes while iterating over the rows, it is better to use itertuples() which returns namedtuples of the values and which is generally much faster than iterrows()</p>
</blockquote>
<ul>
<li>iterrows: Do not modify rows</li>
</ul>
<blockquote>
<p>You should <strong>never modify</strong> something you are iterating over. This is not guaranteed to work in all cases. Depending on the data types, the iterator returns a copy and not a view, and writing to it will have no effect.</p>
</blockquote>
<p>Use <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.apply.html" rel="noreferrer">DataFrame.apply()</a> instead:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">    new_df = df.apply(<span class="hljs-keyword">lambda</span> x: x * <span class="hljs-number">2</span>, axis = <span class="hljs-number">1</span>)
</code></pre>
<ul>
<li>itertuples:</li>
</ul>
<blockquote>
<p>The column names will be renamed to positional names if they are invalid Python identifiers, repeated, or start with an underscore. With a large number of columns (&gt;255), regular tuples are returned.</p>
</blockquote>
<p>See <a href="https://pandas.pydata.org/docs/user_guide/basics.html#iteration" rel="noreferrer">pandas docs on iteration</a> for more details.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You should use <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.iterrows.html" rel="noreferrer"><code>df.iterrows()</code></a>. Though iterating row-by-row is not especially efficient since <code>Series</code> objects have to be created.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>While <code>iterrows()</code> is a good option, sometimes <code>itertuples()</code> can be much faster:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">df = pd.DataFrame({<span class="hljs-string">'a'</span>: randn(<span class="hljs-number">1000</span>), <span class="hljs-string">'b'</span>: randn(<span class="hljs-number">1000</span>),<span class="hljs-string">'N'</span>: randint(<span class="hljs-number">100</span>, <span class="hljs-number">1000</span>, (<span class="hljs-number">1000</span>)), <span class="hljs-string">'x'</span>: <span class="hljs-string">'x'</span>})

%timeit [row.a * <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> idx, row <span class="hljs-keyword">in</span> df.iterrows()]
<span class="hljs-comment"># =&gt; 10 loops, best of 3: 50.3 ms per loop</span>

%timeit [row[<span class="hljs-number">1</span>] * <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> df.itertuples()]
<span class="hljs-comment"># =&gt; 1000 loops, best of 3: 541 µs per loop</span>
</code></pre>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You can use the <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.iloc.html" rel="noreferrer"><code>df.iloc</code></a> function as follows:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(df)):
    <span class="hljs-built_in">print</span>(df.iloc[i][<span class="hljs-string">'c1'</span>], df.iloc[i][<span class="hljs-string">'c2'</span>])
</code></pre>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You can also use <code>df.apply()</code> to iterate over rows and access multiple columns for a function.</p>

<p><a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.apply.html">docs: DataFrame.apply()</a></p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">valuation_formula</span>(<span class="hljs-params">x, y</span>):
    <span class="hljs-keyword">return</span> x * y * <span class="hljs-number">0.5</span>

df[<span class="hljs-string">'price'</span>] = df.apply(<span class="hljs-keyword">lambda</span> row: valuation_formula(row[<span class="hljs-string">'x'</span>], row[<span class="hljs-string">'y'</span>]), axis=<span class="hljs-number">1</span>)
</code></pre>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>How to iterate efficiently</h1>

<p>If you really have to iterate a Pandas dataframe, you will probably want to <strong>avoid using iterrows()</strong>. There are different methods and the usual <code>iterrows()</code> is far from being the best. <strong>itertuples() can be 100 times faster.</strong></p>

<p><strong>In short:</strong></p>

<ul>
<li>As a general rule, use <code>df.itertuples(name=None)</code>. In particular, when you have a fixed number columns and less than 255 columns. <em>See point (3)</em></li>
<li>Otherwise, use <code>df.itertuples()</code> except if your columns have special characters such as spaces or '-'. <em>See point (2)</em></li>
<li>It is possible to use <code>itertuples()</code> even if your dataframe has strange columns by using the last example. <em>See point (4)</em></li>
<li>Only use <code>iterrows()</code> if you cannot the previous solutions. <em>See point (1)</em></li>
</ul>

<h1>Different methods to iterate over rows in a Pandas dataframe:</h1>

<p>Generate a random dataframe with a million rows and 4 columns:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">    df = pd.DataFrame(np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, size=(<span class="hljs-number">1000000</span>, <span class="hljs-number">4</span>)), columns=<span class="hljs-built_in">list</span>(<span class="hljs-string">'ABCD'</span>))
    <span class="hljs-built_in">print</span>(df)
</code></pre>

<p>1) The usual <code>iterrows()</code> is convenient, but damn slow:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">start_time = time.clock()
result = <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> _, row <span class="hljs-keyword">in</span> df.iterrows():
    result += <span class="hljs-built_in">max</span>(row[<span class="hljs-string">'B'</span>], row[<span class="hljs-string">'C'</span>])

total_elapsed_time = <span class="hljs-built_in">round</span>(time.clock() - start_time, <span class="hljs-number">2</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"1. Iterrows done in {} seconds, result = {}"</span>.<span class="hljs-built_in">format</span>(total_elapsed_time, result))
</code></pre>

<p>2) The default <code>itertuples()</code> is already much faster, but it doesn't work with column names such as <code>My Col-Name is very Strange</code> (you should avoid this method if your columns are repeated or if a column name cannot be simply converted to a Python variable name).:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">start_time = time.clock()
result = <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> df.itertuples(index=<span class="hljs-literal">False</span>):
    result += <span class="hljs-built_in">max</span>(row.B, row.C)

total_elapsed_time = <span class="hljs-built_in">round</span>(time.clock() - start_time, <span class="hljs-number">2</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"2. Named Itertuples done in {} seconds, result = {}"</span>.<span class="hljs-built_in">format</span>(total_elapsed_time, result))
</code></pre>

<p>3) The default <code>itertuples()</code> using name=None is even faster but not really convenient as you have to define a variable per column.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">start_time = time.clock()
result = <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span>(_, col1, col2, col3, col4) <span class="hljs-keyword">in</span> df.itertuples(name=<span class="hljs-literal">None</span>):
    result += <span class="hljs-built_in">max</span>(col2, col3)

total_elapsed_time = <span class="hljs-built_in">round</span>(time.clock() - start_time, <span class="hljs-number">2</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"3. Itertuples done in {} seconds, result = {}"</span>.<span class="hljs-built_in">format</span>(total_elapsed_time, result))
</code></pre>

<p>4) Finally, the named <code>itertuples()</code> is slower than the previous point, but you do not have to define a variable per column and it works with column names such as <code>My Col-Name is very Strange</code>.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">start_time = time.clock()
result = <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> df.itertuples(index=<span class="hljs-literal">False</span>):
    result += <span class="hljs-built_in">max</span>(row[df.columns.get_loc(<span class="hljs-string">'B'</span>)], row[df.columns.get_loc(<span class="hljs-string">'C'</span>)])

total_elapsed_time = <span class="hljs-built_in">round</span>(time.clock() - start_time, <span class="hljs-number">2</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"4. Polyvalent Itertuples working even with special characters in the column name done in {} seconds, result = {}"</span>.<span class="hljs-built_in">format</span>(total_elapsed_time, result))
</code></pre>

<p>Output:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">         A   B   C   D
<span class="hljs-number">0</span>       <span class="hljs-number">41</span>  <span class="hljs-number">63</span>  <span class="hljs-number">42</span>  <span class="hljs-number">23</span>
<span class="hljs-number">1</span>       <span class="hljs-number">54</span>   <span class="hljs-number">9</span>  <span class="hljs-number">24</span>  <span class="hljs-number">65</span>
<span class="hljs-number">2</span>       <span class="hljs-number">15</span>  <span class="hljs-number">34</span>  <span class="hljs-number">10</span>   <span class="hljs-number">9</span>
<span class="hljs-number">3</span>       <span class="hljs-number">39</span>  <span class="hljs-number">94</span>  <span class="hljs-number">82</span>  <span class="hljs-number">97</span>
<span class="hljs-number">4</span>        <span class="hljs-number">4</span>  <span class="hljs-number">88</span>  <span class="hljs-number">79</span>  <span class="hljs-number">54</span>
<span class="hljs-meta">... </span>    ..  ..  ..  ..
<span class="hljs-number">999995</span>  <span class="hljs-number">48</span>  <span class="hljs-number">27</span>   <span class="hljs-number">4</span>  <span class="hljs-number">25</span>
<span class="hljs-number">999996</span>  <span class="hljs-number">16</span>  <span class="hljs-number">51</span>  <span class="hljs-number">34</span>  <span class="hljs-number">28</span>
<span class="hljs-number">999997</span>   <span class="hljs-number">1</span>  <span class="hljs-number">39</span>  <span class="hljs-number">61</span>  <span class="hljs-number">14</span>
<span class="hljs-number">999998</span>  <span class="hljs-number">66</span>  <span class="hljs-number">51</span>  <span class="hljs-number">27</span>  <span class="hljs-number">70</span>
<span class="hljs-number">999999</span>  <span class="hljs-number">51</span>  <span class="hljs-number">53</span>  <span class="hljs-number">47</span>  <span class="hljs-number">99</span>

[<span class="hljs-number">1000000</span> rows x <span class="hljs-number">4</span> columns]

<span class="hljs-number">1.</span> Iterrows done <span class="hljs-keyword">in</span> <span class="hljs-number">104.96</span> seconds, result = <span class="hljs-number">66151519</span>
<span class="hljs-number">2.</span> Named Itertuples done <span class="hljs-keyword">in</span> <span class="hljs-number">1.26</span> seconds, result = <span class="hljs-number">66151519</span>
<span class="hljs-number">3.</span> Itertuples done <span class="hljs-keyword">in</span> <span class="hljs-number">0.94</span> seconds, result = <span class="hljs-number">66151519</span>
<span class="hljs-number">4.</span> Polyvalent Itertuples working even <span class="hljs-keyword">with</span> special characters <span class="hljs-keyword">in</span> the column name done <span class="hljs-keyword">in</span> <span class="hljs-number">2.94</span> seconds, result = <span class="hljs-number">66151519</span>
</code></pre>

<p><a href="https://medium.com/swlh/why-pandas-itertuples-is-faster-than-iterrows-and-how-to-make-it-even-faster-bc50c0edd30d" rel="noreferrer">This article is a very interesting comparison between iterrows and itertuples</a></p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I was looking for <strong>How to iterate on rows</strong> <strong><em>and</em></strong> <strong>columns</strong> and ended here so:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">for</span> i, row <span class="hljs-keyword">in</span> df.iterrows():
    <span class="hljs-keyword">for</span> j, column <span class="hljs-keyword">in</span> row.iteritems():
        <span class="hljs-built_in">print</span>(column)
</code></pre>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You can write your own iterator that implements <code>namedtuple</code></p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple

<span class="hljs-keyword">def</span> <span class="hljs-title function_">myiter</span>(<span class="hljs-params">d, cols=<span class="hljs-literal">None</span></span>):
    <span class="hljs-keyword">if</span> cols <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        v = d.values.tolist()
        cols = d.columns.values.tolist()
    <span class="hljs-keyword">else</span>:
        j = [d.columns.get_loc(c) <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> cols]
        v = d.values[:, j].tolist()

    n = namedtuple(<span class="hljs-string">'MyTuple'</span>, cols)

    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> <span class="hljs-built_in">iter</span>(v):
        <span class="hljs-keyword">yield</span> n(*line)
</code></pre>

<p>This is directly comparable to <code>pd.DataFrame.itertuples</code>.  I'm aiming at performing the same task with more efficiency.</p>

<hr>

<p>For the given dataframe with my function:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-built_in">list</span>(myiter(df))

[MyTuple(c1=<span class="hljs-number">10</span>, c2=<span class="hljs-number">100</span>), MyTuple(c1=<span class="hljs-number">11</span>, c2=<span class="hljs-number">110</span>), MyTuple(c1=<span class="hljs-number">12</span>, c2=<span class="hljs-number">120</span>)]
</code></pre>

<p>Or with <code>pd.DataFrame.itertuples</code>:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-built_in">list</span>(df.itertuples(index=<span class="hljs-literal">False</span>))

[Pandas(c1=<span class="hljs-number">10</span>, c2=<span class="hljs-number">100</span>), Pandas(c1=<span class="hljs-number">11</span>, c2=<span class="hljs-number">110</span>), Pandas(c1=<span class="hljs-number">12</span>, c2=<span class="hljs-number">120</span>)]
</code></pre>

<hr>

<p><strong>A comprehensive test</strong><br>
We test making all columns available and subsetting the columns.  </p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">iterfullA</span>(<span class="hljs-params">d</span>):
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(myiter(d))

<span class="hljs-keyword">def</span> <span class="hljs-title function_">iterfullB</span>(<span class="hljs-params">d</span>):
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(d.itertuples(index=<span class="hljs-literal">False</span>))

<span class="hljs-keyword">def</span> <span class="hljs-title function_">itersubA</span>(<span class="hljs-params">d</span>):
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(myiter(d, [<span class="hljs-string">'col3'</span>, <span class="hljs-string">'col4'</span>, <span class="hljs-string">'col5'</span>, <span class="hljs-string">'col6'</span>, <span class="hljs-string">'col7'</span>]))

<span class="hljs-keyword">def</span> <span class="hljs-title function_">itersubB</span>(<span class="hljs-params">d</span>):
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(d[[<span class="hljs-string">'col3'</span>, <span class="hljs-string">'col4'</span>, <span class="hljs-string">'col5'</span>, <span class="hljs-string">'col6'</span>, <span class="hljs-string">'col7'</span>]].itertuples(index=<span class="hljs-literal">False</span>))

res = pd.DataFrame(
    index=[<span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">100</span>, <span class="hljs-number">300</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">3000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">30000</span>],
    columns=<span class="hljs-string">'iterfullA iterfullB itersubA itersubB'</span>.split(),
    dtype=<span class="hljs-built_in">float</span>
)

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res.index:
    d = pd.DataFrame(np.random.randint(<span class="hljs-number">10</span>, size=(i, <span class="hljs-number">10</span>))).add_prefix(<span class="hljs-string">'col'</span>)
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> res.columns:
        stmt = <span class="hljs-string">'{}(d)'</span>.<span class="hljs-built_in">format</span>(j)
        setp = <span class="hljs-string">'from __main__ import d, {}'</span>.<span class="hljs-built_in">format</span>(j)
        res.at[i, j] = timeit(stmt, setp, number=<span class="hljs-number">100</span>)

res.groupby(res.columns.<span class="hljs-built_in">str</span>[<span class="hljs-number">4</span>:-<span class="hljs-number">1</span>], axis=<span class="hljs-number">1</span>).plot(loglog=<span class="hljs-literal">True</span>);
</code></pre>

<p><a href="https://i.stack.imgur.com/rt88e.png" rel="noreferrer"><img src="https://i.stack.imgur.com/rt88e.png" alt="enter image description here"></a></p>

<p><a href="https://i.stack.imgur.com/azbOF.png" rel="noreferrer"><img src="https://i.stack.imgur.com/azbOF.png" alt="enter image description here"></a></p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>To loop all rows in a <code>dataframe</code> you can use:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(date_example.index)):
    <span class="hljs-built_in">print</span> date_example[<span class="hljs-string">'Date'</span>].iloc[x]
</code></pre>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-py s-code-block"><code class="hljs language-python"> <span class="hljs-keyword">for</span> ind <span class="hljs-keyword">in</span> df.index:
     <span class="hljs-built_in">print</span> df[<span class="hljs-string">'c1'</span>][ind], df[<span class="hljs-string">'c2'</span>][ind]
</code></pre>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>We have multiple options to do the same, lots of folks have shared their answers.</p>
<p>I found below two methods easy and efficient to do :</p>
<ol>
<li><a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.iterrows.html" rel="noreferrer">DataFrame.iterrows()</a></li>
<li><a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.itertuples.html" rel="noreferrer">DataFrame.itertuples()</a></li>
</ol>
<p>Example:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"> <span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
 inp = [{<span class="hljs-string">'c1'</span>:<span class="hljs-number">10</span>, <span class="hljs-string">'c2'</span>:<span class="hljs-number">100</span>}, {<span class="hljs-string">'c1'</span>:<span class="hljs-number">11</span>,<span class="hljs-string">'c2'</span>:<span class="hljs-number">110</span>}, {<span class="hljs-string">'c1'</span>:<span class="hljs-number">12</span>,<span class="hljs-string">'c2'</span>:<span class="hljs-number">120</span>}]
 df = pd.DataFrame(inp)
 <span class="hljs-built_in">print</span> (df)

 <span class="hljs-comment">#With iterrows method </span>

 <span class="hljs-keyword">for</span> index, row <span class="hljs-keyword">in</span> df.iterrows():
     <span class="hljs-built_in">print</span>(row[<span class="hljs-string">"c1"</span>], row[<span class="hljs-string">"c2"</span>])

 <span class="hljs-comment">#With itertuples method</span>

 <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> df.itertuples(index=<span class="hljs-literal">True</span>, name=<span class="hljs-string">'Pandas'</span>):
     <span class="hljs-built_in">print</span>(row.c1, row.c2)
</code></pre>
<p>Note: itertuples() is supposed to be faster than iterrows()</p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Sometimes a useful pattern is:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment"># Borrowing @KutalmisB df example</span>
df = pd.DataFrame({<span class="hljs-string">'col1'</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-string">'col2'</span>: [<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>]}, index=[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>])
<span class="hljs-comment"># The to_dict call results in a list of dicts</span>
<span class="hljs-comment"># where each row_dict is a dictionary with k:v pairs of columns:value for that row</span>
<span class="hljs-keyword">for</span> row_dict <span class="hljs-keyword">in</span> df.to_dict(orient=<span class="hljs-string">'records'</span>):
    <span class="hljs-built_in">print</span>(row_dict)
</code></pre>

<p>Which results in:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">{<span class="hljs-string">'col1'</span>:<span class="hljs-number">1.0</span>, <span class="hljs-string">'col2'</span>:<span class="hljs-number">0.1</span>}
{<span class="hljs-string">'col1'</span>:<span class="hljs-number">2.0</span>, <span class="hljs-string">'col2'</span>:<span class="hljs-number">0.2</span>}
</code></pre>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Update</strong>: cs95 has updated <a href="https://stackoverflow.com/questions/16476924/how-to-iterate-over-rows-in-a-dataframe-in-pandas/55557758#55557758">his answer</a> to include plain numpy vectorization. You can simply refer to his answer.</p>
<hr>
<p><a href="https://stackoverflow.com/questions/16476924/how-to-iterate-over-rows-in-a-dataframe-in-pandas/55557758#55557758">cs95 shows</a> that Pandas vectorization far outperforms other Pandas methods for computing stuff with dataframes.</p>
<p>I wanted to add that if you first convert the dataframe to a NumPy array and then use vectorization, it's even faster than Pandas dataframe vectorization, (and that includes the time to turn it back into a dataframe series).</p>
<p>If you add the following functions to cs95's benchmark code, this becomes pretty evident:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">np_vectorization</span>(<span class="hljs-params">df</span>):
    np_arr = df.to_numpy()
    <span class="hljs-keyword">return</span> pd.Series(np_arr[:,<span class="hljs-number">0</span>] + np_arr[:,<span class="hljs-number">1</span>], index=df.index)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">just_np_vectorization</span>(<span class="hljs-params">df</span>):
    np_arr = df.to_numpy()
    <span class="hljs-keyword">return</span> np_arr[:,<span class="hljs-number">0</span>] + np_arr[:,<span class="hljs-number">1</span>]
</code></pre>
<p><a href="https://i.stack.imgur.com/L0u4A.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/L0u4A.png" alt="Enter image description here"></a></p>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In short</p>
<ul>
<li>Use vectorization if possible</li>
<li>If an operation can't be vectorized - use list comprehensions</li>
<li>If you need a single object representing the entire row - use itertuples</li>
<li>If the above is too slow - try <em>swifter.apply</em></li>
<li>If it's still too slow - try a <a href="https://en.wikipedia.org/wiki/Cython" rel="noreferrer">Cython</a> routine</li>
</ul>
<h3>Benchmark</h3>
<p><a href="https://i.stack.imgur.com/ytaWK.png" rel="noreferrer"><img src="https://i.stack.imgur.com/ytaWK.png" alt="Benchmark of iteration over rows in a Pandas DataFrame"></a></p>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>To loop all rows in a <code>dataframe</code> and <strong>use</strong> values of each row <strong>conveniently</strong>, <code>namedtuples</code> can be converted to <code>ndarray</code>s. For example:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">df = pd.DataFrame({<span class="hljs-string">'col1'</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-string">'col2'</span>: [<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>]}, index=[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>])
</code></pre>

<p>Iterating over the rows:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> df.itertuples(index=<span class="hljs-literal">False</span>, name=<span class="hljs-string">'Pandas'</span>):
    <span class="hljs-built_in">print</span> np.asarray(row)
</code></pre>

<p>results in:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">[ <span class="hljs-number">1.</span>   <span class="hljs-number">0.1</span>]
[ <span class="hljs-number">2.</span>   <span class="hljs-number">0.2</span>]
</code></pre>

<p>Please note that if <code>index=True</code>, <strong>the index is added as the first element of the tuple</strong>, which may be undesirable for some applications.</p>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 18</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There is a way to iterate throw rows while getting a DataFrame in return, and not a Series. I don't see anyone mentioning that you can pass index as a list for the row to be returned as a DataFrame:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(df)):
    row = df.iloc[[i]]
</code></pre>

<p>Note the usage of double brackets. This returns a DataFrame with a single row.</p>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 19</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>For both viewing and modifying values, I would use <code>iterrows()</code>. In a for loop and by using tuple unpacking (see the example: <code>i, row</code>), I use the <code>row</code> for only viewing the value and use <code>i</code> with the <code>loc</code> method when I want to modify values. As stated in previous answers, here you should not modify something you are iterating over.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">for</span> i, row <span class="hljs-keyword">in</span> df.iterrows():
    df_column_A = df.loc[i, <span class="hljs-string">'A'</span>]
    <span class="hljs-keyword">if</span> df_column_A == <span class="hljs-string">'Old_Value'</span>:
        df_column_A = <span class="hljs-string">'New_value'</span>  
</code></pre>

<p>Here the <code>row</code> in the loop is a copy of that row, and not a view of it. Therefore, you should NOT write something like <code>row['A'] = 'New_Value'</code>, it will not modify the DataFrame. However, you can use <code>i</code> and <code>loc</code> and specify the DataFrame to do the work.</p>
    </div></div></div></div><div id="solution20" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 20</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There are so many ways to iterate over the rows in Pandas dataframe. One very simple and intuitive way is:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">df = pd.DataFrame({<span class="hljs-string">'A'</span>:[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-string">'B'</span>:[<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], <span class="hljs-string">'C'</span>:[<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]})
<span class="hljs-built_in">print</span>(df)
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(df.shape[<span class="hljs-number">0</span>]):
    <span class="hljs-comment"># For printing the second column</span>
    <span class="hljs-built_in">print</span>(df.iloc[i, <span class="hljs-number">1</span>])

    <span class="hljs-comment"># For printing more than one columns</span>
    <span class="hljs-built_in">print</span>(df.iloc[i, [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>]])
</code></pre>
    </div></div></div></div><div id="solution21" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 21</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The easiest way, use the <code>apply</code> function</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_row</span>(<span class="hljs-params">row</span>):
   <span class="hljs-built_in">print</span> row[<span class="hljs-string">'c1'</span>], row[<span class="hljs-string">'c2'</span>]

df.apply(<span class="hljs-keyword">lambda</span> row: print_row(row), axis=<span class="hljs-number">1</span>)
</code></pre>
    </div></div></div></div><div id="solution22" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 22</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As many answers here correctly and clearly point out, you should not generally attempt to loop in Pandas, but rather should write vectorized code.  But the question remains if you should <em>ever</em> write loops in Pandas, and if so the best way to loop in those situations.</p>
<p><strong>I believe there is at least one general situation where loops are appropriate: when you need to calculate some function that depends on values in <em>other</em> rows in a somewhat complex manner.  In this case, the looping code is often simpler, more readable, and less error prone than vectorized code.</strong>  The looping code might even be faster, too.</p>
<p>I will attempt to show this with an example.  Suppose you want to take a cumulative sum of a column, but reset it whenever some other column equals zero:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np

df = pd.DataFrame( { <span class="hljs-string">'x'</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], <span class="hljs-string">'y'</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]  } )

<span class="hljs-comment">#   x  y  desired_result</span>
<span class="hljs-comment">#0  1  1               1</span>
<span class="hljs-comment">#1  2  1               3</span>
<span class="hljs-comment">#2  3  1               6</span>
<span class="hljs-comment">#3  4  0               4</span>
<span class="hljs-comment">#4  5  1               9</span>
<span class="hljs-comment">#5  6  1              15</span>
</code></pre>
<p>This is a good example where you could certainly write one line of Pandas to achieve this, although it's not especially readable, especially if you aren't fairly experienced with Pandas already:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">df.groupby( (df.y==<span class="hljs-number">0</span>).cumsum() )[<span class="hljs-string">'x'</span>].cumsum()
</code></pre>
<p>That's going to be fast enough for most situations, although you could also write faster code by avoiding the <code>groupby</code>, but it will likely be even less readable.</p>
<p>Alternatively, what if we write this as a loop?  You could do something like the following with NumPy:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> numba <span class="hljs-keyword">as</span> nb

<span class="hljs-meta">@nb.jit(<span class="hljs-params">nopython=<span class="hljs-literal">True</span></span>)  </span><span class="hljs-comment"># Optional</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">custom_sum</span>(<span class="hljs-params">x,y</span>):
    x_sum = x.copy()
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(df)):
        <span class="hljs-keyword">if</span> y[i] &gt; <span class="hljs-number">0</span>: x_sum[i] = x_sum[i-<span class="hljs-number">1</span>] + x[i]
    <span class="hljs-keyword">return</span> x_sum

df[<span class="hljs-string">'desired_result'</span>] = custom_sum( df.x.to_numpy(), df.y.to_numpy() )
</code></pre>
<p>Admittedly, there's a bit of overhead there required to convert DataFrame columns to NumPy arrays, but the core piece of code is just one line of code that you could read even if you didn't know anything about Pandas or NumPy:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">if</span> y[i] &gt; <span class="hljs-number">0</span>: x_sum[i] = x_sum[i-<span class="hljs-number">1</span>] + x[i]
</code></pre>
<p>And this code is actually <em>faster</em> than the vectorized code.  In some quick tests with 100,000 rows, the above is about 10x faster than the <em>groupby</em> approach.  Note that one key to the speed there is numba, which is optional.  Without the "@nb.jit" line, the looping code is actually about 10x slower than the <em>groupby</em> approach.</p>
<p>Clearly this example is simple enough that you would likely prefer the one line of pandas to writing a loop with its associated overhead.  However, there are more complex versions of this problem for which the readability or speed of the NumPy/numba loop approach likely makes sense.</p>
    </div></div></div></div><div id="solution23" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 23</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><code>df.iterrows()</code> returns <code>tuple(a, b)</code> where <code>a</code> is the <code>index</code> and <code>b</code> is the <code>row</code>.</p>
    </div></div></div></div><div id="solution24" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 24</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You can also do NumPy indexing for even greater speed ups. It's not really iterating but works much better than iteration for certain applications.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">subset = row[<span class="hljs-string">'c1'</span>][<span class="hljs-number">0</span>:<span class="hljs-number">5</span>]
<span class="hljs-built_in">all</span> = row[<span class="hljs-string">'c1'</span>][:]
</code></pre>

<p>You may also want to cast it to an array. These indexes/selections are supposed to act like NumPy arrays already, but I ran into issues and needed to cast</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">np.asarray(<span class="hljs-built_in">all</span>)
imgs[:] = cv2.resize(imgs[:], (<span class="hljs-number">224</span>,<span class="hljs-number">224</span>) ) <span class="hljs-comment"># Resize every image in an hdf5 file</span>
</code></pre>
    </div></div></div></div><div id="solution25" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 25</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Disclaimer:</strong> Although here are so many answers which recommend <strong>not</strong> using an iterative (loop) approach (and I mostly agree), I would still see it as a reasonable approach for the following situation:</p>
<h2>Extend dataframe with data from API</h2>
<p>Let's say you have a large dataframe which contains incomplete user data. Now you have to extend this data with additional columns, for example the user's <code>age</code> and <code>gender</code>.</p>
<p>Both values have to be fetched from a backend API. I'm assuming the API doesn't provide a "batch" endpoint (which would accept multiple user IDs at once). Otherwise, you should rather call the API only once.</p>
<p>The costs (waiting time) for the network request surpass the iteration of the dataframe by far. We're talking about network roundtrip times of hundreds of milliseconds compared to the negligibly small gains in using alternative approaches to iterations.</p>
<h2>1 expensive network request for each row</h2>
<p>So in this case, I would absolutely prefer using an iterative approach. Although the network request is expensive, it is guaranteed being triggered only once for each row in the dataframe. Here is an example using <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iterrows.html#pandas-dataframe-iterrows" rel="nofollow noreferrer">DataFrame.iterrows</a>:</p>
<h2>Example</h2>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">for</span> index, row <span class="hljs-keyword">in</span> users_df.iterrows():
  user_id = row[<span class="hljs-string">'user_id'</span>]
  <span class="hljs-comment"># trigger expensive network request once for each row</span>
  response_dict = backend_api.get(<span class="hljs-string">f'/api/user-data/<span class="hljs-subst">{user_id}</span>'</span>)
  <span class="hljs-comment"># extend dataframe with multiple data from response</span>
  users_df.at[index, <span class="hljs-string">'age'</span>] = response_dict.get(<span class="hljs-string">'age'</span>)
  users_df.at[index, <span class="hljs-string">'gender'</span>] = response_dict.get(<span class="hljs-string">'gender'</span>)
</code></pre>
    </div></div></div></div><div id="solution26" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 26</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This example uses iloc to isolate each digit in the data frame. </p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd

 a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
 b = [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]

 mjr = pd.DataFrame({<span class="hljs-string">'a'</span>:a, <span class="hljs-string">'b'</span>:b})

 size = mjr.shape

 <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size[<span class="hljs-number">0</span>]):
     <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size[<span class="hljs-number">1</span>]):
         <span class="hljs-built_in">print</span>(mjr.iloc[i, j])
</code></pre>
    </div></div></div></div><div id="solution27" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 27</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Some libraries (e.g. a Java interop library that I use) require values to be passed in a row at a time, for example, if streaming data. To replicate the streaming nature, I 'stream' my dataframe values one by one, I wrote the below, which comes in handy from time to time.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataFrameReader</span>:
  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, df</span>):
    self._df = df
    self._row = <span class="hljs-literal">None</span>
    self._columns = df.columns.tolist()
    self.reset()
    self.row_index = <span class="hljs-number">0</span>

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, key</span>):
    <span class="hljs-keyword">return</span> self.__getitem__(key)

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">read</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">bool</span>:
    self._row = <span class="hljs-built_in">next</span>(self._iterator, <span class="hljs-literal">None</span>)
    self.row_index += <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> self._row <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">columns</span>(<span class="hljs-params">self</span>):
    <span class="hljs-keyword">return</span> self._columns

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">reset</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:
    self._iterator = self._df.itertuples()

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_index</span>(<span class="hljs-params">self</span>):
    <span class="hljs-keyword">return</span> self._row[<span class="hljs-number">0</span>]

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>(<span class="hljs-params">self</span>):
    <span class="hljs-keyword">return</span> self._row[<span class="hljs-number">0</span>]

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">to_dict</span>(<span class="hljs-params">self, columns: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span></span>):
    <span class="hljs-keyword">return</span> self.row(columns=columns)

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">tolist</span>(<span class="hljs-params">self, cols</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">object</span>]:
    <span class="hljs-keyword">return</span> [self.__getitem__(c) <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> cols]

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">row</span>(<span class="hljs-params">self, columns: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">object</span>]:
    cols = <span class="hljs-built_in">set</span>(self._columns <span class="hljs-keyword">if</span> columns <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> columns)
    <span class="hljs-keyword">return</span> {c : self.__getitem__(c) <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> self._columns <span class="hljs-keyword">if</span> c <span class="hljs-keyword">in</span> cols}

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, key</span>) -&gt; <span class="hljs-built_in">object</span>:
    <span class="hljs-comment"># the df index of the row is at index 0</span>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(key) <span class="hljs-keyword">is</span> <span class="hljs-built_in">list</span>:
            ix = [self._columns.index(key) + <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> key]
        <span class="hljs-keyword">else</span>:
            ix = self._columns.index(key) + <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> self._row[ix]
    <span class="hljs-keyword">except</span> BaseException <span class="hljs-keyword">as</span> e:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-string">'DataFrameReader'</span>:
    <span class="hljs-keyword">if</span> self.read():
        <span class="hljs-keyword">return</span> self
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">raise</span> StopIteration

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-string">'DataFrameReader'</span>:
    <span class="hljs-keyword">return</span> self
</code></pre>

<p>Which can be used:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> DataFrameReader(df):
  <span class="hljs-built_in">print</span>(row.my_column_name)
  <span class="hljs-built_in">print</span>(row.to_dict())
  <span class="hljs-built_in">print</span>(row[<span class="hljs-string">'my_column_name'</span>])
  <span class="hljs-built_in">print</span>(row.tolist())
</code></pre>

<p>And preserves the values/ name mapping for the rows being iterated. Obviously, is a lot slower than using apply and Cython as indicated above, but is necessary in some circumstances.</p>
    </div></div></div></div><div id="solution28" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 28</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Along with the great answers in this post I am going to propose <strong>Divide and Conquer</strong> approach, I am not writing this answer to abolish the other great answers but to fulfill them with another approach which was working efficiently for me. It has two steps of <code>splitting</code> and <code>merging</code> the pandas dataframe:</p>
<p><strong>PROS of Divide and Conquer:</strong></p>
<ul>
<li>You don't need to use vectorization or any other methods to cast the type of your dataframe into another type</li>
<li>You don't need to Cythonize your code which normally takes extra time from you</li>
<li>Both <code>iterrows()</code> and <code>itertuples()</code> in my case were having the same performance over entire dataframe</li>
<li>Depends on your choice of slicing <code>index</code>, you will be able to exponentially quicken the iteration. The higher <code>index</code>, the quicker your iteration process.</li>
</ul>
<p><strong>CONS of Divide and Conquer:</strong></p>
<ul>
<li>You shouldn't have dependency over the iteration process to the same dataframe and different <em>slice</em>. Meaning if you want to read or write from other <em>slice</em>, it maybe difficult to do that.</li>
</ul>
<p><strong>===================    Divide and Conquer Approach    =================</strong></p>
<p><strong>Step 1: Splitting/Slicing</strong></p>
<p>In this step, we are going to divide the iteration over the entire dataframe. Think that you are going to read a csv file into pandas df then iterate over it. In may case I have 5,000,000 records and I am going to split it into 100,000 records.</p>
<p><strong>NOTE:</strong> I need to reiterate as other runtime analysis explained in the other solutions in this page, "number of records" has exponential proportion of "runtime" on search on the df. Based on the benchmark on my data here are the results:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">Number of records | Iteration per second
========================================
<span class="hljs-number">100</span>,<span class="hljs-number">000</span>           | <span class="hljs-number">500</span> it/s
<span class="hljs-number">500</span>,<span class="hljs-number">000</span>           | <span class="hljs-number">200</span> it/s
<span class="hljs-number">1</span>,<span class="hljs-number">000</span>,<span class="hljs-number">000</span>         | <span class="hljs-number">50</span> it/s
<span class="hljs-number">5</span>,<span class="hljs-number">000</span>,<span class="hljs-number">000</span>         | <span class="hljs-number">20</span> it/s
</code></pre>
<p><strong>Step 2: Merging</strong></p>
<p>This is going to be an easy step, just merge all the written csv files into one dataframe and write it into a bigger csv file.</p>
<p>Here is the sample code:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment"># Step 1 (Splitting/Slicing)</span>
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
df_all = pd.read_csv(<span class="hljs-string">'C:/KtV.csv'</span>)
df_index = <span class="hljs-number">100000</span>
df_len = <span class="hljs-built_in">len</span>(df)
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(df_len // df_index + <span class="hljs-number">1</span>):
    lower_bound = i * df_index 
    higher_bound = <span class="hljs-built_in">min</span>(lower_bound + df_index, df_len)
    <span class="hljs-comment"># splitting/slicing df (make sure to copy() otherwise it will be a view</span>
    df = df_all[lower_bound:higher_bound].copy()
    <span class="hljs-string">'''
    write your iteration over the sliced df here
    using iterrows() or intertuples() or ...
    '''</span>
    <span class="hljs-comment"># writing into csv files</span>
    df.to_csv(<span class="hljs-string">'C:/KtV_prep_'</span>+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">'.csv'</span>)



<span class="hljs-comment"># Step 2 (Merging)</span>
filename=<span class="hljs-string">'C:/KtV_prep_'</span>
df = (pd.read_csv(f) <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> [filename+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">'.csv'</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(ktv_len // ktv_index + <span class="hljs-number">1</span>)])
df_prep_all = pd.concat(df)
df_prep_all.to_csv(<span class="hljs-string">'C:/KtV_prep_all.csv'</span>)
</code></pre>
<p><strong>Reference:</strong></p>
<p><a href="https://stackoverflow.com/questions/7837722/what-is-the-most-efficient-way-to-loop-through-dataframes-with-pandas">Efficient way of iteration over datafreame</a></p>
<p><a href="https://stackoverflow.com/questions/20906474/import-multiple-csv-files-into-pandas-and-concatenate-into-one-dataframe">Concatenate csv files into one Pandas Dataframe</a></p>
    </div></div></div></div><div id="solution29" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 29</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As <a href="https://stackoverflow.com/questions/16476924/how-to-iterate-over-rows-in-a-dataframe-in-pandas/16476974#16476974">the accepted answer</a> states, the fastest way to apply a function over rows is to use a <strong>vectorized function</strong>, the so-called NumPy <code>ufuncs</code> (universal functions).</p>
<p>But what should you do when the function you want to apply isn't already implemented in NumPy?</p>
<p>Well, using the <code>vectorize</code> decorator from <code>numba</code>, you can easily create ufuncs directly in Python like this:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">from</span> numba <span class="hljs-keyword">import</span> vectorize, float64

<span class="hljs-meta">@vectorize(<span class="hljs-params">[float64(<span class="hljs-params">float64</span>)]</span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):
    <span class="hljs-comment">#x is your line, do something with it, and return a float</span>
</code></pre>
<p>The documentation for this function is here: <em><a href="https://numba.pydata.org/numba-doc/latest/user/vectorize.html" rel="nofollow noreferrer">Creating NumPy universal functions</a></em></p>
    </div></div></div></div><div id="solution30" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 30</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Probably the most elegant solution (but certainly not the most efficient):</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> df.values:
    c2 = row[<span class="hljs-number">1</span>]
    <span class="hljs-built_in">print</span>(row)
    <span class="hljs-comment"># ...</span>

<span class="hljs-keyword">for</span> c1, c2 <span class="hljs-keyword">in</span> df.values:
    <span class="hljs-comment"># ...</span>
</code></pre>
<p>Note that:</p>
<ul>
<li>the <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.values.html" rel="nofollow noreferrer">documentation</a> explicitly recommends to use <code>.to_numpy()</code> instead</li>
<li>the produced NumPy array will have a dtype that fits all columns, in the worst case <code>object</code></li>
<li>there are <a href="https://stackoverflow.com/a/55557758/4248897">good reasons</a> not to use a loop in the first place</li>
</ul>
<p>Still, I think this option should be included here, as a straight-forward solution to a (one should think) trivial problem.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/web-scraping-javascript-page-with-python-1657388240875">Web-scraping JavaScript page with Python</a><a href="/questions/how-do-i-get-php-errors-to-display-1657384570095">How do I get PHP errors to display?</a><a href="/questions/dynamically-select-data-frame-columns-using-dollar-and-a-character-value-1657387836662">Dynamically select data frame columns using $ and a character value</a><a href="/questions/removing-duplicates-in-lists-1657388207448">Removing duplicates in lists</a><a href="/questions/strange-result-when-removing-item-from-a-list-while-iterating-over-it-duplicate-1657387735759">Strange result when removing item from a list while iterating over it [duplicate]</a><a href="/questions/dynamic-tabs-with-user-click-chosen-components-1657388465232">Dynamic tabs with user-click chosen components</a><a href="/questions/post-an-html-table-to-ado.net-datatable-1657387462723">Post an HTML Table to ADO.NET DataTable</a><a href="/questions/default-constructor-with-empty-brackets-1657388246967">Default constructor with empty brackets</a><a href="/questions/how-to-make-a-great-r-reproducible-example-1657384198173">How to make a great R reproducible example</a><a href="/questions/resolve-build-errors-due-to-circular-dependency-amongst-classes-1657384903462">Resolve build errors due to circular dependency amongst classes</a><a href="/questions/how-to-convert-a-factor-to-integernumeric-without-loss-of-information-1657387880273">How to convert a factor to integer\numeric without loss of information?</a><a href="/questions/how-do-i-give-text-or-an-image-a-transparent-background-using-css-1657388188508">How do I give text or an image a transparent background using CSS?</a><a href="/questions/center-one-and-rightleft-align-other-flexbox-element-1657387899083">Center one and right/left align other flexbox element</a><a href="/questions/self-references-in-object-literals-initializers-1657384835356">Self-references in object literals / initializers</a><a href="/questions/what-is-the-explicit-promise-construction-antipattern-and-how-do-i-avoid-it-1657384436212">What is the explicit promise construction antipattern and how do I avoid it?</a><a href="/questions/why-does-my-recursive-function-return-none-1657387792894">Why does my recursive function return None?</a><a href="/questions/how-do-i-iterate-over-the-words-of-a-string-1657384806129">How do I iterate over the words of a string?</a><a href="/questions/what-are-valid-values-for-the-id-attribute-in-html-1657384874780">What are valid values for the id attribute in HTML?</a><a href="/questions/can-a-local-variable&#x27;s-memory-be-accessed-outside-its-scope-1657384460386">Can a local variable&#x27;s memory be accessed outside its scope?</a><a href="/questions/how-to-horizontally-center-an-element-1657384634147">How to horizontally center an element</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iterrows.html#pandas-dataframe-iterrows\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;DataFrame.iterrows\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; is a generator which yields both the index and row (as a Series):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; pandas \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; pd\n\ndf = pd.DataFrame({\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c1\u0026apos;\u0026lt;/span\u0026gt;: [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12\u0026lt;/span\u0026gt;], \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c2\u0026apos;\u0026lt;/span\u0026gt;: [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;110\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;120\u0026lt;/span\u0026gt;]})\ndf = df.reset_index()  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# make sure indexes pair with number of rows\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; index, row \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; df.iterrows():\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(row[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c1\u0026apos;\u0026lt;/span\u0026gt;], row[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c2\u0026apos;\u0026lt;/span\u0026gt;])\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;110\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;120\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;blockquote\u0026gt;\n\u0026lt;h2\u0026gt;How to iterate over rows in a DataFrame in Pandas?\u0026lt;/h2\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;h1\u0026gt;Answer: DON\u0026apos;T\u0026lt;sup\u0026gt;*\u0026lt;/sup\u0026gt;!\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;Iteration in Pandas is an anti-pattern and is something you should only do when you have exhausted every other option. You should not use any function with \u0026quot;\u0026lt;code\u0026gt;iter\u0026lt;/code\u0026gt;\u0026quot; in its name for more than a few thousand rows or you will have to get used to a \u0026lt;strong\u0026gt;lot\u0026lt;/strong\u0026gt; of waiting.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Do you want to print a DataFrame? Use \u0026lt;a href=\u0026quot;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_string.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;DataFrame.to_string()\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Do you want to compute something? In that case, search for methods in this order (list modified from \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/24870953/does-iterrows-have-performance-issues\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt;):\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Vectorization\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Cython\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Cython\u0026lt;/a\u0026gt; routines\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;List Comprehensions (vanilla \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; loop)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.apply.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;DataFrame.apply()\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt;: i) \u0026amp;nbsp;Reductions that can be performed in Cython, ii) Iteration in Python space\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.itertuples.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;DataFrame.itertuples()\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iteritems.html#pandas.DataFrame.iteritems\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;iteritems()\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;DataFrame.iterrows()\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;iterrows\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;itertuples\u0026lt;/code\u0026gt; (both receiving many votes in answers to this question) should be used in very rare circumstances, such as generating row objects/nametuples for sequential processing, which is really the only thing these functions are useful for.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Appeal to Authority\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/basics.html#iteration\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;The documentation page\u0026lt;/a\u0026gt; on iteration has a huge red warning box that says:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Iterating through pandas objects is generally slow. In many cases, iterating manually over the rows is not needed [...].\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sub\u0026gt;* It\u0026apos;s actually a little more complicated than \u0026quot;don\u0026apos;t\u0026quot;. \u0026lt;code\u0026gt;df.iterrows()\u0026lt;/code\u0026gt; is the correct answer to this question, but \u0026quot;vectorize your ops\u0026quot; is the better one. I will concede that there are circumstances where iteration cannot be avoided (for example, some operations where the result depends on the value computed for the previous row). However, it takes some familiarity with the library to know when. If you\u0026apos;re not sure whether you need an iterative solution, you probably don\u0026apos;t. PS: To know more about my rationale for writing this answer, skip to the very bottom.\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;Faster than Looping: \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/1422149/what-is-vectorization\u0026quot;\u0026gt;Vectorization\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;https://cython.org\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Cython\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;A good number of basic operations and computations are \u0026quot;vectorised\u0026quot; by pandas (either through NumPy, or through Cythonized functions). This includes arithmetic, comparisons, (most) reductions, reshaping (such as pivoting), joins, and groupby operations. Look through the documentation on \u0026lt;a href=\u0026quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/basics.html#essential-basic-functionality\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Essential Basic Functionality\u0026lt;/a\u0026gt; to find a suitable vectorised method for your problem.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If none exists, feel free to write your own using custom \u0026lt;a href=\u0026quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/enhancingperf.html#cython-writing-c-extensions-for-pandas\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Cython extensions\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;Next Best Thing: \u0026lt;a href=\u0026quot;https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;List Comprehensions\u0026lt;/a\u0026gt;\u0026lt;sup\u0026gt;*\u0026lt;/sup\u0026gt;\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;List comprehensions should be your next port of call if 1) there is no vectorized solution available, 2) performance is important, but not important enough to go through the hassle of cythonizing your code, and 3) you\u0026apos;re trying to perform elementwise transformation on your code. There is a \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/54028199/for-loops-with-pandas-when-should-i-care\u0026quot;\u0026gt;good amount of evidence\u0026lt;/a\u0026gt; to suggest that list comprehensions are sufficiently fast (and even sometimes faster) for many common Pandas tasks.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The formula is simple,\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Iterating over one column - `f` is some function that processes your data\u0026lt;/span\u0026gt;\nresult = [f(x) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; x \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; df[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;col\u0026apos;\u0026lt;/span\u0026gt;]]\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Iterating over two columns, use `zip`\u0026lt;/span\u0026gt;\nresult = [f(x, y) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; x, y \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;zip\u0026lt;/span\u0026gt;(df[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;col1\u0026apos;\u0026lt;/span\u0026gt;], df[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;col2\u0026apos;\u0026lt;/span\u0026gt;])]\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Iterating over multiple columns - same data type\u0026lt;/span\u0026gt;\nresult = [f(row[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;], ..., row[n]) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; row \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; df[[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;col1\u0026apos;\u0026lt;/span\u0026gt;, ...,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;coln\u0026apos;\u0026lt;/span\u0026gt;]].to_numpy()]\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Iterating over multiple columns - differing data type\u0026lt;/span\u0026gt;\nresult = [f(row[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;], ..., row[n]) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; row \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;zip\u0026lt;/span\u0026gt;(df[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;col1\u0026apos;\u0026lt;/span\u0026gt;], ..., df[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;coln\u0026apos;\u0026lt;/span\u0026gt;])]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;If you can encapsulate your business logic into a function, you can use a list comprehension that calls it. You can make arbitrarily complex things work through the simplicity and speed of raw Python code.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Caveats\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;List comprehensions assume that your data is easy to work with - what that means is your data types are consistent and you don\u0026apos;t have NaNs, but this cannot always be guaranteed.\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;The first one is more obvious, but when dealing with NaNs, prefer in-built pandas methods if they exist (because they have much better corner-case handling logic), or ensure your business logic includes appropriate NaN handling logic.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;When dealing with mixed data types you should iterate over \u0026lt;code\u0026gt;zip(df[\u0026apos;A\u0026apos;], df[\u0026apos;B\u0026apos;], ...)\u0026lt;/code\u0026gt; instead of \u0026lt;code\u0026gt;df[[\u0026apos;A\u0026apos;, \u0026apos;B\u0026apos;]].to_numpy()\u0026lt;/code\u0026gt; as the latter implicitly upcasts data to the most common type. As an example if A is numeric and B is string, \u0026lt;code\u0026gt;to_numpy()\u0026lt;/code\u0026gt; will cast the entire array to string, which may not be what you want. Fortunately \u0026lt;code\u0026gt;zip\u0026lt;/code\u0026gt;ping your columns together is the most straightforward workaround to this.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sub\u0026gt;*Your mileage may vary for the reasons outlined in the \u0026lt;strong\u0026gt;Caveats\u0026lt;/strong\u0026gt; section above.\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;An Obvious Example\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Let\u0026apos;s demonstrate the difference with a simple example of adding two pandas columns \u0026lt;code\u0026gt;A + B\u0026lt;/code\u0026gt;. This is a vectorizable operaton, so it will be easy to contrast the performance of the methods discussed above.\u0026lt;/p\u0026gt;\n\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/y44RJ.png\u0026quot; width=\u0026quot;600\u0026quot;\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://gist.github.com/Coldsp33d/948f96b384ca5bdf6e8ce203ac97c9a0\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Benchmarking code, for your reference\u0026lt;/a\u0026gt;. The line at the bottom measures a function written in numpandas, a style of Pandas that mixes heavily with NumPy to squeeze out maximum performance. Writing numpandas code should be avoided unless you know what you\u0026apos;re doing. Stick to the API where you can (i.e., prefer \u0026lt;code\u0026gt;vec\u0026lt;/code\u0026gt; over \u0026lt;code\u0026gt;vec_numpy\u0026lt;/code\u0026gt;).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I should mention, however, that it isn\u0026apos;t always this cut and dry. Sometimes the answer to \u0026quot;what is the best method for an operation\u0026quot; is \u0026quot;it depends on your data\u0026quot;. My advice is to test out different approaches on your data before settling on one.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;My Personal Opinion \u0026lt;sup\u0026gt;*\u0026lt;/sup\u0026gt;\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Most of the analyses performed on the various alternatives to the iter family has been through the lens of performance. However, in most situations you will typically be working on a reasonably sized dataset (nothing beyond a few thousand or 100K rows) and performance will come second to simplicity/readability of the solution.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Here is my personal preference when selecting a method to use for a problem.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For the novice:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Vectorization\u0026lt;/em\u0026gt; (when possible)\u0026lt;em\u0026gt;; \u0026lt;code\u0026gt;apply()\u0026lt;/code\u0026gt;; List Comprehensions; \u0026lt;code\u0026gt;itertuples()\u0026lt;/code\u0026gt;/\u0026lt;code\u0026gt;iteritems()\u0026lt;/code\u0026gt;; \u0026lt;code\u0026gt;iterrows()\u0026lt;/code\u0026gt;; Cython\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;For the more experienced:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Vectorization\u0026lt;/em\u0026gt; (when possible)\u0026lt;em\u0026gt;; \u0026lt;code\u0026gt;apply()\u0026lt;/code\u0026gt;; List Comprehensions; Cython; \u0026lt;code\u0026gt;itertuples()\u0026lt;/code\u0026gt;/\u0026lt;code\u0026gt;iteritems()\u0026lt;/code\u0026gt;; \u0026lt;code\u0026gt;iterrows()\u0026lt;/code\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Vectorization prevails as the most idiomatic method for any problem that can be vectorized. Always seek to vectorize! When in doubt, consult the docs, or look on Stack Overflow for an existing question on your particular task.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I do tend to go on about how bad \u0026lt;code\u0026gt;apply\u0026lt;/code\u0026gt; is in a lot of my posts, but I do concede it is easier for a beginner to wrap their head around what it\u0026apos;s doing. Additionally, there are quite a few use cases for \u0026lt;code\u0026gt;apply\u0026lt;/code\u0026gt; has explained in \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/54432583/when-should-i-not-want-to-use-pandas-apply-in-my-code\u0026quot;\u0026gt;this post of mine\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Cython ranks lower down on the list because it takes more time and effort to pull off correctly. You will usually never need to write code with pandas that demands this level of performance that even a list comprehension cannot satisfy.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sub\u0026gt;* As with any personal opinion, please take with heaps of salt!\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;Further Reading\u0026lt;/h2\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/10min.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;10 Minutes to pandas\u0026lt;/a\u0026gt;, and \u0026lt;a href=\u0026quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/basics.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Essential Basic Functionality\u0026lt;/a\u0026gt; - Useful links that introduce you to Pandas and its library of vectorized*/cythonized functions.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/enhancingperf.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Enhancing Performance\u0026lt;/a\u0026gt; - A primer from the documentation on enhancing standard Pandas operations\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/54028199/for-loops-with-pandas-when-should-i-care\u0026quot;\u0026gt;Are for-loops in pandas really bad? When should I care?\u0026lt;/a\u0026gt;\u0026lt;/em\u0026gt; - a detailed writeup by me on list comprehensions and their suitability for various operations (mainly ones involving non-numeric data)\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/54432583/when-should-i-ever-want-to-use-pandas-apply-in-my-code\u0026quot;\u0026gt;When should I (not) want to use pandas apply() in my code?\u0026lt;/a\u0026gt;\u0026lt;/em\u0026gt; - \u0026lt;code\u0026gt;apply\u0026lt;/code\u0026gt; is slow (but not as slow as the \u0026lt;code\u0026gt;iter*\u0026lt;/code\u0026gt; family. There are, however, situations where one can (or should) consider \u0026lt;code\u0026gt;apply\u0026lt;/code\u0026gt; as a serious alternative, especially in some \u0026lt;code\u0026gt;GroupBy\u0026lt;/code\u0026gt; operations).\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sub\u0026gt;* Pandas string methods are \u0026quot;vectorized\u0026quot; in the sense that they are specified on the series but operate on each element. The underlying mechanisms are still iterative, because string operations are inherently hard to vectorize.\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;Why I Wrote this Answer\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;A common trend I notice from new users is to ask questions of the form \u0026quot;How can I iterate over my df to do X?\u0026quot;. Showing code that calls \u0026lt;code\u0026gt;iterrows()\u0026lt;/code\u0026gt; while doing something inside a \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; loop. Here is why. A new user to the library who has not been introduced to the concept of vectorization will likely envision the code that solves their problem as iterating over their data to do something. Not knowing how to iterate over a DataFrame, the first thing they do is Google it and end up here, at this question. They then see the accepted answer telling them how to, and they close their eyes and run this code without ever first questioning if iteration is the right thing to do.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The aim of this answer is to help new users understand that iteration is not necessarily the solution to every problem, and that better, faster and more idiomatic solutions could exist, and that it is worth investing time in exploring them. I\u0026apos;m not trying to start a war of iteration vs. vectorization, but I want new users to be informed when developing solutions to their problems with this library.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;First consider if you really need to \u0026lt;em\u0026gt;iterate\u0026lt;/em\u0026gt; over rows in a DataFrame. See \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/55557758/3844376\u0026quot;\u0026gt;this answer\u0026lt;/a\u0026gt; for alternatives.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If you still need to iterate over rows, you can use methods below. Note some  \u0026lt;strong\u0026gt;important caveats\u0026lt;/strong\u0026gt; which are not mentioned in any of the other answers.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.iterrows.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;DataFrame.iterrows()\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; index, row \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; df.iterrows():\n      \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(row[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;c1\u0026quot;\u0026lt;/span\u0026gt;], row[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;c2\u0026quot;\u0026lt;/span\u0026gt;])\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.itertuples.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;DataFrame.itertuples()\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; row \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; df.itertuples(index=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;, name=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Pandas\u0026apos;\u0026lt;/span\u0026gt;):\n      \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(row.c1, row.c2)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;itertuples()\u0026lt;/code\u0026gt; is supposed to be faster than \u0026lt;code\u0026gt;iterrows()\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;But be aware, according to the docs (pandas 0.24.2 at the moment):\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;iterrows: \u0026lt;code\u0026gt;dtype\u0026lt;/code\u0026gt; might not match from row to row\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Because iterrows returns a Series for each row, it \u0026lt;strong\u0026gt;does not preserve\u0026lt;/strong\u0026gt; dtypes across the rows (dtypes are preserved across columns for DataFrames). To preserve dtypes while iterating over the rows, it is better to use itertuples() which returns namedtuples of the values and which is generally much faster than iterrows()\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;iterrows: Do not modify rows\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;You should \u0026lt;strong\u0026gt;never modify\u0026lt;/strong\u0026gt; something you are iterating over. This is not guaranteed to work in all cases. Depending on the data types, the iterator returns a copy and not a view, and writing to it will have no effect.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Use \u0026lt;a href=\u0026quot;http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.apply.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;DataFrame.apply()\u0026lt;/a\u0026gt; instead:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;    new_df = df.apply(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt; x: x * \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, axis = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;itertuples:\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;The column names will be renamed to positional names if they are invalid Python identifiers, repeated, or start with an underscore. With a large number of columns (\u0026amp;gt;255), regular tuples are returned.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;See \u0026lt;a href=\u0026quot;https://pandas.pydata.org/docs/user_guide/basics.html#iteration\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;pandas docs on iteration\u0026lt;/a\u0026gt; for more details.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You should use \u0026lt;a href=\u0026quot;http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.iterrows.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;df.iterrows()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;. Though iterating row-by-row is not especially efficient since \u0026lt;code\u0026gt;Series\u0026lt;/code\u0026gt; objects have to be created.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;While \u0026lt;code\u0026gt;iterrows()\u0026lt;/code\u0026gt; is a good option, sometimes \u0026lt;code\u0026gt;itertuples()\u0026lt;/code\u0026gt; can be much faster:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;df = pd.DataFrame({\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: randn(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;), \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: randn(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;),\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;N\u0026apos;\u0026lt;/span\u0026gt;: randint(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;, (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;)), \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;x\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;x\u0026apos;\u0026lt;/span\u0026gt;})\n\n%timeit [row.a * \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; idx, row \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; df.iterrows()]\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# =\u0026amp;gt; 10 loops, best of 3: 50.3 ms per loop\u0026lt;/span\u0026gt;\n\n%timeit [row[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] * \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; row \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; df.itertuples()]\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# =\u0026amp;gt; 1000 loops, best of 3: 541 µs per loop\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You can use the \u0026lt;a href=\u0026quot;https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.iloc.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;df.iloc\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; function as follows:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; i \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;range\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;len\u0026lt;/span\u0026gt;(df)):\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(df.iloc[i][\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c1\u0026apos;\u0026lt;/span\u0026gt;], df.iloc[i][\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c2\u0026apos;\u0026lt;/span\u0026gt;])\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You can also use \u0026lt;code\u0026gt;df.apply()\u0026lt;/code\u0026gt; to iterate over rows and access multiple columns for a function.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.apply.html\u0026quot;\u0026gt;docs: DataFrame.apply()\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;valuation_formula\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;x, y\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; x * y * \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.5\u0026lt;/span\u0026gt;\n\ndf[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;price\u0026apos;\u0026lt;/span\u0026gt;] = df.apply(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt; row: valuation_formula(row[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;x\u0026apos;\u0026lt;/span\u0026gt;], row[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;y\u0026apos;\u0026lt;/span\u0026gt;]), axis=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;How to iterate efficiently\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;If you really have to iterate a Pandas dataframe, you will probably want to \u0026lt;strong\u0026gt;avoid using iterrows()\u0026lt;/strong\u0026gt;. There are different methods and the usual \u0026lt;code\u0026gt;iterrows()\u0026lt;/code\u0026gt; is far from being the best. \u0026lt;strong\u0026gt;itertuples() can be 100 times faster.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;In short:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;As a general rule, use \u0026lt;code\u0026gt;df.itertuples(name=None)\u0026lt;/code\u0026gt;. In particular, when you have a fixed number columns and less than 255 columns. \u0026lt;em\u0026gt;See point (3)\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Otherwise, use \u0026lt;code\u0026gt;df.itertuples()\u0026lt;/code\u0026gt; except if your columns have special characters such as spaces or \u0026apos;-\u0026apos;. \u0026lt;em\u0026gt;See point (2)\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It is possible to use \u0026lt;code\u0026gt;itertuples()\u0026lt;/code\u0026gt; even if your dataframe has strange columns by using the last example. \u0026lt;em\u0026gt;See point (4)\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Only use \u0026lt;code\u0026gt;iterrows()\u0026lt;/code\u0026gt; if you cannot the previous solutions. \u0026lt;em\u0026gt;See point (1)\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;h1\u0026gt;Different methods to iterate over rows in a Pandas dataframe:\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;Generate a random dataframe with a million rows and 4 columns:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;    df = pd.DataFrame(np.random.randint(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;, size=(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000000\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;)), columns=\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;list\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;ABCD\u0026apos;\u0026lt;/span\u0026gt;))\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(df)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;1) The usual \u0026lt;code\u0026gt;iterrows()\u0026lt;/code\u0026gt; is convenient, but damn slow:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;start_time = time.clock()\nresult = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; _, row \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; df.iterrows():\n    result += \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;max\u0026lt;/span\u0026gt;(row[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;B\u0026apos;\u0026lt;/span\u0026gt;], row[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;C\u0026apos;\u0026lt;/span\u0026gt;])\n\ntotal_elapsed_time = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;round\u0026lt;/span\u0026gt;(time.clock() - start_time, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1. Iterrows done in {} seconds, result = {}\u0026quot;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;format\u0026lt;/span\u0026gt;(total_elapsed_time, result))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;2) The default \u0026lt;code\u0026gt;itertuples()\u0026lt;/code\u0026gt; is already much faster, but it doesn\u0026apos;t work with column names such as \u0026lt;code\u0026gt;My Col-Name is very Strange\u0026lt;/code\u0026gt; (you should avoid this method if your columns are repeated or if a column name cannot be simply converted to a Python variable name).:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;start_time = time.clock()\nresult = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; row \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; df.itertuples(index=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;):\n    result += \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;max\u0026lt;/span\u0026gt;(row.B, row.C)\n\ntotal_elapsed_time = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;round\u0026lt;/span\u0026gt;(time.clock() - start_time, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;2. Named Itertuples done in {} seconds, result = {}\u0026quot;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;format\u0026lt;/span\u0026gt;(total_elapsed_time, result))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;3) The default \u0026lt;code\u0026gt;itertuples()\u0026lt;/code\u0026gt; using name=None is even faster but not really convenient as you have to define a variable per column.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;start_time = time.clock()\nresult = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(_, col1, col2, col3, col4) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; df.itertuples(name=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;):\n    result += \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;max\u0026lt;/span\u0026gt;(col2, col3)\n\ntotal_elapsed_time = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;round\u0026lt;/span\u0026gt;(time.clock() - start_time, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;3. Itertuples done in {} seconds, result = {}\u0026quot;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;format\u0026lt;/span\u0026gt;(total_elapsed_time, result))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;4) Finally, the named \u0026lt;code\u0026gt;itertuples()\u0026lt;/code\u0026gt; is slower than the previous point, but you do not have to define a variable per column and it works with column names such as \u0026lt;code\u0026gt;My Col-Name is very Strange\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;start_time = time.clock()\nresult = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; row \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; df.itertuples(index=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;):\n    result += \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;max\u0026lt;/span\u0026gt;(row[df.columns.get_loc(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;B\u0026apos;\u0026lt;/span\u0026gt;)], row[df.columns.get_loc(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;C\u0026apos;\u0026lt;/span\u0026gt;)])\n\ntotal_elapsed_time = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;round\u0026lt;/span\u0026gt;(time.clock() - start_time, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;4. Polyvalent Itertuples working even with special characters in the column name done in {} seconds, result = {}\u0026quot;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;format\u0026lt;/span\u0026gt;(total_elapsed_time, result))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Output:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;         A   B   C   D\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;       \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;41\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;63\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;23\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;       \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;54\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;24\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;65\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;       \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;15\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;34\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;       \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;39\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;94\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;82\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;97\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;        \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;88\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;79\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;54\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;    ..  ..  ..  ..\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;999995\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;48\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;27\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;25\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;999996\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;16\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;51\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;34\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;28\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;999997\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;39\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;61\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;14\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;999998\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;66\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;51\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;27\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;70\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;999999\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;51\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;53\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;47\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;99\u0026lt;/span\u0026gt;\n\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000000\u0026lt;/span\u0026gt; rows x \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt; columns]\n\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1.\u0026lt;/span\u0026gt; Iterrows done \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;104.96\u0026lt;/span\u0026gt; seconds, result = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;66151519\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2.\u0026lt;/span\u0026gt; Named Itertuples done \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1.26\u0026lt;/span\u0026gt; seconds, result = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;66151519\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3.\u0026lt;/span\u0026gt; Itertuples done \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.94\u0026lt;/span\u0026gt; seconds, result = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;66151519\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4.\u0026lt;/span\u0026gt; Polyvalent Itertuples working even \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;with\u0026lt;/span\u0026gt; special characters \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; the column name done \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2.94\u0026lt;/span\u0026gt; seconds, result = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;66151519\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://medium.com/swlh/why-pandas-itertuples-is-faster-than-iterrows-and-how-to-make-it-even-faster-bc50c0edd30d\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;This article is a very interesting comparison between iterrows and itertuples\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I was looking for \u0026lt;strong\u0026gt;How to iterate on rows\u0026lt;/strong\u0026gt; \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;and\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt; \u0026lt;strong\u0026gt;columns\u0026lt;/strong\u0026gt; and ended here so:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; i, row \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; df.iterrows():\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; j, column \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; row.iteritems():\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(column)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You can write your own iterator that implements \u0026lt;code\u0026gt;namedtuple\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; collections \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; namedtuple\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;myiter\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;d, cols=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; cols \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;:\n        v = d.values.tolist()\n        cols = d.columns.values.tolist()\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;:\n        j = [d.columns.get_loc(c) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; c \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; cols]\n        v = d.values[:, j].tolist()\n\n    n = namedtuple(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;MyTuple\u0026apos;\u0026lt;/span\u0026gt;, cols)\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; line \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;iter\u0026lt;/span\u0026gt;(v):\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;yield\u0026lt;/span\u0026gt; n(*line)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This is directly comparable to \u0026lt;code\u0026gt;pd.DataFrame.itertuples\u0026lt;/code\u0026gt;.  I\u0026apos;m aiming at performing the same task with more efficiency.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;For the given dataframe with my function:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;list\u0026lt;/span\u0026gt;(myiter(df))\n\n[MyTuple(c1=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, c2=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;), MyTuple(c1=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;, c2=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;110\u0026lt;/span\u0026gt;), MyTuple(c1=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12\u0026lt;/span\u0026gt;, c2=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;120\u0026lt;/span\u0026gt;)]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Or with \u0026lt;code\u0026gt;pd.DataFrame.itertuples\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;list\u0026lt;/span\u0026gt;(df.itertuples(index=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;))\n\n[Pandas(c1=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, c2=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;), Pandas(c1=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;, c2=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;110\u0026lt;/span\u0026gt;), Pandas(c1=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12\u0026lt;/span\u0026gt;, c2=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;120\u0026lt;/span\u0026gt;)]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;A comprehensive test\u0026lt;/strong\u0026gt;\u0026lt;br\u0026gt;\nWe test making all columns available and subsetting the columns.  \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;iterfullA\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;d\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;list\u0026lt;/span\u0026gt;(myiter(d))\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;iterfullB\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;d\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;list\u0026lt;/span\u0026gt;(d.itertuples(index=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;))\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;itersubA\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;d\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;list\u0026lt;/span\u0026gt;(myiter(d, [\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;col3\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;col4\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;col5\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;col6\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;col7\u0026apos;\u0026lt;/span\u0026gt;]))\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;itersubB\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;d\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;list\u0026lt;/span\u0026gt;(d[[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;col3\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;col4\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;col5\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;col6\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;col7\u0026apos;\u0026lt;/span\u0026gt;]].itertuples(index=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;))\n\nres = pd.DataFrame(\n    index=[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;30\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;300\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3000\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10000\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;30000\u0026lt;/span\u0026gt;],\n    columns=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;iterfullA iterfullB itersubA itersubB\u0026apos;\u0026lt;/span\u0026gt;.split(),\n    dtype=\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt;\n)\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; i \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; res.index:\n    d = pd.DataFrame(np.random.randint(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, size=(i, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;))).add_prefix(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;col\u0026apos;\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; j \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; res.columns:\n        stmt = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;{}(d)\u0026apos;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;format\u0026lt;/span\u0026gt;(j)\n        setp = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;from __main__ import d, {}\u0026apos;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;format\u0026lt;/span\u0026gt;(j)\n        res.at[i, j] = timeit(stmt, setp, number=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;)\n\nres.groupby(res.columns.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;:-\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;], axis=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;).plot(loglog=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/rt88e.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/rt88e.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/azbOF.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/azbOF.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;To loop all rows in a \u0026lt;code\u0026gt;dataframe\u0026lt;/code\u0026gt; you can use:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; x \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;range\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;len\u0026lt;/span\u0026gt;(date_example.index)):\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; date_example[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Date\u0026apos;\u0026lt;/span\u0026gt;].iloc[x]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; ind \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; df.index:\n     \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; df[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c1\u0026apos;\u0026lt;/span\u0026gt;][ind], df[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c2\u0026apos;\u0026lt;/span\u0026gt;][ind]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;We have multiple options to do the same, lots of folks have shared their answers.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I found below two methods easy and efficient to do :\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.iterrows.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;DataFrame.iterrows()\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.itertuples.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;DataFrame.itertuples()\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;Example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; pandas \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; pd\n inp = [{\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c1\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c2\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;}, {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c1\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c2\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;110\u0026lt;/span\u0026gt;}, {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c1\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c2\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;120\u0026lt;/span\u0026gt;}]\n df = pd.DataFrame(inp)\n \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; (df)\n\n \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#With iterrows method \u0026lt;/span\u0026gt;\n\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; index, row \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; df.iterrows():\n     \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(row[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;c1\u0026quot;\u0026lt;/span\u0026gt;], row[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;c2\u0026quot;\u0026lt;/span\u0026gt;])\n\n \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#With itertuples method\u0026lt;/span\u0026gt;\n\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; row \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; df.itertuples(index=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;, name=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Pandas\u0026apos;\u0026lt;/span\u0026gt;):\n     \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(row.c1, row.c2)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Note: itertuples() is supposed to be faster than iterrows()\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Sometimes a useful pattern is:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Borrowing @KutalmisB df example\u0026lt;/span\u0026gt;\ndf = pd.DataFrame({\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;col1\u0026apos;\u0026lt;/span\u0026gt;: [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;], \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;col2\u0026apos;\u0026lt;/span\u0026gt;: [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.2\u0026lt;/span\u0026gt;]}, index=[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;])\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# The to_dict call results in a list of dicts\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# where each row_dict is a dictionary with k:v pairs of columns:value for that row\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; row_dict \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; df.to_dict(orient=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;records\u0026apos;\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(row_dict)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Which results in:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;{\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;col1\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1.0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;col2\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.1\u0026lt;/span\u0026gt;}\n{\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;col1\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2.0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;col2\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.2\u0026lt;/span\u0026gt;}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Update\u0026lt;/strong\u0026gt;: cs95 has updated \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/16476924/how-to-iterate-over-rows-in-a-dataframe-in-pandas/55557758#55557758\u0026quot;\u0026gt;his answer\u0026lt;/a\u0026gt; to include plain numpy vectorization. You can simply refer to his answer.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/16476924/how-to-iterate-over-rows-in-a-dataframe-in-pandas/55557758#55557758\u0026quot;\u0026gt;cs95 shows\u0026lt;/a\u0026gt; that Pandas vectorization far outperforms other Pandas methods for computing stuff with dataframes.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I wanted to add that if you first convert the dataframe to a NumPy array and then use vectorization, it\u0026apos;s even faster than Pandas dataframe vectorization, (and that includes the time to turn it back into a dataframe series).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If you add the following functions to cs95\u0026apos;s benchmark code, this becomes pretty evident:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;np_vectorization\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;df\u0026lt;/span\u0026gt;):\n    np_arr = df.to_numpy()\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; pd.Series(np_arr[:,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] + np_arr[:,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;], index=df.index)\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;just_np_vectorization\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;df\u0026lt;/span\u0026gt;):\n    np_arr = df.to_numpy()\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; np_arr[:,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] + np_arr[:,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/L0u4A.png\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/L0u4A.png\u0026quot; alt=\u0026quot;Enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In short\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Use vectorization if possible\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If an operation can\u0026apos;t be vectorized - use list comprehensions\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If you need a single object representing the entire row - use itertuples\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the above is too slow - try \u0026lt;em\u0026gt;swifter.apply\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If it\u0026apos;s still too slow - try a \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Cython\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Cython\u0026lt;/a\u0026gt; routine\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;h3\u0026gt;Benchmark\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/ytaWK.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/ytaWK.png\u0026quot; alt=\u0026quot;Benchmark of iteration over rows in a Pandas DataFrame\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;To loop all rows in a \u0026lt;code\u0026gt;dataframe\u0026lt;/code\u0026gt; and \u0026lt;strong\u0026gt;use\u0026lt;/strong\u0026gt; values of each row \u0026lt;strong\u0026gt;conveniently\u0026lt;/strong\u0026gt;, \u0026lt;code\u0026gt;namedtuples\u0026lt;/code\u0026gt; can be converted to \u0026lt;code\u0026gt;ndarray\u0026lt;/code\u0026gt;s. For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;df = pd.DataFrame({\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;col1\u0026apos;\u0026lt;/span\u0026gt;: [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;], \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;col2\u0026apos;\u0026lt;/span\u0026gt;: [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.2\u0026lt;/span\u0026gt;]}, index=[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;])\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Iterating over the rows:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; row \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; df.itertuples(index=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;, name=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Pandas\u0026apos;\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; np.asarray(row)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;results in:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;[ \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1.\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.1\u0026lt;/span\u0026gt;]\n[ \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2.\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.2\u0026lt;/span\u0026gt;]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Please note that if \u0026lt;code\u0026gt;index=True\u0026lt;/code\u0026gt;, \u0026lt;strong\u0026gt;the index is added as the first element of the tuple\u0026lt;/strong\u0026gt;, which may be undesirable for some applications.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There is a way to iterate throw rows while getting a DataFrame in return, and not a Series. I don\u0026apos;t see anyone mentioning that you can pass index as a list for the row to be returned as a DataFrame:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; i \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;range\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;len\u0026lt;/span\u0026gt;(df)):\n    row = df.iloc[[i]]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note the usage of double brackets. This returns a DataFrame with a single row.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;For both viewing and modifying values, I would use \u0026lt;code\u0026gt;iterrows()\u0026lt;/code\u0026gt;. In a for loop and by using tuple unpacking (see the example: \u0026lt;code\u0026gt;i, row\u0026lt;/code\u0026gt;), I use the \u0026lt;code\u0026gt;row\u0026lt;/code\u0026gt; for only viewing the value and use \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; with the \u0026lt;code\u0026gt;loc\u0026lt;/code\u0026gt; method when I want to modify values. As stated in previous answers, here you should not modify something you are iterating over.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; i, row \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; df.iterrows():\n    df_column_A = df.loc[i, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;A\u0026apos;\u0026lt;/span\u0026gt;]\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; df_column_A == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Old_Value\u0026apos;\u0026lt;/span\u0026gt;:\n        df_column_A = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;New_value\u0026apos;\u0026lt;/span\u0026gt;  \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here the \u0026lt;code\u0026gt;row\u0026lt;/code\u0026gt; in the loop is a copy of that row, and not a view of it. Therefore, you should NOT write something like \u0026lt;code\u0026gt;row[\u0026apos;A\u0026apos;] = \u0026apos;New_Value\u0026apos;\u0026lt;/code\u0026gt;, it will not modify the DataFrame. However, you can use \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;loc\u0026lt;/code\u0026gt; and specify the DataFrame to do the work.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are so many ways to iterate over the rows in Pandas dataframe. One very simple and intuitive way is:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;df = pd.DataFrame({\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;A\u0026apos;\u0026lt;/span\u0026gt;:[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;], \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;B\u0026apos;\u0026lt;/span\u0026gt;:[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;], \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;C\u0026apos;\u0026lt;/span\u0026gt;:[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt;]})\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(df)\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; i \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;range\u0026lt;/span\u0026gt;(df.shape[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]):\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# For printing the second column\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(df.iloc[i, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;])\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# For printing more than one columns\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(df.iloc[i, [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;]])\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The easiest way, use the \u0026lt;code\u0026gt;apply\u0026lt;/code\u0026gt; function\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;print_row\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;row\u0026lt;/span\u0026gt;):\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; row[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c1\u0026apos;\u0026lt;/span\u0026gt;], row[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c2\u0026apos;\u0026lt;/span\u0026gt;]\n\ndf.apply(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt; row: print_row(row), axis=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As many answers here correctly and clearly point out, you should not generally attempt to loop in Pandas, but rather should write vectorized code.  But the question remains if you should \u0026lt;em\u0026gt;ever\u0026lt;/em\u0026gt; write loops in Pandas, and if so the best way to loop in those situations.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;I believe there is at least one general situation where loops are appropriate: when you need to calculate some function that depends on values in \u0026lt;em\u0026gt;other\u0026lt;/em\u0026gt; rows in a somewhat complex manner.  In this case, the looping code is often simpler, more readable, and less error prone than vectorized code.\u0026lt;/strong\u0026gt;  The looping code might even be faster, too.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I will attempt to show this with an example.  Suppose you want to take a cumulative sum of a column, but reset it whenever some other column equals zero:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; pandas \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; pd\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; numpy \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; np\n\ndf = pd.DataFrame( { \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;x\u0026apos;\u0026lt;/span\u0026gt;:[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;], \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;y\u0026apos;\u0026lt;/span\u0026gt;:[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]  } )\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#   x  y  desired_result\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#0  1  1               1\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#1  2  1               3\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#2  3  1               6\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#3  4  0               4\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#4  5  1               9\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#5  6  1              15\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This is a good example where you could certainly write one line of Pandas to achieve this, although it\u0026apos;s not especially readable, especially if you aren\u0026apos;t fairly experienced with Pandas already:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;df.groupby( (df.y==\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;).cumsum() )[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;x\u0026apos;\u0026lt;/span\u0026gt;].cumsum()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;That\u0026apos;s going to be fast enough for most situations, although you could also write faster code by avoiding the \u0026lt;code\u0026gt;groupby\u0026lt;/code\u0026gt;, but it will likely be even less readable.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Alternatively, what if we write this as a loop?  You could do something like the following with NumPy:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; numba \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; nb\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@nb.jit(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;nopython=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;)  \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Optional\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;custom_sum\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;x,y\u0026lt;/span\u0026gt;):\n    x_sum = x.copy()\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; i \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;range\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;len\u0026lt;/span\u0026gt;(df)):\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; y[i] \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;: x_sum[i] = x_sum[i-\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] + x[i]\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; x_sum\n\ndf[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;desired_result\u0026apos;\u0026lt;/span\u0026gt;] = custom_sum( df.x.to_numpy(), df.y.to_numpy() )\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Admittedly, there\u0026apos;s a bit of overhead there required to convert DataFrame columns to NumPy arrays, but the core piece of code is just one line of code that you could read even if you didn\u0026apos;t know anything about Pandas or NumPy:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; y[i] \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;: x_sum[i] = x_sum[i-\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] + x[i]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;And this code is actually \u0026lt;em\u0026gt;faster\u0026lt;/em\u0026gt; than the vectorized code.  In some quick tests with 100,000 rows, the above is about 10x faster than the \u0026lt;em\u0026gt;groupby\u0026lt;/em\u0026gt; approach.  Note that one key to the speed there is numba, which is optional.  Without the \u0026quot;@nb.jit\u0026quot; line, the looping code is actually about 10x slower than the \u0026lt;em\u0026gt;groupby\u0026lt;/em\u0026gt; approach.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Clearly this example is simple enough that you would likely prefer the one line of pandas to writing a loop with its associated overhead.  However, there are more complex versions of this problem for which the readability or speed of the NumPy/numba loop approach likely makes sense.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;df.iterrows()\u0026lt;/code\u0026gt; returns \u0026lt;code\u0026gt;tuple(a, b)\u0026lt;/code\u0026gt; where \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is the \u0026lt;code\u0026gt;index\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; is the \u0026lt;code\u0026gt;row\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You can also do NumPy indexing for even greater speed ups. It\u0026apos;s not really iterating but works much better than iteration for certain applications.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;subset = row[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c1\u0026apos;\u0026lt;/span\u0026gt;][\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;all\u0026lt;/span\u0026gt; = row[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c1\u0026apos;\u0026lt;/span\u0026gt;][:]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You may also want to cast it to an array. These indexes/selections are supposed to act like NumPy arrays already, but I ran into issues and needed to cast\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;np.asarray(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;all\u0026lt;/span\u0026gt;)\nimgs[:] = cv2.resize(imgs[:], (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;224\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;224\u0026lt;/span\u0026gt;) ) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Resize every image in an hdf5 file\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Disclaimer:\u0026lt;/strong\u0026gt; Although here are so many answers which recommend \u0026lt;strong\u0026gt;not\u0026lt;/strong\u0026gt; using an iterative (loop) approach (and I mostly agree), I would still see it as a reasonable approach for the following situation:\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Extend dataframe with data from API\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Let\u0026apos;s say you have a large dataframe which contains incomplete user data. Now you have to extend this data with additional columns, for example the user\u0026apos;s \u0026lt;code\u0026gt;age\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;gender\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Both values have to be fetched from a backend API. I\u0026apos;m assuming the API doesn\u0026apos;t provide a \u0026quot;batch\u0026quot; endpoint (which would accept multiple user IDs at once). Otherwise, you should rather call the API only once.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The costs (waiting time) for the network request surpass the iteration of the dataframe by far. We\u0026apos;re talking about network roundtrip times of hundreds of milliseconds compared to the negligibly small gains in using alternative approaches to iterations.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;1 expensive network request for each row\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;So in this case, I would absolutely prefer using an iterative approach. Although the network request is expensive, it is guaranteed being triggered only once for each row in the dataframe. Here is an example using \u0026lt;a href=\u0026quot;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iterrows.html#pandas-dataframe-iterrows\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;DataFrame.iterrows\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Example\u0026lt;/h2\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; index, row \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; users_df.iterrows():\n  user_id = row[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;user_id\u0026apos;\u0026lt;/span\u0026gt;]\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# trigger expensive network request once for each row\u0026lt;/span\u0026gt;\n  response_dict = backend_api.get(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;f\u0026apos;/api/user-data/\u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;{user_id}\u0026lt;/span\u0026gt;\u0026apos;\u0026lt;/span\u0026gt;)\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# extend dataframe with multiple data from response\u0026lt;/span\u0026gt;\n  users_df.at[index, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;age\u0026apos;\u0026lt;/span\u0026gt;] = response_dict.get(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;age\u0026apos;\u0026lt;/span\u0026gt;)\n  users_df.at[index, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;gender\u0026apos;\u0026lt;/span\u0026gt;] = response_dict.get(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;gender\u0026apos;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This example uses iloc to isolate each digit in the data frame. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; pandas \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; pd\n\n a = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;]\n b = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;]\n\n mjr = pd.DataFrame({\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;:a, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;:b})\n\n size = mjr.shape\n\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; i \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;range\u0026lt;/span\u0026gt;(size[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]):\n     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; j \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;range\u0026lt;/span\u0026gt;(size[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]):\n         \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(mjr.iloc[i, j])\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Some libraries (e.g. a Java interop library that I use) require values to be passed in a row at a time, for example, if streaming data. To replicate the streaming nature, I \u0026apos;stream\u0026apos; my dataframe values one by one, I wrote the below, which comes in handy from time to time.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;DataFrameReader\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__init__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, df\u0026lt;/span\u0026gt;):\n    self._df = df\n    self._row = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;\n    self._columns = df.columns.tolist()\n    self.reset()\n    self.row_index = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__getattr__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, key\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; self.__getitem__(key)\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;read\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;) -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt;:\n    self._row = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;next\u0026lt;/span\u0026gt;(self._iterator, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;)\n    self.row_index += \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; self._row \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;columns\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; self._columns\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;reset\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;) -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;:\n    self._iterator = self._df.itertuples()\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;get_index\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; self._row[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;index\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; self._row[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;to_dict\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, columns: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;List\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; self.row(columns=columns)\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;tolist\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, cols\u0026lt;/span\u0026gt;) -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;List\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt;]:\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; [self.__getitem__(c) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; c \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; cols]\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;row\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, columns: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;List\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;) -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Dict\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt;]:\n    cols = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;set\u0026lt;/span\u0026gt;(self._columns \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; columns \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; columns)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; {c : self.__getitem__(c) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; c \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; self._columns \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; c \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; cols}\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__getitem__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, key\u0026lt;/span\u0026gt;) -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# the df index of the row is at index 0\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;try\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt;(key) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;list\u0026lt;/span\u0026gt;:\n            ix = [self._columns.index(key) + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; k \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; key]\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;:\n            ix = self._columns.index(key) + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; self._row[ix]\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;except\u0026lt;/span\u0026gt; BaseException \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; e:\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__next__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;) -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;DataFrameReader\u0026apos;\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; self.read():\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; self\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;raise\u0026lt;/span\u0026gt; StopIteration\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__iter__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;) -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;DataFrameReader\u0026apos;\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; self\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Which can be used:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; row \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; DataFrameReader(df):\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(row.my_column_name)\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(row.to_dict())\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(row[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;my_column_name\u0026apos;\u0026lt;/span\u0026gt;])\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(row.tolist())\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And preserves the values/ name mapping for the rows being iterated. Obviously, is a lot slower than using apply and Cython as indicated above, but is necessary in some circumstances.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Along with the great answers in this post I am going to propose \u0026lt;strong\u0026gt;Divide and Conquer\u0026lt;/strong\u0026gt; approach, I am not writing this answer to abolish the other great answers but to fulfill them with another approach which was working efficiently for me. It has two steps of \u0026lt;code\u0026gt;splitting\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;merging\u0026lt;/code\u0026gt; the pandas dataframe:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;PROS of Divide and Conquer:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;You don\u0026apos;t need to use vectorization or any other methods to cast the type of your dataframe into another type\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;You don\u0026apos;t need to Cythonize your code which normally takes extra time from you\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Both \u0026lt;code\u0026gt;iterrows()\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;itertuples()\u0026lt;/code\u0026gt; in my case were having the same performance over entire dataframe\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Depends on your choice of slicing \u0026lt;code\u0026gt;index\u0026lt;/code\u0026gt;, you will be able to exponentially quicken the iteration. The higher \u0026lt;code\u0026gt;index\u0026lt;/code\u0026gt;, the quicker your iteration process.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;CONS of Divide and Conquer:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;You shouldn\u0026apos;t have dependency over the iteration process to the same dataframe and different \u0026lt;em\u0026gt;slice\u0026lt;/em\u0026gt;. Meaning if you want to read or write from other \u0026lt;em\u0026gt;slice\u0026lt;/em\u0026gt;, it maybe difficult to do that.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;===================    Divide and Conquer Approach    =================\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Step 1: Splitting/Slicing\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In this step, we are going to divide the iteration over the entire dataframe. Think that you are going to read a csv file into pandas df then iterate over it. In may case I have 5,000,000 records and I am going to split it into 100,000 records.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;NOTE:\u0026lt;/strong\u0026gt; I need to reiterate as other runtime analysis explained in the other solutions in this page, \u0026quot;number of records\u0026quot; has exponential proportion of \u0026quot;runtime\u0026quot; on search on the df. Based on the benchmark on my data here are the results:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;Number of records | Iteration per second\n========================================\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;000\u0026lt;/span\u0026gt;           | \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;500\u0026lt;/span\u0026gt; it/s\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;500\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;000\u0026lt;/span\u0026gt;           | \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;200\u0026lt;/span\u0026gt; it/s\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;000\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;000\u0026lt;/span\u0026gt;         | \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;50\u0026lt;/span\u0026gt; it/s\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;000\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;000\u0026lt;/span\u0026gt;         | \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt; it/s\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Step 2: Merging\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This is going to be an easy step, just merge all the written csv files into one dataframe and write it into a bigger csv file.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Here is the sample code:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Step 1 (Splitting/Slicing)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; pandas \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; pd\ndf_all = pd.read_csv(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;C:/KtV.csv\u0026apos;\u0026lt;/span\u0026gt;)\ndf_index = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100000\u0026lt;/span\u0026gt;\ndf_len = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;len\u0026lt;/span\u0026gt;(df)\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; i \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;range\u0026lt;/span\u0026gt;(df_len // df_index + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;):\n    lower_bound = i * df_index \n    higher_bound = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;min\u0026lt;/span\u0026gt;(lower_bound + df_index, df_len)\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# splitting/slicing df (make sure to copy() otherwise it will be a view\u0026lt;/span\u0026gt;\n    df = df_all[lower_bound:higher_bound].copy()\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026apos;\u0026apos;\n    write your iteration over the sliced df here\n    using iterrows() or intertuples() or ...\n    \u0026apos;\u0026apos;\u0026apos;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# writing into csv files\u0026lt;/span\u0026gt;\n    df.to_csv(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;C:/KtV_prep_\u0026apos;\u0026lt;/span\u0026gt;+\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt;(i)+\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;.csv\u0026apos;\u0026lt;/span\u0026gt;)\n\n\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Step 2 (Merging)\u0026lt;/span\u0026gt;\nfilename=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;C:/KtV_prep_\u0026apos;\u0026lt;/span\u0026gt;\ndf = (pd.read_csv(f) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; f \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; [filename+\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt;(i)+\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;.csv\u0026apos;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; i \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;range\u0026lt;/span\u0026gt;(ktv_len // ktv_index + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)])\ndf_prep_all = pd.concat(df)\ndf_prep_all.to_csv(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;C:/KtV_prep_all.csv\u0026apos;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Reference:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/7837722/what-is-the-most-efficient-way-to-loop-through-dataframes-with-pandas\u0026quot;\u0026gt;Efficient way of iteration over datafreame\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/20906474/import-multiple-csv-files-into-pandas-and-concatenate-into-one-dataframe\u0026quot;\u0026gt;Concatenate csv files into one Pandas Dataframe\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/16476924/how-to-iterate-over-rows-in-a-dataframe-in-pandas/16476974#16476974\u0026quot;\u0026gt;the accepted answer\u0026lt;/a\u0026gt; states, the fastest way to apply a function over rows is to use a \u0026lt;strong\u0026gt;vectorized function\u0026lt;/strong\u0026gt;, the so-called NumPy \u0026lt;code\u0026gt;ufuncs\u0026lt;/code\u0026gt; (universal functions).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;But what should you do when the function you want to apply isn\u0026apos;t already implemented in NumPy?\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Well, using the \u0026lt;code\u0026gt;vectorize\u0026lt;/code\u0026gt; decorator from \u0026lt;code\u0026gt;numba\u0026lt;/code\u0026gt;, you can easily create ufuncs directly in Python like this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; numba \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; vectorize, float64\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@vectorize(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;[float64(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;float64\u0026lt;/span\u0026gt;)]\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#x is your line, do something with it, and return a float\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The documentation for this function is here: \u0026lt;em\u0026gt;\u0026lt;a href=\u0026quot;https://numba.pydata.org/numba-doc/latest/user/vectorize.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Creating NumPy universal functions\u0026lt;/a\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Probably the most elegant solution (but certainly not the most efficient):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; row \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; df.values:\n    c2 = row[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(row)\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# ...\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; c1, c2 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; df.values:\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# ...\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Note that:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;the \u0026lt;a href=\u0026quot;https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.values.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;documentation\u0026lt;/a\u0026gt; explicitly recommends to use \u0026lt;code\u0026gt;.to_numpy()\u0026lt;/code\u0026gt; instead\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;the produced NumPy array will have a dtype that fits all columns, in the worst case \u0026lt;code\u0026gt;object\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;there are \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/55557758/4248897\u0026quot;\u0026gt;good reasons\u0026lt;/a\u0026gt; not to use a loop in the first place\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Still, I think this option should be included here, as a straight-forward solution to a (one should think) trivial problem.\u0026lt;/p\u0026gt;\n    "],"id":234,"title":"How to iterate over rows in a DataFrame in Pandas","content":"\n                \n\u0026lt;p\u0026gt;I have a pandas dataframe, \u0026lt;code\u0026gt;df\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;   c1   c2\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;110\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;120\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;How do I iterate over the rows of this dataframe? For every row, I want to be able to access its elements (values in cells) by the name of the columns. For example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; row \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; df.rows:\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(row[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c1\u0026apos;\u0026lt;/span\u0026gt;], row[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c2\u0026apos;\u0026lt;/span\u0026gt;])\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;I found a \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/7837722/what-is-the-most-efficient-way-to-loop-through-dataframes-with-pandas\u0026quot;\u0026gt;similar question\u0026lt;/a\u0026gt; which suggests using either of these:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; date, row \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; df.T.iteritems():\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; row \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; df.iterrows():\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;But I do not understand what the \u0026lt;code\u0026gt;row\u0026lt;/code\u0026gt; object is and how I can work with it.\u0026lt;/p\u0026gt;\n    ","slug":"how-to-iterate-over-rows-in-a-dataframe-in-pandas-1657387358115","postType":"QUESTION","createdAt":"2022-07-09T17:22:38.000Z","updatedAt":"2022-07-09T17:22:38.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"Web-scraping JavaScript page with Python","slug":"web-scraping-javascript-page-with-python-1657388240875"},{"title":"How do I get PHP errors to display?","slug":"how-do-i-get-php-errors-to-display-1657384570095"},{"title":"Dynamically select data frame columns using $ and a character value","slug":"dynamically-select-data-frame-columns-using-dollar-and-a-character-value-1657387836662"},{"title":"Removing duplicates in lists","slug":"removing-duplicates-in-lists-1657388207448"},{"title":"Strange result when removing item from a list while iterating over it [duplicate]","slug":"strange-result-when-removing-item-from-a-list-while-iterating-over-it-duplicate-1657387735759"},{"title":"Dynamic tabs with user-click chosen components","slug":"dynamic-tabs-with-user-click-chosen-components-1657388465232"},{"title":"Post an HTML Table to ADO.NET DataTable","slug":"post-an-html-table-to-ado.net-datatable-1657387462723"},{"title":"Default constructor with empty brackets","slug":"default-constructor-with-empty-brackets-1657388246967"},{"title":"How to make a great R reproducible example","slug":"how-to-make-a-great-r-reproducible-example-1657384198173"},{"title":"Resolve build errors due to circular dependency amongst classes","slug":"resolve-build-errors-due-to-circular-dependency-amongst-classes-1657384903462"},{"title":"How to convert a factor to integer\\numeric without loss of information?","slug":"how-to-convert-a-factor-to-integernumeric-without-loss-of-information-1657387880273"},{"title":"How do I give text or an image a transparent background using CSS?","slug":"how-do-i-give-text-or-an-image-a-transparent-background-using-css-1657388188508"},{"title":"Center one and right/left align other flexbox element","slug":"center-one-and-rightleft-align-other-flexbox-element-1657387899083"},{"title":"Self-references in object literals / initializers","slug":"self-references-in-object-literals-initializers-1657384835356"},{"title":"What is the explicit promise construction antipattern and how do I avoid it?","slug":"what-is-the-explicit-promise-construction-antipattern-and-how-do-i-avoid-it-1657384436212"},{"title":"Why does my recursive function return None?","slug":"why-does-my-recursive-function-return-none-1657387792894"},{"title":"How do I iterate over the words of a string?","slug":"how-do-i-iterate-over-the-words-of-a-string-1657384806129"},{"title":"What are valid values for the id attribute in HTML?","slug":"what-are-valid-values-for-the-id-attribute-in-html-1657384874780"},{"title":"Can a local variable's memory be accessed outside its scope?","slug":"can-a-local-variable's-memory-be-accessed-outside-its-scope-1657384460386"},{"title":"How to horizontally center an element","slug":"how-to-horizontally-center-an-element-1657384634147"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"how-to-iterate-over-rows-in-a-dataframe-in-pandas-1657387358115"},"buildId":"BnkbnjkWYxefPXjTJLVVv","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>