<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>How do function pointers in C work? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="I had some experience lately with function pointers in C.

So going on with the tradition of answering your own questions, I decided to make a small summary of the very basics, for those who need a quick dive-in to the subject.
    "/><meta property="og:title" content="How do function pointers in C work? | Solutions Checker"/><meta property="og:description" content="I had some experience lately with function pointers in C.

So going on with the tradition of answering your own questions, I decided to make a small summary of the very basics, for those who need a quick dive-in to the subject.
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"How do function pointers in C work?","text":"I had some experience lately with function pointers in C.\n\nSo going on with the tradition of answering your own questions, I decided to make a small summary of the very basics, for those who need a quick dive-in to the subject.\n    ","answerCount":11,"upVoteCount":500,"suggestedAnswer":[{"text":"Function pointers in C\n\nLet&apos;s start with a basic function which we will be pointing to:\n\nint addInt(int n, int m) {\n    return n+m;\n}\n\n\nFirst thing, let&apos;s define a pointer to a function which receives 2 ints and returns an int:\n\nint (*functionPtr)(int,int);\n\n\nNow we can safely point to our function:\n\nfunctionPtr = &amp;addInt;\n\n\nNow that we have a pointer to the function, let&apos;s use it:\n\nint sum = (*functionPtr)(2, 3); // sum == 5\n\n\nPassing the pointer to another function is basically the same:\n\nint add2to3(int (*functionPtr)(int, int)) {\n    return (*functionPtr)(2, 3);\n}\n\n\nWe can use function pointers in return values as well (try to keep up, it gets messy):\n\n// this is a function called functionFactory which receives parameter n\n// and returns a pointer to another function which receives two ints\n// and it returns another int\nint (*functionFactory(int n))(int, int) {\n    printf(&quot;Got parameter %d&quot;, n);\n    int (*functionPtr)(int,int) = &amp;addInt;\n    return functionPtr;\n}\n\n\nBut it&apos;s much nicer to use a typedef:\n\ntypedef int (*myFuncDef)(int, int);\n// note that the typedef name is indeed myFuncDef\n\nmyFuncDef functionFactory(int n) {\n    printf(&quot;Got parameter %d&quot;, n);\n    myFuncDef functionPtr = &amp;addInt;\n    return functionPtr;\n}\n\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"Function pointers in C can be used to perform object-oriented programming in C.\n\nFor example, the following lines is written in C:\n\nString s1 = newString();\ns1-&gt;set(s1, &quot;hello&quot;);\n\n\nYes, the -&gt; and the lack of a new operator is a dead give away, but it sure seems to imply that we&apos;re setting the text of some String class to be &quot;hello&quot;.\n\nBy using function pointers, it is possible to emulate methods in C.\n\nHow is this accomplished?\n\nThe String class is actually a struct with a bunch of function pointers which act as a way to simulate methods. The following is a partial declaration of the String class:\n\ntypedef struct String_Struct* String;\n\nstruct String_Struct\n{\n    char* (*get)(const void* self);\n    void (*set)(const void* self, char* value);\n    int (*length)(const void* self);\n};\n\nchar* getString(const void* self);\nvoid setString(const void* self, char* value);\nint lengthString(const void* self);\n\nString newString();\n\n\nAs can be seen, the methods of the String class are actually function pointers to the declared function. In preparing the instance of the String, the newString function is called in order to set up the function pointers to their respective functions:\n\nString newString()\n{\n    String self = (String)malloc(sizeof(struct String_Struct));\n\n    self-&gt;get = &amp;getString;\n    self-&gt;set = &amp;setString;\n    self-&gt;length = &amp;lengthString;\n\n    self-&gt;set(self, &quot;&quot;);\n\n    return self;\n}\n\n\nFor example, the getString function that is called by invoking the get method is defined as the following:\n\nchar* getString(const void* self_obj)\n{\n    return ((String)self_obj)-&gt;internal-&gt;value;\n}\n\n\nOne thing that can be noticed is that there is no concept of an instance of an object and having methods that are actually a part of an object, so a &quot;self object&quot; must be passed in on each invocation. (And the internal is just a hidden struct which was omitted from the code listing earlier -- it is a way of performing information hiding, but that is not relevant to function pointers.)\n\nSo, rather than being able to do s1-&gt;set(&quot;hello&quot;);, one must pass in the object to perform the action on s1-&gt;set(s1, &quot;hello&quot;). \n\nWith that minor explanation having to pass in a reference to yourself out of the way, we&apos;ll move to the next part, which is inheritance in C.\n\nLet&apos;s say we want to make a subclass of String, say an ImmutableString. In order to make the string immutable, the set method will not be accessible, while maintaining access to get and length, and force the &quot;constructor&quot; to accept a char*:\n\ntypedef struct ImmutableString_Struct* ImmutableString;\n\nstruct ImmutableString_Struct\n{\n    String base;\n\n    char* (*get)(const void* self);\n    int (*length)(const void* self);\n};\n\nImmutableString newImmutableString(const char* value);\n\n\nBasically, for all subclasses, the available methods are once again function pointers. This time, the declaration for the set method is not present, therefore, it cannot be called in a ImmutableString.\n\nAs for the implementation of the ImmutableString, the only relevant code is the &quot;constructor&quot; function, the newImmutableString:\n\nImmutableString newImmutableString(const char* value)\n{\n    ImmutableString self = (ImmutableString)malloc(sizeof(struct ImmutableString_Struct));\n\n    self-&gt;base = newString();\n\n    self-&gt;get = self-&gt;base-&gt;get;\n    self-&gt;length = self-&gt;base-&gt;length;\n\n    self-&gt;base-&gt;set(self-&gt;base, (char*)value);\n\n    return self;\n}\n\n\nIn instantiating the ImmutableString, the function pointers to the get and length methods actually refer to the String.get and String.length method, by going through the base variable which is an internally stored String object.\n\nThe use of a function pointer can achieve inheritance of a method from a superclass.\n\nWe can further continue to polymorphism in C.\n\nIf for example we wanted to change the behavior of the length method to return 0 all the time in the ImmutableString class for some reason, all that would have to be done is to:\n\n\nAdd a function that is going to serve as the overriding length method.\nGo to the &quot;constructor&quot; and set the function pointer to the overriding length method.\n\n\nAdding an overriding length method in ImmutableString may be performed by adding an lengthOverrideMethod:\n\nint lengthOverrideMethod(const void* self)\n{\n    return 0;\n}\n\n\nThen, the function pointer for the length method in the constructor is hooked up to the lengthOverrideMethod:\n\nImmutableString newImmutableString(const char* value)\n{\n    ImmutableString self = (ImmutableString)malloc(sizeof(struct ImmutableString_Struct));\n\n    self-&gt;base = newString();\n\n    self-&gt;get = self-&gt;base-&gt;get;\n    self-&gt;length = &amp;lengthOverrideMethod;\n\n    self-&gt;base-&gt;set(self-&gt;base, (char*)value);\n\n    return self;\n}\n\n\nNow, rather than having an identical behavior for the length method in ImmutableString class as the String class, now the length method will refer to the behavior defined in the lengthOverrideMethod function.\n\nI must add a disclaimer that I am still learning how to write with an object-oriented programming style in C, so there probably are points that I didn&apos;t explain well, or may just be off mark in terms of how best to implement OOP in C. But my purpose was to try to illustrate one of many uses of function pointers.\n\nFor more information on how to perform object-oriented programming in C, please refer to the following questions:\n\n\nObject-Orientation in C?\nCan you write object oriented code in C?\n\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"The guide to getting fired: How to abuse function pointers in GCC on x86 machines by compiling your code by hand:\n\nThese string literals are bytes of 32-bit x86 machine code.  0xC3 is an x86 ret instruction.\n\nYou wouldn&apos;t normally write these by hand, you&apos;d write in assembly language and then use an assembler like nasm to assemble it into a flat binary which you hexdump into a C string literal.\n\n\nReturns the current value on the EAX register\n\nint eax = ((int(*)())(&quot;\\xc3 &lt;- This returns the value of the EAX register&quot;))();\n\nWrite a swap function\n\nint a = 10, b = 20;\n((void(*)(int*,int*))&quot;\\x8b\\x44\\x24\\x04\\x8b\\x5c\\x24\\x08\\x8b\\x00\\x8b\\x1b\\x31\\xc3\\x31\\xd8\\x31\\xc3\\x8b\\x4c\\x24\\x04\\x89\\x01\\x8b\\x4c\\x24\\x08\\x89\\x19\\xc3 &lt;- This swaps the values of a and b&quot;)(&amp;a,&amp;b);\n\nWrite a for-loop counter to 1000, calling some function each time\n\n((int(*)())&quot;\\x66\\x31\\xc0\\x8b\\x5c\\x24\\x04\\x66\\x40\\x50\\xff\\xd3\\x58\\x66\\x3d\\xe8\\x03\\x75\\xf4\\xc3&quot;)(&amp;function); // calls function with 1-&gt;1000\n\nYou can even write a recursive function that counts to 100\n\nconst char* lol = &quot;\\x8b\\x5c\\x24\\x4\\x3d\\xe8\\x3\\x0\\x0\\x7e\\x2\\x31\\xc0\\x83\\xf8\\x64\\x7d\\x6\\x40\\x53\\xff\\xd3\\x5b\\xc3\\xc3 &lt;- Recursively calls the function at address lol.&quot;;\ni = ((int(*)())(lol))(lol);\n\n\n\nNote that compilers place string literals in the .rodata section (or .rdata on Windows), which is linked as part of the text segment (along with code for functions).\n\nThe text segment has Read+Exec permission, so casting string literals to function pointers works without needing mprotect() or VirtualProtect() system calls like you&apos;d need for dynamically allocated memory.  (Or gcc -z execstack links the program with stack + data segment + heap executable, as a quick hack.)\n\n\n\nTo disassemble these, you can compile this to put a label on the bytes, and use a disassembler.\n\n// at global scope\nconst char swap[] = &quot;\\x8b\\x44\\x24\\x04\\x8b\\x5c\\x24\\x08\\x8b\\x00\\x8b\\x1b\\x31\\xc3\\x31\\xd8\\x31\\xc3\\x8b\\x4c\\x24\\x04\\x89\\x01\\x8b\\x4c\\x24\\x08\\x89\\x19\\xc3 &lt;- This swaps the values of a and b&quot;;\n\n\nCompiling with gcc -c -m32 foo.c and disassembling with objdump -D -rwC -Mintel, we can get the assembly, and find out that this code violates the ABI by clobbering EBX (a call-preserved register) and is generally inefficient.\n\n00000000 &lt;swap&gt;:\n   0:   8b 44 24 04             mov    eax,DWORD PTR [esp+0x4]   # load int *a arg from the stack\n   4:   8b 5c 24 08             mov    ebx,DWORD PTR [esp+0x8]   # ebx = b\n   8:   8b 00                   mov    eax,DWORD PTR [eax]       # dereference: eax = *a\n   a:   8b 1b                   mov    ebx,DWORD PTR [ebx]\n   c:   31 c3                   xor    ebx,eax                # pointless xor-swap\n   e:   31 d8                   xor    eax,ebx                # instead of just storing with opposite registers\n  10:   31 c3                   xor    ebx,eax\n  12:   8b 4c 24 04             mov    ecx,DWORD PTR [esp+0x4]  # reload a from the stack\n  16:   89 01                   mov    DWORD PTR [ecx],eax     # store to *a\n  18:   8b 4c 24 08             mov    ecx,DWORD PTR [esp+0x8]\n  1c:   89 19                   mov    DWORD PTR [ecx],ebx\n  1e:   c3                      ret    \n\n  not shown: the later bytes are ASCII text documentation\n  they&apos;re not executed by the CPU because the ret instruction sends execution back to the caller\n\n\nThis machine code will (probably) work in 32-bit code on Windows, Linux, OS X, and so on: the default calling conventions on all those OSes pass args on the stack instead of more efficiently in registers.  But EBX is call-preserved in all the normal calling conventions, so using it as a scratch register without saving/restoring it can easily make the caller crash.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"One of my favorite uses for function pointers is as cheap and easy iterators - \n\n#include &lt;stdio.h&gt;\n#define MAX_COLORS  256\n\ntypedef struct {\n    char* name;\n    int red;\n    int green;\n    int blue;\n} Color;\n\nColor Colors[MAX_COLORS];\n\n\nvoid eachColor (void (*fp)(Color *c)) {\n    int i;\n    for (i=0; i&lt;MAX_COLORS; i++)\n        (*fp)(&amp;Colors[i]);\n}\n\nvoid printColor(Color* c) {\n    if (c-&gt;name)\n        printf(&quot;%s = %i,%i,%i\\n&quot;, c-&gt;name, c-&gt;red, c-&gt;green, c-&gt;blue);\n}\n\nint main() {\n    Colors[0].name=&quot;red&quot;;\n    Colors[0].red=255;\n    Colors[1].name=&quot;blue&quot;;\n    Colors[1].blue=255;\n    Colors[2].name=&quot;black&quot;;\n\n    eachColor(printColor);\n}\n\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"Function pointers become easy to declare once you have the basic declarators:\n\n\nid: ID: ID is a\nPointer: *D: D pointer to\nFunction: D(&lt;parameters&gt;): D function taking &lt;parameters&gt; returning\n\n\nWhile D is another declarator built using those same rules. In the end, somewhere, it ends with ID (see below for an example), which is the name of the declared entity. Let&apos;s try to build a function taking a pointer to a function taking nothing and returning int, and returning a pointer to a function taking a char and returning int. With type-defs it&apos;s like this\n\ntypedef int ReturnFunction(char);\ntypedef int ParameterFunction(void);\nReturnFunction *f(ParameterFunction *p);\n\n\nAs you see, it&apos;s pretty easy to build it up using typedefs. Without typedefs, it&apos;s not hard either with the above declarator rules, applied consistently. As you see i missed out the part the pointer points to, and the thing the function returns. That&apos;s what appears at the very left of the declaration, and is not of interest: It&apos;s added at the end if one built up the declarator already. Let&apos;s do that. Building it up consistently, first wordy - showing the structure using [ and ]:\n\nfunction taking \n    [pointer to [function taking [void] returning [int]]] \nreturning\n    [pointer to [function taking [char] returning [int]]]\n\n\nAs you see, one can describe a type completely by appending declarators one after each other. Construction can be done in two ways. One is bottom-up, starting with the very right thing (leaves) and working the way through up to the identifier. The other way is top-down, starting at the identifier, working the way down to the leaves. I&apos;ll show both ways.\n\nBottom Up\n\nConstruction starts with the thing at the right: The thing returned, which is the function taking char. To keep the declarators distinct, i&apos;m going to number them:\n\nD1(char);\n\n\nInserted the char parameter directly, since it&apos;s trivial. Adding a pointer to declarator by replacing D1 by *D2. Note that we have to wrap parentheses around *D2. That can be known by looking up the precedence of the *-operator and the function-call operator (). Without our parentheses, the compiler would read it as *(D2(char p)). But that would not be a plain replace of D1 by *D2 anymore, of course. Parentheses are always allowed around declarators. So you don&apos;t make anything wrong if you add too much of them, actually.\n\n(*D2)(char);\n\n\nReturn type is complete! Now, let&apos;s replace D2 by the function declarator function taking &lt;parameters&gt; returning, which is D3(&lt;parameters&gt;) which we are at now. \n\n(*D3(&lt;parameters&gt;))(char)\n\n\nNote that no parentheses are needed, since we want D3 to be a function-declarator and not a pointer declarator this time. Great, only thing left is the parameters for it. The parameter is done exactly the same as we&apos;ve done the return type, just with char replaced by void. So i&apos;ll copy it:\n\n(*D3(   (*ID1)(void)))(char)\n\n\nI&apos;ve replaced D2 by ID1, since we are finished with that parameter (it&apos;s already a pointer to a function - no need for another declarator). ID1 will be the name of the parameter. Now, i told above at the end one adds the type which all those declarator modify - the one appearing at the very left of every declaration. For functions, that becomes the return type. For pointers the pointed to type etc... It&apos;s interesting when written down the type, it will appear in the opposite order, at the very right :) Anyway, substituting it yields the complete declaration. Both times int of course. \n\nint (*ID0(int (*ID1)(void)))(char)\n\n\nI&apos;ve called the identifier of the function ID0 in that example. \n\nTop Down\n\nThis starts at the identifier at the very left in the description of the type, wrapping that declarator as we walk our way through the right. Start with function taking &lt;parameters&gt; returning\n\nID0(&lt;parameters&gt;)\n\n\nThe next thing in the description (after &quot;returning&quot;) was pointer to. Let&apos;s incorporate it:\n\n*ID0(&lt;parameters&gt;)\n\n\nThen the next thing was functon taking &lt;parameters&gt; returning. The parameter is a simple char, so we put it in right away again, since it&apos;s really trivial.\n\n(*ID0(&lt;parameters&gt;))(char)\n\n\nNote the parentheses we added, since we again want that the * binds first, and then the (char). Otherwise it would read function taking &lt;parameters&gt; returning function .... Noes, functions returning functions aren&apos;t even allowed. \n\nNow we just need to put &lt;parameters&gt;. I will show a short version of the deriveration, since i think you already by now have the idea how to do it.\n\npointer to: *ID1\n... function taking void returning: (*ID1)(void)\n\n\nJust put int before the declarators like we did with bottom-up, and we are finished\n\nint (*ID0(int (*ID1)(void)))(char)\n\n\nThe nice thing\n\nIs bottom-up or top-down better? I&apos;m used to bottom-up, but some people may be more comfortable with top-down. It&apos;s a matter of taste i think. Incidentally, if you apply all the operators in that declaration, you will end up getting an int:\n\nint v = (*ID0(some_function_pointer))(some_char);\n\n\nThat is a nice property of declarations in C: The declaration asserts that if those operators are used in an expression using the identifier, then it yields the type on the very left. It&apos;s like that for arrays too. \n\nHope you liked this little tutorial! Now we can link to this when people wonder about the strange declaration syntax of functions. I tried to put as little C internals as possible. Feel free to edit/fix things in it. \n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"Another good use for function pointers:Switching between versions painlessly\n\nThey&apos;re very handy to use for when you want different functions at different times, or different phases of development. For instance, I&apos;m developing an application on a host computer that has a console, but the final release of the software will be put on an Avnet ZedBoard (which has ports for displays and consoles, but they are not needed/wanted for the final release). So during development, I will use printf to view status and error messages, but when I&apos;m done, I don&apos;t want anything printed. Here&apos;s what I&apos;ve done:\n\nversion.h\n\n// First, undefine all macros associated with version.h\n#undef DEBUG_VERSION\n#undef RELEASE_VERSION\n#undef INVALID_VERSION\n\n\n// Define which version we want to use\n#define DEBUG_VERSION       // The current version\n// #define RELEASE_VERSION  // To be uncommented when finished debugging\n\n#ifndef __VERSION_H_      /* prevent circular inclusions */\n    #define __VERSION_H_  /* by using protection macros */\n    void board_init();\n    void noprintf(const char *c, ...); // mimic the printf prototype\n#endif\n\n// Mimics the printf function prototype. This is what I&apos;ll actually \n// use to print stuff to the screen\nvoid (* zprintf)(const char*, ...); \n\n// If debug version, use printf\n#ifdef DEBUG_VERSION\n    #include &lt;stdio.h&gt;\n#endif\n\n// If both debug and release version, error\n#ifdef DEBUG_VERSION\n#ifdef RELEASE_VERSION\n    #define INVALID_VERSION\n#endif\n#endif\n\n// If neither debug or release version, error\n#ifndef DEBUG_VERSION\n#ifndef RELEASE_VERSION\n    #define INVALID_VERSION\n#endif\n#endif\n\n#ifdef INVALID_VERSION\n    // Won&apos;t allow compilation without a valid version define\n    #error &quot;Invalid version definition&quot;\n#endif\n\n\nIn version.c I will define the 2 function prototypes present in version.h\n\nversion.c\n\n#include &quot;version.h&quot;\n\n/*****************************************************************************/\n/**\n* @name board_init\n*\n* Sets up the application based on the version type defined in version.h.\n* Includes allowing or prohibiting printing to STDOUT.\n*\n* MUST BE CALLED FIRST THING IN MAIN\n*\n* @return    None\n*\n*****************************************************************************/\nvoid board_init()\n{\n    // Assign the print function to the correct function pointer\n    #ifdef DEBUG_VERSION\n        zprintf = &amp;printf;\n    #else\n        // Defined below this function\n        zprintf = &amp;noprintf;\n    #endif\n}\n\n/*****************************************************************************/\n/**\n* @name noprintf\n*\n* simply returns with no actions performed\n*\n* @return   None\n*\n*****************************************************************************/\nvoid noprintf(const char* c, ...)\n{\n    return;\n}\n\n\nNotice how the function pointer is prototyped in version.h as void (* zprintf)(const char *, ...);When it is referenced in the application, it will start executing wherever it is pointing, which has yet to be defined.\nIn version.c, notice in the board_init()function where zprintf is assigned a unique function (whose function signature matches) depending on the version that is defined in version.hzprintf = &amp;printf; zprintf calls printf for debugging purposesorzprintf = &amp;noprint; zprintf just returns and will not run unnecessary code\n\nRunning the code will look like this:\n\nmainProg.c\n\n#include &quot;version.h&quot;\n#include &lt;stdlib.h&gt;\nint main()\n{\n    // Must run board_init(), which assigns the function\n    // pointer to an actual function\n    board_init();\n\n    void *ptr = malloc(100); // Allocate 100 bytes of memory\n    // malloc returns NULL if unable to allocate the memory.\n\n    if (ptr == NULL)\n    {\n        zprintf(&quot;Unable to allocate memory\\n&quot;);\n        return 1;\n    }\n\n    // Other things to do...\n    return 0;\n}\n\n\nThe above code will use printf if in debug mode, or do nothing if in release mode. This is much easier than going through the entire project and commenting out or deleting code. All that I need to do is change the version in version.h and the code will do the rest!\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"Function pointer is usually defined by typedef, and used as param &amp; return value.\n\nAbove answers already explained a lot, I just give a full example:\n\n#include &lt;stdio.h&gt;\n\n#define NUM_A 1\n#define NUM_B 2\n\n// define a function pointer type\ntypedef int (*two_num_operation)(int, int);\n\n// an actual standalone function\nstatic int sum(int a, int b) {\n    return a + b;\n}\n\n// use function pointer as param,\nstatic int sum_via_pointer(int a, int b, two_num_operation funp) {\n    return (*funp)(a, b);\n}\n\n// use function pointer as return value,\nstatic two_num_operation get_sum_fun() {\n    return &amp;sum;\n}\n\n// test - use function pointer as variable,\nvoid test_pointer_as_variable() {\n    // create a pointer to function,\n    two_num_operation sum_p = &amp;sum;\n    // call function via pointer\n    printf(&quot;pointer as variable:\\t %d + %d = %d\\n&quot;, NUM_A, NUM_B, (*sum_p)(NUM_A, NUM_B));\n}\n\n// test - use function pointer as param,\nvoid test_pointer_as_param() {\n    printf(&quot;pointer as param:\\t %d + %d = %d\\n&quot;, NUM_A, NUM_B, sum_via_pointer(NUM_A, NUM_B, &amp;sum));\n}\n\n// test - use function pointer as return value,\nvoid test_pointer_as_return_value() {\n    printf(&quot;pointer as return value:\\t %d + %d = %d\\n&quot;, NUM_A, NUM_B, (*get_sum_fun())(NUM_A, NUM_B));\n}\n\nint main() {\n    test_pointer_as_variable();\n    test_pointer_as_param();\n    test_pointer_as_return_value();\n\n    return 0;\n}\n\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"Starting from scratch function has Some Memory Address From Where They start executing. In Assembly Language They Are called as (call &quot;function&apos;s memory address&quot;).Now come back to C If function has a memory address then they can be manipulated by Pointers in C.So By the rules of C \n\n1.First you need to declare a pointer to function \n2.Pass the Address of the  Desired function \n\n****Note-&gt;the functions should be of same type**** \n\nThis Simple Programme will Illustrate Every Thing.\n\n#include&lt;stdio.h&gt;\nvoid (*print)() ;//Declare a  Function Pointers\nvoid sayhello();//Declare The Function Whose Address is to be passed\n                //The Functions should Be of Same Type\nint main()\n{\n print=sayhello;//Addressof sayhello is assigned to print\n print();//print Does A call To The Function \n return 0;\n}\n\nvoid sayhello()\n{\n printf(&quot;\\n Hello World&quot;);\n}\n\n\nAfter That lets See How machine Understands Them.Glimpse of machine instruction of the above programme in 32 bit architecture.\n\nThe red mark area is showing how the address is being exchanged and storing in eax. Then their is a call instruction on eax. eax contains the desired address of the function.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"One of the big uses for function pointers in C is to call a function selected at run-time. For example, the C run-time library has two routines, qsort and bsearch, which take a pointer to a function that is called to compare two items being sorted; this allows you to sort or search, respectively, anything, based on any criteria you wish to use. \n\nA very basic example, if there is one function called print(int x, int y) which in turn may require to call a function (either add() or sub(), which are of the same type) then what we will do, we will add one function pointer argument to the print() function as shown below:\n\n#include &lt;stdio.h&gt;\n\nint add()\n{\n   return (100+10);\n}\n\nint sub()\n{\n   return (100-10);\n}\n\nvoid print(int x, int y, int (*func)())\n{\n    printf(&quot;value is: %d\\n&quot;, (x+y+(*func)()));\n}\n\nint main()\n{\n    int x=100, y=200;\n    print(x,y,add);\n    print(x,y,sub);\n\n    return 0;\n}\n\n\nThe output is:\n\n\n  value is: 410\n  value is: 390\n\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"A function pointer is a variable that contains the address of a function. Since it is a pointer variable though with some restricted properties, you can use it pretty much like you would any other pointer variable in data structures.\n\nThe only exception I can think of is treating the function pointer as pointing to something other than a single value. Doing pointer arithmetic by incrementing or decrementing a function pointer or adding/subtracting an offset to a function pointer isn&apos;t really of any utility as a function pointer only points to a single thing, the entry point of a function.\n\nThe size of a function pointer variable, the number of bytes occupied by the variable, may vary depending on the underlying architecture, e.g. x32 or x64 or whatever.\n\nThe declaration for a function pointer variable needs to specify the same kind of information as a function declaration in order for the C compiler to do the kinds of checks that it normally does. If you don&apos;t specify a parameter list in the declaration/definition of the function pointer, the C compiler will not be able to check the use of parameters. There are cases when this lack of checking can be useful however just remember that a safety net has been removed.\n\nSome examples:\n\nint func (int a, char *pStr);    // declares a function\n\nint (*pFunc)(int a, char *pStr);  // declares or defines a function pointer\n\nint (*pFunc2) ();                 // declares or defines a function pointer, no parameter list specified.\n\nint (*pFunc3) (void);             // declares or defines a function pointer, no arguments.\n\n\nThe first two declararations are somewhat similar in that:\n\n\nfunc is a function that takes an int and a char * and returns an int\npFunc is a function pointer to which is assigned the address of a function that takes an int and a char * and returns an int\n\n\nSo from the above we could have a source line in which the address of the function func() is assigned to the function pointer variable pFunc as in pFunc = func;.\n\nNotice the syntax used with a function pointer declaration/definition in which parenthesis are used to overcome the natural operator precedence rules.\n\nint *pfunc(int a, char *pStr);    // declares a function that returns int pointer\nint (*pFunc)(int a, char *pStr);  // declares a function pointer that returns an int\n\n\nSeveral Different Usage Examples\n\nSome examples of usage of a function pointer:\n\nint (*pFunc) (int a, char *pStr);    // declare a simple function pointer variable\nint (*pFunc[55])(int a, char *pStr); // declare an array of 55 function pointers\nint (**pFunc)(int a, char *pStr);    // declare a pointer to a function pointer variable\nstruct {                             // declare a struct that contains a function pointer\n    int x22;\n    int (*pFunc)(int a, char *pStr);\n} thing = {0, func};                 // assign values to the struct variable\nchar * xF (int x, int (*p)(int a, char *pStr));  // declare a function that has a function pointer as an argument\nchar * (*pxF) (int x, int (*p)(int a, char *pStr));  // declare a function pointer that points to a function that has a function pointer as an argument\n\n\nYou can use variable length parameter lists in the definition of a function pointer.\n\nint sum (int a, int b, ...);\nint (*psum)(int a, int b, ...);\n\n\nOr you can not specify a parameter list at all. This can be useful but it eliminates the opportunity for the C compiler to perform checks on the argument list provided. \n\nint  sum ();      // nothing specified in the argument list so could be anything or nothing\nint (*psum)();\nint  sum2(void);  // void specified in the argument list so no parameters when calling this function\nint (*psum2)(void);\n\n\nC style Casts\n\nYou can use C style casts with function pointers. However be aware that a C compiler may be lax about checks or provide warnings rather than errors.\n\nint sum (int a, char *b);\nint (*psplsum) (int a, int b);\npsplsum = sum;               // generates a compiler warning\npsplsum = (int (*)(int a, int b)) sum;   // no compiler warning, cast to function pointer\npsplsum = (int *(int a, int b)) sum;     // compiler error of bad cast generated, parenthesis are required.\n\n\nCompare Function Pointer to Equality\n\nYou can check that a function pointer is equal to a particular function address using an if statement though I am not sure how useful that would be. Other comparison operators would seem to have even less utility.\n\nstatic int func1(int a, int b) {\n    return a + b;\n}\n\nstatic int func2(int a, int b, char *c) {\n    return c[0] + a + b;\n}\n\nstatic int func3(int a, int b, char *x) {\n    return a + b;\n}\n\nstatic char *func4(int a, int b, char *c, int (*p)())\n{\n    if (p == func1) {\n        p(a, b);\n    }\n    else if (p == func2) {\n        p(a, b, c);      // warning C4047: &apos;==&apos;: &apos;int (__cdecl *)()&apos; differs in levels of indirection from &apos;char *(__cdecl *)(int,int,char *)&apos;\n    } else if (p == func3) {\n        p(a, b, c);\n    }\n    return c;\n}\n\n\nAn Array of Function Pointers\n\nAnd if you want to have an array of function pointers each of the elements of which the argument list has differences then you can define a function pointer with the argument list unspecified (not void which means no arguments but just unspecified) something like the following though you may see warnings from the C compiler. This also works for a function pointer parameter to a function:\n\nint(*p[])() = {       // an array of function pointers\n    func1, func2, func3\n};\nint(**pp)();          // a pointer to a function pointer\n\n\np[0](a, b);\np[1](a, b, 0);\np[2](a, b);      // oops, left off the last argument but it compiles anyway.\n\nfunc4(a, b, 0, func1);\nfunc4(a, b, 0, func2);  // warning C4047: &apos;function&apos;: &apos;int (__cdecl *)()&apos; differs in levels of indirection from &apos;char *(__cdecl *)(int,int,char *)&apos;\nfunc4(a, b, 0, func3);\n\n    // iterate over the array elements using an array index\nfor (i = 0; i &lt; sizeof(p) / sizeof(p[0]); i++) {\n    func4(a, b, 0, p[i]);\n}\n    // iterate over the array elements using a pointer\nfor (pp = p; pp &lt; p + sizeof(p)/sizeof(p[0]); pp++) {\n    (*pp)(a, b, 0);          // pointer to a function pointer so must dereference it.\n    func4(a, b, 0, *pp);     // pointer to a function pointer so must dereference it.\n}\n\n\nC style namespace Using Global struct with Function Pointers\n\nYou can use the static keyword to specify a function whose name is file scope and then assign this to a global variable as a way of providing something similar to the namespace functionality of C++.\n\nIn a header file define a struct that will be our namespace along with a global variable that uses it.\n\ntypedef struct {\n   int (*func1) (int a, int b);             // pointer to function that returns an int\n   char *(*func2) (int a, int b, char *c);  // pointer to function that returns a pointer\n} FuncThings;\n\nextern const FuncThings FuncThingsGlobal;\n\n\nThen in the C source file:\n\n#include &quot;header.h&quot;\n\n// the function names used with these static functions do not need to be the\n// same as the struct member names. It&apos;s just helpful if they are when trying\n// to search for them.\n// the static keyword ensures these names are file scope only and not visible\n// outside of the file.\nstatic int func1 (int a, int b)\n{\n    return a + b;\n}\n\nstatic char *func2 (int a, int b, char *c)\n{\n    c[0] = a % 100; c[1] = b % 50;\n    return c;\n}\n\nconst FuncThings FuncThingsGlobal = {func1, func2};\n\n\nThis would then be used by specifying the complete name of global struct variable and member name to access the function. The const modifier is used on the global so that it can not be changed by accident.\n\nint abcd = FuncThingsGlobal.func1 (a, b);\n\n\nApplication Areas of Function Pointers\n\nA DLL library component could do something similar to the C style namespace approach in which a particular library interface is requested from a factory method in a library interface which supports the creation of a struct containing function pointers.. This library interface loads the requested DLL version, creates a struct with the necessary function pointers, and then returns the struct to the requesting caller for use.\n\ntypedef struct {\n    HMODULE  hModule;\n    int (*Func1)();\n    int (*Func2)();\n    int(*Func3)(int a, int b);\n} LibraryFuncStruct;\n\nint  LoadLibraryFunc LPCTSTR  dllFileName, LibraryFuncStruct *pStruct)\n{\n    int  retStatus = 0;   // default is an error detected\n\n    pStruct-&gt;hModule = LoadLibrary (dllFileName);\n    if (pStruct-&gt;hModule) {\n        pStruct-&gt;Func1 = (int (*)()) GetProcAddress (pStruct-&gt;hModule, &quot;Func1&quot;);\n        pStruct-&gt;Func2 = (int (*)()) GetProcAddress (pStruct-&gt;hModule, &quot;Func2&quot;);\n        pStruct-&gt;Func3 = (int (*)(int a, int b)) GetProcAddress(pStruct-&gt;hModule, &quot;Func3&quot;);\n        retStatus = 1;\n    }\n\n    return retStatus;\n}\n\nvoid FreeLibraryFunc (LibraryFuncStruct *pStruct)\n{\n    if (pStruct-&gt;hModule) FreeLibrary (pStruct-&gt;hModule);\n    pStruct-&gt;hModule = 0;\n}\n\n\nand this could be used as in:\n\nLibraryFuncStruct myLib = {0};\nLoadLibraryFunc (L&quot;library.dll&quot;, &amp;myLib);\n//  ....\nmyLib.Func1();\n//  ....\nFreeLibraryFunc (&amp;myLib);\n\n\nThe same approach can be used to define an abstract hardware layer for code that uses a particular model of the underlying hardware. Function pointers are filled in with hardware specific functions by a factory to provide the hardware specific functionality that implements functions specified in the abstract hardware model. This can be used to provide an abstract hardware layer used by software which calls a factory function in order to get the specific hardware function interface then uses the function pointers provided to perform actions for the underlying hardware without needing to know implementation details about the specific target.\n\nFunction Pointers to create Delegates, Handlers, and Callbacks\n\nYou can use function pointers as a way to delegate some task or functionality. The classic example in C is the comparison delegate function pointer used with the Standard C library functions qsort() and bsearch() to provide the collation order for sorting a list of items or performing a binary search over a sorted list of items. The comparison function delegate specifies the collation algorithm used in the sort or the binary search.\n\nAnother use is similar to applying an algorithm to a C++ Standard Template Library container.\n\nvoid * ApplyAlgorithm (void *pArray, size_t sizeItem, size_t nItems, int (*p)(void *)) {\n    unsigned char *pList = pArray;\n    unsigned char *pListEnd = pList + nItems * sizeItem;\n    for ( ; pList &lt; pListEnd; pList += sizeItem) {\n        p (pList);\n    }\n\n    return pArray;\n}\n\nint pIncrement(int *pI) {\n    (*pI)++;\n\n    return 1;\n}\n\nvoid * ApplyFold(void *pArray, size_t sizeItem, size_t nItems, void * pResult, int(*p)(void *, void *)) {\n    unsigned char *pList = pArray;\n    unsigned char *pListEnd = pList + nItems * sizeItem;\n    for (; pList &lt; pListEnd; pList += sizeItem) {\n        p(pList, pResult);\n    }\n\n    return pArray;\n}\n\nint pSummation(int *pI, int *pSum) {\n    (*pSum) += *pI;\n\n    return 1;\n}\n\n// source code and then lets use our function.\nint intList[30] = { 0 }, iSum = 0;\n\nApplyAlgorithm(intList, sizeof(int), sizeof(intList) / sizeof(intList[0]), pIncrement);\nApplyFold(intList, sizeof(int), sizeof(intList) / sizeof(intList[0]), &amp;iSum, pSummation);\n\n\nAnother example is with GUI source code in which a handler for a particular event is registered by providing a function pointer which is actually called when the event happens. The Microsoft MFC framework with its message maps uses something similar to handle Windows messages that are delivered to a window or thread.\n\nAsynchronous functions that require a callback are similar to an event handler. The user of the asynchronous function calls the asynchronous function to start some action and provides a function pointer which the asynchronous function will call once the action is complete. In this case the event is the asynchronous function completing its task.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"Since function pointers are often typed callbacks, you might want to have a look at type safe callbacks. The same applies to entry points, etc of functions that are not callbacks.\n\nC is quite fickle and forgiving at the same time :)\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-12e9794e898cd5f3.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-928c5d1eb8fb0bba.js" defer=""></script><script src="/_next/static/BnkbnjkWYxefPXjTJLVVv/_buildManifest.js" defer=""></script><script src="/_next/static/BnkbnjkWYxefPXjTJLVVv/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/how-do-function-pointers-in-c-work-1657388332074#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/how-do-function-pointers-in-c-work-1657388332074"><h1>How do function pointers in C work?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/function-pointers">function-pointers</a></div></div><div class="question-content mt-5">
                
<p>I had some experience lately with function pointers in C.</p>

<p>So going on with the tradition of answering your own questions, I decided to make a small summary of the very basics, for those who need a quick dive-in to the subject.</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/function-pointers">function-pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>Function pointers in C</h1>

<p>Let's start with a basic function which we will be <em>pointing to</em>:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">addInt</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> {
    <span class="hljs-keyword">return</span> n+m;
}
</code></pre>

<p>First thing, let's define a pointer to a function which receives 2 <code>int</code>s and returns an <code>int</code>:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> (*functionPtr)(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>);
</code></pre>

<p>Now we can safely point to our function:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">functionPtr = &amp;addInt;
</code></pre>

<p>Now that we have a pointer to the function, let's use it:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> sum = (*functionPtr)(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// sum == 5</span>
</code></pre>

<p>Passing the pointer to another function is basically the same:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">add2to3</span><span class="hljs-params">(<span class="hljs-type">int</span> (*functionPtr)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>))</span> {
    <span class="hljs-keyword">return</span> (*functionPtr)(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
}
</code></pre>

<p>We can use function pointers in return values as well (try to keep up, it gets messy):</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-comment">// this is a function called functionFactory which receives parameter n</span>
<span class="hljs-comment">// and returns a pointer to another function which receives two ints</span>
<span class="hljs-comment">// and it returns another int</span>
<span class="hljs-type">int</span> (*functionFactory(<span class="hljs-type">int</span> n))(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got parameter %d"</span>, n);
    <span class="hljs-type">int</span> (*functionPtr)(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>) = &amp;addInt;
    <span class="hljs-keyword">return</span> functionPtr;
}
</code></pre>

<p>But it's much nicer to use a <code>typedef</code>:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*myFuncDef)</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;
<span class="hljs-comment">// note that the typedef name is indeed myFuncDef</span>

myFuncDef <span class="hljs-title function_">functionFactory</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got parameter %d"</span>, n);
    myFuncDef functionPtr = &amp;addInt;
    <span class="hljs-keyword">return</span> functionPtr;
}
</code></pre>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/function-pointers">function-pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Function pointers in C can be used to perform object-oriented programming in C.</strong></p>

<p>For example, the following lines is written in C:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">String s1 = newString();
s1-&gt;<span class="hljs-built_in">set</span>(s1, <span class="hljs-string">"hello"</span>);
</code></pre>

<p>Yes, the <code>-&gt;</code> and the lack of a <code>new</code> operator is a dead give away, but it sure seems to imply that we're setting the text of some <code>String</code> class to be <code>"hello"</code>.</p>

<p>By using function pointers, <strong>it is possible to emulate methods in C</strong>.</p>

<p>How is this accomplished?</p>

<p>The <code>String</code> class is actually a <code>struct</code> with a bunch of function pointers which act as a way to simulate methods. The following is a partial declaration of the <code>String</code> class:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">String_Struct</span>* <span class="hljs-title">String</span>;</span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">String_Struct</span>
{</span>
    <span class="hljs-type">char</span>* (*get)(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* self);
    <span class="hljs-type">void</span> (*<span class="hljs-built_in">set</span>)(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* self, <span class="hljs-type">char</span>* value);
    <span class="hljs-type">int</span> (*length)(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* self);
};

<span class="hljs-type">char</span>* <span class="hljs-title function_">getString</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* self)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">setString</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* self, <span class="hljs-type">char</span>* value)</span>;
<span class="hljs-type">int</span> <span class="hljs-title function_">lengthString</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* self)</span>;

String <span class="hljs-title function_">newString</span><span class="hljs-params">()</span>;
</code></pre>

<p>As can be seen, the methods of the <code>String</code> class are actually function pointers to the declared function. In preparing the instance of the <code>String</code>, the <code>newString</code> function is called in order to set up the function pointers to their respective functions:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">String <span class="hljs-title function_">newString</span><span class="hljs-params">()</span>
{
    String self = (String)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> String_Struct));

    self-&gt;get = &amp;getString;
    self-&gt;<span class="hljs-built_in">set</span> = &amp;setString;
    self-&gt;length = &amp;lengthString;

    self-&gt;<span class="hljs-built_in">set</span>(self, <span class="hljs-string">""</span>);

    <span class="hljs-keyword">return</span> self;
}
</code></pre>

<p>For example, the <code>getString</code> function that is called by invoking the <code>get</code> method is defined as the following:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span>* <span class="hljs-title function_">getString</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* self_obj)</span>
{
    <span class="hljs-keyword">return</span> ((String)self_obj)-&gt;internal-&gt;value;
}
</code></pre>

<p>One thing that can be noticed is that there is no concept of an instance of an object and having methods that are actually a part of an object, so a "self object" must be passed in on each invocation. (And the <code>internal</code> is just a hidden <code>struct</code> which was omitted from the code listing earlier -- it is a way of performing information hiding, but that is not relevant to function pointers.)</p>

<p>So, rather than being able to do <code>s1-&gt;set("hello");</code>, one must pass in the object to perform the action on <code>s1-&gt;set(s1, "hello")</code>. </p>

<p>With that minor explanation having to pass in a reference to yourself out of the way, we'll move to the next part, which is <strong>inheritance in C</strong>.</p>

<p>Let's say we want to make a subclass of <code>String</code>, say an <code>ImmutableString</code>. In order to make the string immutable, the <code>set</code> method will not be accessible, while maintaining access to <code>get</code> and <code>length</code>, and force the "constructor" to accept a <code>char*</code>:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ImmutableString_Struct</span>* <span class="hljs-title">ImmutableString</span>;</span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ImmutableString_Struct</span>
{</span>
    String base;

    <span class="hljs-type">char</span>* (*get)(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* self);
    <span class="hljs-type">int</span> (*length)(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* self);
};

ImmutableString <span class="hljs-title function_">newImmutableString</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* value)</span>;
</code></pre>

<p>Basically, for all subclasses, the available methods are once again function pointers. This time, the declaration for the <code>set</code> method is not present, therefore, it cannot be called in a <code>ImmutableString</code>.</p>

<p>As for the implementation of the <code>ImmutableString</code>, the only relevant code is the "constructor" function, the <code>newImmutableString</code>:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">ImmutableString <span class="hljs-title function_">newImmutableString</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* value)</span>
{
    ImmutableString self = (ImmutableString)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ImmutableString_Struct));

    self-&gt;base = newString();

    self-&gt;get = self-&gt;base-&gt;get;
    self-&gt;length = self-&gt;base-&gt;length;

    self-&gt;base-&gt;<span class="hljs-built_in">set</span>(self-&gt;base, (<span class="hljs-type">char</span>*)value);

    <span class="hljs-keyword">return</span> self;
}
</code></pre>

<p>In instantiating the <code>ImmutableString</code>, the function pointers to the <code>get</code> and <code>length</code> methods actually refer to the <code>String.get</code> and <code>String.length</code> method, by going through the <code>base</code> variable which is an internally stored <code>String</code> object.</p>

<p>The use of a function pointer can achieve inheritance of a method from a superclass.</p>

<p>We can further continue to <strong>polymorphism in C</strong>.</p>

<p>If for example we wanted to change the behavior of the <code>length</code> method to return <code>0</code> all the time in the <code>ImmutableString</code> class for some reason, all that would have to be done is to:</p>

<ol>
<li>Add a function that is going to serve as the overriding <code>length</code> method.</li>
<li>Go to the "constructor" and set the function pointer to the overriding <code>length</code> method.</li>
</ol>

<p>Adding an overriding <code>length</code> method in <code>ImmutableString</code> may be performed by adding an <code>lengthOverrideMethod</code>:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">lengthOverrideMethod</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* self)</span>
{
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>Then, the function pointer for the <code>length</code> method in the constructor is hooked up to the <code>lengthOverrideMethod</code>:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">ImmutableString <span class="hljs-title function_">newImmutableString</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* value)</span>
{
    ImmutableString self = (ImmutableString)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ImmutableString_Struct));

    self-&gt;base = newString();

    self-&gt;get = self-&gt;base-&gt;get;
    self-&gt;length = &amp;lengthOverrideMethod;

    self-&gt;base-&gt;<span class="hljs-built_in">set</span>(self-&gt;base, (<span class="hljs-type">char</span>*)value);

    <span class="hljs-keyword">return</span> self;
}
</code></pre>

<p>Now, rather than having an identical behavior for the <code>length</code> method in <code>ImmutableString</code> class as the <code>String</code> class, now the <code>length</code> method will refer to the behavior defined in the <code>lengthOverrideMethod</code> function.</p>

<p>I must add a disclaimer that I am still learning how to write with an object-oriented programming style in C, so there probably are points that I didn't explain well, or may just be off mark in terms of how best to implement OOP in C. But my purpose was to try to illustrate one of many uses of function pointers.</p>

<p>For more information on how to perform object-oriented programming in C, please refer to the following questions:</p>

<ul>
<li><a href="https://stackoverflow.com/questions/415452/object-orientation-in-c">Object-Orientation in C?</a></li>
<li><a href="https://stackoverflow.com/questions/351733/can-you-write-object-oriented-code-in-c">Can you write object oriented code in C?</a></li>
</ul>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/function-pointers">function-pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The guide to getting fired: How to abuse function pointers in GCC on x86 machines by compiling your code by hand:</p>

<p>These string literals are bytes of 32-bit x86 machine code.  <code>0xC3</code> is <a href="http://felixcloutier.com/x86/RET.html" rel="noreferrer">an x86 <code>ret</code> instruction</a>.</p>

<p>You wouldn't normally write these by hand, you'd write in assembly language and then use an assembler like <code>nasm</code> to assemble it into a flat binary which you hexdump into a C string literal.</p>

<ol>
<li><p>Returns the current value on the EAX register</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> eax = ((<span class="hljs-type">int</span>(*)())(<span class="hljs-string">"\xc3 &lt;- This returns the value of the EAX register"</span>))();
</code></pre></li>
<li><p>Write a swap function</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;
((<span class="hljs-type">void</span>(*)(<span class="hljs-type">int</span>*,<span class="hljs-type">int</span>*))<span class="hljs-string">"\x8b\x44\x24\x04\x8b\x5c\x24\x08\x8b\x00\x8b\x1b\x31\xc3\x31\xd8\x31\xc3\x8b\x4c\x24\x04\x89\x01\x8b\x4c\x24\x08\x89\x19\xc3 &lt;- This swaps the values of a and b"</span>)(&amp;a,&amp;b);
</code></pre></li>
<li><p>Write a for-loop counter to 1000, calling some function each time</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">((<span class="hljs-type">int</span>(*)())<span class="hljs-string">"\x66\x31\xc0\x8b\x5c\x24\x04\x66\x40\x50\xff\xd3\x58\x66\x3d\xe8\x03\x75\xf4\xc3"</span>)(&amp;function); <span class="hljs-comment">// calls function with 1-&gt;1000</span>
</code></pre></li>
<li><p>You can even write a recursive function that counts to 100</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* lol = <span class="hljs-string">"\x8b\x5c\x24\x4\x3d\xe8\x3\x0\x0\x7e\x2\x31\xc0\x83\xf8\x64\x7d\x6\x40\x53\xff\xd3\x5b\xc3\xc3 &lt;- Recursively calls the function at address lol."</span>;
i = ((<span class="hljs-type">int</span>(*)())(lol))(lol);
</code></pre></li>
</ol>

<p>Note that compilers place string literals in the <code>.rodata</code> section (or <code>.rdata</code> on Windows), which is linked as part of the text segment (along with code for functions).</p>

<p>The text segment has Read+Exec permission, so casting string literals to function pointers works without needing <code>mprotect()</code> or <code>VirtualProtect()</code> system calls like you'd need for dynamically allocated memory.  (Or <code>gcc -z execstack</code> links the program with stack + data segment + heap executable, as a quick hack.)</p>

<hr>

<p>To disassemble these, you can compile this to put a label on the bytes, and use a disassembler.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-comment">// at global scope</span>
<span class="hljs-type">const</span> <span class="hljs-type">char</span> swap[] = <span class="hljs-string">"\x8b\x44\x24\x04\x8b\x5c\x24\x08\x8b\x00\x8b\x1b\x31\xc3\x31\xd8\x31\xc3\x8b\x4c\x24\x04\x89\x01\x8b\x4c\x24\x08\x89\x19\xc3 &lt;- This swaps the values of a and b"</span>;
</code></pre>

<p>Compiling with <code>gcc -c -m32 foo.c</code> and disassembling with <code>objdump -D -rwC -Mintel</code>, we can get the assembly, and find out that this code violates the ABI by clobbering EBX (a call-preserved register) and is generally inefficient.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-number">00000000</span> &lt;swap&gt;:
   <span class="hljs-number">0</span>:   <span class="hljs-number">8b</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">04</span>             mov    eax,DWORD PTR [esp+<span class="hljs-number">0x4</span>]   <span class="hljs-meta"># load int *a arg from the stack</span>
   <span class="hljs-number">4</span>:   <span class="hljs-number">8b</span> <span class="hljs-number">5</span>c <span class="hljs-number">24</span> <span class="hljs-number">08</span>             mov    ebx,DWORD PTR [esp+<span class="hljs-number">0x8</span>]   <span class="hljs-meta"># ebx = b</span>
   <span class="hljs-number">8</span>:   <span class="hljs-number">8b</span> <span class="hljs-number">00</span>                   mov    eax,DWORD PTR [eax]       <span class="hljs-meta"># dereference: eax = *a</span>
   a:   <span class="hljs-number">8b</span> <span class="hljs-number">1b</span>                   mov    ebx,DWORD PTR [ebx]
   c:   <span class="hljs-number">31</span> c3                   xor    ebx,eax                <span class="hljs-meta"># pointless xor-swap</span>
   e:   <span class="hljs-number">31</span> d8                   xor    eax,ebx                <span class="hljs-meta"># instead of just storing with opposite registers</span>
  <span class="hljs-number">10</span>:   <span class="hljs-number">31</span> c3                   xor    ebx,eax
  <span class="hljs-number">12</span>:   <span class="hljs-number">8b</span> <span class="hljs-number">4</span>c <span class="hljs-number">24</span> <span class="hljs-number">04</span>             mov    ecx,DWORD PTR [esp+<span class="hljs-number">0x4</span>]  <span class="hljs-meta"># reload a from the stack</span>
  <span class="hljs-number">16</span>:   <span class="hljs-number">89</span> <span class="hljs-number">01</span>                   mov    DWORD PTR [ecx],eax     <span class="hljs-meta"># store to *a</span>
  <span class="hljs-number">18</span>:   <span class="hljs-number">8b</span> <span class="hljs-number">4</span>c <span class="hljs-number">24</span> <span class="hljs-number">08</span>             mov    ecx,DWORD PTR [esp+<span class="hljs-number">0x8</span>]
  <span class="hljs-number">1</span>c:   <span class="hljs-number">89</span> <span class="hljs-number">19</span>                   mov    DWORD PTR [ecx],ebx
  <span class="hljs-number">1</span>e:   c3                      ret    

  not shown: the later bytes are ASCII text documentation
  they<span class="hljs-number">'</span>re not executed by the CPU because the ret instruction sends execution back to the caller
</code></pre>

<p>This machine code will (probably) work in 32-bit code on Windows, Linux, OS X, and so on: the default calling conventions on all those OSes pass args on the stack instead of more efficiently in registers.  But EBX is call-preserved in all the normal calling conventions, so using it as a scratch register without saving/restoring it can easily make the caller crash.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/function-pointers">function-pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>One of my favorite uses for function pointers is as cheap and easy iterators - </p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_COLORS  256</span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
    <span class="hljs-type">char</span>* name;
    <span class="hljs-type">int</span> red;
    <span class="hljs-type">int</span> green;
    <span class="hljs-type">int</span> blue;
} Color;

Color Colors[MAX_COLORS];


<span class="hljs-type">void</span> <span class="hljs-title function_">eachColor</span> <span class="hljs-params">(<span class="hljs-type">void</span> (*fp)(Color *c))</span> {
    <span class="hljs-type">int</span> i;
    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;MAX_COLORS; i++)
        (*fp)(&amp;Colors[i]);
}

<span class="hljs-type">void</span> <span class="hljs-title function_">printColor</span><span class="hljs-params">(Color* c)</span> {
    <span class="hljs-keyword">if</span> (c-&gt;name)
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s = %i,%i,%i\n"</span>, c-&gt;name, c-&gt;red, c-&gt;green, c-&gt;blue);
}

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    Colors[<span class="hljs-number">0</span>].name=<span class="hljs-string">"red"</span>;
    Colors[<span class="hljs-number">0</span>].red=<span class="hljs-number">255</span>;
    Colors[<span class="hljs-number">1</span>].name=<span class="hljs-string">"blue"</span>;
    Colors[<span class="hljs-number">1</span>].blue=<span class="hljs-number">255</span>;
    Colors[<span class="hljs-number">2</span>].name=<span class="hljs-string">"black"</span>;

    eachColor(printColor);
}
</code></pre>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/function-pointers">function-pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Function pointers become easy to declare once you have the basic declarators:</p>

<ul>
<li>id: <code>ID</code>: <em>ID is a</em></li>
<li>Pointer: <code>*D</code>: <em>D pointer to</em></li>
<li>Function: <code>D(&lt;parameters&gt;)</code>: <em>D function taking <code>&lt;</code>parameters<code>&gt;</code> returning</em></li>
</ul>

<p>While D is another declarator built using those same rules. In the end, somewhere, it ends with <code>ID</code> (see below for an example), which is the name of the declared entity. Let's try to build a function taking a pointer to a function taking nothing and returning int, and returning a pointer to a function taking a char and returning int. With type-defs it's like this</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ReturnFunction</span><span class="hljs-params">(<span class="hljs-type">char</span>)</span>;
<span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ParameterFunction</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;
ReturnFunction *<span class="hljs-title function_">f</span><span class="hljs-params">(ParameterFunction *p)</span>;
</code></pre>

<p>As you see, it's pretty easy to build it up using typedefs. Without typedefs, it's not hard either with the above declarator rules, applied consistently. As you see i missed out the part the pointer points to, and the thing the function returns. That's what appears at the very left of the declaration, and is not of interest: It's added at the end if one built up the declarator already. Let's do that. Building it up consistently, first wordy - showing the structure using <code>[</code> and <code>]</code>:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">function taking 
    [pointer to [function taking [<span class="hljs-type">void</span>] returning [<span class="hljs-type">int</span>]]] 
returning
    [pointer to [function taking [<span class="hljs-type">char</span>] returning [<span class="hljs-type">int</span>]]]
</code></pre>

<p>As you see, one can describe a type completely by appending declarators one after each other. Construction can be done in two ways. One is bottom-up, starting with the very right thing (leaves) and working the way through up to the identifier. The other way is top-down, starting at the identifier, working the way down to the leaves. I'll show both ways.</p>

<h2>Bottom Up</h2>

<p>Construction starts with the thing at the right: The thing returned, which is the function taking char. To keep the declarators distinct, i'm going to number them:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">D1(<span class="hljs-type">char</span>);
</code></pre>

<p>Inserted the char parameter directly, since it's trivial. Adding a pointer to declarator by replacing <code>D1</code> by <code>*D2</code>. Note that we have to wrap parentheses around <code>*D2</code>. That can be known by looking up the precedence of the <code>*-operator</code> and the function-call operator <code>()</code>. Without our parentheses, the compiler would read it as <code>*(D2(char p))</code>. But that would not be a plain replace of D1 by <code>*D2</code> anymore, of course. Parentheses are always allowed around declarators. So you don't make anything wrong if you add too much of them, actually.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">(*D2)(<span class="hljs-type">char</span>);
</code></pre>

<p>Return type is complete! Now, let's replace <code>D2</code> by the function declarator <em>function taking <code>&lt;parameters&gt;</code> returning</em>, which is <code>D3(&lt;parameters&gt;)</code> which we are at now. </p>

<pre class="lang-c s-code-block"><code class="hljs language-c">(*D3(&lt;parameters&gt;))(<span class="hljs-type">char</span>)
</code></pre>

<p>Note that no parentheses are needed, since we <em>want</em> <code>D3</code> to be a function-declarator and not a pointer declarator this time. Great, only thing left is the parameters for it. The parameter is done exactly the same as we've done the return type, just with <code>char</code> replaced by <code>void</code>. So i'll copy it:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">(*D3(   (*ID1)(<span class="hljs-type">void</span>)))(<span class="hljs-type">char</span>)
</code></pre>

<p>I've replaced <code>D2</code> by <code>ID1</code>, since we are finished with that parameter (it's already a pointer to a function - no need for another declarator). <code>ID1</code> will be the name of the parameter. Now, i told above at the end one adds the type which all those declarator modify - the one appearing at the very left of every declaration. For functions, that becomes the return type. For pointers the pointed to type etc... It's interesting when written down the type, it will appear in the opposite order, at the very right :) Anyway, substituting it yields the complete declaration. Both times <code>int</code> of course. </p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> (*ID0(<span class="hljs-type">int</span> (*ID1)(<span class="hljs-type">void</span>)))(<span class="hljs-type">char</span>)
</code></pre>

<p>I've called the identifier of the function <code>ID0</code> in that example. </p>

<h2>Top Down</h2>

<p>This starts at the identifier at the very left in the description of the type, wrapping that declarator as we walk our way through the right. Start with <em>function taking <code>&lt;</code>parameters<code>&gt;</code> returning</em></p>

<pre class="lang-c s-code-block"><code class="hljs language-c">ID0(&lt;parameters&gt;)
</code></pre>

<p>The next thing in the description (after "returning") was <em>pointer to</em>. Let's incorporate it:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">*ID0(&lt;parameters&gt;)
</code></pre>

<p>Then the next thing was <em>functon taking <code>&lt;</code>parameters<code>&gt;</code> returning</em>. The parameter is a simple char, so we put it in right away again, since it's really trivial.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">(*ID0(&lt;parameters&gt;))(<span class="hljs-type">char</span>)
</code></pre>

<p>Note the parentheses we added, since we again want that the <code>*</code> binds first, and <em>then</em> the <code>(char)</code>. Otherwise it would read <em>function taking <code>&lt;</code>parameters<code>&gt;</code> returning function ...</em>. Noes, functions returning functions aren't even allowed. </p>

<p>Now we just need to put <code>&lt;</code>parameters<code>&gt;</code>. I will show a short version of the deriveration, since i think you already by now have the idea how to do it.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">pointer to: *ID1
... function taking <span class="hljs-type">void</span> returning: (*ID1)(<span class="hljs-type">void</span>)
</code></pre>

<p>Just put <code>int</code> before the declarators like we did with bottom-up, and we are finished</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> (*ID0(<span class="hljs-type">int</span> (*ID1)(<span class="hljs-type">void</span>)))(<span class="hljs-type">char</span>)
</code></pre>

<h2>The nice thing</h2>

<p>Is bottom-up or top-down better? I'm used to bottom-up, but some people may be more comfortable with top-down. It's a matter of taste i think. Incidentally, if you apply all the operators in that declaration, you will end up getting an int:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> v = (*ID0(some_function_pointer))(some_char);
</code></pre>

<p>That is a nice property of declarations in C: The declaration asserts that if those operators are used in an expression using the identifier, then it yields the type on the very left. It's like that for arrays too. </p>

<p>Hope you liked this little tutorial! Now we can link to this when people wonder about the strange declaration syntax of functions. I tried to put as little C internals as possible. Feel free to edit/fix things in it. </p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/function-pointers">function-pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2>Another good use for function pointers:<br>Switching between versions painlessly</h2>

<p>They're very handy to use for when you want different functions at different times, or different phases of development. For instance, I'm developing an application on a host computer that has a console, but the final release of the software will be put on an Avnet ZedBoard (which has ports for displays and consoles, but they are not needed/wanted for the final release). So during development, I will use <code>printf</code> to view status and error messages, but when I'm done, I don't want anything printed. Here's what I've done:</p>

<h1>version.h</h1>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-comment">// First, undefine all macros associated with version.h</span>
<span class="hljs-meta">#<span class="hljs-keyword">undef</span> DEBUG_VERSION</span>
<span class="hljs-meta">#<span class="hljs-keyword">undef</span> RELEASE_VERSION</span>
<span class="hljs-meta">#<span class="hljs-keyword">undef</span> INVALID_VERSION</span>


<span class="hljs-comment">// Define which version we want to use</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG_VERSION       <span class="hljs-comment">// The current version</span></span>
<span class="hljs-comment">// #define RELEASE_VERSION  // To be uncommented when finished debugging</span>

<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __VERSION_H_      <span class="hljs-comment">/* prevent circular inclusions */</span></span>
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> __VERSION_H_  <span class="hljs-comment">/* by using protection macros */</span></span>
    <span class="hljs-type">void</span> <span class="hljs-title function_">board_init</span><span class="hljs-params">()</span>;
    <span class="hljs-type">void</span> <span class="hljs-title function_">noprintf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *c, ...)</span>; <span class="hljs-comment">// mimic the printf prototype</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

<span class="hljs-comment">// Mimics the printf function prototype. This is what I'll actually </span>
<span class="hljs-comment">// use to print stuff to the screen</span>
<span class="hljs-type">void</span> (* zprintf)(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, ...); 

<span class="hljs-comment">// If debug version, use printf</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEBUG_VERSION</span>
    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

<span class="hljs-comment">// If both debug and release version, error</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEBUG_VERSION</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> RELEASE_VERSION</span>
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> INVALID_VERSION</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

<span class="hljs-comment">// If neither debug or release version, error</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DEBUG_VERSION</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> RELEASE_VERSION</span>
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> INVALID_VERSION</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> INVALID_VERSION</span>
    <span class="hljs-comment">// Won't allow compilation without a valid version define</span>
    <span class="hljs-meta">#<span class="hljs-keyword">error</span> <span class="hljs-string">"Invalid version definition"</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>

<p>In <code>version.c</code> I will define the 2 function prototypes present in <code>version.h</code></p>

<h1>version.c</h1>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"version.h"</span></span>

<span class="hljs-comment">/*****************************************************************************/</span>
<span class="hljs-comment">/**
* @name board_init
*
* Sets up the application based on the version type defined in version.h.
* Includes allowing or prohibiting printing to STDOUT.
*
* MUST BE CALLED FIRST THING IN MAIN
*
* @return    None
*
*****************************************************************************/</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">board_init</span><span class="hljs-params">()</span>
{
    <span class="hljs-comment">// Assign the print function to the correct function pointer</span>
    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEBUG_VERSION</span>
        zprintf = &amp;<span class="hljs-built_in">printf</span>;
    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
        <span class="hljs-comment">// Defined below this function</span>
        zprintf = &amp;noprintf;
    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
}

<span class="hljs-comment">/*****************************************************************************/</span>
<span class="hljs-comment">/**
* @name noprintf
*
* simply returns with no actions performed
*
* @return   None
*
*****************************************************************************/</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">noprintf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* c, ...)</span>
{
    <span class="hljs-keyword">return</span>;
}
</code></pre>

<p></p><p>Notice how the function pointer is prototyped in <code>version.h</code> as </p><p><code>void (* zprintf)(const char *, ...);</code></p><p>When it is referenced in the application, it will start executing wherever it is pointing, which has yet to be defined.</p>
<p>In <code>version.c</code>, notice in the <code>board_init()</code>function where <code>zprintf</code> is assigned a unique function (whose function signature matches) depending on the version that is defined in <code>version.h</code></p><p><code>zprintf = &amp;printf;</code> zprintf calls printf for debugging purposes</p><p>or</p><p><code>zprintf = &amp;noprint;</code> zprintf just returns and will not run unnecessary code</p><p></p>

<p>Running the code will look like this:</p>

<h1>mainProg.c</h1>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"version.h"</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>
{
    <span class="hljs-comment">// Must run board_init(), which assigns the function</span>
    <span class="hljs-comment">// pointer to an actual function</span>
    board_init();

    <span class="hljs-type">void</span> *ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">// Allocate 100 bytes of memory</span>
    <span class="hljs-comment">// malloc returns NULL if unable to allocate the memory.</span>

    <span class="hljs-keyword">if</span> (ptr == <span class="hljs-literal">NULL</span>)
    {
        zprintf(<span class="hljs-string">"Unable to allocate memory\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }

    <span class="hljs-comment">// Other things to do...</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>The above code will use <code>printf</code> if in debug mode, or do nothing if in release mode. This is much easier than going through the entire project and commenting out or deleting code. All that I need to do is change the version in <code>version.h</code> and the code will do the rest!</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/function-pointers">function-pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Function pointer is usually defined by <code>typedef</code>, and used as param &amp; return value.</p>

<p>Above answers already explained a lot, I just give a full example:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM_A 1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM_B 2</span>

<span class="hljs-comment">// define a function pointer type</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*two_num_operation)</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;

<span class="hljs-comment">// an actual standalone function</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
    <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-comment">// use function pointer as param,</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum_via_pointer</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, two_num_operation funp)</span> {
    <span class="hljs-keyword">return</span> (*funp)(a, b);
}

<span class="hljs-comment">// use function pointer as return value,</span>
<span class="hljs-type">static</span> two_num_operation <span class="hljs-title function_">get_sum_fun</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> &amp;sum;
}

<span class="hljs-comment">// test - use function pointer as variable,</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">test_pointer_as_variable</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// create a pointer to function,</span>
    two_num_operation sum_p = &amp;sum;
    <span class="hljs-comment">// call function via pointer</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"pointer as variable:\t %d + %d = %d\n"</span>, NUM_A, NUM_B, (*sum_p)(NUM_A, NUM_B));
}

<span class="hljs-comment">// test - use function pointer as param,</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">test_pointer_as_param</span><span class="hljs-params">()</span> {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"pointer as param:\t %d + %d = %d\n"</span>, NUM_A, NUM_B, sum_via_pointer(NUM_A, NUM_B, &amp;sum));
}

<span class="hljs-comment">// test - use function pointer as return value,</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">test_pointer_as_return_value</span><span class="hljs-params">()</span> {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"pointer as return value:\t %d + %d = %d\n"</span>, NUM_A, NUM_B, (*get_sum_fun())(NUM_A, NUM_B));
}

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    test_pointer_as_variable();
    test_pointer_as_param();
    test_pointer_as_return_value();

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/function-pointers">function-pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Starting from scratch function has Some Memory Address From Where They start executing. In Assembly Language They Are called as (call "function's memory address").Now come back to C If function has a memory address then they can be manipulated by Pointers in C.So By the rules of C </p>

<p>1.First you need to declare a pointer to function 
2.Pass the Address of the  Desired function </p>

<p>****Note-&gt;the functions should be of same type**** </p>

<p>This Simple Programme will Illustrate Every Thing.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-type">void</span> (*print)() ;<span class="hljs-comment">//Declare a  Function Pointers</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">sayhello</span><span class="hljs-params">()</span>;<span class="hljs-comment">//Declare The Function Whose Address is to be passed</span>
                <span class="hljs-comment">//The Functions should Be of Same Type</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>
{
 print=sayhello;<span class="hljs-comment">//Addressof sayhello is assigned to print</span>
 print();<span class="hljs-comment">//print Does A call To The Function </span>
 <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-type">void</span> <span class="hljs-title function_">sayhello</span><span class="hljs-params">()</span>
{
 <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n Hello World"</span>);
}
</code></pre>

<p><img src="https://i.stack.imgur.com/L4qpJ.png" alt="enter image description here">After That lets See How machine Understands Them.Glimpse of machine instruction of the above programme in 32 bit architecture.</p>

<p>The red mark area is showing how the address is being exchanged and storing in eax. Then their is a call instruction on eax. eax contains the desired address of the function.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/function-pointers">function-pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>One of the big uses for function pointers in C is to call a function selected at run-time. For example, the C run-time library has two routines, <a href="https://en.cppreference.com/w/c/algorithm/qsort" rel="noreferrer"><code>qsort</code></a> and <a href="https://en.cppreference.com/w/c/algorithm/bsearch" rel="noreferrer"><code>bsearch</code></a>, which take a pointer to a function that is called to compare two items being sorted; this allows you to sort or search, respectively, anything, based on any criteria you wish to use. </p>

<p>A very basic example, if there is one function called <code>print(int x, int y)</code> which in turn may require to call a function (either <code>add()</code> or <code>sub()</code>, which are of the same type) then what we will do, we will add one function pointer argument to the <code>print()</code> function as shown below:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>
{
   <span class="hljs-keyword">return</span> (<span class="hljs-number">100</span>+<span class="hljs-number">10</span>);
}

<span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">()</span>
{
   <span class="hljs-keyword">return</span> (<span class="hljs-number">100</span><span class="hljs-number">-10</span>);
}

<span class="hljs-type">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> (*func)())</span>
{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"value is: %d\n"</span>, (x+y+(*func)()));
}

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>
{
    <span class="hljs-type">int</span> x=<span class="hljs-number">100</span>, y=<span class="hljs-number">200</span>;
    print(x,y,add);
    print(x,y,sub);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>The output is:</p>

<blockquote>
  <p>value is: 410<br>
  value is: 390</p>
</blockquote>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/function-pointers">function-pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A function pointer is a variable that contains the address of a function. Since it is a pointer variable though with some restricted properties, you can use it pretty much like you would any other pointer variable in data structures.</p>

<p>The only exception I can think of is treating the function pointer as pointing to something other than a single value. Doing pointer arithmetic by incrementing or decrementing a function pointer or adding/subtracting an offset to a function pointer isn't really of any utility as a function pointer only points to a single thing, the entry point of a function.</p>

<p>The size of a function pointer variable, the number of bytes occupied by the variable, may vary depending on the underlying architecture, e.g. x32 or x64 or whatever.</p>

<p>The declaration for a function pointer variable needs to specify the same kind of information as a function declaration in order for the C compiler to do the kinds of checks that it normally does. If you don't specify a parameter list in the declaration/definition of the function pointer, the C compiler will not be able to check the use of parameters. There are cases when this lack of checking can be useful however just remember that a safety net has been removed.</p>

<p>Some examples:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">func</span> <span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">char</span> *pStr)</span>;    <span class="hljs-comment">// declares a function</span>

<span class="hljs-type">int</span> (*pFunc)(<span class="hljs-type">int</span> a, <span class="hljs-type">char</span> *pStr);  <span class="hljs-comment">// declares or defines a function pointer</span>

<span class="hljs-type">int</span> (*pFunc2) ();                 <span class="hljs-comment">// declares or defines a function pointer, no parameter list specified.</span>

<span class="hljs-type">int</span> (*pFunc3) (<span class="hljs-type">void</span>);             <span class="hljs-comment">// declares or defines a function pointer, no arguments.</span>
</code></pre>

<p>The first two declararations are somewhat similar in that:</p>

<ul>
<li><code>func</code> is a function that takes an <code>int</code> and a <code>char *</code> and returns an <code>int</code></li>
<li><code>pFunc</code> is a function pointer to which is assigned the address of a function that takes an <code>int</code> and a <code>char *</code> and returns an <code>int</code></li>
</ul>

<p>So from the above we could have a source line in which the address of the function <code>func()</code> is assigned to the function pointer variable <code>pFunc</code> as in <code>pFunc = func;</code>.</p>

<p>Notice the syntax used with a function pointer declaration/definition in which parenthesis are used to overcome the natural operator precedence rules.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> *<span class="hljs-title function_">pfunc</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">char</span> *pStr)</span>;    <span class="hljs-comment">// declares a function that returns int pointer</span>
<span class="hljs-type">int</span> (*pFunc)(<span class="hljs-type">int</span> a, <span class="hljs-type">char</span> *pStr);  <span class="hljs-comment">// declares a function pointer that returns an int</span>
</code></pre>

<p><strong>Several Different Usage Examples</strong></p>

<p>Some examples of usage of a function pointer:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> (*pFunc) (<span class="hljs-type">int</span> a, <span class="hljs-type">char</span> *pStr);    <span class="hljs-comment">// declare a simple function pointer variable</span>
<span class="hljs-type">int</span> (*pFunc[<span class="hljs-number">55</span>])(<span class="hljs-type">int</span> a, <span class="hljs-type">char</span> *pStr); <span class="hljs-comment">// declare an array of 55 function pointers</span>
<span class="hljs-type">int</span> (**pFunc)(<span class="hljs-type">int</span> a, <span class="hljs-type">char</span> *pStr);    <span class="hljs-comment">// declare a pointer to a function pointer variable</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>                             <span class="hljs-comment">// declare a struct that contains a function pointer</span>
    <span class="hljs-type">int</span> x22;
    <span class="hljs-type">int</span> (*pFunc)(<span class="hljs-type">int</span> a, <span class="hljs-type">char</span> *pStr);
} thing = {<span class="hljs-number">0</span>, func};                 <span class="hljs-comment">// assign values to the struct variable</span>
<span class="hljs-type">char</span> * <span class="hljs-title function_">xF</span> <span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> (*p)(<span class="hljs-type">int</span> a, <span class="hljs-type">char</span> *pStr))</span>;  <span class="hljs-comment">// declare a function that has a function pointer as an argument</span>
<span class="hljs-type">char</span> * (*pxF) (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> (*p)(<span class="hljs-type">int</span> a, <span class="hljs-type">char</span> *pStr));  <span class="hljs-comment">// declare a function pointer that points to a function that has a function pointer as an argument</span>
</code></pre>

<p>You can use variable length parameter lists in the definition of a function pointer.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span> <span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, ...)</span>;
<span class="hljs-type">int</span> (*psum)(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, ...);
</code></pre>

<p>Or you can not specify a parameter list at all. This can be useful but it eliminates the opportunity for the C compiler to perform checks on the argument list provided. </p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span>  <span class="hljs-title function_">sum</span> <span class="hljs-params">()</span>;      <span class="hljs-comment">// nothing specified in the argument list so could be anything or nothing</span>
<span class="hljs-type">int</span> (*psum)();
<span class="hljs-type">int</span>  <span class="hljs-title function_">sum2</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;  <span class="hljs-comment">// void specified in the argument list so no parameters when calling this function</span>
<span class="hljs-type">int</span> (*psum2)(<span class="hljs-type">void</span>);
</code></pre>

<p><strong>C style Casts</strong></p>

<p>You can use C style casts with function pointers. However be aware that a C compiler may be lax about checks or provide warnings rather than errors.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span> <span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">char</span> *b)</span>;
<span class="hljs-type">int</span> (*psplsum) (<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b);
psplsum = sum;               <span class="hljs-comment">// generates a compiler warning</span>
psplsum = (<span class="hljs-type">int</span> (*)(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)) sum;   <span class="hljs-comment">// no compiler warning, cast to function pointer</span>
psplsum = (<span class="hljs-type">int</span> *(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)) sum;     <span class="hljs-comment">// compiler error of bad cast generated, parenthesis are required.</span>
</code></pre>

<p><strong>Compare Function Pointer to Equality</strong></p>

<p>You can check that a function pointer is equal to a particular function address using an <code>if</code> statement though I am not sure how useful that would be. Other comparison operators would seem to have even less utility.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">func1</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
    <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">char</span> *c)</span> {
    <span class="hljs-keyword">return</span> c[<span class="hljs-number">0</span>] + a + b;
}

<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">func3</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">char</span> *x)</span> {
    <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-type">static</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">func4</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">char</span> *c, <span class="hljs-type">int</span> (*p)())</span>
{
    <span class="hljs-keyword">if</span> (p == func1) {
        p(a, b);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == func2) {
        p(a, b, c);      <span class="hljs-comment">// warning C4047: '==': 'int (__cdecl *)()' differs in levels of indirection from 'char *(__cdecl *)(int,int,char *)'</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == func3) {
        p(a, b, c);
    }
    <span class="hljs-keyword">return</span> c;
}
</code></pre>

<p><strong>An Array of Function Pointers</strong></p>

<p>And if you want to have an array of function pointers each of the elements of which the argument list has differences then you can define a function pointer with the argument list unspecified (not <code>void</code> which means no arguments but just unspecified) something like the following though you may see warnings from the C compiler. This also works for a function pointer parameter to a function:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span>(*p[])() = {       <span class="hljs-comment">// an array of function pointers</span>
    func1, func2, func3
};
<span class="hljs-type">int</span>(**pp)();          <span class="hljs-comment">// a pointer to a function pointer</span>


p[<span class="hljs-number">0</span>](a, b);
p[<span class="hljs-number">1</span>](a, b, <span class="hljs-number">0</span>);
p[<span class="hljs-number">2</span>](a, b);      <span class="hljs-comment">// oops, left off the last argument but it compiles anyway.</span>

func4(a, b, <span class="hljs-number">0</span>, func1);
func4(a, b, <span class="hljs-number">0</span>, func2);  <span class="hljs-comment">// warning C4047: 'function': 'int (__cdecl *)()' differs in levels of indirection from 'char *(__cdecl *)(int,int,char *)'</span>
func4(a, b, <span class="hljs-number">0</span>, func3);

    <span class="hljs-comment">// iterate over the array elements using an array index</span>
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(p) / <span class="hljs-keyword">sizeof</span>(p[<span class="hljs-number">0</span>]); i++) {
    func4(a, b, <span class="hljs-number">0</span>, p[i]);
}
    <span class="hljs-comment">// iterate over the array elements using a pointer</span>
<span class="hljs-keyword">for</span> (pp = p; pp &lt; p + <span class="hljs-keyword">sizeof</span>(p)/<span class="hljs-keyword">sizeof</span>(p[<span class="hljs-number">0</span>]); pp++) {
    (*pp)(a, b, <span class="hljs-number">0</span>);          <span class="hljs-comment">// pointer to a function pointer so must dereference it.</span>
    func4(a, b, <span class="hljs-number">0</span>, *pp);     <span class="hljs-comment">// pointer to a function pointer so must dereference it.</span>
}
</code></pre>

<p><strong>C style <code>namespace</code> Using Global <code>struct</code> with Function Pointers</strong></p>

<p>You can use the <code>static</code> keyword to specify a function whose name is file scope and then assign this to a global variable as a way of providing something similar to the <code>namespace</code> functionality of C++.</p>

<p>In a header file define a struct that will be our namespace along with a global variable that uses it.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
   <span class="hljs-type">int</span> (*func1) (<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b);             <span class="hljs-comment">// pointer to function that returns an int</span>
   <span class="hljs-type">char</span> *(*func2) (<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">char</span> *c);  <span class="hljs-comment">// pointer to function that returns a pointer</span>
} FuncThings;

<span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> FuncThings FuncThingsGlobal;
</code></pre>

<p>Then in the C source file:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"header.h"</span></span>

<span class="hljs-comment">// the function names used with these static functions do not need to be the</span>
<span class="hljs-comment">// same as the struct member names. It's just helpful if they are when trying</span>
<span class="hljs-comment">// to search for them.</span>
<span class="hljs-comment">// the static keyword ensures these names are file scope only and not visible</span>
<span class="hljs-comment">// outside of the file.</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">func1</span> <span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>
{
    <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-type">static</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">func2</span> <span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">char</span> *c)</span>
{
    c[<span class="hljs-number">0</span>] = a % <span class="hljs-number">100</span>; c[<span class="hljs-number">1</span>] = b % <span class="hljs-number">50</span>;
    <span class="hljs-keyword">return</span> c;
}

<span class="hljs-type">const</span> FuncThings FuncThingsGlobal = {func1, func2};
</code></pre>

<p>This would then be used by specifying the complete name of global struct variable and member name to access the function. The <code>const</code> modifier is used on the global so that it can not be changed by accident.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> abcd = FuncThingsGlobal.func1 (a, b);
</code></pre>

<p><strong>Application Areas of Function Pointers</strong></p>

<p>A DLL library component could do something similar to the C style <code>namespace</code> approach in which a particular library interface is requested from a factory method in a library interface which supports the creation of a <code>struct</code> containing function pointers.. This library interface loads the requested DLL version, creates a struct with the necessary function pointers, and then returns the struct to the requesting caller for use.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
    HMODULE  hModule;
    <span class="hljs-type">int</span> (*Func1)();
    <span class="hljs-type">int</span> (*Func2)();
    <span class="hljs-type">int</span>(*Func3)(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b);
} LibraryFuncStruct;

<span class="hljs-type">int</span>  LoadLibraryFunc LPCTSTR  dllFileName, LibraryFuncStruct *pStruct)
{
    <span class="hljs-type">int</span>  retStatus = <span class="hljs-number">0</span>;   <span class="hljs-comment">// default is an error detected</span>

    pStruct-&gt;hModule = LoadLibrary (dllFileName);
    <span class="hljs-keyword">if</span> (pStruct-&gt;hModule) {
        pStruct-&gt;Func1 = (<span class="hljs-type">int</span> (*)()) GetProcAddress (pStruct-&gt;hModule, <span class="hljs-string">"Func1"</span>);
        pStruct-&gt;Func2 = (<span class="hljs-type">int</span> (*)()) GetProcAddress (pStruct-&gt;hModule, <span class="hljs-string">"Func2"</span>);
        pStruct-&gt;Func3 = (<span class="hljs-type">int</span> (*)(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)) GetProcAddress(pStruct-&gt;hModule, <span class="hljs-string">"Func3"</span>);
        retStatus = <span class="hljs-number">1</span>;
    }

    <span class="hljs-keyword">return</span> retStatus;
}

<span class="hljs-type">void</span> <span class="hljs-title function_">FreeLibraryFunc</span> <span class="hljs-params">(LibraryFuncStruct *pStruct)</span>
{
    <span class="hljs-keyword">if</span> (pStruct-&gt;hModule) FreeLibrary (pStruct-&gt;hModule);
    pStruct-&gt;hModule = <span class="hljs-number">0</span>;
}
</code></pre>

<p>and this could be used as in:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">LibraryFuncStruct myLib = {<span class="hljs-number">0</span>};
LoadLibraryFunc (<span class="hljs-string">L"library.dll"</span>, &amp;myLib);
<span class="hljs-comment">//  ....</span>
myLib.Func1();
<span class="hljs-comment">//  ....</span>
FreeLibraryFunc (&amp;myLib);
</code></pre>

<p>The same approach can be used to define an abstract hardware layer for code that uses a particular model of the underlying hardware. Function pointers are filled in with hardware specific functions by a factory to provide the hardware specific functionality that implements functions specified in the abstract hardware model. This can be used to provide an abstract hardware layer used by software which calls a factory function in order to get the specific hardware function interface then uses the function pointers provided to perform actions for the underlying hardware without needing to know implementation details about the specific target.</p>

<p><strong>Function Pointers to create Delegates, Handlers, and Callbacks</strong></p>

<p>You can use function pointers as a way to delegate some task or functionality. The classic example in C is the comparison delegate function pointer used with the Standard C library functions <code>qsort()</code> and <code>bsearch()</code> to provide the collation order for sorting a list of items or performing a binary search over a sorted list of items. The comparison function delegate specifies the collation algorithm used in the sort or the binary search.</p>

<p>Another use is similar to applying an algorithm to a C++ Standard Template Library container.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">void</span> * <span class="hljs-title function_">ApplyAlgorithm</span> <span class="hljs-params">(<span class="hljs-type">void</span> *pArray, <span class="hljs-type">size_t</span> sizeItem, <span class="hljs-type">size_t</span> nItems, <span class="hljs-type">int</span> (*p)(<span class="hljs-type">void</span> *))</span> {
    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *pList = pArray;
    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *pListEnd = pList + nItems * sizeItem;
    <span class="hljs-keyword">for</span> ( ; pList &lt; pListEnd; pList += sizeItem) {
        p (pList);
    }

    <span class="hljs-keyword">return</span> pArray;
}

<span class="hljs-type">int</span> <span class="hljs-title function_">pIncrement</span><span class="hljs-params">(<span class="hljs-type">int</span> *pI)</span> {
    (*pI)++;

    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-type">void</span> * <span class="hljs-title function_">ApplyFold</span><span class="hljs-params">(<span class="hljs-type">void</span> *pArray, <span class="hljs-type">size_t</span> sizeItem, <span class="hljs-type">size_t</span> nItems, <span class="hljs-type">void</span> * pResult, <span class="hljs-type">int</span>(*p)(<span class="hljs-type">void</span> *, <span class="hljs-type">void</span> *))</span> {
    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *pList = pArray;
    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *pListEnd = pList + nItems * sizeItem;
    <span class="hljs-keyword">for</span> (; pList &lt; pListEnd; pList += sizeItem) {
        p(pList, pResult);
    }

    <span class="hljs-keyword">return</span> pArray;
}

<span class="hljs-type">int</span> <span class="hljs-title function_">pSummation</span><span class="hljs-params">(<span class="hljs-type">int</span> *pI, <span class="hljs-type">int</span> *pSum)</span> {
    (*pSum) += *pI;

    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-comment">// source code and then lets use our function.</span>
<span class="hljs-type">int</span> intList[<span class="hljs-number">30</span>] = { <span class="hljs-number">0</span> }, iSum = <span class="hljs-number">0</span>;

ApplyAlgorithm(intList, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>), <span class="hljs-keyword">sizeof</span>(intList) / <span class="hljs-keyword">sizeof</span>(intList[<span class="hljs-number">0</span>]), pIncrement);
ApplyFold(intList, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>), <span class="hljs-keyword">sizeof</span>(intList) / <span class="hljs-keyword">sizeof</span>(intList[<span class="hljs-number">0</span>]), &amp;iSum, pSummation);
</code></pre>

<p>Another example is with GUI source code in which a handler for a particular event is registered by providing a function pointer which is actually called when the event happens. The Microsoft MFC framework with its message maps uses something similar to handle Windows messages that are delivered to a window or thread.</p>

<p>Asynchronous functions that require a callback are similar to an event handler. The user of the asynchronous function calls the asynchronous function to start some action and provides a function pointer which the asynchronous function will call once the action is complete. In this case the event is the asynchronous function completing its task.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/function-pointers">function-pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Since function pointers are often typed callbacks, you might want to have a look at <a href="http://ccan.ozlabs.org/info/typesafe_cb.html" rel="nofollow noreferrer">type safe callbacks</a>. The same applies to entry points, etc of functions that are not callbacks.</p>

<p>C is quite fickle and forgiving at the same time :)</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/what-is-the-canonical-way-to-check-for-errors-using-the-cuda-runtime-api-1657387302698">What is the canonical way to check for errors using the CUDA runtime API?</a><a href="/questions/big-o-how-do-you-calculateapproximate-it-1657387856392">Big O, how do you calculate/approximate it?</a><a href="/questions/is-there-any-way-to-kill-a-thread-1657387859831">Is there any way to kill a Thread?</a><a href="/questions/what-is-the-difference-between-%22inner-join%22-and-%22outer-join%22-1657387501982">What is the difference between &quot;INNER JOIN&quot; and &quot;OUTER JOIN&quot;?</a><a href="/questions/what-is-javascript&#x27;s-highest-integer-value-that-a-number-can-go-to-without-losing-precision-1657387622983">What is JavaScript&#x27;s highest integer value that a number can go to without losing precision?</a><a href="/questions/how-can-i-get-useful-error-messages-in-php-1657384609065">How can I get useful error messages in PHP?</a><a href="/questions/how-to-make-good-reproducible-pandas-examples-1657384310402">How to make good reproducible pandas examples</a><a href="/questions/why-should-i-not-include-lessbitsstdc++.hgreater-1657384470484">Why should I not #include &lt;bits/stdc++.h&gt;?</a><a href="/questions/webdriverwait-not-working-as-expected-1657387373148">WebDriverWait not working as expected</a><a href="/questions/sorting-object-property-by-values-1657388367300">Sorting object property by values</a><a href="/questions/what-are-metaclasses-in-python-1657387811608">What are metaclasses in Python?</a><a href="/questions/what-does-the-&#x27;static&#x27;-keyword-do-in-a-class-1657388554238">What does the &#x27;static&#x27; keyword do in a class?</a><a href="/questions/how-can-i-tell-if-a-dom-element-is-visible-in-the-current-viewport-1657388316510">How can I tell if a DOM element is visible in the current viewport?</a><a href="/questions/undefined-unspecified-and-implementation-defined-behavior-1657384516085">Undefined, unspecified and implementation-defined behavior</a><a href="/questions/how-do-i-check-if-an-array-includes-a-value-in-javascript-1657387421185">How do I check if an array includes a value in JavaScript?</a><a href="/questions/selenium-%22selenium.common.exceptions.nosuchelementexception%22-when-using-chrome-1657388136699">Selenium &quot;selenium.common.exceptions.NoSuchElementException&quot; when using Chrome</a><a href="/questions/how-to-join-(merge)-data-frames-(inner-outer-left-right)-1657384406445">How to join (merge) data frames (inner, outer, left, right)</a><a href="/questions/why-does-the-order-in-which-libraries-are-linked-sometimes-cause-errors-in-gcc-1657387609554">Why does the order in which libraries are linked sometimes cause errors in GCC?</a><a href="/questions/how-to-remove-items-from-a-list-while-iterating-1657384496375">How to remove items from a list while iterating?</a><a href="/questions/how-can-i-combine-two-strings-together-in-php-1657388279401">How can I combine two strings together in PHP?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;h1\u0026gt;Function pointers in C\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;Let\u0026apos;s start with a basic function which we will be \u0026lt;em\u0026gt;pointing to\u0026lt;/em\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;addInt\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; m)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; n+m;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;First thing, let\u0026apos;s define a pointer to a function which receives 2 \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;s and returns an \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*functionPtr)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now we can safely point to our function:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;functionPtr = \u0026amp;amp;addInt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now that we have a pointer to the function, let\u0026apos;s use it:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; sum = (*functionPtr)(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// sum == 5\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Passing the pointer to another function is basically the same:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;add2to3\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*functionPtr)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;))\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (*functionPtr)(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;We can use function pointers in return values as well (try to keep up, it gets messy):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// this is a function called functionFactory which receives parameter n\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// and returns a pointer to another function which receives two ints\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// and it returns another int\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*functionFactory(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n))(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Got parameter %d\u0026quot;\u0026lt;/span\u0026gt;, n);\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*functionPtr)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;) = \u0026amp;amp;addInt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; functionPtr;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;But it\u0026apos;s much nicer to use a \u0026lt;code\u0026gt;typedef\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(*myFuncDef)\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// note that the typedef name is indeed myFuncDef\u0026lt;/span\u0026gt;\n\nmyFuncDef \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;functionFactory\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Got parameter %d\u0026quot;\u0026lt;/span\u0026gt;, n);\n    myFuncDef functionPtr = \u0026amp;amp;addInt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; functionPtr;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Function pointers in C can be used to perform object-oriented programming in C.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example, the following lines is written in C:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;String s1 = newString();\ns1-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;set\u0026lt;/span\u0026gt;(s1, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Yes, the \u0026lt;code\u0026gt;-\u0026amp;gt;\u0026lt;/code\u0026gt; and the lack of a \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; operator is a dead give away, but it sure seems to imply that we\u0026apos;re setting the text of some \u0026lt;code\u0026gt;String\u0026lt;/code\u0026gt; class to be \u0026lt;code\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;By using function pointers, \u0026lt;strong\u0026gt;it is possible to emulate methods in C\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;How is this accomplished?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;String\u0026lt;/code\u0026gt; class is actually a \u0026lt;code\u0026gt;struct\u0026lt;/code\u0026gt; with a bunch of function pointers which act as a way to simulate methods. The following is a partial declaration of the \u0026lt;code\u0026gt;String\u0026lt;/code\u0026gt; class:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-class\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;String_Struct\u0026lt;/span\u0026gt;* \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-class\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;String_Struct\u0026lt;/span\u0026gt;\n{\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* (*get)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;* self);\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; (*\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;set\u0026lt;/span\u0026gt;)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;* self, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* value);\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*length)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;* self);\n};\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;* self)\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;* self, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* value)\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;lengthString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;* self)\u0026lt;/span\u0026gt;;\n\nString \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;newString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;As can be seen, the methods of the \u0026lt;code\u0026gt;String\u0026lt;/code\u0026gt; class are actually function pointers to the declared function. In preparing the instance of the \u0026lt;code\u0026gt;String\u0026lt;/code\u0026gt;, the \u0026lt;code\u0026gt;newString\u0026lt;/code\u0026gt; function is called in order to set up the function pointers to their respective functions:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;String \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;newString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n{\n    String self = (String)\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; String_Struct));\n\n    self-\u0026amp;gt;get = \u0026amp;amp;getString;\n    self-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;set\u0026lt;/span\u0026gt; = \u0026amp;amp;setString;\n    self-\u0026amp;gt;length = \u0026amp;amp;lengthString;\n\n    self-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;set\u0026lt;/span\u0026gt;(self, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; self;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;For example, the \u0026lt;code\u0026gt;getString\u0026lt;/code\u0026gt; function that is called by invoking the \u0026lt;code\u0026gt;get\u0026lt;/code\u0026gt; method is defined as the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;* self_obj)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; ((String)self_obj)-\u0026amp;gt;internal-\u0026amp;gt;value;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;One thing that can be noticed is that there is no concept of an instance of an object and having methods that are actually a part of an object, so a \u0026quot;self object\u0026quot; must be passed in on each invocation. (And the \u0026lt;code\u0026gt;internal\u0026lt;/code\u0026gt; is just a hidden \u0026lt;code\u0026gt;struct\u0026lt;/code\u0026gt; which was omitted from the code listing earlier -- it is a way of performing information hiding, but that is not relevant to function pointers.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So, rather than being able to do \u0026lt;code\u0026gt;s1-\u0026amp;gt;set(\u0026quot;hello\u0026quot;);\u0026lt;/code\u0026gt;, one must pass in the object to perform the action on \u0026lt;code\u0026gt;s1-\u0026amp;gt;set(s1, \u0026quot;hello\u0026quot;)\u0026lt;/code\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;With that minor explanation having to pass in a reference to yourself out of the way, we\u0026apos;ll move to the next part, which is \u0026lt;strong\u0026gt;inheritance in C\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Let\u0026apos;s say we want to make a subclass of \u0026lt;code\u0026gt;String\u0026lt;/code\u0026gt;, say an \u0026lt;code\u0026gt;ImmutableString\u0026lt;/code\u0026gt;. In order to make the string immutable, the \u0026lt;code\u0026gt;set\u0026lt;/code\u0026gt; method will not be accessible, while maintaining access to \u0026lt;code\u0026gt;get\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;length\u0026lt;/code\u0026gt;, and force the \u0026quot;constructor\u0026quot; to accept a \u0026lt;code\u0026gt;char*\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-class\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ImmutableString_Struct\u0026lt;/span\u0026gt;* \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ImmutableString\u0026lt;/span\u0026gt;;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-class\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ImmutableString_Struct\u0026lt;/span\u0026gt;\n{\u0026lt;/span\u0026gt;\n    String base;\n\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* (*get)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;* self);\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*length)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;* self);\n};\n\nImmutableString \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;newImmutableString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* value)\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Basically, for all subclasses, the available methods are once again function pointers. This time, the declaration for the \u0026lt;code\u0026gt;set\u0026lt;/code\u0026gt; method is not present, therefore, it cannot be called in a \u0026lt;code\u0026gt;ImmutableString\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As for the implementation of the \u0026lt;code\u0026gt;ImmutableString\u0026lt;/code\u0026gt;, the only relevant code is the \u0026quot;constructor\u0026quot; function, the \u0026lt;code\u0026gt;newImmutableString\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;ImmutableString \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;newImmutableString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* value)\u0026lt;/span\u0026gt;\n{\n    ImmutableString self = (ImmutableString)\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; ImmutableString_Struct));\n\n    self-\u0026amp;gt;base = newString();\n\n    self-\u0026amp;gt;get = self-\u0026amp;gt;base-\u0026amp;gt;get;\n    self-\u0026amp;gt;length = self-\u0026amp;gt;base-\u0026amp;gt;length;\n\n    self-\u0026amp;gt;base-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;set\u0026lt;/span\u0026gt;(self-\u0026amp;gt;base, (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*)value);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; self;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In instantiating the \u0026lt;code\u0026gt;ImmutableString\u0026lt;/code\u0026gt;, the function pointers to the \u0026lt;code\u0026gt;get\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;length\u0026lt;/code\u0026gt; methods actually refer to the \u0026lt;code\u0026gt;String.get\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;String.length\u0026lt;/code\u0026gt; method, by going through the \u0026lt;code\u0026gt;base\u0026lt;/code\u0026gt; variable which is an internally stored \u0026lt;code\u0026gt;String\u0026lt;/code\u0026gt; object.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The use of a function pointer can achieve inheritance of a method from a superclass.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;We can further continue to \u0026lt;strong\u0026gt;polymorphism in C\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If for example we wanted to change the behavior of the \u0026lt;code\u0026gt;length\u0026lt;/code\u0026gt; method to return \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt; all the time in the \u0026lt;code\u0026gt;ImmutableString\u0026lt;/code\u0026gt; class for some reason, all that would have to be done is to:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Add a function that is going to serve as the overriding \u0026lt;code\u0026gt;length\u0026lt;/code\u0026gt; method.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Go to the \u0026quot;constructor\u0026quot; and set the function pointer to the overriding \u0026lt;code\u0026gt;length\u0026lt;/code\u0026gt; method.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;Adding an overriding \u0026lt;code\u0026gt;length\u0026lt;/code\u0026gt; method in \u0026lt;code\u0026gt;ImmutableString\u0026lt;/code\u0026gt; may be performed by adding an \u0026lt;code\u0026gt;lengthOverrideMethod\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;lengthOverrideMethod\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;* self)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Then, the function pointer for the \u0026lt;code\u0026gt;length\u0026lt;/code\u0026gt; method in the constructor is hooked up to the \u0026lt;code\u0026gt;lengthOverrideMethod\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;ImmutableString \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;newImmutableString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* value)\u0026lt;/span\u0026gt;\n{\n    ImmutableString self = (ImmutableString)\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; ImmutableString_Struct));\n\n    self-\u0026amp;gt;base = newString();\n\n    self-\u0026amp;gt;get = self-\u0026amp;gt;base-\u0026amp;gt;get;\n    self-\u0026amp;gt;length = \u0026amp;amp;lengthOverrideMethod;\n\n    self-\u0026amp;gt;base-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;set\u0026lt;/span\u0026gt;(self-\u0026amp;gt;base, (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*)value);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; self;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now, rather than having an identical behavior for the \u0026lt;code\u0026gt;length\u0026lt;/code\u0026gt; method in \u0026lt;code\u0026gt;ImmutableString\u0026lt;/code\u0026gt; class as the \u0026lt;code\u0026gt;String\u0026lt;/code\u0026gt; class, now the \u0026lt;code\u0026gt;length\u0026lt;/code\u0026gt; method will refer to the behavior defined in the \u0026lt;code\u0026gt;lengthOverrideMethod\u0026lt;/code\u0026gt; function.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I must add a disclaimer that I am still learning how to write with an object-oriented programming style in C, so there probably are points that I didn\u0026apos;t explain well, or may just be off mark in terms of how best to implement OOP in C. But my purpose was to try to illustrate one of many uses of function pointers.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For more information on how to perform object-oriented programming in C, please refer to the following questions:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/415452/object-orientation-in-c\u0026quot;\u0026gt;Object-Orientation in C?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/351733/can-you-write-object-oriented-code-in-c\u0026quot;\u0026gt;Can you write object oriented code in C?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The guide to getting fired: How to abuse function pointers in GCC on x86 machines by compiling your code by hand:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;These string literals are bytes of 32-bit x86 machine code.  \u0026lt;code\u0026gt;0xC3\u0026lt;/code\u0026gt; is \u0026lt;a href=\u0026quot;http://felixcloutier.com/x86/RET.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;an x86 \u0026lt;code\u0026gt;ret\u0026lt;/code\u0026gt; instruction\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You wouldn\u0026apos;t normally write these by hand, you\u0026apos;d write in assembly language and then use an assembler like \u0026lt;code\u0026gt;nasm\u0026lt;/code\u0026gt; to assemble it into a flat binary which you hexdump into a C string literal.\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Returns the current value on the EAX register\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; eax = ((\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;(*)())(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\xc3 \u0026amp;lt;- This returns the value of the EAX register\u0026quot;\u0026lt;/span\u0026gt;))();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Write a swap function\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, b = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt;;\n((\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;(*)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;*,\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;*))\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\x8b\\x44\\x24\\x04\\x8b\\x5c\\x24\\x08\\x8b\\x00\\x8b\\x1b\\x31\\xc3\\x31\\xd8\\x31\\xc3\\x8b\\x4c\\x24\\x04\\x89\\x01\\x8b\\x4c\\x24\\x08\\x89\\x19\\xc3 \u0026amp;lt;- This swaps the values of a and b\u0026quot;\u0026lt;/span\u0026gt;)(\u0026amp;amp;a,\u0026amp;amp;b);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Write a for-loop counter to 1000, calling some function each time\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;((\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;(*)())\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\x66\\x31\\xc0\\x8b\\x5c\\x24\\x04\\x66\\x40\\x50\\xff\\xd3\\x58\\x66\\x3d\\xe8\\x03\\x75\\xf4\\xc3\u0026quot;\u0026lt;/span\u0026gt;)(\u0026amp;amp;function); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// calls function with 1-\u0026amp;gt;1000\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;You can even write a recursive function that counts to 100\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* lol = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\x8b\\x5c\\x24\\x4\\x3d\\xe8\\x3\\x0\\x0\\x7e\\x2\\x31\\xc0\\x83\\xf8\\x64\\x7d\\x6\\x40\\x53\\xff\\xd3\\x5b\\xc3\\xc3 \u0026amp;lt;- Recursively calls the function at address lol.\u0026quot;\u0026lt;/span\u0026gt;;\ni = ((\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;(*)())(lol))(lol);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;Note that compilers place string literals in the \u0026lt;code\u0026gt;.rodata\u0026lt;/code\u0026gt; section (or \u0026lt;code\u0026gt;.rdata\u0026lt;/code\u0026gt; on Windows), which is linked as part of the text segment (along with code for functions).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The text segment has Read+Exec permission, so casting string literals to function pointers works without needing \u0026lt;code\u0026gt;mprotect()\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;VirtualProtect()\u0026lt;/code\u0026gt; system calls like you\u0026apos;d need for dynamically allocated memory.  (Or \u0026lt;code\u0026gt;gcc -z execstack\u0026lt;/code\u0026gt; links the program with stack + data segment + heap executable, as a quick hack.)\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;To disassemble these, you can compile this to put a label on the bytes, and use a disassembler.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// at global scope\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; swap[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\x8b\\x44\\x24\\x04\\x8b\\x5c\\x24\\x08\\x8b\\x00\\x8b\\x1b\\x31\\xc3\\x31\\xd8\\x31\\xc3\\x8b\\x4c\\x24\\x04\\x89\\x01\\x8b\\x4c\\x24\\x08\\x89\\x19\\xc3 \u0026amp;lt;- This swaps the values of a and b\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Compiling with \u0026lt;code\u0026gt;gcc -c -m32 foo.c\u0026lt;/code\u0026gt; and disassembling with \u0026lt;code\u0026gt;objdump -D -rwC -Mintel\u0026lt;/code\u0026gt;, we can get the assembly, and find out that this code violates the ABI by clobbering EBX (a call-preserved register) and is generally inefficient.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00000000\u0026lt;/span\u0026gt; \u0026amp;lt;swap\u0026amp;gt;:\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;:   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8b\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;44\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;24\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;04\u0026lt;/span\u0026gt;             mov    eax,DWORD PTR [esp+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x4\u0026lt;/span\u0026gt;]   \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# load int *a arg from the stack\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;:   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8b\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;c \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;24\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;08\u0026lt;/span\u0026gt;             mov    ebx,DWORD PTR [esp+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x8\u0026lt;/span\u0026gt;]   \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# ebx = b\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;:   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8b\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt;                   mov    eax,DWORD PTR [eax]       \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# dereference: eax = *a\u0026lt;/span\u0026gt;\n   a:   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8b\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1b\u0026lt;/span\u0026gt;                   mov    ebx,DWORD PTR [ebx]\n   c:   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;31\u0026lt;/span\u0026gt; c3                   xor    ebx,eax                \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# pointless xor-swap\u0026lt;/span\u0026gt;\n   e:   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;31\u0026lt;/span\u0026gt; d8                   xor    eax,ebx                \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# instead of just storing with opposite registers\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;:   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;31\u0026lt;/span\u0026gt; c3                   xor    ebx,eax\n  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12\u0026lt;/span\u0026gt;:   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8b\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;c \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;24\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;04\u0026lt;/span\u0026gt;             mov    ecx,DWORD PTR [esp+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x4\u0026lt;/span\u0026gt;]  \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# reload a from the stack\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;16\u0026lt;/span\u0026gt;:   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;89\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;01\u0026lt;/span\u0026gt;                   mov    DWORD PTR [ecx],eax     \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# store to *a\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;18\u0026lt;/span\u0026gt;:   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8b\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;c \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;24\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;08\u0026lt;/span\u0026gt;             mov    ecx,DWORD PTR [esp+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x8\u0026lt;/span\u0026gt;]\n  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;c:   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;89\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;19\u0026lt;/span\u0026gt;                   mov    DWORD PTR [ecx],ebx\n  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;e:   c3                      ret    \n\n  not shown: the later bytes are ASCII text documentation\n  they\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;\u0026apos;\u0026lt;/span\u0026gt;re not executed by the CPU because the ret instruction sends execution back to the caller\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This machine code will (probably) work in 32-bit code on Windows, Linux, OS X, and so on: the default calling conventions on all those OSes pass args on the stack instead of more efficiently in registers.  But EBX is call-preserved in all the normal calling conventions, so using it as a scratch register without saving/restoring it can easily make the caller crash.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;One of my favorite uses for function pointers is as cheap and easy iterators - \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; MAX_COLORS  256\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-class\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; {\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* name;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; red;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; green;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; blue;\n} Color;\n\nColor Colors[MAX_COLORS];\n\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;eachColor\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; (*fp)(Color *c))\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (i=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i\u0026amp;lt;MAX_COLORS; i++)\n        (*fp)(\u0026amp;amp;Colors[i]);\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;printColor\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Color* c)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (c-\u0026amp;gt;name)\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%s = %i,%i,%i\\n\u0026quot;\u0026lt;/span\u0026gt;, c-\u0026amp;gt;name, c-\u0026amp;gt;red, c-\u0026amp;gt;green, c-\u0026amp;gt;blue);\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n    Colors[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;].name=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;red\u0026quot;\u0026lt;/span\u0026gt;;\n    Colors[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;].red=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;255\u0026lt;/span\u0026gt;;\n    Colors[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;].name=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;blue\u0026quot;\u0026lt;/span\u0026gt;;\n    Colors[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;].blue=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;255\u0026lt;/span\u0026gt;;\n    Colors[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;].name=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;black\u0026quot;\u0026lt;/span\u0026gt;;\n\n    eachColor(printColor);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Function pointers become easy to declare once you have the basic declarators:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;id: \u0026lt;code\u0026gt;ID\u0026lt;/code\u0026gt;: \u0026lt;em\u0026gt;ID is a\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Pointer: \u0026lt;code\u0026gt;*D\u0026lt;/code\u0026gt;: \u0026lt;em\u0026gt;D pointer to\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Function: \u0026lt;code\u0026gt;D(\u0026amp;lt;parameters\u0026amp;gt;)\u0026lt;/code\u0026gt;: \u0026lt;em\u0026gt;D function taking \u0026lt;code\u0026gt;\u0026amp;lt;\u0026lt;/code\u0026gt;parameters\u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt; returning\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;While D is another declarator built using those same rules. In the end, somewhere, it ends with \u0026lt;code\u0026gt;ID\u0026lt;/code\u0026gt; (see below for an example), which is the name of the declared entity. Let\u0026apos;s try to build a function taking a pointer to a function taking nothing and returning int, and returning a pointer to a function taking a char and returning int. With type-defs it\u0026apos;s like this\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;ReturnFunction\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;ParameterFunction\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;;\nReturnFunction *\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(ParameterFunction *p)\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;As you see, it\u0026apos;s pretty easy to build it up using typedefs. Without typedefs, it\u0026apos;s not hard either with the above declarator rules, applied consistently. As you see i missed out the part the pointer points to, and the thing the function returns. That\u0026apos;s what appears at the very left of the declaration, and is not of interest: It\u0026apos;s added at the end if one built up the declarator already. Let\u0026apos;s do that. Building it up consistently, first wordy - showing the structure using \u0026lt;code\u0026gt;[\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;]\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;function taking \n    [pointer to [function taking [\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;] returning [\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;]]] \nreturning\n    [pointer to [function taking [\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;] returning [\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;]]]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;As you see, one can describe a type completely by appending declarators one after each other. Construction can be done in two ways. One is bottom-up, starting with the very right thing (leaves) and working the way through up to the identifier. The other way is top-down, starting at the identifier, working the way down to the leaves. I\u0026apos;ll show both ways.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Bottom Up\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Construction starts with the thing at the right: The thing returned, which is the function taking char. To keep the declarators distinct, i\u0026apos;m going to number them:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;D1(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Inserted the char parameter directly, since it\u0026apos;s trivial. Adding a pointer to declarator by replacing \u0026lt;code\u0026gt;D1\u0026lt;/code\u0026gt; by \u0026lt;code\u0026gt;*D2\u0026lt;/code\u0026gt;. Note that we have to wrap parentheses around \u0026lt;code\u0026gt;*D2\u0026lt;/code\u0026gt;. That can be known by looking up the precedence of the \u0026lt;code\u0026gt;*-operator\u0026lt;/code\u0026gt; and the function-call operator \u0026lt;code\u0026gt;()\u0026lt;/code\u0026gt;. Without our parentheses, the compiler would read it as \u0026lt;code\u0026gt;*(D2(char p))\u0026lt;/code\u0026gt;. But that would not be a plain replace of D1 by \u0026lt;code\u0026gt;*D2\u0026lt;/code\u0026gt; anymore, of course. Parentheses are always allowed around declarators. So you don\u0026apos;t make anything wrong if you add too much of them, actually.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;(*D2)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Return type is complete! Now, let\u0026apos;s replace \u0026lt;code\u0026gt;D2\u0026lt;/code\u0026gt; by the function declarator \u0026lt;em\u0026gt;function taking \u0026lt;code\u0026gt;\u0026amp;lt;parameters\u0026amp;gt;\u0026lt;/code\u0026gt; returning\u0026lt;/em\u0026gt;, which is \u0026lt;code\u0026gt;D3(\u0026amp;lt;parameters\u0026amp;gt;)\u0026lt;/code\u0026gt; which we are at now. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;(*D3(\u0026amp;lt;parameters\u0026amp;gt;))(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that no parentheses are needed, since we \u0026lt;em\u0026gt;want\u0026lt;/em\u0026gt; \u0026lt;code\u0026gt;D3\u0026lt;/code\u0026gt; to be a function-declarator and not a pointer declarator this time. Great, only thing left is the parameters for it. The parameter is done exactly the same as we\u0026apos;ve done the return type, just with \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt; replaced by \u0026lt;code\u0026gt;void\u0026lt;/code\u0026gt;. So i\u0026apos;ll copy it:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;(*D3(   (*ID1)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)))(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;ve replaced \u0026lt;code\u0026gt;D2\u0026lt;/code\u0026gt; by \u0026lt;code\u0026gt;ID1\u0026lt;/code\u0026gt;, since we are finished with that parameter (it\u0026apos;s already a pointer to a function - no need for another declarator). \u0026lt;code\u0026gt;ID1\u0026lt;/code\u0026gt; will be the name of the parameter. Now, i told above at the end one adds the type which all those declarator modify - the one appearing at the very left of every declaration. For functions, that becomes the return type. For pointers the pointed to type etc... It\u0026apos;s interesting when written down the type, it will appear in the opposite order, at the very right :) Anyway, substituting it yields the complete declaration. Both times \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; of course. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*ID0(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*ID1)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)))(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;ve called the identifier of the function \u0026lt;code\u0026gt;ID0\u0026lt;/code\u0026gt; in that example. \u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Top Down\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;This starts at the identifier at the very left in the description of the type, wrapping that declarator as we walk our way through the right. Start with \u0026lt;em\u0026gt;function taking \u0026lt;code\u0026gt;\u0026amp;lt;\u0026lt;/code\u0026gt;parameters\u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt; returning\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;ID0(\u0026amp;lt;parameters\u0026amp;gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The next thing in the description (after \u0026quot;returning\u0026quot;) was \u0026lt;em\u0026gt;pointer to\u0026lt;/em\u0026gt;. Let\u0026apos;s incorporate it:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;*ID0(\u0026amp;lt;parameters\u0026amp;gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Then the next thing was \u0026lt;em\u0026gt;functon taking \u0026lt;code\u0026gt;\u0026amp;lt;\u0026lt;/code\u0026gt;parameters\u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt; returning\u0026lt;/em\u0026gt;. The parameter is a simple char, so we put it in right away again, since it\u0026apos;s really trivial.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;(*ID0(\u0026amp;lt;parameters\u0026amp;gt;))(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note the parentheses we added, since we again want that the \u0026lt;code\u0026gt;*\u0026lt;/code\u0026gt; binds first, and \u0026lt;em\u0026gt;then\u0026lt;/em\u0026gt; the \u0026lt;code\u0026gt;(char)\u0026lt;/code\u0026gt;. Otherwise it would read \u0026lt;em\u0026gt;function taking \u0026lt;code\u0026gt;\u0026amp;lt;\u0026lt;/code\u0026gt;parameters\u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt; returning function ...\u0026lt;/em\u0026gt;. Noes, functions returning functions aren\u0026apos;t even allowed. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now we just need to put \u0026lt;code\u0026gt;\u0026amp;lt;\u0026lt;/code\u0026gt;parameters\u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt;. I will show a short version of the deriveration, since i think you already by now have the idea how to do it.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;pointer to: *ID1\n... function taking \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; returning: (*ID1)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Just put \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; before the declarators like we did with bottom-up, and we are finished\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*ID0(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*ID1)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)))(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h2\u0026gt;The nice thing\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Is bottom-up or top-down better? I\u0026apos;m used to bottom-up, but some people may be more comfortable with top-down. It\u0026apos;s a matter of taste i think. Incidentally, if you apply all the operators in that declaration, you will end up getting an int:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; v = (*ID0(some_function_pointer))(some_char);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;That is a nice property of declarations in C: The declaration asserts that if those operators are used in an expression using the identifier, then it yields the type on the very left. It\u0026apos;s like that for arrays too. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Hope you liked this little tutorial! Now we can link to this when people wonder about the strange declaration syntax of functions. I tried to put as little C internals as possible. Feel free to edit/fix things in it. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;Another good use for function pointers:\u0026lt;br\u0026gt;Switching between versions painlessly\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;They\u0026apos;re very handy to use for when you want different functions at different times, or different phases of development. For instance, I\u0026apos;m developing an application on a host computer that has a console, but the final release of the software will be put on an Avnet ZedBoard (which has ports for displays and consoles, but they are not needed/wanted for the final release). So during development, I will use \u0026lt;code\u0026gt;printf\u0026lt;/code\u0026gt; to view status and error messages, but when I\u0026apos;m done, I don\u0026apos;t want anything printed. Here\u0026apos;s what I\u0026apos;ve done:\u0026lt;/p\u0026gt;\n\n\u0026lt;h1\u0026gt;version.h\u0026lt;/h1\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// First, undefine all macros associated with version.h\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;undef\u0026lt;/span\u0026gt; DEBUG_VERSION\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;undef\u0026lt;/span\u0026gt; RELEASE_VERSION\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;undef\u0026lt;/span\u0026gt; INVALID_VERSION\u0026lt;/span\u0026gt;\n\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Define which version we want to use\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; DEBUG_VERSION       \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// The current version\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// #define RELEASE_VERSION  // To be uncommented when finished debugging\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ifndef\u0026lt;/span\u0026gt; __VERSION_H_      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* prevent circular inclusions */\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; __VERSION_H_  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* by using protection macros */\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;board_init\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;noprintf\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *c, ...)\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// mimic the printf prototype\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;endif\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Mimics the printf function prototype. This is what I\u0026apos;ll actually \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// use to print stuff to the screen\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; (* zprintf)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*, ...); \n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// If debug version, use printf\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ifdef\u0026lt;/span\u0026gt; DEBUG_VERSION\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;endif\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// If both debug and release version, error\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ifdef\u0026lt;/span\u0026gt; DEBUG_VERSION\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ifdef\u0026lt;/span\u0026gt; RELEASE_VERSION\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; INVALID_VERSION\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;endif\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;endif\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// If neither debug or release version, error\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ifndef\u0026lt;/span\u0026gt; DEBUG_VERSION\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ifndef\u0026lt;/span\u0026gt; RELEASE_VERSION\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; INVALID_VERSION\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;endif\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;endif\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ifdef\u0026lt;/span\u0026gt; INVALID_VERSION\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Won\u0026apos;t allow compilation without a valid version define\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;error\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Invalid version definition\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;endif\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In \u0026lt;code\u0026gt;version.c\u0026lt;/code\u0026gt; I will define the 2 function prototypes present in \u0026lt;code\u0026gt;version.h\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;h1\u0026gt;version.c\u0026lt;/h1\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;version.h\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*****************************************************************************/\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/**\n* @name board_init\n*\n* Sets up the application based on the version type defined in version.h.\n* Includes allowing or prohibiting printing to STDOUT.\n*\n* MUST BE CALLED FIRST THING IN MAIN\n*\n* @return    None\n*\n*****************************************************************************/\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;board_init\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Assign the print function to the correct function pointer\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ifdef\u0026lt;/span\u0026gt; DEBUG_VERSION\u0026lt;/span\u0026gt;\n        zprintf = \u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Defined below this function\u0026lt;/span\u0026gt;\n        zprintf = \u0026amp;amp;noprintf;\n    \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;endif\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*****************************************************************************/\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/**\n* @name noprintf\n*\n* simply returns with no actions performed\n*\n* @return   None\n*\n*****************************************************************************/\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;noprintf\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* c, ...)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;p\u0026gt;Notice how the function pointer is prototyped in \u0026lt;code\u0026gt;version.h\u0026lt;/code\u0026gt; as \u0026lt;/p\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;void (* zprintf)(const char *, ...);\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;p\u0026gt;When it is referenced in the application, it will start executing wherever it is pointing, which has yet to be defined.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In \u0026lt;code\u0026gt;version.c\u0026lt;/code\u0026gt;, notice in the \u0026lt;code\u0026gt;board_init()\u0026lt;/code\u0026gt;function where \u0026lt;code\u0026gt;zprintf\u0026lt;/code\u0026gt; is assigned a unique function (whose function signature matches) depending on the version that is defined in \u0026lt;code\u0026gt;version.h\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;zprintf = \u0026amp;amp;printf;\u0026lt;/code\u0026gt; zprintf calls printf for debugging purposes\u0026lt;/p\u0026gt;\u0026lt;p\u0026gt;or\u0026lt;/p\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;zprintf = \u0026amp;amp;noprint;\u0026lt;/code\u0026gt; zprintf just returns and will not run unnecessary code\u0026lt;/p\u0026gt;\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Running the code will look like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;h1\u0026gt;mainProg.c\u0026lt;/h1\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;version.h\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdlib.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Must run board_init(), which assigns the function\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// pointer to an actual function\u0026lt;/span\u0026gt;\n    board_init();\n\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; *ptr = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Allocate 100 bytes of memory\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// malloc returns NULL if unable to allocate the memory.\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (ptr == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;)\n    {\n        zprintf(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Unable to allocate memory\\n\u0026quot;\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Other things to do...\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The above code will use \u0026lt;code\u0026gt;printf\u0026lt;/code\u0026gt; if in debug mode, or do nothing if in release mode. This is much easier than going through the entire project and commenting out or deleting code. All that I need to do is change the version in \u0026lt;code\u0026gt;version.h\u0026lt;/code\u0026gt; and the code will do the rest!\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Function pointer is usually defined by \u0026lt;code\u0026gt;typedef\u0026lt;/code\u0026gt;, and used as param \u0026amp;amp; return value.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Above answers already explained a lot, I just give a full example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; NUM_A 1\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; NUM_B 2\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// define a function pointer type\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(*two_num_operation)\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// an actual standalone function\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sum\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; b)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; a + b;\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// use function pointer as param,\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sum_via_pointer\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; b, two_num_operation funp)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (*funp)(a, b);\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// use function pointer as return value,\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; two_num_operation \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;get_sum_fun\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026amp;amp;sum;\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// test - use function pointer as variable,\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;test_pointer_as_variable\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// create a pointer to function,\u0026lt;/span\u0026gt;\n    two_num_operation sum_p = \u0026amp;amp;sum;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// call function via pointer\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;pointer as variable:\\t %d + %d = %d\\n\u0026quot;\u0026lt;/span\u0026gt;, NUM_A, NUM_B, (*sum_p)(NUM_A, NUM_B));\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// test - use function pointer as param,\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;test_pointer_as_param\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;pointer as param:\\t %d + %d = %d\\n\u0026quot;\u0026lt;/span\u0026gt;, NUM_A, NUM_B, sum_via_pointer(NUM_A, NUM_B, \u0026amp;amp;sum));\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// test - use function pointer as return value,\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;test_pointer_as_return_value\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;pointer as return value:\\t %d + %d = %d\\n\u0026quot;\u0026lt;/span\u0026gt;, NUM_A, NUM_B, (*get_sum_fun())(NUM_A, NUM_B));\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n    test_pointer_as_variable();\n    test_pointer_as_param();\n    test_pointer_as_return_value();\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Starting from scratch function has Some Memory Address From Where They start executing. In Assembly Language They Are called as (call \u0026quot;function\u0026apos;s memory address\u0026quot;).Now come back to C If function has a memory address then they can be manipulated by Pointers in C.So By the rules of C \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;1.First you need to declare a pointer to function \n2.Pass the Address of the  Desired function \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;****Note-\u0026amp;gt;the functions should be of same type**** \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This Simple Programme will Illustrate Every Thing.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; (*print)() ;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Declare a  Function Pointers\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sayhello\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Declare The Function Whose Address is to be passed\u0026lt;/span\u0026gt;\n                \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//The Functions should Be of Same Type\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n{\n print=sayhello;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Addressof sayhello is assigned to print\u0026lt;/span\u0026gt;\n print();\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//print Does A call To The Function \u0026lt;/span\u0026gt;\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sayhello\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n{\n \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n Hello World\u0026quot;\u0026lt;/span\u0026gt;);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/L4qpJ.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;After That lets See How machine Understands Them.Glimpse of machine instruction of the above programme in 32 bit architecture.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The red mark area is showing how the address is being exchanged and storing in eax. Then their is a call instruction on eax. eax contains the desired address of the function.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;One of the big uses for function pointers in C is to call a function selected at run-time. For example, the C run-time library has two routines, \u0026lt;a href=\u0026quot;https://en.cppreference.com/w/c/algorithm/qsort\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;qsort\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;https://en.cppreference.com/w/c/algorithm/bsearch\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;bsearch\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;, which take a pointer to a function that is called to compare two items being sorted; this allows you to sort or search, respectively, anything, based on any criteria you wish to use. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A very basic example, if there is one function called \u0026lt;code\u0026gt;print(int x, int y)\u0026lt;/code\u0026gt; which in turn may require to call a function (either \u0026lt;code\u0026gt;add()\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;sub()\u0026lt;/code\u0026gt;, which are of the same type) then what we will do, we will add one function pointer argument to the \u0026lt;code\u0026gt;print()\u0026lt;/code\u0026gt; function as shown below:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;add\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n{\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;);\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sub\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n{\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-10\u0026lt;/span\u0026gt;);\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; y, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*func)())\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;value is: %d\\n\u0026quot;\u0026lt;/span\u0026gt;, (x+y+(*func)()));\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;, y=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;200\u0026lt;/span\u0026gt;;\n    print(x,y,add);\n    print(x,y,sub);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The output is:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;value is: 410\u0026lt;br\u0026gt;\n  value is: 390\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A function pointer is a variable that contains the address of a function. Since it is a pointer variable though with some restricted properties, you can use it pretty much like you would any other pointer variable in data structures.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The only exception I can think of is treating the function pointer as pointing to something other than a single value. Doing pointer arithmetic by incrementing or decrementing a function pointer or adding/subtracting an offset to a function pointer isn\u0026apos;t really of any utility as a function pointer only points to a single thing, the entry point of a function.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The size of a function pointer variable, the number of bytes occupied by the variable, may vary depending on the underlying architecture, e.g. x32 or x64 or whatever.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The declaration for a function pointer variable needs to specify the same kind of information as a function declaration in order for the C compiler to do the kinds of checks that it normally does. If you don\u0026apos;t specify a parameter list in the declaration/definition of the function pointer, the C compiler will not be able to check the use of parameters. There are cases when this lack of checking can be useful however just remember that a safety net has been removed.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Some examples:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *pStr)\u0026lt;/span\u0026gt;;    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// declares a function\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*pFunc)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *pStr);  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// declares or defines a function pointer\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*pFunc2) ();                 \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// declares or defines a function pointer, no parameter list specified.\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*pFunc3) (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;);             \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// declares or defines a function pointer, no arguments.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The first two declararations are somewhat similar in that:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;func\u0026lt;/code\u0026gt; is a function that takes an \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; and a \u0026lt;code\u0026gt;char *\u0026lt;/code\u0026gt; and returns an \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;pFunc\u0026lt;/code\u0026gt; is a function pointer to which is assigned the address of a function that takes an \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; and a \u0026lt;code\u0026gt;char *\u0026lt;/code\u0026gt; and returns an \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;So from the above we could have a source line in which the address of the function \u0026lt;code\u0026gt;func()\u0026lt;/code\u0026gt; is assigned to the function pointer variable \u0026lt;code\u0026gt;pFunc\u0026lt;/code\u0026gt; as in \u0026lt;code\u0026gt;pFunc = func;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Notice the syntax used with a function pointer declaration/definition in which parenthesis are used to overcome the natural operator precedence rules.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;pfunc\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *pStr)\u0026lt;/span\u0026gt;;    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// declares a function that returns int pointer\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*pFunc)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *pStr);  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// declares a function pointer that returns an int\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Several Different Usage Examples\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Some examples of usage of a function pointer:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*pFunc) (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *pStr);    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// declare a simple function pointer variable\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*pFunc[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;55\u0026lt;/span\u0026gt;])(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *pStr); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// declare an array of 55 function pointers\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (**pFunc)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *pStr);    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// declare a pointer to a function pointer variable\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-class\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; {\u0026lt;/span\u0026gt;                             \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// declare a struct that contains a function pointer\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x22;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*pFunc)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *pStr);\n} thing = {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, func};                 \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// assign values to the struct variable\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; * \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;xF\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*p)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *pStr))\u0026lt;/span\u0026gt;;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// declare a function that has a function pointer as an argument\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; * (*pxF) (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*p)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *pStr));  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// declare a function pointer that points to a function that has a function pointer as an argument\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You can use variable length parameter lists in the definition of a function pointer.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sum\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; b, ...)\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*psum)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; b, ...);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Or you can not specify a parameter list at all. This can be useful but it eliminates the opportunity for the C compiler to perform checks on the argument list provided. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sum\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;;      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// nothing specified in the argument list so could be anything or nothing\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*psum)();\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sum2\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// void specified in the argument list so no parameters when calling this function\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*psum2)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;C style Casts\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can use C style casts with function pointers. However be aware that a C compiler may be lax about checks or provide warnings rather than errors.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sum\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *b)\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*psplsum) (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; b);\npsplsum = sum;               \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// generates a compiler warning\u0026lt;/span\u0026gt;\npsplsum = (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; b)) sum;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// no compiler warning, cast to function pointer\u0026lt;/span\u0026gt;\npsplsum = (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; b)) sum;     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// compiler error of bad cast generated, parenthesis are required.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Compare Function Pointer to Equality\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can check that a function pointer is equal to a particular function address using an \u0026lt;code\u0026gt;if\u0026lt;/code\u0026gt; statement though I am not sure how useful that would be. Other comparison operators would seem to have even less utility.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;func1\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; b)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; a + b;\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;func2\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; b, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *c)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; c[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] + a + b;\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;func3\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; b, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *x)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; a + b;\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;func4\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; b, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *c, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*p)())\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (p == func1) {\n        p(a, b);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (p == func2) {\n        p(a, b, c);      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// warning C4047: \u0026apos;==\u0026apos;: \u0026apos;int (__cdecl *)()\u0026apos; differs in levels of indirection from \u0026apos;char *(__cdecl *)(int,int,char *)\u0026apos;\u0026lt;/span\u0026gt;\n    } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (p == func3) {\n        p(a, b, c);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; c;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;An Array of Function Pointers\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;And if you want to have an array of function pointers each of the elements of which the argument list has differences then you can define a function pointer with the argument list unspecified (not \u0026lt;code\u0026gt;void\u0026lt;/code\u0026gt; which means no arguments but just unspecified) something like the following though you may see warnings from the C compiler. This also works for a function pointer parameter to a function:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;(*p[])() = {       \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// an array of function pointers\u0026lt;/span\u0026gt;\n    func1, func2, func3\n};\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;(**pp)();          \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// a pointer to a function pointer\u0026lt;/span\u0026gt;\n\n\np[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;](a, b);\np[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;](a, b, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\np[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;](a, b);      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// oops, left off the last argument but it compiles anyway.\u0026lt;/span\u0026gt;\n\nfunc4(a, b, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, func1);\nfunc4(a, b, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, func2);  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// warning C4047: \u0026apos;function\u0026apos;: \u0026apos;int (__cdecl *)()\u0026apos; differs in levels of indirection from \u0026apos;char *(__cdecl *)(int,int,char *)\u0026apos;\u0026lt;/span\u0026gt;\nfunc4(a, b, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, func3);\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// iterate over the array elements using an array index\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(p) / \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]); i++) {\n    func4(a, b, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, p[i]);\n}\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// iterate over the array elements using a pointer\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (pp = p; pp \u0026amp;lt; p + \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(p)/\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]); pp++) {\n    (*pp)(a, b, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);          \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// pointer to a function pointer so must dereference it.\u0026lt;/span\u0026gt;\n    func4(a, b, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, *pp);     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// pointer to a function pointer so must dereference it.\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;C style \u0026lt;code\u0026gt;namespace\u0026lt;/code\u0026gt; Using Global \u0026lt;code\u0026gt;struct\u0026lt;/code\u0026gt; with Function Pointers\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can use the \u0026lt;code\u0026gt;static\u0026lt;/code\u0026gt; keyword to specify a function whose name is file scope and then assign this to a global variable as a way of providing something similar to the \u0026lt;code\u0026gt;namespace\u0026lt;/code\u0026gt; functionality of C++.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In a header file define a struct that will be our namespace along with a global variable that uses it.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-class\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; {\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*func1) (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; b);             \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// pointer to function that returns an int\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *(*func2) (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; b, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *c);  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// pointer to function that returns a pointer\u0026lt;/span\u0026gt;\n} FuncThings;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extern\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; FuncThings FuncThingsGlobal;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Then in the C source file:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;header.h\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// the function names used with these static functions do not need to be the\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// same as the struct member names. It\u0026apos;s just helpful if they are when trying\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// to search for them.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// the static keyword ensures these names are file scope only and not visible\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// outside of the file.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;func1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; b)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; a + b;\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;func2\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; b, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *c)\u0026lt;/span\u0026gt;\n{\n    c[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = a % \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;; c[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] = b % \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;50\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; c;\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; FuncThings FuncThingsGlobal = {func1, func2};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This would then be used by specifying the complete name of global struct variable and member name to access the function. The \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt; modifier is used on the global so that it can not be changed by accident.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; abcd = FuncThingsGlobal.func1 (a, b);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Application Areas of Function Pointers\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A DLL library component could do something similar to the C style \u0026lt;code\u0026gt;namespace\u0026lt;/code\u0026gt; approach in which a particular library interface is requested from a factory method in a library interface which supports the creation of a \u0026lt;code\u0026gt;struct\u0026lt;/code\u0026gt; containing function pointers.. This library interface loads the requested DLL version, creates a struct with the necessary function pointers, and then returns the struct to the requesting caller for use.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-class\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; {\u0026lt;/span\u0026gt;\n    HMODULE  hModule;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*Func1)();\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*Func2)();\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;(*Func3)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; b);\n} LibraryFuncStruct;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;  LoadLibraryFunc LPCTSTR  dllFileName, LibraryFuncStruct *pStruct)\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;  retStatus = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// default is an error detected\u0026lt;/span\u0026gt;\n\n    pStruct-\u0026amp;gt;hModule = LoadLibrary (dllFileName);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (pStruct-\u0026amp;gt;hModule) {\n        pStruct-\u0026amp;gt;Func1 = (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*)()) GetProcAddress (pStruct-\u0026amp;gt;hModule, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Func1\u0026quot;\u0026lt;/span\u0026gt;);\n        pStruct-\u0026amp;gt;Func2 = (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*)()) GetProcAddress (pStruct-\u0026amp;gt;hModule, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Func2\u0026quot;\u0026lt;/span\u0026gt;);\n        pStruct-\u0026amp;gt;Func3 = (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; b)) GetProcAddress(pStruct-\u0026amp;gt;hModule, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Func3\u0026quot;\u0026lt;/span\u0026gt;);\n        retStatus = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; retStatus;\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;FreeLibraryFunc\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(LibraryFuncStruct *pStruct)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (pStruct-\u0026amp;gt;hModule) FreeLibrary (pStruct-\u0026amp;gt;hModule);\n    pStruct-\u0026amp;gt;hModule = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and this could be used as in:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;LibraryFuncStruct myLib = {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;};\nLoadLibraryFunc (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026quot;library.dll\u0026quot;\u0026lt;/span\u0026gt;, \u0026amp;amp;myLib);\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  ....\u0026lt;/span\u0026gt;\nmyLib.Func1();\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  ....\u0026lt;/span\u0026gt;\nFreeLibraryFunc (\u0026amp;amp;myLib);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The same approach can be used to define an abstract hardware layer for code that uses a particular model of the underlying hardware. Function pointers are filled in with hardware specific functions by a factory to provide the hardware specific functionality that implements functions specified in the abstract hardware model. This can be used to provide an abstract hardware layer used by software which calls a factory function in order to get the specific hardware function interface then uses the function pointers provided to perform actions for the underlying hardware without needing to know implementation details about the specific target.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Function Pointers to create Delegates, Handlers, and Callbacks\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can use function pointers as a way to delegate some task or functionality. The classic example in C is the comparison delegate function pointer used with the Standard C library functions \u0026lt;code\u0026gt;qsort()\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;bsearch()\u0026lt;/code\u0026gt; to provide the collation order for sorting a list of items or performing a binary search over a sorted list of items. The comparison function delegate specifies the collation algorithm used in the sort or the binary search.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Another use is similar to applying an algorithm to a C++ Standard Template Library container.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; * \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;ApplyAlgorithm\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; *pArray, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; sizeItem, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; nItems, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*p)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; *))\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *pList = pArray;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *pListEnd = pList + nItems * sizeItem;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; ( ; pList \u0026amp;lt; pListEnd; pList += sizeItem) {\n        p (pList);\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; pArray;\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;pIncrement\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *pI)\u0026lt;/span\u0026gt; {\n    (*pI)++;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; * \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;ApplyFold\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; *pArray, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; sizeItem, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; nItems, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; * pResult, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;(*p)(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; *, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; *))\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *pList = pArray;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *pListEnd = pList + nItems * sizeItem;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (; pList \u0026amp;lt; pListEnd; pList += sizeItem) {\n        p(pList, pResult);\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; pArray;\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;pSummation\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *pI, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *pSum)\u0026lt;/span\u0026gt; {\n    (*pSum) += *pI;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// source code and then lets use our function.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; intList[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;30\u0026lt;/span\u0026gt;] = { \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; }, iSum = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\nApplyAlgorithm(intList, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;), \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(intList) / \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(intList[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]), pIncrement);\nApplyFold(intList, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;), \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(intList) / \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(intList[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]), \u0026amp;amp;iSum, pSummation);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Another example is with GUI source code in which a handler for a particular event is registered by providing a function pointer which is actually called when the event happens. The Microsoft MFC framework with its message maps uses something similar to handle Windows messages that are delivered to a window or thread.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Asynchronous functions that require a callback are similar to an event handler. The user of the asynchronous function calls the asynchronous function to start some action and provides a function pointer which the asynchronous function will call once the action is complete. In this case the event is the asynchronous function completing its task.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Since function pointers are often typed callbacks, you might want to have a look at \u0026lt;a href=\u0026quot;http://ccan.ozlabs.org/info/typesafe_cb.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;type safe callbacks\u0026lt;/a\u0026gt;. The same applies to entry points, etc of functions that are not callbacks.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;C is quite fickle and forgiving at the same time :)\u0026lt;/p\u0026gt;\n    "],"id":532,"title":"How do function pointers in C work?","content":"\n                \n\u0026lt;p\u0026gt;I had some experience lately with function pointers in C.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So going on with the tradition of answering your own questions, I decided to make a small summary of the very basics, for those who need a quick dive-in to the subject.\u0026lt;/p\u0026gt;\n    ","slug":"how-do-function-pointers-in-c-work-1657388332074","postType":"QUESTION","createdAt":"2022-07-09T17:38:52.000Z","updatedAt":"2022-07-09T17:38:52.000Z","tags":[{"id":2614,"name":"function-pointers","slug":"function-pointers","createdAt":"2022-07-09T17:38:52.000Z","updatedAt":"2022-07-09T17:38:52.000Z","Questions_Tags":{"questionId":532,"tagId":2614}}],"relatedQuestions":[{"title":"How do function pointers in C work?","slug":"how-do-function-pointers-in-c-work-1657388332074","tags":[{"name":"function-pointers","Questions_Tags":{"questionId":532,"tagId":2614}}]}]},"randomQuestions":[{"title":"What is the canonical way to check for errors using the CUDA runtime API?","slug":"what-is-the-canonical-way-to-check-for-errors-using-the-cuda-runtime-api-1657387302698"},{"title":"Big O, how do you calculate/approximate it?","slug":"big-o-how-do-you-calculateapproximate-it-1657387856392"},{"title":"Is there any way to kill a Thread?","slug":"is-there-any-way-to-kill-a-thread-1657387859831"},{"title":"What is the difference between \"INNER JOIN\" and \"OUTER JOIN\"?","slug":"what-is-the-difference-between-\"inner-join\"-and-\"outer-join\"-1657387501982"},{"title":"What is JavaScript's highest integer value that a number can go to without losing precision?","slug":"what-is-javascript's-highest-integer-value-that-a-number-can-go-to-without-losing-precision-1657387622983"},{"title":"How can I get useful error messages in PHP?","slug":"how-can-i-get-useful-error-messages-in-php-1657384609065"},{"title":"How to make good reproducible pandas examples","slug":"how-to-make-good-reproducible-pandas-examples-1657384310402"},{"title":"Why should I not #include \u003cbits/stdc++.h\u003e?","slug":"why-should-i-not-include-lessbitsstdc++.hgreater-1657384470484"},{"title":"WebDriverWait not working as expected","slug":"webdriverwait-not-working-as-expected-1657387373148"},{"title":"Sorting object property by values","slug":"sorting-object-property-by-values-1657388367300"},{"title":"What are metaclasses in Python?","slug":"what-are-metaclasses-in-python-1657387811608"},{"title":"What does the 'static' keyword do in a class?","slug":"what-does-the-'static'-keyword-do-in-a-class-1657388554238"},{"title":"How can I tell if a DOM element is visible in the current viewport?","slug":"how-can-i-tell-if-a-dom-element-is-visible-in-the-current-viewport-1657388316510"},{"title":"Undefined, unspecified and implementation-defined behavior","slug":"undefined-unspecified-and-implementation-defined-behavior-1657384516085"},{"title":"How do I check if an array includes a value in JavaScript?","slug":"how-do-i-check-if-an-array-includes-a-value-in-javascript-1657387421185"},{"title":"Selenium \"selenium.common.exceptions.NoSuchElementException\" when using Chrome","slug":"selenium-\"selenium.common.exceptions.nosuchelementexception\"-when-using-chrome-1657388136699"},{"title":"How to join (merge) data frames (inner, outer, left, right)","slug":"how-to-join-(merge)-data-frames-(inner-outer-left-right)-1657384406445"},{"title":"Why does the order in which libraries are linked sometimes cause errors in GCC?","slug":"why-does-the-order-in-which-libraries-are-linked-sometimes-cause-errors-in-gcc-1657387609554"},{"title":"How to remove items from a list while iterating?","slug":"how-to-remove-items-from-a-list-while-iterating-1657384496375"},{"title":"How can I combine two strings together in PHP?","slug":"how-can-i-combine-two-strings-together-in-php-1657388279401"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"how-do-function-pointers-in-c-work-1657388332074"},"buildId":"BnkbnjkWYxefPXjTJLVVv","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>