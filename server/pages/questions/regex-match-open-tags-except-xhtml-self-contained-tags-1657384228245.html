<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2eccd4d47c856f2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2eccd4d47c856f2b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/471-84c36aa98dd4107c.js" defer=""></script><script src="/_next/static/chunks/81-096e453de8a27667.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-e3d1b60e109d3ba1.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_buildManifest.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.hFcsiD code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-6e32c308-0"]{content:"hFcsiD,"}/*!sc*/
.ljvTUN .comment-item .comment-body .d-inline-flex.ai-center{text-align:right;}/*!sc*/
.ljvTUN .comment-item .comment-body .comment-date{float:right;}/*!sc*/
data-styled.g6[id="sc-6e32c308-1"]{content:"ljvTUN,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="https://flowbite.com/docs/images/logo.svg" class="mr-3 h-6 sm:h-9" alt="Flowbite Logo"/><span class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Hunter</span></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/regex-match-open-tags-except-xhtml-self-contained-tags-1657384228245#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-6e32c308-0 hFcsiD flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/regex-match-open-tags-except-xhtml-self-contained-tags-1657384228245">RegEx match open tags except XHTML self-contained tags</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/regex">regex</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/xhtml">xhtml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/html">html</a></div></div><div class="question-content mt-5">
                    <div>
            <aside class="s-notice s-notice__info post-notice js-post-notice mb16" role="status">
        <div class="d-flex fd-column fw-nowrap">
            <div class="d-flex fw-nowrap">
                    <div class="flex--item mr8">
                        <svg aria-hidden="true" class="svg-icon iconLock" width="18" height="18" viewBox="0 0 18 18"><path d="M16 9a2 2 0 0 0-2-2V6A5 5 0 0 0 4 6v1a2 2 0 0 0-2 2v6c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V9Zm-7 5a2 2 0 1 1 0-4 2 2 0 0 1 0 4Zm3.1-7H5.9V6a3.1 3.1 0 0 1 6.2 0v1Z"></path></svg>
                    </div>
                <div class="flex--item wmn0 fl1 lh-lg">
                    <div class="flex--item fl1 lh-lg">
                        <b>Locked</b>. Comments on this question have been disabled, but it is still accepting new answers and other interactions. <a href="/help/locked-posts">Learn more</a>.
                        
                    </div>
                </div>
            </div>
        </div>
</aside>

    </div>

<p>I need to match all of these opening tags:</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"foo"</span>&gt;</span>
</code></pre>

<p>But not these:</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">hr</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"foo"</span> /&gt;</span>
</code></pre>

<p>I came up with this and wanted to make sure I've got it right. I am only capturing the <code>a-z</code>.</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml">&lt;([a-z]+) *[^/]*?&gt;
</code></pre>

<p>I believe it says:</p>

<ul>
<li>Find a less-than, then</li>
<li>Find (and capture) a-z one or more times, then</li>
<li>Find zero or more spaces, then</li>
<li>Find any character zero or more times, greedy, except <code>/</code>, then</li>
<li>Find a greater-than</li>
</ul>

<p>Do I have that right? And more importantly, what do you think?</p>
    </div></div></div><div class="sc-6e32c308-1 ljvTUN flex text-xs pl-10 flex-col comment items-center justify-center"><h4 class="text-left mt-10 text-lg font-semibold">Comments</h4><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy">Kobi: I think it's time for me to quit the post of Assistant Don't Parse HTML With Regex Officer. No matter how many times we say it, they won't stop coming every day... every hour even. It is a lost cause, which someone else can fight for a bit. So go on, parse HTML with regex, if you must. It's only broken code, not life and death.</span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/18936/bobince" title="515,904 reputation" class="comment-user">bobince</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment1612336_1732454"><span title="2009-11-13 23:18:03Z, License: CC BY-SA 2.5" class="relativetime-clean">Nov 13, 2009 at 23:18</span></a></span>
            </div>
        </div><span class="divide-x-8 "></span><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy">If you can't see this post, here's a screencapture of it in all its glory: <a href="http://imgur.com/gOPS2.png" rel="nofollow noreferrer">imgur.com/gOPS2.png</a></span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/68086/andrew-keeton" title="20,787 reputation" class="comment-user">Andrew Keeton</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment1647711_1732454"><span title="2009-11-19 14:37:27Z, License: CC BY-SA 2.5" class="relativetime-clean">Nov 19, 2009 at 14:37</span></a></span>
                        <span title="this comment was edited 1 time">
                            <svg aria-hidden="true" class="va-text-bottom o50 svg-icon iconPencilSm" width="14" height="14" viewBox="0 0 14 14"><path d="m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z"></path></svg>
                        </span>
            </div>
        </div><span class="divide-x-8 "></span><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy">Also, scraping fairly regularly formatted data from large documents is going to be WAY faster with judicious use of scan &amp; regex than any generic parser. And if you are comfortable with coding regexes, way faster to code than coding xpaths. And almost certainly less fragile to changes in what you are scraping. So bleh.</span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/173542/michael-johnston" title="5,208 reputation" class="comment-user">Michael Johnston</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment13095248_1733489"><span title="2012-04-17 20:47:27Z, License: CC BY-SA 3.0" class="relativetime-clean">Apr 17, 2012 at 20:47</span></a></span>
            </div>
        </div><span class="divide-x-8 "></span><button class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">See more</button></div><div class="sc-6e32c308-2 bFXWFO"><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
                    <div>
            <aside class="s-notice s-notice__info post-notice js-post-notice mb16" role="status">
        <div class="d-flex fd-column fw-nowrap">
            <div class="d-flex fw-nowrap">
                    <div class="flex--item mr8">
                        <svg aria-hidden="true" class="svg-icon iconLock" width="18" height="18" viewBox="0 0 18 18"><path d="M16 9a2 2 0 0 0-2-2V6A5 5 0 0 0 4 6v1a2 2 0 0 0-2 2v6c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V9Zm-7 5a2 2 0 1 1 0-4 2 2 0 0 1 0 4Zm3.1-7H5.9V6a3.1 3.1 0 0 1 6.2 0v1Z"></path></svg>
                    </div>
                <div class="flex--item wmn0 fl1 lh-lg">
                    <div class="flex--item fl1 lh-lg">
                        <b>Locked</b>. There are <a href="/help/locked-posts">disputes about this answers content</a> being resolved at this time. It is not currently accepting new interactions.
                        
                    </div>
                </div>
            </div>
        </div>
</aside>

    </div>

<p>You can't parse [X]HTML with regex. Because HTML can't be parsed by regex. Regex is not a tool that can be used to correctly parse HTML. As I have answered in HTML-and-regex questions here so many times before, the use of regex will not allow you to consume HTML. Regular expressions are a tool that is insufficiently sophisticated to understand the constructs employed by HTML. HTML is not a regular language and hence cannot be parsed by regular expressions. Regex queries are not equipped to break down HTML into its meaningful parts. so many times but it is not getting to me. Even enhanced irregular regular expressions as used by Perl are not up to the task of parsing HTML. You will never make me crack. HTML is a language of sufficient complexity that it cannot be parsed by regular expressions. Even Jon Skeet cannot parse HTML using regular expressions. Every time you attempt to parse HTML with regular expressions, the unholy child weeps the blood of virgins, and Russian hackers pwn your webapp. Parsing HTML with regex summons tainted souls into the realm of the living. HTML and regex go together like love, marriage, and ritual infanticide. The &lt;center&gt; cannot hold it is too late. The force of regex and HTML together in the same conceptual space will destroy your mind like so much watery putty. If you parse HTML with regex you are giving in to Them and their blasphemous ways which doom us all to inhuman toil for the One whose Name cannot be expressed in the Basic Multilingual Plane, he comes. HTML-plus-regexp will liquify the nerves of the sentient whilst you observe, your psyche withering in the onslaught of horror. Rege̿̔̉x-based HTML parsers are the cancer that is killing StackOverflow <i>it is too late it is too late we cannot be saved</i> the transgression of a chi͡ld ensures regex will consume all living tissue (except for HTML which it cannot, as previously prophesied) <i>dear lord help us how can anyone survive this scourge</i> using regex to parse HTML has doomed humanity to an eternity of dread torture and security holes <i>using rege</i>x as a tool to process HTML establishes a brea<i>ch between this world</i> and the dread realm of c͒ͪo͛ͫrrupt entities (like SGML entities, but <i>more corrupt) a mere glimp</i>se of the world of reg<b>ex parsers for HTML will ins</b>tantly transport a p<i>rogrammer's consciousness i</i>nto a w<i>orl</i>d of ceaseless screaming, he comes<strike>, the pestilent sl</strike>ithy regex-infection wil<b>l devour your HT</b>ML parser, application and existence for all time like Visual Basic only worse <i>he comes he com</i>es <i>do not fi</i>ght h<b>e com̡e̶s, ̕h̵i</b>s un̨ho͞ly radiańcé de<i>stro҉ying all enli̍̈́̂̈́ghtenment, HTML tags <b>lea͠ki̧n͘g fr̶ǫm ̡yo͟ur eye͢s̸ ̛l̕ik͏e liq</b>uid p</i>ain, the song of re̸gular expre<strike>ssion parsing </strike>will exti<i>nguish the voices of mor<b>tal man from the sp</b>here I can see it can you see ̲͚̖͔̙î̩́t̲͎̩̱͔́̋̀ it is beautiful t</i>he f<code>inal snuf</code>fing o<i>f the lie<b>s of Man ALL IS LOŚ͖̩͇̗̪̏̈́T A</b></i><b>LL IS L</b>OST th<i>e pon̷y he come</i>s he c̶̮om<strike>es he co</strike><b><strike>me</strike>s t<i>he</i> ich</b>or permeat<i>es al</i>l MY FAC<i>E MY FACE h god n<b>o NO NOO̼</b></i><b>OO N</b>Θ stop t<i>he an*̶͑̾̾̅ͫ͏̙̤g͇̫͛͆̾ͫ̑͆l͖͉̗̩̳̟̍ͫͥͨ</i>e̠̅s<code> ͎a̧͈͖r̽̾̈́͒͑e</code> n<b>ot rè̑ͧ̌aͨl̘̝̙̃ͤ͂̾̆ ZA̡͊͠͝LGΌ ISͮ̂҉̯͈͕̹̘̱ T</b>O͇̹̺ͅƝ̴ȳ̳ TH̘<b>Ë͖́̉ ͠P̯͍̭O̚N̐Y̡ H̸̡̪̯ͨ͊̽̅̾̎Ȩ̬̩̾͛ͪ̈́̀́͘ ̶̧̨̱̹̭̯ͧ̾ͬC̷̙̲̝͖ͭ̏ͥͮ͟Oͮ͏̮̪̝͍M̲̖͊̒ͪͩͬ̚̚͜Ȇ̴̟̟͙̞ͩ͌͝</b>S̨̥̫͎̭ͯ̿̔̀ͅ</p>
<hr>
<p>Have you tried using an XML parser instead?</p>
<hr>
<blockquote>
<p><strong>Moderator's Note</strong></p>
<p>This post is locked to prevent inappropriate edits to its content. The post looks exactly as it is supposed to look - there are no problems with its content. Please do not flag it for our attention.</p>
</blockquote>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>While <em>arbitrary</em> HTML with only a regex is impossible, it's sometimes appropriate to use them for parsing a <em>limited, known</em> set of HTML.  </p>

<p>If you have a small set of HTML pages that you want to scrape data from and then stuff into a database, regexes might work fine.  For example, I recently wanted to get the names, parties, and districts of Australian federal Representatives, which I got off of the Parliament's web site.  This was a limited, one-time job.  </p>

<p>Regexes worked just fine for me, and were very fast to set up.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I think the flaw here is that HTML is a <a href="http://en.wikipedia.org/wiki/Context-free_grammar" rel="noreferrer">Chomsky Type 2 grammar (context free grammar)</a> and a regular expression is a <a href="http://en.wikipedia.org/wiki/Regular_grammar" rel="noreferrer">Chomsky Type 3 grammar (regular grammar)</a>. Since a Type 2 grammar is fundamentally more complex than a Type 3 grammar (see the <a href="http://en.wikipedia.org/wiki/Chomsky_hierarchy" rel="noreferrer">Chomsky hierarchy</a>), it is <em>mathematically impossible</em> to parse XML with a regular expression.</p>
<p>But many will try, and some will even claim success - but until others find the fault and totally mess you up.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Don't listen to these guys. You totally <strong>can</strong> parse context-free grammars with regex if you break the task into smaller pieces. You can generate the correct pattern with a script that does each of these in order: </p>

<ol>
<li>Solve the Halting Problem.</li>
<li>Square a circle.</li>
<li>Work out the Traveling Salesman Problem in O(log n) or less. If it's any more than that, you'll run out of RAM and the engine will hang.</li>
<li>The pattern will be pretty big, so make sure you have an algorithm that losslessly compresses random data.</li>
<li>Almost there - just divide the whole thing by zero. Easy-peasy.</li>
</ol>

<p>I haven't quite finished the last part myself, but I know I'm getting close. It keeps throwing <code>CthulhuRlyehWgahnaglFhtagnException</code>s for some reason, so I'm going to port it to VB 6 and use <code>On Error Resume Next</code>. I'll update with the code once I investigate this strange door that just opened in the wall. Hmm.</p>

<p>P.S. Pierre de Fermat also figured out how to do it, but the margin he was writing in wasn't big enough for the code.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Disclaimer</strong>: use a parser if you have the option. That said...</p>

<p>This is the regex I use (!) to match HTML tags:</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml">&lt;(?:"[^"]*"['"]*|'[^']*'['"]*|[^'"&gt;])+&gt;
</code></pre>

<p>It may not be perfect, but I ran this code through a <em>lot</em> of HTML. Note that it even catches strange things like <code>&lt;a name="badgenerator""&gt;</code>, which show up on the web.</p>

<p>I guess to make it not match self contained tags, you'd either want to use <a href="https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732395#1732395">Kobi</a>'s negative look-behind:</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml">&lt;(?:"[^"]*"['"]*|'[^']*'['"]*|[^'"&gt;])+(?&lt;!/\s*)&gt;
</code></pre>

<p>or just combine if and if not.</p>

<p><strong>To downvoters:</strong> This is working code from an actual product. I doubt anyone reading this page will get the impression that it is socially acceptable to use regexes on HTML. </p>

<p><strong>Caveat</strong>: I should note that this regex still breaks down in the presence of CDATA blocks, comments, and script and style elements. Good news is, you can get rid of those using a regex...  </p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There are people that will tell you that the Earth is round (or perhaps that the Earth is an oblate spheroid if they want to use strange words). They are lying.</p>
<p>There are people that will tell you that Regular Expressions shouldn't be recursive. They are limiting you. They need to subjugate you, and they do it by keeping you in ignorance.</p>
<p>You can live in their reality or take the red pill.</p>
<p>Like Lord Marshal (is he a relative of the Marshal .NET class?), I have seen the <strike>Underverse</strike> Stack Based Regex-Verse and returned with <strike>powers</strike> knowledge you can't imagine. Yes, I think there were an Old One or two protecting them, but they were watching football on the TV, so it wasn't difficult.</p>
<p>I think the XML case is quite simple. The RegEx (in the .NET syntax), deflated and coded in base64 to make it easier to comprehend by your feeble mind, should be something like this:</p>
<pre class="lang-html s-code-block"><code class="hljs language-xml">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
+r/vD34mUADO1P4/AQAA//8=
</code></pre>
<p>The options to set is <code>RegexOptions.ExplicitCapture</code>. The capture group you are looking for is <code>ELEMENTNAME</code>. If the capture group <code>ERROR</code> is not empty then there was a parsing error and the Regex stopped.</p>
<p>If you have problems reconverting it to a human-readable regex, this should help:</p>
<pre class="lang-csharp s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">FromBase64</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> str</span>)</span>
{
    <span class="hljs-built_in">byte</span>[] byteArray = Convert.FromBase64String(str);

    <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> msIn = <span class="hljs-keyword">new</span> MemoryStream(byteArray))
    <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> msOut = <span class="hljs-keyword">new</span> MemoryStream()) {
        <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> ds = <span class="hljs-keyword">new</span> DeflateStream(msIn, CompressionMode.Decompress)) {
            ds.CopyTo(msOut);
        }

        <span class="hljs-keyword">return</span> Encoding.UTF8.GetString(msOut.ToArray());
    }
}
</code></pre>
<p>If you are unsure, no, I'm NOT kidding (but perhaps I'm lying). It WILL work. I've built tons of unit tests to test it, and I have even used (part of) the <a href="http://www.w3.org/XML/Test/" rel="noreferrer">conformance tests</a>. It's a tokenizer, not a full-blown parser, so it will only split the XML into its component tokens. It won't parse/integrate DTDs.</p>
<p>Oh... if you want the source code of the regex, with some auxiliary methods:</p>
<p><a href="http://pastebin.com/hzYazFVb" rel="noreferrer">regex to tokenize an xml</a> or <a href="https://topaz.github.io/paste/#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" rel="noreferrer">the full plain regex</a></p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In shell, you can parse <a href="https://en.wikipedia.org/wiki/HTML" rel="noreferrer">HTML</a> using <a href="https://en.wikipedia.org/wiki/Sed" rel="noreferrer">sed</a>:</p>

<ol>
<li><a href="http://sed.sourceforge.net/grabbag/scripts/turing.sed" rel="noreferrer">Turing.sed</a></li>
<li>Write HTML parser (homework)</li>
<li>???</li>
<li>Profit!</li>
</ol>

<hr>

<p>Related (why you shouldn't use regex match):</p>

<ul>
<li><a href="https://blog.codinghorror.com/if-you-like-regular-expressions-so-much-why-dont-you-marry-them/" rel="noreferrer">If You Like Regular Expressions So Much, Why Don't You Marry Them?</a></li>
<li><a href="https://blog.codinghorror.com/regular-expressions-now-you-have-two-problems/" rel="noreferrer">Regular Expressions: Now You Have Two Problems</a></li>
<li><a href="http://danlec.com/blog/hacking-stackoverflow-com-s-html-sanitizer" rel="noreferrer">Hacking stackoverflow.com's HTML sanitizer</a></li>
</ul>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I agree that the right tool to parse XML and <em>especially HTML</em> is a parser and not a regular expression engine. However, like others have pointed out, sometimes using a regex is quicker, easier, and gets the job done if you know the data format.</p>

<p>Microsoft actually has a section of <a href="https://docs.microsoft.com/dotnet/standard/base-types/best-practices" rel="noreferrer">Best Practices for Regular Expressions in the .NET Framework</a> and specifically talks about <a href="https://docs.microsoft.com/dotnet/standard/base-types/best-practices#consider-the-input-source" rel="noreferrer">Consider[ing] the Input Source</a>.</p>

<p>Regular Expressions do have limitations, but have you considered the following?</p>

<p>The .NET framework is unique when it comes to regular expressions in that it supports <a href="https://docs.microsoft.com/dotnet/standard/base-types/grouping-constructs-in-regular-expressions#balancing_group_definition" rel="noreferrer">Balancing Group Definitions</a>.</p>

<ul>
<li>See <a href="https://weblogs.asp.net/whaggard/377025" rel="noreferrer">Matching Balanced Constructs with .NET Regular Expressions</a></li>
<li>See <a href="https://docs.microsoft.com/archive/blogs/bclteam/net-regular-expressions-regex-and-balanced-matching-ryan-byington" rel="noreferrer">.NET Regular Expressions: Regex and Balanced Matching</a></li>
<li>See Microsoft's docs on <a href="https://docs.microsoft.com/dotnet/standard/base-types/grouping-constructs-in-regular-expressions#balancing_group_definition" rel="noreferrer">Balancing Group Definitions</a></li>
</ul>

<p>For this reason, I believe you CAN parse XML using regular expressions. Note however, that it <strong>must be valid XML</strong> (<em>browsers are very forgiving of HTML and allow bad XML syntax inside HTML</em>). This is possible since the "Balancing Group Definition" will allow the regular expression engine to act as a PDA.</p>

<p>Quote from article 1 cited above:</p>

<blockquote>
  <p><strong>.NET Regular Expression Engine</strong></p>
  
  <p>As described above properly balanced constructs cannot be described by
  a regular expression. However, the .NET regular expression engine
  provides a few constructs that allow balanced constructs to be
  recognized. </p>
  
  <ul>
  <li><code>(?&lt;group&gt;)</code> - pushes the captured result on the capture stack with
  the name group.</li>
  <li><code>(?&lt;-group&gt;)</code> - pops the top most capture with the name group off the
  capture stack.</li>
  <li><code>(?(group)yes|no)</code> - matches the yes part if there exists a group
  with the name group otherwise matches no part.</li>
  </ul>
  
  <p>These constructs allow for a .NET regular expression to emulate a
  restricted PDA by essentially allowing simple versions of the stack
  operations: push, pop and empty. The simple operations are pretty much
  equivalent to increment, decrement and compare to zero respectively.
  This allows for the .NET regular expression engine to recognize a
  subset of the context-free languages, in particular the ones that only
  require a simple counter. This in turn allows for the non-traditional
  .NET regular expressions to recognize individual properly balanced
  constructs.</p>
</blockquote>

<p>Consider the following regular expression:</p>

<pre class="lang-none s-code-block"><code>(?=&lt;ul\s+id="matchMe"\s+type="square"\s*&gt;)
(?&gt;
   &lt;!-- .*? --&gt;                  |
   &lt;[^&gt;]*/&gt;                      |
   (?&lt;opentag&gt;&lt;(?!/)[^&gt;]*[^/]&gt;)  |
   (?&lt;-opentag&gt;&lt;/[^&gt;]*[^/]&gt;)     |
   [^&lt;&gt;]*
)*
(?(opentag)(?!))
</code></pre>

<p>Use the flags:</p>

<ul>
<li>Singleline</li>
<li>IgnorePatternWhitespace (not necessary if you collapse regex and remove all whitespace)</li>
<li>IgnoreCase (not necessary)</li>
</ul>

<h2>Regular Expression Explained (inline)</h2>

<pre class="lang-none s-code-block"><code>(?=&lt;ul\s+id="matchMe"\s+type="square"\s*&gt;) # match start with &lt;ul id="matchMe"...
(?&gt;                                        # atomic group / don't backtrack (faster)
   &lt;!-- .*? --&gt;                 |          # match xml / html comment
   &lt;[^&gt;]*/&gt;                     |          # self closing tag
   (?&lt;opentag&gt;&lt;(?!/)[^&gt;]*[^/]&gt;) |          # push opening xml tag
   (?&lt;-opentag&gt;&lt;/[^&gt;]*[^/]&gt;)    |          # pop closing xml tag
   [^&lt;&gt;]*                                  # something between tags
)*                                         # match as many xml tags as possible
(?(opentag)(?!))                           # ensure no 'opentag' groups are on stack
</code></pre>

<p>You can try this at <a href="http://derekslager.com/blog/posts/2007/09/a-better-dotnet-regular-expression-tester.ashx" rel="noreferrer">A Better .NET Regular Expression Tester</a>.</p>

<p>I used the sample source of:</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"matchMe"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"square"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>stuff...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>more stuff<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>still more<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Another <span class="hljs-symbol">&amp;gt;</span>ul<span class="hljs-symbol">&amp;lt;</span>, oh my!<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
               <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>

<p>This found the match:</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"matchMe"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"square"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>stuff...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>more stuff<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>still more<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Another <span class="hljs-symbol">&amp;gt;</span>ul<span class="hljs-symbol">&amp;lt;</span>, oh my!<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
               <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>

<p>although it actually came out like this:</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"matchMe"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"square"</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>stuff...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>more stuff<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>still more<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>                         <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Another <span class="hljs-symbol">&amp;gt;</span>ul<span class="hljs-symbol">&amp;lt;</span>, oh my!<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>                         <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>               <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>           <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>

<p>Lastly, I really enjoyed Jeff Atwood's article:  <a href="https://blog.codinghorror.com/parsing-html-the-cthulhu-way/" rel="noreferrer">Parsing Html The Cthulhu Way</a>. Funny enough, it cites the answer to this question that currently has over 4k votes.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I suggest using <a href="http://querypath.org/" rel="noreferrer">QueryPath</a> for parsing XML and HTML in PHP.  It's basically much the same syntax as jQuery, only it's on the server side.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>While the answers that you can't parse HTML with regexes are correct, they don't apply here. The OP just wants to parse one HTML tag with regexes, and that is something that can be done with a regular expression.</p>

<p>The suggested regex is wrong, though:</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml">&lt;([a-z]+) *[^/]*?&gt;
</code></pre>

<p>If you add something to the regex, by backtracking it can be forced to match silly things like <code>&lt;a &gt;&gt;</code>, <code>[^/]</code> is too permissive. Also note that <code>&lt;space&gt;*[^/]*</code> is redundant, because the <code>[^/]*</code> can also match spaces.</p>

<p>My suggestion would be</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml">&lt;([a-z]+)[^&gt;]*(?&lt;!/)&gt;
</code></pre>

<p>Where <code>(?&lt;! ... )</code> is (in Perl regexes) the negative look-behind. It reads "a &lt;, then a word, then anything that's not a &gt;, the last of which may not be a /, followed by &gt;".</p>

<p>Note that this allows things like <code>&lt;a/ &gt;</code> (just like the original regex), so if you want something more restrictive, you need to build a regex to match attribute pairs separated by spaces.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Try:</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml">&lt;([^\s]+)(\s[^&gt;]*?)?(?&lt;!/)&gt;
</code></pre>

<p>It is similar to yours, but the last <code>&gt;</code> must not be after a slash, and also accepts <code>h1</code>.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Sun Tzu, an ancient Chinese strategist, general, and philosopher, said:</p>

<blockquote>
  <p>It is said that if you know your enemies and know yourself, you can win a hundred battles without a single loss.
  If you only know yourself, but not your opponent, you may win or may lose.
  If you know neither yourself nor your enemy, you will always endanger yourself.</p>
</blockquote>

<p>In this case your enemy is HTML and you are either yourself or regex.  You might even be Perl with irregular regex. Know HTML.  Know yourself.</p>

<p>I have composed a haiku describing the nature of HTML.</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml">HTML has
complexity exceeding
regular language.
</code></pre>

<p>I have also composed a haiku describing the nature of regex in Perl.</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml">The regex you seek
is defined within the phrase
&lt;([a-zA-Z]+)(?:[^&gt;]*[^/]*)?&gt;
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-html s-code-block"><code class="hljs language-xml"><span class="hljs-meta">&lt;?php
$selfClosing = explode(',', 'area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed');

$html = '
&lt;p&gt;&lt;a href="#"&gt;foo&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;br/&gt;
&lt;div&gt;name&lt;/div&gt;';

$dom = new DOMDocument();
$dom-&gt;loadHTML($html);
$els = $dom-&gt;getElementsByTagName('*');
foreach ( $els as $el ) {
    $nodeName = strtolower($el-&gt;nodeName);
    if ( !in_array( $nodeName, $selfClosing ) ) {
        var_dump( $nodeName );
    }
}
</span></code></pre>

<p>Output:</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml">string(4) "html"
string(4) "body"
string(1) "p"
string(1) "a"
string(3) "div"
</code></pre>

<p>Basically just define the element node names that are self closing, load the whole html string into a DOM library, grab all elements, loop through and filter out ones which aren't self closing and operate on them.</p>

<p>I'm sure you already know by now that you shouldn't use regex for this purpose.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I don't know your exact need for this, but if you are also using .NET, couldn't you use <a href="http://www.codeplex.com/htmlagilitypack" rel="noreferrer">Html Agility Pack</a>?</p>

<p>Excerpt:</p>

<blockquote>
  <p><em>It is a .NET code library that allows
  you to parse "out of the web" HTML
  files. The parser is very tolerant
  with "real world" malformed HTML.</em></p>
</blockquote>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You want the first <code>&gt;</code> not preceded by a <code>/</code>.  Look <a href="http://www.regular-expressions.info/lookaround.html" rel="noreferrer">here</a> for details on how to do that.  It's referred to as negative lookbehind.</p>

<p>However, a naïve implementation of that will end up matching <code>&lt;bar/&gt;&lt;/foo&gt;</code> in this example document</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">foo</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bar</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">foo</span>&gt;</span>
</code></pre>

<p>Can you provide a little more information on the problem you're trying to solve?  Are you iterating through tags programatically?</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The W3C explains parsing in a pseudo regexp form:<br>
<a href="http://www.w3.org/TR/REC-xml-names/#ns-using" rel="noreferrer">W3C Link</a>  </p>

<p>Follow the var links for <code>QName</code>, <code>S</code>, and <code>Attribute</code> to get a clearer picture.<br>
Based on that you can create a pretty good regexp to handle things like stripping tags.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you need this for PHP:</p>

<p>The <a href="http://www.php.net/manual/en/function.dom-import-simplexml.php" rel="noreferrer">PHP DOM</a> <a href="http://php.net/manual/en/class.domdocument.php" rel="noreferrer">functions</a> won't work properly unless it is properly formatted XML. No matter how much better their use is for the rest of mankind.</p>

<p><a href="http://simplehtmldom.sourceforge.net/" rel="noreferrer">simplehtmldom</a> is good, but I found it a bit buggy, and it is is quite memory heavy [Will crash on large pages.]</p>

<p>I have never used <a href="http://querypath.org/" rel="noreferrer">querypath</a>, so can't comment on its usefulness. </p>

<p>Another one to try is my <a href="http://github.com/siteroller/domparser" rel="noreferrer">DOMParser</a> which is very light on resources and I've been using happily for a while. Simple to learn &amp; powerful.</p>

<p>For Python and Java, similar links were posted.</p>

<p>For the downvoters - I only wrote my class when the XML parsers proved unable to withstand real use. Religious downvoting just prevents useful answers from being posted - keep things within perspective of the question, please.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 18</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here's the solution:</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml"><span class="hljs-meta">&lt;?php
// here's the pattern:
$pattern = '/&lt;(\w+)(\s+(\w+)\s*\=\s*(\'|")(.*?)\\4\s*)*\s*(\/&gt;|&gt;)/';

// a string to parse:
$string = 'Hello, try clicking &lt;a href="#paragraph"&gt;here&lt;/a&gt;
    &lt;br/&gt;and check out.&lt;hr /&gt;
    &lt;h2&gt;title&lt;/h2&gt;
    &lt;a name ="paragraph" rel= "I\'m an anchor"&gt;&lt;/a&gt;
    Fine, &lt;span title=\'highlight the "punch"\'&gt;thanks&lt;span&gt;.
    &lt;div class = "clear"&gt;&lt;/div&gt;
    &lt;br&gt;';

// let's get the occurrences:
preg_match_all($pattern, $string, $matches, PREG_PATTERN_ORDER);

// print the result:
print_r($matches[0]);
?&gt;</span>
</code></pre>

<p>To test it deeply, I entered in the string auto-closing tags like:</p>

<ol>
<li>&lt;hr /&gt;</li>
<li>&lt;br/&gt;</li>
<li>&lt;br&gt;</li>
</ol>

<p>I also entered tags with:</p>

<ol>
<li>one attribute</li>
<li>more than one attribute</li>
<li>attributes which value is bound either into <strong>single quotes</strong> or into <strong>double quotes</strong></li>
<li>attributes containing single quotes when the delimiter is a double quote and vice versa</li>
<li>"unpretty" attributes with a space before the "=" symbol, after it and both before and after it.</li>
</ol>

<p>Should you find something which does not work in the proof of concept above, I am available in analyzing the code to improve my skills.</p>

<p><strong>&lt;EDIT&gt;</strong>
I forgot that the question from the user was to avoid the parsing of self-closing tags.
In this case the pattern is simpler, turning into this:</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml">$pattern = '/&lt;(\w+)(\s+(\w+)\s*\=\s*(\'|")(.*?)\\4\s*)*\s*&gt;/';
</code></pre>

<p>The user @ridgerunner noticed that the pattern does not allow <strong>unquoted attributes</strong> or <strong>attributes with no value</strong>. In this case a fine tuning brings us the following pattern:</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml">$pattern = '/&lt;(\w+)(\s+(\w+)(\s*\=\s*(\'|"|)(.*?)\\5\s*)?)*\s*&gt;/';
</code></pre>

<p><strong>&lt;/EDIT&gt;</strong></p>

<h1>Understanding the pattern</h1>

<p>If someone is interested in learning more about the pattern, I provide some line:</p>

<ol>
<li>the first sub-expression (\w+) matches the tag name</li>
<li>the second sub-expression contains the pattern of an attribute. It is composed by:

<ol>
<li>one or more whitespaces \s+</li>
<li>the name of the attribute (\w+)</li>
<li>zero or more whitespaces \s* (it is possible or not, leaving blanks here)</li>
<li>the "=" symbol</li>
<li>again, zero or more whitespaces</li>
<li>the delimiter of the attribute value, a single or double quote ('|"). In the pattern, the single quote is escaped because it coincides with the PHP string delimiter. This sub-expression is captured with the parentheses so it can be referenced again to parse the closure of the attribute, that's why it is very important.</li>
<li>the value of the attribute, matched by <em>almost</em> anything: (.*?); in this specific syntax, using the <strong>greedy match</strong> (the question mark after the asterisk) the RegExp engine enables a "look-ahead"-like operator, which matches anything but what follows this sub-expression</li>
<li>here comes the fun: the \4 part is a <strong>backreference operator</strong>, which refers to a sub-expression defined before in the pattern, in this case, I am referring to the fourth sub-expression, which is the first attribute delimiter found</li>
<li>zero or more whitespaces \s*</li>
<li>the attribute sub-expression ends here, with the specification of zero or more possible occurrences, given by the asterisk.</li>
</ol></li>
<li>Then, since a tag may end with a whitespace before the "&gt;" symbol, zero or more whitespaces are matched with the \s* subpattern.</li>
<li>The tag to match may end with a simple "&gt;" symbol, or a possible XHTML closure, which makes use of the slash before it: (/&gt;|&gt;). The slash is, of course, escaped since it coincides with the regular expression delimiter.</li>
</ol>

<p>Small tip: to better analyze this code it is necessary looking at the source code generated since I did not provide any HTML special characters escaping.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 19</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Whenever I need to quickly extract something from an HTML document, I use Tidy to convert it to XML and then use XPath or XSLT to get what I need.
In your case, something like this: </p>

<pre class="lang-html s-code-block"><code class="hljs language-xml">//p/a[@href='foo']
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 20</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I used a open source tool called <a href="http://htmlparser.sourceforge.net/">HTMLParser</a> before. It's designed to parse HTML in various ways and serves the purpose quite well. It can parse HTML as different treenode and you can easily use its API to get attributes out of the node. Check it out and see if this can help you.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 21</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I like to parse HTML with regular expressions. I don't attempt to parse idiot HTML that is deliberately broken. This code is my main parser (Perl edition):</p>
<pre class="lang-html s-code-block"><code class="hljs language-xml">$_ = join "",<span class="hljs-tag">&lt;<span class="hljs-name">STDIN</span>&gt;</span>; tr/\n\r \t/ /s; s/&lt;/\n&lt;/g; s/&gt;/&gt;\n/g; s/\n ?\n/\n/g;
s/^ ?\n//s; s/ $//s; print
</code></pre>
<p>It's called <em>htmlsplit</em>, splits the HTML into lines, with one tag or chunk of text on each line. The lines can then be processed further with other text tools and scripts, such as <a href="http://en.wikipedia.org/wiki/Grep" rel="noreferrer">grep</a>, <a href="http://en.wikipedia.org/wiki/Sed" rel="noreferrer">sed</a>, Perl, etc. I'm not even joking :) Enjoy.</p>
<p>It is simple enough to rejig my slurp-everything-first Perl script into a nice streaming thing, if you wish to process enormous web pages. But it's not really necessary.</p>
<p><a href="http://sam.nipl.net/code/nipl-tools/bin/htmlsplit" rel="noreferrer">HTML Split</a></p>
<hr>
<p>Some better regular expressions:</p>
<pre class="lang-html s-code-block"><code class="hljs language-xml">/(&lt;.*?&gt;|[^&lt;]+)\s*/g    # Get tags and text
/(\w+)="(.*?)"/g       # Get attibutes
</code></pre>
<p>They are good for XML / XHTML.</p>
<p>With minor variations, it can cope with messy HTML... or convert the HTML -&gt; XHTML first.</p>
<hr>
<p>The best way to write regular expressions is in the <a href="http://en.wikipedia.org/wiki/Lex_%28software%29" rel="noreferrer">Lex</a> / <a href="http://en.wikipedia.org/wiki/Yacc" rel="noreferrer">Yacc</a> style, not as opaque one-liners or commented multi-line monstrosities. I didn't do that here, yet; these ones barely need it.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 22</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There are some nice regexes for replacing HTML with BBCode <a href="http://www.garyshood.com/htmltobb/source.txt" rel="noreferrer">here</a>. For all you nay-sayers, note that he's not trying to fully parse HTML, just to sanitize it. He can probably afford to kill off tags that his simple "parser" can't understand.</p>

<p>For example:</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml">$store =~ s/http:/http:\/\//gi;
$store =~ s/https:/https:\/\//gi;
$baseurl = $store;

if (!$query-&gt;param("ascii")) {
    $html =~ s/\s\s+/\n/gi;
    $html =~ s/&lt;pre(.*?)&gt;(.*?)&lt;\/pre&gt;/\[code]$2\[\/code]/sgmi;
}

$html =~ s/\n//gi;
$html =~ s/\r\r//gi;
$html =~ s/$baseurl//gi;
$html =~ s/&lt;h[1-7](.*?)&gt;(.*?)&lt;\/h[1-7]&gt;/\n\[b]$2\[\/b]\n/sgmi;
$html =~ s/<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>/\n\n/gi;
$html =~ s/&lt;br(.*?)&gt;/\n/gi;
$html =~ s/&lt;textarea(.*?)&gt;(.*?)&lt;\/textarea&gt;/\[code]$2\[\/code]/sgmi;
$html =~ s/<span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>(.*?)&lt;\/b&gt;/\[b]$1\[\/b]/gi;
$html =~ s/<span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>(.*?)&lt;\/i&gt;/\[i]$1\[\/i]/gi;
$html =~ s/<span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span>(.*?)&lt;\/u&gt;/\[u]$1\[\/u]/gi;
$html =~ s/<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>(.*?)&lt;\/em&gt;/\[i]$1\[\/i]/gi;
$html =~ s/<span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>(.*?)&lt;\/strong&gt;/\[b]$1\[\/b]/gi;
$html =~ s/<span class="hljs-tag">&lt;<span class="hljs-name">cite</span>&gt;</span>(.*?)&lt;\/cite&gt;/\[i]$1\[\/i]/gi;
$html =~ s/<span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"(.*?)"</span>&gt;</span>(.*?)&lt;\/font&gt;/\[color=$1]$2\[\/color]/sgmi;
$html =~ s/<span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">(.*?)</span>&gt;</span>(.*?)&lt;\/font&gt;/\[color=$1]$2\[\/color]/sgmi;
$html =~ s/&lt;link(.*?)&gt;//gi;
$html =~ s/&lt;li(.*?)&gt;(.*?)&lt;\/li&gt;/\[\*]$2/gi;
$html =~ s/&lt;ul(.*?)&gt;/\[list]/gi;
$html =~ s/&lt;\/ul&gt;/\[\/list]/gi;
$html =~ s/<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>/\n/gi;
$html =~ s/&lt;\/div&gt;/\n/gi;
$html =~ s/&lt;td(.*?)&gt;/ /gi;
$html =~ s/&lt;tr(.*?)&gt;/\n/gi;

$html =~ s/&lt;img(.*?)src="(.*?)"(.*?)&gt;/\[img]$baseurl\/$2\[\/img]/gi;
$html =~ s/&lt;a(.*?)href="(.*?)"(.*?)&gt;(.*?)&lt;\/a&gt;/\[url=$baseurl\/$2]$4\[\/url]/gi;
$html =~ s/\[url=$baseurl\/http:\/\/(.*?)](.*?)\[\/url]/\[url=http:\/\/$1]$2\[\/url]/gi;
$html =~ s/\[img]$baseurl\/http:\/\/(.*?)\[\/img]/\[img]http:\/\/$1\[\/img]/gi;

$html =~ s/<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>(.*?)&lt;\/head&gt;//sgmi;
$html =~ s/<span class="hljs-tag">&lt;<span class="hljs-name">object</span>&gt;</span>(.*?)&lt;\/object&gt;//sgmi;
$html =~ s/&lt;script(.*?)&gt;(.*?)&lt;\/script&gt;//sgmi;
$html =~ s/&lt;style(.*?)&gt;(.*?)&lt;\/style&gt;//sgmi;
$html =~ s/<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>(.*?)&lt;\/title&gt;//sgmi;
$html =~ s/<span class="hljs-comment">&lt;!--(.*?)--&gt;</span>/\n/sgmi;

$html =~ s/\/\//\//gi;
$html =~ s/http:\//http:\/\//gi;
$html =~ s/https:\//https:\/\//gi;

$html =~ s/&lt;(?:[^&gt;'"]*|(['"]).*?\1)*&gt;//gsi;
$html =~ s/\r\r//gi;
$html =~ s/\[img]\//\[img]/gi;
$html =~ s/\[url=\//\[url=/gi;
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 23</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>About the question of the regular expression methods to parse (x)HTML, the answer to all of the ones who spoke about some limits is: you have not been trained enough to rule the force of this powerful weapon, since <strong>nobody</strong> here spoke about <strong>recursion</strong>.</p>
<p>A regular expression-agnostic colleague notified me this discussion, which is not certainly the first on the web about this old and hot topic.</p>
<p>After reading some posts, the first thing I did was looking for the "?R" string in this thread. The second was to search about "recursion".</p>
<p>No, holy cow, no match found. Since nobody mentioned the main mechanism a parser is built onto, I was soon aware that nobody got the point.</p>
<p>If an (x)HTML parser needs recursion, a regular expression parser without recursion is not enough for the purpose. It's a simple construct.</p>
<p>The <strong>black art of regular expressions is hard to master</strong>, so maybe there are further possibilities we left out while trying and testing our personal solution to capture the whole web in one hand... Well, I am sure about it :)</p>
<p>Here's the magic pattern:</p>
<pre class="lang-html s-code-block"><code class="hljs language-xml">$pattern = "/&lt;([\w]+)([^&gt;]*?)(([\s]*\/&gt;)|(&gt;((([^&lt;]*?|&lt;\!\-\-.*?\-\-&gt;)|(?R))*)&lt;\/\\1[\s]*&gt;))/s";
</code></pre>
<p>Just try it. It's written as a PHP string, so the "s" modifier makes classes include newlines.</p>
<p>Here's a <strong>sample note on the PHP manual</strong> I wrote in January: <a href="http://php.net/manual/en/regexp.reference.recursive.php" rel="nofollow noreferrer">Reference</a></p>
<p>(Take care. In that note I wrongly used the "m" modifier; it should be erased, notwithstanding it is discarded by the regular expression engine, since no <code>^</code> or <code>$</code> anchoring was used).</p>
<p>Now, we could speak about the limits of this method from a more informed point of view:</p>
<ol>
<li>according to the specific implementation of the regular expression engine, recursion may have a limit in the <strong>number of nested patterns parsed</strong>, but it depends on the language used</li>
<li>although corrupted, (x)HTML does not drive into severe errors. It is not <em>sanitized</em>.</li>
</ol>
<p>Anyhow, it is only a regular expression pattern, but it discloses the possibility to develop of a lot of powerful implementations.</p>
<p>I wrote this pattern to power the <em>recursive descent parser</em> of a template engine I built in my framework, and performances are really great, both in execution times or in memory usage (nothing to do with other template engines which use the same syntax).</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 24</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-html s-code-block"><code class="hljs language-xml">&lt;\s*(\w+)[^/&gt;]*&gt;
</code></pre>
<p>The parts explained:</p>
<p><code>&lt;</code>: Starting character</p>
<p><code>\s*</code>: It may have whitespaces before the tag name (ugly, but possible).</p>
<p><code>(\w+)</code>: tags can contain letters and numbers (h1). Well, <code>\w</code> also matches '_', but it does not hurt I guess. If curious, use ([a-zA-Z0-9]+) instead.</p>
<p><code>[^/&gt;]*</code>: Anything except <code>&gt;</code> and <code>/</code> until closing <code>&gt;</code></p>
<p><code>&gt;</code>: Closing <code>&gt;</code></p>
<h3>UNRELATED</h3>
<p>And to the fellows, who underestimate regular expressions, saying they are only as powerful as regular languages:</p>
<p>a<sup>n</sup>ba<sup>n</sup>ba<sup>n</sup> which is not regular and not even context free, can be matched with <code>^(a+)b\1b\1$</code></p>
<p>Backreferencing <a href="http://en.wiktionary.org/wiki/FTW" rel="noreferrer">FTW</a>!</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 25</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As many people have already pointed out, HTML is not a regular language which can make it very difficult to parse. My solution to this is to turn it into a regular language using a tidy program and then to use an XML parser to consume the results. There are a lot of good options for this. My program is written using Java with the <a href="http://jtidy.sourceforge.net/" rel="noreferrer">jtidy</a> library to turn the HTML into XML and then Jaxen to xpath into the result.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 26</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you're simply trying to find those tags (without ambitions of parsing) try this regular expression:</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml">/&lt;[^/]*?&gt;/g
</code></pre>

<p>I wrote it in 30 seconds, and tested here:
<a href="http://gskinner.com/RegExr/">http://gskinner.com/RegExr/</a></p>

<p>It matches the types of tags you mentioned, while ignoring the types you said you wanted to ignore.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 27</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It seems to me you're trying to match tags without a "/" at the end. Try this:</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml">&lt;([a-zA-Z][a-zA-Z0-9]*)[^&gt;]*(?&lt;!/)&gt;
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 28</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It's true that when programming it's usually best to use dedicated parsers and APIs instead of regular expressions when dealing with HTML, especially if accuracy is paramount (e.g., if your processing might have security implications). However, I dont ascribe to a dogmatic view that XML-style markup should never be processed with regular expressions. There are cases when regular expressions are a great tool for the job, such as when making one-time edits in a text editor, fixing broken XML files, or dealing with file formats that look like but arent quite XML. There are some issues to be aware of, but they're not insurmountable or even necessarily relevant.</p>

<p>A simple regex like <code>&lt;([^&gt;"']|"[^"]*"|'[^']*')*&gt;</code> is usually good enough, in cases such as those I just mentioned. It's a naive solution, all things considered, but it does correctly allow unencoded <code>&gt;</code> symbols in attribute values. If you're looking for, e.g., a <code>table</code> tag, you could adapt it as <code>&lt;/?table\b([^&gt;"']|"[^"]*"|'[^']*')*&gt;</code>.</p>

<p>Just to give a sense of what a more "advanced" HTML regex would look like, the following does a fairly respectable job of emulating real-world browser behavior and the HTML5 parsing algorithm:</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml">&lt;/?([A-Za-z][^\s&gt;/]*)(?:=\s*(?:"[^"]*"|'[^']*'|[^\s&gt;]+)|[^&gt;])*(?:&gt;|$)
</code></pre>

<p>The following matches a fairly strict definition of XML tags (although it doesn't account for the full set of Unicode characters allowed in XML names):</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml">&lt;(?:([_:A-Z][-.:\w]*)(?:\s+[_:A-Z][-.:\w]*\s*=\s*(?:"[^"]*"|'[^']*'))*\s*/?|/([_:A-Z][-.:\w]*)\s*)&gt;
</code></pre>

<p>Granted, these don't account for surrounding context and a few edge cases, but even such things could be dealt with if you really wanted to (e.g., by searching between the matches of another regex).</p>

<p>At the end of the day, use the most appropriate tool for the job, even in the cases when that tool happens to be a regex.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 29</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Although it's not suitable and effective to use regular expressions for that purpose sometimes regular expressions provide quick solutions for simple match problems and in my view it's not that horrbile to use regular expressions for trivial works. </p>

<p>There is a <a href="http://blog.stevenlevithan.com/archives/match-innermost-html-element" rel="noreferrer">definitive blog post</a> about matching innermost HTML elements written by Steven Levithan.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 30</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you only want the tag names, it should be possible to do this via a regular expression.</p>
<pre class="lang-html s-code-block"><code class="hljs language-xml">&lt;([a-zA-Z]+)(?:[^&gt;]*[^/] *)?&gt;
</code></pre>
<p>should do what you need. But I think the solution of "moritz" is already fine. I didn't see it in the beginning.</p>
<p>For all downvoters: In some cases it just makes sense to use a regular expression, because it can be the easiest and quickest solution. I agree that in general you should not parse HTML with regular expressions.</p>
<p>But regular expressions can be a very powerful tool when you have a subset of HTML where you know the format and you just want to extract some values. I did that hundreds of times and almost always achieved what I wanted.</p>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n                    \u0026lt;div\u0026gt;\n            \u0026lt;aside class=\u0026quot;s-notice s-notice__info post-notice js-post-notice mb16\u0026quot; role=\u0026quot;status\u0026quot;\u0026gt;\n        \u0026lt;div class=\u0026quot;d-flex fd-column fw-nowrap\u0026quot;\u0026gt;\n            \u0026lt;div class=\u0026quot;d-flex fw-nowrap\u0026quot;\u0026gt;\n                    \u0026lt;div class=\u0026quot;flex--item mr8\u0026quot;\u0026gt;\n                        \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;svg-icon iconLock\u0026quot; width=\u0026quot;18\u0026quot; height=\u0026quot;18\u0026quot; viewBox=\u0026quot;0 0 18 18\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;M16 9a2 2 0 0 0-2-2V6A5 5 0 0 0 4 6v1a2 2 0 0 0-2 2v6c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V9Zm-7 5a2 2 0 1 1 0-4 2 2 0 0 1 0 4Zm3.1-7H5.9V6a3.1 3.1 0 0 1 6.2 0v1Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                    \u0026lt;/div\u0026gt;\n                \u0026lt;div class=\u0026quot;flex--item wmn0 fl1 lh-lg\u0026quot;\u0026gt;\n                    \u0026lt;div class=\u0026quot;flex--item fl1 lh-lg\u0026quot;\u0026gt;\n                        \u0026lt;b\u0026gt;Locked\u0026lt;/b\u0026gt;. There are \u0026lt;a href=\u0026quot;/help/locked-posts\u0026quot;\u0026gt;disputes about this answers content\u0026lt;/a\u0026gt; being resolved at this time. It is not currently accepting new interactions.\n                        \n                    \u0026lt;/div\u0026gt;\n                \u0026lt;/div\u0026gt;\n            \u0026lt;/div\u0026gt;\n        \u0026lt;/div\u0026gt;\n\u0026lt;/aside\u0026gt;\n\n    \u0026lt;/div\u0026gt;\n\n\u0026lt;p\u0026gt;You can\u0026apos;t parse [X]HTML with regex. Because HTML can\u0026apos;t be parsed by regex. Regex is not a tool that can be used to correctly parse HTML. As I have answered in HTML-and-regex questions here so many times before, the use of regex will not allow you to consume HTML. Regular expressions are a tool that is insufficiently sophisticated to understand the constructs employed by HTML. HTML is not a regular language and hence cannot be parsed by regular expressions. Regex queries are not equipped to break down HTML into its meaningful parts. so many times but it is not getting to me. Even enhanced irregular regular expressions as used by Perl are not up to the task of parsing HTML. You will never make me crack. HTML is a language of sufficient complexity that it cannot be parsed by regular expressions. Even Jon Skeet cannot parse HTML using regular expressions. Every time you attempt to parse HTML with regular expressions, the unholy child weeps the blood of virgins, and Russian hackers pwn your webapp. Parsing HTML with regex summons tainted souls into the realm of the living. HTML and regex go together like love, marriage, and ritual infanticide. The \u0026amp;lt;center\u0026amp;gt; cannot hold it is too late. The force of regex and HTML together in the same conceptual space will destroy your mind like so much watery putty. If you parse HTML with regex you are giving in to Them and their blasphemous ways which doom us all to inhuman toil for the One whose Name cannot be expressed in the Basic Multilingual Plane, he comes. HTML-plus-regexp will liquify the nerves of the sentient whilst you observe, your psyche withering in the onslaught of horror. Rege̿̔̉x-based HTML parsers are the cancer that is killing StackOverflow \u0026lt;i\u0026gt;it is too late it is too late we cannot be saved\u0026lt;/i\u0026gt; the transgression of a chi͡ld ensures regex will consume all living tissue (except for HTML which it cannot, as previously prophesied) \u0026lt;i\u0026gt;dear lord help us how can anyone survive this scourge\u0026lt;/i\u0026gt; using regex to parse HTML has doomed humanity to an eternity of dread torture and security holes \u0026lt;i\u0026gt;using rege\u0026lt;/i\u0026gt;x as a tool to process HTML establishes a brea\u0026lt;i\u0026gt;ch between this world\u0026lt;/i\u0026gt; and the dread realm of c͒ͪo͛ͫrrupt entities (like SGML entities, but \u0026lt;i\u0026gt;more corrupt) a mere glimp\u0026lt;/i\u0026gt;se of the world of reg\u0026lt;b\u0026gt;ex parsers for HTML will ins\u0026lt;/b\u0026gt;tantly transport a p\u0026lt;i\u0026gt;rogrammer\u0026apos;s consciousness i\u0026lt;/i\u0026gt;nto a w\u0026lt;i\u0026gt;orl\u0026lt;/i\u0026gt;d of ceaseless screaming, he comes\u0026lt;strike\u0026gt;, the pestilent sl\u0026lt;/strike\u0026gt;ithy regex-infection wil\u0026lt;b\u0026gt;l devour your HT\u0026lt;/b\u0026gt;ML parser, application and existence for all time like Visual Basic only worse \u0026lt;i\u0026gt;he comes he com\u0026lt;/i\u0026gt;es \u0026lt;i\u0026gt;do not fi\u0026lt;/i\u0026gt;ght h\u0026lt;b\u0026gt;e com̡e̶s, ̕h̵i\u0026lt;/b\u0026gt;s un̨ho͞ly radiańcé de\u0026lt;i\u0026gt;stro҉ying all enli̍̈́̂̈́ghtenment, HTML tags \u0026lt;b\u0026gt;lea͠ki̧n͘g fr̶ǫm ̡yo͟ur eye͢s̸ ̛l̕ik͏e liq\u0026lt;/b\u0026gt;uid p\u0026lt;/i\u0026gt;ain, the song of re̸gular expre\u0026lt;strike\u0026gt;ssion parsing \u0026lt;/strike\u0026gt;will exti\u0026lt;i\u0026gt;nguish the voices of mor\u0026lt;b\u0026gt;tal man from the sp\u0026lt;/b\u0026gt;here I can see it can you see ̲͚̖͔̙î̩́t̲͎̩̱͔́̋̀ it is beautiful t\u0026lt;/i\u0026gt;he f\u0026lt;code\u0026gt;inal snuf\u0026lt;/code\u0026gt;fing o\u0026lt;i\u0026gt;f the lie\u0026lt;b\u0026gt;s of Man ALL IS LOŚ͖̩͇̗̪̏̈́T A\u0026lt;/b\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;b\u0026gt;LL IS L\u0026lt;/b\u0026gt;OST th\u0026lt;i\u0026gt;e pon̷y he come\u0026lt;/i\u0026gt;s he c̶̮om\u0026lt;strike\u0026gt;es he co\u0026lt;/strike\u0026gt;\u0026lt;b\u0026gt;\u0026lt;strike\u0026gt;me\u0026lt;/strike\u0026gt;s t\u0026lt;i\u0026gt;he\u0026lt;/i\u0026gt; ich\u0026lt;/b\u0026gt;or permeat\u0026lt;i\u0026gt;es al\u0026lt;/i\u0026gt;l MY FAC\u0026lt;i\u0026gt;E MY FACE h god n\u0026lt;b\u0026gt;o NO NOO̼\u0026lt;/b\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;b\u0026gt;OO N\u0026lt;/b\u0026gt;Θ stop t\u0026lt;i\u0026gt;he an*̶͑̾̾̅ͫ͏̙̤g͇̫͛͆̾ͫ̑͆l͖͉̗̩̳̟̍ͫͥͨ\u0026lt;/i\u0026gt;e̠̅s\u0026lt;code\u0026gt; ͎a̧͈͖r̽̾̈́͒͑e\u0026lt;/code\u0026gt; n\u0026lt;b\u0026gt;ot rè̑ͧ̌aͨl̘̝̙̃ͤ͂̾̆ ZA̡͊͠͝LGΌ ISͮ̂҉̯͈͕̹̘̱ T\u0026lt;/b\u0026gt;O͇̹̺ͅƝ̴ȳ̳ TH̘\u0026lt;b\u0026gt;Ë͖́̉ ͠P̯͍̭O̚N̐Y̡ H̸̡̪̯ͨ͊̽̅̾̎Ȩ̬̩̾͛ͪ̈́̀́͘ ̶̧̨̱̹̭̯ͧ̾ͬC̷̙̲̝͖ͭ̏ͥͮ͟Oͮ͏̮̪̝͍M̲̖͊̒ͪͩͬ̚̚͜Ȇ̴̟̟͙̞ͩ͌͝\u0026lt;/b\u0026gt;S̨̥̫͎̭ͯ̿̔̀ͅ\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;Have you tried using an XML parser instead?\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Moderator\u0026apos;s Note\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This post is locked to prevent inappropriate edits to its content. The post looks exactly as it is supposed to look - there are no problems with its content. Please do not flag it for our attention.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;While \u0026lt;em\u0026gt;arbitrary\u0026lt;/em\u0026gt; HTML with only a regex is impossible, it\u0026apos;s sometimes appropriate to use them for parsing a \u0026lt;em\u0026gt;limited, known\u0026lt;/em\u0026gt; set of HTML.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you have a small set of HTML pages that you want to scrape data from and then stuff into a database, regexes might work fine.  For example, I recently wanted to get the names, parties, and districts of Australian federal Representatives, which I got off of the Parliament\u0026apos;s web site.  This was a limited, one-time job.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Regexes worked just fine for me, and were very fast to set up.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I think the flaw here is that HTML is a \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Context-free_grammar\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Chomsky Type 2 grammar (context free grammar)\u0026lt;/a\u0026gt; and a regular expression is a \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Regular_grammar\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Chomsky Type 3 grammar (regular grammar)\u0026lt;/a\u0026gt;. Since a Type 2 grammar is fundamentally more complex than a Type 3 grammar (see the \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Chomsky_hierarchy\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Chomsky hierarchy\u0026lt;/a\u0026gt;), it is \u0026lt;em\u0026gt;mathematically impossible\u0026lt;/em\u0026gt; to parse XML with a regular expression.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;But many will try, and some will even claim success - but until others find the fault and totally mess you up.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Don\u0026apos;t listen to these guys. You totally \u0026lt;strong\u0026gt;can\u0026lt;/strong\u0026gt; parse context-free grammars with regex if you break the task into smaller pieces. You can generate the correct pattern with a script that does each of these in order: \u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Solve the Halting Problem.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Square a circle.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Work out the Traveling Salesman Problem in O(log n) or less. If it\u0026apos;s any more than that, you\u0026apos;ll run out of RAM and the engine will hang.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The pattern will be pretty big, so make sure you have an algorithm that losslessly compresses random data.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Almost there - just divide the whole thing by zero. Easy-peasy.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;I haven\u0026apos;t quite finished the last part myself, but I know I\u0026apos;m getting close. It keeps throwing \u0026lt;code\u0026gt;CthulhuRlyehWgahnaglFhtagnException\u0026lt;/code\u0026gt;s for some reason, so I\u0026apos;m going to port it to VB 6 and use \u0026lt;code\u0026gt;On Error Resume Next\u0026lt;/code\u0026gt;. I\u0026apos;ll update with the code once I investigate this strange door that just opened in the wall. Hmm.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;P.S. Pierre de Fermat also figured out how to do it, but the margin he was writing in wasn\u0026apos;t big enough for the code.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Disclaimer\u0026lt;/strong\u0026gt;: use a parser if you have the option. That said...\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is the regex I use (!) to match HTML tags:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026amp;lt;(?:\u0026quot;[^\u0026quot;]*\u0026quot;[\u0026apos;\u0026quot;]*|\u0026apos;[^\u0026apos;]*\u0026apos;[\u0026apos;\u0026quot;]*|[^\u0026apos;\u0026quot;\u0026amp;gt;])+\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It may not be perfect, but I ran this code through a \u0026lt;em\u0026gt;lot\u0026lt;/em\u0026gt; of HTML. Note that it even catches strange things like \u0026lt;code\u0026gt;\u0026amp;lt;a name=\u0026quot;badgenerator\u0026quot;\u0026quot;\u0026amp;gt;\u0026lt;/code\u0026gt;, which show up on the web.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I guess to make it not match self contained tags, you\u0026apos;d either want to use \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732395#1732395\u0026quot;\u0026gt;Kobi\u0026lt;/a\u0026gt;\u0026apos;s negative look-behind:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026amp;lt;(?:\u0026quot;[^\u0026quot;]*\u0026quot;[\u0026apos;\u0026quot;]*|\u0026apos;[^\u0026apos;]*\u0026apos;[\u0026apos;\u0026quot;]*|[^\u0026apos;\u0026quot;\u0026amp;gt;])+(?\u0026amp;lt;!/\\s*)\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;or just combine if and if not.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;To downvoters:\u0026lt;/strong\u0026gt; This is working code from an actual product. I doubt anyone reading this page will get the impression that it is socially acceptable to use regexes on HTML. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Caveat\u0026lt;/strong\u0026gt;: I should note that this regex still breaks down in the presence of CDATA blocks, comments, and script and style elements. Good news is, you can get rid of those using a regex...  \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are people that will tell you that the Earth is round (or perhaps that the Earth is an oblate spheroid if they want to use strange words). They are lying.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;There are people that will tell you that Regular Expressions shouldn\u0026apos;t be recursive. They are limiting you. They need to subjugate you, and they do it by keeping you in ignorance.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;You can live in their reality or take the red pill.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Like Lord Marshal (is he a relative of the Marshal .NET class?), I have seen the \u0026lt;strike\u0026gt;Underverse\u0026lt;/strike\u0026gt; Stack Based Regex-Verse and returned with \u0026lt;strike\u0026gt;powers\u0026lt;/strike\u0026gt; knowledge you can\u0026apos;t imagine. Yes, I think there were an Old One or two protecting them, but they were watching football on the TV, so it wasn\u0026apos;t difficult.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I think the XML case is quite simple. The RegEx (in the .NET syntax), deflated and coded in base64 to make it easier to comprehend by your feeble mind, should be something like this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;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\n+r/vD34mUADO1P4/AQAA//8=\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The options to set is \u0026lt;code\u0026gt;RegexOptions.ExplicitCapture\u0026lt;/code\u0026gt;. The capture group you are looking for is \u0026lt;code\u0026gt;ELEMENTNAME\u0026lt;/code\u0026gt;. If the capture group \u0026lt;code\u0026gt;ERROR\u0026lt;/code\u0026gt; is not empty then there was a parsing error and the Regex stopped.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If you have problems reconverting it to a human-readable regex, this should help:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-csharp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;FromBase64\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt; str\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;byte\u0026lt;/span\u0026gt;[] byteArray = Convert.FromBase64String(str);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; msIn = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; MemoryStream(byteArray))\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; msOut = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; MemoryStream()) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; ds = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; DeflateStream(msIn, CompressionMode.Decompress)) {\n            ds.CopyTo(msOut);\n        }\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; Encoding.UTF8.GetString(msOut.ToArray());\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;If you are unsure, no, I\u0026apos;m NOT kidding (but perhaps I\u0026apos;m lying). It WILL work. I\u0026apos;ve built tons of unit tests to test it, and I have even used (part of) the \u0026lt;a href=\u0026quot;http://www.w3.org/XML/Test/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;conformance tests\u0026lt;/a\u0026gt;. It\u0026apos;s a tokenizer, not a full-blown parser, so it will only split the XML into its component tokens. It won\u0026apos;t parse/integrate DTDs.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Oh... if you want the source code of the regex, with some auxiliary methods:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://pastebin.com/hzYazFVb\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;regex to tokenize an xml\u0026lt;/a\u0026gt; or \u0026lt;a href=\u0026quot;https://topaz.github.io/paste/#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\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;the full plain regex\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In shell, you can parse \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/HTML\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;HTML\u0026lt;/a\u0026gt; using \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Sed\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;sed\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://sed.sourceforge.net/grabbag/scripts/turing.sed\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Turing.sed\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Write HTML parser (homework)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;???\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Profit!\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Related (why you shouldn\u0026apos;t use regex match):\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://blog.codinghorror.com/if-you-like-regular-expressions-so-much-why-dont-you-marry-them/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;If You Like Regular Expressions So Much, Why Don\u0026apos;t You Marry Them?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://blog.codinghorror.com/regular-expressions-now-you-have-two-problems/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Regular Expressions: Now You Have Two Problems\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://danlec.com/blog/hacking-stackoverflow-com-s-html-sanitizer\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Hacking stackoverflow.com\u0026apos;s HTML sanitizer\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I agree that the right tool to parse XML and \u0026lt;em\u0026gt;especially HTML\u0026lt;/em\u0026gt; is a parser and not a regular expression engine. However, like others have pointed out, sometimes using a regex is quicker, easier, and gets the job done if you know the data format.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Microsoft actually has a section of \u0026lt;a href=\u0026quot;https://docs.microsoft.com/dotnet/standard/base-types/best-practices\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Best Practices for Regular Expressions in the .NET Framework\u0026lt;/a\u0026gt; and specifically talks about \u0026lt;a href=\u0026quot;https://docs.microsoft.com/dotnet/standard/base-types/best-practices#consider-the-input-source\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Consider[ing] the Input Source\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Regular Expressions do have limitations, but have you considered the following?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The .NET framework is unique when it comes to regular expressions in that it supports \u0026lt;a href=\u0026quot;https://docs.microsoft.com/dotnet/standard/base-types/grouping-constructs-in-regular-expressions#balancing_group_definition\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Balancing Group Definitions\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;See \u0026lt;a href=\u0026quot;https://weblogs.asp.net/whaggard/377025\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Matching Balanced Constructs with .NET Regular Expressions\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;See \u0026lt;a href=\u0026quot;https://docs.microsoft.com/archive/blogs/bclteam/net-regular-expressions-regex-and-balanced-matching-ryan-byington\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;.NET Regular Expressions: Regex and Balanced Matching\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;See Microsoft\u0026apos;s docs on \u0026lt;a href=\u0026quot;https://docs.microsoft.com/dotnet/standard/base-types/grouping-constructs-in-regular-expressions#balancing_group_definition\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Balancing Group Definitions\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;For this reason, I believe you CAN parse XML using regular expressions. Note however, that it \u0026lt;strong\u0026gt;must be valid XML\u0026lt;/strong\u0026gt; (\u0026lt;em\u0026gt;browsers are very forgiving of HTML and allow bad XML syntax inside HTML\u0026lt;/em\u0026gt;). This is possible since the \u0026quot;Balancing Group Definition\u0026quot; will allow the regular expression engine to act as a PDA.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Quote from article 1 cited above:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;.NET Regular Expression Engine\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;As described above properly balanced constructs cannot be described by\n  a regular expression. However, the .NET regular expression engine\n  provides a few constructs that allow balanced constructs to be\n  recognized. \u0026lt;/p\u0026gt;\n  \n  \u0026lt;ul\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;code\u0026gt;(?\u0026amp;lt;group\u0026amp;gt;)\u0026lt;/code\u0026gt; - pushes the captured result on the capture stack with\n  the name group.\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;code\u0026gt;(?\u0026amp;lt;-group\u0026amp;gt;)\u0026lt;/code\u0026gt; - pops the top most capture with the name group off the\n  capture stack.\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;code\u0026gt;(?(group)yes|no)\u0026lt;/code\u0026gt; - matches the yes part if there exists a group\n  with the name group otherwise matches no part.\u0026lt;/li\u0026gt;\n  \u0026lt;/ul\u0026gt;\n  \n  \u0026lt;p\u0026gt;These constructs allow for a .NET regular expression to emulate a\n  restricted PDA by essentially allowing simple versions of the stack\n  operations: push, pop and empty. The simple operations are pretty much\n  equivalent to increment, decrement and compare to zero respectively.\n  This allows for the .NET regular expression engine to recognize a\n  subset of the context-free languages, in particular the ones that only\n  require a simple counter. This in turn allows for the non-traditional\n  .NET regular expressions to recognize individual properly balanced\n  constructs.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Consider the following regular expression:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-none s-code-block\u0026quot;\u0026gt;\u0026lt;code\u0026gt;(?=\u0026amp;lt;ul\\s+id=\u0026quot;matchMe\u0026quot;\\s+type=\u0026quot;square\u0026quot;\\s*\u0026amp;gt;)\n(?\u0026amp;gt;\n   \u0026amp;lt;!-- .*? --\u0026amp;gt;                  |\n   \u0026amp;lt;[^\u0026amp;gt;]*/\u0026amp;gt;                      |\n   (?\u0026amp;lt;opentag\u0026amp;gt;\u0026amp;lt;(?!/)[^\u0026amp;gt;]*[^/]\u0026amp;gt;)  |\n   (?\u0026amp;lt;-opentag\u0026amp;gt;\u0026amp;lt;/[^\u0026amp;gt;]*[^/]\u0026amp;gt;)     |\n   [^\u0026amp;lt;\u0026amp;gt;]*\n)*\n(?(opentag)(?!))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Use the flags:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Singleline\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;IgnorePatternWhitespace (not necessary if you collapse regex and remove all whitespace)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;IgnoreCase (not necessary)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;h2\u0026gt;Regular Expression Explained (inline)\u0026lt;/h2\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-none s-code-block\u0026quot;\u0026gt;\u0026lt;code\u0026gt;(?=\u0026amp;lt;ul\\s+id=\u0026quot;matchMe\u0026quot;\\s+type=\u0026quot;square\u0026quot;\\s*\u0026amp;gt;) # match start with \u0026amp;lt;ul id=\u0026quot;matchMe\u0026quot;...\n(?\u0026amp;gt;                                        # atomic group / don\u0026apos;t backtrack (faster)\n   \u0026amp;lt;!-- .*? --\u0026amp;gt;                 |          # match xml / html comment\n   \u0026amp;lt;[^\u0026amp;gt;]*/\u0026amp;gt;                     |          # self closing tag\n   (?\u0026amp;lt;opentag\u0026amp;gt;\u0026amp;lt;(?!/)[^\u0026amp;gt;]*[^/]\u0026amp;gt;) |          # push opening xml tag\n   (?\u0026amp;lt;-opentag\u0026amp;gt;\u0026amp;lt;/[^\u0026amp;gt;]*[^/]\u0026amp;gt;)    |          # pop closing xml tag\n   [^\u0026amp;lt;\u0026amp;gt;]*                                  # something between tags\n)*                                         # match as many xml tags as possible\n(?(opentag)(?!))                           # ensure no \u0026apos;opentag\u0026apos; groups are on stack\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You can try this at \u0026lt;a href=\u0026quot;http://derekslager.com/blog/posts/2007/09/a-better-dotnet-regular-expression-tester.ashx\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;A Better .NET Regular Expression Tester\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I used the sample source of:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;html\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;body\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;br\u0026lt;/span\u0026gt; /\u0026amp;gt;\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;matchMe\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;square\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;stuff...\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;more stuff\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n          \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n               \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;span\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;still more\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;span\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n               \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n                    \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;Another \u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026amp;amp;gt;\u0026lt;/span\u0026gt;ul\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026amp;amp;lt;\u0026lt;/span\u0026gt;, oh my!\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n                    \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;...\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n               \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n          \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;body\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;html\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This found the match:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;   \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;matchMe\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;square\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;stuff...\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;more stuff\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n          \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n               \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;span\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;still more\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;span\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n               \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n                    \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;Another \u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026amp;amp;gt;\u0026lt;/span\u0026gt;ul\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026amp;amp;lt;\u0026lt;/span\u0026gt;, oh my!\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n                    \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;...\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n               \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n          \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;although it actually came out like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;matchMe\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;square\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;           \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;stuff...\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;           \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;more stuff\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;           \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;               \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;                    \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;span\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;still more\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;span\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;                    \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;                         \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;Another \u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026amp;amp;gt;\u0026lt;/span\u0026gt;ul\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026amp;amp;lt;\u0026lt;/span\u0026gt;, oh my!\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;                         \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;...\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;                    \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;               \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;           \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;        \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Lastly, I really enjoyed Jeff Atwood\u0026apos;s article:  \u0026lt;a href=\u0026quot;https://blog.codinghorror.com/parsing-html-the-cthulhu-way/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Parsing Html The Cthulhu Way\u0026lt;/a\u0026gt;. Funny enough, it cites the answer to this question that currently has over 4k votes.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I suggest using \u0026lt;a href=\u0026quot;http://querypath.org/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;QueryPath\u0026lt;/a\u0026gt; for parsing XML and HTML in PHP.  It\u0026apos;s basically much the same syntax as jQuery, only it\u0026apos;s on the server side.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;While the answers that you can\u0026apos;t parse HTML with regexes are correct, they don\u0026apos;t apply here. The OP just wants to parse one HTML tag with regexes, and that is something that can be done with a regular expression.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The suggested regex is wrong, though:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026amp;lt;([a-z]+) *[^/]*?\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If you add something to the regex, by backtracking it can be forced to match silly things like \u0026lt;code\u0026gt;\u0026amp;lt;a \u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;[^/]\u0026lt;/code\u0026gt; is too permissive. Also note that \u0026lt;code\u0026gt;\u0026amp;lt;space\u0026amp;gt;*[^/]*\u0026lt;/code\u0026gt; is redundant, because the \u0026lt;code\u0026gt;[^/]*\u0026lt;/code\u0026gt; can also match spaces.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;My suggestion would be\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026amp;lt;([a-z]+)[^\u0026amp;gt;]*(?\u0026amp;lt;!/)\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Where \u0026lt;code\u0026gt;(?\u0026amp;lt;! ... )\u0026lt;/code\u0026gt; is (in Perl regexes) the negative look-behind. It reads \u0026quot;a \u0026amp;lt;, then a word, then anything that\u0026apos;s not a \u0026amp;gt;, the last of which may not be a /, followed by \u0026amp;gt;\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note that this allows things like \u0026lt;code\u0026gt;\u0026amp;lt;a/ \u0026amp;gt;\u0026lt;/code\u0026gt; (just like the original regex), so if you want something more restrictive, you need to build a regex to match attribute pairs separated by spaces.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Try:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026amp;lt;([^\\s]+)(\\s[^\u0026amp;gt;]*?)?(?\u0026amp;lt;!/)\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It is similar to yours, but the last \u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt; must not be after a slash, and also accepts \u0026lt;code\u0026gt;h1\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Sun Tzu, an ancient Chinese strategist, general, and philosopher, said:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;It is said that if you know your enemies and know yourself, you can win a hundred battles without a single loss.\n  If you only know yourself, but not your opponent, you may win or may lose.\n  If you know neither yourself nor your enemy, you will always endanger yourself.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;In this case your enemy is HTML and you are either yourself or regex.  You might even be Perl with irregular regex. Know HTML.  Know yourself.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I have composed a haiku describing the nature of HTML.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;HTML has\ncomplexity exceeding\nregular language.\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I have also composed a haiku describing the nature of regex in Perl.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;The regex you seek\nis defined within the phrase\n\u0026amp;lt;([a-zA-Z]+)(?:[^\u0026amp;gt;]*[^/]*)?\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;lt;?php\n$selfClosing = explode(\u0026apos;,\u0026apos;, \u0026apos;area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed\u0026apos;);\n\n$html = \u0026apos;\n\u0026amp;lt;p\u0026amp;gt;\u0026amp;lt;a href=\u0026quot;#\u0026quot;\u0026amp;gt;foo\u0026amp;lt;/a\u0026amp;gt;\u0026amp;lt;/p\u0026amp;gt;\n\u0026amp;lt;hr/\u0026amp;gt;\n\u0026amp;lt;br/\u0026amp;gt;\n\u0026amp;lt;div\u0026amp;gt;name\u0026amp;lt;/div\u0026amp;gt;\u0026apos;;\n\n$dom = new DOMDocument();\n$dom-\u0026amp;gt;loadHTML($html);\n$els = $dom-\u0026amp;gt;getElementsByTagName(\u0026apos;*\u0026apos;);\nforeach ( $els as $el ) {\n    $nodeName = strtolower($el-\u0026amp;gt;nodeName);\n    if ( !in_array( $nodeName, $selfClosing ) ) {\n        var_dump( $nodeName );\n    }\n}\n\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Output:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;string(4) \u0026quot;html\u0026quot;\nstring(4) \u0026quot;body\u0026quot;\nstring(1) \u0026quot;p\u0026quot;\nstring(1) \u0026quot;a\u0026quot;\nstring(3) \u0026quot;div\u0026quot;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Basically just define the element node names that are self closing, load the whole html string into a DOM library, grab all elements, loop through and filter out ones which aren\u0026apos;t self closing and operate on them.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;m sure you already know by now that you shouldn\u0026apos;t use regex for this purpose.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I don\u0026apos;t know your exact need for this, but if you are also using .NET, couldn\u0026apos;t you use \u0026lt;a href=\u0026quot;http://www.codeplex.com/htmlagilitypack\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Html Agility Pack\u0026lt;/a\u0026gt;?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Excerpt:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;It is a .NET code library that allows\n  you to parse \u0026quot;out of the web\u0026quot; HTML\n  files. The parser is very tolerant\n  with \u0026quot;real world\u0026quot; malformed HTML.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You want the first \u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt; not preceded by a \u0026lt;code\u0026gt;/\u0026lt;/code\u0026gt;.  Look \u0026lt;a href=\u0026quot;http://www.regular-expressions.info/lookaround.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt; for details on how to do that.  It\u0026apos;s referred to as negative lookbehind.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However, a naïve implementation of that will end up matching \u0026lt;code\u0026gt;\u0026amp;lt;bar/\u0026amp;gt;\u0026amp;lt;/foo\u0026amp;gt;\u0026lt;/code\u0026gt; in this example document\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;/\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Can you provide a little more information on the problem you\u0026apos;re trying to solve?  Are you iterating through tags programatically?\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The W3C explains parsing in a pseudo regexp form:\u0026lt;br\u0026gt;\n\u0026lt;a href=\u0026quot;http://www.w3.org/TR/REC-xml-names/#ns-using\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;W3C Link\u0026lt;/a\u0026gt;  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Follow the var links for \u0026lt;code\u0026gt;QName\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;S\u0026lt;/code\u0026gt;, and \u0026lt;code\u0026gt;Attribute\u0026lt;/code\u0026gt; to get a clearer picture.\u0026lt;br\u0026gt;\nBased on that you can create a pretty good regexp to handle things like stripping tags.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you need this for PHP:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;a href=\u0026quot;http://www.php.net/manual/en/function.dom-import-simplexml.php\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;PHP DOM\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;http://php.net/manual/en/class.domdocument.php\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;functions\u0026lt;/a\u0026gt; won\u0026apos;t work properly unless it is properly formatted XML. No matter how much better their use is for the rest of mankind.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://simplehtmldom.sourceforge.net/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;simplehtmldom\u0026lt;/a\u0026gt; is good, but I found it a bit buggy, and it is is quite memory heavy [Will crash on large pages.]\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I have never used \u0026lt;a href=\u0026quot;http://querypath.org/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;querypath\u0026lt;/a\u0026gt;, so can\u0026apos;t comment on its usefulness. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Another one to try is my \u0026lt;a href=\u0026quot;http://github.com/siteroller/domparser\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;DOMParser\u0026lt;/a\u0026gt; which is very light on resources and I\u0026apos;ve been using happily for a while. Simple to learn \u0026amp;amp; powerful.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For Python and Java, similar links were posted.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For the downvoters - I only wrote my class when the XML parsers proved unable to withstand real use. Religious downvoting just prevents useful answers from being posted - keep things within perspective of the question, please.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here\u0026apos;s the solution:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;lt;?php\n// here\u0026apos;s the pattern:\n$pattern = \u0026apos;/\u0026amp;lt;(\\w+)(\\s+(\\w+)\\s*\\=\\s*(\\\u0026apos;|\u0026quot;)(.*?)\\\\4\\s*)*\\s*(\\/\u0026amp;gt;|\u0026amp;gt;)/\u0026apos;;\n\n// a string to parse:\n$string = \u0026apos;Hello, try clicking \u0026amp;lt;a href=\u0026quot;#paragraph\u0026quot;\u0026amp;gt;here\u0026amp;lt;/a\u0026amp;gt;\n    \u0026amp;lt;br/\u0026amp;gt;and check out.\u0026amp;lt;hr /\u0026amp;gt;\n    \u0026amp;lt;h2\u0026amp;gt;title\u0026amp;lt;/h2\u0026amp;gt;\n    \u0026amp;lt;a name =\u0026quot;paragraph\u0026quot; rel= \u0026quot;I\\\u0026apos;m an anchor\u0026quot;\u0026amp;gt;\u0026amp;lt;/a\u0026amp;gt;\n    Fine, \u0026amp;lt;span title=\\\u0026apos;highlight the \u0026quot;punch\u0026quot;\\\u0026apos;\u0026amp;gt;thanks\u0026amp;lt;span\u0026amp;gt;.\n    \u0026amp;lt;div class = \u0026quot;clear\u0026quot;\u0026amp;gt;\u0026amp;lt;/div\u0026amp;gt;\n    \u0026amp;lt;br\u0026amp;gt;\u0026apos;;\n\n// let\u0026apos;s get the occurrences:\npreg_match_all($pattern, $string, $matches, PREG_PATTERN_ORDER);\n\n// print the result:\nprint_r($matches[0]);\n?\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;To test it deeply, I entered in the string auto-closing tags like:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026amp;lt;hr /\u0026amp;gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026amp;lt;br/\u0026amp;gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026amp;lt;br\u0026amp;gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;I also entered tags with:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;one attribute\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;more than one attribute\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;attributes which value is bound either into \u0026lt;strong\u0026gt;single quotes\u0026lt;/strong\u0026gt; or into \u0026lt;strong\u0026gt;double quotes\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;attributes containing single quotes when the delimiter is a double quote and vice versa\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026quot;unpretty\u0026quot; attributes with a space before the \u0026quot;=\u0026quot; symbol, after it and both before and after it.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;Should you find something which does not work in the proof of concept above, I am available in analyzing the code to improve my skills.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026amp;lt;EDIT\u0026amp;gt;\u0026lt;/strong\u0026gt;\nI forgot that the question from the user was to avoid the parsing of self-closing tags.\nIn this case the pattern is simpler, turning into this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;$pattern = \u0026apos;/\u0026amp;lt;(\\w+)(\\s+(\\w+)\\s*\\=\\s*(\\\u0026apos;|\u0026quot;)(.*?)\\\\4\\s*)*\\s*\u0026amp;gt;/\u0026apos;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The user @ridgerunner noticed that the pattern does not allow \u0026lt;strong\u0026gt;unquoted attributes\u0026lt;/strong\u0026gt; or \u0026lt;strong\u0026gt;attributes with no value\u0026lt;/strong\u0026gt;. In this case a fine tuning brings us the following pattern:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;$pattern = \u0026apos;/\u0026amp;lt;(\\w+)(\\s+(\\w+)(\\s*\\=\\s*(\\\u0026apos;|\u0026quot;|)(.*?)\\\\5\\s*)?)*\\s*\u0026amp;gt;/\u0026apos;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026amp;lt;/EDIT\u0026amp;gt;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;h1\u0026gt;Understanding the pattern\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;If someone is interested in learning more about the pattern, I provide some line:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;the first sub-expression (\\w+) matches the tag name\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;the second sub-expression contains the pattern of an attribute. It is composed by:\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;one or more whitespaces \\s+\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;the name of the attribute (\\w+)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;zero or more whitespaces \\s* (it is possible or not, leaving blanks here)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;the \u0026quot;=\u0026quot; symbol\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;again, zero or more whitespaces\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;the delimiter of the attribute value, a single or double quote (\u0026apos;|\u0026quot;). In the pattern, the single quote is escaped because it coincides with the PHP string delimiter. This sub-expression is captured with the parentheses so it can be referenced again to parse the closure of the attribute, that\u0026apos;s why it is very important.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;the value of the attribute, matched by \u0026lt;em\u0026gt;almost\u0026lt;/em\u0026gt; anything: (.*?); in this specific syntax, using the \u0026lt;strong\u0026gt;greedy match\u0026lt;/strong\u0026gt; (the question mark after the asterisk) the RegExp engine enables a \u0026quot;look-ahead\u0026quot;-like operator, which matches anything but what follows this sub-expression\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;here comes the fun: the \\4 part is a \u0026lt;strong\u0026gt;backreference operator\u0026lt;/strong\u0026gt;, which refers to a sub-expression defined before in the pattern, in this case, I am referring to the fourth sub-expression, which is the first attribute delimiter found\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;zero or more whitespaces \\s*\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;the attribute sub-expression ends here, with the specification of zero or more possible occurrences, given by the asterisk.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Then, since a tag may end with a whitespace before the \u0026quot;\u0026amp;gt;\u0026quot; symbol, zero or more whitespaces are matched with the \\s* subpattern.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The tag to match may end with a simple \u0026quot;\u0026amp;gt;\u0026quot; symbol, or a possible XHTML closure, which makes use of the slash before it: (/\u0026amp;gt;|\u0026amp;gt;). The slash is, of course, escaped since it coincides with the regular expression delimiter.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;Small tip: to better analyze this code it is necessary looking at the source code generated since I did not provide any HTML special characters escaping.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Whenever I need to quickly extract something from an HTML document, I use Tidy to convert it to XML and then use XPath or XSLT to get what I need.\nIn your case, something like this: \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;//p/a[@href=\u0026apos;foo\u0026apos;]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I used a open source tool called \u0026lt;a href=\u0026quot;http://htmlparser.sourceforge.net/\u0026quot;\u0026gt;HTMLParser\u0026lt;/a\u0026gt; before. It\u0026apos;s designed to parse HTML in various ways and serves the purpose quite well. It can parse HTML as different treenode and you can easily use its API to get attributes out of the node. Check it out and see if this can help you.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I like to parse HTML with regular expressions. I don\u0026apos;t attempt to parse idiot HTML that is deliberately broken. This code is my main parser (Perl edition):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;$_ = join \u0026quot;\u0026quot;,\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;STDIN\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;; tr/\\n\\r \\t/ /s; s/\u0026amp;lt;/\\n\u0026amp;lt;/g; s/\u0026amp;gt;/\u0026amp;gt;\\n/g; s/\\n ?\\n/\\n/g;\ns/^ ?\\n//s; s/ $//s; print\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;It\u0026apos;s called \u0026lt;em\u0026gt;htmlsplit\u0026lt;/em\u0026gt;, splits the HTML into lines, with one tag or chunk of text on each line. The lines can then be processed further with other text tools and scripts, such as \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Grep\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;grep\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Sed\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;sed\u0026lt;/a\u0026gt;, Perl, etc. I\u0026apos;m not even joking :) Enjoy.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;It is simple enough to rejig my slurp-everything-first Perl script into a nice streaming thing, if you wish to process enormous web pages. But it\u0026apos;s not really necessary.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://sam.nipl.net/code/nipl-tools/bin/htmlsplit\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;HTML Split\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;Some better regular expressions:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;/(\u0026amp;lt;.*?\u0026amp;gt;|[^\u0026amp;lt;]+)\\s*/g    # Get tags and text\n/(\\w+)=\u0026quot;(.*?)\u0026quot;/g       # Get attibutes\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;They are good for XML / XHTML.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;With minor variations, it can cope with messy HTML... or convert the HTML -\u0026amp;gt; XHTML first.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;The best way to write regular expressions is in the \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Lex_%28software%29\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Lex\u0026lt;/a\u0026gt; / \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Yacc\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Yacc\u0026lt;/a\u0026gt; style, not as opaque one-liners or commented multi-line monstrosities. I didn\u0026apos;t do that here, yet; these ones barely need it.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are some nice regexes for replacing HTML with BBCode \u0026lt;a href=\u0026quot;http://www.garyshood.com/htmltobb/source.txt\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt;. For all you nay-sayers, note that he\u0026apos;s not trying to fully parse HTML, just to sanitize it. He can probably afford to kill off tags that his simple \u0026quot;parser\u0026quot; can\u0026apos;t understand.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;$store =~ s/http:/http:\\/\\//gi;\n$store =~ s/https:/https:\\/\\//gi;\n$baseurl = $store;\n\nif (!$query-\u0026amp;gt;param(\u0026quot;ascii\u0026quot;)) {\n    $html =~ s/\\s\\s+/\\n/gi;\n    $html =~ s/\u0026amp;lt;pre(.*?)\u0026amp;gt;(.*?)\u0026amp;lt;\\/pre\u0026amp;gt;/\\[code]$2\\[\\/code]/sgmi;\n}\n\n$html =~ s/\\n//gi;\n$html =~ s/\\r\\r//gi;\n$html =~ s/$baseurl//gi;\n$html =~ s/\u0026amp;lt;h[1-7](.*?)\u0026amp;gt;(.*?)\u0026amp;lt;\\/h[1-7]\u0026amp;gt;/\\n\\[b]$2\\[\\/b]\\n/sgmi;\n$html =~ s/\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;p\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;/\\n\\n/gi;\n$html =~ s/\u0026amp;lt;br(.*?)\u0026amp;gt;/\\n/gi;\n$html =~ s/\u0026amp;lt;textarea(.*?)\u0026amp;gt;(.*?)\u0026amp;lt;\\/textarea\u0026amp;gt;/\\[code]$2\\[\\/code]/sgmi;\n$html =~ s/\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;(.*?)\u0026amp;lt;\\/b\u0026amp;gt;/\\[b]$1\\[\\/b]/gi;\n$html =~ s/\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;i\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;(.*?)\u0026amp;lt;\\/i\u0026amp;gt;/\\[i]$1\\[\\/i]/gi;\n$html =~ s/\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;u\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;(.*?)\u0026amp;lt;\\/u\u0026amp;gt;/\\[u]$1\\[\\/u]/gi;\n$html =~ s/\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;em\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;(.*?)\u0026amp;lt;\\/em\u0026amp;gt;/\\[i]$1\\[\\/i]/gi;\n$html =~ s/\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;strong\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;(.*?)\u0026amp;lt;\\/strong\u0026amp;gt;/\\[b]$1\\[\\/b]/gi;\n$html =~ s/\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;cite\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;(.*?)\u0026amp;lt;\\/cite\u0026amp;gt;/\\[i]$1\\[\\/i]/gi;\n$html =~ s/\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;font\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;color\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;(.*?)\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;(.*?)\u0026amp;lt;\\/font\u0026amp;gt;/\\[color=$1]$2\\[\\/color]/sgmi;\n$html =~ s/\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;font\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;color\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;(.*?)\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;(.*?)\u0026amp;lt;\\/font\u0026amp;gt;/\\[color=$1]$2\\[\\/color]/sgmi;\n$html =~ s/\u0026amp;lt;link(.*?)\u0026amp;gt;//gi;\n$html =~ s/\u0026amp;lt;li(.*?)\u0026amp;gt;(.*?)\u0026amp;lt;\\/li\u0026amp;gt;/\\[\\*]$2/gi;\n$html =~ s/\u0026amp;lt;ul(.*?)\u0026amp;gt;/\\[list]/gi;\n$html =~ s/\u0026amp;lt;\\/ul\u0026amp;gt;/\\[\\/list]/gi;\n$html =~ s/\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;/\\n/gi;\n$html =~ s/\u0026amp;lt;\\/div\u0026amp;gt;/\\n/gi;\n$html =~ s/\u0026amp;lt;td(.*?)\u0026amp;gt;/ /gi;\n$html =~ s/\u0026amp;lt;tr(.*?)\u0026amp;gt;/\\n/gi;\n\n$html =~ s/\u0026amp;lt;img(.*?)src=\u0026quot;(.*?)\u0026quot;(.*?)\u0026amp;gt;/\\[img]$baseurl\\/$2\\[\\/img]/gi;\n$html =~ s/\u0026amp;lt;a(.*?)href=\u0026quot;(.*?)\u0026quot;(.*?)\u0026amp;gt;(.*?)\u0026amp;lt;\\/a\u0026amp;gt;/\\[url=$baseurl\\/$2]$4\\[\\/url]/gi;\n$html =~ s/\\[url=$baseurl\\/http:\\/\\/(.*?)](.*?)\\[\\/url]/\\[url=http:\\/\\/$1]$2\\[\\/url]/gi;\n$html =~ s/\\[img]$baseurl\\/http:\\/\\/(.*?)\\[\\/img]/\\[img]http:\\/\\/$1\\[\\/img]/gi;\n\n$html =~ s/\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;head\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;(.*?)\u0026amp;lt;\\/head\u0026amp;gt;//sgmi;\n$html =~ s/\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;(.*?)\u0026amp;lt;\\/object\u0026amp;gt;//sgmi;\n$html =~ s/\u0026amp;lt;script(.*?)\u0026amp;gt;(.*?)\u0026amp;lt;\\/script\u0026amp;gt;//sgmi;\n$html =~ s/\u0026amp;lt;style(.*?)\u0026amp;gt;(.*?)\u0026amp;lt;\\/style\u0026amp;gt;//sgmi;\n$html =~ s/\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;title\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;(.*?)\u0026amp;lt;\\/title\u0026amp;gt;//sgmi;\n$html =~ s/\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026amp;lt;!--(.*?)--\u0026amp;gt;\u0026lt;/span\u0026gt;/\\n/sgmi;\n\n$html =~ s/\\/\\//\\//gi;\n$html =~ s/http:\\//http:\\/\\//gi;\n$html =~ s/https:\\//https:\\/\\//gi;\n\n$html =~ s/\u0026amp;lt;(?:[^\u0026amp;gt;\u0026apos;\u0026quot;]*|([\u0026apos;\u0026quot;]).*?\\1)*\u0026amp;gt;//gsi;\n$html =~ s/\\r\\r//gi;\n$html =~ s/\\[img]\\//\\[img]/gi;\n$html =~ s/\\[url=\\//\\[url=/gi;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;About the question of the regular expression methods to parse (x)HTML, the answer to all of the ones who spoke about some limits is: you have not been trained enough to rule the force of this powerful weapon, since \u0026lt;strong\u0026gt;nobody\u0026lt;/strong\u0026gt; here spoke about \u0026lt;strong\u0026gt;recursion\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A regular expression-agnostic colleague notified me this discussion, which is not certainly the first on the web about this old and hot topic.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;After reading some posts, the first thing I did was looking for the \u0026quot;?R\u0026quot; string in this thread. The second was to search about \u0026quot;recursion\u0026quot;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;No, holy cow, no match found. Since nobody mentioned the main mechanism a parser is built onto, I was soon aware that nobody got the point.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If an (x)HTML parser needs recursion, a regular expression parser without recursion is not enough for the purpose. It\u0026apos;s a simple construct.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The \u0026lt;strong\u0026gt;black art of regular expressions is hard to master\u0026lt;/strong\u0026gt;, so maybe there are further possibilities we left out while trying and testing our personal solution to capture the whole web in one hand... Well, I am sure about it :)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Here\u0026apos;s the magic pattern:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;$pattern = \u0026quot;/\u0026amp;lt;([\\w]+)([^\u0026amp;gt;]*?)(([\\s]*\\/\u0026amp;gt;)|(\u0026amp;gt;((([^\u0026amp;lt;]*?|\u0026amp;lt;\\!\\-\\-.*?\\-\\-\u0026amp;gt;)|(?R))*)\u0026amp;lt;\\/\\\\1[\\s]*\u0026amp;gt;))/s\u0026quot;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Just try it. It\u0026apos;s written as a PHP string, so the \u0026quot;s\u0026quot; modifier makes classes include newlines.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Here\u0026apos;s a \u0026lt;strong\u0026gt;sample note on the PHP manual\u0026lt;/strong\u0026gt; I wrote in January: \u0026lt;a href=\u0026quot;http://php.net/manual/en/regexp.reference.recursive.php\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Reference\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;(Take care. In that note I wrongly used the \u0026quot;m\u0026quot; modifier; it should be erased, notwithstanding it is discarded by the regular expression engine, since no \u0026lt;code\u0026gt;^\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;$\u0026lt;/code\u0026gt; anchoring was used).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Now, we could speak about the limits of this method from a more informed point of view:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;according to the specific implementation of the regular expression engine, recursion may have a limit in the \u0026lt;strong\u0026gt;number of nested patterns parsed\u0026lt;/strong\u0026gt;, but it depends on the language used\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;although corrupted, (x)HTML does not drive into severe errors. It is not \u0026lt;em\u0026gt;sanitized\u0026lt;/em\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;Anyhow, it is only a regular expression pattern, but it discloses the possibility to develop of a lot of powerful implementations.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I wrote this pattern to power the \u0026lt;em\u0026gt;recursive descent parser\u0026lt;/em\u0026gt; of a template engine I built in my framework, and performances are really great, both in execution times or in memory usage (nothing to do with other template engines which use the same syntax).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026amp;lt;\\s*(\\w+)[^/\u0026amp;gt;]*\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The parts explained:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;\u0026amp;lt;\u0026lt;/code\u0026gt;: Starting character\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;\\s*\u0026lt;/code\u0026gt;: It may have whitespaces before the tag name (ugly, but possible).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;(\\w+)\u0026lt;/code\u0026gt;: tags can contain letters and numbers (h1). Well, \u0026lt;code\u0026gt;\\w\u0026lt;/code\u0026gt; also matches \u0026apos;_\u0026apos;, but it does not hurt I guess. If curious, use ([a-zA-Z0-9]+) instead.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;[^/\u0026amp;gt;]*\u0026lt;/code\u0026gt;: Anything except \u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;/\u0026lt;/code\u0026gt; until closing \u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt;: Closing \u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;UNRELATED\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;And to the fellows, who underestimate regular expressions, saying they are only as powerful as regular languages:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;a\u0026lt;sup\u0026gt;n\u0026lt;/sup\u0026gt;ba\u0026lt;sup\u0026gt;n\u0026lt;/sup\u0026gt;ba\u0026lt;sup\u0026gt;n\u0026lt;/sup\u0026gt; which is not regular and not even context free, can be matched with \u0026lt;code\u0026gt;^(a+)b\\1b\\1$\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Backreferencing \u0026lt;a href=\u0026quot;http://en.wiktionary.org/wiki/FTW\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;FTW\u0026lt;/a\u0026gt;!\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As many people have already pointed out, HTML is not a regular language which can make it very difficult to parse. My solution to this is to turn it into a regular language using a tidy program and then to use an XML parser to consume the results. There are a lot of good options for this. My program is written using Java with the \u0026lt;a href=\u0026quot;http://jtidy.sourceforge.net/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;jtidy\u0026lt;/a\u0026gt; library to turn the HTML into XML and then Jaxen to xpath into the result.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you\u0026apos;re simply trying to find those tags (without ambitions of parsing) try this regular expression:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;/\u0026amp;lt;[^/]*?\u0026amp;gt;/g\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I wrote it in 30 seconds, and tested here:\n\u0026lt;a href=\u0026quot;http://gskinner.com/RegExr/\u0026quot;\u0026gt;http://gskinner.com/RegExr/\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It matches the types of tags you mentioned, while ignoring the types you said you wanted to ignore.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It seems to me you\u0026apos;re trying to match tags without a \u0026quot;/\u0026quot; at the end. Try this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026amp;lt;([a-zA-Z][a-zA-Z0-9]*)[^\u0026amp;gt;]*(?\u0026amp;lt;!/)\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It\u0026apos;s true that when programming it\u0026apos;s usually best to use dedicated parsers and APIs instead of regular expressions when dealing with HTML, especially if accuracy is paramount (e.g., if your processing might have security implications). However, I dont ascribe to a dogmatic view that XML-style markup should never be processed with regular expressions. There are cases when regular expressions are a great tool for the job, such as when making one-time edits in a text editor, fixing broken XML files, or dealing with file formats that look like but arent quite XML. There are some issues to be aware of, but they\u0026apos;re not insurmountable or even necessarily relevant.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A simple regex like \u0026lt;code\u0026gt;\u0026amp;lt;([^\u0026amp;gt;\u0026quot;\u0026apos;]|\u0026quot;[^\u0026quot;]*\u0026quot;|\u0026apos;[^\u0026apos;]*\u0026apos;)*\u0026amp;gt;\u0026lt;/code\u0026gt; is usually good enough, in cases such as those I just mentioned. It\u0026apos;s a naive solution, all things considered, but it does correctly allow unencoded \u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt; symbols in attribute values. If you\u0026apos;re looking for, e.g., a \u0026lt;code\u0026gt;table\u0026lt;/code\u0026gt; tag, you could adapt it as \u0026lt;code\u0026gt;\u0026amp;lt;/?table\\b([^\u0026amp;gt;\u0026quot;\u0026apos;]|\u0026quot;[^\u0026quot;]*\u0026quot;|\u0026apos;[^\u0026apos;]*\u0026apos;)*\u0026amp;gt;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Just to give a sense of what a more \u0026quot;advanced\u0026quot; HTML regex would look like, the following does a fairly respectable job of emulating real-world browser behavior and the HTML5 parsing algorithm:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026amp;lt;/?([A-Za-z][^\\s\u0026amp;gt;/]*)(?:=\\s*(?:\u0026quot;[^\u0026quot;]*\u0026quot;|\u0026apos;[^\u0026apos;]*\u0026apos;|[^\\s\u0026amp;gt;]+)|[^\u0026amp;gt;])*(?:\u0026amp;gt;|$)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The following matches a fairly strict definition of XML tags (although it doesn\u0026apos;t account for the full set of Unicode characters allowed in XML names):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026amp;lt;(?:([_:A-Z][-.:\\w]*)(?:\\s+[_:A-Z][-.:\\w]*\\s*=\\s*(?:\u0026quot;[^\u0026quot;]*\u0026quot;|\u0026apos;[^\u0026apos;]*\u0026apos;))*\\s*/?|/([_:A-Z][-.:\\w]*)\\s*)\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Granted, these don\u0026apos;t account for surrounding context and a few edge cases, but even such things could be dealt with if you really wanted to (e.g., by searching between the matches of another regex).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;At the end of the day, use the most appropriate tool for the job, even in the cases when that tool happens to be a regex.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Although it\u0026apos;s not suitable and effective to use regular expressions for that purpose sometimes regular expressions provide quick solutions for simple match problems and in my view it\u0026apos;s not that horrbile to use regular expressions for trivial works. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There is a \u0026lt;a href=\u0026quot;http://blog.stevenlevithan.com/archives/match-innermost-html-element\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;definitive blog post\u0026lt;/a\u0026gt; about matching innermost HTML elements written by Steven Levithan.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you only want the tag names, it should be possible to do this via a regular expression.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026amp;lt;([a-zA-Z]+)(?:[^\u0026amp;gt;]*[^/] *)?\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;should do what you need. But I think the solution of \u0026quot;moritz\u0026quot; is already fine. I didn\u0026apos;t see it in the beginning.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For all downvoters: In some cases it just makes sense to use a regular expression, because it can be the easiest and quickest solution. I agree that in general you should not parse HTML with regular expressions.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;But regular expressions can be a very powerful tool when you have a subset of HTML where you know the format and you just want to extract some values. I did that hundreds of times and almost always achieved what I wanted.\u0026lt;/p\u0026gt;\n    "],"comment":["\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Kobi: I think it\u0026apos;s time for me to quit the post of Assistant Don\u0026apos;t Parse HTML With Regex Officer. No matter how many times we say it, they won\u0026apos;t stop coming every day... every hour even. It is a lost cause, which someone else can fight for a bit. So go on, parse HTML with regex, if you must. It\u0026apos;s only broken code, not life and death.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/18936/bobince\u0026quot; title=\u0026quot;515,904 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;bobince\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment1612336_1732454\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-11-13 23:18:03Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 13, 2009 at 23:18\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;If you can\u0026apos;t see this post, here\u0026apos;s a screencapture of it in all its glory: \u0026lt;a href=\u0026quot;http://imgur.com/gOPS2.png\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;imgur.com/gOPS2.png\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/68086/andrew-keeton\u0026quot; title=\u0026quot;20,787 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Andrew Keeton\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment1647711_1732454\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-11-19 14:37:27Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 19, 2009 at 14:37\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Also, scraping fairly regularly formatted data from large documents is going to be WAY faster with judicious use of scan \u0026amp;amp; regex than any generic parser. And if you are comfortable with coding regexes, way faster to code than coding xpaths. And almost certainly less fragile to changes in what you are scraping. So bleh.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/173542/michael-johnston\u0026quot; title=\u0026quot;5,208 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Michael Johnston\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment13095248_1733489\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-04-17 20:47:27Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 17, 2012 at 20:47\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@MichaelJohnston \u0026quot;Less fragile\u0026quot;? Almost certainly not. Regexes care about text-formatting details than an XML parser can silently ignore. Switching between \u0026lt;code\u0026gt;\u0026amp;amp;foo;\u0026lt;/code\u0026gt; encodings and \u0026lt;code\u0026gt;CDATA\u0026lt;/code\u0026gt; sections? Using an HTML minifier to remove all whitespace in your document that the browser doesn\u0026apos;t render? An XML parser won\u0026apos;t care, and neither will a well-written XPath statement. A regex-based \u0026quot;parser\u0026quot;, on the other hand...\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/14122/charles-duffy\u0026quot; title=\u0026quot;259,585 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Charles Duffy\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment15088991_1733489\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-07-11 16:03:24Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 11, 2012 at 16:03\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@CharlesDuffy for an one time job it\u0026apos;s ok, and for spaces we use \\s+\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1090657/quantum\u0026quot; title=\u0026quot;3,492 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;quantum\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment15115534_1733489\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-07-12 13:50:01Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 12, 2012 at 13:50\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@xiaomao indeed, if having to know all the gotchas and workarounds to get an 80% solution that fails the rest of the time \u0026quot;works for you\u0026quot;, I can\u0026apos;t stop you. Meanwhile, I\u0026apos;m over on my side of the fence using parsers that work on 100% of syntactically valid XML.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/14122/charles-duffy\u0026quot; title=\u0026quot;259,585 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Charles Duffy\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment15120388_1733489\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-07-12 16:07:28Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 12, 2012 at 16:07\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I once had to pull some data off ~10k pages, all with the same HTML template. They were littered with HTML errors that caused parsers to choke, and all their styling was inline or with \u0026lt;code\u0026gt;\u0026amp;lt;font\u0026amp;gt;\u0026lt;/code\u0026gt; etc.: no classes or IDs to help navigate the DOM. After fighting all day with the \u0026quot;right\u0026quot; approach, I finally switched to a regex solution and had it working in an hour.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/122087/paul-a-jungwirth\u0026quot; title=\u0026quot;22,242 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Paul A Jungwirth\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment16523188_1733489\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-09-07 07:14:38Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 7, 2012 at 7:14\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;The OP is asking to parse a very limited subset of XHTML: start tags. What makes (X)HTML a CFG is its potential to have elements between the start and end tags of other elements (as in a grammar rule \u0026lt;code\u0026gt;A -\u0026amp;gt; s A e\u0026lt;/code\u0026gt;). (X)HTML does \u0026lt;i\u0026gt;not\u0026lt;/i\u0026gt; have this property \u0026lt;i\u0026gt;within\u0026lt;/i\u0026gt; a start tag: a start tag cannot contain other start tags. The subset that the OP is trying to parse is not a CFG.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/423105/larsh\u0026quot; title=\u0026quot;26,696 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;LarsH\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment12073546_1758162\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-03-02 08:43:55Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 2, 2012 at 8:43\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;In CS theory, regular languages \u0026lt;i\u0026gt;are\u0026lt;/i\u0026gt; a strict subset of context-free languages, but regular expression implementations in mainstream programming languages are more powerful.  As \u0026lt;a href=\u0026quot;http://www.noulakaz.net/weblog/2007/03/18/a-regular-expression-to-check-for-prime-numbers/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;noulakaz.net/weblog/2007/03/18/\u0026lt;/a\u0026gt; describes, so-called \u0026quot;regular expressions\u0026quot; can check for prime numbers in unary, which is certainly something that a regular expression from CS theory can\u0026apos;t accomplish.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/960195/adam-mihalcin\u0026quot; title=\u0026quot;13,724 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Adam Mihalcin\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment12448141_1758162\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-03-19 23:50:52Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 19, 2012 at 23:50\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@eyelidlessness: the same \u0026quot;only if\u0026quot; applies to all CFGs, does it not? I.e. if the (X)HTML input is not well-formed, not even a full-blown XML parser will work reliably. Maybe if you give examples of the \u0026quot;(X)HTML syntax errors implemented in real world user agents\u0026quot; you\u0026apos;re referring to, I\u0026apos;ll understand what you\u0026apos;re getting at better.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/423105/larsh\u0026quot; title=\u0026quot;26,696 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;LarsH\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment13885068_1758162\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-05-22 05:09:22Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 22, 2012 at 5:09\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@AdamMihalcin is exactly right. Most extant regex engines are more powerful than Chomsky Type 3 grammars (eg non-greedy matching, backrefs). Some regex engines (such as Perl\u0026apos;s) are Turing complete. It\u0026apos;s true that even those are poor tools for parsing HTML, but this oft-cited argument is not the reason why.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/272427/dubiousjim\u0026quot; title=\u0026quot;4,622 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;dubiousjim\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment14106691_1758162\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-05-31 13:44:04Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 31, 2012 at 13:44\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;This is the most \u0026quot;full and short\u0026quot; answer here. It leads people to learn basics of formal grammars and languages and hopefully some maths so they will not wast time on hopeless things like solving NP-tasks in polynomial time\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/639353/mishmashru\u0026quot; title=\u0026quot;447 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;mishmashru\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment22995858_1758162\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-04-19 12:15:57Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 19, 2013 at 12:15\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Divison by zero is a much easier problem than the others you mention. If you use intervals, rather than plain floating point arithmetic (which everyone should be but nobody is), you can happily divide something by [an interval containing] zero. The result is simply an interval containing plus and minus infinity.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3408/rjmunro\u0026quot; title=\u0026quot;26,105 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;rjmunro\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment14424307_5236278\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-06-14 10:53:39Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 14, 2012 at 10:53\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Fermat\u0026apos;s small margin problem has been solved by soft margins in modern text-editing software.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/820321/kd4ttc\u0026quot; title=\u0026quot;1,038 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;kd4ttc\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment21359004_5236278\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-03-01 20:24:32Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 1, 2013 at 20:24\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Fermat\u0026apos;s small margin problem has been solved by Randall Munroe by setting the fontsize to zero: \u0026lt;a href=\u0026quot;http://xkcd.com/1381/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;xkcd.com/1381\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/401828/heltonbiker\u0026quot; title=\u0026quot;25,339 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;heltonbiker\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment41473537_5236278\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-10-16 19:55:17Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 16, 2014 at 19:55\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;FYI: Fermat\u0026apos;s problem \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Wiles%27_proof_of_Fermat%27s_Last_Theorem\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;has \u0026lt;i\u0026gt;actually\u0026lt;/i\u0026gt; been solved in 1995\u0026lt;/a\u0026gt;, and it only took mathematicians 358 years to do so.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/202504/jmiserez\u0026quot; title=\u0026quot;2,784 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;jmiserez\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment44568333_5236278\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-01-22 18:40:17Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 22, 2015 at 18:40\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I was able to bypass that sticky divide-by-zero step by instead using Brownian ratchets yielded from cold fusion...though it only works when I remove the cosmological constant.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/880904/tim-lehner\u0026quot; title=\u0026quot;14,305 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Tim Lehner\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment59460768_5236278\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-03-09 18:52:43Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 9, 2016 at 18:52\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I would go with something that works on sane things than weep about not being universally perfect :-)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1176394/prajeesh-kumar\u0026quot; title=\u0026quot;1,876 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;prajeesh kumar\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment13616563_1736801\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-05-10 03:44:49Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 10, 2012 at 3:44\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;so you do not actually solve the parsing problem with regexp only but as a part of the parser this may work. PS: working product doesn\u0026apos;t mean good code. No offence, but this is how industrial programming works and gets their money\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/639353/mishmashru\u0026quot; title=\u0026quot;447 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;mishmashru\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment22995936_1736801\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-04-19 12:18:30Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 19, 2013 at 12:18\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Your regex starts fail on the very shortest possible, valid HTML: \u0026lt;code\u0026gt;\u0026amp;lt;!doctype html\u0026amp;gt;\u0026amp;lt;title\u0026amp;gt;\u0026amp;lt;\u0026amp;lt;/title\u0026amp;gt;\u0026lt;/code\u0026gt;. Simple \u0026lt;code\u0026gt;\u0026apos;\u0026amp;lt;!doctype html\u0026amp;gt;\u0026amp;lt;title\u0026amp;gt;\u0026amp;lt;\u0026amp;lt;/title\u0026amp;gt;\u0026apos;.match(/\u0026amp;lt;(?:\u0026quot;[^\u0026quot;]*\u0026quot;[\u0026apos;\u0026quot;]*|\u0026apos;[^\u0026apos;]*\u0026apos;[\u0026apos;\u0026quot;]*|[^\u0026apos;\u0026quot;\u0026amp;gt;])+\u0026amp;gt;/g)\u0026lt;/code\u0026gt; returns \u0026lt;code\u0026gt;[\u0026quot;\u0026amp;lt;!doctype html\u0026amp;gt;\u0026quot;, \u0026quot;\u0026amp;lt;title\u0026amp;gt;\u0026quot;, \u0026quot;\u0026amp;lt;\u0026amp;lt;/title\u0026amp;gt;\u0026quot;]\u0026lt;/code\u0026gt; while should \u0026lt;code\u0026gt;[\u0026quot;\u0026amp;lt;title\u0026amp;gt;\u0026quot;, \u0026quot;\u0026amp;lt;/title\u0026amp;gt;\u0026quot;]\u0026lt;/code\u0026gt;.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;span class=\u0026quot;comment-user\u0026quot;\u0026gt;user1180790\u0026lt;/span\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment35875284_1736801\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-05-01 16:48:11Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 1, 2014 at 16:48\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;if we\u0026apos;re just trying to match \u0026amp;amp; not match the examples given, /\u0026amp;lt;.([^r\u0026amp;gt;][^\u0026amp;gt;]*)?\u0026amp;gt;/g works :-) // javascript:  \u0026apos;\u0026amp;lt;p\u0026amp;gt; \u0026amp;lt;a href=\u0026quot;foo\u0026quot;\u0026amp;gt; \u0026amp;lt;br /\u0026amp;gt; \u0026amp;lt;hr class=\u0026quot;foo\u0026quot; /\u0026amp;gt;\u0026apos;.match(/\u0026amp;lt;.([^r\u0026amp;gt;][^\u0026amp;gt;]*)?\u0026amp;gt;/g)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/358236/imma\u0026quot; title=\u0026quot;4,822 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;imma\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment36631031_1736801\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-05-22 16:14:26Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 22, 2014 at 16:14\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026quot;Is someone using CDATA inside HTML?\u0026quot; - yes, I do. It takes less bytes if you show HTML source code in \u0026lt;code\u0026gt;\u0026amp;lt;pre\u0026amp;gt;\u0026lt;/code\u0026gt; tags.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/282601/cweiske\u0026quot; title=\u0026quot;28,834 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;cweiske\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment54059485_1736801\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-10-14 10:56:16Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 14, 2015 at 10:56\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Good Lord, it\u0026apos;s massive. My biggest question is why? You realize that all modern languages have XML parsers, right? You can do all that in like 3 lines and be sure it\u0026apos;ll work. Furthermore, do you also realize that pure regex is \u0026lt;b\u0026gt;provably\u0026lt;/b\u0026gt; unable to do certain things? Unless you\u0026apos;ve created a hybrid regex/imperative code parser, but it doesn\u0026apos;t look like you have. Can you compress random data as well?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/399649/justin-morgan\u0026quot; title=\u0026quot;28,845 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Justin Morgan\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment5890952_5233151\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-03-08 15:23:45Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 8, 2011 at 15:23\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Justin I don\u0026apos;t need a reason. It could be done (and it wasn\u0026apos;t illegal/immoral), so I have done it. There are no limitations to the mind except those we acknowledge (Napoleon Hill)... Modern languages can parse XML? Really? And I thought that THAT was illegal! :-)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/613130/xanatos\u0026quot; title=\u0026quot;106,603 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;xanatos\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment5891077_5233151\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-03-08 15:31:34Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 8, 2011 at 15:31\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Sir, I\u0026apos;m convinced. I\u0026apos;m going to use this code as part of the kernel for my perpetual-motion machine--can you believe those fools at the patent office keep rejecting my application? Well, I\u0026apos;ll show them. I\u0026apos;ll show them all!\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/399649/justin-morgan\u0026quot; title=\u0026quot;28,845 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Justin Morgan\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment5893435_5233151\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-03-08 17:55:54Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 8, 2011 at 17:55\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Justin So an Xml Parser is by definition bug free, while a Regex isn\u0026apos;t? Because if an Xml Parser isn\u0026apos;t bug free by definition there could be an xml that make it crash and we are back to step 0. Let say this: both the Xml Parser and this Regex try to be able to parse all the \u0026quot;legal\u0026quot; XML. They CAN parse some \u0026quot;illegal\u0026quot; XML. Bugs could crash both of them. C# XmlReader is surely more tested than this Regex.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/613130/xanatos\u0026quot; title=\u0026quot;106,603 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;xanatos\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment5907706_5233151\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-03-09 15:08:36Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 9, 2011 at 15:08\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;No, nothing is bug free: 1) All programs contain at least one bug. 2) All programs contain at least one line of unnecessary source code. 3) By #1 and #2 and using logical induction, it\u0026apos;s a simple matter to prove that any program can be reduced to a single line of code with a bug. (from Learning Perl)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/244811/scott-weaver\u0026quot; title=\u0026quot;6,927 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Scott Weaver\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment11735313_5233151\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-02-16 00:53:34Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 16, 2012 at 0:53\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Im afraid you did not get the joke, @kenorb. Please, read the question and the accepted answer once more. This is not about HTML parsing tools in general, nor about HTML parsing shell tools, its about parsing HTML via regexes.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2157640/palec\u0026quot; title=\u0026quot;11,673 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Palec\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment54010279_2263520\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-10-13 08:12:01Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 13, 2015 at 8:12\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;No, @Abdul. It is completely, provably (in the mathematical sense) impossible.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2157640/palec\u0026quot; title=\u0026quot;11,673 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Palec\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment73090810_2263520\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-03-24 13:24:19Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 24, 2017 at 13:24\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Yes, that answer summarizes it well, @Abdul. Note that, however, regex implementations are not really \u0026lt;i\u0026gt;regular\u0026lt;/i\u0026gt; expressions in the mathematical sense -- they have constructs that make them stronger, often Turing-complete (equivalent to Type 0 grammars). The argument breaks with this fact, but is still somewhat valid in the sense that regexes were never meant to be capable of doing such a job, though.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2157640/palec\u0026quot; title=\u0026quot;11,673 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Palec\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment73093275_2263520\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-03-24 14:24:35Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 24, 2017 at 14:24\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;And by the way, the joke I referred to was the content of this answer before kenorb\u0026apos;s (radical) edits, specifically revision 4, @Abdul.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2157640/palec\u0026quot; title=\u0026quot;11,673 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Palec\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment73093363_2263520\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-03-24 14:26:48Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 24, 2017 at 14:26\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;The funny thing is that OP never asked to parse html using regex. He asked to match text (which happens to be HTML) using regex. Which is perfectly reasonable.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/11906/paralife\u0026quot; title=\u0026quot;5,986 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Paralife\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment86127667_2263520\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-03-29 15:29:49Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 29, 2018 at 15:29\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026lt;code\u0026gt;System.Text\u0026lt;/code\u0026gt; is not part of C#. It\u0026apos;s part of .NET.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/76337/john-saunders\u0026quot; title=\u0026quot;159,292 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;John Saunders\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment11457016_7564061\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-02-02 19:07:53Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 2, 2012 at 19:07\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;In the first line of your regex (\u0026lt;code\u0026gt;(?=\u0026amp;lt;ul\\s*id=\u0026quot;matchMe\u0026quot;\\s*type=\u0026quot;square\u0026quot;\\s*\u0026amp;gt;) # match start with \u0026amp;lt;ul id=\u0026quot;matchMe\u0026quot;...\u0026lt;/code\u0026gt;), in between \u0026quot;\u0026amp;lt;ul\u0026quot; and \u0026quot;id\u0026quot; should be \u0026lt;code\u0026gt;\\s+\u0026lt;/code\u0026gt;, not \u0026lt;code\u0026gt;\\s*\u0026lt;/code\u0026gt;, unless you want it to match \u0026amp;lt;ulid=... ;)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1344461/c0deh4cker\u0026quot; title=\u0026quot;3,857 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;C0deH4cker\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment14956273_7564061\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-07-06 02:49:08Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 6, 2012 at 2:49\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@C0deH4cker You are correct, the expression should have \u0026lt;code\u0026gt;\\s+\u0026lt;/code\u0026gt; instead of \u0026lt;code\u0026gt;\\s*\u0026lt;/code\u0026gt;.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/590956/sam\u0026quot; title=\u0026quot;26,379 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Sam\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment14982109_7564061\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-07-06 22:33:05Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 6, 2012 at 22:33\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Not that I really understand it, but I think your regex fails on \u0026lt;code\u0026gt;\u0026amp;lt;img src=\u0026quot;images/pic.jpg\u0026quot; /\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1455622/scheintod\u0026quot; title=\u0026quot;7,714 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Scheintod\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment28164133_7564061\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-09-27 17:05:13Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 27, 2013 at 17:05\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Scheintod Thank you for the comment.  I updated the code.  The previous expression failed for self closing tags that had a \u0026lt;code\u0026gt;/\u0026lt;/code\u0026gt; somewhere inside which failed for your \u0026lt;code\u0026gt;\u0026amp;lt;img src=\u0026quot;images/pic.jpg\u0026quot; /\u0026amp;gt;\u0026lt;/code\u0026gt; html.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/590956/sam\u0026quot; title=\u0026quot;26,379 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Sam\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment28167413_7564061\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-09-27 19:00:25Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 27, 2013 at 19:00\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@KylejQuery does not parse XML, it uses the client\u0026apos;s builtin parser (if there is one). Therefore you do not need jQuery to do it, but as little as two lines of \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Parsing_and_serializing_XML\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;plain old JavaScript\u0026lt;/a\u0026gt;. If there is no builtin parser, jQuery will not help.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/257182/robg\u0026quot; title=\u0026quot;135,390 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;RobG\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment29262125_1732595\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-10-31 06:25:27Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 31, 2013 at 6:25\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@RobG Actually jQuery uses the DOM, not the built-in parser.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/510036/qix-monica-was-mistreated\u0026quot; title=\u0026quot;13,383 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Qix - MONICA WAS MISTREATED\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment40656661_1732595\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-09-22 03:49:04Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 22, 2014 at 3:49\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Qixyou\u0026apos;d better tell the authors of the documentation then: \u0026quot;\u0026lt;i\u0026gt;jQuery.parseXML uses the native parsing function of the browser\u0026lt;/i\u0026gt;\u0026quot;. Source: \u0026lt;a href=\u0026quot;http://api.jquery.com/jQuery.parseXML/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;i\u0026gt;jQuery.parseXML()\u0026lt;/i\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/257182/robg\u0026quot; title=\u0026quot;135,390 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;RobG\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment40657671_1732595\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-09-22 05:01:30Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 22, 2014 at 5:01\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Having come here from the meme question (\u0026lt;a href=\u0026quot;http://meta.stackexchange.com/questions/19478/the-many-memes-of-meta/19479#19479\u0026quot; title=\u0026quot;the many memes of meta\u0026quot;\u0026gt;meta.stackexchange.com/questions/19478/the-many-memes-of-meta/\u0026lt;/a\u0026gt;), I love that one of the answers is \u0026apos;Use jQuery\u0026apos;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/8681/jorn\u0026quot; title=\u0026quot;17,482 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Jorn\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment60351141_1732595\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-04-01 21:09:45Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 1, 2016 at 21:09\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;+1 for noting that the question is not about parsing full (X)HTML, it\u0026apos;s about matching (X)HTML open tags.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/423105/larsh\u0026quot; title=\u0026quot;26,696 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;LarsH\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment16545748_2146912\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-09-08 02:26:22Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 8, 2012 at 2:26\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Something else most of the answers seem to ignore, is that an HTML parser can very well use regular expressions in its implementation for parts of HTML, and I would be surprised if most parsers didn\u0026apos;t do this.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2543666/thayne\u0026quot; title=\u0026quot;6,341 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Thayne\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment46771251_2146912\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-03-26 19:15:04Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 26, 2015 at 19:15\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Thayne Exactly. When parsing individual tags, a regular expression is the right tool for the job. It is quite ridiculous that one has to scroll halfway down the page to find a reasonable answer. The accepted answer is incorrect because it mixes up lexing and parsing.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3476849/kasperd\u0026quot; title=\u0026quot;1,882 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;kasperd\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment55471750_2146912\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-11-22 10:26:25Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 22, 2015 at 10:26\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;The answer given here will fail when an attribute value contains a \u0026apos;\u0026amp;gt;\u0026apos; or \u0026apos;/\u0026apos; character.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3829420/martin-l\u0026quot; title=\u0026quot;936 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Martin L\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment61105461_2146912\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-04-21 08:14:04Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 21, 2016 at 8:14\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;This will work incorrectly on HTML containing comments or CData sections.  It will also not work correctly if a quoted attribute contains a \u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt; character. I agree what OP suggest \u0026lt;i\u0026gt;can\u0026lt;/i\u0026gt; be done with a regex, but the one presented here is far to simplistic.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/7488/jacquesb\u0026quot; title=\u0026quot;41,075 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;JacquesB\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment77757983_2146912\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-07-30 10:14:41Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 30, 2017 at 10:14\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026amp;lt;a href=\u0026quot;foo\u0026quot; title=\u0026quot;5\u0026amp;gt;3\u0026quot;\u0026amp;gt; Oops \u0026amp;lt;/a\u0026amp;gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/31582/gareth\u0026quot; title=\u0026quot;125,465 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Gareth\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment1612303_1732395\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-11-13 23:11:39Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 13, 2009 at 23:11\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt; is valid in an attribute value. Indeed, in the canonical XML serialisation you must not use \u0026lt;code\u0026gt;\u0026amp;amp;gt;\u0026lt;/code\u0026gt;. (Which isn\u0026apos;t entirely relevant, except to emphasise that \u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt; in an attribute value is not at all an unusual thing.)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/18936/bobince\u0026quot; title=\u0026quot;515,904 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;bobince\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment1612577_1732395\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-11-14 00:15:33Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 14, 2009 at 0:15\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Kobi: what does the exlamation mark (the one you placed tpward the end) mean in a regexp?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/260080/marco-demaio\u0026quot; title=\u0026quot;32,479 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Marco Demaio\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment6710778_1732395\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-04-30 17:16:11Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 30, 2011 at 17:16\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@bobince: are u sure? I don\u0026apos;t understand anymore, so is this valid HTML too: \u0026lt;code\u0026gt;\u0026amp;lt;div title=\u0026quot;this tag is a \u0026amp;lt;div\u0026amp;gt;\u0026amp;lt;/div\u0026amp;gt;\u0026quot;\u0026amp;gt;hello\u0026amp;lt;/div\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/260080/marco-demaio\u0026quot; title=\u0026quot;32,479 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Marco Demaio\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment6710897_1732395\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-04-30 17:31:15Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 30, 2011 at 17:31\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@MarcoDemaio - \u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt; does not have to be escaped in an attribute value, but \u0026lt;code\u0026gt;\u0026amp;lt;\u0026lt;/code\u0026gt; does. So this is would be valid HTML: \u0026lt;code\u0026gt;\u0026amp;lt;div title=\u0026quot;this tag is a \u0026amp;amp;lt;div\u0026amp;gt;\u0026amp;amp;lt;/div\u0026amp;gt;\u0026quot;\u0026amp;gt;hello\u0026amp;lt;/div\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/317052/daniel-haley\u0026quot; title=\u0026quot;49,268 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Daniel Haley\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment67296534_1732395\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-10-12 22:11:04Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 12, 2016 at 22:11\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;If you\u0026apos;re dealing with real XHTML then append getElementsByTagName with \u0026lt;code\u0026gt;NS\u0026lt;/code\u0026gt; and specify the namespace.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/145190/meder-omuraliev\u0026quot; title=\u0026quot;178,452 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;meder omuraliev\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment1618096_1737662\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-11-15 14:39:44Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 15, 2009 at 14:39\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;CodePlex closed down (but this one is in the CodePlex archive). Perhaps update?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/63550/peter-mortensen\u0026quot; title=\u0026quot;30,018 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Peter Mortensen\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment112135990_1745488\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2020-08-14 15:47:34Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 14, 2020 at 15:47\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;That\u0026apos;s not a psuedo regexp form, that\u0026apos;s an EBNF form, as specified here: \u0026lt;a href=\u0026quot;http://www.w3.org/TR/REC-xml/#sec-notation\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;XML spec, appendix 6\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2097355/rob-g\u0026quot; title=\u0026quot;64 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Rob G\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment45231567_1736770\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-02-11 10:34:58Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 11, 2015 at 10:34\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Does not match valid tags having attributes with no value, i.e. \u0026lt;code\u0026gt;\u0026amp;lt;option selected\u0026amp;gt;\u0026lt;/code\u0026gt;. Also does not match valid tags with unquoted attribute values, i.e. \u0026lt;code\u0026gt;\u0026amp;lt;p id=10\u0026amp;gt;\u0026lt;/code\u0026gt;.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/433790/ridgerunner\u0026quot; title=\u0026quot;32,361 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;ridgerunner\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment8098950_6817767\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-07-25 15:01:59Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 25, 2011 at 15:01\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@ridgerunner: Thanks very much for your comment. In that case the pattern must change a bit: $pattern = \u0026apos;/\u0026amp;lt;(\\w+)(\\s+(\\w+)(\\s*\\=\\s*(\\\u0026apos;|\u0026quot;|)(.*?)\\\\5\\s*)?)*\\s*\u0026amp;gt;/\u0026apos;; I tested it and works in case of non-quoted attributes or attributes with no value.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/383764/yodabar\u0026quot; title=\u0026quot;4,501 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;yodabar\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment8100663_6817767\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-07-25 16:41:46Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 25, 2011 at 16:41\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 3 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;How about a space before the tag name: \u0026lt;code\u0026gt;\u0026amp;lt; a href=\u0026quot;http://wtf.org\u0026quot; \u0026amp;gt;\u0026lt;/code\u0026gt; I\u0026apos;m pretty sure it is legal, but you don\u0026apos;t match it.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1967396/floris\u0026quot; title=\u0026quot;45,073 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Floris\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment28400943_6817767\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-10-05 04:58:49Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 5, 2013 at 4:58\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;NO sorry, whitespaces before a tagname are illegal. Beyond being \u0026quot;pretty sure\u0026quot; why don\u0026apos;t you provide some evidences of your objection? Here are mine, \u0026lt;a href=\u0026quot;http://www.w3.org/TR/xml11/#sec-starttags\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;w3.org/TR/xml11/#sec-starttags\u0026lt;/a\u0026gt; referred to XML 1.1, and you can find the same for HTML 4, 5 and XHTML, as a W3C validation would also warn if you make a test. As a lot of other blah-blah-poets around here, I did not still receive any intelligent argumentation, apart some hundred of minus to my answers, to demonstrate where my code fails according to the \u0026lt;i\u0026gt;rules of contract\u0026lt;/i\u0026gt; specified in the question. I would only welcome them.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/383764/yodabar\u0026quot; title=\u0026quot;4,501 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;yodabar\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment28430952_6817767\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-10-06 18:03:45Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 6, 2013 at 18:03\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;XML tags can contain colons, e.g. \u0026lt;code\u0026gt;\u0026amp;lt;namespace:name\u0026amp;gt;\u0026lt;/code\u0026gt;, is that not so in HTML?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/22820/qwertie\u0026quot; title=\u0026quot;15,216 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Qwertie\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment111341890_6817767\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2020-07-17 21:54:59Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 17, 2020 at 21:54\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026quot;I don\u0026apos;t attempt to parse idiot HTML that is deliberately broken.\u0026quot;  How does your code know the difference?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/125389/kevin-panko\u0026quot; title=\u0026quot;8,099 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Kevin Panko\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment8124904_6653839\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-07-26 20:38:07Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 26, 2011 at 20:38\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;(get attributes bug 1) \u0026lt;code\u0026gt;/(\\w+)=\u0026quot;(.*?)\u0026quot;/\u0026lt;/code\u0026gt; assumes double quotes. It will miss values in single quotes. In html version 4 and earlier unquoted value is allowed, if it is a simple word.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/904933/david-andersson\u0026quot; title=\u0026quot;725 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;David Andersson\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment66191097_6653839\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-09-11 08:23:51Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 11, 2016 at 8:23\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;(get attributes bug 2) \u0026lt;code\u0026gt;/(\\w+)=\u0026quot;(.*?)\u0026quot;/\u0026lt;/code\u0026gt; may falsely match text that looks like an attribute within an attribute, e.g. \u0026lt;code\u0026gt;\u0026amp;lt;img title=\u0026quot;Nope down=\u0026apos;up\u0026apos; for aussies\u0026quot; src=\u0026quot;...\u0026quot; /\u0026amp;gt;\u0026lt;/code\u0026gt;. If applied globally, it will also match such things in ordinary text or in html comments.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/904933/david-andersson\u0026quot; title=\u0026quot;725 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;David Andersson\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment66191152_6653839\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-09-11 08:28:54Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 11, 2016 at 8:28\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;(get attributes bug 3) \u0026lt;code\u0026gt;/(\\w+)=\u0026quot;(.*?)\u0026quot;/\u0026lt;/code\u0026gt; Optional whitespace should be allowed around the equal sign.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/904933/david-andersson\u0026quot; title=\u0026quot;725 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;David Andersson\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment66191321_6653839\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-09-11 08:42:23Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 11, 2016 at 8:42\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;(html split bug 1) \u0026lt;code\u0026gt;s/\u0026amp;gt;/\u0026amp;gt;\\n/g\u0026lt;/code\u0026gt; Since \u0026quot;\u0026amp;gt;\u0026quot; is allowed in data, this may split text lines and confuse subsequent processing.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/904933/david-andersson\u0026quot; title=\u0026quot;725 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;David Andersson\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment66191692_6653839\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-09-11 09:09:52Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 11, 2016 at 9:09\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Don\u0026apos;t do this. Please.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/381285/maletor\u0026quot; title=\u0026quot;6,792 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;maletor\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment52604067_2708960\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-09-03 02:12:42Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 3, 2015 at 2:12\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I\u0026apos;ll put this in the \u0026quot;Regex which doesn\u0026apos;t allow greater-than in attributes\u0026quot; bin. Check it against \u0026amp;lt;input value=\u0026quot;is 5 \u0026amp;gt; 3?\u0026quot; /\u0026amp;gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/31582/gareth\u0026quot; title=\u0026quot;125,465 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Gareth\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment3275117_3180176\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-07-05 16:24:02Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 5, 2010 at 16:24\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;If you put something like that in production code, you would likely be shot by the maintainer.  A jury would never convict him.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/72943/aehiilrs\u0026quot; title=\u0026quot;1,245 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;aehiilrs\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment3275182_3180176\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-07-05 16:33:01Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 5, 2010 at 16:33\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Regular expressions can\u0026apos;t work because by definition they are not recursive. Adding a recursive operator to regular expressions basically makes a CFG only with poorer syntax. Why not use something designed to be recursive in the first place rather than violently insert recursion into something already overflowing with extraneous functionality?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/52443/welbog\u0026quot; title=\u0026quot;57,799 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Welbog\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment3284978_3180176\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-07-06 18:38:34Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 6, 2010 at 18:38\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;My objection isn\u0026apos;t one of functionality it is one of time invested. The problem with RegEx is that by the time you post the cutsey little one liners it appears that you did something more efficiently (\u0026quot;See one line of code!\u0026quot;). And of course no one mentions the half hour (or 3) that they spent with their cheat-sheet and (hopefully) testing every possible permutation of input. And once you get past all that when the maintainer goes to figure out or validate the code they can\u0026apos;t just look at it and see that it is right. The have to dissect the expression and essentially retest it all over again...\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/102270/oorang\u0026quot; title=\u0026quot;6,510 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Oorang\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment3321225_3180176\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-07-10 15:11:09Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 10, 2010 at 15:11\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;... to know that it is good. And that will happen even with people who are \u0026lt;i\u0026gt;good\u0026lt;/i\u0026gt; with regex. And honestly I suspect that overwhelming majority of people won\u0026apos;t know it well. So you take one of the most notorious maintenance nightmares and combine it with recursion which is the \u0026lt;i\u0026gt;other\u0026lt;/i\u0026gt; maintenance nightmare and I think to myself what I really need on my project is someone a little less clever. The goal is to write code that bad programmers can maintain without breaking the code base. I know it galls to code to the least common denominator. But hiring excellent talent is hard, and you often...\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/102270/oorang\u0026quot; title=\u0026quot;6,510 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Oorang\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment3321252_3180176\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-07-10 15:17:22Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 10, 2010 at 15:17\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@GlitchMr, that was his point. Modern regular expressions are not technically regular, nor is there any reason for them to be.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/873843/alanaktion\u0026quot; title=\u0026quot;1,317 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;alanaktion\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment20494033_10535487\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-02-02 15:45:29Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 2, 2013 at 15:45\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@alanaktion: The \u0026quot;modern\u0026quot; regular expressions (read: with Perl extensions) cannot match within \u0026lt;code\u0026gt;O(MN)\u0026lt;/code\u0026gt; (M being regular expression length, N being text length). Backreferences are one of causes of that. The implementation in awk doesn\u0026apos;t have backreferences and matches everything within \u0026lt;code\u0026gt;O(MN)\u0026lt;/code\u0026gt; time.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/736054/konrad-borowski\u0026quot; title=\u0026quot;10,835 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Konrad Borowski\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment20863430_10535487\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-02-14 16:52:45Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 14, 2013 at 16:52\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026lt;code\u0026gt;\u0026amp;lt;a href=\u0026quot;foo\u0026quot; title=\u0026quot;5\u0026amp;gt;3\u0026quot;\u0026amp;gt; Oops \u0026amp;lt;/a\u0026amp;gt;\u0026lt;/code\u0026gt; (quoting @Gareth - odd how people keep posting answers with this specific deficiency over and over. CDATA is kind of easy to overlook, but this is rather more basic)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/22820/qwertie\u0026quot; title=\u0026quot;15,216 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Qwertie\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment111341972_10535487\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2020-07-17 21:59:38Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 17, 2020 at 21:59\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;FYI, you don\u0026apos;t need to escape angle brackets.  Of course, it does no harm to escape them anyway, but look at the confusion you could have avoided. ;)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/20938/alan-moore\u0026quot; title=\u0026quot;71,569 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Alan Moore\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment62509129_10844758\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-05-29 07:47:04Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 29, 2016 at 7:47\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I sometimes escape unnecessarily when I\u0026apos;m unsure if something is special character or not. I\u0026apos;ve edited the answer; it works the same but more concise.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/217867/lonnie-best\u0026quot; title=\u0026quot;8,494 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Lonnie Best\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment62568124_10844758\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-05-31 07:23:11Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 31, 2016 at 7:23\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;This does not work. For the input \u0026apos;\u0026amp;lt;x a=\u0026quot;\u0026amp;lt;b\u0026amp;gt;\u0026quot;/\u0026amp;gt;\u0026amp;lt;y\u0026amp;gt;\u0026apos; the matches are x and y, although x is terminated.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/402322/ceving\u0026quot; title=\u0026quot;19,959 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;ceving\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment6771435_1738126\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-05-04 16:33:18Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 4, 2011 at 16:33\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        "],"id":5,"title":"RegEx match open tags except XHTML self-contained tags","content":"\n                    \u0026lt;div\u0026gt;\n            \u0026lt;aside class=\u0026quot;s-notice s-notice__info post-notice js-post-notice mb16\u0026quot; role=\u0026quot;status\u0026quot;\u0026gt;\n        \u0026lt;div class=\u0026quot;d-flex fd-column fw-nowrap\u0026quot;\u0026gt;\n            \u0026lt;div class=\u0026quot;d-flex fw-nowrap\u0026quot;\u0026gt;\n                    \u0026lt;div class=\u0026quot;flex--item mr8\u0026quot;\u0026gt;\n                        \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;svg-icon iconLock\u0026quot; width=\u0026quot;18\u0026quot; height=\u0026quot;18\u0026quot; viewBox=\u0026quot;0 0 18 18\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;M16 9a2 2 0 0 0-2-2V6A5 5 0 0 0 4 6v1a2 2 0 0 0-2 2v6c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V9Zm-7 5a2 2 0 1 1 0-4 2 2 0 0 1 0 4Zm3.1-7H5.9V6a3.1 3.1 0 0 1 6.2 0v1Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                    \u0026lt;/div\u0026gt;\n                \u0026lt;div class=\u0026quot;flex--item wmn0 fl1 lh-lg\u0026quot;\u0026gt;\n                    \u0026lt;div class=\u0026quot;flex--item fl1 lh-lg\u0026quot;\u0026gt;\n                        \u0026lt;b\u0026gt;Locked\u0026lt;/b\u0026gt;. Comments on this question have been disabled, but it is still accepting new answers and other interactions. \u0026lt;a href=\u0026quot;/help/locked-posts\u0026quot;\u0026gt;Learn more\u0026lt;/a\u0026gt;.\n                        \n                    \u0026lt;/div\u0026gt;\n                \u0026lt;/div\u0026gt;\n            \u0026lt;/div\u0026gt;\n        \u0026lt;/div\u0026gt;\n\u0026lt;/aside\u0026gt;\n\n    \u0026lt;/div\u0026gt;\n\n\u0026lt;p\u0026gt;I need to match all of these opening tags:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;p\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;href\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;foo\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;But not these:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;br\u0026lt;/span\u0026gt; /\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;hr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;foo\u0026quot;\u0026lt;/span\u0026gt; /\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I came up with this and wanted to make sure I\u0026apos;ve got it right. I am only capturing the \u0026lt;code\u0026gt;a-z\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026amp;lt;([a-z]+) *[^/]*?\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I believe it says:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Find a less-than, then\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Find (and capture) a-z one or more times, then\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Find zero or more spaces, then\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Find any character zero or more times, greedy, except \u0026lt;code\u0026gt;/\u0026lt;/code\u0026gt;, then\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Find a greater-than\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Do I have that right? And more importantly, what do you think?\u0026lt;/p\u0026gt;\n    ","slug":"regex-match-open-tags-except-xhtml-self-contained-tags-1657384228245","postType":"QUESTION","createdAt":"2022-07-09T16:30:28.000Z","updatedAt":"2022-07-09T16:30:28.000Z","tags":[{"id":13,"name":"regex","slug":"regex","createdAt":"2022-07-09T16:30:28.000Z","updatedAt":"2022-07-09T16:30:28.000Z","Questions_Tags":{"questionId":5,"tagId":13}},{"id":14,"name":"xhtml","slug":"xhtml","createdAt":"2022-07-09T16:30:28.000Z","updatedAt":"2022-07-09T16:30:28.000Z","Questions_Tags":{"questionId":5,"tagId":14}},{"id":15,"name":"html","slug":"html","createdAt":"2022-07-09T16:30:28.000Z","updatedAt":"2022-07-09T16:30:28.000Z","Questions_Tags":{"questionId":5,"tagId":15}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"regex-match-open-tags-except-xhtml-self-contained-tags-1657384228245"},"buildId":"4Y8KGE-c2lolBeBmcum_I","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>