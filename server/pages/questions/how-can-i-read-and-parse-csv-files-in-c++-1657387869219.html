<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2eccd4d47c856f2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2eccd4d47c856f2b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/471-84c36aa98dd4107c.js" defer=""></script><script src="/_next/static/chunks/81-096e453de8a27667.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-e3d1b60e109d3ba1.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_buildManifest.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.hFcsiD code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-6e32c308-0"]{content:"hFcsiD,"}/*!sc*/
.ljvTUN .comment-item .comment-body .d-inline-flex.ai-center{text-align:right;}/*!sc*/
.ljvTUN .comment-item .comment-body .comment-date{float:right;}/*!sc*/
data-styled.g6[id="sc-6e32c308-1"]{content:"ljvTUN,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="https://flowbite.com/docs/images/logo.svg" class="mr-3 h-6 sm:h-9" alt="Flowbite Logo"/><span class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Hunter</span></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/how-can-i-read-and-parse-csv-files-in-c%2B%2B-1657387869219#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-6e32c308-0 hFcsiD flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219">How can I read and parse CSV files in C++?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/csv">csv</a></div></div><div class="question-content mt-5">
                
<p>I need to load and use CSV file data in C++.  At this point it can really just be a comma-delimited parser (ie don't worry about escaping new lines and commas).  The main need is a line-by-line parser that will return a vector for the next line each time the method is called.</p>

<p>I found this article which looks quite promising:
<a href="http://www.boost.org/doc/libs/1_35_0/libs/spirit/example/fundamental/list_parser.cpp" rel="noreferrer">http://www.boost.org/doc/libs/1_35_0/libs/spirit/example/fundamental/list_parser.cpp</a></p>

<p>I've never used Boost's Spirit, but am willing to try it. But only if there isn't a more straightforward solution I'm overlooking.</p>
    </div></div></div><div class="sc-6e32c308-1 ljvTUN flex text-xs pl-10 flex-col comment items-center justify-center"><h4 class="text-left mt-10 text-lg font-semibold">Comments</h4><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy">I have looked at <code>boost::spirit</code> for parsing.  It is more for parsing grammars thank parsing a simple file format.  Someone on my team was trying to use it to parse XML and it was a pain to debug.  Stay away from <code>boost::spirit</code> if possible.</span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/35577/chrish" title="2,274 reputation" class="comment-user">chrish</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment938051_1120140"><span title="2009-07-13 19:30:27Z, License: CC BY-SA 2.5" class="relativetime-clean">Jul 13, 2009 at 19:30</span></a></span>
            </div>
        </div><span class="divide-x-8 "></span><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy">Sorry chrish, but that's terrible advice.  Spirit isn't always an appropriate solution but I've used it - and continue to use it - successfully in a number of projects.  Compared to similar tools (Antlr, Lex/yacc etc) it has significant advantages.  Now, for parsing CSV it's probably overkill...</span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/7405/mattyt" title="6,341 reputation" class="comment-user">MattyT</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment941839_1120140"><span title="2009-07-14 12:09:26Z, License: CC BY-SA 2.5" class="relativetime-clean">Jul 14, 2009 at 12:09</span></a></span>
            </div>
        </div><span class="divide-x-8 "></span><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy">@MattyT IMHO <code>spirit</code> is pretty hard to use for a parser combinator library. Having had some (very pleasant) experience with Haskells <code>(atto)parsec</code> libraries I expected it (spirit) to work similarly well, but gave up on it after fighting with 600 line compiler errors.</span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/383508/fho" title="6,658 reputation" class="comment-user">fho</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment38375206_1120140"><span title="2014-07-14 13:24:45Z, License: CC BY-SA 3.0" class="relativetime-clean">Jul 14, 2014 at 13:24</span></a></span>
            </div>
        </div><span class="divide-x-8 "></span><button class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">See more</button></div><div class="sc-6e32c308-2 bFXWFO"><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you don't care about escaping comma and newline,<br>
AND you can't embed comma and newline in quotes (If you can't escape then...)<br>
then its only about three lines of code (OK 14 -&gt;But its only 15 to read the whole file).</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">getNextLineAndSplitIntoTokens</span><span class="hljs-params">(std::istream&amp; str)</span>
</span>{
    std::vector&lt;std::string&gt;   result;
    std::string                line;
    std::<span class="hljs-built_in">getline</span>(str,line);

    <span class="hljs-function">std::stringstream          <span class="hljs-title">lineStream</span><span class="hljs-params">(line)</span></span>;
    std::string                cell;

    <span class="hljs-keyword">while</span>(std::<span class="hljs-built_in">getline</span>(lineStream,cell, <span class="hljs-string">','</span>))
    {
        result.<span class="hljs-built_in">push_back</span>(cell);
    }
    <span class="hljs-comment">// This checks for a trailing comma with no data after it.</span>
    <span class="hljs-keyword">if</span> (!lineStream &amp;&amp; cell.<span class="hljs-built_in">empty</span>())
    {
        <span class="hljs-comment">// If there was a trailing comma then add an empty element.</span>
        result.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">""</span>);
    }
    <span class="hljs-keyword">return</span> result;
}
</code></pre>
<p>I would just create a class representing a row.<br>
Then stream into that object:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">CSVRow</span>
{
    <span class="hljs-keyword">public</span>:
        std::string_view <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> index) <span class="hljs-type">const</span>
        {
            <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string_view</span>(&amp;m_line[m_data[index] + <span class="hljs-number">1</span>], m_data[index + <span class="hljs-number">1</span>] -  (m_data[index] + <span class="hljs-number">1</span>));
        }
        <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>
        </span>{
            <span class="hljs-keyword">return</span> m_data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
        }
        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">readNextRow</span><span class="hljs-params">(std::istream&amp; str)</span>
        </span>{
            std::<span class="hljs-built_in">getline</span>(str, m_line);

            m_data.<span class="hljs-built_in">clear</span>();
            m_data.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">-1</span>);
            std::string::size_type pos = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">while</span>((pos = m_line.<span class="hljs-built_in">find</span>(<span class="hljs-string">','</span>, pos)) != std::string::npos)
            {
                m_data.<span class="hljs-built_in">emplace_back</span>(pos);
                ++pos;
            }
            <span class="hljs-comment">// This checks for a trailing comma with no data after it.</span>
            pos   = m_line.<span class="hljs-built_in">size</span>();
            m_data.<span class="hljs-built_in">emplace_back</span>(pos);
        }
    <span class="hljs-keyword">private</span>:
        std::string         m_line;
        std::vector&lt;<span class="hljs-type">int</span>&gt;    m_data;
};

std::istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(std::istream&amp; str, CSVRow&amp; data)
{
    data.<span class="hljs-built_in">readNextRow</span>(str);
    <span class="hljs-keyword">return</span> str;
}   
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-function">std::ifstream       <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">"plop.csv"</span>)</span></span>;

    CSVRow              row;
    <span class="hljs-keyword">while</span>(file &gt;&gt; row)
    {
        std::cout &lt;&lt; <span class="hljs-string">"4th Element("</span> &lt;&lt; row[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-string">")\n"</span>;
    }
}
</code></pre>
<p>But with a little work we could technically create an iterator:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSVIterator</span>
{   
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">typedef</span> std::input_iterator_tag     iterator_category;
        <span class="hljs-keyword">typedef</span> CSVRow                      value_type;
        <span class="hljs-keyword">typedef</span> std::<span class="hljs-type">size_t</span>                 difference_type;
        <span class="hljs-keyword">typedef</span> CSVRow*                     pointer;
        <span class="hljs-keyword">typedef</span> CSVRow&amp;                     reference;

        <span class="hljs-built_in">CSVIterator</span>(std::istream&amp; str)  :<span class="hljs-built_in">m_str</span>(str.<span class="hljs-built_in">good</span>()?&amp;str:<span class="hljs-literal">nullptr</span>) { ++(*<span class="hljs-keyword">this</span>); }
        <span class="hljs-built_in">CSVIterator</span>()                   :<span class="hljs-built_in">m_str</span>(<span class="hljs-literal">nullptr</span>) {}

        <span class="hljs-comment">// Pre Increment</span>
        CSVIterator&amp; <span class="hljs-keyword">operator</span>++()               {<span class="hljs-keyword">if</span> (m_str) { <span class="hljs-keyword">if</span> (!((*m_str) &gt;&gt; m_row)){m_str = <span class="hljs-literal">nullptr</span>;}}<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;}
        <span class="hljs-comment">// Post increment</span>
        CSVIterator <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)             {<span class="hljs-function">CSVIterator    <span class="hljs-title">tmp</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;++(*<span class="hljs-keyword">this</span>);<span class="hljs-keyword">return</span> tmp;}
        CSVRow <span class="hljs-type">const</span>&amp; <span class="hljs-keyword">operator</span>*()   <span class="hljs-type">const</span>       {<span class="hljs-keyword">return</span> m_row;}
        CSVRow <span class="hljs-type">const</span>* <span class="hljs-keyword">operator</span>-&gt;()  <span class="hljs-type">const</span>       {<span class="hljs-keyword">return</span> &amp;m_row;}

        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(CSVIterator <span class="hljs-type">const</span>&amp; rhs) {<span class="hljs-built_in">return</span> ((<span class="hljs-keyword">this</span> == &amp;rhs) || ((<span class="hljs-keyword">this</span>-&gt;m_str == <span class="hljs-literal">nullptr</span>) &amp;&amp; (rhs.m_str == <span class="hljs-literal">nullptr</span>)));}
        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(CSVIterator <span class="hljs-type">const</span>&amp; rhs) {<span class="hljs-keyword">return</span> !((*<span class="hljs-keyword">this</span>) == rhs);}
    <span class="hljs-keyword">private</span>:
        std::istream*       m_str;
        CSVRow              m_row;
};


<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-function">std::ifstream       <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">"plop.csv"</span>)</span></span>;

    <span class="hljs-keyword">for</span>(CSVIterator <span class="hljs-built_in">loop</span>(file); loop != <span class="hljs-built_in">CSVIterator</span>(); ++loop)
    {
        std::cout &lt;&lt; <span class="hljs-string">"4th Element("</span> &lt;&lt; (*loop)[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-string">")\n"</span>;
    }
}
</code></pre>
<p>Now that we are in 2020 lets add a CSVRange object:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSVRange</span>
{
    std::istream&amp;   stream;
    <span class="hljs-keyword">public</span>:
        <span class="hljs-built_in">CSVRange</span>(std::istream&amp; str)
            : <span class="hljs-built_in">stream</span>(str)
        {}
        <span class="hljs-function">CSVIterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{<span class="hljs-keyword">return</span> CSVIterator{stream};}
        <span class="hljs-function">CSVIterator <span class="hljs-title">end</span><span class="hljs-params">()</span>   <span class="hljs-type">const</span> </span>{<span class="hljs-keyword">return</span> CSVIterator{};}
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-function">std::ifstream       <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">"plop.csv"</span>)</span></span>;

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; row: <span class="hljs-built_in">CSVRange</span>(file))
    {
        std::cout &lt;&lt; <span class="hljs-string">"4th Element("</span> &lt;&lt; row[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-string">")\n"</span>;
    }
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>My version is not using anything but the standard C++11 library. It copes well with Excel CSV quotation:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">spam eggs,<span class="hljs-string">"foo,bar"</span>,<span class="hljs-string">""</span><span class="hljs-string">"fizz buzz"</span><span class="hljs-string">""</span>
<span class="hljs-number">1.23</span>,<span class="hljs-number">4.567</span>,<span class="hljs-number">-8.00E+09</span>
</code></pre>

<p>The code is written as a finite-state machine and is consuming one character at a time. I think it's easier to reason about.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;istream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>

<span class="hljs-keyword">enum class</span> <span class="hljs-title class_">CSVState</span> {
    UnquotedField,
    QuotedField,
    QuotedQuote
};

<span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">readCSVRow</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;row)</span> </span>{
    CSVState state = CSVState::UnquotedField;
    std::vector&lt;std::string&gt; fields {<span class="hljs-string">""</span>};
    <span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// index of the current field</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : row) {
        <span class="hljs-keyword">switch</span> (state) {
            <span class="hljs-keyword">case</span> CSVState::UnquotedField:
                <span class="hljs-keyword">switch</span> (c) {
                    <span class="hljs-keyword">case</span> <span class="hljs-string">','</span>: <span class="hljs-comment">// end of field</span>
                              fields.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">""</span>); i++;
                              <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'"'</span>: state = CSVState::QuotedField;
                              <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">default</span>:  fields[i].<span class="hljs-built_in">push_back</span>(c);
                              <span class="hljs-keyword">break</span>; }
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> CSVState::QuotedField:
                <span class="hljs-keyword">switch</span> (c) {
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'"'</span>: state = CSVState::QuotedQuote;
                              <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">default</span>:  fields[i].<span class="hljs-built_in">push_back</span>(c);
                              <span class="hljs-keyword">break</span>; }
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> CSVState::QuotedQuote:
                <span class="hljs-keyword">switch</span> (c) {
                    <span class="hljs-keyword">case</span> <span class="hljs-string">','</span>: <span class="hljs-comment">// , after closing quote</span>
                              fields.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">""</span>); i++;
                              state = CSVState::UnquotedField;
                              <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'"'</span>: <span class="hljs-comment">// "" -&gt; "</span>
                              fields[i].<span class="hljs-built_in">push_back</span>(<span class="hljs-string">'"'</span>);
                              state = CSVState::QuotedField;
                              <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">default</span>:  <span class="hljs-comment">// end of quote</span>
                              state = CSVState::UnquotedField;
                              <span class="hljs-keyword">break</span>; }
                <span class="hljs-keyword">break</span>;
        }
    }
    <span class="hljs-keyword">return</span> fields;
}

<span class="hljs-comment">/// Read CSV file, Excel dialect. Accept "quoted fields ""with quotes"""</span>
std::vector&lt;std::vector&lt;std::string&gt;&gt; <span class="hljs-built_in">readCSV</span>(std::istream &amp;in) {
    std::vector&lt;std::vector&lt;std::string&gt;&gt; table;
    std::string row;
    <span class="hljs-keyword">while</span> (!in.<span class="hljs-built_in">eof</span>()) {
        std::<span class="hljs-built_in">getline</span>(in, row);
        <span class="hljs-keyword">if</span> (in.<span class="hljs-built_in">bad</span>() || in.<span class="hljs-built_in">fail</span>()) {
            <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">auto</span> fields = <span class="hljs-built_in">readCSVRow</span>(row);
        table.<span class="hljs-built_in">push_back</span>(fields);
    }
    <span class="hljs-keyword">return</span> table;
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Solution using Boost Tokenizer:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">std::vector&lt;std::string&gt; vec;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> boost;
tokenizer&lt;escaped_list_separator&lt;<span class="hljs-type">char</span>&gt; &gt; <span class="hljs-built_in">tk</span>(
   line, <span class="hljs-built_in">escaped_list_separator</span>&lt;<span class="hljs-type">char</span>&gt;(<span class="hljs-string">'\\'</span>, <span class="hljs-string">','</span>, <span class="hljs-string">'\"'</span>));
<span class="hljs-keyword">for</span> (tokenizer&lt;escaped_list_separator&lt;<span class="hljs-type">char</span>&gt; &gt;::iterator <span class="hljs-built_in">i</span>(tk.<span class="hljs-built_in">begin</span>());
   i!=tk.<span class="hljs-built_in">end</span>();++i) 
{
   vec.<span class="hljs-built_in">push_back</span>(*i);
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The <a href="http://www.partow.net/programming/strtk/index.html" rel="nofollow noreferrer">C++ String Toolkit Library (StrTk)</a> has a token grid class that allows you to load data either from <b>text files, strings or char buffers</b>, and to parse/process them in a row-column fashion.</p>

<p>You can specify the row delimiters and column delimiters or just use the defaults.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>
</span>{
   std::string data = <span class="hljs-string">"1,2,3,4,5\n"</span>
                      <span class="hljs-string">"0,2,4,6,8\n"</span>
                      <span class="hljs-string">"1,3,5,7,9\n"</span>;

   <span class="hljs-function">strtk::token_grid <span class="hljs-title">grid</span><span class="hljs-params">(data,data.size(),<span class="hljs-string">","</span>)</span></span>;

   <span class="hljs-keyword">for</span>(std::<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; grid.<span class="hljs-built_in">row_count</span>(); ++i)
   {
      strtk::token_grid::row_type r = grid.<span class="hljs-built_in">row</span>(i);
      <span class="hljs-keyword">for</span>(std::<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; r.<span class="hljs-built_in">size</span>(); ++j)
      {
         std::cout &lt;&lt; r.<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">int</span>&gt;(j) &lt;&lt; <span class="hljs-string">"\t"</span>;
      }
      std::cout &lt;&lt; std::endl;
   }
   std::cout &lt;&lt; std::endl;
}
</code></pre>

<p>More examples can be found <a href="http://www.partow.net/programming/strtk/index.html#tutorial" rel="nofollow noreferrer">Here</a></p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>You can use Boost Tokenizer with escaped_list_separator.</strong></p>
<blockquote>
<p><strong>escaped_list_separator</strong> parses a superset of the csv. <a href="https://www.boost.org/doc/libs/release/libs/tokenizer/doc/escaped_list_separator.htm" rel="nofollow noreferrer">Boost::tokenizer</a></p>
</blockquote>
<p>This only uses Boost tokenizer header files, no linking to boost libraries required.</p>
<p>Here is an example, (see <a href="http://mybyteofcode.blogspot.com/2010/02/parse-csv-file-with-boost-tokenizer-in.html" rel="nofollow noreferrer">Parse CSV File With Boost Tokenizer In C++</a> for details or <code>Boost::tokenizer</code> ):</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>     <span class="hljs-comment">// cout, endl</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span>      <span class="hljs-comment">// fstream</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>    <span class="hljs-comment">// copy</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span>     <span class="hljs-comment">// ostream_operator</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/tokenizer.hpp&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> boost;
    <span class="hljs-function">string <span class="hljs-title">data</span><span class="hljs-params">(<span class="hljs-string">"data.csv"</span>)</span></span>;

    <span class="hljs-function">ifstream <span class="hljs-title">in</span><span class="hljs-params">(data.c_str())</span></span>;
    <span class="hljs-keyword">if</span> (!in.<span class="hljs-built_in">is_open</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;

    <span class="hljs-keyword">typedef</span> tokenizer&lt; escaped_list_separator&lt;<span class="hljs-type">char</span>&gt; &gt; Tokenizer;
    vector&lt; string &gt; vec;
    string line;

    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(in,line))
    {
        <span class="hljs-function">Tokenizer <span class="hljs-title">tok</span><span class="hljs-params">(line)</span></span>;
        vec.<span class="hljs-built_in">assign</span>(tok.<span class="hljs-built_in">begin</span>(),tok.<span class="hljs-built_in">end</span>());

        <span class="hljs-comment">// vector now contains strings from one row, output to cout here</span>
        <span class="hljs-built_in">copy</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">ostream_iterator</span>&lt;string&gt;(cout, <span class="hljs-string">"|"</span>));

        cout &lt;&lt; <span class="hljs-string">"\n----------------------"</span> &lt;&lt; endl;
    }
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It is not overkill to use Spirit for parsing CSVs. Spirit is well suited for micro-parsing tasks. For instance, with Spirit 2.1, it is as easy as:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">bool</span> r = <span class="hljs-built_in">phrase_parse</span>(first, last,

    <span class="hljs-comment">//  Begin grammar</span>
    (
        double_ % <span class="hljs-string">','</span>
    )
    ,
    <span class="hljs-comment">//  End grammar</span>

    space, v);
</code></pre>

<p>The vector, v, gets stuffed with the values. <a href="http://www.boost.org/doc/libs/1_41_0/libs/spirit/doc/html/spirit/qi/tutorials.html" rel="noreferrer">There is a series of tutorials</a> touching on this in the new Spirit 2.1 docs that's just been released with Boost 1.41.</p>

<p>The tutorial progresses from simple to complex. The CSV parsers are presented somewhere in the middle and touches on various techniques in using Spirit. The generated code is as tight as hand written code. Check out the assembler generated!</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you <strong>DO</strong> care about parsing CSV correctly, this will do it...relatively slowly as it works one char at a time.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ParseCSV</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; csvSource, vector&lt;vector&lt;string&gt; &gt;&amp; lines)</span>
    </span>{
       <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">inQuote</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;
       <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">newLine</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;
       string field;
       lines.<span class="hljs-built_in">clear</span>();
       vector&lt;string&gt; line;

       string::const_iterator aChar = csvSource.<span class="hljs-built_in">begin</span>();
       <span class="hljs-keyword">while</span> (aChar != csvSource.<span class="hljs-built_in">end</span>())
       {
          <span class="hljs-keyword">switch</span> (*aChar)
          {
          <span class="hljs-keyword">case</span> <span class="hljs-string">'"'</span>:
             newLine = <span class="hljs-literal">false</span>;
             inQuote = !inQuote;
             <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-string">','</span>:
             newLine = <span class="hljs-literal">false</span>;
             <span class="hljs-keyword">if</span> (inQuote == <span class="hljs-literal">true</span>)
             {
                field += *aChar;
             }
             <span class="hljs-keyword">else</span>
             {
                line.<span class="hljs-built_in">push_back</span>(field);
                field.<span class="hljs-built_in">clear</span>();
             }
             <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-string">'\n'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'\r'</span>:
             <span class="hljs-keyword">if</span> (inQuote == <span class="hljs-literal">true</span>)
             {
                field += *aChar;
             }
             <span class="hljs-keyword">else</span>
             {
                <span class="hljs-keyword">if</span> (newLine == <span class="hljs-literal">false</span>)
                {
                   line.<span class="hljs-built_in">push_back</span>(field);
                   lines.<span class="hljs-built_in">push_back</span>(line);
                   field.<span class="hljs-built_in">clear</span>();
                   line.<span class="hljs-built_in">clear</span>();
                   newLine = <span class="hljs-literal">true</span>;
                }
             }
             <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">default</span>:
             newLine = <span class="hljs-literal">false</span>;
             field.<span class="hljs-built_in">push_back</span>(*aChar);
             <span class="hljs-keyword">break</span>;
          }

          aChar++;
       }

       <span class="hljs-keyword">if</span> (field.<span class="hljs-built_in">size</span>())
          line.<span class="hljs-built_in">push_back</span>(field);

       <span class="hljs-keyword">if</span> (line.<span class="hljs-built_in">size</span>())
          lines.<span class="hljs-built_in">push_back</span>(line);
    }
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>When using the Boost Tokenizer escaped_list_separator for CSV files, then one should be aware of the following:</p>

<ol>
<li>It requires an escape-character (default back-slash - \)</li>
<li>It requires a splitter/seperator-character (default comma - ,)</li>
<li>It requires an quote-character (default quote - ")</li>
</ol>

<p>The CSV format specified by wiki states that data fields can contain separators in quotes (supported):</p>

<blockquote>
  <p>1997,Ford,E350,"Super, luxurious truck"</p>
</blockquote>

<p>The CSV format specified by wiki states that single quotes should be handled with double-quotes (escaped_list_separator will strip away all quote characters):</p>

<blockquote>
  <p>1997,Ford,E350,"Super ""luxurious"" truck"</p>
</blockquote>

<p>The CSV format doesn't specify that any back-slash characters should be stripped away (escaped_list_separator will strip away all escape characters).</p>

<p>A possible work-around to fix the default behavior of the boost escaped_list_separator:</p>

<ol>
<li>First replace all back-slash characters (\) with two back-slash characters (\\) so they are not stripped away.</li>
<li>Secondly replace all double-quotes ("") with a single back-slash character and a quote (\")</li>
</ol>

<p>This work-around has the side-effect that empty data-fields that are represented by a double-quote, will be transformed into a single-quote-token. When iterating through the tokens, then one must check if the token is a single-quote, and treat it like an empty string.</p>

<p>Not pretty but it works, as long there are not newlines within the quotes.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><a href="https://github.com/AriaFallah/csv-parser" rel="noreferrer">I wrote a header-only, C++11 CSV parser</a>. It's well tested, fast, supports the entire CSV spec (quoted fields, delimiter/terminator in quotes, quote escaping, etc.), and is configurable to account for the CSVs that don't adhere to the specification.</p>

<p>Configuration is done through a fluent interface:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// constructor accepts any input stream</span>
CsvParser parser = <span class="hljs-built_in">CsvParser</span>(std::cin)
  .<span class="hljs-built_in">delimiter</span>(<span class="hljs-string">';'</span>)    <span class="hljs-comment">// delimited by ; instead of ,</span>
  .<span class="hljs-built_in">quote</span>(<span class="hljs-string">'\''</span>)       <span class="hljs-comment">// quoted fields use ' instead of "</span>
  .<span class="hljs-built_in">terminator</span>(<span class="hljs-string">'\0'</span>); <span class="hljs-comment">// terminated by \0 instead of by \r\n, \n, or \r</span>
</code></pre>

<p>Parsing is just a range based for loop:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"../parser.hpp"</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> aria::csv;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-function">std::ifstream <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-string">"some_file.csv"</span>)</span></span>;
  <span class="hljs-function">CsvParser <span class="hljs-title">parser</span><span class="hljs-params">(f)</span></span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; row : parser) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; field : row) {
      std::cout &lt;&lt; field &lt;&lt; <span class="hljs-string">" | "</span>;
    }
    std::cout &lt;&lt; std::endl;
  }
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As all the CSV questions seem to get redirected here, I thought I'd post my answer here.  This answer does not directly address the asker's question. I wanted to be able to read in a stream that is known to be in CSV format, and also the types of each field was already known. Of course, the method below could be used to treat every field to be a string type.</p>

<p>As an example of how I wanted to be able to use a CSV input stream, consider the following input (taken from <a href="http://en.wikipedia.org/wiki/Comma-separated_values" rel="nofollow noreferrer">wikipedia's page on CSV</a>):</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span> input[] =
<span class="hljs-string">"Year,Make,Model,Description,Price\n"</span>
<span class="hljs-string">"1997,Ford,E350,\"ac, abs, moon\",3000.00\n"</span>
<span class="hljs-string">"1999,Chevy,\"Venture \"\"Extended Edition\"\"\",\"\",4900.00\n"</span>
<span class="hljs-string">"1999,Chevy,\"Venture \"\"Extended Edition, Very Large\"\"\",\"\",5000.00\n"</span>
<span class="hljs-string">"1996,Jeep,Grand Cherokee,\"MUST SELL!\n\
air, moon roof, loaded\",4799.00\n"</span>
;
</code></pre>

<p>Then, I wanted to be able to read in the data like this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">std::istringstream <span class="hljs-title">ss</span><span class="hljs-params">(input)</span></span>;
std::string title[<span class="hljs-number">5</span>];
<span class="hljs-type">int</span> year;
std::string make, model, desc;
<span class="hljs-type">float</span> price;
<span class="hljs-built_in">csv_istream</span>(ss)
    &gt;&gt; title[<span class="hljs-number">0</span>] &gt;&gt; title[<span class="hljs-number">1</span>] &gt;&gt; title[<span class="hljs-number">2</span>] &gt;&gt; title[<span class="hljs-number">3</span>] &gt;&gt; title[<span class="hljs-number">4</span>];
<span class="hljs-keyword">while</span> (<span class="hljs-built_in">csv_istream</span>(ss)
       &gt;&gt; year &gt;&gt; make &gt;&gt; model &gt;&gt; desc &gt;&gt; price) {
    <span class="hljs-comment">//...do something with the record...</span>
}
</code></pre>

<p>This was the solution I ended up with.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">csv_istream</span> {
    std::istream &amp;is_;
    <span class="hljs-built_in">csv_istream</span> (std::istream &amp;is) : <span class="hljs-built_in">is_</span>(is) {}
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">scan_ws</span> <span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">while</span> (is_.<span class="hljs-built_in">good</span>()) {
            <span class="hljs-type">int</span> c = is_.<span class="hljs-built_in">peek</span>();
            <span class="hljs-keyword">if</span> (c != <span class="hljs-string">' '</span> &amp;&amp; c != <span class="hljs-string">'\t'</span>) <span class="hljs-keyword">break</span>;
            is_.<span class="hljs-built_in">get</span>();
        }
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">scan</span> <span class="hljs-params">(std::string *s = <span class="hljs-number">0</span>)</span> <span class="hljs-type">const</span> </span>{
        std::string ws;
        <span class="hljs-type">int</span> c = is_.<span class="hljs-built_in">get</span>();
        <span class="hljs-keyword">if</span> (is_.<span class="hljs-built_in">good</span>()) {
            <span class="hljs-keyword">do</span> {
                <span class="hljs-keyword">if</span> (c == <span class="hljs-string">','</span> || c == <span class="hljs-string">'\n'</span>) <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">if</span> (s) {
                    ws += c;
                    <span class="hljs-keyword">if</span> (c != <span class="hljs-string">' '</span> &amp;&amp; c != <span class="hljs-string">'\t'</span>) {
                        *s += ws;
                        ws.<span class="hljs-built_in">clear</span>();
                    }
                }
                c = is_.<span class="hljs-built_in">get</span>();
            } <span class="hljs-keyword">while</span> (is_.<span class="hljs-built_in">good</span>());
            <span class="hljs-keyword">if</span> (is_.<span class="hljs-built_in">eof</span>()) is_.<span class="hljs-built_in">clear</span>();
        }
    }
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">bool</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">set_value</span> {
        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(std::string in, T &amp;v)</span> <span class="hljs-type">const</span> </span>{
            std::<span class="hljs-built_in">istringstream</span>(in) &gt;&gt; v;
        }
    };
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">set_value</span>&lt;T, <span class="hljs-literal">true</span>&gt; {
        <span class="hljs-keyword">template</span> &lt;<span class="hljs-type">bool</span> SIGNED&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">convert</span> <span class="hljs-params">(std::string in, T &amp;v)</span> <span class="hljs-type">const</span> </span>{
            <span class="hljs-keyword">if</span> (SIGNED) v = ::<span class="hljs-built_in">strtoll</span>(in.<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
            <span class="hljs-keyword">else</span> v = ::<span class="hljs-built_in">strtoull</span>(in.<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
        }
        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(std::string in, T &amp;v)</span> <span class="hljs-type">const</span> </span>{
            convert&lt;is_signed_int&lt;T&gt;::val&gt;(in, v);
        }
    };
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">const</span> csv_istream &amp; <span class="hljs-keyword">operator</span> &gt;&gt; (T &amp;v) <span class="hljs-type">const</span> {
        std::string tmp;
        <span class="hljs-built_in">scan</span>(&amp;tmp);
        set_value&lt;T, is_int&lt;T&gt;::val&gt;()(tmp, v);
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
    <span class="hljs-type">const</span> csv_istream &amp; <span class="hljs-keyword">operator</span> &gt;&gt; (std::string &amp;v) <span class="hljs-type">const</span> {
        v.<span class="hljs-built_in">clear</span>();
        <span class="hljs-built_in">scan_ws</span>();
        <span class="hljs-keyword">if</span> (is_.<span class="hljs-built_in">peek</span>() != <span class="hljs-string">'"'</span>) <span class="hljs-built_in">scan</span>(&amp;v);
        <span class="hljs-keyword">else</span> {
            std::string tmp;
            is_.<span class="hljs-built_in">get</span>();
            std::<span class="hljs-built_in">getline</span>(is_, tmp, <span class="hljs-string">'"'</span>);
            <span class="hljs-keyword">while</span> (is_.<span class="hljs-built_in">peek</span>() == <span class="hljs-string">'"'</span>) {
                v += tmp;
                v += is_.<span class="hljs-built_in">get</span>();
                std::<span class="hljs-built_in">getline</span>(is_, tmp, <span class="hljs-string">'"'</span>);
            }
            v += tmp;
            <span class="hljs-built_in">scan</span>();
        }
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-type">const</span> csv_istream &amp; <span class="hljs-keyword">operator</span> &gt;&gt; (T &amp;(*manip)(T &amp;)) <span class="hljs-type">const</span> {
        is_ &gt;&gt; manip;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span> <span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> !is_.<span class="hljs-built_in">fail</span>(); }
};
</code></pre>

<p>With the following helpers that may be simplified by the new integral traits templates in C++11:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_signed_int</span> { <span class="hljs-keyword">enum</span> { val = <span class="hljs-literal">false</span> }; };
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_signed_int</span>&lt;<span class="hljs-type">short</span>&gt; { <span class="hljs-keyword">enum</span> { val = <span class="hljs-literal">true</span>}; };
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_signed_int</span>&lt;<span class="hljs-type">int</span>&gt; { <span class="hljs-keyword">enum</span> { val = <span class="hljs-literal">true</span>}; };
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_signed_int</span>&lt;<span class="hljs-type">long</span>&gt; { <span class="hljs-keyword">enum</span> { val = <span class="hljs-literal">true</span>}; };
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_signed_int</span>&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; { <span class="hljs-keyword">enum</span> { val = <span class="hljs-literal">true</span>}; };

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_unsigned_int</span> { <span class="hljs-keyword">enum</span> { val = <span class="hljs-literal">false</span> }; };
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_unsigned_int</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>&gt; { <span class="hljs-keyword">enum</span> { val = <span class="hljs-literal">true</span>}; };
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_unsigned_int</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt; { <span class="hljs-keyword">enum</span> { val = <span class="hljs-literal">true</span>}; };
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_unsigned_int</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>&gt; { <span class="hljs-keyword">enum</span> { val = <span class="hljs-literal">true</span>}; };
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_unsigned_int</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; { <span class="hljs-keyword">enum</span> { val = <span class="hljs-literal">true</span>}; };

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_int</span> {
    <span class="hljs-keyword">enum</span> { val = (is_signed_int&lt;T&gt;::val || is_unsigned_int&lt;T&gt;::val) };
};
</code></pre>

<p><a href="https://tio.run/##rVZtT@NGEP7uXzG4UrDpFuXK0VNev/ToqRVUlaAnVQRFxt6EFc6u5d2YIi6/nc6sHbKOHTig5iWb3Zlnnnn1xln20zyOH38QMk6XCYehUNrkPFqMvc2eXm95hi@yNDK4Z@4zLqMFh4sx4PEyNiD0VIu55MlUSAMPwOVygR9FlMIIZlGqOawG@OugtOsO9Y3KzXgbAiX5dwLg33vUUyXn79WHF0BejOVSviearvZw/QXeFth2rLfEuB3pTeHeDfXuyNuAe4BPDSGoJ/li3O/TwbdvDTrVUUjWVoPHCjnWxVSUrVTBa5P0@@utDqIM7LYrGGzLhNAnewGtHlZWvlACUxtHcnqnIQghVlKvPaDn7kak3NI/nCuVBGHoHNJDDsfoIUlknN8G4aB@PoMghr0R7ONPpwPlemL2Q7hGXrdb0mSHGxek5LnFtvINXROYtAONBLpN8q7Mnd5Aupy3rBHd3c4mamtj4@EIvWL7lNFyPZHtHq41dNgCZSOu4ccRxIPWw2ei2Y5Gz4FFdAPQtHkYpzzKt5NXz8HzOzsCaoVbyqhZJXTI1YyiTssGIbcQ2tqQwbVS6VMzam6m2EhL7kTG1o/KeB4ZlVO518pISAYX0CmahVRrOBQtWyoQMoTxGIoGx8FOkk16QyROA2bs2Ntokktw/vuXP08@j0v6yK3guXkNdYpuiRFCgWmyakalKXpwGE/xSxAy6OLvVlo4vSocjeXzKqv/JdCVg8PWkTkOSLkIXxXy0oo7GjsbcpjAoJ2MS9ksso1JmkBBB7ccGrV8li@CDecwQOE67ZybZS7hwNyIqjFLR17k6rJqY100O6ea721zrhzZdor4OERKz1yetgRaOqEtLjsm@JMO7qdCcjLMwEaEjNYFnUlRcRtV3JoDrqC51mDwdLKDyqvo1Odcu0EbtNY22JXk1jL9vvRjqQYHi0iKLKR12CwAdIckrczL9fYEbifN5gawVtijKM4ikaKHqIJXEnp7LiIhSfjBqwjfRDm2dbY0l1cw8vx/sALZWXTL2ZlKeMo@cx3nIjNCSfZXLmI@kb7nf@j1PrHfVJ6wk6PjLpv4UcwgutYMFkrJic@Out3uYbe7Fu6xX294cY@CX7lEdhwm/sQ/@ddwmeAF7iQRZID2UNf@@9h7AwCDrzy/h9Mon3MX7LjO5hf2B@cZ@5JHMgHEzdUt5yh59vf5BZyfnJ7uTeTEi0ReugO5UjOGF8wITRG1T71ehYb3yubbBbQObESxsmodJ0zKL4@vBh4l4h4DXT9fUNTRIoUdEoz7wJuhUQMZxX3gObUVaB3aIsByKWG7V5v1B2f9s7M@ctYfkUbVsW24JTRxLCvylttP4kYLYkefllnoXmxjtTQwHILfJ@XRpU9fLA5tXvlbDW0lCb6StJaekSQCa1FLZrcscaxELd3dktaLStSuS1lMMN7kPW/1@B8" rel="nofollow noreferrer" title="C++ (gcc)  Try It Online">Try it online!</a></p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You might want to look at my FOSS project <a href="http://code.google.com/p/csvfix/" rel="nofollow noreferrer">CSVfix</a> (<a href="https://bitbucket.org/neilb/csvfix/" rel="nofollow noreferrer"><em>updated link</em></a>), which is a CSV stream editor written in C++. The CSV parser is no prize, but does the job and the whole package may do what you need without you writing any code.</p>

<p>See <a href="https://bitbucket.org/neilb/csvfix/src/default/alib/src/a_csv.cpp?fileviewer=file-view-default" rel="nofollow noreferrer">alib/src/a_csv.cpp</a> for the CSV parser, and <a href="https://bitbucket.org/neilb/csvfix/src/default/csvfix/src/csved_ioman.cpp?fileviewer=file-view-default#csved_ioman.cpp-348" rel="nofollow noreferrer">csvlib/src/csved_ioman.cpp</a> (<code>IOManager::ReadCSV</code>) for a usage example.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Another CSV I/O library can be found here:</p>

<p><a href="http://code.google.com/p/fast-cpp-csv-parser/" rel="noreferrer">http://code.google.com/p/fast-cpp-csv-parser/</a></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"csv.h"</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
  <span class="hljs-function">io::CSVReader&lt;3&gt; <span class="hljs-title">in</span><span class="hljs-params">(<span class="hljs-string">"ram.csv"</span>)</span></span>;
  in.<span class="hljs-built_in">read_header</span>(io::ignore_extra_column, <span class="hljs-string">"vendor"</span>, <span class="hljs-string">"size"</span>, <span class="hljs-string">"speed"</span>);
  std::string vendor; <span class="hljs-type">int</span> size; <span class="hljs-type">double</span> speed;
  <span class="hljs-keyword">while</span>(in.<span class="hljs-built_in">read_row</span>(vendor, size, speed)){
    <span class="hljs-comment">// do stuff with the data</span>
  }
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Another solution similar to <a href="https://stackoverflow.com/a/1120224/1749822">Loki Astari's answer</a>, in C++11. Rows here are <code>std::tuple</code>s of a given type. The code scans one line, then scans until each delimiter, and then converts and dumps the value directly into the tuple (with a bit of template code).</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> row : <span class="hljs-built_in">csv</span>&lt;std::string, <span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt;(file, <span class="hljs-string">','</span>)) {
    std::cout &lt;&lt; <span class="hljs-string">"first col: "</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(row) &lt;&lt; std::endl;
}
</code></pre>

<p><strong>Advanges:</strong></p>

<ul>
<li>quite clean and simple to use, only C++11.</li>
<li>automatic type conversion into <code>std::tuple&lt;t1, ...&gt;</code> via <code>operator&gt;&gt;</code>.</li>
</ul>

<p><strong>What's missing:</strong></p>

<ul>
<li>escaping and quoting</li>
<li>no error handling in case of malformed CSV.</li>
</ul>

<p>The main code:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">namespace</span> csvtools {
    <span class="hljs-comment">/// Read the last element of the tuple without calling recursively</span>
    <span class="hljs-keyword">template</span> &lt;std::<span class="hljs-type">size_t</span> idx, <span class="hljs-keyword">class</span>... fields&gt;
    <span class="hljs-keyword">typename</span> std::enable_if&lt;idx &gt;= std::tuple_size&lt;std::tuple&lt;fields...&gt;&gt;::value - <span class="hljs-number">1</span>&gt;::type
    <span class="hljs-built_in">read_tuple</span>(std::istream &amp;in, std::tuple&lt;fields...&gt; &amp;out, <span class="hljs-type">const</span> <span class="hljs-type">char</span> delimiter) {
        std::string cell;
        std::<span class="hljs-built_in">getline</span>(in, cell, delimiter);
        <span class="hljs-function">std::stringstream <span class="hljs-title">cell_stream</span><span class="hljs-params">(cell)</span></span>;
        cell_stream &gt;&gt; std::<span class="hljs-built_in">get</span>&lt;idx&gt;(out);
    }

    <span class="hljs-comment">/// Read the @p idx-th element of the tuple and then calls itself with @p idx + 1 to</span>
    <span class="hljs-comment">/// read the next element of the tuple. Automatically falls in the previous case when</span>
    <span class="hljs-comment">/// reaches the last element of the tuple thanks to enable_if</span>
    <span class="hljs-keyword">template</span> &lt;std::<span class="hljs-type">size_t</span> idx, <span class="hljs-keyword">class</span>... fields&gt;
    <span class="hljs-keyword">typename</span> std::enable_if&lt;idx &lt; std::tuple_size&lt;std::tuple&lt;fields...&gt;&gt;::value - <span class="hljs-number">1</span>&gt;::<span class="hljs-function">type
    <span class="hljs-title">read_tuple</span><span class="hljs-params">(std::istream &amp;in, std::tuple&lt;fields...&gt; &amp;out, <span class="hljs-type">const</span> <span class="hljs-type">char</span> delimiter)</span> </span>{
        std::string cell;
        std::<span class="hljs-built_in">getline</span>(in, cell, delimiter);
        <span class="hljs-function">std::stringstream <span class="hljs-title">cell_stream</span><span class="hljs-params">(cell)</span></span>;
        cell_stream &gt;&gt; std::<span class="hljs-built_in">get</span>&lt;idx&gt;(out);
        <span class="hljs-built_in">read_tuple</span>&lt;idx + <span class="hljs-number">1</span>, fields...&gt;(in, out, delimiter);
    }
}

<span class="hljs-comment">/// Iterable csv wrapper around a stream. @p fields the list of types that form up a row.</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... fields&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">csv</span> {
    std::istream &amp;_in;
    <span class="hljs-type">const</span> <span class="hljs-type">char</span> _delim;
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">typedef</span> std::tuple&lt;fields...&gt; value_type;
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span>;

    <span class="hljs-comment">/// Construct from a stream.</span>
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">csv</span><span class="hljs-params">(std::istream &amp;in, <span class="hljs-type">const</span> <span class="hljs-type">char</span> delim)</span> : _in(in), _delim(delim) {</span>}

    <span class="hljs-comment">/// Status of the underlying stream</span>
    <span class="hljs-comment">/// @{</span>
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">good</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">return</span> _in.<span class="hljs-built_in">good</span>();
    }
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> std::istream &amp;<span class="hljs-title">underlying_stream</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">return</span> _in;
    }
    <span class="hljs-comment">/// @}</span>

    <span class="hljs-function"><span class="hljs-keyword">inline</span> iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">inline</span> iterator <span class="hljs-title">end</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:

    <span class="hljs-comment">/// Reads a line into a stringstream, and then reads the line into a tuple, that is returned</span>
    <span class="hljs-function"><span class="hljs-keyword">inline</span> value_type <span class="hljs-title">read_row</span><span class="hljs-params">()</span> </span>{
        std::string line;
        std::<span class="hljs-built_in">getline</span>(_in, line);
        <span class="hljs-function">std::stringstream <span class="hljs-title">line_stream</span><span class="hljs-params">(line)</span></span>;
        std::tuple&lt;fields...&gt; retval;
        csvtools::<span class="hljs-built_in">read_tuple</span>&lt;<span class="hljs-number">0</span>, fields...&gt;(line_stream, retval, _delim);
        <span class="hljs-keyword">return</span> retval;
    }
};

<span class="hljs-comment">/// Iterator; just calls recursively @ref csv::read_row and stores the result.</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... fields&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">csv</span>&lt;fields...&gt;::iterator {
    csv::value_type _row;
    csv *_parent;
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">typedef</span> std::input_iterator_tag iterator_category;
    <span class="hljs-keyword">typedef</span> csv::value_type         value_type;
    <span class="hljs-keyword">typedef</span> std::<span class="hljs-type">size_t</span>             difference_type;
    <span class="hljs-keyword">typedef</span> csv::value_type *       pointer;
    <span class="hljs-keyword">typedef</span> csv::value_type &amp;       reference;

    <span class="hljs-comment">/// Construct an empty/end iterator</span>
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">iterator</span><span class="hljs-params">()</span> : _parent(nullptr) {</span>}
    <span class="hljs-comment">/// Construct an iterator at the beginning of the @p parent csv object.</span>
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">iterator</span><span class="hljs-params">(csv &amp;parent)</span> : _parent(parent.good() ? &amp;parent : nullptr) {</span>
        ++(*<span class="hljs-keyword">this</span>);
    }

    <span class="hljs-comment">/// Read one row, if possible. Set to end if parent is not good anymore.</span>
    <span class="hljs-keyword">inline</span> iterator &amp;<span class="hljs-keyword">operator</span>++() {
        <span class="hljs-keyword">if</span> (_parent != <span class="hljs-literal">nullptr</span>) {
            _row = _parent-&gt;<span class="hljs-built_in">read_row</span>();
            <span class="hljs-keyword">if</span> (!_parent-&gt;<span class="hljs-built_in">good</span>()) {
                _parent = <span class="hljs-literal">nullptr</span>;
            }
        }
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }

    <span class="hljs-keyword">inline</span> iterator <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) {
        iterator copy = *<span class="hljs-keyword">this</span>;
        ++(*<span class="hljs-keyword">this</span>);
        <span class="hljs-keyword">return</span> copy;
    }

    <span class="hljs-keyword">inline</span> csv::value_type <span class="hljs-type">const</span> &amp;<span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> {
        <span class="hljs-keyword">return</span> _row;
    }

    <span class="hljs-keyword">inline</span> csv::value_type <span class="hljs-type">const</span> *<span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> {
        <span class="hljs-keyword">return</span> &amp;_row;
    }

    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(iterator <span class="hljs-type">const</span> &amp;other) {
        <span class="hljs-built_in">return</span> (<span class="hljs-keyword">this</span> == &amp;other) <span class="hljs-built_in">or</span> (_parent == <span class="hljs-literal">nullptr</span> <span class="hljs-keyword">and</span> other._parent == <span class="hljs-literal">nullptr</span>);
    }
    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(iterator <span class="hljs-type">const</span> &amp;other) {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">not</span> (*<span class="hljs-keyword">this</span> == other);
    }
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... fields&gt;
<span class="hljs-keyword">typename</span> csv&lt;fields...&gt;::iterator csv&lt;fields...&gt;::<span class="hljs-built_in">begin</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(*<span class="hljs-keyword">this</span>);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... fields&gt;
<span class="hljs-keyword">typename</span> csv&lt;fields...&gt;::iterator csv&lt;fields...&gt;::<span class="hljs-built_in">end</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>();
}
</code></pre>

<p>I put a tiny working example on <a href="https://github.com/LizardM4/ballin-octo-tribble/tree/master/csv" rel="nofollow noreferrer">GitHub</a>; I've been using it for parsing some numerical data and it served its purpose.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is another implementation of a Unicode CSV parser (works with wchar_t). I wrote part of it, while Jonathan Leffler wrote the rest.</p>

<p>Note: This parser is aimed at replicating Excel's behavior as closely as possible, specifically when importing <strong>broken or malformed</strong> CSV files.</p>

<p>This is the original question - <a href="https://stackoverflow.com/questions/15520113/parsing-csv-file-with-multiline-fields-and-escaped-double-quotes">Parsing CSV file with multiline fields and escaped double quotes</a></p>

<p>This is the code as a SSCCE (Short, Self-Contained, Correct Example).</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wchar.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wctype.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *<span class="hljs-title">nextCsvField</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *p, <span class="hljs-type">wchar_t</span> sep, <span class="hljs-type">bool</span> *newline)</span></span>;

<span class="hljs-comment">// Returns a pointer to the start of the next field,</span>
<span class="hljs-comment">// or zero if this is the last field in the CSV</span>
<span class="hljs-comment">// p is the start position of the field</span>
<span class="hljs-comment">// sep is the separator used, i.e. comma or semicolon</span>
<span class="hljs-comment">// newline says whether the field ends with a newline or with a comma</span>
<span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *<span class="hljs-title">nextCsvField</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *p, <span class="hljs-type">wchar_t</span> sep, <span class="hljs-type">bool</span> *newline)</span>
</span>{
    <span class="hljs-comment">// Parse quoted sequences</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-string">'"'</span> == p[<span class="hljs-number">0</span>]) {
        p++;
        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
            <span class="hljs-comment">// Find next double-quote</span>
            p = <span class="hljs-built_in">wcschr</span>(p, <span class="hljs-string">L'"'</span>);
            <span class="hljs-comment">// If we don't find it or it's the last symbol</span>
            <span class="hljs-comment">// then this is the last field</span>
            <span class="hljs-keyword">if</span> (!p || !p[<span class="hljs-number">1</span>])
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
            <span class="hljs-comment">// Check for "", it is an escaped double-quote</span>
            <span class="hljs-keyword">if</span> (p[<span class="hljs-number">1</span>] != <span class="hljs-string">'"'</span>)
                <span class="hljs-keyword">break</span>;
            <span class="hljs-comment">// Skip the escaped double-quote</span>
            p += <span class="hljs-number">2</span>;
        }
    }

    <span class="hljs-comment">// Find next newline or comma.</span>
    <span class="hljs-type">wchar_t</span> newline_or_sep[<span class="hljs-number">4</span>] = <span class="hljs-string">L"\n\r "</span>;
    newline_or_sep[<span class="hljs-number">2</span>] = sep;
    p = <span class="hljs-built_in">wcspbrk</span>(p, newline_or_sep);

    <span class="hljs-comment">// If no newline or separator, this is the last field.</span>
    <span class="hljs-keyword">if</span> (!p)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Check if we had newline.</span>
    *newline = (p[<span class="hljs-number">0</span>] == <span class="hljs-string">'\r'</span> || p[<span class="hljs-number">0</span>] == <span class="hljs-string">'\n'</span>);

    <span class="hljs-comment">// Handle "\r\n", otherwise just increment</span>
    <span class="hljs-keyword">if</span> (p[<span class="hljs-number">0</span>] == <span class="hljs-string">'\r'</span> &amp;&amp; p[<span class="hljs-number">1</span>] == <span class="hljs-string">'\n'</span>)
        p += <span class="hljs-number">2</span>;
    <span class="hljs-keyword">else</span>
        p++;

    <span class="hljs-keyword">return</span> p;
}

<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">wchar_t</span> *<span class="hljs-title">csvFieldData</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *fld_s, <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *fld_e, <span class="hljs-type">wchar_t</span> *buffer, <span class="hljs-type">size_t</span> buflen)</span>
</span>{
    <span class="hljs-type">wchar_t</span> *dst = buffer;
    <span class="hljs-type">wchar_t</span> *end = buffer + buflen - <span class="hljs-number">1</span>;
    <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *src = fld_s;

    <span class="hljs-keyword">if</span> (*src == <span class="hljs-string">L'"'</span>)
    {
        <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *p = src + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (p &lt; fld_e &amp;&amp; dst &lt; end)
        {
            <span class="hljs-keyword">if</span> (p[<span class="hljs-number">0</span>] == <span class="hljs-string">L'"'</span> &amp;&amp; p+<span class="hljs-number">1</span> &lt; fld_s &amp;&amp; p[<span class="hljs-number">1</span>] == <span class="hljs-string">L'"'</span>)
            {
                *dst++ = p[<span class="hljs-number">0</span>];
                p += <span class="hljs-number">2</span>;
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p[<span class="hljs-number">0</span>] == <span class="hljs-string">L'"'</span>)
            {
                p++;
                <span class="hljs-keyword">break</span>;
            }
            <span class="hljs-keyword">else</span>
                *dst++ = *p++;
        }
        src = p;
    }
    <span class="hljs-keyword">while</span> (src &lt; fld_e &amp;&amp; dst &lt; end)
        *dst++ = *src++;
    <span class="hljs-keyword">if</span> (dst &gt;= end)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    *dst = <span class="hljs-string">L'\0'</span>;
    <span class="hljs-keyword">return</span>(buffer);
}

<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">dissect</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *line)</span>
</span>{
    <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *start = line;
    <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *next;
    <span class="hljs-type">bool</span>     eol;
    <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L"Input %3zd: [%.*ls]\n"</span>, <span class="hljs-built_in">wcslen</span>(line), <span class="hljs-built_in">wcslen</span>(line)<span class="hljs-number">-1</span>, line);
    <span class="hljs-keyword">while</span> ((next = <span class="hljs-built_in">nextCsvField</span>(start, <span class="hljs-string">L','</span>, &amp;eol)) != <span class="hljs-number">0</span>)
    {
        <span class="hljs-type">wchar_t</span> buffer[<span class="hljs-number">1024</span>];
        <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L"Raw Field: [%.*ls] (eol = %d)\n"</span>, (next - start - eol), start, eol);
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">csvFieldData</span>(start, next<span class="hljs-number">-1</span>, buffer, <span class="hljs-built_in">sizeof</span>(buffer)/<span class="hljs-built_in">sizeof</span>(buffer[<span class="hljs-number">0</span>])) != <span class="hljs-number">0</span>)
            <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L"Field %3zd: [%ls]\n"</span>, <span class="hljs-built_in">wcslen</span>(buffer), buffer);
        start = next;
    }
}

<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> multiline[] =
   <span class="hljs-string">L"First field of first row,\"This field is multiline\n"</span>
    <span class="hljs-string">"\n"</span>
    <span class="hljs-string">"but that's OK because it's enclosed in double quotes, and this\n"</span>
    <span class="hljs-string">"is an escaped \"\" double quote\" but this one \"\" is not\n"</span>
    <span class="hljs-string">"   \"This is second field of second row, but it is not multiline\n"</span>
    <span class="hljs-string">"   because it doesn't start \n"</span>
    <span class="hljs-string">"   with an immediate double quote\"\n"</span>
    ;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
    <span class="hljs-type">wchar_t</span> line[<span class="hljs-number">1024</span>];

    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">fgetws</span>(line, <span class="hljs-built_in">sizeof</span>(line)/<span class="hljs-built_in">sizeof</span>(line[<span class="hljs-number">0</span>]), stdin))
        <span class="hljs-built_in">dissect</span>(line);
    <span class="hljs-built_in">dissect</span>(multiline);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This is an old thread but its still at the top of search results, so I'm adding my solution using std::stringstream and a simple string replace method by Yves Baumes I found here.  </p>

<p>The following example will read a file line by line, ignore comment lines starting with // and parse the other lines into a combination of strings, ints and doubles. Stringstream does the parsing, but expects fields to be delimited by whitespace, so I use stringreplace to turn commas into spaces first. It handles tabs ok, but doesn't deal with quoted strings.</p>

<p>Bad or missing input is simply ignored, which may or may not be good, depending on your circumstance.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StringReplace</span><span class="hljs-params">(std::string&amp; str, <span class="hljs-type">const</span> std::string&amp; oldStr, <span class="hljs-type">const</span> std::string&amp; newStr)</span>
<span class="hljs-comment">// code by  Yves Baumes</span>
<span class="hljs-comment">// http://stackoverflow.com/questions/1494399/how-do-i-search-find-and-replace-in-a-standard-string</span>
</span>{
  <span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span>((pos = str.<span class="hljs-built_in">find</span>(oldStr, pos)) != std::string::npos)
  {
     str.<span class="hljs-built_in">replace</span>(pos, oldStr.<span class="hljs-built_in">length</span>(), newStr);
     pos += newStr.<span class="hljs-built_in">length</span>();
  }
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LoadCSV</span><span class="hljs-params">(std::string &amp;filename)</span> </span>{
   <span class="hljs-function">std::ifstream <span class="hljs-title">stream</span><span class="hljs-params">(filename)</span></span>;
   std::string in_line;
   std::string Field;
   std::string Chan;
   <span class="hljs-type">int</span> ChanType;
   <span class="hljs-type">double</span> Scale;
   <span class="hljs-type">int</span> Import;
   <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(stream, in_line)) {
      <span class="hljs-built_in">StringReplace</span>(in_line, <span class="hljs-string">","</span>, <span class="hljs-string">" "</span>);
      <span class="hljs-function">std::stringstream <span class="hljs-title">line</span><span class="hljs-params">(in_line)</span></span>;
      line &gt;&gt; Field &gt;&gt; Chan &gt;&gt; ChanType &gt;&gt; Scale &gt;&gt; Import;
      <span class="hljs-keyword">if</span> (Field.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)!=<span class="hljs-string">"//"</span>) {
         <span class="hljs-comment">// do your stuff </span>
         <span class="hljs-comment">// this is CBuilder code for demonstration, sorry</span>
         <span class="hljs-built_in">ShowMessage</span>((String)Field.<span class="hljs-built_in">c_str</span>() + <span class="hljs-string">"\n"</span> + Chan.<span class="hljs-built_in">c_str</span>() + <span class="hljs-string">"\n"</span> + <span class="hljs-built_in">IntToStr</span>(ChanType) + <span class="hljs-string">"\n"</span> +<span class="hljs-built_in">FloatToStr</span>(Scale) + <span class="hljs-string">"\n"</span> +<span class="hljs-built_in">IntToStr</span>(Import));
      }
   }
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I needed an easy-to-use C++ library for parsing CSV files but couldn't find any available, so I ended up building one.
<a href="https://github.com/d99kris/rapidcsv/" rel="nofollow noreferrer">Rapidcsv</a> is a C++11 header-only library which gives direct access to parsed columns (or rows) as vectors, in datatype of choice. For example:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rapidcsv.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-function">rapidcsv::Document <span class="hljs-title">doc</span><span class="hljs-params">(<span class="hljs-string">"../tests/msft.csv"</span>)</span></span>;

  std::vector&lt;<span class="hljs-type">float</span>&gt; close = doc.<span class="hljs-built_in">GetColumn</span>&lt;<span class="hljs-type">float</span>&gt;(<span class="hljs-string">"Close"</span>);
  std::cout &lt;&lt; <span class="hljs-string">"Read "</span> &lt;&lt; close.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">" values."</span> &lt;&lt; std::endl;
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You can use the header-only <a href="https://github.com/ashaduri/csv-parser" rel="nofollow noreferrer">Csv::Parser</a> library.</p>
<ul>
<li>It fully supports RFC 4180, including quoted values, escaped quotes, and newlines in field values.</li>
<li>It requires only standard C++ (C++17).</li>
<li>It supports reading CSV data from <code>std::string_view</code> at compile-time.</li>
<li>It's extensively tested using <a href="https://github.com/catchorg/Catch2" rel="nofollow noreferrer">Catch2</a>.</li>
</ul>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 18</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is code for reading a matrix, note you also have a csvwrite function in matlab</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">loadFromCSV</span><span class="hljs-params">( <span class="hljs-type">const</span> std::string&amp; filename )</span>
</span>{
    <span class="hljs-function">std::ifstream       <span class="hljs-title">file</span><span class="hljs-params">( filename.c_str() )</span></span>;
    std::vector&lt; std::vector&lt;std::string&gt; &gt;   matrix;
    std::vector&lt;std::string&gt;   row;
    std::string                line;
    std::string                cell;

    <span class="hljs-keyword">while</span>( file )
    {
        std::<span class="hljs-built_in">getline</span>(file,line);
        <span class="hljs-function">std::stringstream <span class="hljs-title">lineStream</span><span class="hljs-params">(line)</span></span>;
        row.<span class="hljs-built_in">clear</span>();

        <span class="hljs-keyword">while</span>( std::<span class="hljs-built_in">getline</span>( lineStream, cell, <span class="hljs-string">','</span> ) )
            row.<span class="hljs-built_in">push_back</span>( cell );

        <span class="hljs-keyword">if</span>( !row.<span class="hljs-built_in">empty</span>() )
            matrix.<span class="hljs-built_in">push_back</span>( row );
    }

    <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">int</span>(matrix.<span class="hljs-built_in">size</span>()); i++ )
    {
        <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-built_in">int</span>(matrix[i].<span class="hljs-built_in">size</span>()); j++ )
            std::cout &lt;&lt; matrix[i][j] &lt;&lt; <span class="hljs-string">" "</span>;

        std::cout &lt;&lt; std::endl;
    }
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 19</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Excuse me, but this all seems like a great deal of elaborate syntax to hide a few lines of code.</p>

<p>Why not this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">/**

  Read line from a CSV file

  @param[in] fp file pointer to open file
  @param[in] vls reference to vector of strings to hold next line

  */</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">readCSV</span><span class="hljs-params">( FILE *fp, std::vector&lt;std::string&gt;&amp; vls )</span>
</span>{
    vls.<span class="hljs-built_in">clear</span>();
    <span class="hljs-keyword">if</span>( ! fp )
        <span class="hljs-keyword">return</span>;
    <span class="hljs-type">char</span> buf[<span class="hljs-number">10000</span>];
    <span class="hljs-keyword">if</span>( ! <span class="hljs-built_in">fgets</span>( buf,<span class="hljs-number">999</span>,fp) )
        <span class="hljs-keyword">return</span>;
    std::string s = buf;
    <span class="hljs-type">int</span> p,q;
    q = <span class="hljs-number">-1</span>;
    <span class="hljs-comment">// loop over columns</span>
    <span class="hljs-keyword">while</span>( <span class="hljs-number">1</span> ) {
        p = q;
        q = s.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">",\n"</span>,p+<span class="hljs-number">1</span>);
        <span class="hljs-keyword">if</span>( q == <span class="hljs-number">-1</span> ) 
            <span class="hljs-keyword">break</span>;
        vls.<span class="hljs-built_in">push_back</span>( s.<span class="hljs-built_in">substr</span>(p+<span class="hljs-number">1</span>,q-p<span class="hljs-number">-1</span>) );
    }
}

<span class="hljs-type">int</span> _tmain(<span class="hljs-type">int</span> argc, _TCHAR* argv[])
{
    std::vector&lt;std::string&gt; vls;
    FILE * fp = <span class="hljs-built_in">fopen</span>( argv[<span class="hljs-number">1</span>], <span class="hljs-string">"r"</span> );
    <span class="hljs-keyword">if</span>( ! fp )
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-built_in">readCSV</span>( fp, vls );
    <span class="hljs-built_in">readCSV</span>( fp, vls );
    <span class="hljs-built_in">readCSV</span>( fp, vls );
    std::cout &lt;&lt; <span class="hljs-string">"row 3, col 4 is "</span> &lt;&lt; vls[<span class="hljs-number">3</span>].<span class="hljs-built_in">c_str</span>() &lt;&lt; <span class="hljs-string">"\n"</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 20</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You can open and read .csv file using fopen ,fscanf functions ,but the important thing is to parse the data.Simplest way to parse the data using delimiter.In case of .csv , delimiter is ','.</p>

<p>Suppose your data1.csv file is as follows : </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">A,<span class="hljs-number">45</span>,<span class="hljs-number">76</span>,<span class="hljs-number">01</span>
B,<span class="hljs-number">77</span>,<span class="hljs-number">67</span>,<span class="hljs-number">02</span>
C,<span class="hljs-number">63</span>,<span class="hljs-number">76</span>,<span class="hljs-number">03</span>
D,<span class="hljs-number">65</span>,<span class="hljs-number">44</span>,<span class="hljs-number">04</span>
</code></pre>

<p>you can tokenize data and store in char array and later use atoi() etc function for appropriate conversions  </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">FILE *fp;
<span class="hljs-type">char</span> str1[<span class="hljs-number">10</span>], str2[<span class="hljs-number">10</span>], str3[<span class="hljs-number">10</span>], str4[<span class="hljs-number">10</span>];

fp = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">"G:\\data1.csv"</span>, <span class="hljs-string">"r"</span>);
<span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == fp)
{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\nError in opening file."</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
<span class="hljs-keyword">while</span>(EOF != <span class="hljs-built_in">fscanf</span>(fp, <span class="hljs-string">" %[^,], %[^,], %[^,], %s, %s, %s, %s "</span>, str1, str2, str3, str4))
{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n%s %s %s %s"</span>, str1, str2, str3, str4);
}
<span class="hljs-built_in">fclose</span>(fp);
</code></pre>

<p>[^,], ^ -it inverts logic , means match any string that does not contain comma then last , says to match comma that terminated previous string. </p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 21</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The first thing you need to do is make sure the file exists. To accomplish
this you just need to try and open the file stream at the path. After you
have opened the file stream use stream.fail() to see if it worked as expected,
or not.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">fileExists</span><span class="hljs-params">(string fileName)</span>
</span>{

ifstream test;

test.<span class="hljs-built_in">open</span>(fileName.<span class="hljs-built_in">c_str</span>());

<span class="hljs-keyword">if</span> (test.<span class="hljs-built_in">fail</span>())
{
    test.<span class="hljs-built_in">close</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
<span class="hljs-keyword">else</span>
{
    test.<span class="hljs-built_in">close</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
}
</code></pre>

<p>You must also verify that the file provided is the correct type of file.
To accomplish this you need to look through the file path provided until 
you find the file extension. Once you have the file extension make sure
that it is a .csv file.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">verifyExtension</span><span class="hljs-params">(string filename)</span>
</span>{
<span class="hljs-type">int</span> period = <span class="hljs-number">0</span>;

<span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; filename.<span class="hljs-built_in">length</span>(); i++)
{
    <span class="hljs-keyword">if</span> (filename[i] == <span class="hljs-string">'.'</span>)
        period = i;
}

string extension;

<span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = period; i &lt; filename.<span class="hljs-built_in">length</span>(); i++)
    extension += filename[i];

<span class="hljs-keyword">if</span> (extension == <span class="hljs-string">".csv"</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
<span class="hljs-keyword">else</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
</code></pre>

<p>This function will return the file extension which is used later in an error message.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">string <span class="hljs-title">getExtension</span><span class="hljs-params">(string filename)</span>
</span>{
<span class="hljs-type">int</span> period = <span class="hljs-number">0</span>;

<span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; filename.<span class="hljs-built_in">length</span>(); i++)
{
    <span class="hljs-keyword">if</span> (filename[i] == <span class="hljs-string">'.'</span>)
        period = i;
}

string extension;

<span class="hljs-keyword">if</span> (period != <span class="hljs-number">0</span>)
{
    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = period; i &lt; filename.<span class="hljs-built_in">length</span>(); i++)
        extension += filename[i];
}
<span class="hljs-keyword">else</span>
    extension = <span class="hljs-string">"NO FILE"</span>;

<span class="hljs-keyword">return</span> extension;
}
</code></pre>

<p>This function will actually call the error checks created above and then parse through the file.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parseFile</span><span class="hljs-params">(string fileName)</span>
</span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fileExists</span>(fileName) &amp;&amp; <span class="hljs-built_in">verifyExtension</span>(fileName))
    {
        ifstream fs;
        fs.<span class="hljs-built_in">open</span>(fileName.<span class="hljs-built_in">c_str</span>());
        string fileCommand;

        <span class="hljs-keyword">while</span> (fs.<span class="hljs-built_in">good</span>())
        {
            string temp;

            <span class="hljs-built_in">getline</span>(fs, fileCommand, <span class="hljs-string">'\n'</span>);

            <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; fileCommand.<span class="hljs-built_in">length</span>(); i++)
            {
                <span class="hljs-keyword">if</span> (fileCommand[i] != <span class="hljs-string">','</span>)
                    temp += fileCommand[i];
                <span class="hljs-keyword">else</span>
                    temp += <span class="hljs-string">" "</span>;
            }

            <span class="hljs-keyword">if</span> (temp != <span class="hljs-string">"\0"</span>)
            {
                <span class="hljs-comment">// Place your code here to run the file.</span>
            }
        }
        fs.<span class="hljs-built_in">close</span>();
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">fileExists</span>(fileName))
    {
        cout &lt;&lt; <span class="hljs-string">"Error: The provided file does not exist: "</span> &lt;&lt; fileName &lt;&lt; endl;

        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">verifyExtension</span>(fileName))
        {
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getExtension</span>(fileName) != <span class="hljs-string">"NO FILE"</span>)
                cout &lt;&lt; <span class="hljs-string">"\tCheck the file extension."</span> &lt;&lt; endl;
            <span class="hljs-keyword">else</span>
                cout &lt;&lt; <span class="hljs-string">"\tThere is no file in the provided path."</span> &lt;&lt; endl;
        }
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">verifyExtension</span>(fileName)) 
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getExtension</span>(fileName) != <span class="hljs-string">"NO FILE"</span>)
            cout &lt;&lt; <span class="hljs-string">"Incorrect file extension provided: "</span> &lt;&lt; <span class="hljs-built_in">getExtension</span>(fileName) &lt;&lt; endl;
        <span class="hljs-keyword">else</span>
            cout &lt;&lt; <span class="hljs-string">"There is no file in the following path: "</span> &lt;&lt; fileName &lt;&lt; endl;
    }
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 22</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Since i'm not used to boost right now, I will suggest a more simple solution. Lets suppose that your .csv file has 100 lines with 10 numbers in each line separated by a ','. You could load this data in the form of an array with the following code:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">int</span> A[<span class="hljs-number">100</span>][<span class="hljs-number">10</span>];
    ifstream ifs;
    ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">"name_of_file.csv"</span>);
    string s1;
    <span class="hljs-type">char</span> c;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k&lt;<span class="hljs-number">100</span>; k++)
    {
        <span class="hljs-built_in">getline</span>(ifs,s1);
        <span class="hljs-function">stringstream <span class="hljs-title">stream</span><span class="hljs-params">(s1)</span></span>;
        <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)
        {
            stream &gt;&gt;A[k][j];
            stream &gt;&gt; c;
            j++;
            <span class="hljs-keyword">if</span>(!stream) {<span class="hljs-keyword">break</span>;}
        }
    }


}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 23</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You can use this library:
<a href="https://github.com/vadamsky/csvworker" rel="nofollow noreferrer">https://github.com/vadamsky/csvworker</a></p>

<p>Code for example:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"csvworker.h"</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">//</span>
    CsvWorker csv;
    csv.<span class="hljs-built_in">loadFromFile</span>(<span class="hljs-string">"example.csv"</span>);
    cout &lt;&lt; csv.<span class="hljs-built_in">getRowsNumber</span>() &lt;&lt; <span class="hljs-string">"  "</span> &lt;&lt; csv.<span class="hljs-built_in">getColumnsNumber</span>() &lt;&lt; endl;

    csv.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>) = <span class="hljs-string">"0"</span>;
    csv.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) = <span class="hljs-string">"0"</span>;
    csv.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) = <span class="hljs-string">"0"</span>;
    csv.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>) = <span class="hljs-string">"0"</span>;
    csv.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>) = <span class="hljs-string">"0"</span>;
    csv.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>) = <span class="hljs-string">"0"</span>;
    csv.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>) = <span class="hljs-string">"0"</span>;
    csv.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>) = <span class="hljs-string">"0"</span>;

    <span class="hljs-keyword">for</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;csv.<span class="hljs-built_in">getRowsNumber</span>();++i)
    {
        <span class="hljs-comment">//cout &lt;&lt; csv.getRow(i) &lt;&lt; endl;</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;csv.<span class="hljs-built_in">getColumnsNumber</span>();++j)
        {
            cout &lt;&lt; csv.<span class="hljs-built_in">getField</span>(i, j) &lt;&lt; <span class="hljs-string">"."</span>;
        }
        cout &lt;&lt; endl;
    }

    csv.<span class="hljs-built_in">saveToFile</span>(<span class="hljs-string">"test.csv"</span>);

    <span class="hljs-comment">//</span>
    <span class="hljs-function">CsvWorker <span class="hljs-title">csv2</span><span class="hljs-params">(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>)</span></span>;

    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) = <span class="hljs-string">"a"</span>;
    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) = <span class="hljs-string">"b"</span>;
    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>) = <span class="hljs-string">"r"</span>;
    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>) = <span class="hljs-string">"a"</span>;
    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>) = <span class="hljs-string">"c"</span>;
    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) = <span class="hljs-string">"a"</span>;
    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) = <span class="hljs-string">"d"</span>;
    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>) = <span class="hljs-string">"a"</span>;
    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>) = <span class="hljs-string">"b"</span>;
    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>) = <span class="hljs-string">"r"</span>;
    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) = <span class="hljs-string">"a"</span>;

    csv2.<span class="hljs-built_in">saveToFile</span>(<span class="hljs-string">"test2.csv"</span>);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 24</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You gotta feel proud when you use something so beautiful as <code>boost::spirit</code></p>

<p>Here my attempt of a parser (almost) complying with the CSV specifications on this link <a href="http://www.ietf.org/rfc/rfc4180.txt" rel="nofollow noreferrer">CSV specs</a> (I didn't need line breaks within fields. Also the spaces around the commas are dismissed).</p>

<p>After you overcome the shocking experience of waiting 10 seconds for compiling this code :), you can sit back and enjoy.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// csvparser.cpp</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/spirit/include/qi.hpp&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/spirit/include/phoenix_operator.hpp&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">namespace</span> qi = boost::spirit::qi;
<span class="hljs-keyword">namespace</span> bascii = boost::spirit::ascii;

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Iterator&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">csv_parser</span> : qi::grammar&lt;Iterator, std::<span class="hljs-built_in">vector</span>&lt;std::string&gt;(), 
    bascii::space_type&gt;
{
    qi::rule&lt;Iterator, <span class="hljs-built_in">char</span>()                                           &gt; COMMA;
    qi::rule&lt;Iterator, <span class="hljs-built_in">char</span>()                                           &gt; DDQUOTE;
    qi::rule&lt;Iterator, std::<span class="hljs-built_in">string</span>(),               bascii::space_type  &gt; non_escaped;
    qi::rule&lt;Iterator, std::<span class="hljs-built_in">string</span>(),               bascii::space_type  &gt; escaped;
    qi::rule&lt;Iterator, std::<span class="hljs-built_in">string</span>(),               bascii::space_type  &gt; field;
    qi::rule&lt;Iterator, std::<span class="hljs-built_in">vector</span>&lt;std::string&gt;(),  bascii::space_type  &gt; start;

    <span class="hljs-built_in">csv_parser</span>() : csv_parser::<span class="hljs-built_in">base_type</span>(start)
    {
        <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> qi;
        <span class="hljs-keyword">using</span> qi::lit;
        <span class="hljs-keyword">using</span> qi::lexeme;
        <span class="hljs-keyword">using</span> bascii::char_;

        start       = field % <span class="hljs-string">','</span>;
        field       = escaped | non_escaped;
        escaped     = lexeme[<span class="hljs-string">'"'</span> &gt;&gt; *( char_ -(<span class="hljs-built_in">char_</span>(<span class="hljs-string">'"'</span>) | <span class="hljs-string">','</span>) | COMMA | DDQUOTE)  &gt;&gt; <span class="hljs-string">'"'</span>];
        non_escaped = lexeme[       *( char_ -(<span class="hljs-built_in">char_</span>(<span class="hljs-string">'"'</span>) | <span class="hljs-string">','</span>)                  )        ];
        DDQUOTE     = <span class="hljs-built_in">lit</span>(<span class="hljs-string">"\"\""</span>)       [_val = <span class="hljs-string">'"'</span>];
        COMMA       = <span class="hljs-built_in">lit</span>(<span class="hljs-string">","</span>)          [_val = <span class="hljs-string">','</span>];
    }

};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    std::cout &lt;&lt; <span class="hljs-string">"Enter CSV lines [empty] to quit\n"</span>;

    <span class="hljs-keyword">using</span> bascii::space;
    <span class="hljs-keyword">typedef</span> std::string::const_iterator iterator_type;
    <span class="hljs-keyword">typedef</span> csv_parser&lt;iterator_type&gt; csv_parser;

    csv_parser grammar;
    std::string str;
    <span class="hljs-type">int</span> fid;
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(std::cin, str))
    {
        fid = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">if</span> (str.<span class="hljs-built_in">empty</span>())
            <span class="hljs-keyword">break</span>;

        std::vector&lt;std::string&gt; csv;
        std::string::const_iterator it_beg = str.<span class="hljs-built_in">begin</span>();
        std::string::const_iterator it_end = str.<span class="hljs-built_in">end</span>();
        <span class="hljs-type">bool</span> r = <span class="hljs-built_in">phrase_parse</span>(it_beg, it_end, grammar, space, csv);

        <span class="hljs-keyword">if</span> (r &amp;&amp; it_beg == it_end)
        {
            std::cout &lt;&lt; <span class="hljs-string">"Parsing succeeded\n"</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; field: csv)
            {
                std::cout &lt;&lt; <span class="hljs-string">"field "</span> &lt;&lt; ++fid &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; field &lt;&lt; std::endl;
            }
        }
        <span class="hljs-keyword">else</span>
        {
            std::cout &lt;&lt; <span class="hljs-string">"Parsing failed\n"</span>;
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>Compile:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">make csvparser
</code></pre>

<p>Test (example stolen from <a href="https://en.wikipedia.org/wiki/Comma-separated_values#Example" rel="nofollow noreferrer">Wikipedia</a>):</p>

<pre class="lang-none s-code-block"><code>./csvparser
Enter CSV lines [empty] to quit

1999,Chevy,"Venture ""Extended Edition, Very Large""",,5000.00
Parsing succeeded
field 1: 1999
field 2: Chevy
field 3: Venture "Extended Edition, Very Large"
field 4: 
field 5: 5000.00

1999,Chevy,"Venture ""Extended Edition, Very Large""",,5000.00"
Parsing failed
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 25</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This solution detects these 4 cases</p>

<p>complete class is at</p>

<p><a href="https://github.com/pedro-vicente/csv-parser" rel="nofollow noreferrer">https://github.com/pedro-vicente/csv-parser</a></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-number">1</span>,field <span class="hljs-number">2</span>,field <span class="hljs-number">3</span>,
<span class="hljs-number">1</span>,field <span class="hljs-number">2</span>,<span class="hljs-string">"field 3 quoted, with separator"</span>,
<span class="hljs-number">1</span>,field <span class="hljs-number">2</span>,<span class="hljs-string">"field 3
with newline"</span>,
<span class="hljs-number">1</span>,field <span class="hljs-number">2</span>,<span class="hljs-string">"field 3
with newline and separator,"</span>,
</code></pre>

<p>It reads the file character by character, and reads 1 row at a time to a vector (of strings), therefore suitable for very large files.</p>

<p>Usage is</p>

<p>Iterate until an empty row is returned (end of file). A row is a vector where each entry is a CSV column.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">read_csv_t</span> csv;
csv.<span class="hljs-built_in">open</span>(<span class="hljs-string">"../test.csv"</span>);
std::vector&lt;std::string&gt; row;
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)
{
  row = csv.<span class="hljs-built_in">read_row</span>();
  <span class="hljs-keyword">if</span> (row.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)
  {
    <span class="hljs-keyword">break</span>;
  }
}
</code></pre>

<p>the class declaration</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">read_csv_t</span>
{
<span class="hljs-keyword">public</span>:
  <span class="hljs-built_in">read_csv_t</span>();
  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;file_name)</span></span>;
  <span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">read_row</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:
  std::ifstream m_ifs;
};
</code></pre>

<p>the implementation</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">read_csv_t::read_row</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-type">bool</span> quote_mode = <span class="hljs-literal">false</span>;
  std::vector&lt;std::string&gt; row;
  std::string column;
  <span class="hljs-type">char</span> c;
  <span class="hljs-keyword">while</span> (m_ifs.<span class="hljs-built_in">get</span>(c))
  {
    <span class="hljs-keyword">switch</span> (c)
    {
      <span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////////////////////////////</span>
      <span class="hljs-comment">//separator ',' detected. </span>
      <span class="hljs-comment">//in quote mode add character to column</span>
      <span class="hljs-comment">//push column if not in quote mode</span>
      <span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////////////////////////////</span>

    <span class="hljs-keyword">case</span> <span class="hljs-string">','</span>:
      <span class="hljs-keyword">if</span> (quote_mode == <span class="hljs-literal">true</span>)
      {
        column += c;
      }
      <span class="hljs-keyword">else</span>
      {
        row.<span class="hljs-built_in">push_back</span>(column);
        column.<span class="hljs-built_in">clear</span>();
      }
      <span class="hljs-keyword">break</span>;

      <span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////////////////////////////</span>
      <span class="hljs-comment">//quote '"' detected. </span>
      <span class="hljs-comment">//toggle quote mode</span>
      <span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////////////////////////////</span>

    <span class="hljs-keyword">case</span> <span class="hljs-string">'"'</span>:
      quote_mode = !quote_mode;
      <span class="hljs-keyword">break</span>;

      <span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////////////////////////////</span>
      <span class="hljs-comment">//line end detected</span>
      <span class="hljs-comment">//in quote mode add character to column</span>
      <span class="hljs-comment">//return row if not in quote mode</span>
      <span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////////////////////////////</span>

    <span class="hljs-keyword">case</span> <span class="hljs-string">'\n'</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'\r'</span>:
      <span class="hljs-keyword">if</span> (quote_mode == <span class="hljs-literal">true</span>)
      {
        column += c;
      }
      <span class="hljs-keyword">else</span>
      {
        <span class="hljs-keyword">return</span> row;
      }
      <span class="hljs-keyword">break</span>;

      <span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////////////////////////////</span>
      <span class="hljs-comment">//default, add character to column</span>
      <span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////////////////////////////</span>

    <span class="hljs-keyword">default</span>:
      column += c;
      <span class="hljs-keyword">break</span>;
    }
  }

  <span class="hljs-comment">//return empty vector if end of file detected </span>
  m_ifs.<span class="hljs-built_in">close</span>();
  std::vector&lt;std::string&gt; v;
  <span class="hljs-keyword">return</span> v;
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 26</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong><em>Parsing CSV file lines with Stream</em></strong></p>

<p>I wrote a small example of parsing CSV file lines, it can be developed with for and while loops if desired:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{


<span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">"Infile.csv"</span>)</span></span>;
<span class="hljs-function">ofstream <span class="hljs-title">fout</span><span class="hljs-params">(<span class="hljs-string">"OutFile.csv"</span>)</span></span>;
string strline, strremain, strCol1 , strout;

string delimeter =<span class="hljs-string">";"</span>;

<span class="hljs-type">int</span> d1;
</code></pre>

<p>to continue until the end of the file:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span> (!fin.<span class="hljs-built_in">eof</span>()){ 
</code></pre>

<p>get first line from InFile :</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">    <span class="hljs-built_in">getline</span>(fin,strline,<span class="hljs-string">'\n'</span>);      
</code></pre>

<p>find delimeter position in line:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">    d1 = strline.<span class="hljs-built_in">find</span>(<span class="hljs-string">';'</span>);
</code></pre>

<p>and parse first column:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">    strCol1 = strline.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,d1); <span class="hljs-comment">// parse first Column</span>
    d1++;
    strremain = strline.<span class="hljs-built_in">substr</span>(d1); <span class="hljs-comment">// remaining line</span>
</code></pre>

<p>create output line in CSV format:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">    strout.<span class="hljs-built_in">append</span>(strCol1);
    strout.<span class="hljs-built_in">append</span>(delimeter);
</code></pre>

<p>write line to Out File:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">    fout &lt;&lt; strout &lt;&lt; endl; <span class="hljs-comment">//out file line</span>

} 

fin.<span class="hljs-built_in">close</span>();
fout.<span class="hljs-built_in">close</span>();

<span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);
}
</code></pre>

<p>This code is compiled and running. Good luck!</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 27</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You could also take a look at capabilities of <code>Qt</code> library.</p>

<p>It has regular expressions support and QString class has nice methods, e.g. <code>split()</code> returning QStringList, list of strings obtained by splitting the original string with a provided delimiter. Should suffice for csv file.. </p>

<p>To get a column with a given header name I use following: <a href="https://stackoverflow.com/questions/970330/c-inheritance-qt-problem-qstring/1011601#1011601">c++ inheritance Qt problem qstring</a></p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 28</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you don't want to deal with including boost in your project (it is considerably large if all you are going to use it for is CSV parsing...)</p>

<p>I have had luck with the CSV parsing here:</p>

<p><a href="http://www.zedwood.com/article/112/cpp-csv-parser" rel="nofollow">http://www.zedwood.com/article/112/cpp-csv-parser</a></p>

<p>It handles quoted fields - but does not handle inline \n characters (which is probably fine for most uses).</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 29</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>For what it is worth, here is my implementation. It deals with wstring input, but could be adjusted to string easily. It does not handle newline in fields (as my application does not either, but adding its support isn't too difficult) and it does not comply with "\r\n" end of line as per RFC (assuming you use std::getline), but it does handle whitespace trimming and double-quotes correctly (hopefully).</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-comment">// trim whitespaces around field or double-quotes, remove double-quotes and replace escaped double-quotes (double double-quotes)</span>
<span class="hljs-function">wstring <span class="hljs-title">trimquote</span><span class="hljs-params">(<span class="hljs-type">const</span> wstring&amp; str, <span class="hljs-type">const</span> wstring&amp; whitespace, <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> quotChar)</span>
</span>{
    wstring ws;
    wstring::size_type strBegin = str.<span class="hljs-built_in">find_first_not_of</span>(whitespace);
    <span class="hljs-keyword">if</span> (strBegin == wstring::npos)
        <span class="hljs-keyword">return</span> <span class="hljs-string">L""</span>;

    wstring::size_type strEnd = str.<span class="hljs-built_in">find_last_not_of</span>(whitespace);
    wstring::size_type strRange = strEnd - strBegin + <span class="hljs-number">1</span>;

    <span class="hljs-keyword">if</span>((str[strBegin] == quotChar) &amp;&amp; (str[strEnd] == quotChar))
    {
        ws = str.<span class="hljs-built_in">substr</span>(strBegin+<span class="hljs-number">1</span>, strRange<span class="hljs-number">-2</span>);
        strBegin = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>((strEnd = ws.<span class="hljs-built_in">find</span>(quotChar, strBegin)) != wstring::npos)
        {
            ws.<span class="hljs-built_in">erase</span>(strEnd, <span class="hljs-number">1</span>);
            strBegin = strEnd+<span class="hljs-number">1</span>;
        }

    }
    <span class="hljs-keyword">else</span>
        ws = str.<span class="hljs-built_in">substr</span>(strBegin, strRange);
    <span class="hljs-keyword">return</span> ws;
}

<span class="hljs-function">pair&lt;<span class="hljs-type">unsigned</span>, <span class="hljs-type">unsigned</span>&gt; <span class="hljs-title">nextCSVQuotePair</span><span class="hljs-params">(<span class="hljs-type">const</span> wstring&amp; line, <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> quotChar, <span class="hljs-type">unsigned</span> ofs = <span class="hljs-number">0</span>)</span>
</span>{
    pair&lt;<span class="hljs-type">unsigned</span>, <span class="hljs-type">unsigned</span>&gt; r;
    r.first = line.<span class="hljs-built_in">find</span>(quotChar, ofs);
    r.second = wstring::npos;
    <span class="hljs-keyword">if</span>(r.first != wstring::npos)
    {
        r.second = r.first;
        <span class="hljs-keyword">while</span>(((r.second = line.<span class="hljs-built_in">find</span>(quotChar, r.second+<span class="hljs-number">1</span>)) != wstring::npos)
            &amp;&amp; (line[r.second+<span class="hljs-number">1</span>] == quotChar)) <span class="hljs-comment">// WARNING: assumes null-terminated string such that line[r.second+1] always exist</span>
            r.second++;

    }
    <span class="hljs-keyword">return</span> r;
}

<span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-title">parseLine</span><span class="hljs-params">(vector&lt;wstring&gt;&amp; fields, <span class="hljs-type">const</span> wstring&amp; line)</span>
</span>{
    <span class="hljs-type">unsigned</span> ofs, ofs0, np;
    <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> delim = <span class="hljs-string">L','</span>;
    <span class="hljs-type">const</span> wstring whitespace = <span class="hljs-string">L" \t\xa0\x3000\x2000\x2001\x2002\x2003\x2004\x2005\x2006\x2007\x2008\x2009\x200a\x202f\x205f"</span>;
    <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> quotChar = <span class="hljs-string">L'\"'</span>;
    pair&lt;<span class="hljs-type">unsigned</span>, <span class="hljs-type">unsigned</span>&gt; quot;

    fields.<span class="hljs-built_in">clear</span>();

    ofs = ofs0 = <span class="hljs-number">0</span>;
    quot = <span class="hljs-built_in">nextCSVQuotePair</span>(line, quotChar);
    <span class="hljs-keyword">while</span>((np = line.<span class="hljs-built_in">find</span>(delim, ofs)) != wstring::npos)
    {
        <span class="hljs-keyword">if</span>((np &gt; quot.first) &amp;&amp; (np &lt; quot.second))
        { <span class="hljs-comment">// skip delimiter inside quoted field</span>
            ofs = quot.second+<span class="hljs-number">1</span>;
            quot = <span class="hljs-built_in">nextCSVQuotePair</span>(line, quotChar, ofs);
            <span class="hljs-keyword">continue</span>;
        }
        fields.<span class="hljs-built_in">push_back</span>( <span class="hljs-built_in">trimquote</span>(line.<span class="hljs-built_in">substr</span>(ofs0, np-ofs0), whitespace, quotChar) );
        ofs = ofs0 = np+<span class="hljs-number">1</span>;
    }
    fields.<span class="hljs-built_in">push_back</span>( <span class="hljs-built_in">trimquote</span>(line.<span class="hljs-built_in">substr</span>(ofs0), whitespace, quotChar) );

    <span class="hljs-keyword">return</span> fields.<span class="hljs-built_in">size</span>();
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 30</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is a ready-to use function if all you need is to load a data file of doubles (no integers, no text).</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-comment">/**
 * Parse a CSV data file and fill the 2d STL vector "data".
 * Limits: only "pure datas" of doubles, not encapsulated by " and without \n inside.
 * Further no formatting in the data (e.g. scientific notation)
 * It however handles both dots and commas as decimal separators and removes thousand separator.
 * 
 * returnCodes[0]: file access 0-&gt; ok 1-&gt; not able to read; 2-&gt; decimal separator equal to comma separator
 * returnCodes[1]: number of records
 * returnCodes[2]: number of fields. -1 If rows have different field size
 * 
 */</span>
<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt;
<span class="hljs-title">readCsvData</span> <span class="hljs-params">(vector &lt;vector &lt;<span class="hljs-type">double</span>&gt;&gt;&amp; data, <span class="hljs-type">const</span> string&amp; filename, <span class="hljs-type">const</span> string&amp; delimiter, <span class="hljs-type">const</span> string&amp; decseparator)</span></span>{

 <span class="hljs-type">int</span> vv[<span class="hljs-number">3</span>] = { <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span> };
 <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">returnCodes</span><span class="hljs-params">(&amp;vv[<span class="hljs-number">0</span>], &amp;vv[<span class="hljs-number">0</span>]+<span class="hljs-number">3</span>)</span></span>;

 string rowstring, stringtoken;
 <span class="hljs-type">double</span> doubletoken;
 <span class="hljs-type">int</span> rowcount=<span class="hljs-number">0</span>;
 <span class="hljs-type">int</span> fieldcount=<span class="hljs-number">0</span>;
 data.<span class="hljs-built_in">clear</span>();

 <span class="hljs-function">ifstream <span class="hljs-title">iFile</span><span class="hljs-params">(filename, ios_base::in)</span></span>;
 <span class="hljs-keyword">if</span> (!iFile.<span class="hljs-built_in">is_open</span>()){
   returnCodes[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
   <span class="hljs-keyword">return</span> returnCodes;
 }
 <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(iFile, rowstring)) {
    <span class="hljs-keyword">if</span> (rowstring==<span class="hljs-string">""</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// empty line</span>
    rowcount ++; <span class="hljs-comment">//let's start with 1</span>
    <span class="hljs-keyword">if</span>(delimiter == decseparator){
      returnCodes[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>;
      <span class="hljs-keyword">return</span> returnCodes;
    }
    <span class="hljs-keyword">if</span>(decseparator != <span class="hljs-string">"."</span>){
     <span class="hljs-comment">// remove dots (used as thousand separators)</span>
     string::iterator end_pos = <span class="hljs-built_in">remove</span>(rowstring.<span class="hljs-built_in">begin</span>(), rowstring.<span class="hljs-built_in">end</span>(), <span class="hljs-string">'.'</span>);
     rowstring.<span class="hljs-built_in">erase</span>(end_pos, rowstring.<span class="hljs-built_in">end</span>());
     <span class="hljs-comment">// replace decimal separator with dots.</span>
     <span class="hljs-built_in">replace</span>(rowstring.<span class="hljs-built_in">begin</span>(), rowstring.<span class="hljs-built_in">end</span>(),decseparator.<span class="hljs-built_in">c_str</span>()[<span class="hljs-number">0</span>], <span class="hljs-string">'.'</span>); 
    } <span class="hljs-keyword">else</span> {
     <span class="hljs-comment">// remove commas (used as thousand separators)</span>
     string::iterator end_pos = <span class="hljs-built_in">remove</span>(rowstring.<span class="hljs-built_in">begin</span>(), rowstring.<span class="hljs-built_in">end</span>(), <span class="hljs-string">','</span>);
     rowstring.<span class="hljs-built_in">erase</span>(end_pos, rowstring.<span class="hljs-built_in">end</span>());
    }
    <span class="hljs-comment">// tokenize..</span>
    vector&lt;<span class="hljs-type">double</span>&gt; tokens;
    <span class="hljs-comment">// Skip delimiters at beginning.</span>
    string::size_type lastPos = rowstring.<span class="hljs-built_in">find_first_not_of</span>(delimiter, <span class="hljs-number">0</span>);
    <span class="hljs-comment">// Find first "non-delimiter".</span>
    string::size_type pos     = rowstring.<span class="hljs-built_in">find_first_of</span>(delimiter, lastPos);
    <span class="hljs-keyword">while</span> (string::npos != pos || string::npos != lastPos){
        <span class="hljs-comment">// Found a token, convert it to double add it to the vector.</span>
        stringtoken = rowstring.<span class="hljs-built_in">substr</span>(lastPos, pos - lastPos);
        <span class="hljs-keyword">if</span> (stringtoken == <span class="hljs-string">""</span>) {
      tokens.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0.0</span>);
    } <span class="hljs-keyword">else</span> {
          istringstream <span class="hljs-built_in">totalSString</span>(stringtoken);
      totalSString &gt;&gt; doubletoken;
      tokens.<span class="hljs-built_in">push_back</span>(doubletoken);
    }     
        <span class="hljs-comment">// Skip delimiters.  Note the "not_of"</span>
        lastPos = rowstring.<span class="hljs-built_in">find_first_not_of</span>(delimiter, pos);
        <span class="hljs-comment">// Find next "non-delimiter"</span>
        pos = rowstring.<span class="hljs-built_in">find_first_of</span>(delimiter, lastPos);
    }
    <span class="hljs-keyword">if</span>(rowcount == <span class="hljs-number">1</span>){
      fieldcount = tokens.<span class="hljs-built_in">size</span>();
      returnCodes[<span class="hljs-number">2</span>] = tokens.<span class="hljs-built_in">size</span>();
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> ( tokens.<span class="hljs-built_in">size</span>() != fieldcount){
    returnCodes[<span class="hljs-number">2</span>] = <span class="hljs-number">-1</span>;
      }
    }
    data.<span class="hljs-built_in">push_back</span>(tokens);
 }
 iFile.<span class="hljs-built_in">close</span>();
 returnCodes[<span class="hljs-number">1</span>] = rowcount;
 <span class="hljs-keyword">return</span> returnCodes;
}
</code></pre>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;If you don\u0026apos;t care about escaping comma and newline,\u0026lt;br\u0026gt;\nAND you can\u0026apos;t embed comma and newline in quotes (If you can\u0026apos;t escape then...)\u0026lt;br\u0026gt;\nthen its only about three lines of code (OK 14 -\u0026amp;gt;But its only 15 to read the whole file).\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::vector\u0026amp;lt;std::string\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;getNextLineAndSplitIntoTokens\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::istream\u0026amp;amp; str)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    std::vector\u0026amp;lt;std::string\u0026amp;gt;   result;\n    std::string                line;\n    std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(str,line);\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::stringstream          \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;lineStream\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(line)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    std::string                cell;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(lineStream,cell, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;))\n    {\n        result.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(cell);\n    }\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This checks for a trailing comma with no data after it.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!lineStream \u0026amp;amp;\u0026amp;amp; cell.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;empty\u0026lt;/span\u0026gt;())\n    {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// If there was a trailing comma then add an empty element.\u0026lt;/span\u0026gt;\n        result.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; result;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;I would just create a class representing a row.\u0026lt;br\u0026gt;\nThen stream into that object:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iterator\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;fstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;sstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;CSVRow\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n        std::string_view \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;[](std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; index) \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string_view\u0026lt;/span\u0026gt;(\u0026amp;amp;m_line[m_data[index] + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;], m_data[index + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] -  (m_data[index] + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;));\n        }\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\n        \u0026lt;/span\u0026gt;{\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; m_data.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;() - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n        }\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;readNextRow\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::istream\u0026amp;amp; str)\u0026lt;/span\u0026gt;\n        \u0026lt;/span\u0026gt;{\n            std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(str, m_line);\n\n            m_data.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n            m_data.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;emplace_back\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;);\n            std::string::size_type pos = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;((pos = m_line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;, pos)) != std::string::npos)\n            {\n                m_data.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;emplace_back\u0026lt;/span\u0026gt;(pos);\n                ++pos;\n            }\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This checks for a trailing comma with no data after it.\u0026lt;/span\u0026gt;\n            pos   = m_line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;();\n            m_data.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;emplace_back\u0026lt;/span\u0026gt;(pos);\n        }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n        std::string         m_line;\n        std::vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;    m_data;\n};\n\nstd::istream\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;gt;(std::istream\u0026amp;amp; str, CSVRow\u0026amp;amp; data)\n{\n    data.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;readNextRow\u0026lt;/span\u0026gt;(str);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; str;\n}   \n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::ifstream       \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;file\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;plop.csv\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n    CSVRow              row;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(file \u0026amp;gt;\u0026amp;gt; row)\n    {\n        std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;4th Element(\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; row[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;)\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;But with a little work we could technically create an iterator:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;CSVIterator\u0026lt;/span\u0026gt;\n{   \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; std::input_iterator_tag     iterator_category;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; CSVRow                      value_type;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt;                 difference_type;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; CSVRow*                     pointer;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; CSVRow\u0026amp;amp;                     reference;\n\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CSVIterator\u0026lt;/span\u0026gt;(std::istream\u0026amp;amp; str)  :\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;m_str\u0026lt;/span\u0026gt;(str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;good\u0026lt;/span\u0026gt;()?\u0026amp;amp;str:\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;) { ++(*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;); }\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CSVIterator\u0026lt;/span\u0026gt;()                   :\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;m_str\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;) {}\n\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Pre Increment\u0026lt;/span\u0026gt;\n        CSVIterator\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;++()               {\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (m_str) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!((*m_str) \u0026amp;gt;\u0026amp;gt; m_row)){m_str = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;;}}\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;}\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Post increment\u0026lt;/span\u0026gt;\n        CSVIterator \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;++(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)             {\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;CSVIterator    \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;tmp\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;++(*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;);\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; tmp;}\n        CSVRow \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;*()   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;       {\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; m_row;}\n        CSVRow \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;* \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;-\u0026amp;gt;()  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;       {\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026amp;amp;m_row;}\n\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;==(CSVIterator \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp; rhs) {\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; ((\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; == \u0026amp;amp;rhs) || ((\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;-\u0026amp;gt;m_str == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;) \u0026amp;amp;\u0026amp;amp; (rhs.m_str == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;)));}\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;!=(CSVIterator \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp; rhs) {\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; !((*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;) == rhs);}\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n        std::istream*       m_str;\n        CSVRow              m_row;\n};\n\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::ifstream       \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;file\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;plop.csv\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(CSVIterator \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;loop\u0026lt;/span\u0026gt;(file); loop != \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CSVIterator\u0026lt;/span\u0026gt;(); ++loop)\n    {\n        std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;4th Element(\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; (*loop)[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;)\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now that we are in 2020 lets add a CSVRange object:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;CSVRange\u0026lt;/span\u0026gt;\n{\n    std::istream\u0026amp;amp;   stream;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CSVRange\u0026lt;/span\u0026gt;(std::istream\u0026amp;amp; str)\n            : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stream\u0026lt;/span\u0026gt;(str)\n        {}\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;CSVIterator \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; CSVIterator{stream};}\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;CSVIterator \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; CSVIterator{};}\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::ifstream       \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;file\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;plop.csv\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt;\u0026amp;amp; row: \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CSVRange\u0026lt;/span\u0026gt;(file))\n    {\n        std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;4th Element(\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; row[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;)\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;My version is not using anything but the standard C++11 library. It copes well with Excel CSV quotation:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;spam eggs,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;foo,bar\u0026quot;\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;fizz buzz\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1.23\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4.567\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-8.00E+09\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The code is written as a finite-state machine and is consuming one character at a time. I think it\u0026apos;s easier to reason about.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;istream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;CSVState\u0026lt;/span\u0026gt; {\n    UnquotedField,\n    QuotedField,\n    QuotedQuote\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::vector\u0026amp;lt;std::string\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;readCSVRow\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string \u0026amp;amp;row)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    CSVState state = CSVState::UnquotedField;\n    std::vector\u0026amp;lt;std::string\u0026amp;gt; fields {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;};\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// index of the current field\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; c : row) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;switch\u0026lt;/span\u0026gt; (state) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; CSVState::UnquotedField:\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;switch\u0026lt;/span\u0026gt; (c) {\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// end of field\u0026lt;/span\u0026gt;\n                              fields.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;); i++;\n                              \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;: state = CSVState::QuotedField;\n                              \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;:  fields[i].\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(c);\n                              \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;; }\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; CSVState::QuotedField:\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;switch\u0026lt;/span\u0026gt; (c) {\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;: state = CSVState::QuotedQuote;\n                              \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;:  fields[i].\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(c);\n                              \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;; }\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; CSVState::QuotedQuote:\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;switch\u0026lt;/span\u0026gt; (c) {\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// , after closing quote\u0026lt;/span\u0026gt;\n                              fields.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;); i++;\n                              state = CSVState::UnquotedField;\n                              \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// \u0026quot;\u0026quot; -\u0026amp;gt; \u0026quot;\u0026lt;/span\u0026gt;\n                              fields[i].\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;);\n                              state = CSVState::QuotedField;\n                              \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;:  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// end of quote\u0026lt;/span\u0026gt;\n                              state = CSVState::UnquotedField;\n                              \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;; }\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n        }\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; fields;\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Read CSV file, Excel dialect. Accept \u0026quot;quoted fields \u0026quot;\u0026quot;with quotes\u0026quot;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\nstd::vector\u0026amp;lt;std::vector\u0026amp;lt;std::string\u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;readCSV\u0026lt;/span\u0026gt;(std::istream \u0026amp;amp;in) {\n    std::vector\u0026amp;lt;std::vector\u0026amp;lt;std::string\u0026amp;gt;\u0026amp;gt; table;\n    std::string row;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (!in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;()) {\n        std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(in, row);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;bad\u0026lt;/span\u0026gt;() || in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;()) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; fields = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;readCSVRow\u0026lt;/span\u0026gt;(row);\n        table.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(fields);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; table;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Solution using Boost Tokenizer:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;std::vector\u0026amp;lt;std::string\u0026amp;gt; vec;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; boost;\ntokenizer\u0026amp;lt;escaped_list_separator\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;tk\u0026lt;/span\u0026gt;(\n   line, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;escaped_list_separator\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\\\\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;));\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (tokenizer\u0026amp;lt;escaped_list_separator\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026amp;gt;::iterator \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;i\u0026lt;/span\u0026gt;(tk.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;());\n   i!=tk.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;();++i) \n{\n   vec.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(*i);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The \u0026lt;a href=\u0026quot;http://www.partow.net/programming/strtk/index.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;C++ String Toolkit Library (StrTk)\u0026lt;/a\u0026gt; has a token grid class that allows you to load data either from \u0026lt;b\u0026gt;text files, strings or char buffers\u0026lt;/b\u0026gt;, and to parse/process them in a row-column fashion.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can specify the row delimiters and column delimiters or just use the defaults.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   std::string data = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1,2,3,4,5\\n\u0026quot;\u0026lt;/span\u0026gt;\n                      \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0,2,4,6,8\\n\u0026quot;\u0026lt;/span\u0026gt;\n                      \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1,3,5,7,9\\n\u0026quot;\u0026lt;/span\u0026gt;;\n\n   \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;strtk::token_grid \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;grid\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(data,data.size(),\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;,\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; grid.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;row_count\u0026lt;/span\u0026gt;(); ++i)\n   {\n      strtk::token_grid::row_type r = grid.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;row\u0026lt;/span\u0026gt;(i);\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; j = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; j \u0026amp;lt; r.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;(); ++j)\n      {\n         std::cout \u0026amp;lt;\u0026amp;lt; r.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;(j) \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\t\u0026quot;\u0026lt;/span\u0026gt;;\n      }\n      std::cout \u0026amp;lt;\u0026amp;lt; std::endl;\n   }\n   std::cout \u0026amp;lt;\u0026amp;lt; std::endl;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;More examples can be found \u0026lt;a href=\u0026quot;http://www.partow.net/programming/strtk/index.html#tutorial\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Here\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;You can use Boost Tokenizer with escaped_list_separator.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;escaped_list_separator\u0026lt;/strong\u0026gt; parses a superset of the csv. \u0026lt;a href=\u0026quot;https://www.boost.org/doc/libs/release/libs/tokenizer/doc/escaped_list_separator.htm\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Boost::tokenizer\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;This only uses Boost tokenizer header files, no linking to boost libraries required.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Here is an example, (see \u0026lt;a href=\u0026quot;http://mybyteofcode.blogspot.com/2010/02/parse-csv-file-with-boost-tokenizer-in.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Parse CSV File With Boost Tokenizer In C++\u0026lt;/a\u0026gt; for details or \u0026lt;code\u0026gt;Boost::tokenizer\u0026lt;/code\u0026gt; ):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// cout, endl\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;fstream\u0026amp;gt;\u0026lt;/span\u0026gt;      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// fstream\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;algorithm\u0026amp;gt;\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// copy\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iterator\u0026amp;gt;\u0026lt;/span\u0026gt;     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ostream_operator\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;boost/tokenizer.hpp\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; boost;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;data.csv\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;ifstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(data.c_str())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;is_open\u0026lt;/span\u0026gt;()) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; tokenizer\u0026amp;lt; escaped_list_separator\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026amp;gt; Tokenizer;\n    vector\u0026amp;lt; string \u0026amp;gt; vec;\n    string line;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(in,line))\n    {\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;Tokenizer \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;tok\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(line)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n        vec.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assign\u0026lt;/span\u0026gt;(tok.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(),tok.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;());\n\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// vector now contains strings from one row, output to cout here\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;copy\u0026lt;/span\u0026gt;(vec.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), vec.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ostream_iterator\u0026lt;/span\u0026gt;\u0026amp;lt;string\u0026amp;gt;(cout, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;|\u0026quot;\u0026lt;/span\u0026gt;));\n\n        cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n----------------------\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It is not overkill to use Spirit for parsing CSVs. Spirit is well suited for micro-parsing tasks. For instance, with Spirit 2.1, it is as easy as:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; r = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;phrase_parse\u0026lt;/span\u0026gt;(first, last,\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  Begin grammar\u0026lt;/span\u0026gt;\n    (\n        double_ % \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;\n    )\n    ,\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  End grammar\u0026lt;/span\u0026gt;\n\n    space, v);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The vector, v, gets stuffed with the values. \u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/1_41_0/libs/spirit/doc/html/spirit/qi/tutorials.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;There is a series of tutorials\u0026lt;/a\u0026gt; touching on this in the new Spirit 2.1 docs that\u0026apos;s just been released with Boost 1.41.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The tutorial progresses from simple to complex. The CSV parsers are presented somewhere in the middle and touches on various techniques in using Spirit. The generated code is as tight as hand written code. Check out the assembler generated!\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you \u0026lt;strong\u0026gt;DO\u0026lt;/strong\u0026gt; care about parsing CSV correctly, this will do it...relatively slowly as it works one char at a time.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ParseCSV\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; string\u0026amp;amp; csvSource, vector\u0026amp;lt;vector\u0026amp;lt;string\u0026amp;gt; \u0026amp;gt;\u0026amp;amp; lines)\u0026lt;/span\u0026gt;\n    \u0026lt;/span\u0026gt;{\n       \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;inQuote\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n       \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;newLine\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n       string field;\n       lines.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n       vector\u0026amp;lt;string\u0026amp;gt; line;\n\n       string::const_iterator aChar = csvSource.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;();\n       \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (aChar != csvSource.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;())\n       {\n          \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;switch\u0026lt;/span\u0026gt; (*aChar)\n          {\n          \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;:\n             newLine = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n             inQuote = !inQuote;\n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n\n          \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;:\n             newLine = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (inQuote == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;)\n             {\n                field += *aChar;\n             }\n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n             {\n                line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(field);\n                field.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n             }\n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n\n          \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;:\n          \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\r\u0026apos;\u0026lt;/span\u0026gt;:\n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (inQuote == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;)\n             {\n                field += *aChar;\n             }\n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n             {\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (newLine == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;)\n                {\n                   line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(field);\n                   lines.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(line);\n                   field.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n                   line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n                   newLine = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\n                }\n             }\n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n\n          \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;:\n             newLine = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n             field.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(*aChar);\n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n          }\n\n          aChar++;\n       }\n\n       \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (field.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;())\n          line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(field);\n\n       \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;())\n          lines.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(line);\n    }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;When using the Boost Tokenizer escaped_list_separator for CSV files, then one should be aware of the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;It requires an escape-character (default back-slash - \\)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It requires a splitter/seperator-character (default comma - ,)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It requires an quote-character (default quote - \u0026quot;)\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;The CSV format specified by wiki states that data fields can contain separators in quotes (supported):\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;1997,Ford,E350,\u0026quot;Super, luxurious truck\u0026quot;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;The CSV format specified by wiki states that single quotes should be handled with double-quotes (escaped_list_separator will strip away all quote characters):\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;1997,Ford,E350,\u0026quot;Super \u0026quot;\u0026quot;luxurious\u0026quot;\u0026quot; truck\u0026quot;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;The CSV format doesn\u0026apos;t specify that any back-slash characters should be stripped away (escaped_list_separator will strip away all escape characters).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A possible work-around to fix the default behavior of the boost escaped_list_separator:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;First replace all back-slash characters (\\) with two back-slash characters (\\\\) so they are not stripped away.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Secondly replace all double-quotes (\u0026quot;\u0026quot;) with a single back-slash character and a quote (\\\u0026quot;)\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;This work-around has the side-effect that empty data-fields that are represented by a double-quote, will be transformed into a single-quote-token. When iterating through the tokens, then one must check if the token is a single-quote, and treat it like an empty string.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Not pretty but it works, as long there are not newlines within the quotes.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/AriaFallah/csv-parser\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;I wrote a header-only, C++11 CSV parser\u0026lt;/a\u0026gt;. It\u0026apos;s well tested, fast, supports the entire CSV spec (quoted fields, delimiter/terminator in quotes, quote escaping, etc.), and is configurable to account for the CSVs that don\u0026apos;t adhere to the specification.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Configuration is done through a fluent interface:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// constructor accepts any input stream\u0026lt;/span\u0026gt;\nCsvParser parser = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CsvParser\u0026lt;/span\u0026gt;(std::cin)\n  .\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;delimiter\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;;\u0026apos;\u0026lt;/span\u0026gt;)    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// delimited by ; instead of ,\u0026lt;/span\u0026gt;\n  .\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;quote\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\\u0026apos;\u0026apos;\u0026lt;/span\u0026gt;)       \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// quoted fields use \u0026apos; instead of \u0026quot;\u0026lt;/span\u0026gt;\n  .\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;terminator\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// terminated by \\0 instead of by \\r\\n, \\n, or \\r\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Parsing is just a range based for loop:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;../parser.hpp\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; aria::csv;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::ifstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;some_file.csv\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;CsvParser \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;parser\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(f)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt;\u0026amp;amp; row : parser) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt;\u0026amp;amp; field : row) {\n      std::cout \u0026amp;lt;\u0026amp;lt; field \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; | \u0026quot;\u0026lt;/span\u0026gt;;\n    }\n    std::cout \u0026amp;lt;\u0026amp;lt; std::endl;\n  }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As all the CSV questions seem to get redirected here, I thought I\u0026apos;d post my answer here.  This answer does not directly address the asker\u0026apos;s question. I wanted to be able to read in a stream that is known to be in CSV format, and also the types of each field was already known. Of course, the method below could be used to treat every field to be a string type.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As an example of how I wanted to be able to use a CSV input stream, consider the following input (taken from \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Comma-separated_values\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;wikipedia\u0026apos;s page on CSV\u0026lt;/a\u0026gt;):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; input[] =\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Year,Make,Model,Description,Price\\n\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1997,Ford,E350,\\\u0026quot;ac, abs, moon\\\u0026quot;,3000.00\\n\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1999,Chevy,\\\u0026quot;Venture \\\u0026quot;\\\u0026quot;Extended Edition\\\u0026quot;\\\u0026quot;\\\u0026quot;,\\\u0026quot;\\\u0026quot;,4900.00\\n\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1999,Chevy,\\\u0026quot;Venture \\\u0026quot;\\\u0026quot;Extended Edition, Very Large\\\u0026quot;\\\u0026quot;\\\u0026quot;,\\\u0026quot;\\\u0026quot;,5000.00\\n\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1996,Jeep,Grand Cherokee,\\\u0026quot;MUST SELL!\\n\\\nair, moon roof, loaded\\\u0026quot;,4799.00\\n\u0026quot;\u0026lt;/span\u0026gt;\n;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Then, I wanted to be able to read in the data like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::istringstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ss\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(input)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\nstd::string title[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;];\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; year;\nstd::string make, model, desc;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt; price;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;csv_istream\u0026lt;/span\u0026gt;(ss)\n    \u0026amp;gt;\u0026amp;gt; title[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] \u0026amp;gt;\u0026amp;gt; title[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] \u0026amp;gt;\u0026amp;gt; title[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;] \u0026amp;gt;\u0026amp;gt; title[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] \u0026amp;gt;\u0026amp;gt; title[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;];\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;csv_istream\u0026lt;/span\u0026gt;(ss)\n       \u0026amp;gt;\u0026amp;gt; year \u0026amp;gt;\u0026amp;gt; make \u0026amp;gt;\u0026amp;gt; model \u0026amp;gt;\u0026amp;gt; desc \u0026amp;gt;\u0026amp;gt; price) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//...do something with the record...\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This was the solution I ended up with.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;csv_istream\u0026lt;/span\u0026gt; {\n    std::istream \u0026amp;amp;is_;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;csv_istream\u0026lt;/span\u0026gt; (std::istream \u0026amp;amp;is) : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;is_\u0026lt;/span\u0026gt;(is) {}\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;scan_ws\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;good\u0026lt;/span\u0026gt;()) {\n            \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; c = is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;peek\u0026lt;/span\u0026gt;();\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (c != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos; \u0026apos;\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; c != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\t\u0026apos;\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n            is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;();\n        }\n    }\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;scan\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::string *s = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n        std::string ws;\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; c = is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;();\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;good\u0026lt;/span\u0026gt;()) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;do\u0026lt;/span\u0026gt; {\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (c == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt; || c == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (s) {\n                    ws += c;\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (c != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos; \u0026apos;\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; c != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\t\u0026apos;\u0026lt;/span\u0026gt;) {\n                        *s += ws;\n                        ws.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n                    }\n                }\n                c = is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;();\n            } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;good\u0026lt;/span\u0026gt;());\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;()) is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n        }\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;set_value\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::string in, T \u0026amp;amp;v)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n            std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;istringstream\u0026lt;/span\u0026gt;(in) \u0026amp;gt;\u0026amp;gt; v;\n        }\n    };\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;set_value\u0026lt;/span\u0026gt;\u0026amp;lt;T, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;\u0026amp;gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; SIGNED\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;convert\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::string in, T \u0026amp;amp;v)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (SIGNED) v = ::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strtoll\u0026lt;/span\u0026gt;(in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c_str\u0026lt;/span\u0026gt;(), \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; v = ::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strtoull\u0026lt;/span\u0026gt;(in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c_str\u0026lt;/span\u0026gt;(), \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n        }\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::string in, T \u0026amp;amp;v)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n            convert\u0026amp;lt;is_signed_int\u0026amp;lt;T\u0026amp;gt;::val\u0026amp;gt;(in, v);\n        }\n    };\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; csv_istream \u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026amp;gt;\u0026amp;gt; (T \u0026amp;amp;v) \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; {\n        std::string tmp;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;scan\u0026lt;/span\u0026gt;(\u0026amp;amp;tmp);\n        set_value\u0026amp;lt;T, is_int\u0026amp;lt;T\u0026amp;gt;::val\u0026amp;gt;()(tmp, v);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n    }\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; csv_istream \u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026amp;gt;\u0026amp;gt; (std::string \u0026amp;amp;v) \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; {\n        v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;scan_ws\u0026lt;/span\u0026gt;();\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;peek\u0026lt;/span\u0026gt;() != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;scan\u0026lt;/span\u0026gt;(\u0026amp;amp;v);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n            std::string tmp;\n            is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;();\n            std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(is_, tmp, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;);\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;peek\u0026lt;/span\u0026gt;() == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;) {\n                v += tmp;\n                v += is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;();\n                std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(is_, tmp, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;);\n            }\n            v += tmp;\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;scan\u0026lt;/span\u0026gt;();\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; csv_istream \u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026amp;gt;\u0026amp;gt; (T \u0026amp;amp;(*manip)(T \u0026amp;amp;)) \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; {\n        is_ \u0026amp;gt;\u0026amp;gt; manip;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n    }\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; !is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;(); }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;With the following helpers that may be simplified by the new integral traits templates in C++11:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_signed_int\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt; }; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_signed_int\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;short\u0026lt;/span\u0026gt;\u0026amp;gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;}; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_signed_int\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;}; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_signed_int\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt;\u0026amp;gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;}; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_signed_int\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt;\u0026amp;gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;}; };\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_unsigned_int\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt; }; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_unsigned_int\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;short\u0026lt;/span\u0026gt;\u0026amp;gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;}; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_unsigned_int\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;}; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_unsigned_int\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt;\u0026amp;gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;}; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_unsigned_int\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt;\u0026amp;gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;}; };\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_int\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = (is_signed_int\u0026amp;lt;T\u0026amp;gt;::val || is_unsigned_int\u0026amp;lt;T\u0026amp;gt;::val) };\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://tio.run/##rVZtT@NGEP7uXzG4UrDpFuXK0VNev/ToqRVUlaAnVQRFxt6EFc6u5d2YIi6/nc6sHbKOHTig5iWb3Zlnnnn1xln20zyOH38QMk6XCYehUNrkPFqMvc2eXm95hi@yNDK4Z@4zLqMFh4sx4PEyNiD0VIu55MlUSAMPwOVygR9FlMIIZlGqOawG@OugtOsO9Y3KzXgbAiX5dwLg33vUUyXn79WHF0BejOVSviearvZw/QXeFth2rLfEuB3pTeHeDfXuyNuAe4BPDSGoJ/li3O/TwbdvDTrVUUjWVoPHCjnWxVSUrVTBa5P0@@utDqIM7LYrGGzLhNAnewGtHlZWvlACUxtHcnqnIQghVlKvPaDn7kak3NI/nCuVBGHoHNJDDsfoIUlknN8G4aB@PoMghr0R7ONPpwPlemL2Q7hGXrdb0mSHGxek5LnFtvINXROYtAONBLpN8q7Mnd5Aupy3rBHd3c4mamtj4@EIvWL7lNFyPZHtHq41dNgCZSOu4ccRxIPWw2ei2Y5Gz4FFdAPQtHkYpzzKt5NXz8HzOzsCaoVbyqhZJXTI1YyiTssGIbcQ2tqQwbVS6VMzam6m2EhL7kTG1o/KeB4ZlVO518pISAYX0CmahVRrOBQtWyoQMoTxGIoGx8FOkk16QyROA2bs2Ntokktw/vuXP08@j0v6yK3guXkNdYpuiRFCgWmyakalKXpwGE/xSxAy6OLvVlo4vSocjeXzKqv/JdCVg8PWkTkOSLkIXxXy0oo7GjsbcpjAoJ2MS9ksso1JmkBBB7ccGrV8li@CDecwQOE67ZybZS7hwNyIqjFLR17k6rJqY100O6ea721zrhzZdor4OERKz1yetgRaOqEtLjsm@JMO7qdCcjLMwEaEjNYFnUlRcRtV3JoDrqC51mDwdLKDyqvo1Odcu0EbtNY22JXk1jL9vvRjqQYHi0iKLKR12CwAdIckrczL9fYEbifN5gawVtijKM4ikaKHqIJXEnp7LiIhSfjBqwjfRDm2dbY0l1cw8vx/sALZWXTL2ZlKeMo@cx3nIjNCSfZXLmI@kb7nf@j1PrHfVJ6wk6PjLpv4UcwgutYMFkrJic@Out3uYbe7Fu6xX294cY@CX7lEdhwm/sQ/@ddwmeAF7iQRZID2UNf@@9h7AwCDrzy/h9Mon3MX7LjO5hf2B@cZ@5JHMgHEzdUt5yh59vf5BZyfnJ7uTeTEi0ReugO5UjOGF8wITRG1T71ehYb3yubbBbQObESxsmodJ0zKL4@vBh4l4h4DXT9fUNTRIoUdEoz7wJuhUQMZxX3gObUVaB3aIsByKWG7V5v1B2f9s7M@ctYfkUbVsW24JTRxLCvylttP4kYLYkefllnoXmxjtTQwHILfJ@XRpU9fLA5tXvlbDW0lCb6StJaekSQCa1FLZrcscaxELd3dktaLStSuS1lMMN7kPW/1@B8\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot; title=\u0026quot;C++ (gcc)  Try It Online\u0026quot;\u0026gt;Try it online!\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You might want to look at my FOSS project \u0026lt;a href=\u0026quot;http://code.google.com/p/csvfix/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;CSVfix\u0026lt;/a\u0026gt; (\u0026lt;a href=\u0026quot;https://bitbucket.org/neilb/csvfix/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;em\u0026gt;updated link\u0026lt;/em\u0026gt;\u0026lt;/a\u0026gt;), which is a CSV stream editor written in C++. The CSV parser is no prize, but does the job and the whole package may do what you need without you writing any code.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;See \u0026lt;a href=\u0026quot;https://bitbucket.org/neilb/csvfix/src/default/alib/src/a_csv.cpp?fileviewer=file-view-default\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;alib/src/a_csv.cpp\u0026lt;/a\u0026gt; for the CSV parser, and \u0026lt;a href=\u0026quot;https://bitbucket.org/neilb/csvfix/src/default/csvfix/src/csved_ioman.cpp?fileviewer=file-view-default#csved_ioman.cpp-348\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;csvlib/src/csved_ioman.cpp\u0026lt;/a\u0026gt; (\u0026lt;code\u0026gt;IOManager::ReadCSV\u0026lt;/code\u0026gt;) for a usage example.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Another CSV I/O library can be found here:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://code.google.com/p/fast-cpp-csv-parser/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://code.google.com/p/fast-cpp-csv-parser/\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;csv.h\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;io::CSVReader\u0026amp;lt;3\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;ram.csv\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n  in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read_header\u0026lt;/span\u0026gt;(io::ignore_extra_column, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;vendor\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;size\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;speed\u0026quot;\u0026lt;/span\u0026gt;);\n  std::string vendor; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; size; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; speed;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read_row\u0026lt;/span\u0026gt;(vendor, size, speed)){\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// do stuff with the data\u0026lt;/span\u0026gt;\n  }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Another solution similar to \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/1120224/1749822\u0026quot;\u0026gt;Loki Astari\u0026apos;s answer\u0026lt;/a\u0026gt;, in C++11. Rows here are \u0026lt;code\u0026gt;std::tuple\u0026lt;/code\u0026gt;s of a given type. The code scans one line, then scans until each delimiter, and then converts and dumps the value directly into the tuple (with a bit of template code).\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; row : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;csv\u0026lt;/span\u0026gt;\u0026amp;lt;std::string, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt;\u0026amp;gt;(file, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;)) {\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;first col: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\u0026amp;gt;(row) \u0026amp;lt;\u0026amp;lt; std::endl;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Advanges:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;quite clean and simple to use, only C++11.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;automatic type conversion into \u0026lt;code\u0026gt;std::tuple\u0026amp;lt;t1, ...\u0026amp;gt;\u0026lt;/code\u0026gt; via \u0026lt;code\u0026gt;operator\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;What\u0026apos;s missing:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;escaping and quoting\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;no error handling in case of malformed CSV.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;The main code:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iterator\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;sstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; csvtools {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Read the last element of the tuple without calling recursively\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; idx, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;... fields\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; std::enable_if\u0026amp;lt;idx \u0026amp;gt;= std::tuple_size\u0026amp;lt;std::tuple\u0026amp;lt;fields...\u0026amp;gt;\u0026amp;gt;::value - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\u0026amp;gt;::type\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read_tuple\u0026lt;/span\u0026gt;(std::istream \u0026amp;amp;in, std::tuple\u0026amp;lt;fields...\u0026amp;gt; \u0026amp;amp;out, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; delimiter) {\n        std::string cell;\n        std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(in, cell, delimiter);\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::stringstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;cell_stream\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(cell)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n        cell_stream \u0026amp;gt;\u0026amp;gt; std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;\u0026amp;lt;idx\u0026amp;gt;(out);\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Read the @p idx-th element of the tuple and then calls itself with @p idx + 1 to\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// read the next element of the tuple. Automatically falls in the previous case when\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// reaches the last element of the tuple thanks to enable_if\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; idx, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;... fields\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; std::enable_if\u0026amp;lt;idx \u0026amp;lt; std::tuple_size\u0026amp;lt;std::tuple\u0026amp;lt;fields...\u0026amp;gt;\u0026amp;gt;::value - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;type\n    \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;read_tuple\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::istream \u0026amp;amp;in, std::tuple\u0026amp;lt;fields...\u0026amp;gt; \u0026amp;amp;out, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; delimiter)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n        std::string cell;\n        std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(in, cell, delimiter);\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::stringstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;cell_stream\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(cell)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n        cell_stream \u0026amp;gt;\u0026amp;gt; std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;\u0026amp;lt;idx\u0026amp;gt;(out);\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read_tuple\u0026lt;/span\u0026gt;\u0026amp;lt;idx + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, fields...\u0026amp;gt;(in, out, delimiter);\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Iterable csv wrapper around a stream. @p fields the list of types that form up a row.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;... fields\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;csv\u0026lt;/span\u0026gt; {\n    std::istream \u0026amp;amp;_in;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; _delim;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; std::tuple\u0026amp;lt;fields...\u0026amp;gt; value_type;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;iterator\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Construct from a stream.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;csv\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::istream \u0026amp;amp;in, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; delim)\u0026lt;/span\u0026gt; : _in(in), _delim(delim) {\u0026lt;/span\u0026gt;}\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Status of the underlying stream\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// @{\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;good\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; _in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;good\u0026lt;/span\u0026gt;();\n    }\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::istream \u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;underlying_stream\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; _in;\n    }\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// @}\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; iterator \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; iterator \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Reads a line into a stringstream, and then reads the line into a tuple, that is returned\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; value_type \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;read_row\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n        std::string line;\n        std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(_in, line);\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::stringstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;line_stream\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(line)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n        std::tuple\u0026amp;lt;fields...\u0026amp;gt; retval;\n        csvtools::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read_tuple\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, fields...\u0026amp;gt;(line_stream, retval, _delim);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; retval;\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Iterator; just calls recursively @ref csv::read_row and stores the result.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;... fields\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;csv\u0026lt;/span\u0026gt;\u0026amp;lt;fields...\u0026amp;gt;::iterator {\n    csv::value_type _row;\n    csv *_parent;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; std::input_iterator_tag iterator_category;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; csv::value_type         value_type;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt;             difference_type;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; csv::value_type *       pointer;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; csv::value_type \u0026amp;amp;       reference;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Construct an empty/end iterator\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;iterator\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; : _parent(nullptr) {\u0026lt;/span\u0026gt;}\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Construct an iterator at the beginning of the @p parent csv object.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;iterator\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(csv \u0026amp;amp;parent)\u0026lt;/span\u0026gt; : _parent(parent.good() ? \u0026amp;amp;parent : nullptr) {\u0026lt;/span\u0026gt;\n        ++(*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;);\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Read one row, if possible. Set to end if parent is not good anymore.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; iterator \u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;++() {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (_parent != \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;) {\n            _row = _parent-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read_row\u0026lt;/span\u0026gt;();\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!_parent-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;good\u0026lt;/span\u0026gt;()) {\n                _parent = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;;\n            }\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; iterator \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;++(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;) {\n        iterator copy = *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n        ++(*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; copy;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; csv::value_type \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;*() \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; _row;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; csv::value_type \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;-\u0026amp;gt;() \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026amp;amp;_row;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;==(iterator \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026amp;amp;other) {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; == \u0026amp;amp;other) \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;or\u0026lt;/span\u0026gt; (_parent == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;and\u0026lt;/span\u0026gt; other._parent == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;);\n    }\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;!=(iterator \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026amp;amp;other) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; (*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; == other);\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;... fields\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; csv\u0026amp;lt;fields...\u0026amp;gt;::iterator csv\u0026amp;lt;fields...\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;() {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;iterator\u0026lt;/span\u0026gt;(*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;);\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;... fields\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; csv\u0026amp;lt;fields...\u0026amp;gt;::iterator csv\u0026amp;lt;fields...\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;() {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;iterator\u0026lt;/span\u0026gt;();\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I put a tiny working example on \u0026lt;a href=\u0026quot;https://github.com/LizardM4/ballin-octo-tribble/tree/master/csv\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;GitHub\u0026lt;/a\u0026gt;; I\u0026apos;ve been using it for parsing some numerical data and it served its purpose.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is another implementation of a Unicode CSV parser (works with wchar_t). I wrote part of it, while Jonathan Leffler wrote the rest.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note: This parser is aimed at replicating Excel\u0026apos;s behavior as closely as possible, specifically when importing \u0026lt;strong\u0026gt;broken or malformed\u0026lt;/strong\u0026gt; CSV files.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is the original question - \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/15520113/parsing-csv-file-with-multiline-fields-and-escaped-double-quotes\u0026quot;\u0026gt;Parsing CSV file with multiline fields and escaped double quotes\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is the code as a SSCCE (Short, Self-Contained, Correct Example).\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdbool.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;wchar.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;wctype.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extern\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;nextCsvField\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *p, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; sep, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; *newline)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Returns a pointer to the start of the next field,\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// or zero if this is the last field in the CSV\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// p is the start position of the field\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// sep is the separator used, i.e. comma or semicolon\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// newline says whether the field ends with a newline or with a comma\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;nextCsvField\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *p, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; sep, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; *newline)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Parse quoted sequences\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt; == p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]) {\n        p++;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) {\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Find next double-quote\u0026lt;/span\u0026gt;\n            p = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wcschr\u0026lt;/span\u0026gt;(p, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;);\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// If we don\u0026apos;t find it or it\u0026apos;s the last symbol\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// then this is the last field\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!p || !p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;])\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Check for \u0026quot;\u0026quot;, it is an escaped double-quote\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;)\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Skip the escaped double-quote\u0026lt;/span\u0026gt;\n            p += \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n        }\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Find next newline or comma.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; newline_or_sep[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026quot;\\n\\r \u0026quot;\u0026lt;/span\u0026gt;;\n    newline_or_sep[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;] = sep;\n    p = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wcspbrk\u0026lt;/span\u0026gt;(p, newline_or_sep);\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// If no newline or separator, this is the last field.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!p)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Check if we had newline.\u0026lt;/span\u0026gt;\n    *newline = (p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\r\u0026apos;\u0026lt;/span\u0026gt; || p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;);\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Handle \u0026quot;\\r\\n\u0026quot;, otherwise just increment\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\r\u0026apos;\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;)\n        p += \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n        p++;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; p;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;csvFieldData\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *fld_s, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *fld_e, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *buffer, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; buflen)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *dst = buffer;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *end = buffer + buflen - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *src = fld_s;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (*src == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;)\n    {\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *p = src + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (p \u0026amp;lt; fld_e \u0026amp;amp;\u0026amp;amp; dst \u0026amp;lt; end)\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; p+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; \u0026amp;lt; fld_s \u0026amp;amp;\u0026amp;amp; p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;)\n            {\n                *dst++ = p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;];\n                p += \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n            }\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;)\n            {\n                p++;\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n            }\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n                *dst++ = *p++;\n        }\n        src = p;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (src \u0026amp;lt; fld_e \u0026amp;amp;\u0026amp;amp; dst \u0026amp;lt; end)\n        *dst++ = *src++;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (dst \u0026amp;gt;= end)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    *dst = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;(buffer);\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;dissect\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *line)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *start = line;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *next;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt;     eol;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wprintf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026quot;Input %3zd: [%.*ls]\\n\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wcslen\u0026lt;/span\u0026gt;(line), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wcslen\u0026lt;/span\u0026gt;(line)\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;, line);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; ((next = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;nextCsvField\u0026lt;/span\u0026gt;(start, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;, \u0026amp;amp;eol)) != \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n    {\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; buffer[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1024\u0026lt;/span\u0026gt;];\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wprintf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026quot;Raw Field: [%.*ls] (eol = %d)\\n\u0026quot;\u0026lt;/span\u0026gt;, (next - start - eol), start, eol);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;csvFieldData\u0026lt;/span\u0026gt;(start, next\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;, buffer, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(buffer)/\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(buffer[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;])) != \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wprintf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026quot;Field %3zd: [%ls]\\n\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wcslen\u0026lt;/span\u0026gt;(buffer), buffer);\n        start = next;\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; multiline[] =\n   \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026quot;First field of first row,\\\u0026quot;This field is multiline\\n\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;but that\u0026apos;s OK because it\u0026apos;s enclosed in double quotes, and this\\n\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;is an escaped \\\u0026quot;\\\u0026quot; double quote\\\u0026quot; but this one \\\u0026quot;\\\u0026quot; is not\\n\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;   \\\u0026quot;This is second field of second row, but it is not multiline\\n\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;   because it doesn\u0026apos;t start \\n\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;   with an immediate double quote\\\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;\n    ;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; line[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1024\u0026lt;/span\u0026gt;];\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fgetws\u0026lt;/span\u0026gt;(line, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(line)/\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(line[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]), stdin))\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dissect\u0026lt;/span\u0026gt;(line);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dissect\u0026lt;/span\u0026gt;(multiline);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is an old thread but its still at the top of search results, so I\u0026apos;m adding my solution using std::stringstream and a simple string replace method by Yves Baumes I found here.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The following example will read a file line by line, ignore comment lines starting with // and parse the other lines into a combination of strings, ints and doubles. Stringstream does the parsing, but expects fields to be delimited by whitespace, so I use stringreplace to turn commas into spaces first. It handles tabs ok, but doesn\u0026apos;t deal with quoted strings.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Bad or missing input is simply ignored, which may or may not be good, depending on your circumstance.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;sstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;fstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;StringReplace\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::string\u0026amp;amp; str, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string\u0026amp;amp; oldStr, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string\u0026amp;amp; newStr)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// code by  Yves Baumes\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// http://stackoverflow.com/questions/1494399/how-do-i-search-find-and-replace-in-a-standard-string\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; pos = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;((pos = str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(oldStr, pos)) != std::string::npos)\n  {\n     str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;replace\u0026lt;/span\u0026gt;(pos, oldStr.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;(), newStr);\n     pos += newStr.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;();\n  }\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;LoadCSV\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::string \u0026amp;amp;filename)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::ifstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;stream\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(filename)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n   std::string in_line;\n   std::string Field;\n   std::string Chan;\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; ChanType;\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; Scale;\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; Import;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(stream, in_line)) {\n      \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;StringReplace\u0026lt;/span\u0026gt;(in_line, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;,\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \u0026quot;\u0026lt;/span\u0026gt;);\n      \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::stringstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;line\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(in_line)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n      line \u0026amp;gt;\u0026amp;gt; Field \u0026amp;gt;\u0026amp;gt; Chan \u0026amp;gt;\u0026amp;gt; ChanType \u0026amp;gt;\u0026amp;gt; Scale \u0026amp;gt;\u0026amp;gt; Import;\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (Field.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)!=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;//\u0026quot;\u0026lt;/span\u0026gt;) {\n         \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// do your stuff \u0026lt;/span\u0026gt;\n         \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// this is CBuilder code for demonstration, sorry\u0026lt;/span\u0026gt;\n         \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ShowMessage\u0026lt;/span\u0026gt;((String)Field.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c_str\u0026lt;/span\u0026gt;() + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt; + Chan.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c_str\u0026lt;/span\u0026gt;() + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;IntToStr\u0026lt;/span\u0026gt;(ChanType) + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt; +\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;FloatToStr\u0026lt;/span\u0026gt;(Scale) + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt; +\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;IntToStr\u0026lt;/span\u0026gt;(Import));\n      }\n   }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I needed an easy-to-use C++ library for parsing CSV files but couldn\u0026apos;t find any available, so I ended up building one.\n\u0026lt;a href=\u0026quot;https://github.com/d99kris/rapidcsv/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Rapidcsv\u0026lt;/a\u0026gt; is a C++11 header-only library which gives direct access to parsed columns (or rows) as vectors, in datatype of choice. For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;rapidcsv.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;rapidcsv::Document \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;doc\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;../tests/msft.csv\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n  std::vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt;\u0026amp;gt; close = doc.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;GetColumn\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Close\u0026quot;\u0026lt;/span\u0026gt;);\n  std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Read \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; close.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;() \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; values.\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; std::endl;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You can use the header-only \u0026lt;a href=\u0026quot;https://github.com/ashaduri/csv-parser\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Csv::Parser\u0026lt;/a\u0026gt; library.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;It fully supports RFC 4180, including quoted values, escaped quotes, and newlines in field values.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It requires only standard C++ (C++17).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It supports reading CSV data from \u0026lt;code\u0026gt;std::string_view\u0026lt;/code\u0026gt; at compile-time.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It\u0026apos;s extensively tested using \u0026lt;a href=\u0026quot;https://github.com/catchorg/Catch2\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Catch2\u0026lt;/a\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is code for reading a matrix, note you also have a csvwrite function in matlab\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;loadFromCSV\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string\u0026amp;amp; filename )\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::ifstream       \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;file\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( filename.c_str() )\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    std::vector\u0026amp;lt; std::vector\u0026amp;lt;std::string\u0026amp;gt; \u0026amp;gt;   matrix;\n    std::vector\u0026amp;lt;std::string\u0026amp;gt;   row;\n    std::string                line;\n    std::string                cell;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( file )\n    {\n        std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(file,line);\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::stringstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;lineStream\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(line)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n        row.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;( lineStream, cell, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt; ) )\n            row.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;( cell );\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;( !row.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;empty\u0026lt;/span\u0026gt;() )\n            matrix.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;( row );\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;(matrix.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;()); i++ )\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; j=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; j\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;(matrix[i].\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;()); j++ )\n            std::cout \u0026amp;lt;\u0026amp;lt; matrix[i][j] \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \u0026quot;\u0026lt;/span\u0026gt;;\n\n        std::cout \u0026amp;lt;\u0026amp;lt; std::endl;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Excuse me, but this all seems like a great deal of elaborate syntax to hide a few lines of code.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Why not this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/**\n\n  Read line from a CSV file\n\n  @param[in] fp file pointer to open file\n  @param[in] vls reference to vector of strings to hold next line\n\n  */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;readCSV\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( FILE *fp, std::vector\u0026amp;lt;std::string\u0026amp;gt;\u0026amp;amp; vls )\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    vls.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;( ! fp )\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; buf[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10000\u0026lt;/span\u0026gt;];\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;( ! \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fgets\u0026lt;/span\u0026gt;( buf,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;999\u0026lt;/span\u0026gt;,fp) )\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;;\n    std::string s = buf;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; p,q;\n    q = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// loop over columns\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; ) {\n        p = q;\n        q = s.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_first_of\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;,\\n\u0026quot;\u0026lt;/span\u0026gt;,p+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;( q == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt; ) \n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n        vls.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;( s.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(p+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,q-p\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;) );\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; _tmain(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, _TCHAR* argv[])\n{\n    std::vector\u0026amp;lt;std::string\u0026amp;gt; vls;\n    FILE * fp = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fopen\u0026lt;/span\u0026gt;( argv[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;], \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;r\u0026quot;\u0026lt;/span\u0026gt; );\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;( ! fp )\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;readCSV\u0026lt;/span\u0026gt;( fp, vls );\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;readCSV\u0026lt;/span\u0026gt;( fp, vls );\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;readCSV\u0026lt;/span\u0026gt;( fp, vls );\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;row 3, col 4 is \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; vls[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;].\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c_str\u0026lt;/span\u0026gt;() \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You can open and read .csv file using fopen ,fscanf functions ,but the important thing is to parse the data.Simplest way to parse the data using delimiter.In case of .csv , delimiter is \u0026apos;,\u0026apos;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Suppose your data1.csv file is as follows : \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;A,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;45\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;76\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;01\u0026lt;/span\u0026gt;\nB,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;77\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;67\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;02\u0026lt;/span\u0026gt;\nC,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;63\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;76\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;03\u0026lt;/span\u0026gt;\nD,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;65\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;44\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;04\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;you can tokenize data and store in char array and later use atoi() etc function for appropriate conversions  \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;FILE *fp;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; str1[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;], str2[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;], str3[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;], str4[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;];\n\nfp = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fopen\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;G:\\\\data1.csv\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;r\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt; == fp)\n{\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\nError in opening file.\u0026quot;\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(EOF != \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fscanf\u0026lt;/span\u0026gt;(fp, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; %[^,], %[^,], %[^,], %s, %s, %s, %s \u0026quot;\u0026lt;/span\u0026gt;, str1, str2, str3, str4))\n{\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n%s %s %s %s\u0026quot;\u0026lt;/span\u0026gt;, str1, str2, str3, str4);\n}\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fclose\u0026lt;/span\u0026gt;(fp);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;[^,], ^ -it inverts logic , means match any string that does not contain comma then last , says to match comma that terminated previous string. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The first thing you need to do is make sure the file exists. To accomplish\nthis you just need to try and open the file stream at the path. After you\nhave opened the file stream use stream.fail() to see if it worked as expected,\nor not.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;fileExists\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(string fileName)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n\nifstream test;\n\ntest.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;open\u0026lt;/span\u0026gt;(fileName.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c_str\u0026lt;/span\u0026gt;());\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (test.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;())\n{\n    test.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;close\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n{\n    test.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;close\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\n}\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You must also verify that the file provided is the correct type of file.\nTo accomplish this you need to look through the file path provided until \nyou find the file extension. Once you have the file extension make sure\nthat it is a .csv file.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;verifyExtension\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(string filename)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; period = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; filename.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;(); i++)\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (filename[i] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;.\u0026apos;\u0026lt;/span\u0026gt;)\n        period = i;\n}\n\nstring extension;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = period; i \u0026amp;lt; filename.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;(); i++)\n    extension += filename[i];\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (extension == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;.csv\u0026quot;\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This function will return the file extension which is used later in an error message.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;getExtension\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(string filename)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; period = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; filename.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;(); i++)\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (filename[i] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;.\u0026apos;\u0026lt;/span\u0026gt;)\n        period = i;\n}\n\nstring extension;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (period != \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = period; i \u0026amp;lt; filename.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;(); i++)\n        extension += filename[i];\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n    extension = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;NO FILE\u0026quot;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; extension;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This function will actually call the error checks created above and then parse through the file.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;parseFile\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(string fileName)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fileExists\u0026lt;/span\u0026gt;(fileName) \u0026amp;amp;\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;verifyExtension\u0026lt;/span\u0026gt;(fileName))\n    {\n        ifstream fs;\n        fs.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;open\u0026lt;/span\u0026gt;(fileName.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c_str\u0026lt;/span\u0026gt;());\n        string fileCommand;\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (fs.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;good\u0026lt;/span\u0026gt;())\n        {\n            string temp;\n\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(fs, fileCommand, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;);\n\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; fileCommand.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;(); i++)\n            {\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (fileCommand[i] != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;)\n                    temp += fileCommand[i];\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n                    temp += \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \u0026quot;\u0026lt;/span\u0026gt;;\n            }\n\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (temp != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\0\u0026quot;\u0026lt;/span\u0026gt;)\n            {\n                \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Place your code here to run the file.\u0026lt;/span\u0026gt;\n            }\n        }\n        fs.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;close\u0026lt;/span\u0026gt;();\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fileExists\u0026lt;/span\u0026gt;(fileName))\n    {\n        cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Error: The provided file does not exist: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; fileName \u0026amp;lt;\u0026amp;lt; endl;\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;verifyExtension\u0026lt;/span\u0026gt;(fileName))\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getExtension\u0026lt;/span\u0026gt;(fileName) != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;NO FILE\u0026quot;\u0026lt;/span\u0026gt;)\n                cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\tCheck the file extension.\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n                cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\tThere is no file in the provided path.\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl;\n        }\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;verifyExtension\u0026lt;/span\u0026gt;(fileName)) \n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getExtension\u0026lt;/span\u0026gt;(fileName) != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;NO FILE\u0026quot;\u0026lt;/span\u0026gt;)\n            cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Incorrect file extension provided: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getExtension\u0026lt;/span\u0026gt;(fileName) \u0026amp;lt;\u0026amp;lt; endl;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n            cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;There is no file in the following path: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; fileName \u0026amp;lt;\u0026amp;lt; endl;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Since i\u0026apos;m not used to boost right now, I will suggest a more simple solution. Lets suppose that your .csv file has 100 lines with 10 numbers in each line separated by a \u0026apos;,\u0026apos;. You could load this data in the form of an array with the following code:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;fstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;sstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; A[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;][\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;];\n    ifstream ifs;\n    ifs.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;open\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;name_of_file.csv\u0026quot;\u0026lt;/span\u0026gt;);\n    string s1;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; c;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; k=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; k\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;; k++)\n    {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(ifs,s1);\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;stringstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;stream\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(s1)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; j=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n        {\n            stream \u0026amp;gt;\u0026amp;gt;A[k][j];\n            stream \u0026amp;gt;\u0026amp;gt; c;\n            j++;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(!stream) {\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;}\n        }\n    }\n\n\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You can use this library:\n\u0026lt;a href=\u0026quot;https://github.com/vadamsky/csvworker\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://github.com/vadamsky/csvworker\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Code for example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;csvworker.h\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//\u0026lt;/span\u0026gt;\n    CsvWorker csv;\n    csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;loadFromFile\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;example.csv\u0026quot;\u0026lt;/span\u0026gt;);\n    cout \u0026amp;lt;\u0026amp;lt; csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getRowsNumber\u0026lt;/span\u0026gt;() \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;  \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getColumnsNumber\u0026lt;/span\u0026gt;() \u0026amp;lt;\u0026amp;lt; endl;\n\n    csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0\u0026quot;\u0026lt;/span\u0026gt;;\n    csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0\u0026quot;\u0026lt;/span\u0026gt;;\n    csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0\u0026quot;\u0026lt;/span\u0026gt;;\n    csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0\u0026quot;\u0026lt;/span\u0026gt;;\n    csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0\u0026quot;\u0026lt;/span\u0026gt;;\n    csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0\u0026quot;\u0026lt;/span\u0026gt;;\n    csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0\u0026quot;\u0026lt;/span\u0026gt;;\n    csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0\u0026quot;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;i\u0026amp;lt;csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getRowsNumber\u0026lt;/span\u0026gt;();++i)\n    {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//cout \u0026amp;lt;\u0026amp;lt; csv.getRow(i) \u0026amp;lt;\u0026amp;lt; endl;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; j=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;j\u0026amp;lt;csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getColumnsNumber\u0026lt;/span\u0026gt;();++j)\n        {\n            cout \u0026amp;lt;\u0026amp;lt; csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getField\u0026lt;/span\u0026gt;(i, j) \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;.\u0026quot;\u0026lt;/span\u0026gt;;\n        }\n        cout \u0026amp;lt;\u0026amp;lt; endl;\n    }\n\n    csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;saveToFile\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;test.csv\u0026quot;\u0026lt;/span\u0026gt;);\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;CsvWorker \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;csv2\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a\u0026quot;\u0026lt;/span\u0026gt;;\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;b\u0026quot;\u0026lt;/span\u0026gt;;\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;r\u0026quot;\u0026lt;/span\u0026gt;;\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a\u0026quot;\u0026lt;/span\u0026gt;;\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;c\u0026quot;\u0026lt;/span\u0026gt;;\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a\u0026quot;\u0026lt;/span\u0026gt;;\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;d\u0026quot;\u0026lt;/span\u0026gt;;\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a\u0026quot;\u0026lt;/span\u0026gt;;\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;b\u0026quot;\u0026lt;/span\u0026gt;;\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;r\u0026quot;\u0026lt;/span\u0026gt;;\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a\u0026quot;\u0026lt;/span\u0026gt;;\n\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;saveToFile\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;test2.csv\u0026quot;\u0026lt;/span\u0026gt;);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You gotta feel proud when you use something so beautiful as \u0026lt;code\u0026gt;boost::spirit\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here my attempt of a parser (almost) complying with the CSV specifications on this link \u0026lt;a href=\u0026quot;http://www.ietf.org/rfc/rfc4180.txt\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;CSV specs\u0026lt;/a\u0026gt; (I didn\u0026apos;t need line breaks within fields. Also the spaces around the commas are dismissed).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;After you overcome the shocking experience of waiting 10 seconds for compiling this code :), you can sit back and enjoy.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// csvparser.cpp\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;boost/spirit/include/qi.hpp\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;boost/spirit/include/phoenix_operator.hpp\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; qi = boost::spirit::qi;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; bascii = boost::spirit::ascii;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Iterator\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;csv_parser\u0026lt;/span\u0026gt; : qi::grammar\u0026amp;lt;Iterator, std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;vector\u0026lt;/span\u0026gt;\u0026amp;lt;std::string\u0026amp;gt;(), \n    bascii::space_type\u0026amp;gt;\n{\n    qi::rule\u0026amp;lt;Iterator, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;()                                           \u0026amp;gt; COMMA;\n    qi::rule\u0026amp;lt;Iterator, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;()                                           \u0026amp;gt; DDQUOTE;\n    qi::rule\u0026amp;lt;Iterator, std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;(),               bascii::space_type  \u0026amp;gt; non_escaped;\n    qi::rule\u0026amp;lt;Iterator, std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;(),               bascii::space_type  \u0026amp;gt; escaped;\n    qi::rule\u0026amp;lt;Iterator, std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;(),               bascii::space_type  \u0026amp;gt; field;\n    qi::rule\u0026amp;lt;Iterator, std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;vector\u0026lt;/span\u0026gt;\u0026amp;lt;std::string\u0026amp;gt;(),  bascii::space_type  \u0026amp;gt; start;\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;csv_parser\u0026lt;/span\u0026gt;() : csv_parser::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;base_type\u0026lt;/span\u0026gt;(start)\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; qi;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; qi::lit;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; qi::lexeme;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; bascii::char_;\n\n        start       = field % \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;;\n        field       = escaped | non_escaped;\n        escaped     = lexeme[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt; \u0026amp;gt;\u0026amp;gt; *( char_ -(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char_\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;) | \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;) | COMMA | DDQUOTE)  \u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;];\n        non_escaped = lexeme[       *( char_ -(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char_\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;) | \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;)                  )        ];\n        DDQUOTE     = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;lit\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\\u0026quot;\\\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;)       [_val = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;];\n        COMMA       = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;lit\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;,\u0026quot;\u0026lt;/span\u0026gt;)          [_val = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;];\n    }\n\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Enter CSV lines [empty] to quit\\n\u0026quot;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; bascii::space;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; std::string::const_iterator iterator_type;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; csv_parser\u0026amp;lt;iterator_type\u0026amp;gt; csv_parser;\n\n    csv_parser grammar;\n    std::string str;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; fid;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(std::cin, str))\n    {\n        fid = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;empty\u0026lt;/span\u0026gt;())\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n\n        std::vector\u0026amp;lt;std::string\u0026amp;gt; csv;\n        std::string::const_iterator it_beg = str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;();\n        std::string::const_iterator it_end = str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;();\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; r = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;phrase_parse\u0026lt;/span\u0026gt;(it_beg, it_end, grammar, space, csv);\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (r \u0026amp;amp;\u0026amp;amp; it_beg == it_end)\n        {\n            std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Parsing succeeded\\n\u0026quot;\u0026lt;/span\u0026gt;;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt;\u0026amp;amp; field: csv)\n            {\n                std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;field \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; ++fid \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; field \u0026amp;lt;\u0026amp;lt; std::endl;\n            }\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n        {\n            std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Parsing failed\\n\u0026quot;\u0026lt;/span\u0026gt;;\n        }\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Compile:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;make csvparser\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Test (example stolen from \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Comma-separated_values#Example\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Wikipedia\u0026lt;/a\u0026gt;):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-none s-code-block\u0026quot;\u0026gt;\u0026lt;code\u0026gt;./csvparser\nEnter CSV lines [empty] to quit\n\n1999,Chevy,\u0026quot;Venture \u0026quot;\u0026quot;Extended Edition, Very Large\u0026quot;\u0026quot;\u0026quot;,,5000.00\nParsing succeeded\nfield 1: 1999\nfield 2: Chevy\nfield 3: Venture \u0026quot;Extended Edition, Very Large\u0026quot;\nfield 4: \nfield 5: 5000.00\n\n1999,Chevy,\u0026quot;Venture \u0026quot;\u0026quot;Extended Edition, Very Large\u0026quot;\u0026quot;\u0026quot;,,5000.00\u0026quot;\nParsing failed\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This solution detects these 4 cases\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;complete class is at\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/pedro-vicente/csv-parser\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://github.com/pedro-vicente/csv-parser\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,field \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,field \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;,\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,field \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;field 3 quoted, with separator\u0026quot;\u0026lt;/span\u0026gt;,\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,field \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;field 3\nwith newline\u0026quot;\u0026lt;/span\u0026gt;,\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,field \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;field 3\nwith newline and separator,\u0026quot;\u0026lt;/span\u0026gt;,\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It reads the file character by character, and reads 1 row at a time to a vector (of strings), therefore suitable for very large files.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Usage is\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Iterate until an empty row is returned (end of file). A row is a vector where each entry is a CSV column.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;read_csv_t\u0026lt;/span\u0026gt; csv;\ncsv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;open\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;../test.csv\u0026quot;\u0026lt;/span\u0026gt;);\nstd::vector\u0026amp;lt;std::string\u0026amp;gt; row;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;)\n{\n  row = csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read_row\u0026lt;/span\u0026gt;();\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (row.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;() == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n  {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n  }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;the class declaration\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;read_csv_t\u0026lt;/span\u0026gt;\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read_csv_t\u0026lt;/span\u0026gt;();\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;open\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string \u0026amp;amp;file_name)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::vector\u0026amp;lt;std::string\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;read_row\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n  std::ifstream m_ifs;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;the implementation\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::vector\u0026amp;lt;std::string\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;read_csv_t::read_row\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; quote_mode = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n  std::vector\u0026amp;lt;std::string\u0026amp;gt; row;\n  std::string column;\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; c;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (m_ifs.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;(c))\n  {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;switch\u0026lt;/span\u0026gt; (c)\n    {\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/////////////////////////////////////////////////////////////////////////////////////////////////////\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//separator \u0026apos;,\u0026apos; detected. \u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//in quote mode add character to column\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//push column if not in quote mode\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/////////////////////////////////////////////////////////////////////////////////////////////////////\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;:\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (quote_mode == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;)\n      {\n        column += c;\n      }\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n      {\n        row.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(column);\n        column.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n      }\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/////////////////////////////////////////////////////////////////////////////////////////////////////\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//quote \u0026apos;\u0026quot;\u0026apos; detected. \u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//toggle quote mode\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/////////////////////////////////////////////////////////////////////////////////////////////////////\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;:\n      quote_mode = !quote_mode;\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/////////////////////////////////////////////////////////////////////////////////////////////////////\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//line end detected\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//in quote mode add character to column\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//return row if not in quote mode\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/////////////////////////////////////////////////////////////////////////////////////////////////////\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\r\u0026apos;\u0026lt;/span\u0026gt;:\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (quote_mode == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;)\n      {\n        column += c;\n      }\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n      {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; row;\n      }\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/////////////////////////////////////////////////////////////////////////////////////////////////////\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//default, add character to column\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/////////////////////////////////////////////////////////////////////////////////////////////////////\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;:\n      column += c;\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n    }\n  }\n\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//return empty vector if end of file detected \u0026lt;/span\u0026gt;\n  m_ifs.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;close\u0026lt;/span\u0026gt;();\n  std::vector\u0026amp;lt;std::string\u0026amp;gt; v;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; v;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;Parsing CSV file lines with Stream\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I wrote a small example of parsing CSV file lines, it can be developed with for and while loops if desired:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;fstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;ifstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;fin\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Infile.csv\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;ofstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;fout\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;OutFile.csv\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\nstring strline, strremain, strCol1 , strout;\n\nstring delimeter =\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;;\u0026quot;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; d1;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;to continue until the end of the file:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (!fin.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;()){ \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;get first line from InFile :\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(fin,strline,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;);      \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;find delimeter position in line:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;    d1 = strline.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;;\u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and parse first column:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;    strCol1 = strline.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,d1); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// parse first Column\u0026lt;/span\u0026gt;\n    d1++;\n    strremain = strline.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(d1); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// remaining line\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;create output line in CSV format:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;    strout.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;append\u0026lt;/span\u0026gt;(strCol1);\n    strout.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;append\u0026lt;/span\u0026gt;(delimeter);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;write line to Out File:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;    fout \u0026amp;lt;\u0026amp;lt; strout \u0026amp;lt;\u0026amp;lt; endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//out file line\u0026lt;/span\u0026gt;\n\n} \n\nfin.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;close\u0026lt;/span\u0026gt;();\nfout.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;close\u0026lt;/span\u0026gt;();\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This code is compiled and running. Good luck!\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You could also take a look at capabilities of \u0026lt;code\u0026gt;Qt\u0026lt;/code\u0026gt; library.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It has regular expressions support and QString class has nice methods, e.g. \u0026lt;code\u0026gt;split()\u0026lt;/code\u0026gt; returning QStringList, list of strings obtained by splitting the original string with a provided delimiter. Should suffice for csv file.. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To get a column with a given header name I use following: \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/970330/c-inheritance-qt-problem-qstring/1011601#1011601\u0026quot;\u0026gt;c++ inheritance Qt problem qstring\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you don\u0026apos;t want to deal with including boost in your project (it is considerably large if all you are going to use it for is CSV parsing...)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I have had luck with the CSV parsing here:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://www.zedwood.com/article/112/cpp-csv-parser\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;http://www.zedwood.com/article/112/cpp-csv-parser\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It handles quoted fields - but does not handle inline \\n characters (which is probably fine for most uses).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;For what it is worth, here is my implementation. It deals with wstring input, but could be adjusted to string easily. It does not handle newline in fields (as my application does not either, but adding its support isn\u0026apos;t too difficult) and it does not comply with \u0026quot;\\r\\n\u0026quot; end of line as per RFC (assuming you use std::getline), but it does handle whitespace trimming and double-quotes correctly (hopefully).\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// trim whitespaces around field or double-quotes, remove double-quotes and replace escaped double-quotes (double double-quotes)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;wstring \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;trimquote\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; wstring\u0026amp;amp; str, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; wstring\u0026amp;amp; whitespace, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; quotChar)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    wstring ws;\n    wstring::size_type strBegin = str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_first_not_of\u0026lt;/span\u0026gt;(whitespace);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (strBegin == wstring::npos)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;;\n\n    wstring::size_type strEnd = str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_last_not_of\u0026lt;/span\u0026gt;(whitespace);\n    wstring::size_type strRange = strEnd - strBegin + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;((str[strBegin] == quotChar) \u0026amp;amp;\u0026amp;amp; (str[strEnd] == quotChar))\n    {\n        ws = str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(strBegin+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, strRange\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-2\u0026lt;/span\u0026gt;);\n        strBegin = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;((strEnd = ws.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(quotChar, strBegin)) != wstring::npos)\n        {\n            ws.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;erase\u0026lt;/span\u0026gt;(strEnd, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n            strBegin = strEnd+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n        }\n\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n        ws = str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(strBegin, strRange);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; ws;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;pair\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;nextCSVQuotePair\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; wstring\u0026amp;amp; line, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; quotChar, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; ofs = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    pair\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt;\u0026amp;gt; r;\n    r.first = line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(quotChar, ofs);\n    r.second = wstring::npos;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(r.first != wstring::npos)\n    {\n        r.second = r.first;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(((r.second = line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(quotChar, r.second+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)) != wstring::npos)\n            \u0026amp;amp;\u0026amp;amp; (line[r.second+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] == quotChar)) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// WARNING: assumes null-terminated string such that line[r.second+1] always exist\u0026lt;/span\u0026gt;\n            r.second++;\n\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; r;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;parseLine\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(vector\u0026amp;lt;wstring\u0026amp;gt;\u0026amp;amp; fields, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; wstring\u0026amp;amp; line)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; ofs, ofs0, np;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; delim = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; wstring whitespace = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026quot; \\t\\xa0\\x3000\\x2000\\x2001\\x2002\\x2003\\x2004\\x2005\\x2006\\x2007\\x2008\\x2009\\x200a\\x202f\\x205f\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; quotChar = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026apos;\\\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;;\n    pair\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt;\u0026amp;gt; quot;\n\n    fields.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n\n    ofs = ofs0 = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    quot = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;nextCSVQuotePair\u0026lt;/span\u0026gt;(line, quotChar);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;((np = line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(delim, ofs)) != wstring::npos)\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;((np \u0026amp;gt; quot.first) \u0026amp;amp;\u0026amp;amp; (np \u0026amp;lt; quot.second))\n        { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// skip delimiter inside quoted field\u0026lt;/span\u0026gt;\n            ofs = quot.second+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n            quot = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;nextCSVQuotePair\u0026lt;/span\u0026gt;(line, quotChar, ofs);\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;continue\u0026lt;/span\u0026gt;;\n        }\n        fields.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;trimquote\u0026lt;/span\u0026gt;(line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(ofs0, np-ofs0), whitespace, quotChar) );\n        ofs = ofs0 = np+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    }\n    fields.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;trimquote\u0026lt;/span\u0026gt;(line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(ofs0), whitespace, quotChar) );\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; fields.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;();\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is a ready-to use function if all you need is to load a data file of doubles (no integers, no text).\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;sstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;fstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iterator\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;algorithm\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/**\n * Parse a CSV data file and fill the 2d STL vector \u0026quot;data\u0026quot;.\n * Limits: only \u0026quot;pure datas\u0026quot; of doubles, not encapsulated by \u0026quot; and without \\n inside.\n * Further no formatting in the data (e.g. scientific notation)\n * It however handles both dots and commas as decimal separators and removes thousand separator.\n * \n * returnCodes[0]: file access 0-\u0026amp;gt; ok 1-\u0026amp;gt; not able to read; 2-\u0026amp;gt; decimal separator equal to comma separator\n * returnCodes[1]: number of records\n * returnCodes[2]: number of fields. -1 If rows have different field size\n * \n */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;readCsvData\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(vector \u0026amp;lt;vector \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;amp; data, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; string\u0026amp;amp; filename, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; string\u0026amp;amp; delimiter, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; string\u0026amp;amp; decseparator)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{\n\n \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; vv[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] = { \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; };\n \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;returnCodes\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026amp;amp;vv[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;], \u0026amp;amp;vv[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n string rowstring, stringtoken;\n \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; doubletoken;\n \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; rowcount=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; fieldcount=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n data.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n\n \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;ifstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;iFile\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(filename, ios_base::in)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!iFile.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;is_open\u0026lt;/span\u0026gt;()){\n   returnCodes[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; returnCodes;\n }\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(iFile, rowstring)) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (rowstring==\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;continue\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// empty line\u0026lt;/span\u0026gt;\n    rowcount ++; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//let\u0026apos;s start with 1\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(delimiter == decseparator){\n      returnCodes[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; returnCodes;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(decseparator != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;.\u0026quot;\u0026lt;/span\u0026gt;){\n     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// remove dots (used as thousand separators)\u0026lt;/span\u0026gt;\n     string::iterator end_pos = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;remove\u0026lt;/span\u0026gt;(rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(), \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;.\u0026apos;\u0026lt;/span\u0026gt;);\n     rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;erase\u0026lt;/span\u0026gt;(end_pos, rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;());\n     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// replace decimal separator with dots.\u0026lt;/span\u0026gt;\n     \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;replace\u0026lt;/span\u0026gt;(rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(),decseparator.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c_str\u0026lt;/span\u0026gt;()[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;], \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;.\u0026apos;\u0026lt;/span\u0026gt;); \n    } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// remove commas (used as thousand separators)\u0026lt;/span\u0026gt;\n     string::iterator end_pos = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;remove\u0026lt;/span\u0026gt;(rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(), \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;);\n     rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;erase\u0026lt;/span\u0026gt;(end_pos, rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;());\n    }\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// tokenize..\u0026lt;/span\u0026gt;\n    vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;\u0026amp;gt; tokens;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Skip delimiters at beginning.\u0026lt;/span\u0026gt;\n    string::size_type lastPos = rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_first_not_of\u0026lt;/span\u0026gt;(delimiter, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Find first \u0026quot;non-delimiter\u0026quot;.\u0026lt;/span\u0026gt;\n    string::size_type pos     = rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_first_of\u0026lt;/span\u0026gt;(delimiter, lastPos);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (string::npos != pos || string::npos != lastPos){\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Found a token, convert it to double add it to the vector.\u0026lt;/span\u0026gt;\n        stringtoken = rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(lastPos, pos - lastPos);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (stringtoken == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;) {\n      tokens.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.0\u0026lt;/span\u0026gt;);\n    } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n          istringstream \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;totalSString\u0026lt;/span\u0026gt;(stringtoken);\n      totalSString \u0026amp;gt;\u0026amp;gt; doubletoken;\n      tokens.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(doubletoken);\n    }     \n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Skip delimiters.  Note the \u0026quot;not_of\u0026quot;\u0026lt;/span\u0026gt;\n        lastPos = rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_first_not_of\u0026lt;/span\u0026gt;(delimiter, pos);\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Find next \u0026quot;non-delimiter\u0026quot;\u0026lt;/span\u0026gt;\n        pos = rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_first_of\u0026lt;/span\u0026gt;(delimiter, lastPos);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(rowcount == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;){\n      fieldcount = tokens.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;();\n      returnCodes[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;] = tokens.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;();\n    } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ( tokens.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;() != fieldcount){\n    returnCodes[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;;\n      }\n    }\n    data.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(tokens);\n }\n iFile.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;close\u0026lt;/span\u0026gt;();\n returnCodes[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] = rowcount;\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; returnCodes;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    "],"comment":["\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I have looked at \u0026lt;code\u0026gt;boost::spirit\u0026lt;/code\u0026gt; for parsing.  It is more for parsing grammars thank parsing a simple file format.  Someone on my team was trying to use it to parse XML and it was a pain to debug.  Stay away from \u0026lt;code\u0026gt;boost::spirit\u0026lt;/code\u0026gt; if possible.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/35577/chrish\u0026quot; title=\u0026quot;2,274 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;chrish\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment938051_1120140\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-07-13 19:30:27Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 13, 2009 at 19:30\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Sorry chrish, but that\u0026apos;s terrible advice.  Spirit isn\u0026apos;t always an appropriate solution but I\u0026apos;ve used it - and continue to use it - successfully in a number of projects.  Compared to similar tools (Antlr, Lex/yacc etc) it has significant advantages.  Now, for parsing CSV it\u0026apos;s probably overkill...\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/7405/mattyt\u0026quot; title=\u0026quot;6,341 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;MattyT\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment941839_1120140\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-07-14 12:09:26Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 14, 2009 at 12:09\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@MattyT IMHO \u0026lt;code\u0026gt;spirit\u0026lt;/code\u0026gt; is pretty hard to use for a parser combinator library. Having had some (very pleasant) experience with Haskells \u0026lt;code\u0026gt;(atto)parsec\u0026lt;/code\u0026gt; libraries I expected it (spirit) to work similarly well, but gave up on it after fighting with 600 line compiler errors.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/383508/fho\u0026quot; title=\u0026quot;6,658 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;fho\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment38375206_1120140\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-07-14 13:24:45Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 14, 2014 at 13:24\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;C CSV Parser: \u0026lt;a href=\u0026quot;http://sourceforge.net/projects/cccsvparser\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;sourceforge.net/projects/cccsvparser\u0026lt;/a\u0026gt; C CSV Writer: \u0026lt;a href=\u0026quot;http://sourceforge.net/projects/cccsvwriter\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;sourceforge.net/projects/cccsvwriter\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3322273/somethingsomething\u0026quot; title=\u0026quot;10,494 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;SomethingSomething\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment39740979_1120140\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-08-23 21:22:59Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 23, 2014 at 21:22\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Why don\u0026apos;t you want to escape commas and new lines! Every search links to this question and I could not find one answer that considers the escaping! :|\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/9495110/shafquat\u0026quot; title=\u0026quot;647 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Shafquat\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment119468174_1120140\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2021-05-18 15:58:44Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 18, 2021 at 15:58\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;first() next(). What is this Java! Only Joking.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/14065/martin-york\u0026quot; title=\u0026quot;247,789 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Martin York\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment940356_1120224\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-07-14 05:15:08Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 14, 2009 at 5:15\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@DarthVader: An overlay broad statement that by its broadness is silly. If you would like to clarify why it is bad and then why this badness applies in this context.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/14065/martin-york\u0026quot; title=\u0026quot;247,789 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Martin York\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment11041441_1120224\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-01-12 20:10:27Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 12, 2012 at 20:10\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@DarthVader: I think it is silly to make broad generalizations. The code above works correctly so I can actually see anything wrong with it. But if you have any specific comment on the above I will definitely consider in in this context. But I can see how you can come to that conclusion by mindlessly following a set of generalized rules for C# and applying it to another language.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/14065/martin-york\u0026quot; title=\u0026quot;247,789 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Martin York\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment11042955_1120224\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-01-12 21:29:40Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 12, 2012 at 21:29\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;also, if you run into weird linking problems with the above code because another library somewhere defines \u0026lt;code\u0026gt;istream::operator\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; (like Eigen), add an \u0026lt;code\u0026gt;inline\u0026lt;/code\u0026gt; before the operator declaration to fix it.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/629578/sk29910\u0026quot; title=\u0026quot;2,266 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;sk29910\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment25184802_1120224\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-06-28 00:58:20Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 28, 2013 at 0:58\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;The parsing part is missing, one still ends up with strings. This is just an over-engineered line splitter.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/412080/maxim-egorushkin\u0026quot; title=\u0026quot;126,374 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Maxim Egorushkin\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment38019998_1120224\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-07-03 09:16:13Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 3, 2014 at 9:16\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;this nested vector of strings is a no-go for modern processors. Throws away their caching ability\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1148542/nikos-yotis\u0026quot; title=\u0026quot;271 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Nikos Yotis\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment86341638_30338543\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-04-05 06:56:52Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 5, 2018 at 6:56\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;plus you got all those switch statements\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1148542/nikos-yotis\u0026quot; title=\u0026quot;271 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Nikos Yotis\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment86341943_30338543\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-04-05 07:05:23Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 5, 2018 at 7:05\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;The top answer didn\u0026apos;t work for me, as I am on an older compiler. This answer worked, vector initialisation may require this: \u0026lt;code\u0026gt;const char *vinit[] = {\u0026quot;\u0026quot;};             vector\u0026amp;lt;string\u0026amp;gt; fields(vinit, end(vinit)); \u0026lt;/code\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1205019/dr-rk\u0026quot; title=\u0026quot;4,137 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;dr_rk\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment86390126_30338543\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-04-06 09:16:27Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 6, 2018 at 9:16\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Looks like a great solution and the best solution. Thank you. I think that you could avoid using the counter i by using the method back on your vector called fields.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/738419/mark-s\u0026quot; title=\u0026quot;155 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Mark S.\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment120034317_30338543\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2021-06-09 19:52:50Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 9, 2021 at 19:52\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Very clean solution, this is a better answer than the \u0026lt;b\u0026gt;topmost\u0026lt;/b\u0026gt; answer !\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1177403/jgx\u0026quot; title=\u0026quot;107 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;jgx\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment121370928_30338543\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2021-08-06 07:19:24Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 6, 2021 at 7:19\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;The boost tokenizer doesn\u0026apos;t fully support the complete CSV standard, but there are some quick workarounds. See \u0026lt;a href=\u0026quot;http://stackoverflow.com/questions/1120140/csv-parser-in-c/1595366#1595366\u0026quot; title=\u0026quot;csv parser in c\u0026quot;\u0026gt;stackoverflow.com/questions/1120140/csv-parser-in-c/\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/193178/rolf-kristensen\u0026quot; title=\u0026quot;14,988 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Rolf Kristensen\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment2647582_1122720\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-04-13 23:03:15Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 13, 2010 at 23:03\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Do you have to have the whole boost library on your machine, or can you just use a subset of their code to do this? 256mb seems like a lot for CSV parsing..\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/289182/npike\u0026quot; title=\u0026quot;12,827 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;NPike\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment6667997_1122720\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-04-27 23:28:02Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 27, 2011 at 23:28\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@NPike : You can use the \u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/release/tools/bcp/index.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;bcp\u0026lt;/a\u0026gt; utility that comes with boost to extract only the headers you actually need.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/636019/ildjarn\u0026quot; title=\u0026quot;61,074 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;ildjarn\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment7097183_1122720\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-05-24 23:06:11Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 24, 2011 at 23:06\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Though \u0026lt;a href=\u0026quot;http://www.partow.net/programming/strtk/index.html#ParsingCSVFilesWithEmbeddedDoubleQuotes\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;strtk supports doublequoted fields\u0026lt;/a\u0026gt;, and even stripping the surrounding quotes (via \u0026lt;code\u0026gt;options.trim_dquotes = true\u0026lt;/code\u0026gt;), it doesn\u0026apos;t support removing doubled doublequotes (e.g. the field \u0026lt;code\u0026gt;\u0026quot;She said \u0026quot;\u0026quot;oh no\u0026quot;\u0026quot;, and left.\u0026quot;\u0026lt;/code\u0026gt; as the c-string \u0026lt;code\u0026gt;\u0026quot;She said \\\u0026quot;oh no\\\u0026quot;, and left.\u0026quot;\u0026lt;/code\u0026gt;).  You\u0026apos;ll have to do that yourself.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/9859/rampion\u0026quot; title=\u0026quot;84,720 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;rampion\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment78812417_1475104\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-08-28 20:29:14Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 28, 2017 at 20:29\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;When using \u0026lt;code\u0026gt;strtk\u0026lt;/code\u0026gt;, you\u0026apos;ll also have to manually handle double-quoted fields that contain newline characters.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/9859/rampion\u0026quot; title=\u0026quot;84,720 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;rampion\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment78851506_1475104\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-08-29 19:02:33Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 29, 2017 at 19:02\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;And if you want to be able to parse embedded new lines \u0026lt;a href=\u0026quot;http://mybyteofcode.blogspot.com/2010/11/parse-csv-file-with-embedded-new-lines.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;mybyteofcode.blogspot.com/2010/11/\u0026lt;/a\u0026gt;.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/45654/stefanb\u0026quot; title=\u0026quot;73,557 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;stefanB\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment5152775_2322735\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-01-12 22:35:23Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 12, 2011 at 22:35\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;While this technique works, I have found it to have very poor performance. Parsing a 90000 line CSV file with ten fields per line takes around 8 seconds on my 2 GHz Xeon. The Python Standard Library csv module parses the same file in about 0.3 seconds.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/107907/rob-smallshire\u0026quot; title=\u0026quot;1,310 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Rob Smallshire\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment14737600_2322735\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-06-27 07:59:23Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 27, 2012 at 7:59\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Rob that\u0026apos;s interesting - what does the Python csv do differently?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/339843/tofutim\u0026quot; title=\u0026quot;21,424 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;tofutim\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment15103816_2322735\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-07-12 05:48:45Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 12, 2012 at 5:48\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@RobSmallshire it\u0026apos;s a simple example code not a high performance one. This code makes copies of all the fields per line. For higher performance you would use different options and return just references to fields in buffer instead of making copies.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/45654/stefanb\u0026quot; title=\u0026quot;73,557 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;stefanB\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment15187859_2322735\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-07-16 00:43:41Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 16, 2012 at 0:43\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Actually it is overkill, the compilation time hit is enormous and makes using Spirit for simple \u0026quot;micro-parsing tasks\u0026quot; unreasonable.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/765234/gerdiner\u0026quot; title=\u0026quot;1,295 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Gerdiner\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment18755196_1764367\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-12-02 00:37:45Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 2, 2012 at 0:37\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Also I\u0026apos;d like to point out that the code above does not parse CSV, it just parses a range of the type of the vector delimited by commas. It doesn\u0026apos;t handle quotes, varying types of columns etc. In short 19 votes for something that does answer the question at all seems a bit suspicious to me.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/765234/gerdiner\u0026quot; title=\u0026quot;1,295 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Gerdiner\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment18755225_1764367\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-12-02 00:40:04Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 2, 2012 at 0:40\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Gerdiner Nonsense. The compilation time hit for small parsers isnt that big, but its also irrelevant because you stuff the code into its own compilation unit and compile it \u0026lt;i\u0026gt;once\u0026lt;/i\u0026gt;. Then you only need to link it and thats as efficient as it gets. And as for your other comment, there are as many dialects of CSV as there are processors for it. This one certainly isnt a very useful dialect but it can be trivially extended to handle quoted values.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1968/konrad-rudolph\u0026quot; title=\u0026quot;508,410 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Konrad Rudolph\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment18884476_1764367\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-12-06 12:04:49Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 6, 2012 at 12:04\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@konrad: Simply including \u0026quot;#include \u0026amp;lt;boost/spirit/include/qi.hpp\u0026amp;gt;\u0026quot; in an empty file with only a main and nothing else takes 9.7sec with MSVC 2012 on a corei7 running at 2.ghz. It\u0026apos;s needless bloat. The accepted answer compiles in under 2secs on the same machine, I\u0026apos;d hate to imagine how long the \u0026apos;proper\u0026apos; Boost.Spirit example would take to compile.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/765234/gerdiner\u0026quot; title=\u0026quot;1,295 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Gerdiner\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment19809513_1764367\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-01-11 00:31:15Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 11, 2013 at 0:31\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Gerdiner I have to agree with you the overhead in using spirit for something as simple as cvs processing is far too great.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;span class=\u0026quot;comment-user\u0026quot;\u0026gt;user1781730\u0026lt;/span\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment33347891_1764367\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-02-25 00:48:11Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 25, 2014 at 0:48\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;AFAICT this won\u0026apos;t handle embedded quote marks correctly (e.g. \u0026quot;This string has \u0026quot;\u0026quot;embedded quote marks\u0026quot;\u0026quot;\u0026quot;,\u0026quot;foo\u0026quot;,1))\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/131930/jeremy-friesner\u0026quot; title=\u0026quot;64,271 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Jeremy Friesner\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment37547427_2481126\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-06-19 00:42:04Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 19, 2014 at 0:42\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Nice work, but you need to add three more things: (1) read header (2) provide fields indexing by name (3) don\u0026apos;t reallocate memory in loop by reusing the same vector of strings\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/737904/maksym-ganenko\u0026quot; title=\u0026quot;1,200 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Maksym Ganenko\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment77490787_44248193\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-07-23 10:14:57Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 23, 2017 at 10:14\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 3 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@MaksymGanenko I do #3. Could you elaborate on #2?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3772221/m0meni\u0026quot; title=\u0026quot;15,296 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;m0meni\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment77500154_44248193\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-07-23 18:48:23Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 23, 2017 at 18:48\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;It\u0026apos;s very useful to get fields not by position in a row, but by name given in the header (in the first row of CSV table). For example, I expect CSV table with \u0026quot;Date\u0026quot; field, but I don\u0026apos;t know what\u0026apos;s \u0026quot;Date\u0026quot; field index in a row.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/737904/maksym-ganenko\u0026quot; title=\u0026quot;1,200 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Maksym Ganenko\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment77512332_44248193\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-07-24 07:50:31Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 24, 2017 at 7:50\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@MaksymGanenko ah I see what you mean. There\u0026apos;s \u0026lt;a href=\u0026quot;https://github.com/ben-strasser/fast-cpp-csv-parser\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;github.com/ben-strasser/fast-cpp-csv-parser\u0026lt;/a\u0026gt; for when you know the columns of your CSV at compile time, and it\u0026apos;s probably better than mine. What I wanted was a CSV parser for the cases where you wanted to use the same code for many different CSVs and don\u0026apos;t know what they look like ahead of time. So I probably won\u0026apos;t add #2, but I will add #1 sometime in the future.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3772221/m0meni\u0026quot; title=\u0026quot;15,296 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;m0meni\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment77532890_44248193\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-07-24 16:12:00Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 24, 2017 at 16:12\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Seems great ... What about the status beta / production ?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/135549/neuro\u0026quot; title=\u0026quot;14,448 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;neuro\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment936502_1120165\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-07-13 15:30:57Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 13, 2009 at 15:30\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;The status is \u0026quot;in development\u0026quot;, as suggested by the version numbers. I really need more feed back from users before going to version 1.0. Plus I have a couple more features I want to add, to do with XML production from CSV.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;span class=\u0026quot;comment-user\u0026quot;\u0026gt;anon\u0026lt;/span\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment936535_1120165\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-07-13 15:36:35Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 13, 2009 at 15:36\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Bookmarking it, and will give it a try next time I have to deal with those wonderful standard CSV files ...\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/135549/neuro\u0026quot; title=\u0026quot;14,448 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;neuro\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment936581_1120165\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-07-13 15:44:00Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 13, 2009 at 15:44\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Nice, but it forces you to choose the number of columns at compile time. Not very useful for many applications.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/59557/quant-dev\u0026quot; title=\u0026quot;6,081 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;quant_dev\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment56691543_13924244\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-12-26 20:30:44Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 26, 2015 at 20:30\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;The github link to the same repository: \u0026lt;a href=\u0026quot;https://github.com/ben-strasser/fast-cpp-csv-parser\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;github.com/ben-strasser/fast-cpp-csv-parser\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1047213/hari\u0026quot; title=\u0026quot;1,073 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Hari\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment122650976_13924244\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2021-09-30 13:11:51Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 30, 2021 at 13:11\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;You may not care about inlining, because most of compilers decide it on its own. At least I am sure in Visual C++. It can inline method independently of your method specification.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2627487/mrpisarik\u0026quot; title=\u0026quot;1,159 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;MrPisarik\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment57899272_34109317\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-01-29 15:56:47Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 29, 2016 at 15:56\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;That\u0026apos;s precisely why I marked them explicitly. Gcc and Clang, the ones I mostly use, have as well their own conventions. A \u0026quot;inline\u0026quot; keyword should be just an incentive.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1749822/pietro-saccardi\u0026quot; title=\u0026quot;2,562 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Pietro Saccardi\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment57899402_34109317\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-01-29 15:59:19Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 29, 2016 at 15:59\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Nice work, but the library doesn\u0026apos;t work properly if header has empty labels. That\u0026apos;s typical for Excel/LibreOffice NxN table. Also, it may skip the last line of data. Unfortunately, your lib is not robust.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/737904/maksym-ganenko\u0026quot; title=\u0026quot;1,200 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Maksym Ganenko\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment77491251_44244394\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-07-23 10:46:25Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 23, 2017 at 10:46\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Thanks for the feedback @MaksymGanenko I\u0026apos;ve fixed the \u0026quot;last line of data\u0026quot; bug for final lines w/o trailing line break. As for the other issue mentioned - \u0026quot;headers with empty labels\u0026quot; - I\u0026apos;m not sure what it refers to? The library should handle empty labels (both quoted and non-quoted). It can also read CSV without header row/column, but then it requires the user to specify this (col title id -1 and row title id -1). Please provide some more details or report a bug at the GitHub page if you have some specific use-case you\u0026apos;d like to see supported. Thanks!\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/485047/d99kris\u0026quot; title=\u0026quot;405 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;d99kris\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment77527994_44244394\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-07-24 14:10:49Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 24, 2017 at 14:10\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Erm, why would there be \u0026lt;code\u0026gt;\u0026quot;,\\n\u0026quot;\u0026lt;/code\u0026gt; in the string?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/265521/timmmm\u0026quot; title=\u0026quot;79,027 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Timmmm\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment42536576_1125863\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-11-18 20:36:01Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 18, 2014 at 20:36\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Timmmm look up the substr method of the String class, and you\u0026apos;ll see that it takes multiple characters, \\n is the newline character, so it counts as a single character, in this instance. It doesn\u0026apos;t search for the entire value as a whole. It\u0026apos;s searching for each individual character; namely comma or newline. substr will return the position of the first character it finds, and -1 if it finds neither, which means it\u0026apos;s finished reading the line. fp keeps track of the position in the file internally, so each call to readCSV moves it one row at a time.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1777235/martyn-shutt\u0026quot; title=\u0026quot;1,623 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Martyn Shutt\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment49410266_1125863\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-06-05 19:23:25Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 5, 2015 at 19:23\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 3 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Another interesting library is \u0026lt;a href=\u0026quot;https://github.com/roman-kashitsyn/text-csv\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;github.com/roman-kashitsyn/text-csv\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/7471760/ferdymercury\u0026quot; title=\u0026quot;466 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;ferdymercury\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment113219752_44836669\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2020-09-23 11:19:13Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 23, 2020 at 11:19\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;this won\u0026apos;t handle commas in quotes\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3847691/ezee\u0026quot; title=\u0026quot;4,096 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Ezee\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment46744812_1443710\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-03-26 06:41:24Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 26, 2015 at 6:41\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Shouldn\u0026apos;t the compiler strip out everything that is non-essential?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/339843/tofutim\u0026quot; title=\u0026quot;21,424 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;tofutim\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment15103785_5836370\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-07-12 05:46:50Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 12, 2012 at 5:46\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        "],"id":402,"title":"How can I read and parse CSV files in C++?","content":"\n                \n\u0026lt;p\u0026gt;I need to load and use CSV file data in C++.  At this point it can really just be a comma-delimited parser (ie don\u0026apos;t worry about escaping new lines and commas).  The main need is a line-by-line parser that will return a vector for the next line each time the method is called.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I found this article which looks quite promising:\n\u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/1_35_0/libs/spirit/example/fundamental/list_parser.cpp\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://www.boost.org/doc/libs/1_35_0/libs/spirit/example/fundamental/list_parser.cpp\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;ve never used Boost\u0026apos;s Spirit, but am willing to try it. But only if there isn\u0026apos;t a more straightforward solution I\u0026apos;m overlooking.\u0026lt;/p\u0026gt;\n    ","slug":"how-can-i-read-and-parse-csv-files-in-c++-1657387869219","postType":"QUESTION","createdAt":"2022-07-09T17:31:09.000Z","updatedAt":"2022-07-09T17:31:09.000Z","tags":[{"id":2159,"name":"text","slug":"text","createdAt":"2022-07-09T17:31:09.000Z","updatedAt":"2022-07-09T17:31:09.000Z","Questions_Tags":{"questionId":402,"tagId":2159}},{"id":2160,"name":"csv","slug":"csv","createdAt":"2022-07-09T17:31:09.000Z","updatedAt":"2022-07-09T17:31:09.000Z","Questions_Tags":{"questionId":402,"tagId":2160}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"how-can-i-read-and-parse-csv-files-in-c++-1657387869219"},"buildId":"4Y8KGE-c2lolBeBmcum_I","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>