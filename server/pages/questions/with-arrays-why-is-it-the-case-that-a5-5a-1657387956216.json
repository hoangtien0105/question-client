{"pageProps":{"data":{"answer":["\n&lt;p&gt;The C standard defines the &lt;code&gt;[]&lt;/code&gt; operator as follows:&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;a[b] == *(a + b)&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;Therefore &lt;code&gt;a[5]&lt;/code&gt; will evaluate to:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;*(a + &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and &lt;code&gt;5[a]&lt;/code&gt; will evaluate to:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;*(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; + a)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;a&lt;/code&gt; is a pointer to the first element of the array. &lt;code&gt;a[5]&lt;/code&gt; is the value that&apos;s 5 &lt;strong&gt;elements&lt;/strong&gt; further from &lt;code&gt;a&lt;/code&gt;, which is the same as &lt;code&gt;*(a + 5)&lt;/code&gt;, and from elementary school math we know those are equal (addition is &lt;a href=&quot;https://en.wikipedia.org/wiki/commutative&quot; rel=&quot;noreferrer&quot;&gt;commutative&lt;/a&gt;).&lt;/p&gt;\n    ","\n&lt;p&gt;Because array access is defined in terms of pointers.  &lt;code&gt;a[i]&lt;/code&gt; is defined to mean &lt;code&gt;*(a + i)&lt;/code&gt;, which is commutative.&lt;/p&gt;\n    ","\n&lt;p&gt;I think something is being missed by the other answers.&lt;/p&gt;\n\n&lt;p&gt;Yes, &lt;code&gt;p[i]&lt;/code&gt; is by definition equivalent to &lt;code&gt;*(p+i)&lt;/code&gt;, which (because addition is commutative) is equivalent to &lt;code&gt;*(i+p)&lt;/code&gt;, which (again, by the definition of the &lt;code&gt;[]&lt;/code&gt; operator) is equivalent to &lt;code&gt;i[p]&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;(And in &lt;code&gt;array[i]&lt;/code&gt;, the array name is implicitly converted to a pointer to the array&apos;s first element.)&lt;/p&gt;\n\n&lt;p&gt;But the commutativity of addition is not all that obvious in this case.&lt;/p&gt;\n\n&lt;p&gt;When both operands are of the same type, or even of different numeric types that are promoted to a common type, commutativity makes perfect sense: &lt;code&gt;x + y == y + x&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;But in this case we&apos;re talking specifically about pointer arithmetic, where one operand is a pointer and the other is an integer. (Integer + integer is a different operation, and pointer + pointer is nonsense.)&lt;/p&gt;\n\n&lt;p&gt;The C standard&apos;s description of the &lt;code&gt;+&lt;/code&gt; operator (&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf&quot;&gt;N1570&lt;/a&gt; 6.5.6) says:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;For addition, either both operands shall have arithmetic type, or one\n  operand shall be a pointer to a complete object type and the other\n  shall have integer type.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;It could just as easily have said:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;For addition, either both operands shall have arithmetic type, or &lt;em&gt;the left&lt;/em&gt;\n  operand shall be a pointer to a complete object type and the &lt;em&gt;right operand&lt;/em&gt;\n  shall have integer type.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;in which case both &lt;code&gt;i + p&lt;/code&gt; and &lt;code&gt;i[p]&lt;/code&gt; would be illegal.&lt;/p&gt;\n\n&lt;p&gt;In C++ terms, we really have two sets of overloaded &lt;code&gt;+&lt;/code&gt; operators, which can be loosely described as:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;pointer operator+(pointer p, integer i);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;pointer operator+(integer i, pointer p);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;of which only the first is really necessary.&lt;/p&gt;\n\n&lt;p&gt;So why is it this way?&lt;/p&gt;\n\n&lt;p&gt;C++ inherited this definition from C, which got it from B (the commutativity of array indexing is explicitly mentioned in the 1972 &lt;a href=&quot;https://www.bell-labs.com/usr/dmr/www/kbman.html&quot;&gt;Users&apos; Reference to B&lt;/a&gt;), which got it from &lt;a href=&quot;https://www.bell-labs.com/usr/dmr/www/bcpl.html&quot;&gt;BCPL&lt;/a&gt; (manual dated 1967), which may well have gotten it from even earlier languages (CPL? Algol?).&lt;/p&gt;\n\n&lt;p&gt;So the idea that array indexing is defined in terms of addition, and that addition, even of a pointer and an integer, is commutative, goes back many decades, to C&apos;s ancestor languages.&lt;/p&gt;\n\n&lt;p&gt;Those languages were much less strongly typed than modern C is. In particular, the distinction between pointers and integers was often ignored. (Early C programmers sometimes used pointers as unsigned integers, before the &lt;code&gt;unsigned&lt;/code&gt; keyword was added to the language.) So the idea of making addition non-commutative because the operands are of different types probably wouldn&apos;t have occurred to the designers of those languages. If a user wanted to add two &quot;things&quot;, whether those &quot;things&quot; are integers, pointers, or something else, it wasn&apos;t up to the language to prevent it.&lt;/p&gt;\n\n&lt;p&gt;And over the years, any change to that rule would have broken existing code (though the 1989 ANSI C standard might have been a good opportunity).&lt;/p&gt;\n\n&lt;p&gt;Changing C and/or C++ to require putting the pointer on the left and the integer on the right might break some existing code, but there would be no loss of real expressive power.&lt;/p&gt;\n\n&lt;p&gt;So now we have &lt;code&gt;arr[3]&lt;/code&gt; and &lt;code&gt;3[arr]&lt;/code&gt; meaning exactly the same thing, though the latter form should never appear outside the &lt;a href=&quot;http://ioccc.org/&quot;&gt;IOCCC&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;And, of course&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt; (&lt;span class=&quot;hljs-string&quot;&gt;&quot;ABCD&quot;&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;] == &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&quot;ABCD&quot;&lt;/span&gt;]) &amp;amp;&amp;amp; (&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&quot;ABCD&quot;&lt;/span&gt;] == &lt;span class=&quot;hljs-string&quot;&gt;&apos;C&apos;&lt;/span&gt;) &amp;amp;&amp;amp; (&lt;span class=&quot;hljs-string&quot;&gt;&quot;ABCD&quot;&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;] == &lt;span class=&quot;hljs-string&quot;&gt;&apos;C&apos;&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The main reason for this was that back in the 70&apos;s when C was designed, computers didn&apos;t have much memory (64KB was a lot), so the C compiler didn&apos;t do much syntax checking.  Hence &quot;&lt;code&gt;X[Y]&lt;/code&gt;&quot; was rather blindly translated into &quot;&lt;code&gt;*(X+Y)&lt;/code&gt;&quot;  &lt;/p&gt;\n\n&lt;p&gt;This also explains the &quot;&lt;code&gt;+=&lt;/code&gt;&quot; and &quot;&lt;code&gt;++&lt;/code&gt;&quot; syntaxes.  Everything in the form &quot;&lt;code&gt;A = B + C&lt;/code&gt;&quot; had the same compiled form.  But, if B was the same object as A, then an assembly level optimization was available.  But the compiler wasn&apos;t bright enough to recognize it, so the developer had to (&lt;code&gt;A += C&lt;/code&gt;).   Similarly, if &lt;code&gt;C&lt;/code&gt; was &lt;code&gt;1&lt;/code&gt;, a different assembly level optimization was available, and again the developer had to make it explicit, because the compiler didn&apos;t recognize it.   (More recently compilers do, so those syntaxes are largely unnecessary these days)&lt;/p&gt;\n    ","\n&lt;p&gt;One thing no-one seems to have mentioned about Dinah&apos;s problem with &lt;code&gt;sizeof&lt;/code&gt;:&lt;/p&gt;\n\n&lt;p&gt;You can only add an integer to a pointer, you can&apos;t add two pointers together. That way when adding a pointer to an integer, or an integer to a pointer, the compiler always knows which bit has a size that needs to be taken into account.&lt;/p&gt;\n    ","\n&lt;p&gt;To answer the question literally. It is not always true that &lt;code&gt;x == x&lt;/code&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; zero = &lt;span class=&quot;hljs-number&quot;&gt;0.0&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; a[] = { &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, zero/zero}; &lt;span class=&quot;hljs-comment&quot;&gt;// NaN&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; (a[&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;] == &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;[a] ? &lt;span class=&quot;hljs-string&quot;&gt;&quot;true&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;false&quot;&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;endl&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;prints&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I just find out this ugly syntax could be &quot;useful&quot;, or at least very fun to play with when you want to deal with an array of indexes which refer to positions into the same array. It can replace nested square brackets and make the code more readable !&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a[] = { &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; , &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; , &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; , &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; , &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; };\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; s = &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; a / &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; *a;  &lt;span class=&quot;hljs-comment&quot;&gt;//  s == 5&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; ; i &amp;lt; s ; ++i) {  \n           \n    &lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; a[a[a[i]]] &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;endl&lt;/span&gt;;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// ... is equivalent to ...&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; i[a][a][a] &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;endl&lt;/span&gt;;  &lt;span class=&quot;hljs-comment&quot;&gt;// but I prefer this one, it&apos;s easier to increase the level of indirection (without loop)&lt;/span&gt;\n    \n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Of course, I&apos;m quite sure that there is no use case for that in real code, but I found it interesting anyway :)&lt;/p&gt;\n    ","\n&lt;p&gt;Nice question/answers.&lt;/p&gt;\n\n&lt;p&gt;Just want to point out that C pointers and arrays are not the &lt;em&gt;same&lt;/em&gt;, although in this case the difference is not essential. &lt;/p&gt;\n\n&lt;p&gt;Consider the following declarations:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;];\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;* p = a;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In &lt;code&gt;a.out&lt;/code&gt;, the symbol &lt;code&gt;a&lt;/code&gt; is at an address that&apos;s the beginning of the array, and symbol &lt;code&gt;p&lt;/code&gt; is at an address where a pointer is stored, and the value of the pointer at that memory location is the beginning of the array. &lt;/p&gt;\n    ","\n&lt;p&gt;For pointers in C, we have&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;a[&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;] == *(a + &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and also&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;[a] == *(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; + a)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Hence it is true that &lt;code&gt;a[5] == 5[a].&lt;/code&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Not an answer, but just some food for thought.\nIf class is having overloaded index/subscript operator, the expression &lt;code&gt;0[x]&lt;/code&gt; will not work:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Sub&lt;/span&gt;\n{&lt;/span&gt;\npublic:\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; operator [](&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; nIndex)\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n    }   \n};\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n{\n    Sub s;\n    s[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;];\n    &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;[s]; &lt;span class=&quot;hljs-comment&quot;&gt;// ERROR &lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Since we dont have access to &lt;strong&gt;int&lt;/strong&gt; class, this cannot be done:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;int&lt;/span&gt;\n{&lt;/span&gt;\n   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; operator[](&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; Sub&amp;amp;);\n};\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;It has very good explanation in &lt;em&gt;A TUTORIAL ON POINTERS AND ARRAYS IN C&lt;/em&gt;\nby Ted Jensen.&lt;/p&gt;\n\n&lt;p&gt;Ted Jensen explained it as:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;In fact, this is true, i.e wherever one writes &lt;code&gt;a[i]&lt;/code&gt; it can be\n  replaced with &lt;code&gt;*(a + i)&lt;/code&gt;  without any problems. In fact, the compiler\n  will create the same code in either case. Thus we see that pointer\n  arithmetic is the same thing as array indexing. Either syntax produces\n  the same result.&lt;/p&gt;\n  \n  &lt;p&gt;This is NOT saying that pointers and arrays\n  are the same thing, they are not. We are only saying that to identify\n  a given element of an array we have the choice of two syntaxes, one\n  using array indexing and the other using pointer arithmetic, which\n  yield identical results.&lt;/p&gt;\n  \n  &lt;p&gt;Now, looking at this last\n  expression, part of it.. &lt;code&gt;(a + i)&lt;/code&gt;, is a simple addition using the +\n  operator and the rules of C state that such an expression is\n  commutative. That is (a + i) is identical to &lt;code&gt;(i + a)&lt;/code&gt;. Thus we could\n  write &lt;code&gt;*(i + a)&lt;/code&gt; just as easily as &lt;code&gt;*(a + i)&lt;/code&gt;.\n  But &lt;code&gt;*(i + a)&lt;/code&gt; could have come from &lt;code&gt;i[a]&lt;/code&gt; ! From all of this comes the curious\n  truth that if:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;];\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;p&gt;writing&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;a[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;] = &lt;span class=&quot;hljs-string&quot;&gt;&apos;x&apos;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;p&gt;is the same as writing&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;[a] = &lt;span class=&quot;hljs-string&quot;&gt;&apos;x&apos;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;I know the question is answered, but I couldn&apos;t resist sharing this explanation.&lt;/p&gt;\n\n&lt;p&gt;I remember Principles of Compiler design,\nLet&apos;s assume &lt;code&gt;a&lt;/code&gt; is an &lt;code&gt;int&lt;/code&gt; array and size of &lt;code&gt;int&lt;/code&gt; is 2 bytes,\n&amp;amp; Base address for &lt;code&gt;a&lt;/code&gt; is 1000.&lt;/p&gt;\n\n&lt;p&gt;How &lt;code&gt;a[5]&lt;/code&gt; will work -&amp;gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;Base Address of your Array a + (&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;*size of(data type &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;array&lt;/span&gt; a))\ni.e. &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt; + (&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;*&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) = &lt;span class=&quot;hljs-number&quot;&gt;1010&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So, &lt;/p&gt;\n\n&lt;p&gt;Similarly when the c code is broken down into 3-address code, \n&lt;code&gt;5[a]&lt;/code&gt; will become -&amp;gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;Base Address of your Array a + (size of(data type &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;array&lt;/span&gt; a)*&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;)\ni.e. &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt; + (&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;*&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;) = &lt;span class=&quot;hljs-number&quot;&gt;1010&lt;/span&gt; \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So basically both the statements are pointing to the same location in memory and hence, &lt;code&gt;a[5] = 5[a]&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;This explanation is also the reason why negative indexes in arrays work in C.&lt;/p&gt;\n\n&lt;p&gt;i.e. if I access &lt;code&gt;a[-5]&lt;/code&gt; it will give me&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;Base Address of your Array a + (&lt;span class=&quot;hljs-number&quot;&gt;-5&lt;/span&gt; * size of(data type &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;array&lt;/span&gt; a))\ni.e. &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt; + (&lt;span class=&quot;hljs-number&quot;&gt;-5&lt;/span&gt;*&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) = &lt;span class=&quot;hljs-number&quot;&gt;990&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It will return me object at location 990.&lt;/p&gt;\n    ","\n&lt;p&gt;in c compiler &lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;a[i]\ni[a]\n*(a+i)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;are different ways to refer to  an element in an array ! (NOT AT ALL WEIRD)&lt;/p&gt;\n    ","\n&lt;p&gt;In C arrays, &lt;code&gt;arr[3]&lt;/code&gt; and &lt;code&gt;3[arr]&lt;/code&gt; are the same, and their equivalent pointer notations are &lt;code&gt;*(arr + 3)&lt;/code&gt; to &lt;code&gt;*(3 + arr)&lt;/code&gt;. But on the contrary &lt;code&gt;[arr]3&lt;/code&gt; or &lt;code&gt;[3]arr&lt;/code&gt; is not correct and will result into syntax error, as &lt;code&gt;(arr + 3)*&lt;/code&gt; and &lt;code&gt;(3 + arr)*&lt;/code&gt; are not valid expressions. The reason is dereference operator should be placed before the address yielded by the expression, not after the address.&lt;/p&gt;\n    ","\n&lt;p&gt;A little bit of history now.  Among other languages, BCPL had a fairly major influence on C&apos;s early development.  If you declared an array in BCPL with something like:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;let V = vec &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;that actually allocated 11 words of memory, not 10.  Typically V was the first, and contained the address of the immediately following word.  So unlike C, naming V went to that location and picked up the address of the zeroeth element of the array.  Therefore array indirection in BCPL, expressed as&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;let J = V!&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;really did have to do &lt;code&gt;J = !(V + 5)&lt;/code&gt; (using BCPL syntax) since it was necessary to fetch V to get the base address of the array.  Thus &lt;code&gt;V!5&lt;/code&gt; and &lt;code&gt;5!V&lt;/code&gt; were synonymous.  As an anecdotal observation, WAFL (Warwick Functional Language) was written in BCPL, and to the best of my memory tended to use the latter syntax rather than the former for accessing the nodes used as data storage.  Granted this is from somewhere between 35 and 40 years ago, so my memory is a little rusty. :)&lt;/p&gt;\n\n&lt;p&gt;The innovation of dispensing with the extra word of storage and having the compiler insert the base address of the array when it was named came later.  According to the C history paper this happened at about the time structures were added to C.&lt;/p&gt;\n\n&lt;p&gt;Note that &lt;code&gt;!&lt;/code&gt; in BCPL was both a unary prefix operator and a binary infix operator, in both cases doing indirection. just that the binary form included an addition of the two operands before doing the indirection.  Given the word oriented nature of BCPL (and B) this actually made a lot of sense.  The restriction of &quot;pointer and integer&quot; was made necessary in C when it gained data types, and &lt;code&gt;sizeof&lt;/code&gt; became a thing.&lt;/p&gt;\n    ","\n&lt;p&gt;Well, this is a feature that is only possible because of the language support.&lt;/p&gt;\n\n&lt;p&gt;The compiler interprets &lt;code&gt;a[i]&lt;/code&gt; as &lt;code&gt;*(a+i)&lt;/code&gt; and the expression &lt;code&gt;5[a]&lt;/code&gt; evaluates to &lt;code&gt;*(5+a)&lt;/code&gt;. Since addition is commutative it turns out that both are equal. Hence the expression evaluates to &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;In C&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a[]={&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;40&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;};\n &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *p=a;\n &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;,*p++);&lt;span class=&quot;hljs-comment&quot;&gt;//output will be 10&lt;/span&gt;\n &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;,*a++);&lt;span class=&quot;hljs-comment&quot;&gt;//will give an error&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Pointer &lt;code&gt;p&lt;/code&gt; is a &quot;variable&quot;, array name &lt;code&gt;a&lt;/code&gt; is a &quot;mnemonic&quot; or &quot;synonym&quot;,\nso &lt;code&gt;p++&lt;/code&gt; is valid but &lt;code&gt;a++&lt;/code&gt; is invalid.&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;a[2]&lt;/code&gt; is equals to &lt;code&gt;2[a]&lt;/code&gt; because the internal operation on both of this is &quot;Pointer Arithmetic&quot; internally calculated as &lt;code&gt;*(a+2)&lt;/code&gt; equals &lt;code&gt;*(2+a)&lt;/code&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Because C compiler always convert array notation in pointer notation.\n&lt;code&gt;a[5] = *(a + 5)&lt;/code&gt;  also &lt;code&gt;5[a] = *(5 + a) = *(a + 5)&lt;/code&gt;\nSo, both are equal.&lt;/p&gt;\n    ","\n&lt;p&gt;Because it&apos;s useful to avoid confusing nesting.&lt;/p&gt;\n&lt;p&gt;Would you rather read this:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;array&lt;/span&gt;[&lt;span class=&quot;hljs-built_in&quot;&gt;array&lt;/span&gt;[head].next].prev\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;or this:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;head[&lt;span class=&quot;hljs-built_in&quot;&gt;array&lt;/span&gt;].next[&lt;span class=&quot;hljs-built_in&quot;&gt;array&lt;/span&gt;].prev\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Incidentally, C++ has a similar commutative property for function calls. Rather than writing &lt;code&gt;g(f(x))&lt;/code&gt; as you must in C, you may use member functions to write &lt;code&gt;x.f().g()&lt;/code&gt;. Replace f and g with lookup tables and you can write &lt;code&gt;g[f[x]]&lt;/code&gt; (functional style) or &lt;code&gt;(x[f])[g]&lt;/code&gt; (oop style). The latter gets really nice with structs containing indices: &lt;code&gt;x[xs].y[ys].z[zs]&lt;/code&gt;. Using the more common notation that&apos;s &lt;code&gt;zs[ys[xs[x].y].z]&lt;/code&gt;.&lt;/p&gt;\n    "],"comment":["\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;would something like a[+] also work like *( a++) OR  *(++a) ?&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/220669/egon&quot; title=&quot;3,580 reputation&quot; class=&quot;comment-user&quot;&gt;Egon&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment2869230_381542&quot;&gt;&lt;span title=&quot;2010-05-13 16:14:09Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;May 13, 2010 at 16:14&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Egon: That&apos;s very creative but unfortunately that&apos;s not how compilers work. The compiler interprets &lt;code&gt;a[1]&lt;/code&gt; as a series of tokens, not strings: *({integer location of}a {operator}+ {integer}1) is the same as *({integer}1 {operator}+ {integer location of}a) but is not the same as *({integer location of}a {operator}+ {operator}+)&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/356/dinah&quot; title=&quot;51,232 reputation&quot; class=&quot;comment-user owner&quot;&gt;Dinah&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment2869755_381542&quot;&gt;&lt;span title=&quot;2010-05-13 17:24:52Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;May 13, 2010 at 17:24&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;An interesting compound variation on this is illustrated in &lt;a href=&quot;http://stackoverflow.com/questions/8910837/why-does-this-work-illogical-array-access&quot;&gt;Illogical array access&lt;/a&gt;, where you have &lt;code&gt;char bar[]; int foo[];&lt;/code&gt; and &lt;code&gt;foo[i][bar]&lt;/code&gt; is used as an expression.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/15168/jonathan-leffler&quot; title=&quot;700,796 reputation&quot; class=&quot;comment-user&quot;&gt;Jonathan Leffler&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment17519706_381542&quot;&gt;&lt;span title=&quot;2012-10-17 06:38:19Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Oct 17, 2012 at 6:38&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@EldritchConundrum, why do you think &apos;the compiler cannot check that the left part is a pointer&apos;? Yes, it can. It&apos;s true that &lt;code&gt;a[b]&lt;/code&gt; = &lt;code&gt;*(a + b)&lt;/code&gt; for any given &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, but it was the language designers&apos; free choice for &lt;code&gt;+&lt;/code&gt; to be defined commutative for all types. Nothing could prevent them from forbidding &lt;code&gt;i + p&lt;/code&gt; while allowing &lt;code&gt;p + i&lt;/code&gt;.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/2623659/ach&quot; title=&quot;2,244 reputation&quot; class=&quot;comment-user&quot;&gt;ach&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment34081716_381542&quot;&gt;&lt;span title=&quot;2014-03-14 19:46:59Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 14, 2014 at 19:46&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Andrey One usually expects &lt;code&gt;+&lt;/code&gt; to be commutative, so maybe the real problem is choosing to make pointer operations resemble arithmetic, instead of designing a separate offset operator.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/278044/eldritch-conundrum&quot; title=&quot;8,182 reputation&quot; class=&quot;comment-user&quot;&gt;Eldritch Conundrum&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment34190749_381542&quot;&gt;&lt;span title=&quot;2014-03-18 10:36:58Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 18, 2014 at 10:36&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;I wonder if it isn&apos;t more like  *((5 * sizeof(a)) + a).  Great explaination though.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/29043/john-macintyre&quot; title=&quot;12,838 reputation&quot; class=&quot;comment-user&quot;&gt;John MacIntyre&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment209120_381549&quot;&gt;&lt;span title=&quot;2008-12-19 17:06:42Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Dec 19, 2008 at 17:06&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Dinah: From a C-compiler perspective, you are right. No sizeof is needed and those expressions I mentioned are THE SAME. However, the compiler will take sizeof into account when producing machine code. If a is an int array, &lt;code&gt;a[5]&lt;/code&gt; will compile to something like &lt;code&gt;mov eax, [ebx+20]&lt;/code&gt; instead of &lt;code&gt;[ebx+5]&lt;/code&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/33708/mmx&quot; title=&quot;403,525 reputation&quot; class=&quot;comment-user&quot;&gt;mmx&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment209151_381549&quot;&gt;&lt;span title=&quot;2008-12-19 17:18:23Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Dec 19, 2008 at 17:18&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 2 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Dinah: A is an address, say 0x1230.  If a was in 32-bit int array, then a[0] is at 0x1230, a[1] is at 0x1234, a[2] at 0x1238...a[5] at x1244 etc.  If we just add 5 to 0x1230, we get 0x1235, which is wrong.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/12725/james-curran&quot; title=&quot;98,930 reputation&quot; class=&quot;comment-user&quot;&gt;James Curran&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment209161_381549&quot;&gt;&lt;span title=&quot;2008-12-19 17:21:39Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Dec 19, 2008 at 17:21&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@sr105: That&apos;s a special case for the + operator, where one of the operands is a pointer and the other an integer. The standard says that the result will be of the type of the pointer. The compiler /has to be/ smart enough.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1088/aib&quot; title=&quot;43,421 reputation&quot; class=&quot;comment-user&quot;&gt;aib&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment215485_381549&quot;&gt;&lt;span title=&quot;2008-12-23 02:08:05Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Dec 23, 2008 at 2:08&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;&quot;from elementary school math we know those are equal&quot; - I understand that you are simplifying, but I&apos;m with those who feel like this is &lt;i&gt;over&lt;/i&gt;simplifying. It&apos;s not elementary that &lt;code&gt;*(10 + (int *)13) != *((int *)10 + 13)&lt;/code&gt;. In other words, there&apos;s more going on here than elementary school arithmetic. The commutativity relies critically on the compiler recognizing which operand is a pointer (and to what size of object). To put it another way, &lt;code&gt;(1 apple + 2 oranges) = (2 oranges + 1 apple)&lt;/code&gt;, but &lt;code&gt;(1 apple + 2 oranges) != (1 orange + 2 apples)&lt;/code&gt;.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/423105/larsh&quot; title=&quot;26,696 reputation&quot; class=&quot;comment-user&quot;&gt;LarsH&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment4704431_381549&quot;&gt;&lt;span title=&quot;2010-12-01 20:54:34Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Dec 1, 2010 at 20:54&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 4 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Arrays are not defined in terms of pointers, but &lt;i&gt;access&lt;/i&gt; to them is.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/560648/lightness-races-in-orbit&quot; title=&quot;369,871 reputation&quot; class=&quot;comment-user&quot;&gt;Lightness Races in Orbit&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment6910264_381551&quot;&gt;&lt;span title=&quot;2011-05-12 23:20:41Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;May 12, 2011 at 23:20&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;I would add &quot;so it is equal to &lt;code&gt;*(i + a)&lt;/code&gt;, which can be written as &lt;code&gt;i[a]&lt;/code&gt;&quot;.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/544557/jim-balter&quot; title=&quot;15,594 reputation&quot; class=&quot;comment-user&quot;&gt;Jim Balter&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment22546148_381551&quot;&gt;&lt;span title=&quot;2013-04-05 22:11:18Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 5, 2013 at 22:11&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;I would suggest you include the quote from the standard, which is as follows:  6.5.2.1: 2      A postfix expression followed by an expression in square brackets [] is a subscripted designation of an element of an array object. The definition of the subscript operator [] is that E1[E2] is identical to (*((E1)+(E2))). Because of the conversion rules that apply to the binary + operator, if E1 is an array object (equivalently, a pointer to the initial element of an array object) and E2 is an integer, E1[E2] designates the E2-th element of E1 (counting from zero).&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/3323096/vality&quot; title=&quot;6,472 reputation&quot; class=&quot;comment-user&quot;&gt;Vality&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment45453039_381551&quot;&gt;&lt;span title=&quot;2015-02-17 21:41:13Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Feb 17, 2015 at 21:41&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Nitpick: It doesn&apos;t make sense to say that &quot;&lt;code&gt;*(a + i)&lt;/code&gt; is commutative&quot;. However, &lt;code&gt;*(a + i) = *(i + a) = i[a]&lt;/code&gt; because &lt;i&gt;addition&lt;/i&gt; is commutative.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/282848/andreas-rejbrand&quot; title=&quot;101,692 reputation&quot; class=&quot;comment-user&quot;&gt;Andreas Rejbrand&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment103086588_381551&quot;&gt;&lt;span title=&quot;2019-10-13 22:18:49Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Oct 13, 2019 at 22:18&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@AndreasRejbrand OTOH &lt;code&gt;+&lt;/code&gt; is the only binary operator in the expression, so it&apos;s rather clear what can be commutative at all.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/6607497/u-windl&quot; title=&quot;2,919 reputation&quot; class=&quot;comment-user&quot;&gt;U. Windl&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment114363502_381551&quot;&gt;&lt;span title=&quot;2020-11-04 13:03:53Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Nov 4, 2020 at 13:03&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Fantastic description of this property. From a high level view, I think &lt;code&gt;3[arr]&lt;/code&gt; is an interesting artifact but should rarely if ever be used. The accepted answer to this question (&amp;lt;&lt;a href=&quot;http://stackoverflow.com/q/1390365/356&gt;&quot;&gt;stackoverflow.com/q/1390365/356&amp;gt;&lt;/a&gt;) which I asked a while back has changed the way I&apos;ve thought about syntax. Although there&apos;s often technically not a right and wrong way to do these things, these kinds of features start you thinking in a way which is separate from the implementation details. There&apos;s benefit to this different way of thinking which is in part lost when you fixate on the implementation details.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/356/dinah&quot; title=&quot;51,232 reputation&quot; class=&quot;comment-user owner&quot;&gt;Dinah&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment27049877_18393343&quot;&gt;&lt;span title=&quot;2013-08-24 01:01:54Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Aug 24, 2013 at 1:01&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Addition is commutative. For the C standard to define it otherwise would be strange. That&apos;s why it could not just as easily said &quot;For addition, either both operands shall have arithmetic type, or the left operand shall be a pointer to a complete object type and the right operand shall have integer type.&quot; - That wouldn&apos;t make sense to most people who add things.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/2250588/iheanyi&quot; title=&quot;3,077 reputation&quot; class=&quot;comment-user&quot;&gt;iheanyi&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment35491389_18393343&quot;&gt;&lt;span title=&quot;2014-04-21 17:54:14Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 21, 2014 at 17:54&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@iheanyi: Addition is usually commutative -- and it usually takes two operands of the same type. Pointer addition lets you add a pointer and an integer, but not two pointers.  IMHO that&apos;s already a sufficiently odd special case that requiring the pointer to be the left operand wouldn&apos;t be a significant burden. (Some languages use &quot;+&quot; for string concatenation; that&apos;s certainly not commutative.)&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/827263/keith-thompson&quot; title=&quot;243,248 reputation&quot; class=&quot;comment-user&quot;&gt;Keith Thompson&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment35492036_18393343&quot;&gt;&lt;span title=&quot;2014-04-21 18:13:58Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 21, 2014 at 18:13&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@supercat, That&apos;s even worse. That would mean that sometimes x + 1 != 1 + x. That would completely violate the associative property of addition.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/2250588/iheanyi&quot; title=&quot;3,077 reputation&quot; class=&quot;comment-user&quot;&gt;iheanyi&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment41617237_18393343&quot;&gt;&lt;span title=&quot;2014-10-21 16:34:59Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Oct 21, 2014 at 16:34&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@iheanyi: I think you meant commutative property; addition is already not associative, since on most implementations (1LL+1U)-2 != 1LL+(1U-2).  Indeed, the change would make some situations associative which presently aren&apos;t, e.g. 3U+(UINT_MAX-2L) would equal (3U+UINT_MAX)-2.  What would be best, though, is for the language to have add new distinct types for promotable integers and &quot;wrapping&quot; algebraic rings, so that adding 2 to a &lt;code&gt;ring16_t&lt;/code&gt; which holds 65535 would yield a &lt;code&gt;ring16_t&lt;/code&gt; with value 1, &lt;i&gt;independent of the size of &lt;code&gt;int&lt;/code&gt;&lt;/i&gt;.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment41617617_18393343&quot;&gt;&lt;span title=&quot;2014-10-21 16:46:00Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Oct 21, 2014 at 16:46&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Actually, that evaluates to false;  the first term &quot;ABCD&quot;[2] == 2[&quot;ABCD&quot;] evaluates to true, or 1, and 1 != &apos;C&apos; :D&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/15168/jonathan-leffler&quot; title=&quot;700,796 reputation&quot; class=&quot;comment-user&quot;&gt;Jonathan Leffler&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment209145_381554&quot;&gt;&lt;span title=&quot;2008-12-19 17:16:12Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Dec 19, 2008 at 17:16&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Jonathan: same ambiguity lead to the editing of the original title of this post. Are we the equal marks mathematical equivalency, code syntax, or pseudo-code. I argue mathematical equivalency but since we&apos;re talking about code, we can&apos;t escape that we&apos;re viewing everything in terms of code syntax.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/356/dinah&quot; title=&quot;51,232 reputation&quot; class=&quot;comment-user owner&quot;&gt;Dinah&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment209175_381554&quot;&gt;&lt;span title=&quot;2008-12-19 17:26:03Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Dec 19, 2008 at 17:26&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Isn&apos;t this a myth? I mean that the += and ++ operators were created to simplify for the compiler? Some code gets clearer with them, and it is useful syntax to have, no matter what the compiler does with it.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/15727/thomas-padron-mccarthy&quot; title=&quot;26,463 reputation&quot; class=&quot;comment-user&quot;&gt;Thomas Padron-McCarthy&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment209208_381554&quot;&gt;&lt;span title=&quot;2008-12-19 17:44:13Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Dec 19, 2008 at 17:44&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;+= and ++ has another significant benefit. if the left hand side changes some variable while evaluated, the change will only done once. a = a + ...; will do it twice.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/34509/johannes-schaub-litb&quot; title=&quot;482,727 reputation&quot; class=&quot;comment-user&quot;&gt;Johannes Schaub - litb&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment209224_381554&quot;&gt;&lt;span title=&quot;2008-12-19 17:49:27Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Dec 19, 2008 at 17:49&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;No - &quot;ABCD&quot;[2] == *(&quot;ABCD&quot; + 2) = *(&quot;CD&quot;) = &apos;C&apos;. Dereferencing a string gives you a char, not a substring&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/15416/msalters&quot; title=&quot;168,160 reputation&quot; class=&quot;comment-user&quot;&gt;MSalters&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment1301172_381554&quot;&gt;&lt;span title=&quot;2009-09-21 10:34:38Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Sep 21, 2009 at 10:34&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;There&apos;s a fairly exhaustive conversation about this in the comments of the accepted answer. I referenced said conversation in the edit to the original question but did not directly address your very valid concern of sizeof. Not sure how to best do this in SO. Should I make another edit to the orig. question?&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/356/dinah&quot; title=&quot;51,232 reputation&quot; class=&quot;comment-user owner&quot;&gt;Dinah&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment583799_537448&quot;&gt;&lt;span title=&quot;2009-04-21 13:51:49Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Apr 21, 2009 at 13:51&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;I&apos;d like to note that you cannot &lt;i&gt;add&lt;/i&gt; pointers, but you can &lt;i&gt;subtract&lt;/i&gt; pointers (returning the number of items between).&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/6607497/u-windl&quot; title=&quot;2,919 reputation&quot; class=&quot;comment-user&quot;&gt;U. Windl&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment114363681_537448&quot;&gt;&lt;span title=&quot;2020-11-04 13:10:19Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Nov 4, 2020 at 13:10&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Actually a &quot;nan&quot; is not equal to itself: &lt;code&gt;cout &amp;lt;&amp;lt; (a[5] == a[5] ? &quot;true&quot; : &quot;false&quot;) &amp;lt;&amp;lt; endl;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/2156952/truey&quot; title=&quot;7,100 reputation&quot; class=&quot;comment-user&quot;&gt;TrueY&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment23103158_7027053&quot;&gt;&lt;span title=&quot;2013-04-23 09:34:43Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 23, 2013 at 9:34&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@TrueY: He did state that specifically for the NaN case (and specifically that &lt;code&gt;x == x&lt;/code&gt; is not always true). I think that was his intention. So he is &lt;i&gt;technically&lt;/i&gt; correct (and possibly, as they say, the best kind of correct!).&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/485088/tim-%c4%8cas&quot; title=&quot;9,868 reputation&quot; class=&quot;comment-user&quot;&gt;Tim Čas&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment45302778_7027053&quot;&gt;&lt;span title=&quot;2015-02-13 01:04:07Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Feb 13, 2015 at 1:04&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;The question is about C, your code is not C code. There is also a &lt;code&gt;NAN&lt;/code&gt; in &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt;, which is better than &lt;code&gt;0.0/0.0&lt;/code&gt;, because &lt;code&gt;0.0/0.0&lt;/code&gt; is UB when &lt;code&gt;__STDC_IEC_559__&lt;/code&gt; is not defined (Most implementations do not define &lt;code&gt;__STDC_IEC_559__&lt;/code&gt;, but on most implementations &lt;code&gt;0.0/0.0&lt;/code&gt; will still work)&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/6082851/12431234123412341234123&quot; title=&quot;1,981 reputation&quot; class=&quot;comment-user&quot;&gt;12431234123412341234123&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment87685380_7027053&quot;&gt;&lt;span title=&quot;2018-05-14 16:02:41Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;May 14, 2018 at 16:02&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;When you see &lt;code&gt;i[a][a][a]&lt;/code&gt; you think i is either a pointer to an array or an array of a pointer to an array or a array ... and &lt;code&gt;a&lt;/code&gt; is a index. When you see &lt;code&gt;a[a[a[i]]]&lt;/code&gt;, you think a is a pointer to a array or a array and &lt;code&gt;i&lt;/code&gt; is a index.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/6082851/12431234123412341234123&quot; title=&quot;1,981 reputation&quot; class=&quot;comment-user&quot;&gt;12431234123412341234123&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment87675343_10971834&quot;&gt;&lt;span title=&quot;2018-05-14 11:58:02Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;May 14, 2018 at 11:58&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Wow! It&apos;s very cool usage of this &quot;stupid&quot; feature. Could be useful in algorithmic contest in some problems))&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/9951331/serge-breusov&quot; title=&quot;1,186 reputation&quot; class=&quot;comment-user&quot;&gt;Serge Breusov&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment89145830_10971834&quot;&gt;&lt;span title=&quot;2018-06-28 08:53:18Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 28, 2018 at 8:53&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;The question is about C, your code is not C code.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/6082851/12431234123412341234123&quot; title=&quot;1,981 reputation&quot; class=&quot;comment-user&quot;&gt;12431234123412341234123&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment121491410_10971834&quot;&gt;&lt;span title=&quot;2021-08-11 15:15:21Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Aug 11, 2021 at 15:15&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;No, technically they are not the same. If you define some b as int*const and make it point to an array, it is still a pointer, meaning that in the symbol table, b refers to a memory location that stores an address, which in turn points to where the array is.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/47707/polythinker&quot; title=&quot;5,106 reputation&quot; class=&quot;comment-user&quot;&gt;PolyThinker&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment213302_383088&quot;&gt;&lt;span title=&quot;2008-12-22 05:42:16Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Dec 22, 2008 at 5:42&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Very good point. I remember having a very nasty bug when I defined a global symbol as char s[100] in one module, declare it as extern char *s; in another module. After linking it all together the program behaved very strangely. Because the module using the extern declaration was using the initial bytes of the array as a pointer to char.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/815409/giorgio&quot; title=&quot;4,795 reputation&quot; class=&quot;comment-user&quot;&gt;Giorgio&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment13444351_383088&quot;&gt;&lt;span title=&quot;2012-05-02 18:15:33Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;May 2, 2012 at 18:15&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Originally, in C&apos;s grandparent BCPL, an array was a pointer.  That is, what you got when you wrote (I have transliterated to C) &lt;code&gt;int a[10]&lt;/code&gt; was a pointer called &apos;a&apos;, which pointed to enough store for 10 integers, elsewhere.  Thus a+i and j+i had the same form: add the contents of a couple of memory locations.  In fact, I think BCPL was typeless, so they were identical. And the sizeof-type scaling did not apply, since BCPL was purely word-oriented (on word-addressed machines also).&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1349603/dave&quot; title=&quot;131 reputation&quot; class=&quot;comment-user&quot;&gt;dave&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment13452413_383088&quot;&gt;&lt;span title=&quot;2012-05-03 02:33:10Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;May 3, 2012 at 2:33&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;I think the best way to understand the difference is to compare &lt;code&gt;int*p = a;&lt;/code&gt; to &lt;code&gt;int b = 5;&lt;/code&gt;  In the latter, &quot;b&quot; and &quot;5&quot; are both integers, but &quot;b&quot; is a variable, while &quot;5&quot; is a fixed value.  Similarly, &quot;p&quot; &amp;amp; &quot;a&quot; are both addresses of a character, but &quot;a&quot; is a fixed value.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/12725/james-curran&quot; title=&quot;98,930 reputation&quot; class=&quot;comment-user&quot;&gt;James Curran&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment21712913_383088&quot;&gt;&lt;span title=&quot;2013-03-12 16:34:28Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 12, 2013 at 16:34&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;While this &quot;answer&quot; does not answer the question (and thus should be a comment, not an answer), you could summarize as &quot;an array is not an lvalue, but a pointer is&quot;.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/6607497/u-windl&quot; title=&quot;2,919 reputation&quot; class=&quot;comment-user&quot;&gt;U. Windl&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment114363814_383088&quot;&gt;&lt;span title=&quot;2020-11-04 13:15:43Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Nov 4, 2020 at 13:15&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;&lt;code&gt;class Sub { public:     int operator[](size_t nIndex) const     {         return 0;     }        friend int operator[](size_t nIndex, const Sub&amp;amp; This)     {         return 0;     }    };&lt;/code&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/103167/ben-voigt&quot; title=&quot;270,543 reputation&quot; class=&quot;comment-user&quot;&gt;Ben Voigt&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment22537952_6401387&quot;&gt;&lt;span title=&quot;2013-04-05 17:23:11Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 5, 2013 at 17:23&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 3 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Have you actually tried compiling it? There are set of operators that cannot be implemented outside class (i.e. as non-static functions)!&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/264325/ajay&quot; title=&quot;17,502 reputation&quot; class=&quot;comment-user&quot;&gt;Ajay&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment22544604_6401387&quot;&gt;&lt;span title=&quot;2013-04-05 21:10:03Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 5, 2013 at 21:10&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;oops, you&apos;re right.  &quot;&lt;code&gt;operator[]&lt;/code&gt; shall be a non-static member function with exactly one parameter.&quot;  I was familiar with that restriction on &lt;code&gt;operator=&lt;/code&gt;, didn&apos;t think it applied to &lt;code&gt;[]&lt;/code&gt;.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/103167/ben-voigt&quot; title=&quot;270,543 reputation&quot; class=&quot;comment-user&quot;&gt;Ben Voigt&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment22544966_6401387&quot;&gt;&lt;span title=&quot;2013-04-05 21:21:37Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 5, 2013 at 21:21&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Of course, if you change the definition of &lt;code&gt;[]&lt;/code&gt; operator, it would never be equivalent again... if &lt;code&gt;a[b]&lt;/code&gt; is equal to &lt;code&gt;*(a + b)&lt;/code&gt; and you change this, you&apos;ll have to overload also &lt;code&gt;int::operator[](const Sub&amp;amp;);&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt; is not a class...&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/3899431/luis-colorado&quot; title=&quot;9,512 reputation&quot; class=&quot;comment-user&quot;&gt;Luis Colorado&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment40600505_6401387&quot;&gt;&lt;span title=&quot;2014-09-19 13:18:17Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Sep 19, 2014 at 13:18&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;This...isn&apos;t...C.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/7659995/md-xf&quot; title=&quot;7,532 reputation&quot; class=&quot;comment-user&quot;&gt;MD XF&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment69434940_6401387&quot;&gt;&lt;span title=&quot;2016-12-13 07:13:46Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Dec 13, 2016 at 7:13&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;a+i is NOT simple addition, because it&apos;s pointer arithmetic.  if the size of the element of a is 1 (char), then yes, it&apos;s just like integer +.  But if it&apos;s (e.g.) an integer, then it might be equivalent to a + 4*i.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/121332/alex-brown&quot; title=&quot;40,446 reputation&quot; class=&quot;comment-user&quot;&gt;Alex Brown&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment55945617_19044346&quot;&gt;&lt;span title=&quot;2015-12-04 20:17:46Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Dec 4, 2015 at 20:17&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@AlexBrown Yes, it is pointer arithmetic, which is exactly why your last sentence is wrong, unless you first cast &apos;a&apos; to be a (char*) (assuming that an int is 4 chars).  I really don&apos;t understand why so many people are getting hung up on the actual value result of pointer arithmetic.  Pointer arithmetic&apos;s entire purpose is to abstract away the underlying pointer values and let the programmer think about the objects being manipulated rather than address values.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/4564515/jschultz410&quot; title=&quot;2,790 reputation&quot; class=&quot;comment-user&quot;&gt;jschultz410&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment85824382_19044346&quot;&gt;&lt;span title=&quot;2018-03-21 16:11:28Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 21, 2018 at 16:11&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Although redundant this is clear, concise and short.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/12943/bill-k&quot; title=&quot;61,238 reputation&quot; class=&quot;comment-user&quot;&gt;Bill K&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment104621199_49616876&quot;&gt;&lt;span title=&quot;2019-12-05 19:04:23Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Dec 5, 2019 at 19:04&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        "],"id":429,"title":"With arrays, why is it the case that a[5] == 5[a]?","content":"\n                \n&lt;p&gt;As Joel points out in &lt;a href=&quot;https://stackoverflow.blog/2008/12/18/podcast-34/&quot;&gt;Stack Overflow podcast #34&lt;/a&gt;, in &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0131103628&quot; rel=&quot;noreferrer&quot;&gt;C Programming Language&lt;/a&gt; (aka: K &amp;amp; R), there is mention of this property of arrays in C: &lt;code&gt;a[5] == 5[a]&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;Joel says that it&apos;s because of pointer arithmetic but I still don&apos;t understand. &lt;strong&gt;Why does &lt;code&gt;a[5] == 5[a]&lt;/code&gt;&lt;/strong&gt;?&lt;/p&gt;\n    ","slug":"with-arrays-why-is-it-the-case-that-a5-5a-1657387956216","postType":"QUESTION","createdAt":"2022-07-09T17:32:36.000Z","updatedAt":"2022-07-09T17:32:36.000Z","tags":[{"id":2254,"name":"pointer-arithmetic","slug":"pointer-arithmetic","createdAt":"2022-07-09T17:32:36.000Z","updatedAt":"2022-07-09T17:32:36.000Z","Questions_Tags":{"questionId":429,"tagId":2254}}]}},"__N_SSG":true}