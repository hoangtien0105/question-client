{"pageProps":{"data":{"answer":["\n&lt;p&gt;There are two things to note here:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;&lt;code&gt;re.findall&lt;/code&gt; returns captured texts if the regex pattern contains capturing groups in it&lt;/strong&gt; &lt;/li&gt;\n&lt;li&gt;the &lt;code&gt;r&apos;\\\\.&apos;&lt;/code&gt; part in your pattern matches two consecutive chars, &lt;code&gt;\\&lt;/code&gt; and any char other than a newline.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;See &lt;a href=&quot;https://docs.python.org/2/library/re.html#re.findall&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;findall&lt;/code&gt; reference&lt;/a&gt;:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result unless they touch the beginning of another match.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Note that &lt;strong&gt;to make &lt;code&gt;re.findall&lt;/code&gt; return just match values&lt;/strong&gt;, you may usually&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;remove redundant capturing groups (e.g. &lt;code&gt;(a(b)c)&lt;/code&gt; -&amp;gt; &lt;code&gt;abc&lt;/code&gt;)&lt;/li&gt;\n&lt;li&gt;convert all capturing groups into &lt;a href=&quot;https://stackoverflow.com/questions/3512471/what-is-a-non-capturing-group-what-does-do&quot;&gt;non-capturing&lt;/a&gt; (that is, replace &lt;code&gt;(&lt;/code&gt; with &lt;code&gt;(?:&lt;/code&gt;) &lt;em&gt;unless&lt;/em&gt; there are backreferences that refer to the group values in the pattern (then see below)&lt;/li&gt;\n&lt;li&gt;use &lt;code&gt;re.finditer&lt;/code&gt; instead (&lt;code&gt;[x.group() for x in re.finditer(pattern, s)]&lt;/code&gt;)&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;In your case, &lt;code&gt;findall&lt;/code&gt; returned all captured texts that were empty because you have &lt;code&gt;\\\\&lt;/code&gt; within &lt;code&gt;r&apos;&apos;&lt;/code&gt; string literal that tried to match a literal &lt;code&gt;\\&lt;/code&gt;. &lt;/p&gt;\n\n&lt;p&gt;To match the numbers, you need to use&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;-?\\d*\\.?\\d+\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The regex matches:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;-?&lt;/code&gt; - Optional minus sign&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;\\d*&lt;/code&gt; - Optional digits&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;\\.?&lt;/code&gt; - Optional decimal separator&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;\\d+&lt;/code&gt; - 1 or more digits.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;See &lt;a href=&quot;https://regex101.com/r/oJ7pX9/1&quot; rel=&quot;noreferrer&quot;&gt;demo&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Here is &lt;a href=&quot;http://ideone.com/GN4CLB&quot; rel=&quot;noreferrer&quot;&gt;IDEONE demo&lt;/a&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; re\ns = &lt;span class=&quot;hljs-string&quot;&gt;r&apos;abc123d, hello 3.1415926, this is my book&apos;&lt;/span&gt;\npattern = &lt;span class=&quot;hljs-string&quot;&gt;r&apos;-?\\d*\\.?\\d+&apos;&lt;/span&gt;\nL = re.findall(pattern, s)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(L)\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;s = &lt;span class=&quot;hljs-string&quot;&gt;r&apos;abc123d, hello 3.1415926, this is my book&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; re.findall(&lt;span class=&quot;hljs-string&quot;&gt;r&apos;-?[0-9]+(?:\\.[0-9]*)?|-?\\.[0-9]+&apos;&lt;/span&gt;,s)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You dont need to &lt;strong&gt;escape&lt;/strong&gt; twice when you are using &lt;strong&gt;raw mode&lt;/strong&gt;.&lt;/p&gt;\n\n&lt;p&gt;Output:&lt;code&gt;[&apos;123&apos;, &apos;3.1415926&apos;]&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;Also the return type will be a list of &lt;strong&gt;strings&lt;/strong&gt;. If you want return type as &lt;strong&gt;integers&lt;/strong&gt; and &lt;strong&gt;floats&lt;/strong&gt; use &lt;code&gt;map&lt;/code&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; re,ast\ns = &lt;span class=&quot;hljs-string&quot;&gt;r&apos;abc123d, hello 3.1415926, this is my book&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;map&lt;/span&gt;(ast.literal_eval,re.findall(&lt;span class=&quot;hljs-string&quot;&gt;r&apos;-?[0-9]+(?:\\.[0-9]*)?|-?\\.[0-9]+&apos;&lt;/span&gt;,s))\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Output: &lt;code&gt;[123, 3.1415926]&lt;/code&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Just to explain why you think that &lt;code&gt;search&lt;/code&gt; returned what you want and &lt;code&gt;findall&lt;/code&gt; didn&apos;t?&lt;/p&gt;\n\n&lt;p&gt;search return a &lt;code&gt;SRE_Match&lt;/code&gt; object that hold some information like:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;string&lt;/code&gt; : attribute contains the string that was passed to search function.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;re&lt;/code&gt;     : &lt;code&gt;REGEX&lt;/code&gt; object used in search function.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;groups()&lt;/code&gt; : list of string captured by the capturing groups inside the &lt;code&gt;REGEX&lt;/code&gt;.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;group(index)&lt;/code&gt;: to retrieve the captured string by group using &lt;code&gt;index &amp;gt; 0&lt;/code&gt;.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;group(0)&lt;/code&gt; : return the string matched by the &lt;code&gt;REGEX&lt;/code&gt;.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&lt;code&gt;search&lt;/code&gt; stops when It found the first mach build the &lt;code&gt;SRE_Match&lt;/code&gt; Object and returning it, check this code:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; re\n\ns = &lt;span class=&quot;hljs-string&quot;&gt;r&apos;abc123d&apos;&lt;/span&gt;\npattern = &lt;span class=&quot;hljs-string&quot;&gt;r&apos;-?[0-9]+(\\.[0-9]*)?|-?\\.[0-9]+&apos;&lt;/span&gt;\nm = re.search(pattern, s)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(m.string)  &lt;span class=&quot;hljs-comment&quot;&gt;# &apos;abc123d&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(m.group(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;))  &lt;span class=&quot;hljs-comment&quot;&gt;# REGEX matched 123&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(m.groups())  &lt;span class=&quot;hljs-comment&quot;&gt;# there is only one group in REGEX (\\.[0-9]*) will  empy string tgis why it return (None,) &lt;/span&gt;\n\ns = &lt;span class=&quot;hljs-string&quot;&gt;&apos;, hello 3.1415926, this is my book&apos;&lt;/span&gt;\nm2 = re.search(pattern, s)  &lt;span class=&quot;hljs-comment&quot;&gt;# &apos;, hello 3.1415926, this is my book&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(m2.string)    &lt;span class=&quot;hljs-comment&quot;&gt;# abc123d&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(m2.group(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;))  &lt;span class=&quot;hljs-comment&quot;&gt;# REGEX matched 3.1415926&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(m2.groups())  &lt;span class=&quot;hljs-comment&quot;&gt;# the captured group has captured this part &apos;.1415926&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;findall&lt;/code&gt; behave differently because it doesn&apos;t just stop when It find the first mach it keeps extracting until the end of the text, but if the &lt;code&gt;REGEX&lt;/code&gt;  contains at least one capturing group the &lt;code&gt;findall&lt;/code&gt; don&apos;t return the matched string but the captured string by the capturing groups:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; re\ns = &lt;span class=&quot;hljs-string&quot;&gt;r&apos;abc123d , hello 3.1415926, this is my book&apos;&lt;/span&gt;\npattern = &lt;span class=&quot;hljs-string&quot;&gt;r&apos;-?[0-9]+(\\.[0-9]*)?|-?\\.[0-9]+&apos;&lt;/span&gt;\nm = re.findall(pattern, s)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(m)  &lt;span class=&quot;hljs-comment&quot;&gt;# [&apos;&apos;, &apos;.1415926&apos;]&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;the first &lt;code&gt;element&lt;/code&gt; is return when the first mach was found witch is &lt;code&gt;&apos;123&apos;&lt;/code&gt; the capturing group captured only &lt;code&gt;&apos;&apos;&lt;/code&gt;, but the second &lt;code&gt;element&lt;/code&gt; was captured in the second match &lt;code&gt;&apos;3.1415926&apos;&lt;/code&gt; the capturing group matched this part &lt;code&gt;&apos;.1415926&apos;&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;If you want to make the &lt;code&gt;findall&lt;/code&gt; return matched string you should make all capturing groups &lt;code&gt;()&lt;/code&gt; in your &lt;code&gt;REGEX&lt;/code&gt; a  non capturing groups&lt;code&gt;(?:)&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; re\ns = &lt;span class=&quot;hljs-string&quot;&gt;r&apos;abc123d , hello 3.1415926, this is my book&apos;&lt;/span&gt;\npattern = &lt;span class=&quot;hljs-string&quot;&gt;r&apos;-?[0-9]+(?:\\.[0-9]*)?|-?\\.[0-9]+&apos;&lt;/span&gt;\nm = re.findall(pattern, s)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(m)  &lt;span class=&quot;hljs-comment&quot;&gt;# [&apos;123&apos;, &apos;3.1415926&apos;]&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    "],"id":556,"title":"re.findall behaves weird","content":"\n                \n&lt;p&gt;The source string is:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# Python 3.4.3&lt;/span&gt;\ns = &lt;span class=&quot;hljs-string&quot;&gt;r&apos;abc123d, hello 3.1415926, this is my book&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and here is my pattern:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;pattern = &lt;span class=&quot;hljs-string&quot;&gt;r&apos;-?[0-9]+(\\\\.[0-9]*)?|-?\\\\.[0-9]+&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;however, &lt;code&gt;re.search&lt;/code&gt; can give me correct result:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;m = re.search(pattern, s)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(m)  &lt;span class=&quot;hljs-comment&quot;&gt;# output: &amp;lt;_sre.SRE_Match object; span=(3, 6), match=&apos;123&apos;&amp;gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;re.findall&lt;/code&gt; just dump out an empty list:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;L = re.findall(pattern, s)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(L)  &lt;span class=&quot;hljs-comment&quot;&gt;# output: [&apos;&apos;, &apos;&apos;, &apos;&apos;]&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;why can&apos;t &lt;code&gt;re.findall&lt;/code&gt; give me the expected list:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&apos;123&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;3.1415926&apos;&lt;/span&gt;]\n&lt;/code&gt;&lt;/pre&gt;\n    ","slug":"re.findall-behaves-weird-1657388408049","postType":"QUESTION","createdAt":"2022-07-09T17:40:08.000Z","updatedAt":"2022-07-09T17:40:08.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"Is there any way to kill a Thread?","slug":"is-there-any-way-to-kill-a-thread-1657387859831"},{"title":"Asking the user for input until they give a valid response","slug":"asking-the-user-for-input-until-they-give-a-valid-response-1657384376162"},{"title":"How to filter Pandas dataframe using 'in' and 'not in' like in SQL","slug":"how-to-filter-pandas-dataframe-using-'in'-and-'not-in'-like-in-sql-1657387371355"},{"title":"How do I return the response from an asynchronous call?","slug":"how-do-i-return-the-response-from-an-asynchronous-call-1657384208012"},{"title":"Why does my recursive function return None?","slug":"why-does-my-recursive-function-return-none-1657387792894"},{"title":"Sort ArrayList of custom Objects by property","slug":"sort-arraylist-of-custom-objects-by-property-1657387678339"},{"title":"How to join (merge) data frames (inner, outer, left, right)","slug":"how-to-join-(merge)-data-frames-(inner-outer-left-right)-1657384406445"},{"title":"How can I access and process nested objects, arrays, or JSON?","slug":"how-can-i-access-and-process-nested-objects-arrays-or-json-1657384332823"},{"title":"Why does printf not flush after the call unless a newline is in the format string?","slug":"why-does-printf-not-flush-after-the-call-unless-a-newline-is-in-the-format-string-1657387853407"},{"title":"How do you convert a byte array to a hexadecimal string, and vice versa?","slug":"how-do-you-convert-a-byte-array-to-a-hexadecimal-string-and-vice-versa-1657388010428"},{"title":"How do I compare strings in Java?","slug":"how-do-i-compare-strings-in-java-1657384243187"},{"title":"What is the purpose of the var keyword and when should I use it (or omit it)?","slug":"what-is-the-purpose-of-the-var-keyword-and-when-should-i-use-it-(or-omit-it)-1657387525538"},{"title":"How do function pointers in C work?","slug":"how-do-function-pointers-in-c-work-1657388332074"},{"title":"How can I sanitize user input with PHP?","slug":"how-can-i-sanitize-user-input-with-php-1657387892329"},{"title":"What is JavaScript's highest integer value that a number can go to without losing precision?","slug":"what-is-javascript's-highest-integer-value-that-a-number-can-go-to-without-losing-precision-1657387622983"},{"title":"Importing files from different folder","slug":"importing-files-from-different-folder-1657388203798"},{"title":"Get all unique values in a JavaScript array (remove duplicates)","slug":"get-all-unique-values-in-a-javascript-array-(remove-duplicates)-1657387435296"},{"title":"What is an IndexOutOfRangeException / ArgumentOutOfRangeException and how do I fix it?","slug":"what-is-an-indexoutofrangeexception-argumentoutofrangeexception-and-how-do-i-fix-it-1657384697159"},{"title":"Why Use Integer Instead of Long?","slug":"why-use-integer-instead-of-long-1657388012352"},{"title":"What is the difference between client-side and server-side programming?","slug":"what-is-the-difference-between-client-side-and-server-side-programming-1657384372926"}]},"__N_SSG":true}