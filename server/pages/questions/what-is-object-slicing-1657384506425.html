<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2eccd4d47c856f2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2eccd4d47c856f2b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/471-84c36aa98dd4107c.js" defer=""></script><script src="/_next/static/chunks/81-096e453de8a27667.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-e3d1b60e109d3ba1.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_buildManifest.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.hFcsiD code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-6e32c308-0"]{content:"hFcsiD,"}/*!sc*/
.ljvTUN .comment-item .comment-body .d-inline-flex.ai-center{text-align:right;}/*!sc*/
.ljvTUN .comment-item .comment-body .comment-date{float:right;}/*!sc*/
data-styled.g6[id="sc-6e32c308-1"]{content:"ljvTUN,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="https://flowbite.com/docs/images/logo.svg" class="mr-3 h-6 sm:h-9" alt="Flowbite Logo"/><span class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Hunter</span></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/what-is-object-slicing-1657384506425#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-6e32c308-0 hFcsiD flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-is-object-slicing-1657384506425">What is object slicing?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/inheritance">inheritance</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/object-slicing">object-slicing</a></div></div><div class="question-content mt-5">
                
<p>In c++ what is object slicing and when does it occur?</p>
    </div></div></div><div class="sc-6e32c308-1 ljvTUN flex text-xs pl-10 flex-col comment items-center justify-center"><h4 class="text-left mt-10 text-lg font-semibold">Comments</h4><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy">Very informative, but see <a href="http://stackoverflow.com/questions/274626#274636">stackoverflow.com/questions/274626#274636</a> for an example of how slicing occurs during method calls (which underscores the danger a little better than the plain assignment example).</span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/1199/blair-conrad" title="220,812 reputation" class="comment-user">Blair Conrad</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment127698_274634"><span title="2008-11-08 13:53:18Z, License: CC BY-SA 2.5" class="relativetime-clean">Nov 8, 2008 at 13:53</span></a></span>
            </div>
        </div><span class="divide-x-8 "></span><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy">Interesting.  I've been programming in C++ for 15 years and this issue never occurred to me, as I've always passed objects by reference as a matter of efficiency and personal style.  Goes to show how good habits can help you.</span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/389146/karl-bielefeldt" title="45,230 reputation" class="comment-user">Karl Bielefeldt</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment5414719_274634"><span title="2011-02-02 03:48:44Z, License: CC BY-SA 2.5" class="relativetime-clean">Feb 2, 2011 at 3:48</span></a></span>
            </div>
        </div><span class="divide-x-8 "></span><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy">@Felix Thanks but I don't think casting back (since not a pointer arithmetic) will work , <code>A a = b;</code> <code>a</code> is now object of type <code>A</code> which has copy of <code>B::foo</code>. It will be mistake to cast it back now i think.</span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<span class="comment-user">user72424</span>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment8412787_274634"><span title="2011-08-12 12:27:17Z, License: CC BY-SA 3.0" class="relativetime-clean">Aug 12, 2011 at 12:27</span></a></span>
            </div>
        </div><span class="divide-x-8 "></span><button class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">See more</button></div><div class="sc-6e32c308-2 bFXWFO"><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>"Slicing" is where you assign an object of a derived class to an instance of a base class, thereby losing part of the information - some of it is "sliced" away.</p>

<p>For example, </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
   <span class="hljs-type">int</span> foo;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A {
   <span class="hljs-type">int</span> bar;
};
</code></pre>

<p>So an object of type <code>B</code> has two data members, <code>foo</code> and <code>bar</code>.</p>

<p>Then if you were to write this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">B b;

A a = b;
</code></pre>

<p>Then the information in <code>b</code> about member <code>bar</code> is lost in <code>a</code>.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Most answers here fail to explain what the actual problem with slicing is. They only explain the benign cases of slicing, not the treacherous ones. Assume, like the other answers, that you're dealing with two classes <code>A</code> and <code>B</code>, where <code>B</code> derives (publicly) from <code>A</code>.</p>

<p>In this situation, C++ lets you pass an instance of <code>B</code> to  <code>A</code>'s assignment operator (and also to the copy constructor). This works because an instance of <code>B</code> can be converted to a <code>const A&amp;</code>, which is what assignment operators and copy-constructors expect their arguments to be.</p>

<h3>The benign case</h3>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">B b;
A a = b;
</code></pre>

<p>Nothing bad happens there - you asked for an instance of <code>A</code> which is a copy of <code>B</code>, and that's exactly what you get. Sure, <code>a</code> won't contain some of <code>b</code>'s members, but how should it? It's an <code>A</code>, after all, not a <code>B</code>, so it hasn't even <em>heard</em> about these members, let alone would be able to store them.</p>

<h3>The treacherous case</h3>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">B b1;
B b2;
A&amp; a_ref = b2;
a_ref = b1;
<span class="hljs-comment">//b2 now contains a mixture of b1 and b2!</span>
</code></pre>

<p>You might think that <code>b2</code> will be a copy of <code>b1</code> afterward. But, alas, it's <strong>not</strong>! If you inspect it, you'll discover that <code>b2</code> is a Frankensteinian creature, made from some chunks of <code>b1</code> (the chunks that <code>B</code> inherits from <code>A</code>), and some chunks of <code>b2</code> (the chunks that only <code>B</code> contains). Ouch!</p>

<p>What happened? Well, C++ by default doesn't treat assignment operators as <code>virtual</code>. Thus, the line <code>a_ref = b1</code> will call the assignment operator of <code>A</code>, not that of <code>B</code>. This is because, for non-virtual functions, the <strong>declared</strong> (formally: <em>static</em>) type (which is <code>A&amp;</code>) determines which function is called, as opposed to the <strong>actual</strong> (formally: <em>dynamic</em>) type (which would be <code>B</code>, since <code>a_ref</code> references an instance of <code>B</code>). Now, <code>A</code>'s assignment operator obviously knows only about the members declared in <code>A</code>, so it will copy only those, leaving the members added in <code>B</code> unchanged.</p>

<h3>A solution</h3>

<p>Assigning only to parts of an object usually makes little sense, yet C++, unfortunately, provides no built-in way to forbid this. You can, however, roll your own. The first step is making the assignment operator <em>virtual</em>. This will guarantee that it's always the <strong>actual</strong> type's assignment operator which is called, not the <strong>declared</strong> type's. The second step is to use <code>dynamic_cast</code> to verify that the assigned object has a compatible type. The third step is to do the actual assignment in a (protected!) member <code>assign()</code>, since <code>B</code>'s <code>assign()</code> will probably want to use <code>A</code>'s <code>assign()</code> to copy <code>A</code>'s, members.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">virtual</span> A&amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> A&amp; a) {
    <span class="hljs-built_in">assign</span>(a);
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
  }

<span class="hljs-keyword">protected</span>:
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(<span class="hljs-type">const</span> A&amp; a)</span> </span>{
    <span class="hljs-comment">// copy members of A from a to this</span>
  }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A {
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">virtual</span> B&amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> A&amp; a) {
    <span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> B* b = <span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">const</span> B*&gt;(&amp;a))
      <span class="hljs-built_in">assign</span>(*b);
    <span class="hljs-keyword">else</span>
      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">bad_assignment</span>();
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
  }

<span class="hljs-keyword">protected</span>:
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(<span class="hljs-type">const</span> B&amp; b)</span> </span>{
    A::<span class="hljs-built_in">assign</span>(b); <span class="hljs-comment">// Let A's assign() copy members of A from b to this</span>
    <span class="hljs-comment">// copy members of B from b to this</span>
  }
};
</code></pre>

<p>Note that, for pure convenience, <code>B</code>'s <code>operator=</code> covariantly overrides the return type, since it <strong>knows</strong> that it's returning an instance of <code>B</code>.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If You have a base class <code>A</code> and a derived class <code>B</code>, then You can do the following.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wantAnA</span><span class="hljs-params">(A myA)</span>
</span>{
   <span class="hljs-comment">// work with myA</span>
}

B derived;
<span class="hljs-comment">// work with the object "derived"</span>
<span class="hljs-built_in">wantAnA</span>(derived);
</code></pre>

<p>Now the method <code>wantAnA</code> needs a copy of <code>derived</code>. However, the object <code>derived</code> cannot be copied completely, as the class <code>B</code> could invent additional member variables which are not in its base class <code>A</code>.</p>

<p>Therefore, to call <code>wantAnA</code>, the compiler will "slice off" all additional members of the derived class. The result might be an object you did not want to create, because</p>

<ul>
<li>it may be incomplete,</li>
<li>it behaves like an <code>A</code>-object (all special behaviour of the class <code>B</code> is lost).</li>
</ul>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>These are all good answers. I would just like to add an execution example when passing objects by value vs by reference:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-comment">// Base class</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">A</span>() {}
    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a) {
        cout &lt;&lt; <span class="hljs-string">"'A' copy constructor"</span> &lt;&lt; endl;
    }
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ cout &lt;&lt; <span class="hljs-string">"I am an 'A'"</span> &lt;&lt; endl; }
};

<span class="hljs-comment">// Derived class</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">B</span>():<span class="hljs-built_in">A</span>() {}
    <span class="hljs-built_in">B</span>(<span class="hljs-type">const</span> B&amp; a):<span class="hljs-built_in">A</span>(a) {
        cout &lt;&lt; <span class="hljs-string">"'B' copy constructor"</span> &lt;&lt; endl;
    }
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ cout &lt;&lt; <span class="hljs-string">"I am a 'B'"</span> &lt;&lt; endl; }
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">const</span> A &amp; a)</span> </span>{
    a.<span class="hljs-built_in">run</span>();
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-type">const</span> A a)</span> </span>{
    a.<span class="hljs-built_in">run</span>();
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    cout &lt;&lt; <span class="hljs-string">"Call by reference"</span> &lt;&lt; endl;
    <span class="hljs-built_in">g</span>(<span class="hljs-built_in">B</span>());
    cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">"Call by copy"</span> &lt;&lt; endl;
    <span class="hljs-built_in">h</span>(<span class="hljs-built_in">B</span>());
}
</code></pre>

<p>The output is:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">Call by reference
I am a <span class="hljs-string">'B'</span>

Call by copy
<span class="hljs-string">'A'</span> copy constructor
I am an <span class="hljs-string">'A'</span>
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Third match in google for "C++ slicing" gives me this Wikipedia article <a href="http://en.wikipedia.org/wiki/Object_slicing" rel="noreferrer">http://en.wikipedia.org/wiki/Object_slicing</a> and this (heated, but the first few posts define the problem) : <a href="http://bytes.com/forum/thread163565.html" rel="noreferrer">http://bytes.com/forum/thread163565.html</a></p>

<p>So it's when you assign an object of a subclass to the super class. The superclass knows nothing of the additional information in the subclass, and hasn't got room to store it, so the additional information gets "sliced off".</p>

<p>If those links don't give enough info for a "good answer" please edit your question to let us know what more you're looking for.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The slicing problem is serious because it can result in memory corruption, and it is very difficult to guarantee a program does not suffer from it. To design it out of the language, classes that support inheritance should be accessible by reference only (not by value). The D programming language has this property.</p>

<p>Consider class A, and class B derived from A. Memory corruption can happen if the A part has a pointer p, and a B instance that points p to B's additional data. Then, when the additional data gets sliced off, p is pointing to garbage.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In C++, a derived class object can be assigned to a base class object, but the other way is not possible.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> { <span class="hljs-type">int</span> x, y; };

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base { <span class="hljs-type">int</span> z, w; };

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> 
</span>{
    Derived d;
    Base b = d; <span class="hljs-comment">// Object Slicing,  z and w of d are sliced off</span>
}
</code></pre>

<p>Object slicing happens when a derived class object is assigned to a base class object, additional attributes of a derived class object are sliced off to form the base class object.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I see all the answers mention when object slicing happens when data members are sliced. Here I give an example that the methods are not overridden:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Say</span><span class="hljs-params">()</span></span>{
        std::cout&lt;&lt;<span class="hljs-string">"I am A"</span>&lt;&lt;std::endl;
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Say</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>{
        std::cout&lt;&lt;<span class="hljs-string">"I am B"</span>&lt;&lt;std::endl;
    }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
   B b;
   A a1;
   A a2=b;

   b.<span class="hljs-built_in">Say</span>(); <span class="hljs-comment">// I am B</span>
   a1.<span class="hljs-built_in">Say</span>(); <span class="hljs-comment">// I am A</span>
   a2.<span class="hljs-built_in">Say</span>(); <span class="hljs-comment">// I am A   why???</span>
}
</code></pre>
<p>B (object b) is derived from A (object a1 and a2). b and a1, as we expect, call their member function. But from polymorphism viewpoint we dont expect a2, which is assigned by b, to not be overridden. Basically, a2 only saves A-class part of b and that is object slicing in C++.</p>
<p>To solve this problem, a reference or pointer should be used</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"> A&amp; a2=b;
 a2.<span class="hljs-built_in">Say</span>(); <span class="hljs-comment">// I am B</span>
</code></pre>
<p>or</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">A* a2 = &amp;b;
a2-&gt;<span class="hljs-built_in">Say</span>(); <span class="hljs-comment">// I am B</span>
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>So ... Why is losing the derived information bad? ... because the author of the derived class may have changed the representation such that slicing off the extra information changes the value being represented by the object.  This can happen if the derived class if used to cache a representation that is more efficient for certain operations, but expensive to transform back to the base representation.</p>

<p>Also thought someone should also mention what you should do to avoid slicing...
Get a copy of C++ Coding Standards, 101 rules guidlines, and best practices.  Dealing with slicing is #54.</p>

<p>It suggests a somewhat sophisticated pattern to fully deal with the issue:  have a protected copy constructor, a protected pure virtual DoClone, and a public Clone with an assert which will tell you if a (further) derived class failed to implement DoClone correctly.  (The Clone method makes a proper deep copy of the polymorphic object.)</p>

<p>You can also mark the copy constructor on the base explicit which allows for explicit slicing if it is desired.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The slicing problem in C++ arises from the value semantics of its objects, which remained mostly due to compatibility with C structs. You need to use explicit reference or pointer syntax to achieve "normal" object behavior found in most other languages that do objects, i.e., objects are always passed around by reference.</p>

<p>The short answers is that you slice the object by assigning a derived object to a base object <em>by value</em>, i.e. the remaining object is only a part of the derived object. In order to preserve value semantics, slicing is a reasonable behavior and has its relatively rare uses, which doesn't exist in most other languages. Some people consider it a feature of C++, while many considered it one of the quirks/misfeatures of C++.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>1. THE DEFINITION OF SLICING PROBLEM</strong></p>

<p>If D is a derived class of the base class B, then you can assign an object of type Derived to a variable (or parameter) of type Base. </p>

<p><em>EXAMPLE</em></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pet</span>
{
 <span class="hljs-keyword">public</span>:
    string name;
};
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-keyword">public</span> Pet
{
<span class="hljs-keyword">public</span>:
    string breed;
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{   
    Dog dog;
    Pet pet;

    dog.name = <span class="hljs-string">"Tommy"</span>;
    dog.breed = <span class="hljs-string">"Kangal Dog"</span>;
    pet = dog;
    cout &lt;&lt; pet.breed; <span class="hljs-comment">//ERROR</span>
</code></pre>

<p>Although the above assignment is allowed, the value that is assigned to the variable pet loses its breed field. This is called the <strong>slicing problem</strong>.</p>

<p><strong>2. HOW TO FIX THE SLICING PROBLEM</strong></p>

<p>To defeat the problem, we use pointers to dynamic variables.</p>

<p><em>EXAMPLE</em></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">Pet *ptrP;
Dog *ptrD;
ptrD = <span class="hljs-keyword">new</span> Dog;         
ptrD-&gt;name = <span class="hljs-string">"Tommy"</span>;
ptrD-&gt;breed = <span class="hljs-string">"Kangal Dog"</span>;
ptrP = ptrD;
cout &lt;&lt; ((Dog *)ptrP)-&gt;breed; 
</code></pre>

<p>In this case, none of the data members or member functions of the dynamic variable
being pointed to by ptrD (descendant class object) will be lost. In addition,  if you need to use functions, the function must be a virtual function.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It seems to me, that slicing isn't so much a problem other than when your own classes and program are poorly architected/designed.</p>

<p>If I pass a subclass object in as a parameter to a method, which takes a parameter of type superclass, I should certainly be aware of that and know the internally, the called method will be working with the superclass (aka baseclass) object only.</p>

<p>It seems to me only the unreasonable expectation that providing a subclass where a baseclass is requested, would somehow result in subclass specific results, would cause slicing to be a problem.  Its either poor design in the use of the method or a poor subclass implementation.  I'm guessing its usually the result of sacrificing good OOP design in favor of expediency or performance gains.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>OK, I'll give it a try after reading many posts explaining object slicing but not how it becomes problematic. </p>

<p>The vicious scenario that can result in memory corruption is the following:</p>

<ul>
<li>Class provides (accidentally, possibly compiler-generated) assignment on a polymorphic base class.</li>
<li>Client copies and slices an instance of a derived class.</li>
<li>Client calls a virtual member function that accesses the sliced-off state.</li>
</ul>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Slicing means that the data added by a subclass are discarded when an object of the subclass is passed or returned by value or from a function expecting a base class object.    </p>

<p><strong>Explanation:</strong>
Consider the following class declaration:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">           <span class="hljs-keyword">class</span> <span class="hljs-title class_">baseclass</span>
          {
                 ...
                 baseclass &amp; <span class="hljs-keyword">operator</span> =(<span class="hljs-type">const</span> baseclass&amp;);
                 <span class="hljs-built_in">baseclass</span>(<span class="hljs-type">const</span> baseclass&amp;);
          }
          <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">( )</span>
          </span>{
                baseclass obj1=m;
                obj1=m;
          }
</code></pre>

<p>As baseclass copy functions don't know anything about the derived only the base part of the derived is copied. This is commonly referred to as slicing. </p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> 
{ 
    <span class="hljs-type">int</span> x; 
};  

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> 
{ 
    <span class="hljs-built_in">B</span>( ) : <span class="hljs-built_in">x</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">c</span>(<span class="hljs-string">'a'</span>) { } 
    <span class="hljs-type">int</span> x; 
    <span class="hljs-type">char</span> c; 
};  

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">( )</span> 
</span>{ 
    A a; 
    B b; 
    a = b;     <span class="hljs-comment">// b.c == 'a' is "sliced" off</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; 
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>when a derived class object is assigned to a base class object, additional attributes of a derived class object are sliced off (discard)  form the base class object.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> { 
<span class="hljs-type">int</span> x;
 };

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base { 
 <span class="hljs-type">int</span> z; 
 };

 <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> 
</span>{
Derived d;
Base b = d; <span class="hljs-comment">// Object Slicing,  z of d is sliced off</span>
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>When a Derived class Object is assigned to Base class Object, all the members of derived class object is copied to base class object except the members which are not present in the base class. These members are Sliced away by the compiler.
This is called Object Slicing.</p>

<p><strong>Here is an Example:</strong> </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>
{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-type">int</span> a;
        <span class="hljs-type">int</span> b;
        <span class="hljs-type">int</span> c;
        <span class="hljs-built_in">Base</span>()
        {
            a=<span class="hljs-number">10</span>;
            b=<span class="hljs-number">20</span>;
            c=<span class="hljs-number">30</span>;
        }
};
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base
{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-type">int</span> d;
        <span class="hljs-type">int</span> e;
        <span class="hljs-built_in">Derived</span>()
        {
            d=<span class="hljs-number">40</span>;
            e=<span class="hljs-number">50</span>;
        }
};
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Derived d;
    cout&lt;&lt;d.a&lt;&lt;<span class="hljs-string">"\n"</span>;
    cout&lt;&lt;d.b&lt;&lt;<span class="hljs-string">"\n"</span>;
    cout&lt;&lt;d.c&lt;&lt;<span class="hljs-string">"\n"</span>;
    cout&lt;&lt;d.d&lt;&lt;<span class="hljs-string">"\n"</span>;
    cout&lt;&lt;d.e&lt;&lt;<span class="hljs-string">"\n"</span>;


    Base b = d;
    cout&lt;&lt;b.a&lt;&lt;<span class="hljs-string">"\n"</span>;
    cout&lt;&lt;b.b&lt;&lt;<span class="hljs-string">"\n"</span>;
    cout&lt;&lt;b.c&lt;&lt;<span class="hljs-string">"\n"</span>;
    cout&lt;&lt;b.d&lt;&lt;<span class="hljs-string">"\n"</span>;
    cout&lt;&lt;b.e&lt;&lt;<span class="hljs-string">"\n"</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p><strong>It will generate:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">[Error] <span class="hljs-string">'class Base'</span> has no member named <span class="hljs-string">'d'</span>
[Error] <span class="hljs-string">'class Base'</span> has no member named <span class="hljs-string">'e'</span>
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 18</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I just ran across the slicing problem and promptly landed here. So let me add my two cents to this.</p>

<p>Let's have an example from "production code" (or something that comes kind of close):</p>

<hr>

<p>Let's say we have something that dispatches actions. A control center UI for example.<br>
This UI needs to get a list of things that are currently able to be dispatched. So we define a class that contains the dispatch-information. Let's call it <code>Action</code>. So an <code>Action</code> has some member variables. For simplicity we just have 2, being a <code>std::string name</code> and a <code>std::function&lt;void()&gt; f</code>. Then it has an <code>void activate()</code> which just executes the <code>f</code> member.</p>

<p>So the UI gets a <code>std::vector&lt;Action&gt;</code> supplied. Imagine some functions like:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(Action toAdd)</span></span>;
</code></pre>

<hr>

<p>Now we have established how it looks from the UI's perspective. No problem so far. But some other guy who works on this project suddenly decides that there are specialized actions that need more information in the <code>Action</code> object. For what reason ever. That could also be solved with lambda captures.  This example is not taken 1-1 from the code.</p>

<p>So the guy derives from <code>Action</code> to add his own flavour.<br>
He passes an instance of his home-brewed class to the <code>push_back</code> but then the program goes haywire.</p>

<p>So what happened?<br>
As you <em>might</em> have guessed: the object has been sliced.</p>

<p>The extra information from the instance has been lost, and <code>f</code> is now prone to undefined behaviour.</p>

<hr>

<p>I hope this example brings light about for those people who can't really imagine things when talking about <code>A</code>s and <code>B</code>s being derived in some manner.</p>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;\u0026quot;Slicing\u0026quot; is where you assign an object of a derived class to an instance of a base class, thereby losing part of the information - some of it is \u0026quot;sliced\u0026quot; away.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example, \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt; {\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; foo;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; A {\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; bar;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So an object of type \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; has two data members, \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;bar\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Then if you were to write this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;B b;\n\nA a = b;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Then the information in \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; about member \u0026lt;code\u0026gt;bar\u0026lt;/code\u0026gt; is lost in \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Most answers here fail to explain what the actual problem with slicing is. They only explain the benign cases of slicing, not the treacherous ones. Assume, like the other answers, that you\u0026apos;re dealing with two classes \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;, where \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; derives (publicly) from \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In this situation, C++ lets you pass an instance of \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; to  \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;\u0026apos;s assignment operator (and also to the copy constructor). This works because an instance of \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; can be converted to a \u0026lt;code\u0026gt;const A\u0026amp;amp;\u0026lt;/code\u0026gt;, which is what assignment operators and copy-constructors expect their arguments to be.\u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;The benign case\u0026lt;/h3\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;B b;\nA a = b;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Nothing bad happens there - you asked for an instance of \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; which is a copy of \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;, and that\u0026apos;s exactly what you get. Sure, \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; won\u0026apos;t contain some of \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt;\u0026apos;s members, but how should it? It\u0026apos;s an \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;, after all, not a \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;, so it hasn\u0026apos;t even \u0026lt;em\u0026gt;heard\u0026lt;/em\u0026gt; about these members, let alone would be able to store them.\u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;The treacherous case\u0026lt;/h3\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;B b1;\nB b2;\nA\u0026amp;amp; a_ref = b2;\na_ref = b1;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//b2 now contains a mixture of b1 and b2!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You might think that \u0026lt;code\u0026gt;b2\u0026lt;/code\u0026gt; will be a copy of \u0026lt;code\u0026gt;b1\u0026lt;/code\u0026gt; afterward. But, alas, it\u0026apos;s \u0026lt;strong\u0026gt;not\u0026lt;/strong\u0026gt;! If you inspect it, you\u0026apos;ll discover that \u0026lt;code\u0026gt;b2\u0026lt;/code\u0026gt; is a Frankensteinian creature, made from some chunks of \u0026lt;code\u0026gt;b1\u0026lt;/code\u0026gt; (the chunks that \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; inherits from \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;), and some chunks of \u0026lt;code\u0026gt;b2\u0026lt;/code\u0026gt; (the chunks that only \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; contains). Ouch!\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;What happened? Well, C++ by default doesn\u0026apos;t treat assignment operators as \u0026lt;code\u0026gt;virtual\u0026lt;/code\u0026gt;. Thus, the line \u0026lt;code\u0026gt;a_ref = b1\u0026lt;/code\u0026gt; will call the assignment operator of \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;, not that of \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;. This is because, for non-virtual functions, the \u0026lt;strong\u0026gt;declared\u0026lt;/strong\u0026gt; (formally: \u0026lt;em\u0026gt;static\u0026lt;/em\u0026gt;) type (which is \u0026lt;code\u0026gt;A\u0026amp;amp;\u0026lt;/code\u0026gt;) determines which function is called, as opposed to the \u0026lt;strong\u0026gt;actual\u0026lt;/strong\u0026gt; (formally: \u0026lt;em\u0026gt;dynamic\u0026lt;/em\u0026gt;) type (which would be \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;, since \u0026lt;code\u0026gt;a_ref\u0026lt;/code\u0026gt; references an instance of \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;). Now, \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;\u0026apos;s assignment operator obviously knows only about the members declared in \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;, so it will copy only those, leaving the members added in \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; unchanged.\u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;A solution\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;Assigning only to parts of an object usually makes little sense, yet C++, unfortunately, provides no built-in way to forbid this. You can, however, roll your own. The first step is making the assignment operator \u0026lt;em\u0026gt;virtual\u0026lt;/em\u0026gt;. This will guarantee that it\u0026apos;s always the \u0026lt;strong\u0026gt;actual\u0026lt;/strong\u0026gt; type\u0026apos;s assignment operator which is called, not the \u0026lt;strong\u0026gt;declared\u0026lt;/strong\u0026gt; type\u0026apos;s. The second step is to use \u0026lt;code\u0026gt;dynamic_cast\u0026lt;/code\u0026gt; to verify that the assigned object has a compatible type. The third step is to do the actual assignment in a (protected!) member \u0026lt;code\u0026gt;assign()\u0026lt;/code\u0026gt;, since \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;\u0026apos;s \u0026lt;code\u0026gt;assign()\u0026lt;/code\u0026gt; will probably want to use \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;\u0026apos;s \u0026lt;code\u0026gt;assign()\u0026lt;/code\u0026gt; to copy \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;\u0026apos;s, members.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt; {\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; A\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;= (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; A\u0026amp;amp; a) {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assign\u0026lt;/span\u0026gt;(a);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n  }\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;protected\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;assign\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; A\u0026amp;amp; a)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// copy members of A from a to this\u0026lt;/span\u0026gt;\n  }\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; A {\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; B\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;= (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; A\u0026amp;amp; a) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; B* b = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dynamic_cast\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; B*\u0026amp;gt;(\u0026amp;amp;a))\n      \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assign\u0026lt;/span\u0026gt;(*b);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;bad_assignment\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n  }\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;protected\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;assign\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; B\u0026amp;amp; b)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    A::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assign\u0026lt;/span\u0026gt;(b); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Let A\u0026apos;s assign() copy members of A from b to this\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// copy members of B from b to this\u0026lt;/span\u0026gt;\n  }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that, for pure convenience, \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;\u0026apos;s \u0026lt;code\u0026gt;operator=\u0026lt;/code\u0026gt; covariantly overrides the return type, since it \u0026lt;strong\u0026gt;knows\u0026lt;/strong\u0026gt; that it\u0026apos;s returning an instance of \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If You have a base class \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; and a derived class \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;, then You can do the following.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;wantAnA\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(A myA)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// work with myA\u0026lt;/span\u0026gt;\n}\n\nB derived;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// work with the object \u0026quot;derived\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wantAnA\u0026lt;/span\u0026gt;(derived);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now the method \u0026lt;code\u0026gt;wantAnA\u0026lt;/code\u0026gt; needs a copy of \u0026lt;code\u0026gt;derived\u0026lt;/code\u0026gt;. However, the object \u0026lt;code\u0026gt;derived\u0026lt;/code\u0026gt; cannot be copied completely, as the class \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; could invent additional member variables which are not in its base class \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Therefore, to call \u0026lt;code\u0026gt;wantAnA\u0026lt;/code\u0026gt;, the compiler will \u0026quot;slice off\u0026quot; all additional members of the derived class. The result might be an object you did not want to create, because\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;it may be incomplete,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;it behaves like an \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;-object (all special behaviour of the class \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; is lost).\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;These are all good answers. I would just like to add an execution example when passing objects by value vs by reference:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Base class\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt; {\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;() {}\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; A\u0026amp;amp; a) {\n        cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026apos;A\u0026apos; copy constructor\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl;\n    }\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;run\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;I am an \u0026apos;A\u0026apos;\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl; }\n};\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Derived class\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; A {\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;():\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;() {}\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; B\u0026amp;amp; a):\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;(a) {\n        cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026apos;B\u0026apos; copy constructor\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl;\n    }\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;run\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;I am a \u0026apos;B\u0026apos;\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl; }\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;g\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; A \u0026amp;amp; a)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    a.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;run\u0026lt;/span\u0026gt;();\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;h\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; A a)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    a.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;run\u0026lt;/span\u0026gt;();\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Call by reference\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;g\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;());\n    cout \u0026amp;lt;\u0026amp;lt; endl \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Call by copy\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;h\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;());\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The output is:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;Call by reference\nI am a \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;B\u0026apos;\u0026lt;/span\u0026gt;\n\nCall by copy\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;A\u0026apos;\u0026lt;/span\u0026gt; copy constructor\nI am an \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;A\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Third match in google for \u0026quot;C++ slicing\u0026quot; gives me this Wikipedia article \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Object_slicing\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://en.wikipedia.org/wiki/Object_slicing\u0026lt;/a\u0026gt; and this (heated, but the first few posts define the problem) : \u0026lt;a href=\u0026quot;http://bytes.com/forum/thread163565.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://bytes.com/forum/thread163565.html\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So it\u0026apos;s when you assign an object of a subclass to the super class. The superclass knows nothing of the additional information in the subclass, and hasn\u0026apos;t got room to store it, so the additional information gets \u0026quot;sliced off\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If those links don\u0026apos;t give enough info for a \u0026quot;good answer\u0026quot; please edit your question to let us know what more you\u0026apos;re looking for.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The slicing problem is serious because it can result in memory corruption, and it is very difficult to guarantee a program does not suffer from it. To design it out of the language, classes that support inheritance should be accessible by reference only (not by value). The D programming language has this property.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Consider class A, and class B derived from A. Memory corruption can happen if the A part has a pointer p, and a B instance that points p to B\u0026apos;s additional data. Then, when the additional data gets sliced off, p is pointing to garbage.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In C++, a derived class object can be assigned to a base class object, but the other way is not possible.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Base\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x, y; };\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Derived\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Base { \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; z, w; };\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \n\u0026lt;/span\u0026gt;{\n    Derived d;\n    Base b = d; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Object Slicing,  z and w of d are sliced off\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Object slicing happens when a derived class object is assigned to a base class object, additional attributes of a derived class object are sliced off to form the base class object.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I see all the answers mention when object slicing happens when data members are sliced. Here I give an example that the methods are not overridden:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Say\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{\n        std::cout\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;I am A\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;lt;std::endl;\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; A{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Say\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;override\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{\n        std::cout\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;I am B\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;lt;std::endl;\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{\n   B b;\n   A a1;\n   A a2=b;\n\n   b.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Say\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// I am B\u0026lt;/span\u0026gt;\n   a1.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Say\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// I am A\u0026lt;/span\u0026gt;\n   a2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Say\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// I am A   why???\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;B (object b) is derived from A (object a1 and a2). b and a1, as we expect, call their member function. But from polymorphism viewpoint we dont expect a2, which is assigned by b, to not be overridden. Basically, a2 only saves A-class part of b and that is object slicing in C++.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;To solve this problem, a reference or pointer should be used\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt; A\u0026amp;amp; a2=b;\n a2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Say\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// I am B\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;or\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;A* a2 = \u0026amp;amp;b;\na2-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Say\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// I am B\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;So ... Why is losing the derived information bad? ... because the author of the derived class may have changed the representation such that slicing off the extra information changes the value being represented by the object.  This can happen if the derived class if used to cache a representation that is more efficient for certain operations, but expensive to transform back to the base representation.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Also thought someone should also mention what you should do to avoid slicing...\nGet a copy of C++ Coding Standards, 101 rules guidlines, and best practices.  Dealing with slicing is #54.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It suggests a somewhat sophisticated pattern to fully deal with the issue:  have a protected copy constructor, a protected pure virtual DoClone, and a public Clone with an assert which will tell you if a (further) derived class failed to implement DoClone correctly.  (The Clone method makes a proper deep copy of the polymorphic object.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can also mark the copy constructor on the base explicit which allows for explicit slicing if it is desired.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The slicing problem in C++ arises from the value semantics of its objects, which remained mostly due to compatibility with C structs. You need to use explicit reference or pointer syntax to achieve \u0026quot;normal\u0026quot; object behavior found in most other languages that do objects, i.e., objects are always passed around by reference.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The short answers is that you slice the object by assigning a derived object to a base object \u0026lt;em\u0026gt;by value\u0026lt;/em\u0026gt;, i.e. the remaining object is only a part of the derived object. In order to preserve value semantics, slicing is a reasonable behavior and has its relatively rare uses, which doesn\u0026apos;t exist in most other languages. Some people consider it a feature of C++, while many considered it one of the quirks/misfeatures of C++.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;1. THE DEFINITION OF SLICING PROBLEM\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If D is a derived class of the base class B, then you can assign an object of type Derived to a variable (or parameter) of type Base. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;EXAMPLE\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Pet\u0026lt;/span\u0026gt;\n{\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    string name;\n};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Pet\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    string breed;\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{   \n    Dog dog;\n    Pet pet;\n\n    dog.name = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Tommy\u0026quot;\u0026lt;/span\u0026gt;;\n    dog.breed = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Kangal Dog\u0026quot;\u0026lt;/span\u0026gt;;\n    pet = dog;\n    cout \u0026amp;lt;\u0026amp;lt; pet.breed; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//ERROR\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Although the above assignment is allowed, the value that is assigned to the variable pet loses its breed field. This is called the \u0026lt;strong\u0026gt;slicing problem\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;2. HOW TO FIX THE SLICING PROBLEM\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To defeat the problem, we use pointers to dynamic variables.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;EXAMPLE\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;Pet *ptrP;\nDog *ptrD;\nptrD = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Dog;         \nptrD-\u0026amp;gt;name = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Tommy\u0026quot;\u0026lt;/span\u0026gt;;\nptrD-\u0026amp;gt;breed = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Kangal Dog\u0026quot;\u0026lt;/span\u0026gt;;\nptrP = ptrD;\ncout \u0026amp;lt;\u0026amp;lt; ((Dog *)ptrP)-\u0026amp;gt;breed; \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In this case, none of the data members or member functions of the dynamic variable\nbeing pointed to by ptrD (descendant class object) will be lost. In addition,  if you need to use functions, the function must be a virtual function.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It seems to me, that slicing isn\u0026apos;t so much a problem other than when your own classes and program are poorly architected/designed.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If I pass a subclass object in as a parameter to a method, which takes a parameter of type superclass, I should certainly be aware of that and know the internally, the called method will be working with the superclass (aka baseclass) object only.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It seems to me only the unreasonable expectation that providing a subclass where a baseclass is requested, would somehow result in subclass specific results, would cause slicing to be a problem.  Its either poor design in the use of the method or a poor subclass implementation.  I\u0026apos;m guessing its usually the result of sacrificing good OOP design in favor of expediency or performance gains.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;OK, I\u0026apos;ll give it a try after reading many posts explaining object slicing but not how it becomes problematic. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The vicious scenario that can result in memory corruption is the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Class provides (accidentally, possibly compiler-generated) assignment on a polymorphic base class.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Client copies and slices an instance of a derived class.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Client calls a virtual member function that accesses the sliced-off state.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Slicing means that the data added by a subclass are discarded when an object of the subclass is passed or returned by value or from a function expecting a base class object.    \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Explanation:\u0026lt;/strong\u0026gt;\nConsider the following class declaration:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;           \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;baseclass\u0026lt;/span\u0026gt;\n          {\n                 ...\n                 baseclass \u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; =(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; baseclass\u0026amp;amp;);\n                 \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;baseclass\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; baseclass\u0026amp;amp;);\n          }\n          \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( )\u0026lt;/span\u0026gt;\n          \u0026lt;/span\u0026gt;{\n                baseclass obj1=m;\n                obj1=m;\n          }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;As baseclass copy functions don\u0026apos;t know anything about the derived only the base part of the derived is copied. This is commonly referred to as slicing. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt; \n{ \n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x; \n};  \n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt; \n{ \n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;( ) : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;) { } \n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x; \n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; c; \n};  \n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( )\u0026lt;/span\u0026gt; \n\u0026lt;/span\u0026gt;{ \n    A a; \n    B b; \n    a = b;     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// b.c == \u0026apos;a\u0026apos; is \u0026quot;sliced\u0026quot; off\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; \n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;when a derived class object is assigned to a base class object, additional attributes of a derived class object are sliced off (discard)  form the base class object.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Base\u0026lt;/span\u0026gt; { \n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x;\n };\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Derived\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Base { \n \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; z; \n };\n\n \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \n\u0026lt;/span\u0026gt;{\nDerived d;\nBase b = d; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Object Slicing,  z of d is sliced off\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;When a Derived class Object is assigned to Base class Object, all the members of derived class object is copied to base class object except the members which are not present in the base class. These members are Sliced away by the compiler.\nThis is called Object Slicing.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Here is an Example:\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;bits/stdc++.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Base\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a;\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; b;\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; c;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Base\u0026lt;/span\u0026gt;()\n        {\n            a=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;;\n            b=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt;;\n            c=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;30\u0026lt;/span\u0026gt;;\n        }\n};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Derived\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Base\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; d;\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; e;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Derived\u0026lt;/span\u0026gt;()\n        {\n            d=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;40\u0026lt;/span\u0026gt;;\n            e=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;50\u0026lt;/span\u0026gt;;\n        }\n};\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    Derived d;\n    cout\u0026amp;lt;\u0026amp;lt;d.a\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    cout\u0026amp;lt;\u0026amp;lt;d.b\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    cout\u0026amp;lt;\u0026amp;lt;d.c\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    cout\u0026amp;lt;\u0026amp;lt;d.d\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    cout\u0026amp;lt;\u0026amp;lt;d.e\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n\n\n    Base b = d;\n    cout\u0026amp;lt;\u0026amp;lt;b.a\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    cout\u0026amp;lt;\u0026amp;lt;b.b\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    cout\u0026amp;lt;\u0026amp;lt;b.c\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    cout\u0026amp;lt;\u0026amp;lt;b.d\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    cout\u0026amp;lt;\u0026amp;lt;b.e\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;It will generate:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;[Error] \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;class Base\u0026apos;\u0026lt;/span\u0026gt; has no member named \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;d\u0026apos;\u0026lt;/span\u0026gt;\n[Error] \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;class Base\u0026apos;\u0026lt;/span\u0026gt; has no member named \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;e\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I just ran across the slicing problem and promptly landed here. So let me add my two cents to this.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Let\u0026apos;s have an example from \u0026quot;production code\u0026quot; (or something that comes kind of close):\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Let\u0026apos;s say we have something that dispatches actions. A control center UI for example.\u0026lt;br\u0026gt;\nThis UI needs to get a list of things that are currently able to be dispatched. So we define a class that contains the dispatch-information. Let\u0026apos;s call it \u0026lt;code\u0026gt;Action\u0026lt;/code\u0026gt;. So an \u0026lt;code\u0026gt;Action\u0026lt;/code\u0026gt; has some member variables. For simplicity we just have 2, being a \u0026lt;code\u0026gt;std::string name\u0026lt;/code\u0026gt; and a \u0026lt;code\u0026gt;std::function\u0026amp;lt;void()\u0026amp;gt; f\u0026lt;/code\u0026gt;. Then it has an \u0026lt;code\u0026gt;void activate()\u0026lt;/code\u0026gt; which just executes the \u0026lt;code\u0026gt;f\u0026lt;/code\u0026gt; member.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So the UI gets a \u0026lt;code\u0026gt;std::vector\u0026amp;lt;Action\u0026amp;gt;\u0026lt;/code\u0026gt; supplied. Imagine some functions like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Action toAdd)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Now we have established how it looks from the UI\u0026apos;s perspective. No problem so far. But some other guy who works on this project suddenly decides that there are specialized actions that need more information in the \u0026lt;code\u0026gt;Action\u0026lt;/code\u0026gt; object. For what reason ever. That could also be solved with lambda captures.  This example is not taken 1-1 from the code.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So the guy derives from \u0026lt;code\u0026gt;Action\u0026lt;/code\u0026gt; to add his own flavour.\u0026lt;br\u0026gt;\nHe passes an instance of his home-brewed class to the \u0026lt;code\u0026gt;push_back\u0026lt;/code\u0026gt; but then the program goes haywire.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So what happened?\u0026lt;br\u0026gt;\nAs you \u0026lt;em\u0026gt;might\u0026lt;/em\u0026gt; have guessed: the object has been sliced.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The extra information from the instance has been lost, and \u0026lt;code\u0026gt;f\u0026lt;/code\u0026gt; is now prone to undefined behaviour.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;I hope this example brings light about for those people who can\u0026apos;t really imagine things when talking about \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;s and \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;s being derived in some manner.\u0026lt;/p\u0026gt;\n    "],"comment":["\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Very informative, but see \u0026lt;a href=\u0026quot;http://stackoverflow.com/questions/274626#274636\u0026quot;\u0026gt;stackoverflow.com/questions/274626#274636\u0026lt;/a\u0026gt; for an example of how slicing occurs during method calls (which underscores the danger a little better than the plain assignment example).\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1199/blair-conrad\u0026quot; title=\u0026quot;220,812 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Blair Conrad\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment127698_274634\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2008-11-08 13:53:18Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 8, 2008 at 13:53\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Interesting.  I\u0026apos;ve been programming in C++ for 15 years and this issue never occurred to me, as I\u0026apos;ve always passed objects by reference as a matter of efficiency and personal style.  Goes to show how good habits can help you.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/389146/karl-bielefeldt\u0026quot; title=\u0026quot;45,230 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Karl Bielefeldt\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment5414719_274634\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-02-02 03:48:44Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 2, 2011 at 3:48\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Felix Thanks but I don\u0026apos;t think casting back (since not a pointer arithmetic) will work , \u0026lt;code\u0026gt;A a = b;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is now object of type \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; which has copy of \u0026lt;code\u0026gt;B::foo\u0026lt;/code\u0026gt;. It will be mistake to cast it back now i think.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;span class=\u0026quot;comment-user\u0026quot;\u0026gt;user72424\u0026lt;/span\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment8412787_274634\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-08-12 12:27:17Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 12, 2011 at 12:27\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;This isn\u0026apos;t \u0026quot;slicing\u0026quot;, or at least a benign variant of it. The real problem occurs if you do \u0026lt;code\u0026gt;B b1; B b2; A\u0026amp;amp; b2_ref = b2; b2 = b1\u0026lt;/code\u0026gt;. You might think you have copied \u0026lt;code\u0026gt;b1\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;b2\u0026lt;/code\u0026gt;, but you haven\u0026apos;t! You have copied a \u0026lt;i\u0026gt;part\u0026lt;/i\u0026gt; of \u0026lt;code\u0026gt;b1\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;b2\u0026lt;/code\u0026gt; (the part of \u0026lt;code\u0026gt;b1\u0026lt;/code\u0026gt; that \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; inherited from \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;), and left the other parts of \u0026lt;code\u0026gt;b2\u0026lt;/code\u0026gt; unchanged. \u0026lt;code\u0026gt;b2\u0026lt;/code\u0026gt; is now a frankensteinian creature consisting of a few bits of \u0026lt;code\u0026gt;b1\u0026lt;/code\u0026gt; followed by some chunks of \u0026lt;code\u0026gt;b2\u0026lt;/code\u0026gt;. Ugh! Downvoting because I think the answer is very missleading.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1582403/fgp\u0026quot; title=\u0026quot;7,708 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;fgp\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment20140437_274634\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-01-22 14:07:42Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 22, 2013 at 14:07\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@fgp Your comment should read \u0026lt;code\u0026gt;B b1; B b2; A\u0026amp;amp; b2_ref = b2; b2_ref = b1\u0026lt;/code\u0026gt; \u0026quot;\u0026lt;i\u0026gt;The real problem occurs if you\u0026lt;/i\u0026gt;\u0026quot; ... derive from a class with a non-virtual assignment operator. Is \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; even intended for derivation? It has no virtual functions. If you derive from a type, you have to deal with the fact that its member functions can be called!\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/963864/curiousguy\u0026quot; title=\u0026quot;7,758 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;curiousguy\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment25231091_274634\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-06-29 14:54:09Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 29, 2013 at 14:54\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;IMHO, the problem is that there are two different kinds of substitutability that may be implied by inheritance: either any \u0026lt;code\u0026gt;derived\u0026lt;/code\u0026gt; value may be given to code expecting a \u0026lt;code\u0026gt;base\u0026lt;/code\u0026gt; value, or any derived reference may be used as a base reference.  I would like to see a language with a type system which addresses both concepts separately.  There are many cases where a derived reference should be substitutable for a base reference, but derived instances should not be substitutable for base ones; there are also many cases where instances should be convertible but references should not substitute.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/363751/supercat\u0026quot; title=\u0026quot;73,697 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;supercat\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment26658068_14461532\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-08-12 16:11:52Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 12, 2013 at 16:11\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I don\u0026apos;t understand what is so bad in your \u0026quot;treacherous\u0026quot; case. You stated that you want to: 1) get a reference to an object of class A and 2) cast the object b1 to class A and copy its stuff to a reference of the class A. What is actually wrong here is the proper logic behind the given code. In other words, you took a small image frame (A), placed it over a bigger image (B) and you painted through that frame, complaining later that your bigger image now looks ugly :) But if we just consider that framed area, it looks pretty good, just as the painter wanted, right? :)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2428861/mladen-b\u0026quot; title=\u0026quot;2,598 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Mladen B.\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment29740595_14461532\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-11-14 13:05:39Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 14, 2013 at 13:05\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;The problem is, differently put, that C++ by default assumes a very strong kind of \u0026lt;i\u0026gt;substitutability\u0026lt;/i\u0026gt; - it requires the base class\u0026apos;es operations to workly correctly on subclass instances. And that even for operations which the compiler autogenerated like assignment. So it\u0026apos;s not enough to not screw up your own operations in this regard, you also have to explicitly disable the wrong ones generated by the compiler. Or of course, stay away from public inheritance, which usually is a good suggestion anway ;-)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1582403/fgp\u0026quot; title=\u0026quot;7,708 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;fgp\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment29812895_14461532\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-11-16 16:31:03Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 16, 2013 at 16:31\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Another common approach is to simply disable the copy and assignment operator. For classes within inheritance hierarchy, usually there is no reason to use value instead of reference or pointer.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/832878/siyuan-ren\u0026quot; title=\u0026quot;7,181 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Siyuan Ren\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment39700380_14461532\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-08-22 10:48:05Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 22, 2014 at 10:48\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;What the? I had no idea operators could be marked virtual\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1124744/paulm\u0026quot; title=\u0026quot;5,428 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;paulm\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment45898479_14461532\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-03-02 15:23:43Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 2, 2015 at 15:23\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;C++ is \u0026lt;b\u0026gt;not\u0026lt;/b\u0026gt; Java! If \u0026lt;code\u0026gt;wantAnA\u0026lt;/code\u0026gt; (as its name implies!) wants an \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;, then that\u0026apos;s what it gets. And an instance of \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;, will, uh, behave like an \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;. How is that surprising?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1582403/fgp\u0026quot; title=\u0026quot;7,708 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;fgp\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment20145814_274636\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-01-22 16:39:53Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 22, 2013 at 16:39\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@fgp: It\u0026apos;s surprising, because you \u0026lt;b\u0026gt;don\u0026apos;t pass an A\u0026lt;/b\u0026gt; to the function.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/25234/black\u0026quot; title=\u0026quot;4,860 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Black\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment21389243_274636\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-03-03 07:03:26Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 3, 2013 at 7:03\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@fgp: The behaviour is similar. However, to the average C++ programmer it might be less obvious. As far as I understood the question, nobody is \u0026quot;complaining\u0026quot;. It\u0026apos;s just about how the compiler handles the situation. Imho, it is better to avoid slicing at all by passing (const) references.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/25234/black\u0026quot; title=\u0026quot;4,860 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Black\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment22577037_274636\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-04-07 12:13:33Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 7, 2013 at 12:13\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@ThomasW No, I would not throw out inheritance, but use references. If the signature of wantAnA would be \u0026lt;b\u0026gt;void wantAnA(const A \u0026amp;amp; myA)\u0026lt;/b\u0026gt;, then there had been not slicing. Instead, a read-only reference to the caller\u0026apos;s object is passed.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/25234/black\u0026quot; title=\u0026quot;4,860 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Black\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment24188927_274636\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-05-28 07:44:30Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 28, 2013 at 7:44\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;the problem is mostly on the automatic casting that the compiler performs from \u0026lt;code\u0026gt;derived\u0026lt;/code\u0026gt; to the type \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;. Implicit casting is always a source of unexpected behavior in C++, because it is often hard to understand from looking at the code locally that a cast took place.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/686184/pqnet\u0026quot; title=\u0026quot;5,347 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;pqnet\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment39192298_274636\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-08-06 23:15:24Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 6, 2014 at 23:15\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Hello. Great answer but I have one question. If I do something like this **\tdev d; base* b = \u0026amp;amp;d;** The slicing also takes place?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/5605546/adrian\u0026quot; title=\u0026quot;794 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Adrian\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment89496282_25453490\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-07-10 06:58:48Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 10, 2018 at 6:58\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Adrian If you introduce some new member functions or member variables in the derived class then those are not accessible from the base class pointer directly. However you can still access them from inside the overloaded base class virtual functions. See  this: \u0026lt;a href=\u0026quot;https://godbolt.org/z/LABx33\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;godbolt.org/z/LABx33\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/5701173/vishal-sharma\u0026quot; title=\u0026quot;1,530 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Vishal Sharma\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment105135400_25453490\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-12-25 14:20:41Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 25, 2019 at 14:20\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 3 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Please explain how the memory corruption can occur.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/27596/foraidt\u0026quot; title=\u0026quot;5,439 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;foraidt\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment127655_274654\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2008-11-08 12:48:51Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 8, 2008 at 12:48\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I forgot that the copy ctor will reset the vptr, my mistake. But you can still get corruption if A has a pointer, and B sets that to point into B\u0026apos;s section that gets sliced off.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/33949/walter-bright\u0026quot; title=\u0026quot;4,191 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Walter Bright\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment131226_274654\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2008-11-11 02:21:25Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 11, 2008 at 2:21\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;This problem isn\u0026apos;t just limited to slicing. Any classes that contain pointers are going to have dubious behaviour with a default assignment operator and copy-constructor.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2283/weeble\u0026quot; title=\u0026quot;16,043 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Weeble\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment348944_274654\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-02-11 11:54:47Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 11, 2009 at 11:54\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Weeble - Which is why you override the default destructor, assignment operator and copy-constructor in these cases.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/81398/bjarke-freund-hansen\u0026quot; title=\u0026quot;26,352 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Bjarke Freund-Hansen\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment1000931_274654\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-07-24 19:55:59Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 24, 2009 at 19:55\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Weeble: What makes object slicing worse than general pointer fixups is that to be certain you have prevented slicing from happening, a base class must provide converting constructors \u0026lt;i\u0026gt;for every derived class\u0026lt;/i\u0026gt;.  (Why?  Any derived classes that are missed are susceptible to being picked up by the base class\u0026apos;s copy ctor, since \u0026lt;code\u0026gt;Derived\u0026lt;/code\u0026gt; is implicitly convertible to \u0026lt;code\u0026gt;Base\u0026lt;/code\u0026gt;.)  This is obviously counter to the Open-Closed Principle, and a big maintenance burden.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/47984/j-random-hacker\u0026quot; title=\u0026quot;49,399 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;j_random_hacker\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment17719248_274654\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-10-24 12:30:26Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 24, 2012 at 12:30\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026quot;\u0026lt;i\u0026gt;You can also mark the copy constructor on the base explicit\u0026lt;/i\u0026gt;\u0026quot; which does \u0026lt;b\u0026gt;not\u0026lt;/b\u0026gt; help at all.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/963864/curiousguy\u0026quot; title=\u0026quot;7,758 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;curiousguy\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment15699737_274977\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-08-04 22:25:20Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 4, 2012 at 22:25\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026quot;\u0026lt;i\u0026gt;\u0026quot;normal\u0026quot; object behavior\u0026lt;/i\u0026gt;\u0026quot; that\u0026apos;s not \u0026quot;normal object behaviour\u0026quot;, that\u0026apos;s \u0026lt;b\u0026gt;reference semantic\u0026lt;/b\u0026gt;. And it relates \u0026lt;b\u0026gt;in no way\u0026lt;/b\u0026gt; with C \u0026lt;code\u0026gt;struct\u0026lt;/code\u0026gt;, compatibility, or other non-sense the any random OOP priest told you.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/963864/curiousguy\u0026quot; title=\u0026quot;7,758 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;curiousguy\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment10203112_275428\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-11-27 11:27:15Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 27, 2011 at 11:27\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@curiousguy Amen, brother. It\u0026apos;s sad to see how often C++ get bashed from not being Java, when value semantics is one of the things that makes C++ so insanely powerfull.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1582403/fgp\u0026quot; title=\u0026quot;7,708 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;fgp\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment20145903_275428\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-01-22 16:42:40Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 22, 2013 at 16:42\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;This  is not a feature, not a quirk/misfeature. It is normal on-stack-copying behavior, since calling a function with an arg or (same) allocating stack variable of type \u0026lt;code\u0026gt;Base\u0026lt;/code\u0026gt; must take exactly \u0026lt;code\u0026gt;sizeof(Base)\u0026lt;/code\u0026gt; bytes in memory, with possible alignment, maybe, that\u0026apos;s why \u0026quot;assignment\u0026quot; (on-stack-copy) will not copy derived class members, their offsets are outside sizeof. To avoid \u0026quot;losing data\u0026quot;, just use pointer, like anyone else, since pointer memory is fixed in place and size, whereas stack is very volitile\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3367446/croll\u0026quot; title=\u0026quot;3,401 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Croll\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment93568998_275428\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-11-16 20:32:51Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 16, 2018 at 20:32\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 6 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Definitely a misfeature of C++. Assigning a derived object to a base object should be banned, while binding a derived object to a reference or a pointer of the base class should be OK.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/6156470/john-z-li\u0026quot; title=\u0026quot;1,753 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;John Z. Li\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment98550780_275428\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-05-02 09:11:27Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 2, 2019 at 9:11\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I understand the \u0026quot;slicing\u0026quot; part, but I don\u0026apos;t understand \u0026quot;problem\u0026quot;. How is it a problem that some state of \u0026lt;code\u0026gt;dog\u0026lt;/code\u0026gt; that isn\u0026apos;t part of class \u0026lt;code\u0026gt;Pet\u0026lt;/code\u0026gt; (the \u0026lt;code\u0026gt;breed\u0026lt;/code\u0026gt; data member) isn\u0026apos;t copied in the variable \u0026lt;code\u0026gt;pet\u0026lt;/code\u0026gt;? The code is is only interested in the \u0026lt;code\u0026gt;Pet\u0026lt;/code\u0026gt; data members - apparently. Slicing is definitely a \u0026quot;problem\u0026quot; if it is unwanted, but I don\u0026apos;t see that here.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/963864/curiousguy\u0026quot; title=\u0026quot;7,758 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;curiousguy\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment11786426_9047531\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-02-18 04:18:43Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 18, 2012 at 4:18\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026quot;\u0026lt;code\u0026gt;((Dog *)ptrP)\u0026lt;/code\u0026gt;\u0026quot; I suggest using \u0026lt;code\u0026gt;static_cast\u0026amp;lt;Dog*\u0026amp;gt;(ptrP)\u0026lt;/code\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/963864/curiousguy\u0026quot; title=\u0026quot;7,758 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;curiousguy\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment11786443_9047531\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-02-18 04:20:21Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 18, 2012 at 4:20\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I suggest pointing out that you will make the string \u0026apos;breed\u0026apos; eventually leak memory without a virtual destructor (the destructor of \u0026apos;string\u0026apos; will not be called) when deleting through \u0026apos;ptrP\u0026apos;... Why is what you show problematic? The fix is mostly proper class design. The problem in this case is that writing down constructors to control visibility when inheriting is tedious and easily forgotten. You won\u0026apos;t get anywhere near the danger zone with your code as there is no polymorphism involved or even mentioned (slicing will truncate your object but not make your program crash, here).\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1634073/dude\u0026quot; title=\u0026quot;583 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Dude\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment17548976_9047531\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-10-18 02:58:34Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 18, 2012 at 2:58\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;-1 This completely fails to explain the actual problem. C++ has value semantics, \u0026lt;b\u0026gt;not\u0026lt;/b\u0026gt; reference semantics like Java, so this is all entirely to be expected. And the \u0026quot;fix\u0026quot; really is an example of truely \u0026lt;i\u0026gt;horrible\u0026lt;/i\u0026gt; C++ code. \u0026quot;Fixing\u0026quot; non-existing problems like this type of slicing by resorting to dynamic allocation is a recipe for buggy code, leaked memory and horrible performance. Note that there \u0026lt;i\u0026gt;are\u0026lt;/i\u0026gt; cases where slicing is bad, but this answer failes to point them out. Hint: the trouble starts if you assign through \u0026lt;i\u0026gt;references\u0026lt;/i\u0026gt;.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1582403/fgp\u0026quot; title=\u0026quot;7,708 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;fgp\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment20145662_9047531\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-01-22 16:35:50Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 22, 2013 at 16:35\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Have to give a -1, This is a compile-time error, not a run-time error, Pet::breed does not exist.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2574612/nicholas-pipitone\u0026quot; title=\u0026quot;3,834 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Nicholas Pipitone\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment113045981_9047531\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2020-09-16 22:20:18Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 16, 2020 at 22:20\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;But remember, Minok, that you\u0026apos;re NOT passing in a reference of that object. You\u0026apos;re passing a NEW copy of that object, but using the base class to copy it in the process.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/52273/arafangion\u0026quot; title=\u0026quot;11,054 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Arafangion\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment4935237_1179794\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-12-22 11:06:31Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 22, 2010 at 11:06\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;protected copy/assignment on the base class and this problem is solved.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1634073/dude\u0026quot; title=\u0026quot;583 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Dude\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment17548901_1179794\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-10-18 02:51:41Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 18, 2012 at 2:51\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;You\u0026apos;re right. Good practice is to use abstract base classes or to restrict the access to copy/assignment. However, it\u0026apos;s not so easy to spot once it\u0026apos;s there and easy to forget to take care of. Calling virtual methods with sliced *this can make mysterious things happen if you get away without an access violation.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1634073/dude\u0026quot; title=\u0026quot;583 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Dude\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment17549057_1179794\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-10-18 03:06:38Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 18, 2012 at 3:06\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I recall from my C++ programming courses in university that there were standing best practices that for every class we created, we were required to write default constructors, copy constructors and assignment operators, as well as a destructor.  This way you made sure that copy construction and the like happened the way you needed it to, while writing the class... rather than later on some odd behavior showing up.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/144719/minok\u0026quot; title=\u0026quot;522 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Minok\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment38797258_1179794\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-07-25 17:24:54Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 25, 2014 at 17:24\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Would you mind giving some extra details? How does your answer differ from the already posted ones?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1065525/alexis-pigeon\u0026quot; title=\u0026quot;7,243 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Alexis Pigeon\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment18687530_13625934\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-11-29 12:55:02Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 29, 2012 at 12:55\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I guess that more explanation wouldn\u0026apos;t be bad.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1582846/looper\u0026quot; title=\u0026quot;1,861 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;looper\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment18687543_13625934\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-11-29 12:55:28Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 29, 2012 at 12:55\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Downvoted because that\u0026apos;s not a good example. It wouldn\u0026apos;t work either if instead of copying d to b, you would use a pointer in which case d and e would still exist but Base doesn\u0026apos;t have those members. Your example only shows that you can\u0026apos;t access members that the class doesn\u0026apos;t have.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3314225/stefan-fabian\u0026quot; title=\u0026quot;468 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Stefan Fabian\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment97553997_45184425\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-03-29 12:33:50Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 29, 2019 at 12:33\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/q/31816095\u0026quot;\u0026gt;Why should I not #include \u0026amp;lt;bits/stdc++.h\u0026amp;gt;?\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;https://stackoverflow.com/q/1452721\u0026quot;\u0026gt;Why is using namespace std; considered bad practice?\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/995714/phuclv\u0026quot; title=\u0026quot;32,962 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;phuclv\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment118689466_45184425\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2021-04-18 11:06:55Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 18, 2021 at 11:06\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        "],"id":78,"title":"What is object slicing?","content":"\n                \n\u0026lt;p\u0026gt;In c++ what is object slicing and when does it occur?\u0026lt;/p\u0026gt;\n    ","slug":"what-is-object-slicing-1657384506425","postType":"QUESTION","createdAt":"2022-07-09T16:35:06.000Z","updatedAt":"2022-07-09T16:35:06.000Z","tags":[{"id":285,"name":"inheritance","slug":"inheritance","createdAt":"2022-07-09T16:35:06.000Z","updatedAt":"2022-07-09T16:35:06.000Z","Questions_Tags":{"questionId":78,"tagId":285}},{"id":286,"name":"object-slicing","slug":"object-slicing","createdAt":"2022-07-09T16:35:06.000Z","updatedAt":"2022-07-09T16:35:06.000Z","Questions_Tags":{"questionId":78,"tagId":286}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"what-is-object-slicing-1657384506425"},"buildId":"4Y8KGE-c2lolBeBmcum_I","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>