{"pageProps":{"data":{"answer":["\n&lt;p&gt;Arguments are &lt;a href=&quot;http://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference&quot; rel=&quot;noreferrer&quot;&gt;passed by assignment&lt;/a&gt;. The rationale behind this is twofold:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;the parameter passed in is actually a &lt;em&gt;reference&lt;/em&gt; to an object (but the reference is passed by value)&lt;/li&gt;\n&lt;li&gt;some data types are mutable, but others aren&apos;t&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;So:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;If you pass a &lt;em&gt;mutable&lt;/em&gt; object into a method, the method gets a reference to that same object and you can mutate it to your heart&apos;s delight, but if you rebind the reference in the method, the outer scope will know nothing about it, and after you&apos;re done, the outer reference will still point at the original object. &lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;If you pass an &lt;em&gt;immutable&lt;/em&gt; object to a method, you still can&apos;t rebind the outer reference, and you can&apos;t even mutate the object.&lt;/p&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;To make it even more clear, let&apos;s have some examples. &lt;/p&gt;\n\n&lt;h2&gt;List - a mutable type&lt;/h2&gt;\n\n&lt;p&gt;&lt;strong&gt;Let&apos;s try to modify the list that was passed to a method:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;try_to_change_list_contents&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;the_list&lt;/span&gt;):\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;got&apos;&lt;/span&gt;, the_list)\n    the_list.append(&lt;span class=&quot;hljs-string&quot;&gt;&apos;four&apos;&lt;/span&gt;)\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;changed to&apos;&lt;/span&gt;, the_list)\n\nouter_list = [&lt;span class=&quot;hljs-string&quot;&gt;&apos;one&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;two&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;three&apos;&lt;/span&gt;]\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;before, outer_list =&apos;&lt;/span&gt;, outer_list)\ntry_to_change_list_contents(outer_list)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;after, outer_list =&apos;&lt;/span&gt;, outer_list)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Output:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-none s-code-block&quot;&gt;&lt;code&gt;before, outer_list = [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]\ngot [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]\nchanged to [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;, &apos;four&apos;]\nafter, outer_list = [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;, &apos;four&apos;]\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Since the parameter passed in is a reference to &lt;code&gt;outer_list&lt;/code&gt;, not a copy of it, we can use the mutating list methods to change it and have the changes reflected in the outer scope.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Now let&apos;s see what happens when we try to change the reference that was passed in as a parameter:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;try_to_change_list_reference&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;the_list&lt;/span&gt;):\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;got&apos;&lt;/span&gt;, the_list)\n    the_list = [&lt;span class=&quot;hljs-string&quot;&gt;&apos;and&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;we&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;can&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;not&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;lie&apos;&lt;/span&gt;]\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;set to&apos;&lt;/span&gt;, the_list)\n\nouter_list = [&lt;span class=&quot;hljs-string&quot;&gt;&apos;we&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;like&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;proper&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;English&apos;&lt;/span&gt;]\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;before, outer_list =&apos;&lt;/span&gt;, outer_list)\ntry_to_change_list_reference(outer_list)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;after, outer_list =&apos;&lt;/span&gt;, outer_list)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Output:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-none s-code-block&quot;&gt;&lt;code&gt;before, outer_list = [&apos;we&apos;, &apos;like&apos;, &apos;proper&apos;, &apos;English&apos;]\ngot [&apos;we&apos;, &apos;like&apos;, &apos;proper&apos;, &apos;English&apos;]\nset to [&apos;and&apos;, &apos;we&apos;, &apos;can&apos;, &apos;not&apos;, &apos;lie&apos;]\nafter, outer_list = [&apos;we&apos;, &apos;like&apos;, &apos;proper&apos;, &apos;English&apos;]\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Since the &lt;code&gt;the_list&lt;/code&gt; parameter was passed by value, assigning a new list to it had no effect that the code outside the method could see. The &lt;code&gt;the_list&lt;/code&gt; was a copy of the &lt;code&gt;outer_list&lt;/code&gt; reference, and we had &lt;code&gt;the_list&lt;/code&gt; point to a new list, but there was no way to change where &lt;code&gt;outer_list&lt;/code&gt; pointed.&lt;/p&gt;\n\n&lt;h2&gt;String - an immutable type&lt;/h2&gt;\n\n&lt;p&gt;&lt;strong&gt;It&apos;s immutable, so there&apos;s nothing we can do to change the contents of the string&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Now, let&apos;s try to change the reference&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;try_to_change_string_reference&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;the_string&lt;/span&gt;):\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;got&apos;&lt;/span&gt;, the_string)\n    the_string = &lt;span class=&quot;hljs-string&quot;&gt;&apos;In a kingdom by the sea&apos;&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;set to&apos;&lt;/span&gt;, the_string)\n\nouter_string = &lt;span class=&quot;hljs-string&quot;&gt;&apos;It was many and many a year ago&apos;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;before, outer_string =&apos;&lt;/span&gt;, outer_string)\ntry_to_change_string_reference(outer_string)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;after, outer_string =&apos;&lt;/span&gt;, outer_string)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Output:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-none s-code-block&quot;&gt;&lt;code&gt;before, outer_string = It was many and many a year ago\ngot It was many and many a year ago\nset to In a kingdom by the sea\nafter, outer_string = It was many and many a year ago\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Again, since the &lt;code&gt;the_string&lt;/code&gt; parameter was passed by value, assigning a new string to it had no effect that the code outside the method could see. The &lt;code&gt;the_string&lt;/code&gt; was a copy of the &lt;code&gt;outer_string&lt;/code&gt; reference, and we had &lt;code&gt;the_string&lt;/code&gt; point to a new string, but there was no way to change where &lt;code&gt;outer_string&lt;/code&gt; pointed.&lt;/p&gt;\n\n&lt;p&gt;I hope this clears things up a little.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;EDIT:&lt;/strong&gt; It&apos;s been noted that this doesn&apos;t answer the question that @David originally asked, &quot;Is there something I can do to pass the variable by actual reference?&quot;. Let&apos;s work on that.&lt;/p&gt;\n\n&lt;h2&gt;How do we get around this?&lt;/h2&gt;\n\n&lt;p&gt;As @Andrea&apos;s answer shows, you could return the new value. This doesn&apos;t change the way things are passed in, but does let you get the information you want back out:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;return_a_whole_new_string&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;the_string&lt;/span&gt;):\n    new_string = something_to_do_with_the_old_string(the_string)\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; new_string\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# then you could call it like&lt;/span&gt;\nmy_string = return_a_whole_new_string(my_string)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;If you really wanted to avoid using a return value, you could create a class to hold your value and pass it into the function or use an existing class, like a list:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;use_a_wrapper_to_simulate_pass_by_reference&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;stuff_to_change&lt;/span&gt;):\n    new_string = something_to_do_with_the_old_string(stuff_to_change[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;])\n    stuff_to_change[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = new_string\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# then you could call it like&lt;/span&gt;\nwrapper = [my_string]\nuse_a_wrapper_to_simulate_pass_by_reference(wrapper)\n\ndo_something_with(wrapper[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;])\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Although this seems a little cumbersome.&lt;/p&gt;\n    ","\n&lt;p&gt;The problem comes from a misunderstanding of what variables are in Python. If you&apos;re used to most traditional languages, you have a mental model of what happens in the following sequence:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;a = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\na = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You believe that &lt;code&gt;a&lt;/code&gt; is a memory location that stores the value &lt;code&gt;1&lt;/code&gt;, then is updated to store the value &lt;code&gt;2&lt;/code&gt;. That&apos;s not how things work in Python. Rather, &lt;code&gt;a&lt;/code&gt; starts as a reference to an object with the value &lt;code&gt;1&lt;/code&gt;, then gets reassigned as a reference to an object with the value &lt;code&gt;2&lt;/code&gt;. Those two objects may continue to coexist even though &lt;code&gt;a&lt;/code&gt; doesn&apos;t refer to the first one anymore; in fact they may be shared by any number of other references within the program.&lt;/p&gt;\n\n&lt;p&gt;When you call a function with a parameter, a new reference is created that refers to the object passed in. This is separate from the reference that was used in the function call, so there&apos;s no way to update that reference and make it refer to a new object. In your example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n    self.variable = &lt;span class=&quot;hljs-string&quot;&gt;&apos;Original&apos;&lt;/span&gt;\n    self.Change(self.variable)\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;Change&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, var&lt;/span&gt;):\n    var = &lt;span class=&quot;hljs-string&quot;&gt;&apos;Changed&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;self.variable&lt;/code&gt; is a reference to the string object &lt;code&gt;&apos;Original&apos;&lt;/code&gt;. When you call &lt;code&gt;Change&lt;/code&gt; you create a second reference &lt;code&gt;var&lt;/code&gt; to the object. Inside the function you reassign the reference &lt;code&gt;var&lt;/code&gt; to a different string object &lt;code&gt;&apos;Changed&apos;&lt;/code&gt;, but the reference &lt;code&gt;self.variable&lt;/code&gt; is separate and does not change.&lt;/p&gt;\n\n&lt;p&gt;The only way around this is to pass a mutable object. Because both references refer to the same object, any changes to the object are reflected in both places.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):         \n    self.variable = [&lt;span class=&quot;hljs-string&quot;&gt;&apos;Original&apos;&lt;/span&gt;]\n    self.Change(self.variable)\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;Change&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, var&lt;/span&gt;):\n    var[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;hljs-string&quot;&gt;&apos;Changed&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I found the other answers rather long and complicated, so I created this simple diagram to explain the way Python treats variables and parameters.\n&lt;a href=&quot;https://i.stack.imgur.com/FdaCu.png&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/FdaCu.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;It is neither pass-by-value or pass-by-reference - it is call-by-object. See this, by Fredrik Lundh:&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;http://web.archive.org/web/20201111195827/http://www.effbot.org/zone/call-by-object.htm&quot; rel=&quot;noreferrer&quot;&gt;http://effbot.org/zone/call-by-object.htm&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Here is a significant quote:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&quot;...variables [names] are &lt;em&gt;not&lt;/em&gt; objects; they cannot be denoted by other variables or referred to by objects.&quot;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;In your example, when the &lt;code&gt;Change&lt;/code&gt; method is called--a &lt;a href=&quot;http://docs.python.org/2/tutorial/classes.html#python-scopes-and-namespaces&quot; rel=&quot;noreferrer&quot;&gt;namespace&lt;/a&gt; is created for it; and &lt;code&gt;var&lt;/code&gt; becomes a name, within that namespace, for the string object &lt;code&gt;&apos;Original&apos;&lt;/code&gt;. That object then has a name in two namespaces. Next, &lt;code&gt;var = &apos;Changed&apos;&lt;/code&gt; binds &lt;code&gt;var&lt;/code&gt; to a new string object, and thus the method&apos;s namespace forgets about &lt;code&gt;&apos;Original&apos;&lt;/code&gt;. Finally, that namespace is forgotten, and the string &lt;code&gt;&apos;Changed&apos;&lt;/code&gt; along with it.&lt;/p&gt;\n    ","\n&lt;p&gt;Think of stuff being passed &lt;strong&gt;by assignment&lt;/strong&gt; instead of by reference/by value. That way, it is always clear, what is happening as long as you understand what happens during the normal assignment.&lt;/p&gt;\n\n&lt;p&gt;So, when passing a list to a function/method, the list is assigned to the parameter name. Appending to the list will result in the list being modified. Reassigning the list &lt;em&gt;inside&lt;/em&gt; the function will not change the original list, since:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;a = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]\nb = a\nb.append(&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;)\nb = [&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;]\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; a, b      &lt;span class=&quot;hljs-comment&quot;&gt;# prints [1, 2, 3, 4] [&apos;a&apos;, &apos;b&apos;]&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Since immutable types cannot be modified, they &lt;em&gt;seem&lt;/em&gt; like being passed by value - passing an int into a function means assigning the int to the function&apos;s parameter. You can only ever reassign that, but it won&apos;t change the original variables value.&lt;/p&gt;\n    ","\n&lt;h1&gt;There are no variables in Python&lt;/h1&gt;\n\n&lt;p&gt;The key to understanding parameter passing is to stop thinking about &quot;variables&quot;. There are names and objects in Python and together they\nappear like variables, but it is useful to always distinguish the three.&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;Python has names and objects.&lt;/li&gt;\n&lt;li&gt;Assignment binds a name to an object.&lt;/li&gt;\n&lt;li&gt;Passing an argument into a function also binds a name (the parameter name of the function) to an object.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;That is all there is to it. Mutability is irrelevant to this question.&lt;/p&gt;\n\n&lt;p&gt;Example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;a = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This binds the name &lt;code&gt;a&lt;/code&gt; to an object of type integer that holds the value 1.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;b = x\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This binds the name &lt;code&gt;b&lt;/code&gt; to the same object that the name &lt;code&gt;x&lt;/code&gt; is currently bound to.\nAfterward, the name &lt;code&gt;b&lt;/code&gt; has nothing to do with the name &lt;code&gt;x&lt;/code&gt; anymore.&lt;/p&gt;\n\n&lt;p&gt;See sections &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#objects-values-and-types&quot; rel=&quot;noreferrer&quot;&gt;3.1&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/reference/executionmodel.html#naming-and-binding&quot; rel=&quot;noreferrer&quot;&gt;4.2&lt;/a&gt; in the Python 3 language reference.&lt;/p&gt;\n\n&lt;h1&gt;How to read the example in the question&lt;/h1&gt;\n\n&lt;p&gt;In the code shown in the question, the statement &lt;code&gt;self.Change(self.variable)&lt;/code&gt; binds the name &lt;code&gt;var&lt;/code&gt; (in the scope of function &lt;code&gt;Change&lt;/code&gt;) to the object that holds the value &lt;code&gt;&apos;Original&apos;&lt;/code&gt; and the assignment &lt;code&gt;var = &apos;Changed&apos;&lt;/code&gt; (in the body of function &lt;code&gt;Change&lt;/code&gt;) assigns that same name again: to some other object (that happens to hold a string as well but could have been something else entirely).&lt;/p&gt;\n\n&lt;h1&gt;How to pass by reference&lt;/h1&gt;\n\n&lt;p&gt;So if the thing you want to change is a mutable object, there is no problem, as everything is effectively passed by reference.&lt;/p&gt;\n\n&lt;p&gt;If it is an &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#objects-values-and-types&quot; rel=&quot;noreferrer&quot;&gt;immutable&lt;/a&gt; object (e.g. a bool, number, string), the way to go is to wrap it in a mutable object.&lt;br&gt;\nThe quick-and-dirty solution for this is a one-element list (instead of &lt;code&gt;self.variable&lt;/code&gt;, pass &lt;code&gt;[self.variable]&lt;/code&gt; and in the function modify &lt;code&gt;var[0]&lt;/code&gt;).&lt;br&gt;\nThe more &lt;a href=&quot;https://www.python.org/dev/peps/pep-0020/&quot; rel=&quot;noreferrer&quot;&gt;pythonic&lt;/a&gt; approach would be to introduce a trivial, one-attribute class. The function receives an instance of the class and manipulates the attribute.&lt;/p&gt;\n    ","\n&lt;p&gt;Effbot (aka Fredrik Lundh) has described Python&apos;s variable passing style as call-by-object:  &lt;a href=&quot;http://effbot.org/zone/call-by-object.htm&quot;&gt;http://effbot.org/zone/call-by-object.htm&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Objects are allocated on the heap and pointers to them can be passed around anywhere.  &lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;When you make an assignment such as &lt;code&gt;x = 1000&lt;/code&gt;, a dictionary entry is created that maps the string &quot;x&quot; in the current namespace to a pointer to the integer object containing one thousand.   &lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;When you update &quot;x&quot; with &lt;code&gt;x = 2000&lt;/code&gt;, a new integer object is created and the dictionary is updated to point at the new object.  The old one thousand object is unchanged (and may or may not be alive depending on whether anything else refers to the object).&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;When you do a new assignment such as &lt;code&gt;y = x&lt;/code&gt;, a new dictionary entry &quot;y&quot; is created that points to the same object as the entry for &quot;x&quot;.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Objects like strings and integers are &lt;em&gt;immutable&lt;/em&gt;.  This simply means that there are no methods that can change the object after it has been created.  For example, once the integer object one-thousand is created, it will never change.  Math is done by creating new integer objects.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Objects like lists are &lt;em&gt;mutable&lt;/em&gt;.  This means that the contents of the object can be changed by anything pointing to the object.  For example, &lt;code&gt;x = []; y = x; x.append(10); print y&lt;/code&gt; will print &lt;code&gt;[10]&lt;/code&gt;.  The empty list was created.  Both &quot;x&quot; and &quot;y&quot; point to the same list.  The &lt;em&gt;append&lt;/em&gt; method mutates (updates) the list object (like adding a record to a database) and the result is visible to both &quot;x&quot; and &quot;y&quot; (just as a database update would be visible to every connection to that database).&lt;/p&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Hope that clarifies the issue for you. &lt;/p&gt;\n    ","\n&lt;p&gt;Technically, &lt;strong&gt;Python always uses pass by reference values&lt;/strong&gt;. I am going to repeat &lt;a href=&quot;https://stackoverflow.com/a/12438316/1346705&quot;&gt;my other answer&lt;/a&gt; to support my statement.&lt;/p&gt;\n\n&lt;p&gt;Python always uses pass-by-reference values. There isn&apos;t any exception. Any variable assignment means copying the reference value. No exception. Any variable is the name bound to the reference value. Always.&lt;/p&gt;\n\n&lt;p&gt;You can think about a reference value as the address of the target object. The address is automatically dereferenced when used. This way, working with the reference value, it seems you work directly with the target object. But there always is a reference in between, one step more to jump to the target.&lt;/p&gt;\n\n&lt;p&gt;Here is the example that proves that Python uses passing by reference:&lt;/p&gt;\n\n&lt;p&gt;&lt;img src=&quot;https://i.stack.imgur.com/uzXcP.png&quot; alt=&quot;Illustrated example of passing the argument&quot;&gt;&lt;/p&gt;\n\n&lt;p&gt;If the argument was passed by value, the outer &lt;code&gt;lst&lt;/code&gt; could not be modified. The green are the target objects (the black is the value stored inside, the red is the object type), the yellow is the memory with the reference value inside -- drawn as the arrow. The blue solid arrow is the reference value that was passed to the function (via the dashed blue arrow path). The ugly dark yellow is the internal dictionary. (It actually could be drawn also as a green ellipse. The colour and the shape only says it is internal.)&lt;/p&gt;\n\n&lt;p&gt;You can use the &lt;a href=&quot;http://docs.python.org/3.3/library/functions.html#id&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;id()&lt;/code&gt;&lt;/a&gt; built-in function to learn what the reference value is (that is, the address of the target object).&lt;/p&gt;\n\n&lt;p&gt;In compiled languages, a variable is a memory space that is able to capture the value of the type. In Python, a variable is a name (captured internally as a string) bound to the reference variable that holds the reference value to the target object. The name of the variable is the key in the internal dictionary, the value part of that dictionary item stores the reference value to the target.&lt;/p&gt;\n\n&lt;p&gt;Reference values are hidden in Python. There isn&apos;t any explicit user type for storing the reference value. However, you can use a list element (or element in any other suitable container type) as the reference variable, because all containers do store the elements also as references to the target objects. In other words, elements are actually not contained inside the container -- only the references to elements are.&lt;/p&gt;\n    ","\n&lt;p&gt;A simple trick I normally use is to just wrap it in a list:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;Change&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, var&lt;/span&gt;):\n    var[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;hljs-string&quot;&gt;&apos;Changed&apos;&lt;/span&gt;\n\nvariable = [&lt;span class=&quot;hljs-string&quot;&gt;&apos;Original&apos;&lt;/span&gt;]\nself.Change(variable)      \n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; variable[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;(Yeah I know this can be inconvenient, but sometimes it is simple enough to do this.)&lt;/p&gt;\n    ","\n&lt;p&gt;(edit - Blair has updated his enormously popular answer so that it is now accurate)&lt;/p&gt;\n\n&lt;p&gt;I think it is important to note that the current post with the most votes (by Blair Conrad), while being correct with respect to its result, is misleading and is borderline incorrect based on its definitions.  While there are many languages (like C) that allow the user to either pass by reference or pass by value, Python is not one of them.&lt;/p&gt;\n\n&lt;p&gt;David Cournapeau&apos;s answer points to the real answer and explains why the behavior in Blair Conrad&apos;s post seems to be correct while the definitions are not.&lt;/p&gt;\n\n&lt;p&gt;To the extent that Python is pass by value, all languages are pass by value since some piece of data (be it a &quot;value&quot; or a &quot;reference&quot;) must be sent. However, that does not mean that Python is pass by value in the sense that a C programmer would think of it.&lt;/p&gt;\n\n&lt;p&gt;If you want the behavior, Blair Conrad&apos;s answer is fine.  But if you want to know the nuts and bolts of why Python is neither pass by value or pass by reference, read David Cournapeau&apos;s answer.&lt;/p&gt;\n    ","\n&lt;p&gt;You got some really good answers here.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;x = [ &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; ]\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; x  &lt;span class=&quot;hljs-comment&quot;&gt;# 2, 4, 4, 5, 5&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;go&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt; li &lt;/span&gt;) :\n  li = [ &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt; ]  &lt;span class=&quot;hljs-comment&quot;&gt;# re-assigning what li POINTS TO, does not&lt;/span&gt;\n  &lt;span class=&quot;hljs-comment&quot;&gt;# change the value of the ORIGINAL variable x&lt;/span&gt;\n\ngo( x ) \n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; x  &lt;span class=&quot;hljs-comment&quot;&gt;# 2, 4, 4, 5, 5  [ STILL! ]&lt;/span&gt;\n\n\nraw_input( &lt;span class=&quot;hljs-string&quot;&gt;&apos;press any key to continue&apos;&lt;/span&gt; )\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Pythons pass-by-assignment scheme isnt quite the same as C++s reference parameters option, but it turns out to be very similar to the argument-passing model of the C language (and others) in practice:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Immutable arguments are effectively passed &lt;strong&gt;by value&lt;/strong&gt;. Objects such as integers and strings are passed by object reference instead of by copying, but because you cant change immutable objects in place anyhow, the effect is much like making a copy.&lt;/li&gt;\n&lt;li&gt;Mutable arguments are effectively passed &lt;strong&gt;by pointer&lt;/strong&gt;. Objects such as lists\nand dictionaries are also passed by object reference, which is similar to the way C\npasses arrays as pointersmutable objects can be changed in place in the function,\nmuch like C arrays.&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;In this case the variable titled &lt;code&gt;var&lt;/code&gt; in the method &lt;code&gt;Change&lt;/code&gt; is assigned a reference to &lt;code&gt;self.variable&lt;/code&gt;, and you immediately assign a string to &lt;code&gt;var&lt;/code&gt;. It&apos;s no longer pointing to &lt;code&gt;self.variable&lt;/code&gt;. The following code snippet shows what would happen if you modify the data structure pointed to by &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;self.variable&lt;/code&gt;, in this case a list:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;PassByReference&lt;/span&gt;:\n&lt;span class=&quot;hljs-meta&quot;&gt;... &lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n&lt;span class=&quot;hljs-meta&quot;&gt;... &lt;/span&gt;        self.variable = [&lt;span class=&quot;hljs-string&quot;&gt;&apos;Original&apos;&lt;/span&gt;]\n&lt;span class=&quot;hljs-meta&quot;&gt;... &lt;/span&gt;        self.change(self.variable)\n&lt;span class=&quot;hljs-meta&quot;&gt;... &lt;/span&gt;        &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; self.variable\n&lt;span class=&quot;hljs-meta&quot;&gt;... &lt;/span&gt;        \n&lt;span class=&quot;hljs-meta&quot;&gt;... &lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;change&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, var&lt;/span&gt;):\n&lt;span class=&quot;hljs-meta&quot;&gt;... &lt;/span&gt;        var.append(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Changed&apos;&lt;/span&gt;)\n&lt;span class=&quot;hljs-meta&quot;&gt;... &lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;q = PassByReference()\n[&lt;span class=&quot;hljs-string&quot;&gt;&apos;Original&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;Changed&apos;&lt;/span&gt;]\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I&apos;m sure someone else could clarify this further.&lt;/p&gt;\n    ","\n&lt;p&gt;A lot of insights in answers here, but i think an additional point is not clearly mentioned here explicitly.   Quoting from python documentation &lt;a href=&quot;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&quot; rel=&quot;noreferrer&quot;&gt;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&lt;/a&gt;  &lt;/p&gt;\n\n&lt;p&gt;&quot;In Python, variables that are only referenced inside a function are implicitly global. If a variable is assigned a new value anywhere within the functions body, its assumed to be a local. If a variable is ever assigned a new value inside the function, the variable is implicitly local, and you need to explicitly declare it as global.\nThough a bit surprising at first, a moments consideration explains this. On one hand, requiring global for assigned variables provides a bar against unintended side-effects. On the other hand, if global was required for all global references, youd be using global all the time. Youd have to declare as global every reference to a built-in function or to a component of an imported module. This clutter would defeat the usefulness of the global declaration for identifying side-effects.&quot;&lt;/p&gt;\n\n&lt;p&gt;Even when passing a mutable object to a function this still applies. And to me clearly explains the reason for the difference in behavior between assigning to the object and operating on the object in the function.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;l&lt;/span&gt;):\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Received&quot;&lt;/span&gt;, l , &lt;span class=&quot;hljs-built_in&quot;&gt;id&lt;/span&gt;(l)\n    l = [&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Changed to&quot;&lt;/span&gt;, l, &lt;span class=&quot;hljs-built_in&quot;&gt;id&lt;/span&gt;(l)  &lt;span class=&quot;hljs-comment&quot;&gt;# New local object created, breaking link to global l&lt;/span&gt;\n\nl= [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Original&quot;&lt;/span&gt;, l, &lt;span class=&quot;hljs-built_in&quot;&gt;id&lt;/span&gt;(l)\ntest(l)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;After&quot;&lt;/span&gt;, l, &lt;span class=&quot;hljs-built_in&quot;&gt;id&lt;/span&gt;(l)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;gives:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;Original [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;] &lt;span class=&quot;hljs-number&quot;&gt;4454645632&lt;/span&gt;\nReceived [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;] &lt;span class=&quot;hljs-number&quot;&gt;4454645632&lt;/span&gt;\nChanged to [&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] &lt;span class=&quot;hljs-number&quot;&gt;4474591928&lt;/span&gt;\nAfter [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;] &lt;span class=&quot;hljs-number&quot;&gt;4454645632&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The assignment to an global variable that is not declared global therefore creates a new local object and breaks the link to the original object.&lt;/p&gt;\n    ","\n&lt;p&gt;As you can state you need to have a mutable object, but let me suggest you to check over the global variables as they can help you or even solve this kind of issue!&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://docs.python.org/3/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&quot; rel=&quot;noreferrer&quot;&gt;http://docs.python.org/3/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;x&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;y&lt;/span&gt;):\n&lt;span class=&quot;hljs-meta&quot;&gt;... &lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;global&lt;/span&gt; z\n&lt;span class=&quot;hljs-meta&quot;&gt;... &lt;/span&gt;    z = y\n...\n\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;x\n&amp;lt;function x at &lt;span class=&quot;hljs-number&quot;&gt;0x00000000020E1730&lt;/span&gt;&amp;gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;y\nTraceback (most recent call last):\n  File &lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;stdin&amp;gt;&quot;&lt;/span&gt;, line &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;\nNameError: name &lt;span class=&quot;hljs-string&quot;&gt;&apos;y&apos;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; defined\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;z\nTraceback (most recent call last):\n  File &lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;stdin&amp;gt;&quot;&lt;/span&gt;, line &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;\nNameError: name &lt;span class=&quot;hljs-string&quot;&gt;&apos;z&apos;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; defined\n\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;x(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;x\n&amp;lt;function x at &lt;span class=&quot;hljs-number&quot;&gt;0x00000000020E1730&lt;/span&gt;&amp;gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;y\nTraceback (most recent call last):\n  File &lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;stdin&amp;gt;&quot;&lt;/span&gt;, line &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;\nNameError: name &lt;span class=&quot;hljs-string&quot;&gt;&apos;y&apos;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; defined\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;z\n&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Here is the simple (I hope) explanation of the concept &lt;code&gt;pass by object&lt;/code&gt; used in Python.&lt;br&gt;\nWhenever you pass an object to the function, the object itself is passed (object in Python is actually what you&apos;d call a value in other programming languages) not the reference to this object. In other words, when you call:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;change_me&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt;&lt;/span&gt;):\n   &lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt; = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]\n\nmy_list = [&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]\nchange_me(my_list)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The actual object - [0, 1] (which would be called a value in other programming languages) is being passed. So in fact the function &lt;code&gt;change_me&lt;/code&gt; will try to do something like:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;which obviously will not change the object passed to the function. If the function looked like this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;change_me&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt;&lt;/span&gt;):\n   &lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt;.append(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Then the call would result in:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;].append(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;which obviously will change the object. &lt;a href=&quot;https://stackoverflow.com/a/534509/831531&quot;&gt;This answer&lt;/a&gt; explains it well.&lt;/p&gt;\n    ","\n&lt;p&gt;Aside from all the great explanations on how this stuff works in Python, I don&apos;t see a simple suggestion for the problem. As you seem to do create objects and instances, the pythonic way of handling instance variables and changing them is the following:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;PassByReference&lt;/span&gt;:\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n        self.variable = &lt;span class=&quot;hljs-string&quot;&gt;&apos;Original&apos;&lt;/span&gt;\n        self.Change()\n        &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; self.variable\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;Change&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n        self.variable = &lt;span class=&quot;hljs-string&quot;&gt;&apos;Changed&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In instance methods, you normally refer to &lt;code&gt;self&lt;/code&gt; to access instance attributes. It is normal to set instance attributes in &lt;code&gt;__init__&lt;/code&gt; and read or change them in instance methods. That is also why you pass &lt;code&gt;self&lt;/code&gt; als the first argument to &lt;code&gt;def Change&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;Another solution would be to create a static method like this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;PassByReference&lt;/span&gt;:\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n        self.variable = &lt;span class=&quot;hljs-string&quot;&gt;&apos;Original&apos;&lt;/span&gt;\n        self.variable = PassByReference.Change(self.variable)\n        &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; self.variable\n\n&lt;span class=&quot;hljs-meta&quot;&gt;    @staticmethod&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;Change&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;var&lt;/span&gt;):\n        var = &lt;span class=&quot;hljs-string&quot;&gt;&apos;Changed&apos;&lt;/span&gt;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; var\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I used the following method to quickly convert a couple of Fortran codes to Python.  True, it&apos;s not pass by reference as the original question was posed, but is a simple work around in some cases.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;a=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;\nb=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;\nc=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;myfunc&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;a,b,c&lt;/span&gt;):\n    a=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n    b=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;\n    c=&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a,b,c\n\na,b,c = myfunc(a,b,c)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; a,b,c\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;There is a little trick to pass an object by reference, even though the language doesn&apos;t make it possible. It works in Java too, it&apos;s the list with one item. ;-)&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;PassByReference&lt;/span&gt;:\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, name&lt;/span&gt;):\n        self.name = name\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;changeRef&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;ref&lt;/span&gt;):\n    ref[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = PassByReference(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Michael&apos;&lt;/span&gt;)\n\nobj = PassByReference(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Peter&apos;&lt;/span&gt;)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; obj.name\n\np = [obj] &lt;span class=&quot;hljs-comment&quot;&gt;# A pointer to obj! ;-)&lt;/span&gt;\nchangeRef(p)\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; p[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;].name &lt;span class=&quot;hljs-comment&quot;&gt;# p-&amp;gt;name&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It&apos;s an ugly hack, but it works. ;-P&lt;/p&gt;\n    ","\n&lt;p&gt;given the way python handles values and references to them, the only way you can reference an arbitrary instance attribute is by name:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;PassByReferenceIsh&lt;/span&gt;:\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n        self.variable = &lt;span class=&quot;hljs-string&quot;&gt;&apos;Original&apos;&lt;/span&gt;\n        self.change(&lt;span class=&quot;hljs-string&quot;&gt;&apos;variable&apos;&lt;/span&gt;)\n        &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; self.variable\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;change&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, var&lt;/span&gt;):\n        self.__dict__[var] = &lt;span class=&quot;hljs-string&quot;&gt;&apos;Changed&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;in real code you would, of course, add error checking on the dict lookup.&lt;/p&gt;\n    ","\n&lt;p&gt;Since your example happens to be object-oriented, you could make the following change to achieve a similar result:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;PassByReference&lt;/span&gt;:\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n        self.variable = &lt;span class=&quot;hljs-string&quot;&gt;&apos;Original&apos;&lt;/span&gt;\n        self.change(&lt;span class=&quot;hljs-string&quot;&gt;&apos;variable&apos;&lt;/span&gt;)\n        &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(self.variable)\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;change&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, var&lt;/span&gt;):\n        &lt;span class=&quot;hljs-built_in&quot;&gt;setattr&lt;/span&gt;(self, var, &lt;span class=&quot;hljs-string&quot;&gt;&apos;Changed&apos;&lt;/span&gt;)\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# o.variable will equal &apos;Changed&apos;&lt;/span&gt;\no = PassByReference()\n&lt;span class=&quot;hljs-keyword&quot;&gt;assert&lt;/span&gt; o.variable == &lt;span class=&quot;hljs-string&quot;&gt;&apos;Changed&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Since it seems to be nowhere mentioned an approach to simulate references as known from e.g. C++ is to use an &quot;update&quot; function and pass that instead of the actual variable (or rather, &quot;name&quot;):&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;need_to_modify&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;update&lt;/span&gt;):\n    update(&lt;span class=&quot;hljs-number&quot;&gt;42&lt;/span&gt;) &lt;span class=&quot;hljs-comment&quot;&gt;# set new value 42&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;# other code&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;call_it&lt;/span&gt;():\n    value = &lt;span class=&quot;hljs-number&quot;&gt;21&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;update_value&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;new_value&lt;/span&gt;):\n        &lt;span class=&quot;hljs-keyword&quot;&gt;nonlocal&lt;/span&gt; value\n        value = new_value\n    need_to_modify(update_value)\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(value) &lt;span class=&quot;hljs-comment&quot;&gt;# prints 42&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This is mostly useful for &quot;out-only references&quot; or in a situation with multiple threads / processes (by making the update function thread / multiprocessing safe).&lt;/p&gt;\n\n&lt;p&gt;Obviously the above does not allow &lt;em&gt;reading&lt;/em&gt; the value, only updating it.&lt;/p&gt;\n    ","\n&lt;p&gt;Since dictionaries are passed by reference, you can use a dict variable to store any referenced values inside it.&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# returns the result of adding numbers `a` and `b`&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;AddNumbers&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;a, b, ref&lt;/span&gt;): &lt;span class=&quot;hljs-comment&quot;&gt;# using a dict for reference&lt;/span&gt;\n    result = a + b\n    ref[&lt;span class=&quot;hljs-string&quot;&gt;&apos;multi&apos;&lt;/span&gt;] = a * b &lt;span class=&quot;hljs-comment&quot;&gt;# reference the multi. ref[&apos;multi&apos;] is number&lt;/span&gt;\n    ref[&lt;span class=&quot;hljs-string&quot;&gt;&apos;msg&apos;&lt;/span&gt;] = &lt;span class=&quot;hljs-string&quot;&gt;&quot;The result: &quot;&lt;/span&gt; + &lt;span class=&quot;hljs-built_in&quot;&gt;str&lt;/span&gt;(result) + &lt;span class=&quot;hljs-string&quot;&gt;&quot; was nice!&quot;&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; result\n\nnumber1 = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;\nnumber2 = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;\nref = {} &lt;span class=&quot;hljs-comment&quot;&gt;# init a dict like that so it can save all the referenced values. this is because all dictionaries are passed by reference, while strings and numbers do not.&lt;/span&gt;\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;sum&lt;/span&gt; = AddNumbers(number1, number2, ref)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;sum: &quot;&lt;/span&gt;, &lt;span class=&quot;hljs-built_in&quot;&gt;sum&lt;/span&gt;)             &lt;span class=&quot;hljs-comment&quot;&gt;# the returned value&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;multi: &quot;&lt;/span&gt;, ref[&lt;span class=&quot;hljs-string&quot;&gt;&apos;multi&apos;&lt;/span&gt;])  &lt;span class=&quot;hljs-comment&quot;&gt;# a referenced value&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;msg: &quot;&lt;/span&gt;, ref[&lt;span class=&quot;hljs-string&quot;&gt;&apos;msg&apos;&lt;/span&gt;])      &lt;span class=&quot;hljs-comment&quot;&gt;# a referenced value&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;While pass by reference is nothing that fits well into python and should be rarely used there are some workarounds that actually can work to get the object currently assigned to a local variable or even reassign a local variable from inside of a called function.&lt;/p&gt;\n\n&lt;p&gt;The basic idea is to have a function that can do that access and can be passed as object into other functions or stored in a class.&lt;/p&gt;\n\n&lt;p&gt;One way is to use &lt;code&gt;global&lt;/code&gt; (for global variables) or &lt;code&gt;nonlocal&lt;/code&gt; (for local variables in a function) in a wrapper function.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;change&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;wrapper&lt;/span&gt;):\n    wrapper(&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;)\n\nx = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;setter&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;val&lt;/span&gt;):\n    &lt;span class=&quot;hljs-keyword&quot;&gt;global&lt;/span&gt; x\n    x = val\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(x)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The same idea works for reading and &lt;code&gt;del&lt;/code&gt;eting a variable.&lt;/p&gt;\n\n&lt;p&gt;For just reading there is even a shorter way of just using &lt;code&gt;lambda: x&lt;/code&gt; which returns a callable that when called returns the current value of x. This is somewhat like &quot;call by name&quot; used in languages in the distant past.&lt;/p&gt;\n\n&lt;p&gt;Passing 3 wrappers to access a variable is a bit unwieldy so those can be wrapped into a class that has a proxy attribute:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ByRef&lt;/span&gt;:\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, r, w, d&lt;/span&gt;):\n        self._read = r\n        self._write = w\n        self._delete = d\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;set&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, val&lt;/span&gt;):\n        self._write(val)\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self._read()\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;remove&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n        self._delete()\n    wrapped = &lt;span class=&quot;hljs-built_in&quot;&gt;property&lt;/span&gt;(get, &lt;span class=&quot;hljs-built_in&quot;&gt;set&lt;/span&gt;, remove)\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# left as an exercise for the reader: define set, get, remove as local functions using global / nonlocal&lt;/span&gt;\nr = ByRef(get, &lt;span class=&quot;hljs-built_in&quot;&gt;set&lt;/span&gt;, remove)\nr.wrapped = &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Pythons &quot;reflection&quot; support makes it possible to get a object that is capable of reassigning a name/variable in a given scope without defining functions explicitly in that scope:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ByRef&lt;/span&gt;:\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, locs, name&lt;/span&gt;):\n        self._locs = locs\n        self._name = name\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;set&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, val&lt;/span&gt;):\n        self._locs[self._name] = val\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self._locs[self._name]\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;remove&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n        &lt;span class=&quot;hljs-keyword&quot;&gt;del&lt;/span&gt; self._locs[self._name]\n    wrapped = &lt;span class=&quot;hljs-built_in&quot;&gt;property&lt;/span&gt;(get, &lt;span class=&quot;hljs-built_in&quot;&gt;set&lt;/span&gt;, remove)\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;change&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;x&lt;/span&gt;):\n    x.wrapped = &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;test_me&lt;/span&gt;():\n    x = &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(x)\n    change(ByRef(&lt;span class=&quot;hljs-built_in&quot;&gt;locals&lt;/span&gt;(), &lt;span class=&quot;hljs-string&quot;&gt;&quot;x&quot;&lt;/span&gt;))\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(x)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here the &lt;code&gt;ByRef&lt;/code&gt; class wraps a dictionary access. So attribute access to &lt;code&gt;wrapped&lt;/code&gt; is translated to a item access in the passed dictionary. By passing the result of the builtin &lt;code&gt;locals&lt;/code&gt; and the name of a local variable this ends up accessing a local variable. The python documentation as of 3.5 advises that changing the dictionary might not work but it seems to work for me.&lt;/p&gt;\n    ","\n&lt;p&gt;You can merely use &lt;strong&gt;an empty class&lt;/strong&gt; as an instance to store reference objects because internally object attributes are stored in an instance dictionary. See the example.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;RefsObj&lt;/span&gt;(&lt;span class=&quot;hljs-title class_ inherited__&quot;&gt;object&lt;/span&gt;):\n    &lt;span class=&quot;hljs-string&quot;&gt;&quot;A class which helps to create references to variables.&quot;&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;pass&lt;/span&gt;\n\n...\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# an example of usage&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;change_ref_var&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;ref_obj&lt;/span&gt;):\n    ref_obj.val = &lt;span class=&quot;hljs-number&quot;&gt;24&lt;/span&gt;\n\nref_obj = RefsObj()\nref_obj.val = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(ref_obj.val) &lt;span class=&quot;hljs-comment&quot;&gt;# or print ref_obj.val for python2&lt;/span&gt;\nchange_ref_var(ref_obj)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(ref_obj.val)\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Pass-By-Reference in Python is quite different from the concept of pass by reference in C++/Java. &lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;Java&amp;amp;C#:&lt;/strong&gt; primitive types(include string)pass by value(copy), Reference type is passed by reference(address copy) so all changes made in the parameter in the called function are visible to the caller.&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;C++:&lt;/strong&gt; Both pass-by-reference or pass-by-value are allowed. If a parameter is passed by reference, you can either modify it or not depending upon whether the parameter was passed as const or not. However, const or not, the parameter maintains the reference to the object and reference cannot be assigned to point to a different object within the called function.&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Python:&lt;/strong&gt; \nPython is pass-by-object-reference, of which it is often said: Object references are passed by value.[Read here]&lt;a href=&quot;https://robertheaton.com/2014/02/09/pythons-pass-by-object-reference-as-explained-by-philip-k-dick/&quot; rel=&quot;nofollow noreferrer&quot;&gt;1&lt;/a&gt;. Both the caller and the function refer to the same object but the parameter in the function is a new variable which is just holding a copy of the object in the caller. Like C++, a parameter can be either modified or not in function - This depends upon the type of object passed. eg; An immutable object type cannot be modified in the called function whereas a mutable object can be either updated or re-initialized. A crucial difference between updating or re-assigning/re-initializing the mutable variable is that updated value gets reflected back in the called function whereas the reinitialized value does not. Scope of any assignment of new object to a mutable variable is local to the function in the python. Examples provided by @blair-conrad are great to understand this.&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;I am new to Python, started yesterday (though I have been programming for 45 years).&lt;/p&gt;\n&lt;p&gt;I came here because I was writing a function where I wanted to have two so called out-parameters. If it would have been only one out-parameter, I wouldn&apos;t get hung up right now on checking how reference/value works in Python. I would just have used the return value of the function instead. But since I needed &lt;em&gt;two&lt;/em&gt; such out-parameters I felt I needed to sort it out.&lt;/p&gt;\n&lt;p&gt;In this post I am going to show how I solved my situation. Perhaps others coming here can find it valuable, even though it is not exactly an answer to the topic question. Experienced Python programmers of course already know about the solution I used, but it was new to me.&lt;/p&gt;\n&lt;p&gt;From the answers here I could quickly see that Python works a bit like Javascript in this regard, and that you need to use workarounds if you want the reference functionality.&lt;/p&gt;\n&lt;p&gt;But then I found something neat in Python that I don&apos;t think I have seen in other languages before, namely that you can return more than one value from a function, in a simple comma separated way, like this:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;somefunction&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;p&lt;/span&gt;):\n    a=p+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n    b=p+&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;\n    c=-p\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a, b, c\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;and that you can handle that on the calling side similarly, like this&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;x, y, z = somefunction(w)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;That was good enough for me and I was satisfied. No need to use some workaround.&lt;/p&gt;\n&lt;p&gt;In other languages you can of course also return many values, but then usually in the from of an object, and you need to adjust the calling side accordingly.&lt;/p&gt;\n&lt;p&gt;The Python way of doing it was nice and simple.&lt;/p&gt;\n&lt;p&gt;If you want to mimic &lt;em&gt;by reference&lt;/em&gt; even more, you could do as follows:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;somefunction&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;a, b, c&lt;/span&gt;):\n    a = a * &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;\n    b = b + a\n    c = a * b * c\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a, b, c\n\nx = &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;\ny = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;\nz = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;F&quot;Before : &lt;span class=&quot;hljs-subst&quot;&gt;{x}&lt;/span&gt;, &lt;span class=&quot;hljs-subst&quot;&gt;{y}&lt;/span&gt;, &lt;span class=&quot;hljs-subst&quot;&gt;{z}&lt;/span&gt;&quot;&lt;/span&gt;)\n\nx, y, z = somefunction(x, y, z)\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;F&quot;After  : &lt;span class=&quot;hljs-subst&quot;&gt;{x}&lt;/span&gt;, &lt;span class=&quot;hljs-subst&quot;&gt;{y}&lt;/span&gt;, &lt;span class=&quot;hljs-subst&quot;&gt;{z}&lt;/span&gt;&quot;&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;which gives this result&lt;/p&gt;\n&lt;pre&gt;Before : 3, 5, 10  \nAfter  : 6, 11, 660  \n&lt;/pre&gt;\n    ","\n&lt;p&gt;alternatively you could use ctypes witch would look something like this&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; ctypes\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;a&lt;/span&gt;):\n    a.value=&lt;span class=&quot;hljs-number&quot;&gt;2398&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;## resign the value in a function&lt;/span&gt;\n\na = ctypes.c_int(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;pre f&quot;&lt;/span&gt;, a)\nf(a)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;post f&quot;&lt;/span&gt;, a)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;as a is a c int and not a python integer and apperently passed by reference. however you have to be carefull as strange things could happen and is therefor not advised&lt;/p&gt;\n    ","\n&lt;p&gt;Most likely not the most reliable method but this works, keep in mind that you are overloading the built-in str function which is typically something you don&apos;t want to do:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; builtins\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;sstr&lt;/span&gt;(&lt;span class=&quot;hljs-title class_ inherited__&quot;&gt;str&lt;/span&gt;):\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__str__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;hasattr&lt;/span&gt;(self, &lt;span class=&quot;hljs-string&quot;&gt;&apos;changed&apos;&lt;/span&gt;):\n            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self.changed\n\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;change&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, value&lt;/span&gt;):\n        self.changed = value\n\nbuiltins.&lt;span class=&quot;hljs-built_in&quot;&gt;str&lt;/span&gt; = sstr\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;change_the_value&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;val&lt;/span&gt;):\n    val.change(&lt;span class=&quot;hljs-string&quot;&gt;&apos;After&apos;&lt;/span&gt;)\n\nval = &lt;span class=&quot;hljs-built_in&quot;&gt;str&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Before&apos;&lt;/span&gt;)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; (val)\nchange_the_value(val)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; (val)\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;What about &lt;a href=&quot;https://docs.python.org/3/library/dataclasses.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;dataclasses&lt;/a&gt;? Also, it allows you to apply type restriction (aka &quot;type hint&quot;).&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; dataclasses &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; dataclass\n\n&lt;span class=&quot;hljs-meta&quot;&gt;@dataclass&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Holder&lt;/span&gt;:\n    obj: your_type &lt;span class=&quot;hljs-comment&quot;&gt;# Need any type? Use &quot;obj: object&quot; then.&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;ref: Holder&lt;/span&gt;):\n    ref.obj = do_something()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;I agree with folks that in most cases you&apos;d better consider not to use it.&lt;/p&gt;\n&lt;p&gt;And yet, when we&apos;re talking about &lt;a href=&quot;https://en.wikipedia.org/wiki/State_pattern&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;em&gt;contexts&lt;/em&gt;&lt;/a&gt; it&apos;s worth to know that way.&lt;/p&gt;\n&lt;p&gt;You can design explicit context class though. When prototyping I prefer dataclasses, just because it&apos;s easy to serialize them back and forth.&lt;/p&gt;\n&lt;p&gt;Cheers!&lt;/p&gt;\n    "],"id":114,"title":"How do I pass a variable by reference?","content":"\n                \n&lt;p&gt;Are parameters passed by reference or by value? How do I pass by reference so that the code below outputs &lt;code&gt;&apos;Changed&apos;&lt;/code&gt; instead of &lt;code&gt;&apos;Original&apos;&lt;/code&gt;?&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;PassByReference&lt;/span&gt;:\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n        self.variable = &lt;span class=&quot;hljs-string&quot;&gt;&apos;Original&apos;&lt;/span&gt;\n        self.change(self.variable)\n        &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(self.variable)\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;change&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, var&lt;/span&gt;):\n        var = &lt;span class=&quot;hljs-string&quot;&gt;&apos;Changed&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","slug":"how-do-i-pass-a-variable-by-reference-1657384657232","postType":"QUESTION","createdAt":"2022-07-09T16:37:37.000Z","updatedAt":"2022-07-09T16:37:37.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"What is a clearfix?","slug":"what-is-a-clearfix-1657387337825"},{"title":"What is the difference between \"px\", \"dip\", \"dp\" and \"sp\"?","slug":"what-is-the-difference-between-\"px\"-\"dip\"-\"dp\"-and-\"sp\"-1657388093250"},{"title":"How can I remove a specific item from an array?","slug":"how-can-i-remove-a-specific-item-from-an-array-1657387552077"},{"title":"Randomize a List<T>","slug":"randomize-a-listlesstgreater-1657388172793"},{"title":"How do I add a delay in a JavaScript loop?","slug":"how-do-i-add-a-delay-in-a-javascript-loop-1657388544679"},{"title":"String.equals versus == [duplicate]","slug":"string.equals-versus-duplicate-1657387599972"},{"title":"Are 'Arrow Functions' and 'Functions' equivalent / interchangeable?","slug":"are-'arrow-functions'-and-'functions'-equivalent-interchangeable-1657384527873"},{"title":"JQuery - $ is not defined","slug":"jquery-dollar-is-not-defined-1657388385731"},{"title":"\"Cross origin requests are only supported for HTTP.\" error when loading a local file","slug":"\"cross-origin-requests-are-only-supported-for-http.\"-error-when-loading-a-local-file-1657387942403"},{"title":"Why is the gets function so dangerous that it should not be used?","slug":"why-is-the-gets-function-so-dangerous-that-it-should-not-be-used-1657384544362"},{"title":"How do JavaScript closures work?","slug":"how-do-javascript-closures-work-1657384418555"},{"title":"Why does Spring MVC respond with a 404 and report \"No mapping found for HTTP request with URI [...] in DispatcherServlet\"?","slug":"why-does-spring-mvc-respond-with-a-404-and-report-\"no-mapping-found-for-http-request-with-uri-...-in-dispatcherservlet\"-1657387995250"},{"title":"Transpose / reshape dataframe without \"timevar\" from long to wide format","slug":"transpose-reshape-dataframe-without-\"timevar\"-from-long-to-wide-format-1657388213347"},{"title":"XMLHttpRequest cannot load XXX No 'Access-Control-Allow-Origin' header","slug":"xmlhttprequest-cannot-load-xxx-no-'access-control-allow-origin'-header-1657384758362"},{"title":"What is an undefined reference/unresolved external symbol error and how do I fix it?","slug":"what-is-an-undefined-referenceunresolved-external-symbol-error-and-how-do-i-fix-it-1657384255179"},{"title":"Why does my recursive function return None?","slug":"why-does-my-recursive-function-return-none-1657387792894"},{"title":"What is the (function() { } )() construct in JavaScript?","slug":"what-is-the-(function()-)()-construct-in-javascript-1657385508348"},{"title":"How do I use extern to share variables between source files?","slug":"how-do-i-use-extern-to-share-variables-between-source-files-1657387453605"},{"title":"How do I format a date in JavaScript?","slug":"how-do-i-format-a-date-in-javascript-1657384649498"},{"title":"How do I use shell variables in an awk script?","slug":"how-do-i-use-shell-variables-in-an-awk-script-1657387754261"}]},"__N_SSG":true}