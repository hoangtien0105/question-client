<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2eccd4d47c856f2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2eccd4d47c856f2b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/471-84c36aa98dd4107c.js" defer=""></script><script src="/_next/static/chunks/81-096e453de8a27667.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-e3d1b60e109d3ba1.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_buildManifest.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.hFcsiD code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-6e32c308-0"]{content:"hFcsiD,"}/*!sc*/
.ljvTUN .comment-item .comment-body .d-inline-flex.ai-center{text-align:right;}/*!sc*/
.ljvTUN .comment-item .comment-body .comment-date{float:right;}/*!sc*/
data-styled.g6[id="sc-6e32c308-1"]{content:"ljvTUN,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="https://flowbite.com/docs/images/logo.svg" class="mr-3 h-6 sm:h-9" alt="Flowbite Logo"/><span class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Hunter</span></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/why-is-iostream%3A%3Aeof-inside-a-loop-condition-(i.e.-while-(!stream.eof()))-considered-wrong-1657384355427#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-6e32c308-0 hFcsiD flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/why-is-iostream::eof-inside-a-loop-condition-(i.e.-while-(!stream.eof()))-considered-wrong-1657384355427">Why is iostream::eof inside a loop condition (i.e. `while (!stream.eof())`) considered wrong?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/iostream">iostream</a></div></div><div class="question-content mt-5">
                
<p>I just found a comment in <a href="https://stackoverflow.com/questions/5578631/c-how-do-you-stop-reading-integer-from-text-file-when-encounter-negative-intege/5578649#5578649">this</a> answer saying that using <code>iostream::eof</code> in a loop condition is "almost certainly wrong". I generally use something like <code>while(cin&gt;&gt;n)</code> - which I guess implicitly checks for EOF.</p>

<p>Why is checking for eof explicitly using <code>while (!cin.eof())</code> wrong?  </p>

<p>How is it different from using <code>scanf("...",...)!=EOF</code> in C (which I often use with no problems)?</p>
    </div></div></div><div class="sc-6e32c308-1 ljvTUN flex text-xs pl-10 flex-col comment items-center justify-center"><h4 class="text-left mt-10 text-lg font-semibold">Comments</h4><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy"><code>scanf(...) != EOF</code> won't work in C either, because <code>scanf</code> returns the number of fields successfully parsed and assigned.  The correct condition is <code>scanf(...) &lt; n</code> where <code>n</code> is the number of fields in the format string.</span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/103167/ben-voigt" title="270,533 reputation" class="comment-user">Ben Voigt</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment12832536_5605125"><span title="2012-04-05 16:50:42Z, License: CC BY-SA 3.0" class="relativetime-clean">Apr 5, 2012 at 16:50</span></a></span>
            </div>
        </div><span class="divide-x-8 "></span><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy">@Ben Voigt, it will return a negative number (which EOF usually is defined as such) in case EOF is reached</span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/281306/sebastian" title="5,863 reputation" class="comment-user">Sebastian</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment18536882_5605125"><span title="2012-11-23 23:44:41Z, License: CC BY-SA 3.0" class="relativetime-clean">Nov 23, 2012 at 23:44</span></a></span>
            </div>
        </div><span class="divide-x-8 "></span><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy">@SebastianGodelet: Actually, it will return <code>EOF</code> if end of file is encountered before the first field conversion (successful or not).  If end-of-file is reached between fields, it will return the number of fields succcessfully converted and stored.  Which makes comparison to <code>EOF</code> wrong.</span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/103167/ben-voigt" title="270,533 reputation" class="comment-user">Ben Voigt</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment18545887_5605125"><span title="2012-11-24 15:06:27Z, License: CC BY-SA 3.0" class="relativetime-clean">Nov 24, 2012 at 15:06</span></a></span>
                        <span title="this comment was edited 1 time">
                            <svg aria-hidden="true" class="va-text-bottom o50 svg-icon iconPencilSm" width="14" height="14" viewBox="0 0 14 14"><path d="m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z"></path></svg>
                        </span>
            </div>
        </div><span class="divide-x-8 "></span><button class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">See more</button></div><div class="sc-6e32c308-2 bFXWFO"><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Because <code>iostream::eof</code> will only return <code>true</code> <em>after</em> reading the end of the stream. It does <em>not</em> indicate, that the next read will be the end of the stream.</p>

<p>Consider this (and assume then next read will be at the end of the stream):</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span>(!inStream.<span class="hljs-built_in">eof</span>()){
  <span class="hljs-type">int</span> data;
  <span class="hljs-comment">// yay, not end of stream yet, now read ...</span>
  inStream &gt;&gt; data;
  <span class="hljs-comment">// oh crap, now we read the end and *only* now the eof bit will be set (as well as the fail bit)</span>
  <span class="hljs-comment">// do stuff with (now uninitialized) data</span>
}
</code></pre>

<p>Against this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> data;
<span class="hljs-keyword">while</span>(inStream &gt;&gt; data){
  <span class="hljs-comment">// when we land here, we can be sure that the read was successful.</span>
  <span class="hljs-comment">// if it wasn't, the returned stream from operator&gt;&gt; would be converted to false</span>
  <span class="hljs-comment">// and the loop wouldn't even be entered</span>
  <span class="hljs-comment">// do stuff with correctly initialized data (hopefully)</span>
}
</code></pre>

<p>And on your second question: Because</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"..."</span>,...)!=EOF)
</code></pre>

<p>is the same as</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">if</span>(!(inStream &gt;&gt; data).<span class="hljs-built_in">eof</span>())
</code></pre>

<p>and <strong>not</strong> the same as</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">if</span>(!inStream.<span class="hljs-built_in">eof</span>())
    inFile &gt;&gt; data
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Bottom-line top:</strong>  With proper handling of white-space, the following is how <code>eof</code> can be used (and even, be more reliable than <code>fail()</code> for error checking):</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span>( !(in&gt;&gt;std::ws).<span class="hljs-built_in">eof</span>() ) {  
   <span class="hljs-type">int</span> data;
   in &gt;&gt; data;
   <span class="hljs-keyword">if</span> ( in.<span class="hljs-built_in">fail</span>() ) <span class="hljs-comment">/* handle with break or throw */</span>; 
   <span class="hljs-comment">// now use data</span>
}    
</code></pre>

<p>(<em>Thanks Tony D for the suggestion to highlight the answer. See his comment below for an example to why this is more robust.</em>)</p>

<hr>

<p>The main argument against using <code>eof()</code> seems to be missing an important subtlety about the role of white space. My proposition is that, checking <code>eof()</code> explicitly is not only not "<em>always wrong</em>" -- which seems to be an overriding opinion in this and similar SO threads --, but with proper handling of white-space, it provides for a cleaner and more reliable error handling, and is the <em>always correct</em> solution (although, not necessarily the tersest).</p>

<p>To summarize what is being suggested as the "proper" termination and read order is the following:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> data;
<span class="hljs-keyword">while</span>(in &gt;&gt; data) {  <span class="hljs-comment">/* ... */</span> }

<span class="hljs-comment">// which is equivalent to </span>
<span class="hljs-keyword">while</span>( !(in &gt;&gt; data).<span class="hljs-built_in">fail</span>() )  {  <span class="hljs-comment">/* ... */</span> }
</code></pre>

<p>The failure due to read attempt beyond eof is taken as the termination condition.  This means is that there is no easy way to distinguish between a successful stream and one that really fails for reasons other than eof. Take the following streams: </p>

<ul>
<li><code>1 2 3 4 5&lt;eof&gt;</code></li>
<li><code>1 2 a 3 4 5&lt;eof&gt;</code> </li>
<li><code>a&lt;eof&gt;</code></li>
</ul>

<p><code>while(in&gt;&gt;data)</code> terminates with a set <code>failbit</code> for <em>all</em> three input. In the first and third, <code>eofbit</code> is also set. So past the loop one needs very ugly extra logic to distinguish a proper input (1st) from improper ones (2nd and 3rd).</p>

<p>Whereas, take the following: </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span>( !in.<span class="hljs-built_in">eof</span>() ) 
{  
   <span class="hljs-type">int</span> data;
   in &gt;&gt; data;
   <span class="hljs-keyword">if</span> ( in.<span class="hljs-built_in">fail</span>() ) <span class="hljs-comment">/* handle with break or throw */</span>; 
   <span class="hljs-comment">// now use data</span>
}    
</code></pre>

<p>Here, <code>in.fail()</code> verifies that as long as there is something to read, it is the correct one. It's purpose is not a mere while-loop terminator. </p>

<p>So far so good, but what happens if there is trailing space in the stream -- what sounds like the major concern against <code>eof()</code> as terminator?</p>

<p>We don't need to surrender our error handling; just eat up the white-space:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span>( !in.<span class="hljs-built_in">eof</span>() ) 
{  
   <span class="hljs-type">int</span> data;
   in &gt;&gt; data &gt;&gt; ws; <span class="hljs-comment">// eat whitespace with std::ws</span>
   <span class="hljs-keyword">if</span> ( in.<span class="hljs-built_in">fail</span>() ) <span class="hljs-comment">/* handle with break or throw */</span>; 
   <span class="hljs-comment">// now use data</span>
}
</code></pre>

<p><code>std::ws</code> skips any potential (zero or more) trailing space in the stream while setting the <code>eofbit</code>, and <strong>not the <code>failbit</code></strong>.  So, <code>in.fail()</code> works as expected, as long as there is at least one data to read. If all-blank streams are also acceptable, then the correct form is:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span>( !(in&gt;&gt;ws).<span class="hljs-built_in">eof</span>() ) 
{  
   <span class="hljs-type">int</span> data;
   in &gt;&gt; data; 
   <span class="hljs-keyword">if</span> ( in.<span class="hljs-built_in">fail</span>() ) <span class="hljs-comment">/* handle with break or throw */</span>; 
   <span class="hljs-comment">/* this will never fire if the eof is reached cleanly */</span>
   <span class="hljs-comment">// now use data</span>
}
</code></pre>

<p><strong>Summary:</strong> A properly constructed <code>while(!eof)</code> is not only possible and not wrong, but allows data to be localized within scope, and provides a cleaner separation of error checking from business as usual.  That being said, <code>while(!fail)</code> is inarguably a more common and terse idiom, and may be preferred in simple (single data per read type of) scenarios. </p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Because if programmers don't write <code>while(stream &gt;&gt; n)</code>, they possibly write this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span>(!stream.<span class="hljs-built_in">eof</span>())
{
    stream &gt;&gt; n;
    <span class="hljs-comment">//some work on n;</span>
}
</code></pre>

<p>Here the problem is, you cannot do <code>some work on n</code> without first checking if the stream read was successful, because if it was unsuccessful, your <code>some work on n</code> would produce undesired result.</p>

<p>The whole point is that, <code>eofbit</code>, <code>badbit</code>, or <code>failbit</code> are set <strong>after an attempt is made to read from the stream.</strong> So if <code>stream &gt;&gt; n</code> fails, then <code>eofbit</code>, <code>badbit</code>, or <code>failbit</code> is set immediately, so its more idiomatic if you write <code>while (stream &gt;&gt; n)</code>, because the returned object <code>stream</code> converts to <code>false</code> if there was some failure in reading from the stream and consequently the loop stops. And it converts to <code>true</code> if the read was successful and the loop continues.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The other answers have explained why the logic is wrong in <code>while (!stream.eof())</code> and how to fix it. I want to focus on something different:</p>

<blockquote>
  <p>why is checking for eof explicitly using <code>iostream::eof</code> wrong?</p>
</blockquote>

<p>In general terms, checking for <code>eof</code> <em>only</em> is wrong because stream extraction (<code>&gt;&gt;</code>) can fail without hitting the end of the file. If you have e.g. <code>int n; cin &gt;&gt; n;</code> and the stream contains <code>hello</code>, then <code>h</code> is not a valid digit, so extraction will fail without reaching the end of the input.</p>

<p>This issue, combined with the general logic error of checking the stream state <em>before</em> attempting to read from it, which means for N input items the loop will run N+1 times, leads to the following symptoms:</p>

<ul>
<li><p>If the stream is empty, the loop will run once. <code>&gt;&gt;</code> will fail (there is no input to be read) and all variables that were supposed to be set (by <code>stream &gt;&gt; x</code>) are actually uninitialized. This leads to garbage data being processed, which can manifest as nonsensical results (often huge numbers).</p>

<p>(If your standard library conforms to C++11, things are a bit different now: A failed <code>&gt;&gt;</code> now sets numeric variables to <code>0</code> instead of leaving them uninitialized (except for <code>char</code>s).)</p></li>
<li><p>If the stream is not empty, the loop will run again after the last valid input. Since in the last iteration all <code>&gt;&gt;</code> operations fail, variables are likely to keep their value from the previous iteration. This can manifest as "the last line is printed twice" or "the last input record is processed twice".</p>

<p>(This should manifest a bit differently since C++11 (see above): Now you get a "phantom record" of zeroes instead of a repeated last line.)</p></li>
<li><p>If the stream contains malformed data but you only check for <code>.eof</code>, you end up with an infinite loop. <code>&gt;&gt;</code> will fail to extract any data from the stream, so the loop spins in place without ever reaching the end.</p></li>
</ul>

<hr>

<p>To recap: The solution is to test the success of the <code>&gt;&gt;</code> operation itself, not to use a separate <code>.eof()</code> method: <code>while (stream &gt;&gt; n &gt;&gt; m) { ... }</code>, just as in C you test the success of the <code>scanf</code> call itself: <code>while (scanf("%d%d", &amp;n, &amp;m) == 2) { ... }</code>.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The important thing to remember is that, <code>inFile.eof()</code> doesnt become <code>True</code> until <em><strong>after</strong></em> an attempted read fails, because youve reached the end of the file. So, in this example, youll get an error.</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span> (!inFile.<span class="hljs-built_in">eof</span>()){
    inFile &gt;&gt; x;
        <span class="hljs-built_in">process</span>(x);
}
</code></pre>
<p>The way to make this loop correct, is to combine reading and checking into a single operation, like so</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span> (inFile &gt;&gt; x)&nbsp;
    <span class="hljs-built_in">process</span>(x);&nbsp;
</code></pre>
<p>By convention, <code>operator&gt;&gt;</code> returns the stream we read from, and a Boolean test on a stream returns <code>False</code> when the stream fails (such as reaching end of file).</p>
<p><strong>So this gives us the correct sequence :</strong></p>
<ul>
<li>read</li>
<li>test whether the read succeeds</li>
<li>if and only if the test succeeds, process what weve read</li>
</ul>
<p>If you happen to encounter some <em>other</em> problem that prevents you from reading from the file correctly, you will not be able to reach <code>eof()</code> as such. For example, lets look at something like this</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> x;&nbsp;
<span class="hljs-keyword">while</span> (!inFile.<span class="hljs-built_in">eof</span>()) {&nbsp;
    inFile &gt;&gt; x;&nbsp;
    <span class="hljs-built_in">process</span>(x);
}&nbsp;
    
</code></pre>
<p>Let us trace through the working of the above code, with an example</p>
<ul>
<li>Assume the contents of the file are <code>'1', '2', '3', 'a', 'b'</code>.</li>
<li>The loop will read the 1, 2, and 3 correctly.</li>
<li>Then itll get to <code>a</code>.</li>
<li>When it tries to extract <code>a</code> as an int, itll fail.</li>
<li>The stream is now in a failed state, until or unless we <code>clear</code> the stream, all attempts at reading from it will fail.</li>
<li>But, when we test for eof(), itll return <code>False</code>, because were not at the end of the file, because theres still <code>a</code> waiting to be read.</li>
<li>The loop will keep trying to read from the file, and fail every time, so it <strong>never</strong> reaches the end of the file.</li>
<li>So, the loop above will run forever.</li>
</ul>
<p>But, if we use a loop like this, we will get the required output.</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span> (inFile &gt;&gt; x)
    <span class="hljs-built_in">process</span>(x);
</code></pre>
<p>In this case, the stream will convert to <code>False</code> not only in case of end of file, but also in case of a failed conversion, such as the <code>a</code> that we cant read as an integer.</p>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;Because \u0026lt;code\u0026gt;iostream::eof\u0026lt;/code\u0026gt; will only return \u0026lt;code\u0026gt;true\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;after\u0026lt;/em\u0026gt; reading the end of the stream. It does \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; indicate, that the next read will be the end of the stream.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Consider this (and assume then next read will be at the end of the stream):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(!inStream.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;()){\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// yay, not end of stream yet, now read ...\u0026lt;/span\u0026gt;\n  inStream \u0026amp;gt;\u0026amp;gt; data;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// oh crap, now we read the end and *only* now the eof bit will be set (as well as the fail bit)\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// do stuff with (now uninitialized) data\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Against this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(inStream \u0026amp;gt;\u0026amp;gt; data){\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// when we land here, we can be sure that the read was successful.\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// if it wasn\u0026apos;t, the returned stream from operator\u0026amp;gt;\u0026amp;gt; would be converted to false\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// and the loop wouldn\u0026apos;t even be entered\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// do stuff with correctly initialized data (hopefully)\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And on your second question: Because\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;scanf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;...\u0026quot;\u0026lt;/span\u0026gt;,...)!=EOF)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;is the same as\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(!(inStream \u0026amp;gt;\u0026amp;gt; data).\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;())\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and \u0026lt;strong\u0026gt;not\u0026lt;/strong\u0026gt; the same as\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(!inStream.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;())\n    inFile \u0026amp;gt;\u0026amp;gt; data\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Bottom-line top:\u0026lt;/strong\u0026gt;  With proper handling of white-space, the following is how \u0026lt;code\u0026gt;eof\u0026lt;/code\u0026gt; can be used (and even, be more reliable than \u0026lt;code\u0026gt;fail()\u0026lt;/code\u0026gt; for error checking):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( !(in\u0026amp;gt;\u0026amp;gt;std::ws).\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;() ) {  \n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n   in \u0026amp;gt;\u0026amp;gt; data;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ( in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;() ) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* handle with break or throw */\u0026lt;/span\u0026gt;; \n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// now use data\u0026lt;/span\u0026gt;\n}    \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;(\u0026lt;em\u0026gt;Thanks Tony D for the suggestion to highlight the answer. See his comment below for an example to why this is more robust.\u0026lt;/em\u0026gt;)\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;The main argument against using \u0026lt;code\u0026gt;eof()\u0026lt;/code\u0026gt; seems to be missing an important subtlety about the role of white space. My proposition is that, checking \u0026lt;code\u0026gt;eof()\u0026lt;/code\u0026gt; explicitly is not only not \u0026quot;\u0026lt;em\u0026gt;always wrong\u0026lt;/em\u0026gt;\u0026quot; -- which seems to be an overriding opinion in this and similar SO threads --, but with proper handling of white-space, it provides for a cleaner and more reliable error handling, and is the \u0026lt;em\u0026gt;always correct\u0026lt;/em\u0026gt; solution (although, not necessarily the tersest).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To summarize what is being suggested as the \u0026quot;proper\u0026quot; termination and read order is the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(in \u0026amp;gt;\u0026amp;gt; data) {  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; }\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// which is equivalent to \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( !(in \u0026amp;gt;\u0026amp;gt; data).\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;() )  {  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The failure due to read attempt beyond eof is taken as the termination condition.  This means is that there is no easy way to distinguish between a successful stream and one that really fails for reasons other than eof. Take the following streams: \u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;1 2 3 4 5\u0026amp;lt;eof\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;1 2 a 3 4 5\u0026amp;lt;eof\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;a\u0026amp;lt;eof\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;while(in\u0026amp;gt;\u0026amp;gt;data)\u0026lt;/code\u0026gt; terminates with a set \u0026lt;code\u0026gt;failbit\u0026lt;/code\u0026gt; for \u0026lt;em\u0026gt;all\u0026lt;/em\u0026gt; three input. In the first and third, \u0026lt;code\u0026gt;eofbit\u0026lt;/code\u0026gt; is also set. So past the loop one needs very ugly extra logic to distinguish a proper input (1st) from improper ones (2nd and 3rd).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Whereas, take the following: \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( !in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;() ) \n{  \n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n   in \u0026amp;gt;\u0026amp;gt; data;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ( in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;() ) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* handle with break or throw */\u0026lt;/span\u0026gt;; \n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// now use data\u0026lt;/span\u0026gt;\n}    \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here, \u0026lt;code\u0026gt;in.fail()\u0026lt;/code\u0026gt; verifies that as long as there is something to read, it is the correct one. It\u0026apos;s purpose is not a mere while-loop terminator. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So far so good, but what happens if there is trailing space in the stream -- what sounds like the major concern against \u0026lt;code\u0026gt;eof()\u0026lt;/code\u0026gt; as terminator?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;We don\u0026apos;t need to surrender our error handling; just eat up the white-space:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( !in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;() ) \n{  \n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n   in \u0026amp;gt;\u0026amp;gt; data \u0026amp;gt;\u0026amp;gt; ws; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// eat whitespace with std::ws\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ( in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;() ) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* handle with break or throw */\u0026lt;/span\u0026gt;; \n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// now use data\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;std::ws\u0026lt;/code\u0026gt; skips any potential (zero or more) trailing space in the stream while setting the \u0026lt;code\u0026gt;eofbit\u0026lt;/code\u0026gt;, and \u0026lt;strong\u0026gt;not the \u0026lt;code\u0026gt;failbit\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;.  So, \u0026lt;code\u0026gt;in.fail()\u0026lt;/code\u0026gt; works as expected, as long as there is at least one data to read. If all-blank streams are also acceptable, then the correct form is:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( !(in\u0026amp;gt;\u0026amp;gt;ws).\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;() ) \n{  \n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n   in \u0026amp;gt;\u0026amp;gt; data; \n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ( in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;() ) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* handle with break or throw */\u0026lt;/span\u0026gt;; \n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* this will never fire if the eof is reached cleanly */\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// now use data\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Summary:\u0026lt;/strong\u0026gt; A properly constructed \u0026lt;code\u0026gt;while(!eof)\u0026lt;/code\u0026gt; is not only possible and not wrong, but allows data to be localized within scope, and provides a cleaner separation of error checking from business as usual.  That being said, \u0026lt;code\u0026gt;while(!fail)\u0026lt;/code\u0026gt; is inarguably a more common and terse idiom, and may be preferred in simple (single data per read type of) scenarios. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Because if programmers don\u0026apos;t write \u0026lt;code\u0026gt;while(stream \u0026amp;gt;\u0026amp;gt; n)\u0026lt;/code\u0026gt;, they possibly write this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(!stream.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;())\n{\n    stream \u0026amp;gt;\u0026amp;gt; n;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//some work on n;\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here the problem is, you cannot do \u0026lt;code\u0026gt;some work on n\u0026lt;/code\u0026gt; without first checking if the stream read was successful, because if it was unsuccessful, your \u0026lt;code\u0026gt;some work on n\u0026lt;/code\u0026gt; would produce undesired result.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The whole point is that, \u0026lt;code\u0026gt;eofbit\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;badbit\u0026lt;/code\u0026gt;, or \u0026lt;code\u0026gt;failbit\u0026lt;/code\u0026gt; are set \u0026lt;strong\u0026gt;after an attempt is made to read from the stream.\u0026lt;/strong\u0026gt; So if \u0026lt;code\u0026gt;stream \u0026amp;gt;\u0026amp;gt; n\u0026lt;/code\u0026gt; fails, then \u0026lt;code\u0026gt;eofbit\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;badbit\u0026lt;/code\u0026gt;, or \u0026lt;code\u0026gt;failbit\u0026lt;/code\u0026gt; is set immediately, so its more idiomatic if you write \u0026lt;code\u0026gt;while (stream \u0026amp;gt;\u0026amp;gt; n)\u0026lt;/code\u0026gt;, because the returned object \u0026lt;code\u0026gt;stream\u0026lt;/code\u0026gt; converts to \u0026lt;code\u0026gt;false\u0026lt;/code\u0026gt; if there was some failure in reading from the stream and consequently the loop stops. And it converts to \u0026lt;code\u0026gt;true\u0026lt;/code\u0026gt; if the read was successful and the loop continues.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The other answers have explained why the logic is wrong in \u0026lt;code\u0026gt;while (!stream.eof())\u0026lt;/code\u0026gt; and how to fix it. I want to focus on something different:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;why is checking for eof explicitly using \u0026lt;code\u0026gt;iostream::eof\u0026lt;/code\u0026gt; wrong?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;In general terms, checking for \u0026lt;code\u0026gt;eof\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;only\u0026lt;/em\u0026gt; is wrong because stream extraction (\u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt;) can fail without hitting the end of the file. If you have e.g. \u0026lt;code\u0026gt;int n; cin \u0026amp;gt;\u0026amp;gt; n;\u0026lt;/code\u0026gt; and the stream contains \u0026lt;code\u0026gt;hello\u0026lt;/code\u0026gt;, then \u0026lt;code\u0026gt;h\u0026lt;/code\u0026gt; is not a valid digit, so extraction will fail without reaching the end of the input.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This issue, combined with the general logic error of checking the stream state \u0026lt;em\u0026gt;before\u0026lt;/em\u0026gt; attempting to read from it, which means for N input items the loop will run N+1 times, leads to the following symptoms:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If the stream is empty, the loop will run once. \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; will fail (there is no input to be read) and all variables that were supposed to be set (by \u0026lt;code\u0026gt;stream \u0026amp;gt;\u0026amp;gt; x\u0026lt;/code\u0026gt;) are actually uninitialized. This leads to garbage data being processed, which can manifest as nonsensical results (often huge numbers).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;(If your standard library conforms to C++11, things are a bit different now: A failed \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; now sets numeric variables to \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt; instead of leaving them uninitialized (except for \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt;s).)\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If the stream is not empty, the loop will run again after the last valid input. Since in the last iteration all \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; operations fail, variables are likely to keep their value from the previous iteration. This can manifest as \u0026quot;the last line is printed twice\u0026quot; or \u0026quot;the last input record is processed twice\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;(This should manifest a bit differently since C++11 (see above): Now you get a \u0026quot;phantom record\u0026quot; of zeroes instead of a repeated last line.)\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If the stream contains malformed data but you only check for \u0026lt;code\u0026gt;.eof\u0026lt;/code\u0026gt;, you end up with an infinite loop. \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; will fail to extract any data from the stream, so the loop spins in place without ever reaching the end.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;To recap: The solution is to test the success of the \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; operation itself, not to use a separate \u0026lt;code\u0026gt;.eof()\u0026lt;/code\u0026gt; method: \u0026lt;code\u0026gt;while (stream \u0026amp;gt;\u0026amp;gt; n \u0026amp;gt;\u0026amp;gt; m) { ... }\u0026lt;/code\u0026gt;, just as in C you test the success of the \u0026lt;code\u0026gt;scanf\u0026lt;/code\u0026gt; call itself: \u0026lt;code\u0026gt;while (scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;amp;n, \u0026amp;amp;m) == 2) { ... }\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The important thing to remember is that, \u0026lt;code\u0026gt;inFile.eof()\u0026lt;/code\u0026gt; doesnt become \u0026lt;code\u0026gt;True\u0026lt;/code\u0026gt; until \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;after\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; an attempted read fails, because youve reached the end of the file. So, in this example, youll get an error.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (!inFile.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;()){\n    inFile \u0026amp;gt;\u0026amp;gt; x;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;process\u0026lt;/span\u0026gt;(x);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The way to make this loop correct, is to combine reading and checking into a single operation, like so\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (inFile \u0026amp;gt;\u0026amp;gt; x)\u0026amp;nbsp;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;process\u0026lt;/span\u0026gt;(x);\u0026amp;nbsp;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;By convention, \u0026lt;code\u0026gt;operator\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; returns the stream we read from, and a Boolean test on a stream returns \u0026lt;code\u0026gt;False\u0026lt;/code\u0026gt; when the stream fails (such as reaching end of file).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;So this gives us the correct sequence :\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;read\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;test whether the read succeeds\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;if and only if the test succeeds, process what weve read\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;If you happen to encounter some \u0026lt;em\u0026gt;other\u0026lt;/em\u0026gt; problem that prevents you from reading from the file correctly, you will not be able to reach \u0026lt;code\u0026gt;eof()\u0026lt;/code\u0026gt; as such. For example, lets look at something like this\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x;\u0026amp;nbsp;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (!inFile.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;()) {\u0026amp;nbsp;\n    inFile \u0026amp;gt;\u0026amp;gt; x;\u0026amp;nbsp;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;process\u0026lt;/span\u0026gt;(x);\n}\u0026amp;nbsp;\n    \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Let us trace through the working of the above code, with an example\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Assume the contents of the file are \u0026lt;code\u0026gt;\u0026apos;1\u0026apos;, \u0026apos;2\u0026apos;, \u0026apos;3\u0026apos;, \u0026apos;a\u0026apos;, \u0026apos;b\u0026apos;\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The loop will read the 1, 2, and 3 correctly.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Then itll get to \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;When it tries to extract \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; as an int, itll fail.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The stream is now in a failed state, until or unless we \u0026lt;code\u0026gt;clear\u0026lt;/code\u0026gt; the stream, all attempts at reading from it will fail.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;But, when we test for eof(), itll return \u0026lt;code\u0026gt;False\u0026lt;/code\u0026gt;, because were not at the end of the file, because theres still \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; waiting to be read.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The loop will keep trying to read from the file, and fail every time, so it \u0026lt;strong\u0026gt;never\u0026lt;/strong\u0026gt; reaches the end of the file.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;So, the loop above will run forever.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;But, if we use a loop like this, we will get the required output.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (inFile \u0026amp;gt;\u0026amp;gt; x)\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;process\u0026lt;/span\u0026gt;(x);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In this case, the stream will convert to \u0026lt;code\u0026gt;False\u0026lt;/code\u0026gt; not only in case of end of file, but also in case of a failed conversion, such as the \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; that we cant read as an integer.\u0026lt;/p\u0026gt;\n    "],"comment":["\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026lt;code\u0026gt;scanf(...) != EOF\u0026lt;/code\u0026gt; won\u0026apos;t work in C either, because \u0026lt;code\u0026gt;scanf\u0026lt;/code\u0026gt; returns the number of fields successfully parsed and assigned.  The correct condition is \u0026lt;code\u0026gt;scanf(...) \u0026amp;lt; n\u0026lt;/code\u0026gt; where \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt; is the number of fields in the format string.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/103167/ben-voigt\u0026quot; title=\u0026quot;270,533 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Ben Voigt\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment12832536_5605125\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-04-05 16:50:42Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 5, 2012 at 16:50\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Ben Voigt, it will return a negative number (which EOF usually is defined as such) in case EOF is reached\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/281306/sebastian\u0026quot; title=\u0026quot;5,863 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Sebastian\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment18536882_5605125\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-11-23 23:44:41Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 23, 2012 at 23:44\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@SebastianGodelet: Actually, it will return \u0026lt;code\u0026gt;EOF\u0026lt;/code\u0026gt; if end of file is encountered before the first field conversion (successful or not).  If end-of-file is reached between fields, it will return the number of fields succcessfully converted and stored.  Which makes comparison to \u0026lt;code\u0026gt;EOF\u0026lt;/code\u0026gt; wrong.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/103167/ben-voigt\u0026quot; title=\u0026quot;270,533 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Ben Voigt\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment18545887_5605125\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-11-24 15:06:27Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 24, 2012 at 15:06\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@SebastianGodelet: No, not really.  He errs when he says that \u0026quot;past the loop there is no (easy) way to distinguish a proper input from an improper one\u0026quot;.  In fact it\u0026apos;s as easy as checking \u0026lt;code\u0026gt;.eof()\u0026lt;/code\u0026gt; after the loop exits.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/103167/ben-voigt\u0026quot; title=\u0026quot;270,533 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Ben Voigt\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment18547414_5605125\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-11-24 16:52:48Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 24, 2012 at 16:52\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Ben Yes, for this case (reading a simple int). But one can easily come up with a scenario where \u0026lt;code\u0026gt;while(fail)\u0026lt;/code\u0026gt; loop terminates with both an actual failure and an eof. Think about if you require 3 ints per iteration (say you are reading an x-y-z point or something), but there is, erroneously, only two ints in the stream.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/108461/sly\u0026quot; title=\u0026quot;1,642 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;sly\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment18550194_5605125\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-11-24 19:47:17Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 24, 2012 at 19:47\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Worth mentioning is that if (!(inStream \u0026amp;gt;\u0026amp;gt; data).eof()) doesn\u0026apos;t do anything useful either. Fallacy 1: It\u0026apos;ll not enter the condition if there was no whitespace after the last piece of data (last datum will not be processed). Fallacy 2: It will enter the condition even if reading data failed, as long as EOF was not reached (infinite loop, processing the same old data over and over again).\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/238233/tronic\u0026quot; title=\u0026quot;10,042 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Tronic\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment20081828_5605159\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-01-20 16:20:10Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 20, 2013 at 16:20\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I think it\u0026apos;s worth pointing out that this answer is slightly misleading. When extracting \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;s or \u0026lt;code\u0026gt;std::string\u0026lt;/code\u0026gt;s or similar, the EOF bit \u0026lt;i\u0026gt;is\u0026lt;/i\u0026gt; set when you extract the one right before the end and the extraction hits the end. You do not need to read again. The reason it doesn\u0026apos;t get set when reading from files is because there\u0026apos;s an extra \u0026lt;code\u0026gt;\\n\u0026lt;/code\u0026gt; at the end. I\u0026apos;ve covered this in \u0026lt;a href=\u0026quot;http://stackoverflow.com/a/14615673/150634\u0026quot;\u0026gt;another answer\u0026lt;/a\u0026gt;. Reading \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt;s is a different matter because it only extracts one at a time and doesn\u0026apos;t continue to hit the end.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/150634/joseph-mansfield\u0026quot; title=\u0026quot;105,003 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Joseph Mansfield\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment22561833_5605159\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-04-06 16:59:44Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 6, 2013 at 16:59\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;The main problem is that \u0026lt;b\u0026gt;just because we haven\u0026apos;t reached the EOF, doesn\u0026apos;t mean the next read will succeed\u0026lt;/b\u0026gt;.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/150634/joseph-mansfield\u0026quot; title=\u0026quot;105,003 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Joseph Mansfield\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment22561896_5605159\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-04-06 17:03:49Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 6, 2013 at 17:03\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@sftrabbit: all true but not very useful... even if there\u0026apos;s no trailing \u0026apos;\\n\u0026apos; it\u0026apos;s reasonable to want other trailing whitespace to be handled consistently with other whitespace throughout the file (i.e. skipped).  Further, a subtle consequence of \u0026quot;when you extract the one right before\u0026quot; is that \u0026lt;code\u0026gt;while (!eof())\u0026lt;/code\u0026gt; won\u0026apos;t \u0026quot;work\u0026quot; on \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;s or \u0026lt;code\u0026gt;std::string\u0026lt;/code\u0026gt;s when the input is totally empty, so even knowing there\u0026apos;s no trailing \u0026lt;code\u0026gt;\\n\u0026lt;/code\u0026gt; care is needed.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/410767/tony-delroy\u0026quot; title=\u0026quot;99,376 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Tony Delroy\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment23094105_5605159\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-04-23 03:34:22Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 23, 2013 at 3:34\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@TonyD Totally agree. The reason I\u0026apos;m saying it is because I think most people when they read this and similar answers will think that if the stream contains \u0026lt;code\u0026gt;\u0026quot;Hello\u0026quot;\u0026lt;/code\u0026gt; (no trailing whitespace or \u0026lt;code\u0026gt;\\n\u0026lt;/code\u0026gt;) and a \u0026lt;code\u0026gt;std::string\u0026lt;/code\u0026gt; is extracted, it will extract the letters from \u0026lt;code\u0026gt;H\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;o\u0026lt;/code\u0026gt;, stop extracting, and then \u0026lt;i\u0026gt;not\u0026lt;/i\u0026gt; set the EOF bit. In fact, it would set the EOF bit because it was the EOF that stopped the extraction. Just hoping to clear that up for people.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/150634/joseph-mansfield\u0026quot; title=\u0026quot;105,003 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Joseph Mansfield\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment23100620_5605159\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-04-23 08:23:10Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 23, 2013 at 8:23\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026quot;\u0026lt;i\u0026gt;So past the loop there is no (easy) way to distinguish a proper input from an improper one.\u0026lt;/i\u0026gt;\u0026quot; Except that in one case both \u0026lt;code\u0026gt;eofbit\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;failbit\u0026lt;/code\u0026gt; are set, in the other only \u0026lt;code\u0026gt;failbit\u0026lt;/code\u0026gt; is set. You only need to test that \u0026lt;i\u0026gt;once\u0026lt;/i\u0026gt; after the loop has terminated, not on every iteration; it will only leave the loop once, so you only need to check \u0026lt;i\u0026gt;why\u0026lt;/i\u0026gt; it left the loop once.  \u0026lt;code\u0026gt;while (in \u0026amp;gt;\u0026amp;gt; data)\u0026lt;/code\u0026gt; works fine for all blank streams.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/981959/jonathan-wakely\u0026quot; title=\u0026quot;160,851 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Jonathan Wakely\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment21189709_13536879\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-02-25 14:09:27Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 25, 2013 at 14:09\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;What you are saying (and a point made earlier) is that a bad formatted stream can be identified as \u0026lt;code\u0026gt;!eof \u0026amp;amp; fail\u0026lt;/code\u0026gt; past loop. There are cases in which one can not rely on this. See above comment (\u0026lt;a href=\u0026quot;http://goo.gl/9mXYX\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;goo.gl/9mXYX\u0026lt;/a\u0026gt;). Eitherway, I am not proposing \u0026lt;code\u0026gt;eof\u0026lt;/code\u0026gt;-check as \u0026lt;i\u0026gt;the-always-better\u0026lt;/i\u0026gt; alternative. I am merely saying, it \u0026lt;i\u0026gt;is\u0026lt;/i\u0026gt; a possible and (in some cases more appropriate) way of doing this, rather than \u0026quot;most certainly wrong!\u0026quot; as it tends to be claimed around here in SO.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/108461/sly\u0026quot; title=\u0026quot;1,642 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;sly\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment21193527_13536879\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-02-25 15:58:29Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 25, 2013 at 15:58\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 7 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026lt;i\u0026gt;\u0026quot;As an example, consider how you\u0026apos;d check for errors where the data is a struct with overloaded operator\u0026amp;gt;\u0026amp;gt; reading multiple fields at once\u0026quot;\u0026lt;/i\u0026gt; - a much simpler case supporting your point is \u0026lt;code\u0026gt;stream \u0026amp;gt;\u0026amp;gt; my_int\u0026lt;/code\u0026gt; where the stream contains e.g. \u0026quot;-\u0026quot;: \u0026lt;code\u0026gt;eofbit\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;failbit\u0026lt;/code\u0026gt; are set.  That\u0026apos;s worse than the \u0026lt;code\u0026gt;operator\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; scenario, where the user-provided overload at least has the option of clearing \u0026lt;code\u0026gt;eofbit\u0026lt;/code\u0026gt; before returning to help support \u0026lt;code\u0026gt;while (s \u0026amp;gt;\u0026amp;gt; x)\u0026lt;/code\u0026gt; usage.  More generally, this answer could use a clean-up - only the final \u0026lt;code\u0026gt;while( !(in\u0026amp;gt;\u0026amp;gt;ws).eof() )\u0026lt;/code\u0026gt; is generally robust, and it\u0026apos;s buried at the end.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/410767/tony-delroy\u0026quot; title=\u0026quot;99,376 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Tony Delroy\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment45712673_13536879\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-02-25 06:09:52Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 25, 2015 at 6:09\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;With your \u0026quot;3 examples\u0026quot; \u0026lt;i\u0026gt;only\u0026lt;/i\u0026gt; the first sets eof.  The third does not because the \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; fails conversion to int and is not read -- it will be left on the input.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/16406/chris-dodd\u0026quot; title=\u0026quot;112,580 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Chris Dodd\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment127062015_13536879\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2022-04-17 20:54:00Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 17 at 20:54\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;so? that\u0026apos;s is kind of the point: early break with a bad stream, or end-loop successfully with eof.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/108461/sly\u0026quot; title=\u0026quot;1,642 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;sly\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment127236554_13536879\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2022-04-26 01:58:03Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 26 at 1:58\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Apart from the mentioned \u0026quot;undesired result\u0026quot; with doing work on the undefined value of \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt;, the program might also fall into an \u0026lt;b\u0026gt;infinite loop\u0026lt;/b\u0026gt;, if the failing stream operation doesn\u0026apos;t consume any input.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/4271479/mastov\u0026quot; title=\u0026quot;2,847 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;mastov\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment87143702_5605161\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-04-27 13:33:26Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 27, 2018 at 13:33\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;this is the most accurate answer, although as of c++11, i dont believe the variables are uninitialized anymore(the first bullet pt)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/7183221/csguy\u0026quot; title=\u0026quot;1,273 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;csguy\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment101610687_55981331\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-08-20 13:52:12Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 20, 2019 at 13:52\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;?syntax error: undefined identifiers \u0026lt;code\u0026gt;True\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;False\u0026lt;/code\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/7143595/matg\u0026quot; title=\u0026quot;464 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;MatG\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment127497273_71187351\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2022-05-08 11:20:10Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 8 at 11:20\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        "],"id":35,"title":"Why is iostream::eof inside a loop condition (i.e. `while (!stream.eof())`) considered wrong?","content":"\n                \n\u0026lt;p\u0026gt;I just found a comment in \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/5578631/c-how-do-you-stop-reading-integer-from-text-file-when-encounter-negative-intege/5578649#5578649\u0026quot;\u0026gt;this\u0026lt;/a\u0026gt; answer saying that using \u0026lt;code\u0026gt;iostream::eof\u0026lt;/code\u0026gt; in a loop condition is \u0026quot;almost certainly wrong\u0026quot;. I generally use something like \u0026lt;code\u0026gt;while(cin\u0026amp;gt;\u0026amp;gt;n)\u0026lt;/code\u0026gt; - which I guess implicitly checks for EOF.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Why is checking for eof explicitly using \u0026lt;code\u0026gt;while (!cin.eof())\u0026lt;/code\u0026gt; wrong?  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;How is it different from using \u0026lt;code\u0026gt;scanf(\u0026quot;...\u0026quot;,...)!=EOF\u0026lt;/code\u0026gt; in C (which I often use with no problems)?\u0026lt;/p\u0026gt;\n    ","slug":"why-is-iostream::eof-inside-a-loop-condition-(i.e.-while-(!stream.eof()))-considered-wrong-1657384355427","postType":"QUESTION","createdAt":"2022-07-09T16:32:35.000Z","updatedAt":"2022-07-09T16:32:35.000Z","tags":[{"id":122,"name":"iostream","slug":"iostream","createdAt":"2022-07-09T16:32:35.000Z","updatedAt":"2022-07-09T16:32:35.000Z","Questions_Tags":{"questionId":35,"tagId":122}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"why-is-iostream::eof-inside-a-loop-condition-(i.e.-while-(!stream.eof()))-considered-wrong-1657384355427"},"buildId":"4Y8KGE-c2lolBeBmcum_I","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>