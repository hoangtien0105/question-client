<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>How do you parse and process HTML/XML in PHP? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="How can one parse HTML/XML and extract information from it?
    "/><meta property="og:title" content="How do you parse and process HTML/XML in PHP? | Solutions Checker"/><meta property="og:description" content="How can one parse HTML/XML and extract information from it?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"How do you parse and process HTML/XML in PHP?","text":"How can one parse HTML/XML and extract information from it?\n    ","answerCount":30,"upVoteCount":500,"suggestedAnswer":[{"text":"Native XML Extensions\nI prefer using one of the native XML extensions since they come bundled with PHP, are usually faster than all the 3rd party libs and give me all the control I need over the markup.\nDOM\n\nThe DOM extension allows you to operate on XML documents through the DOM API with PHP 5. It is an implementation of the W3C&apos;s Document Object Model Core Level 3, a platform- and language-neutral interface that allows programs and scripts to dynamically access and update the content, structure and style of documents.\n\nDOM is capable of parsing and modifying real world (broken) HTML and it can do XPath queries. It is based on libxml.\nIt takes some time to get productive with DOM, but that time is well worth it IMO. Since DOM is a language-agnostic interface, you&apos;ll find implementations in many languages, so if you need to change your programming language, chances are you will already know how to use that language&apos;s DOM API then.\nHow to use the DOM extension has been covered extensively on StackOverflow, so if you choose to use it, you can be sure most of the issues you run into can be solved by searching/browsing Stack Overflow.\nA basic usage example and a general conceptual overview are available in other answers.\nXMLReader\n\nThe XMLReader extension is an XML pull parser. The reader acts as a cursor going forward on the document stream and stopping at each node on the way.\n\nXMLReader, like DOM, is based on libxml. I am not aware of how to trigger the HTML Parser Module, so chances are using XMLReader for parsing broken HTML might be less robust than using DOM where you can explicitly tell it to use libxml&apos;s HTML Parser Module.\nA basic usage example is available in another answer.\nXML Parser\n\nThis extension lets you create XML parsers and then define handlers for different XML events. Each XML parser also has a few parameters you can adjust.\n\nThe XML Parser library is also based on libxml, and implements a SAX style XML push parser. It may be a better choice for memory management than DOM or SimpleXML, but will be more difficult to work with than the pull parser implemented by XMLReader.\nSimpleXml\n\nThe SimpleXML extension provides a very simple and easily usable toolset to convert XML to an object that can be processed with normal property selectors and array iterators.\n\nSimpleXML is an option when you know the HTML is valid XHTML. If you need to parse broken HTML, don&apos;t even consider SimpleXml because it will choke.\nA basic usage example is available, and there are lots of additional examples in the PHP Manual.\n\n3rd Party Libraries (libxml based)\nIf you prefer to use a 3rd-party lib, I&apos;d suggest using a lib that actually uses DOM/libxml underneath instead of string parsing.\nFluentDom\n\nFluentDOM provides a jQuery-like fluent XML interface for the DOMDocument in PHP. Selectors are written in XPath or CSS (using a CSS to XPath converter). Current versions extend the DOM implementing standard interfaces and add features from the DOM Living Standard. FluentDOM can load formats like JSON, CSV, JsonML, RabbitFish and others. Can be installed via Composer.\n\nHtmlPageDom\n\nWa72\\HtmlPageDom is a PHP library for easy manipulation of HTML\ndocuments using DOM. It requires DomCrawler from Symfony2\ncomponents for traversing\nthe DOM tree and extends it by adding methods for manipulating the\nDOM tree of HTML documents.\n\nphpQuery\n\nphpQuery is a server-side, chainable, CSS3 selector driven Document Object Model (DOM) API based on jQuery JavaScript Library.\nThe library is written in PHP5 and provides additional Command Line Interface (CLI).\n\nThis is described as &quot;abandonware and buggy: use at your own risk&quot; but does appear to be minimally maintained.\nlaminas-dom\n\nThe Laminas\\Dom component (formerly Zend_DOM) provides tools for working with DOM documents and structures. Currently, we offer Laminas\\Dom\\Query, which provides a unified interface for querying DOM documents utilizing both XPath and CSS selectors.\nThis package is considered feature-complete, and is now in security-only maintenance mode.\n\nfDOMDocument\n\nfDOMDocument extends the standard DOM to use exceptions at all occasions of errors instead of PHP warnings or notices. They also add various custom methods and shortcuts for convenience and to simplify the usage of DOM.\n\nsabre/xml\n\nsabre/xml is a library that wraps and extends the XMLReader and XMLWriter classes to create a simple &quot;xml to object/array&quot; mapping system and design pattern. Writing and reading XML is single-pass and can therefore be fast and require low memory on large xml files.\n\nFluidXML\n\nFluidXML is a PHP library for manipulating XML with a concise and fluent API.\nIt leverages XPath and the fluent programming pattern to be fun and effective.\n\n\n3rd-Party (not libxml-based)\nThe benefit of building upon DOM/libxml is that you get good performance out of the box because you are based on a native extension. However, not all 3rd-party libs go down this route. Some of them listed below\nPHP Simple HTML DOM Parser\n\n\nAn HTML DOM parser written in PHP5+ lets you manipulate HTML in a very easy way!\nRequire PHP 5+.\nSupports invalid HTML.\nFind tags on an HTML page with selectors just like jQuery.\nExtract contents from HTML in a single line.\n\n\nI generally do not recommend this parser. The codebase is horrible and the parser itself is rather slow and memory hungry. Not all jQuery Selectors (such as child selectors) are possible. Any of the libxml based libraries should outperform this easily.\nPHP Html Parser\n\nPHPHtmlParser is a simple, flexible, html parser which allows you to select tags using any css selector, like jQuery. The goal is to assiste in the development of tools which require a quick, easy way to scrape html, whether it&apos;s valid or not! This project was original supported by sunra/php-simple-html-dom-parser but the support seems to have stopped so this project is my adaptation of his previous work.\n\nAgain, I would not recommend this parser. It is rather slow with high CPU usage. There is also no function to clear memory of created DOM objects. These problems scale particularly with nested loops. The documentation itself is inaccurate and misspelled, with no responses to fixes since 14 Apr 16.\n\nHTML 5\nYou can use the above for parsing HTML5, but there can be quirks due to the markup HTML5 allows. So for HTML5 you may want to consider using a dedicated parser. Note that these are written in PHP, so suffer from slower performance and increased memory usage compared to a compiled extension in a lower-level language.\nHTML5DomDocument\n\nHTML5DOMDocument extends the native DOMDocument library. It fixes some bugs and adds some new functionality.\n\nPreserves html entities (DOMDocument does not)\nPreserves void tags (DOMDocument does not)\nAllows inserting HTML code that moves the correct parts to their proper places (head elements are inserted in the head, body elements in the body)\nAllows querying the DOM with CSS selectors (currently available: *, tagname, tagname#id, #id, tagname.classname, .classname, tagname.classname.classname2, .classname.classname2, tagname[attribute-selector], [attribute-selector], div, p, div p, div &gt; p, div + p, and p ~ ul.)\nAdds support for element-&gt;classList.\nAdds support for element-&gt;innerHTML.\nAdds support for element-&gt;outerHTML.\n\n\nHTML5\n\nHTML5 is a standards-compliant HTML5 parser and writer written entirely in PHP. It is stable and used in many production websites, and has well over five million downloads.\nHTML5 provides the following features.\n\n\n\nAn HTML5 serializer\nSupport for PHP namespaces\nComposer support\nEvent-based (SAX-like) parser\nA DOM tree builder\nInteroperability with QueryPath\nRuns on PHP 5.3.0 or newer\n\n\n\nRegular Expressions\nLast and least recommended, you can extract data from HTML with regular expressions. In general using Regular Expressions on HTML is discouraged.\nMost of the snippets you will find on the web to match markup are brittle. In most cases they are only working for a very particular piece of HTML. Tiny markup changes, like adding whitespace somewhere, or adding, or changing attributes in a tag, can make the RegEx fails when it&apos;s not properly written. You should know what you are doing before using RegEx on HTML.\nHTML parsers already know the syntactical rules of HTML. Regular expressions have to be taught for each new RegEx you write. RegEx are fine in some cases, but it really depends on your use-case.\nYou can write more reliable parsers, but writing a complete and reliable custom parser with regular expressions is a waste of time when the aforementioned libraries already exist and do a much better job on this.\nAlso see Parsing Html The Cthulhu Way\n\nBooks\nIf you want to spend some money, have a look at\n\nPHP Architect&apos;s Guide to Webscraping with PHP\n\nI am not affiliated with PHP Architect or the authors.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"Try Simple HTML DOM Parser.\n\nA HTML DOM parser written in PHP 5+ that lets you manipulate HTML in a very easy way!\nRequire PHP 5+.\nSupports invalid HTML.\nFind tags on an HTML page with selectors just like jQuery.\nExtract contents from HTML in a single line.\nDownload\n\nNote: as the name suggests, it can be useful for simple tasks. It uses regular expressions instead of an HTML parser, so will be considerably slower for more complex tasks. The bulk of its codebase was written in 2008, with only small improvements made since then. It does not follow modern PHP coding standards and would be challenging to incorporate into a modern PSR-compliant project.\nExamples:\nHow to get HTML elements:\n// Create DOM from URL or file\n$html = file_get_html(&apos;http://www.example.com/&apos;);\n\n// Find all images\nforeach($html-&gt;find(&apos;img&apos;) as $element)\n       echo $element-&gt;src . &apos;&lt;br&gt;&apos;;\n\n// Find all links\nforeach($html-&gt;find(&apos;a&apos;) as $element)\n       echo $element-&gt;href . &apos;&lt;br&gt;&apos;;\n\nHow to modify HTML elements:\n// Create DOM from string\n$html = str_get_html(&apos;&lt;div id=&quot;hello&quot;&gt;Hello&lt;/div&gt;&lt;div id=&quot;world&quot;&gt;World&lt;/div&gt;&apos;);\n\n$html-&gt;find(&apos;div&apos;, 1)-&gt;class = &apos;bar&apos;;\n\n$html-&gt;find(&apos;div[id=hello]&apos;, 0)-&gt;innertext = &apos;foo&apos;;\n\necho $html;\n\nExtract content from HTML:\n// Dump contents (without tags) from HTML\necho file_get_html(&apos;http://www.google.com/&apos;)-&gt;plaintext;\n\nScraping Slashdot:\n// Create DOM from URL\n$html = file_get_html(&apos;http://slashdot.org/&apos;);\n\n// Find all article blocks\nforeach($html-&gt;find(&apos;div.article&apos;) as $article) {\n    $item[&apos;title&apos;]     = $article-&gt;find(&apos;div.title&apos;, 0)-&gt;plaintext;\n    $item[&apos;intro&apos;]    = $article-&gt;find(&apos;div.intro&apos;, 0)-&gt;plaintext;\n    $item[&apos;details&apos;] = $article-&gt;find(&apos;div.details&apos;, 0)-&gt;plaintext;\n    $articles[] = $item;\n}\n\nprint_r($articles);\n\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"Just use DOMDocument-&gt;loadHTML() and be done with it. libxml&apos;s HTML parsing algorithm is quite good and fast, and contrary to popular belief, does not choke on malformed HTML.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"Why you shouldn&apos;t and when you should use regular expressions?\n\nFirst off, a common misnomer: Regexps are not for &quot;parsing&quot; HTML. Regexes can however &quot;extract&quot; data. Extracting is what they&apos;re made for. The major drawback of regex HTML extraction over proper SGML toolkits or baseline XML parsers are their syntactic effort and varying reliability.\n\nConsider that making a somewhat dependable HTML extraction regex:\n\n&lt;a\\s+class=&quot;?playbutton\\d?[^&gt;]+id=&quot;(\\d+)&quot;.+?    &lt;a\\s+class=&quot;[\\w\\s]*title\n[\\w\\s]*&quot;[^&gt;]+href=&quot;(http://[^&quot;&gt;]+)&quot;[^&gt;]*&gt;([^&lt;&gt;]+)&lt;/a&gt;.+?\n\n\nis way less readable than a simple phpQuery or QueryPath equivalent:\n\n$div-&gt;find(&quot;.stationcool a&quot;)-&gt;attr(&quot;title&quot;);\n\n\nThere are however specific use cases where they can help.\n\n\nMany DOM traversal frontends don&apos;t reveal HTML comments &lt;!--, which however are sometimes the more useful anchors for extraction. In particular pseudo-HTML variations &lt;$var&gt; or SGML residues are easy to tame with regexps.\nOftentimes regular expressions can save post-processing. However HTML entities often require manual caretaking.\nAnd lastly, for extremely simple tasks like extracting &lt;img src= urls, they are in fact a probable tool. The speed advantage over SGML/XML parsers mostly just comes to play for these very basic extraction procedures.\n\n\nIt&apos;s sometimes even advisable to pre-extract a snippet of HTML using regular expressions /&lt;!--CONTENT--&gt;(.+?)&lt;!--END--&gt;/ and process the remainder using the simpler HTML parser frontends.\n\nNote: I actually have this app, where I employ XML parsing and regular expressions alternatively. Just last week the PyQuery parsing broke, and the regex still worked. Yes weird, and I can&apos;t explain it myself. But so it happened.\nSo please don&apos;t vote real-world considerations down, just because it doesn&apos;t match the regex=evil meme. But let&apos;s also not vote this up too much. It&apos;s just a sidenote for this topic.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"Note, this answer recommends libraries that have now been abandoned for 10+ years.\nphpQuery and QueryPath are extremely similar in replicating the fluent jQuery API. That&apos;s also why they&apos;re two of the easiest approaches to properly parse HTML in PHP.\nExamples for QueryPath\nBasically you first create a queryable DOM tree from an HTML string:\n $qp = qp(&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;title&lt;/h1&gt;...&quot;); // or give filename or URL\n\nThe resulting object contains a complete tree representation of the HTML document. It can be traversed using DOM methods. But the common approach is to use CSS selectors like in jQuery:\n $qp-&gt;find(&quot;div.classname&quot;)-&gt;children()-&gt;...;\n\n foreach ($qp-&gt;find(&quot;p img&quot;) as $img) {\n     print qp($img)-&gt;attr(&quot;src&quot;);\n }\n\nMostly you want to use simple #id and .class or DIV tag selectors for -&gt;find(). But you can also use XPath statements, which sometimes are faster. Also typical jQuery methods like -&gt;children() and -&gt;text() and particularly -&gt;attr() simplify extracting the right HTML snippets. (And already have their SGML entities decoded.)\n $qp-&gt;xpath(&quot;//div/p[1]&quot;);  // get first paragraph in a div\n\nQueryPath also allows injecting new tags into the stream (-&gt;append), and later output and prettify an updated document (-&gt;writeHTML). It can not only parse malformed HTML, but also various XML dialects (with namespaces), and even extract data from HTML microformats (XFN, vCard).\n $qp-&gt;find(&quot;a[target=_blank]&quot;)-&gt;toggleClass(&quot;usability-blunder&quot;);\n\n.\nphpQuery or QueryPath?\nGenerally QueryPath is better suited for manipulation of documents. While phpQuery also implements some pseudo AJAX methods (just HTTP requests) to more closely resemble jQuery. It is said that phpQuery is often faster than QueryPath (because of fewer overall features).\nFor further information on the differences see this comparison on the wayback machine from tagbyte.org. (Original source went missing, so here&apos;s an internet archive link. Yes, you can still locate missing pages, people.)\nAdvantages\n\nSimplicity and Reliability\nSimple to use alternatives -&gt;find(&quot;a img, a object, div a&quot;)\nProper data unescaping (in comparison to regular expression grepping)\n\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"Simple HTML DOM is a great open-source parser:  \n\nsimplehtmldom.sourceforge\n\nIt treats DOM elements in an object-oriented way, and the new iteration has a lot of coverage for non-compliant code. There are also some great functions like you&apos;d see in JavaScript, such as the &quot;find&quot; function, which will return all instances of elements of that tag name.  \n\nI&apos;ve used this in a number of tools, testing it on many different types of web pages, and I think it works great.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"One general approach I haven&apos;t seen mentioned here is to run HTML through Tidy, which can be set to spit out guaranteed-valid XHTML. Then you can use any old XML library on it.\n\nBut to your specific problem, you should take a look at this project: http://fivefilters.org/content-only/ -- it&apos;s a modified version of the Readability algorithm, which is designed to extract just the textual content (not headers and footers) from a page. \n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"For 1a and 2: I would vote for the new Symfony Componet class DOMCrawler ( DomCrawler ).\nThis class allows queries similar to CSS Selectors. Take a look at this presentation for real-world examples: news-of-the-symfony2-world.\n\nThe component is designed to work standalone and can be used without Symfony.\n\nThe only drawback is that it will only work with PHP 5.3 or newer.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"This is commonly referred to as screen scraping, by the way. The library I have used for this is Simple HTML Dom Parser.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"We have created quite a few crawlers for our needs before. At the end of the day, it is usually simple regular expressions that do the thing best. While libraries listed above are good for the reason they are created, if you know what you are looking for, regular expressions is a safer way to go, as you can handle also non-valid HTML/XHTML structures, which would fail, if loaded via most of the parsers.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"I recommend PHP Simple HTML DOM Parser.\n\nIt really has nice features, like:\n\nforeach($html-&gt;find(&apos;img&apos;) as $element)\n       echo $element-&gt;src . &apos;&lt;br&gt;&apos;;\n\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"This sounds like a good task description of W3C XPath technology. It&apos;s easy to express queries like &quot;return all href attributes in img tags that are nested in &lt;foo&gt;&lt;bar&gt;&lt;baz&gt; elements.&quot; Not being a PHP buff, I can&apos;t tell you in what form XPath may be available. If you can call an external program to process the HTML file you should be able to use a command line version of XPath.\nFor a quick intro, see http://en.wikipedia.org/wiki/XPath.\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"Third party alternatives to SimpleHtmlDom that use DOM instead of String Parsing: phpQuery, Zend_Dom, QueryPath and FluentDom.\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"Yes you can use simple_html_dom for the purpose. However I have worked quite a lot with the simple_html_dom, particularly for web scraping and have found it to be too vulnerable. It does the basic job but I won&apos;t recommend it anyways.\nI have never used curl for the purpose but what I have learned is that curl can do the job much more efficiently and is much more solid.\nKindly check out this link:scraping-websites-with-curl\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"QueryPath is good, but be careful of &quot;tracking state&quot; cause if you didn&apos;t realise what it means, it can mean you waste a lot of debugging time trying to find out what happened and why the code doesn&apos;t work.\n\nWhat it means is that each call on the result set modifies the result set in the object, it&apos;s not chainable like in jquery where each link is a new set, you have a single set which is the results from your query and each function call modifies that single set.\n\nin order to get jquery-like behaviour, you need to branch before you do a filter/modify like operation, that means it&apos;ll mirror what happens in jquery much more closely.\n\n$results = qp(&quot;div p&quot;);\n$forename = $results-&gt;find(&quot;input[name=&apos;forename&apos;]&quot;);\n\n\n$results now contains the result set for input[name=&apos;forename&apos;] NOT the original query &quot;div p&quot; this tripped me up a lot, what I found was that QueryPath tracks the filters and finds and everything which modifies your results and stores them in the object.  you need to do this instead\n\n$forename = $results-&gt;branch()-&gt;find(&quot;input[name=&apos;forname&apos;]&quot;)\n\n\nthen $results won&apos;t be modified and you can reuse the result set again and again, perhaps somebody with much more knowledge can clear this up a bit, but it&apos;s basically like this from what I&apos;ve found.\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"Advanced Html Dom is a simple HTML DOM replacement that offers the same interface, but it&apos;s DOM-based which means none of the associated memory issues occur.\n\nIt also has full CSS support, including jQuery extensions.\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"For HTML5, html5 lib has been abandoned for years now. The only HTML5 library I can find with a recent update and maintenance records is html5-php which was just brought to beta 1.0 a little over a week ago.\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"I created a library named PHPPowertools/DOM-Query, which allows you to crawl HTML5 and XML documents just like you do with jQuery.\nUnder the hood, it uses symfony/DomCrawler for conversion of CSS selectors to XPath selectors. It always uses the same DomDocument, even when passing one object to another, to ensure decent performance.\n\nExample use :\nnamespace PowerTools;\n\n// Get file content\n$htmlcode = file_get_contents(&apos;https://github.com&apos;);\n\n// Define your DOMCrawler based on file string\n$H = new DOM_Query($htmlcode);\n\n// Define your DOMCrawler based on an existing DOM_Query instance\n$H = new DOM_Query($H-&gt;select(&apos;body&apos;));\n\n// Passing a string (CSS selector)\n$s = $H-&gt;select(&apos;div.foo&apos;);\n\n// Passing an element object (DOM Element)\n$s = $H-&gt;select($documentBody);\n\n// Passing a DOM Query object\n$s = $H-&gt;select( $H-&gt;select(&apos;p + p&apos;));\n\n// Select the body tag\n$body = $H-&gt;select(&apos;body&apos;);\n\n// Combine different classes as one selector to get all site blocks\n$siteblocks = $body-&gt;select(&apos;.site-header, .masthead, .site-body, .site-footer&apos;);\n\n// Nest your methods just like you would with jQuery\n$siteblocks-&gt;select(&apos;button&apos;)-&gt;add(&apos;span&apos;)-&gt;addClass(&apos;icon icon-printer&apos;);\n\n// Use a lambda function to set the text of all site blocks\n$siteblocks-&gt;text(function( $i, $val) {\n    return $i . &quot; - &quot; . $val-&gt;attr(&apos;class&apos;);\n});\n\n// Append the following HTML to all site blocks\n$siteblocks-&gt;append(&apos;&lt;div class=&quot;site-center&quot;&gt;&lt;/div&gt;&apos;);\n\n// Use a descendant selector to select the site&apos;s footer\n$sitefooter = $body-&gt;select(&apos;.site-footer &gt; .site-center&apos;);\n\n// Set some attributes for the site&apos;s footer\n$sitefooter-&gt;attr(array(&apos;id&apos; =&gt; &apos;aweeesome&apos;, &apos;data-val&apos; =&gt; &apos;see&apos;));\n\n// Use a lambda function to set the attributes of all site blocks\n$siteblocks-&gt;attr(&apos;data-val&apos;, function( $i, $val) {\n    return $i . &quot; - &quot; . $val-&gt;attr(&apos;class&apos;) . &quot; - photo by Kelly Clark&quot;;\n});\n\n// Select the parent of the site&apos;s footer\n$sitefooterparent = $sitefooter-&gt;parent();\n\n// Remove the class of all i-tags within the site&apos;s footer&apos;s parent\n$sitefooterparent-&gt;select(&apos;i&apos;)-&gt;removeAttr(&apos;class&apos;);\n\n// Wrap the site&apos;s footer within two nex selectors\n$sitefooter-&gt;wrap(&apos;&lt;section&gt;&lt;div class=&quot;footer-wrapper&quot;&gt;&lt;/div&gt;&lt;/section&gt;&apos;);\n\n[...]\n\n\nSupported methods :\n\n[x] $ (1)\n[x] $.parseHTML\n[x] $.parseXML\n[x] $.parseJSON\n[x] $selection.add\n[x] $selection.addClass\n[x] $selection.after\n[x] $selection.append\n[x] $selection.attr\n[x] $selection.before\n[x] $selection.children\n[x] $selection.closest\n[x] $selection.contents\n[x] $selection.detach\n[x] $selection.each\n[x] $selection.eq\n[x] $selection.empty (2)\n[x] $selection.find\n[x] $selection.first\n[x] $selection.get\n[x] $selection.insertAfter\n[x] $selection.insertBefore\n[x] $selection.last\n[x] $selection.parent\n[x] $selection.parents\n[x] $selection.remove\n[x] $selection.removeAttr\n[x] $selection.removeClass\n[x] $selection.text\n[x] $selection.wrap\n\n\n\nRenamed &apos;select&apos;, for obvious reasons\nRenamed &apos;void&apos;, since &apos;empty&apos; is a reserved word in PHP\n\n\nNOTE :\nThe library also includes its own zero-configuration autoloader for PSR-0 compatible libraries. The example included should work out of the box without any additional configuration. Alternatively, you can use it with composer.\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0},{"text":"You could try using something like HTML Tidy to cleanup any &quot;broken&quot; HTML and convert the HTML to XHTML, which you can then parse with a XML parser.\n    ","url":"/questions/[slug]#solution19","@type":"Answer","upvoteCount":0},{"text":"I have written a general purpose XML parser that can easily handle GB files. It&apos;s based on XMLReader and it&apos;s very easy to use:\n\n$source = new XmlExtractor(&quot;path/to/tag&quot;, &quot;/path/to/file.xml&quot;);\nforeach ($source as $tag) {\n    echo $tag-&gt;field1;\n    echo $tag-&gt;field2-&gt;subfield1;\n}\n\n\nHere&apos;s the github repo: XmlExtractor\n    ","url":"/questions/[slug]#solution20","@type":"Answer","upvoteCount":0},{"text":"Another option you can try is QueryPath. It&apos;s inspired by jQuery, but on the server in PHP and used in Drupal.\n    ","url":"/questions/[slug]#solution21","@type":"Answer","upvoteCount":0},{"text":"XML_HTMLSax is rather stable - even if it&apos;s not maintained any more. Another option could be to pipe you HTML through Html Tidy and then parse it with standard XML tools.\n    ","url":"/questions/[slug]#solution22","@type":"Answer","upvoteCount":0},{"text":"There are many ways to process HTML/XML DOM of which most have already been mentioned. Hence, I won&apos;t make any attempt to list those myself.\n\nI merely want to add that I personally prefer using the DOM extension and why :\n\n\niit makes optimal use of the performance advantage of the underlying C code\nit&apos;s OO PHP (and allows me to subclass it)\nit&apos;s rather low level (which allows me to use it as a non-bloated foundation for more advanced behavior)\nit provides access to every part of the DOM (unlike eg. SimpleXml, which ignores some of the lesser known XML features)\nit has a syntax used for DOM crawling that&apos;s similar to the syntax used in native Javascript.\n\n\nAnd while I miss the ability to use CSS selectors for DOMDocument, there is a rather simple and convenient way to add this feature: subclassing the DOMDocument and adding JS-like querySelectorAll and querySelector methods to your subclass.\n\nFor parsing the selectors, I recommend using the very minimalistic CssSelector component from the Symfony framework. This component just translates CSS selectors to XPath selectors, which can then be fed into a DOMXpath to retrieve the corresponding Nodelist.\n\nYou can then use this (still very low level) subclass as a foundation for more high level classes, intended to eg. parse very specific types of XML or add more jQuery-like behavior.\n\nThe code below comes straight out my DOM-Query library and uses the technique I described.\n\nFor HTML parsing :\n\nnamespace PowerTools;\n\nuse \\Symfony\\Component\\CssSelector\\CssSelector as CssSelector;\n\nclass DOM_Document extends \\DOMDocument {\n    public function __construct($data = false, $doctype = &apos;html&apos;, $encoding = &apos;UTF-8&apos;, $version = &apos;1.0&apos;) {\n        parent::__construct($version, $encoding);\n        if ($doctype &amp;&amp; $doctype === &apos;html&apos;) {\n            @$this-&gt;loadHTML($data);\n        } else {\n            @$this-&gt;loadXML($data);\n        }\n    }\n\n    public function querySelectorAll($selector, $contextnode = null) {\n        if (isset($this-&gt;doctype-&gt;name) &amp;&amp; $this-&gt;doctype-&gt;name == &apos;html&apos;) {\n            CssSelector::enableHtmlExtension();\n        } else {\n            CssSelector::disableHtmlExtension();\n        }\n        $xpath = new \\DOMXpath($this);\n        return $xpath-&gt;query(CssSelector::toXPath($selector, &apos;descendant::&apos;), $contextnode);\n    }\n\n    [...]\n\n    public function loadHTMLFile($filename, $options = 0) {\n        $this-&gt;loadHTML(file_get_contents($filename), $options);\n    }\n\n    public function loadHTML($source, $options = 0) {\n        if ($source &amp;&amp; $source != &apos;&apos;) {\n            $data = trim($source);\n            $html5 = new HTML5(array(&apos;targetDocument&apos; =&gt; $this, &apos;disableHtmlNsInDom&apos; =&gt; true));\n            $data_start = mb_substr($data, 0, 10);\n            if (strpos($data_start, &apos;&lt;!DOCTYPE &apos;) === 0 || strpos($data_start, &apos;&lt;html&gt;&apos;) === 0) {\n                $html5-&gt;loadHTML($data);\n            } else {\n                @$this-&gt;loadHTML(&apos;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;&apos; . $encoding . &apos;&quot; /&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&apos;);\n                $t = $html5-&gt;loadHTMLFragment($data);\n                $docbody = $this-&gt;getElementsByTagName(&apos;body&apos;)-&gt;item(0);\n                while ($t-&gt;hasChildNodes()) {\n                    $docbody-&gt;appendChild($t-&gt;firstChild);\n                }\n            }\n        }\n    }\n\n    [...]\n}\n\n\nSee also Parsing XML documents with CSS selectors by Symfony&apos;s creator Fabien Potencier on his decision to create the CssSelector component for Symfony and how to use it.\n    ","url":"/questions/[slug]#solution23","@type":"Answer","upvoteCount":0},{"text":"The Symfony framework has bundles which can parse the HTML, and you can use CSS style to select the DOMs instead of using XPath.\n    ","url":"/questions/[slug]#solution24","@type":"Answer","upvoteCount":0},{"text":"With FluidXML you can query and iterate XML using XPath and CSS Selectors.\n\n$doc = fluidxml(&apos;&lt;html&gt;...&lt;/html&gt;&apos;);\n\n$title = $doc-&gt;query(&apos;//head/title&apos;)[0]-&gt;nodeValue;\n\n$doc-&gt;query(&apos;//body/p&apos;, &apos;div.active&apos;, &apos;#bgId&apos;)\n        -&gt;each(function($i, $node) {\n            // $node is a DOMNode.\n            $tag   = $node-&gt;nodeName;\n            $text  = $node-&gt;nodeValue;\n            $class = $node-&gt;getAttribute(&apos;class&apos;);\n        });\n\n\nhttps://github.com/servo-php/fluidxml\n    ","url":"/questions/[slug]#solution25","@type":"Answer","upvoteCount":0},{"text":"JSON and array from XML in three lines:\n\n$xml = simplexml_load_string($xml_string);\n$json = json_encode($xml);\n$array = json_decode($json,TRUE);\n\n\nTa da!\n    ","url":"/questions/[slug]#solution26","@type":"Answer","upvoteCount":0},{"text":"There are several reasons to not parse HTML by regular expression. But, if you have total control of what HTML will be generated, then you can do with simple regular expression.\n\nAbove it&apos;s a function that parses HTML by regular expression. Note that this function is very sensitive and demands that the HTML obey certain rules, but it works very well in many scenarios. If you want a simple parser, and don&apos;t want to install libraries, give this a shot:\n\nfunction array_combine_($keys, $values) {\n    $result = array();\n    foreach ($keys as $i =&gt; $k) {\n        $result[$k][] = $values[$i];\n    }\n    array_walk($result, create_function(&apos;&amp;$v&apos;, &apos;$v = (count($v) == 1)? array_pop($v): $v;&apos;));\n\n    return $result;\n}\n\nfunction extract_data($str) {\n    return (is_array($str))\n        ? array_map(&apos;extract_data&apos;, $str)\n        : ((!preg_match_all(&apos;#&lt;([A-Za-z0-9_]*)[^&gt;]*&gt;(.*?)&lt;/\\1&gt;#s&apos;, $str, $matches))\n            ? $str\n            : array_map((&apos;extract_data&apos;), array_combine_($matches[1], $matches[2])));\n}\n\nprint_r(extract_data(file_get_contents(&quot;http://www.google.com/&quot;)));\n\n    ","url":"/questions/[slug]#solution27","@type":"Answer","upvoteCount":0},{"text":"I&apos;ve created a library called HTML5DOMDocument that is freely available at https://github.com/ivopetkov/html5-dom-document-php\n\nIt supports query selectors too that I think will be extremely helpful in your case. Here is some example code:\n\n$dom = new IvoPetkov\\HTML5DOMDocument();\n$dom-&gt;loadHTML(&apos;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;div class=&quot;content&quot;&gt;This is some text&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&apos;);\necho $dom-&gt;querySelector(&apos;h1&apos;)-&gt;innerHTML;\n\n    ","url":"/questions/[slug]#solution28","@type":"Answer","upvoteCount":0},{"text":"The best method for parse xml:\n\n$xml=&apos;http://www.example.com/rss.xml&apos;;\n$rss = simplexml_load_string($xml);\n$i = 0;\nforeach ($rss-&gt;channel-&gt;item as $feedItem) {\n  $i++;\n  echo $title=$feedItem-&gt;title;\n  echo &apos;&lt;br&gt;&apos;;\n  echo $link=$feedItem-&gt;link;\n  echo &apos;&lt;br&gt;&apos;;\n  if($feedItem-&gt;description !=&apos;&apos;) {\n    $des=$feedItem-&gt;description;\n  } else {\n    $des=&apos;&apos;;\n  }\n  echo $des;\n  echo &apos;&lt;br&gt;&apos;;\n  if($i&gt;5) break;\n}\n\n    ","url":"/questions/[slug]#solution29","@type":"Answer","upvoteCount":0},{"text":"If you&apos;re familiar with jQuery selector, you can use ScarletsQuery for PHP\n\n&lt;pre&gt;&lt;?php\ninclude &quot;ScarletsQuery.php&quot;;\n\n// Load the HTML content and parse it\n$html = file_get_contents(&apos;https://www.lipsum.com&apos;);\n$dom = Scarlets\\Library\\MarkupLanguage::parseText($html);\n\n// Select meta tag on the HTML header\n$description = $dom-&gt;selector(&apos;head meta[name=&quot;description&quot;]&apos;)[0];\n\n// Get &apos;content&apos; attribute value from meta tag\nprint_r($description-&gt;attr(&apos;content&apos;));\n\n$description = $dom-&gt;selector(&apos;#Content p&apos;);\n\n// Get element array\nprint_r($description-&gt;view);\n\n\nThis library usually taking less than 1 second to process offline html.\nIt also accept invalid HTML or missing quote on tag attributes.\n    ","url":"/questions/[slug]#solution30","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-12e9794e898cd5f3.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-928c5d1eb8fb0bba.js" defer=""></script><script src="/_next/static/BnkbnjkWYxefPXjTJLVVv/_buildManifest.js" defer=""></script><script src="/_next/static/BnkbnjkWYxefPXjTJLVVv/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/how-do-you-parse-and-process-htmlxml-in-php-1657384351267#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/how-do-you-parse-and-process-htmlxml-in-php-1657384351267"><h1>How do you parse and process HTML/XML in PHP?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/html-parsing">html-parsing</a></div></div><div class="question-content mt-5">
                
<p>How can one parse HTML/XML and extract information from it?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li><li class="pagination-solution-item"><span data-id="#solution19" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">19</span></li><li class="pagination-solution-item"><span data-id="#solution20" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">20</span></li><li class="pagination-solution-item"><span data-id="#solution21" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">21</span></li><li class="pagination-solution-item"><span data-id="#solution22" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">22</span></li><li class="pagination-solution-item"><span data-id="#solution23" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">23</span></li><li class="pagination-solution-item"><span data-id="#solution24" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">24</span></li><li class="pagination-solution-item"><span data-id="#solution25" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">25</span></li><li class="pagination-solution-item"><span data-id="#solution26" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">26</span></li><li class="pagination-solution-item"><span data-id="#solution27" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">27</span></li><li class="pagination-solution-item"><span data-id="#solution28" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">28</span></li><li class="pagination-solution-item"><span data-id="#solution29" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">29</span></li><li class="pagination-solution-item"><span data-id="#solution30" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">30</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/html-parsing">html-parsing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2>Native XML Extensions</h2>
<p>I prefer using one of the <a href="https://php.net/manual/en/refs.xml.php" rel="nofollow noreferrer">native XML extensions</a> since they come bundled with PHP, are usually faster than all the 3rd party libs and give me all the control I need over the markup.</p>
<h3><a href="https://php.net/manual/en/book.dom.php" rel="nofollow noreferrer">DOM</a></h3>
<blockquote>
<p>The DOM extension allows you to operate on XML documents through the DOM API with PHP 5. It is an implementation of the W3C's Document Object Model Core Level 3, a platform- and language-neutral interface that allows programs and scripts to dynamically access and update the content, structure and style of documents.</p>
</blockquote>
<p>DOM is capable of parsing and modifying real world (broken) HTML and it can do <a href="http://schlitt.info/opensource/blog/0704_xpath.html" rel="nofollow noreferrer">XPath queries</a>. It is based on <a href="http://xmlsoft.org/html/libxml-HTMLparser.html" rel="nofollow noreferrer">libxml</a>.</p>
<p>It takes some time to get productive with DOM, but that time is well worth it IMO. Since DOM is a language-agnostic interface, you'll find implementations in many languages, so if you need to change your programming language, chances are you will already know how to use that language's DOM API then.</p>
<p>How to use the DOM extension has been <a href="https://stackoverflow.com/search?q=DOM+HTML+%5BPHP%5D&amp;submit=search">covered extensively</a> on StackOverflow, so if you choose to use it, you can be sure most of the issues you run into can be solved by searching/browsing Stack Overflow.</p>
<p>A <a href="https://stackoverflow.com/a/3820783">basic usage example</a> and a <a href="https://stackoverflow.com/a/4983721">general conceptual overview</a> are available in other answers.</p>
<h3><a href="https://php.net/manual/en/book.xmlreader.php" rel="nofollow noreferrer">XMLReader</a></h3>
<blockquote>
<p>The XMLReader extension is an XML pull parser. The reader acts as a cursor going forward on the document stream and stopping at each node on the way.</p>
</blockquote>
<p>XMLReader, like DOM, is based on libxml. I am not aware of how to trigger the HTML Parser Module, so chances are using XMLReader for parsing broken HTML might be less robust than using DOM where you can explicitly tell it to use libxml's HTML Parser Module.</p>
<p>A <a href="https://stackoverflow.com/a/3299140">basic usage example</a> is available in another answer.</p>
<h3><a href="https://php.net/manual/en/book.xml.php" rel="nofollow noreferrer">XML Parser</a></h3>
<blockquote>
<p>This extension lets you create XML parsers and then define handlers for different XML events. Each XML parser also has a few parameters you can adjust.</p>
</blockquote>
<p>The XML Parser library is also based on libxml, and implements a <a href="http://en.wikipedia.org/wiki/Simple_API_for_XML" rel="nofollow noreferrer">SAX</a> style XML push parser. It may be a better choice for memory management than DOM or SimpleXML, but will be more difficult to work with than the pull parser implemented by XMLReader.</p>
<h3><a href="https://php.net/manual/en/book.simplexml.php" rel="nofollow noreferrer">SimpleXml</a></h3>
<blockquote>
<p>The SimpleXML extension provides a very simple and easily usable toolset to convert XML to an object that can be processed with normal property selectors and array iterators.</p>
</blockquote>
<p>SimpleXML is an option when you know the HTML is valid XHTML. If you need to parse broken HTML, don't even consider SimpleXml because it will choke.</p>
<p>A <a href="https://stackoverflow.com/a/4906459">basic usage example</a> is available, and there are <a href="https://php.net/manual/en/simplexml.examples-basic.php" rel="nofollow noreferrer">lots of additional examples in the PHP Manual</a>.</p>
<hr>
<h2>3rd Party Libraries (libxml based)</h2>
<p>If you prefer to use a 3rd-party lib, I'd suggest using a lib that actually uses <a href="http://php.net/manual/en/book.dom.php" rel="nofollow noreferrer">DOM</a>/<a href="http://xmlsoft.org/" rel="nofollow noreferrer">libxml</a> underneath instead of string parsing.</p>
<h3><a href="https://github.com/ThomasWeinert/FluentDOM" rel="nofollow noreferrer">FluentDom</a></h3>
<blockquote>
<p>FluentDOM provides a jQuery-like fluent XML interface for the DOMDocument in PHP. Selectors are written in XPath or CSS (using a CSS to XPath converter). Current versions extend the DOM implementing standard interfaces and add features from the DOM Living Standard. FluentDOM can load formats like JSON, CSV, JsonML, RabbitFish and others. Can be installed via Composer.</p>
</blockquote>
<h3><a href="https://github.com/wasinger/htmlpagedom" rel="nofollow noreferrer">HtmlPageDom</a></h3>
<blockquote>
<p><code>Wa72\HtmlPageDom</code> is a PHP library for easy manipulation of HTML
documents using DOM. It requires <a href="https://github.com/symfony/DomCrawler" rel="nofollow noreferrer">DomCrawler from Symfony2
components</a> for traversing
the DOM tree and extends it by adding methods for manipulating the
DOM tree of HTML documents.</p>
</blockquote>
<h3><a href="https://github.com/electrolinux/phpquery" rel="nofollow noreferrer">phpQuery</a></h3>
<blockquote>
<p>phpQuery is a server-side, chainable, CSS3 selector driven Document Object Model (DOM) API based on jQuery JavaScript Library.
The library is written in PHP5 and provides additional Command Line Interface (CLI).</p>
</blockquote>
<p>This is described as "abandonware and buggy: use at your own risk" but does appear to be minimally maintained.</p>
<h3><a href="https://docs.laminas.dev/laminas-dom/" rel="nofollow noreferrer">laminas-dom</a></h3>
<blockquote>
<p>The Laminas\Dom component (formerly Zend_DOM) provides tools for working with DOM documents and structures. Currently, we offer <code>Laminas\Dom\Query</code>, which provides a unified interface for querying DOM documents utilizing both XPath and CSS selectors.</p>
<p>This package is considered feature-complete, and is now in security-only maintenance mode.</p>
</blockquote>
<h3><a href="http://github.com/theseer/fDOMDocument" rel="nofollow noreferrer">fDOMDocument</a></h3>
<blockquote>
<p>fDOMDocument extends the standard DOM to use exceptions at all occasions of errors instead of PHP warnings or notices. They also add various custom methods and shortcuts for convenience and to simplify the usage of DOM.</p>
</blockquote>
<h3><a href="http://sabre.io/xml/" rel="nofollow noreferrer">sabre/xml</a></h3>
<blockquote>
<p>sabre/xml is a library that wraps and extends the XMLReader and XMLWriter classes to create a simple "xml to object/array" mapping system and design pattern. Writing and reading XML is single-pass and can therefore be fast and require low memory on large xml files.</p>
</blockquote>
<h3><a href="https://github.com/servo-php/fluidxml" rel="nofollow noreferrer">FluidXML</a></h3>
<blockquote>
<p>FluidXML is a PHP library for manipulating XML with a concise and fluent API.
It leverages XPath and the fluent programming pattern to be fun and effective.</p>
</blockquote>
<hr>
<h2>3rd-Party (not libxml-based)</h2>
<p>The benefit of building upon DOM/libxml is that you get good performance out of the box because you are based on a native extension. However, not all 3rd-party libs go down this route. Some of them listed below</p>
<h3><a href="https://simplehtmldom.sourceforge.io/docs/1.9/index.html" rel="nofollow noreferrer">PHP Simple HTML DOM Parser</a></h3>
<blockquote>
<ul>
<li>An HTML DOM parser written in PHP5+ lets you manipulate HTML in a very easy way!</li>
<li>Require PHP 5+.</li>
<li>Supports invalid HTML.</li>
<li>Find tags on an HTML page with selectors just like jQuery.</li>
<li>Extract contents from HTML in a single line.</li>
</ul>
</blockquote>
<p>I generally do not recommend this parser. The codebase is horrible and the parser itself is rather slow and memory hungry. Not all jQuery Selectors (such as <a href="https://api.jquery.com/child-selector/" rel="nofollow noreferrer">child selectors</a>) are possible. Any of the libxml based libraries should outperform this easily.</p>
<h3><a href="https://github.com/paquettg/php-html-parser" rel="nofollow noreferrer">PHP Html Parser</a></h3>
<blockquote>
<p>PHPHtmlParser is a simple, flexible, html parser which allows you to select tags using any css selector, like jQuery. The goal is to assiste in the development of tools which require a quick, easy way to scrape html, whether it's valid or not! This project was original supported by sunra/php-simple-html-dom-parser but the support seems to have stopped so this project is my adaptation of his previous work.</p>
</blockquote>
<p>Again, I would not recommend this parser. It is rather slow with high CPU usage. There is also no function to clear memory of created DOM objects. These problems scale particularly with nested loops. The documentation itself is inaccurate and misspelled, with no responses to fixes since 14 Apr 16.</p>
<hr>
<h2>HTML 5</h2>
<p>You can use the above for parsing HTML5, but <a href="https://stackoverflow.com/q/4029341">there can be quirks</a> due to the markup HTML5 allows. So for HTML5 you may want to consider using a dedicated parser. Note that these are written in PHP, so suffer from slower performance and increased memory usage compared to a compiled extension in a lower-level language.</p>
<h3><a href="https://github.com/ivopetkov/html5-dom-document-php/" rel="nofollow noreferrer">HTML5DomDocument</a></h3>
<blockquote>
<p>HTML5DOMDocument extends the native DOMDocument library. It fixes some bugs and adds some new functionality.</p>
<ul>
<li>Preserves html entities (DOMDocument does not)</li>
<li>Preserves void tags (DOMDocument does not)</li>
<li>Allows inserting HTML code that moves the correct parts to their proper places (head elements are inserted in the head, body elements in the body)</li>
<li>Allows querying the DOM with CSS selectors (currently available: <code>*</code>, <code>tagname</code>, <code>tagname#id</code>, <code>#id</code>, <code>tagname.classname</code>, <code>.classname</code>, <code>tagname.classname.classname2</code>, <code>.classname.classname2</code>, <code>tagname[attribute-selector]</code>, <code>[attribute-selector]</code>, <code>div, p</code>, <code>div p</code>, <code>div &gt; p</code>, <code>div + p</code>, and <code>p ~ ul</code>.)</li>
<li>Adds support for element-&gt;classList.</li>
<li>Adds support for element-&gt;innerHTML.</li>
<li>Adds support for element-&gt;outerHTML.</li>
</ul>
</blockquote>
<h3><a href="https://github.com/Masterminds/html5-php" rel="nofollow noreferrer">HTML5</a></h3>
<blockquote>
<p>HTML5 is a standards-compliant HTML5 parser and writer written entirely in PHP. It is stable and used in many production websites, and has well over five million downloads.</p>
<p>HTML5 provides the following features.</p>
</blockquote>
<blockquote>
<ul>
<li>An HTML5 serializer</li>
<li>Support for PHP namespaces</li>
<li>Composer support</li>
<li>Event-based (SAX-like) parser</li>
<li>A DOM tree builder</li>
<li>Interoperability with QueryPath</li>
<li>Runs on PHP 5.3.0 or newer</li>
</ul>
</blockquote>
<hr>
<h2>Regular Expressions</h2>
<p>Last and <strong>least recommended</strong>, you can extract data from HTML with <a href="https://stackoverflow.com/search?q=regular%20expression%20tutorials">regular expressions</a>. In general using Regular Expressions on HTML is discouraged.</p>
<p>Most of the snippets you will find on the web to match markup are brittle. In most cases they are only working for a very particular piece of HTML. Tiny markup changes, like adding whitespace somewhere, or adding, or changing attributes in a tag, can make the RegEx fails when it's not properly written. You should know what you are doing before using RegEx on HTML.</p>
<p>HTML parsers already know the syntactical rules of HTML. Regular expressions have to be taught for each new RegEx you write. RegEx are fine in some cases, but it really depends on your use-case.</p>
<p>You <a href="https://stackoverflow.com/a/4234491">can write more reliable parsers</a>, but writing a <em>complete and reliable</em> custom parser with regular expressions is a waste of time when the aforementioned libraries already exist and do a much better job on this.</p>
<p>Also see <a href="http://www.codinghorror.com/blog/2009/11/parsing-html-the-cthulhu-way.html" rel="nofollow noreferrer">Parsing Html The Cthulhu Way</a></p>
<hr>
<h2>Books</h2>
<p>If you want to spend some money, have a look at</p>
<ul>
<li><a href="http://www.phparch.com/books/phparchitects-guide-to-web-scraping-with-php" rel="nofollow noreferrer">PHP Architect's Guide to Webscraping with PHP</a></li>
</ul>
<p>I am not affiliated with PHP Architect or the authors.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/html-parsing">html-parsing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Try <a href="https://simplehtmldom.sourceforge.io/" rel="noreferrer"><strong>Simple HTML DOM Parser</strong></a>.</p>
<ul>
<li>A HTML DOM parser written in PHP&nbsp;5+ that lets you manipulate HTML in a very easy way!</li>
<li>Require PHP 5+.</li>
<li>Supports invalid HTML.</li>
<li>Find tags on an HTML page with selectors just like jQuery.</li>
<li>Extract contents from HTML in a single line.</li>
<li><a href="https://sourceforge.net/projects/simplehtmldom/files/simplehtmldom/" rel="noreferrer">Download</a></li>
</ul>
<p>Note: as the name suggests, it can be useful for simple tasks. It uses regular expressions instead of an HTML parser, so will be considerably slower for more complex tasks. The bulk of its codebase was written in 2008, with only small improvements made since then. It does not follow modern PHP coding standards and would be challenging to incorporate into a modern PSR-compliant project.</p>
<h2><a href="https://simplehtmldom.sourceforge.io/manual.htm" rel="noreferrer">Examples:</a></h2>
<h3>How to get HTML elements:</h3>
<pre class="default s-code-block"><code class="hljs language-php"><span class="hljs-comment">// Create DOM from URL or file</span>
<span class="hljs-variable">$html</span> = <span class="hljs-title function_ invoke__">file_get_html</span>(<span class="hljs-string">'http://www.example.com/'</span>);

<span class="hljs-comment">// Find all images</span>
<span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$html</span>-&gt;<span class="hljs-title function_ invoke__">find</span>(<span class="hljs-string">'img'</span>) <span class="hljs-keyword">as</span> <span class="hljs-variable">$element</span>)
       <span class="hljs-keyword">echo</span> <span class="hljs-variable">$element</span>-&gt;src . <span class="hljs-string">'&lt;br&gt;'</span>;

<span class="hljs-comment">// Find all links</span>
<span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$html</span>-&gt;<span class="hljs-title function_ invoke__">find</span>(<span class="hljs-string">'a'</span>) <span class="hljs-keyword">as</span> <span class="hljs-variable">$element</span>)
       <span class="hljs-keyword">echo</span> <span class="hljs-variable">$element</span>-&gt;href . <span class="hljs-string">'&lt;br&gt;'</span>;
</code></pre>
<h3>How to modify HTML elements:</h3>
<pre class="default s-code-block"><code class="hljs language-bash">// Create DOM from string
<span class="hljs-variable">$html</span> = str_get_html(<span class="hljs-string">'&lt;div id="hello"&gt;Hello&lt;/div&gt;&lt;div id="world"&gt;World&lt;/div&gt;'</span>);

<span class="hljs-variable">$html</span>-&gt;find(<span class="hljs-string">'div'</span>, 1)-&gt;class = <span class="hljs-string">'bar'</span>;

<span class="hljs-variable">$html</span>-&gt;find(<span class="hljs-string">'div[id=hello]'</span>, 0)-&gt;innertext = <span class="hljs-string">'foo'</span>;

<span class="hljs-built_in">echo</span> <span class="hljs-variable">$html</span>;
</code></pre>
<h3>Extract content from HTML:</h3>
<pre class="default s-code-block"><code class="hljs language-lisp">// Dump contents (<span class="hljs-name">without</span> tags) from HTML
echo file_get_html('http<span class="hljs-symbol">://www</span>.google.com/')-&gt;plaintext<span class="hljs-comment">;</span>
</code></pre>
<h3>Scraping Slashdot:</h3>
<pre class="default s-code-block"><code class="hljs language-php"><span class="hljs-comment">// Create DOM from URL</span>
<span class="hljs-variable">$html</span> = <span class="hljs-title function_ invoke__">file_get_html</span>(<span class="hljs-string">'http://slashdot.org/'</span>);

<span class="hljs-comment">// Find all article blocks</span>
<span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$html</span>-&gt;<span class="hljs-title function_ invoke__">find</span>(<span class="hljs-string">'div.article'</span>) <span class="hljs-keyword">as</span> <span class="hljs-variable">$article</span>) {
    <span class="hljs-variable">$item</span>[<span class="hljs-string">'title'</span>]     = <span class="hljs-variable">$article</span>-&gt;<span class="hljs-title function_ invoke__">find</span>(<span class="hljs-string">'div.title'</span>, <span class="hljs-number">0</span>)-&gt;plaintext;
    <span class="hljs-variable">$item</span>[<span class="hljs-string">'intro'</span>]    = <span class="hljs-variable">$article</span>-&gt;<span class="hljs-title function_ invoke__">find</span>(<span class="hljs-string">'div.intro'</span>, <span class="hljs-number">0</span>)-&gt;plaintext;
    <span class="hljs-variable">$item</span>[<span class="hljs-string">'details'</span>] = <span class="hljs-variable">$article</span>-&gt;<span class="hljs-title function_ invoke__">find</span>(<span class="hljs-string">'div.details'</span>, <span class="hljs-number">0</span>)-&gt;plaintext;
    <span class="hljs-variable">$articles</span>[] = <span class="hljs-variable">$item</span>;
}

<span class="hljs-title function_ invoke__">print_r</span>(<span class="hljs-variable">$articles</span>);
</code></pre>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/html-parsing">html-parsing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Just use <a href="http://docs.php.net/manual/en/domdocument.loadhtml.php" rel="noreferrer">DOMDocument-&gt;loadHTML()</a> and be done with it. libxml's HTML parsing algorithm is quite good and fast, and contrary to popular belief, does not choke on malformed HTML.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/html-parsing">html-parsing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Why you shouldn't and <em>when you should</em> use regular expressions?</strong></p>

<p>First off, a common misnomer: Regexps are not for <em>"<strong>parsing</strong>"</em> HTML. Regexes can however <em>"<strong>extract</strong>"</em> data. Extracting is what they're made for. The major drawback of regex HTML extraction over proper SGML toolkits or baseline XML parsers are their syntactic effort and varying reliability.</p>

<p>Consider that making a somewhat dependable HTML extraction regex:</p>

<pre class="default s-code-block"><code class="hljs language-bash">&lt;a\s+class=<span class="hljs-string">"?playbutton\d?[^&gt;]+id="</span>(\d+)<span class="hljs-string">".+?    &lt;a\s+class="</span>[\w\s]*title
[\w\s]*<span class="hljs-string">"[^&gt;]+href="</span>(http://[^<span class="hljs-string">"&gt;]+)"</span>[^&gt;]*&gt;([^&lt;&gt;]+)&lt;/a&gt;.+?
</code></pre>

<p>is way less readable than a simple phpQuery or QueryPath equivalent:</p>

<pre class="default s-code-block"><code class="hljs language-rust">$div<span class="hljs-punctuation">-&gt;</span><span class="hljs-title function_ invoke__">find</span>(<span class="hljs-string">".stationcool a"</span>)<span class="hljs-punctuation">-&gt;</span><span class="hljs-title function_ invoke__">attr</span>(<span class="hljs-string">"title"</span>);
</code></pre>

<p>There are however specific use cases where they can help.</p>

<ul>
<li>Many DOM traversal frontends don't reveal HTML comments <code>&lt;!--</code>, which however are sometimes the more useful anchors for extraction. In particular pseudo-HTML variations <code>&lt;$var&gt;</code> or SGML residues are easy to tame with regexps.</li>
<li>Oftentimes regular expressions can save post-processing. However HTML entities often require manual caretaking.</li>
<li>And lastly, for e<em>xtremely simple tasks</em> like extracting &lt;img src= urls, they are in fact a probable tool. The speed advantage over SGML/XML parsers mostly just comes to play for these very basic extraction procedures.</li>
</ul>

<p>It's sometimes even advisable to pre-extract a snippet of HTML using regular expressions <code>/&lt;!--CONTENT--&gt;(.+?)&lt;!--END--&gt;/</code> and process the remainder using the simpler HTML parser frontends.</p>

<p><strong>Note:</strong> I actually have this <a href="http://fossil.include-once.org/streamtuner2/" rel="noreferrer">app</a>, where I employ XML parsing and regular expressions alternatively. Just last week the PyQuery parsing broke, and the regex still worked. Yes weird, and I can't explain it myself. But so it happened.<br>
So please don't vote real-world considerations down, just because it doesn't match the regex=evil meme. <strong>But let's also not vote this up too much. It's just a sidenote for this topic.</strong></p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/html-parsing">html-parsing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2>Note, this answer recommends libraries that have now been abandoned for 10+ years.</h2>
<p><a href="https://github.com/TobiaszCudnik/phpquery" rel="nofollow noreferrer">phpQuery</a> and <a href="https://github.com/technosophos/querypath" rel="nofollow noreferrer">QueryPath</a> are extremely similar in replicating the fluent jQuery API. That's also why they're two of the easiest approaches to <em>properly</em> parse HTML in PHP.</p>
<p><strong>Examples for QueryPath</strong></p>
<p>Basically you first create a queryable DOM tree from an HTML string:</p>
<pre class="default s-code-block"><code class="hljs language-xml"> $qp = qp("<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>..."); // or give filename or URL
</code></pre>
<p>The resulting object contains a complete tree representation of the HTML document. It can be traversed using DOM methods. But the common approach is to use CSS selectors like in jQuery:</p>
<pre class="default s-code-block"><code class="hljs language-php"> <span class="hljs-variable">$qp</span>-&gt;<span class="hljs-title function_ invoke__">find</span>(<span class="hljs-string">"div.classname"</span>)-&gt;<span class="hljs-title function_ invoke__">children</span>()-&gt;...;

 <span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$qp</span>-&gt;<span class="hljs-title function_ invoke__">find</span>(<span class="hljs-string">"p img"</span>) <span class="hljs-keyword">as</span> <span class="hljs-variable">$img</span>) {
     <span class="hljs-keyword">print</span> <span class="hljs-title function_ invoke__">qp</span>(<span class="hljs-variable">$img</span>)-&gt;<span class="hljs-title function_ invoke__">attr</span>(<span class="hljs-string">"src"</span>);
 }
</code></pre>
<p>Mostly you want to use simple <code>#id</code> and <code>.class</code> or <code>DIV</code> tag selectors for <code>-&gt;find()</code>. But you can also use <a href="https://en.wikipedia.org/wiki/XPath" rel="nofollow noreferrer">XPath</a> statements, which sometimes are faster. Also typical jQuery methods like <code>-&gt;children()</code> and <code>-&gt;text()</code> and particularly <code>-&gt;attr()</code> simplify extracting the right HTML snippets. (And already have their SGML entities decoded.)</p>
<pre class="default s-code-block"><code class="hljs language-php"> <span class="hljs-variable">$qp</span>-&gt;<span class="hljs-title function_ invoke__">xpath</span>(<span class="hljs-string">"//div/p[1]"</span>);  <span class="hljs-comment">// get first paragraph in a div</span>
</code></pre>
<p>QueryPath also allows injecting new tags into the stream (<code>-&gt;append</code>), and later output and prettify an updated document (<code>-&gt;writeHTML</code>). It can not only parse malformed HTML, but also various XML dialects (with namespaces), and even extract data from HTML microformats (XFN, vCard).</p>
<pre class="default s-code-block"><code class="hljs language-rust"> $qp<span class="hljs-punctuation">-&gt;</span><span class="hljs-title function_ invoke__">find</span>(<span class="hljs-string">"a[target=_blank]"</span>)<span class="hljs-punctuation">-&gt;</span><span class="hljs-title function_ invoke__">toggleClass</span>(<span class="hljs-string">"usability-blunder"</span>);
</code></pre>
<p>.</p>
<p><strong>phpQuery or QueryPath?</strong></p>
<p>Generally QueryPath is better suited for manipulation of documents. While phpQuery also implements some pseudo AJAX methods (just HTTP requests) to more closely resemble jQuery. It is said that phpQuery is often faster than QueryPath (because of fewer overall features).</p>
<p>For further information on the differences see <a href="https://web.archive.org/web/20101230230134/http://www.tagbytag.org/articles/phpquery-vs-querypath" rel="nofollow noreferrer">this comparison on the wayback machine from tagbyte.org</a>. (Original source went missing, so here's an internet archive link. Yes, you can still locate missing pages, people.)</p>
<p><strong>Advantages</strong></p>
<ul>
<li>Simplicity and Reliability</li>
<li>Simple to use alternatives <code>-&gt;find("a img, a object, div a")</code></li>
<li>Proper data unescaping (in comparison to regular expression grepping)</li>
</ul>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/html-parsing">html-parsing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Simple HTML DOM is a great open-source parser:  </p>

<p><a href="http://simplehtmldom.sourceforge.net/" rel="noreferrer">simplehtmldom.sourceforge</a></p>

<p>It treats DOM elements in an object-oriented way, and the new iteration has a lot of coverage for non-compliant code. There are also some great functions like you'd see in JavaScript, such as the "find" function, which will return all instances of elements of that tag name.  </p>

<p>I've used this in a number of tools, testing it on many different types of web pages, and I think it works great.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/html-parsing">html-parsing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>One general approach I haven't seen mentioned here is to run HTML through <a href="http://php.net/manual/en/book.tidy.php" rel="noreferrer">Tidy</a>, which can be set to spit out guaranteed-valid XHTML. Then you can use any old XML library on it.</p>

<p>But to your specific problem, you should take a look at this project: <a href="http://fivefilters.org/content-only/" rel="noreferrer">http://fivefilters.org/content-only/</a> -- it's a modified version of the <a href="http://lab.arc90.com/2009/03/02/readability/" rel="noreferrer">Readability</a> algorithm, which is designed to extract just the textual content (not headers and footers) from a page. </p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/html-parsing">html-parsing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>For 1a and 2: I would vote for the new Symfony Componet class DOMCrawler ( <a href="http://github.com/symfony/symfony/tree/master/src/Symfony/Component/DomCrawler/" rel="noreferrer">DomCrawler</a> ).
This class allows queries similar to CSS Selectors. Take a look at this presentation for real-world examples: <a href="http://www.slideshare.net/fabpot/news-of-the-symfony2-world" rel="noreferrer">news-of-the-symfony2-world</a>.</p>

<p>The component is designed to work standalone and can be used without Symfony.</p>

<p>The only drawback is that it will only work with PHP 5.3 or newer.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/html-parsing">html-parsing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This is commonly referred to as <strong>screen scraping</strong>, by the way. The library I have used for this is <a href="http://sourceforge.net/projects/simplehtmldom/" rel="noreferrer">Simple HTML Dom Parser</a>.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/html-parsing">html-parsing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>We have created quite a few crawlers for our needs before. At the end of the day, it is usually simple regular expressions that do the thing best. While libraries listed above are good for the reason they are created, if you know what you are looking for, regular expressions is a safer way to go, as you can handle also non-valid <a href="http://en.wikipedia.org/wiki/HTML" rel="noreferrer">HTML</a>/<a href="http://en.wikipedia.org/wiki/XHTML" rel="noreferrer">XHTML</a> structures, which would fail, if loaded via most of the parsers.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/html-parsing">html-parsing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I recommend <a href="http://sourceforge.net/projects/simplehtmldom/">PHP Simple HTML DOM Parser</a>.</p>

<p>It really has nice features, like:</p>

<pre class="default s-code-block"><code class="hljs language-php"><span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$html</span>-&gt;<span class="hljs-title function_ invoke__">find</span>(<span class="hljs-string">'img'</span>) <span class="hljs-keyword">as</span> <span class="hljs-variable">$element</span>)
       <span class="hljs-keyword">echo</span> <span class="hljs-variable">$element</span>-&gt;src . <span class="hljs-string">'&lt;br&gt;'</span>;
</code></pre>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/html-parsing">html-parsing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This sounds like a good task description of W3C <a href="http://www.w3.org/TR/xpath/">XPath</a> technology. It's easy to express queries like "return all <code>href</code> attributes in <code>img</code> tags that are nested in <code>&lt;foo&gt;&lt;bar&gt;&lt;baz&gt; elements</code>." Not being a PHP buff, I can't tell you in what form XPath may be available. If you can call an external program to process the HTML file you should be able to use a command line version of XPath.
For a quick intro, see <a href="http://en.wikipedia.org/wiki/XPath">http://en.wikipedia.org/wiki/XPath</a>.</p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/html-parsing">html-parsing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Third party alternatives to SimpleHtmlDom that use DOM instead of String Parsing: <a href="http://code.google.com/p/phpquery/" rel="noreferrer">phpQuery</a>, <a href="http://framework.zend.com/manual/en/zend.dom.html" rel="noreferrer">Zend_Dom</a>, <a href="http://querypath.org/" rel="noreferrer">QueryPath</a> and <a href="http://www.fluentdom.org/" rel="noreferrer">FluentDom</a>.</p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/html-parsing">html-parsing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Yes you can use simple_html_dom for the purpose. However I have worked quite a lot with the simple_html_dom, particularly for web scraping and have found it to be too vulnerable. It does the basic job but I won't recommend it anyways.</p>
<p>I have never used curl for the purpose but what I have learned is that curl can do the job much more efficiently and is much more solid.</p>
<p>Kindly check out this link:<a href="http://spyderwebtech.wordpress.com/2008/08/07/scraping-websites-with-curl/" rel="nofollow noreferrer">scraping-websites-with-curl</a></p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/html-parsing">html-parsing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><em>QueryPath</em> is good, but be careful of "tracking state" cause if you didn't realise what it means, it can mean you waste a lot of debugging time trying to find out what happened and why the code doesn't work.</p>

<p>What it means is that each call on the result set modifies the result set in the object, it's not chainable like in jquery where each link is a new set, you have a single set which is the results from your query and each function call modifies that single set.</p>

<p>in order to get jquery-like behaviour, you need to branch before you do a filter/modify like operation, that means it'll mirror what happens in jquery much more closely.</p>

<pre class="default s-code-block"><code class="hljs language-bash"><span class="hljs-variable">$results</span> = qp(<span class="hljs-string">"div p"</span>);
<span class="hljs-variable">$forename</span> = <span class="hljs-variable">$results</span>-&gt;find(<span class="hljs-string">"input[name='forename']"</span>);
</code></pre>

<p><code>$results</code> now contains the result set for <code>input[name='forename']</code> NOT the original query <code>"div p"</code> this tripped me up a lot, what I found was that <em>QueryPath</em> tracks the filters and finds and everything which modifies your results and stores them in the object.  you need to do this instead</p>

<pre class="default s-code-block"><code class="hljs language-bash"><span class="hljs-variable">$forename</span> = <span class="hljs-variable">$results</span>-&gt;branch()-&gt;find(<span class="hljs-string">"input[name='forname']"</span>)
</code></pre>

<p>then <code>$results</code> won't be modified and you can reuse the result set again and again, perhaps somebody with much more knowledge can clear this up a bit, but it's basically like this from what I've found.</p>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/html-parsing">html-parsing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><a href="https://github.com/monkeysuffrage/advanced_html_dom" rel="noreferrer">Advanced Html Dom</a> is a simple HTML <a href="http://en.wikipedia.org/wiki/Document_Object_Model" rel="noreferrer">DOM</a> replacement that offers the same interface, but it's DOM-based which means none of the associated memory issues occur.</p>

<p>It also has full CSS support, including <a href="http://en.wikipedia.org/wiki/JQuery" rel="noreferrer">jQuery</a> extensions.</p>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/html-parsing">html-parsing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>For <a href="http://en.wikipedia.org/wiki/HTML5" rel="noreferrer">HTML5</a>, html5 lib has been abandoned for years now. The only HTML5 library I can find with a recent update and maintenance records is <a href="https://github.com/Masterminds/html5-php/releases/1.0.0-beta1" rel="noreferrer">html5-php</a> which was just brought to beta 1.0 a little over a week ago.</p>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 18</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/html-parsing">html-parsing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I created a library named <a href="https://github.com/PHPPowertools/DOM-Query" rel="noreferrer"><strong>PHPPowertools/DOM-Query</strong></a>, which allows you to crawl HTML5 and XML documents just like you do with jQuery.</p>
<p>Under the hood, it uses <a href="https://github.com/symfony/DomCrawler" rel="noreferrer"><strong>symfony/DomCrawler</strong></a> for conversion of CSS selectors to <a href="http://en.wikipedia.org/wiki/XPath" rel="noreferrer">XPath</a> selectors. It always uses the same DomDocument, even when passing one object to another, to ensure decent performance.</p>
<hr>
<h3>Example use :</h3>
<pre class="default s-code-block"><code class="hljs language-php"><span class="hljs-keyword">namespace</span> <span class="hljs-title class_">PowerTools</span>;

<span class="hljs-comment">// Get file content</span>
<span class="hljs-variable">$htmlcode</span> = <span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">'https://github.com'</span>);

<span class="hljs-comment">// Define your DOMCrawler based on file string</span>
<span class="hljs-variable">$H</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DOM_Query</span>(<span class="hljs-variable">$htmlcode</span>);

<span class="hljs-comment">// Define your DOMCrawler based on an existing DOM_Query instance</span>
<span class="hljs-variable">$H</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DOM_Query</span>(<span class="hljs-variable">$H</span>-&gt;<span class="hljs-title function_ invoke__">select</span>(<span class="hljs-string">'body'</span>));

<span class="hljs-comment">// Passing a string (CSS selector)</span>
<span class="hljs-variable">$s</span> = <span class="hljs-variable">$H</span>-&gt;<span class="hljs-title function_ invoke__">select</span>(<span class="hljs-string">'div.foo'</span>);

<span class="hljs-comment">// Passing an element object (DOM Element)</span>
<span class="hljs-variable">$s</span> = <span class="hljs-variable">$H</span>-&gt;<span class="hljs-title function_ invoke__">select</span>(<span class="hljs-variable">$documentBody</span>);

<span class="hljs-comment">// Passing a DOM Query object</span>
<span class="hljs-variable">$s</span> = <span class="hljs-variable">$H</span>-&gt;<span class="hljs-title function_ invoke__">select</span>( <span class="hljs-variable">$H</span>-&gt;<span class="hljs-title function_ invoke__">select</span>(<span class="hljs-string">'p + p'</span>));

<span class="hljs-comment">// Select the body tag</span>
<span class="hljs-variable">$body</span> = <span class="hljs-variable">$H</span>-&gt;<span class="hljs-title function_ invoke__">select</span>(<span class="hljs-string">'body'</span>);

<span class="hljs-comment">// Combine different classes as one selector to get all site blocks</span>
<span class="hljs-variable">$siteblocks</span> = <span class="hljs-variable">$body</span>-&gt;<span class="hljs-title function_ invoke__">select</span>(<span class="hljs-string">'.site-header, .masthead, .site-body, .site-footer'</span>);

<span class="hljs-comment">// Nest your methods just like you would with jQuery</span>
<span class="hljs-variable">$siteblocks</span>-&gt;<span class="hljs-title function_ invoke__">select</span>(<span class="hljs-string">'button'</span>)-&gt;<span class="hljs-title function_ invoke__">add</span>(<span class="hljs-string">'span'</span>)-&gt;<span class="hljs-title function_ invoke__">addClass</span>(<span class="hljs-string">'icon icon-printer'</span>);

<span class="hljs-comment">// Use a lambda function to set the text of all site blocks</span>
<span class="hljs-variable">$siteblocks</span>-&gt;<span class="hljs-title function_ invoke__">text</span>(function( <span class="hljs-variable">$i</span>, <span class="hljs-variable">$val</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable">$i</span> . <span class="hljs-string">" - "</span> . <span class="hljs-variable">$val</span>-&gt;<span class="hljs-title function_ invoke__">attr</span>(<span class="hljs-string">'class'</span>);
});

<span class="hljs-comment">// Append the following HTML to all site blocks</span>
<span class="hljs-variable">$siteblocks</span>-&gt;<span class="hljs-title function_ invoke__">append</span>(<span class="hljs-string">'&lt;div class="site-center"&gt;&lt;/div&gt;'</span>);

<span class="hljs-comment">// Use a descendant selector to select the site's footer</span>
<span class="hljs-variable">$sitefooter</span> = <span class="hljs-variable">$body</span>-&gt;<span class="hljs-title function_ invoke__">select</span>(<span class="hljs-string">'.site-footer &gt; .site-center'</span>);

<span class="hljs-comment">// Set some attributes for the site's footer</span>
<span class="hljs-variable">$sitefooter</span>-&gt;<span class="hljs-title function_ invoke__">attr</span>(<span class="hljs-keyword">array</span>(<span class="hljs-string">'id'</span> =&gt; <span class="hljs-string">'aweeesome'</span>, <span class="hljs-string">'data-val'</span> =&gt; <span class="hljs-string">'see'</span>));

<span class="hljs-comment">// Use a lambda function to set the attributes of all site blocks</span>
<span class="hljs-variable">$siteblocks</span>-&gt;<span class="hljs-title function_ invoke__">attr</span>(<span class="hljs-string">'data-val'</span>, function( <span class="hljs-variable">$i</span>, <span class="hljs-variable">$val</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable">$i</span> . <span class="hljs-string">" - "</span> . <span class="hljs-variable">$val</span>-&gt;<span class="hljs-title function_ invoke__">attr</span>(<span class="hljs-string">'class'</span>) . <span class="hljs-string">" - photo by Kelly Clark"</span>;
});

<span class="hljs-comment">// Select the parent of the site's footer</span>
<span class="hljs-variable">$sitefooterparent</span> = <span class="hljs-variable">$sitefooter</span>-&gt;<span class="hljs-built_in">parent</span>();

<span class="hljs-comment">// Remove the class of all i-tags within the site's footer's parent</span>
<span class="hljs-variable">$sitefooterparent</span>-&gt;<span class="hljs-title function_ invoke__">select</span>(<span class="hljs-string">'i'</span>)-&gt;<span class="hljs-title function_ invoke__">removeAttr</span>(<span class="hljs-string">'class'</span>);

<span class="hljs-comment">// Wrap the site's footer within two nex selectors</span>
<span class="hljs-variable">$sitefooter</span>-&gt;<span class="hljs-title function_ invoke__">wrap</span>(<span class="hljs-string">'&lt;section&gt;&lt;div class="footer-wrapper"&gt;&lt;/div&gt;&lt;/section&gt;'</span>);

[...]
</code></pre>
<hr>
<h3>Supported methods :</h3>
<ul>
<li>[x] <a href="http://api.jquery.com/jQuery/" rel="noreferrer">$</a> <em>(1)</em></li>
<li>[x] <a href="http://api.jquery.com/jQuery.parseHTML/" rel="noreferrer">$.parseHTML</a></li>
<li>[x] <a href="http://api.jquery.com/jQuery.parseXML/" rel="noreferrer">$.parseXML</a></li>
<li>[x] <a href="http://api.jquery.com/jQuery.parseJSON/" rel="noreferrer">$.parseJSON</a></li>
<li>[x] <a href="http://api.jquery.com/add/" rel="noreferrer">$selection.add</a></li>
<li>[x] <a href="http://api.jquery.com/addClass/" rel="noreferrer">$selection.addClass</a></li>
<li>[x] <a href="http://api.jquery.com/after/" rel="noreferrer">$selection.after</a></li>
<li>[x] <a href="http://api.jquery.com/append/" rel="noreferrer">$selection.append</a></li>
<li>[x] <a href="http://api.jquery.com/attr/" rel="noreferrer">$selection.attr</a></li>
<li>[x] <a href="http://api.jquery.com/before/" rel="noreferrer">$selection.before</a></li>
<li>[x] <a href="http://api.jquery.com/children/" rel="noreferrer">$selection.children</a></li>
<li>[x] <a href="http://api.jquery.com/closest/" rel="noreferrer">$selection.closest</a></li>
<li>[x] <a href="http://api.jquery.com/contents/" rel="noreferrer">$selection.contents</a></li>
<li>[x] <a href="http://api.jquery.com/detach/" rel="noreferrer">$selection.detach</a></li>
<li>[x] <a href="http://api.jquery.com/each/" rel="noreferrer">$selection.each</a></li>
<li>[x] <a href="http://api.jquery.com/eq/" rel="noreferrer">$selection.eq</a></li>
<li>[x] <a href="http://api.jquery.com/empty/" rel="noreferrer">$selection.empty</a> <em>(2)</em></li>
<li>[x] <a href="http://api.jquery.com/find/" rel="noreferrer">$selection.find</a></li>
<li>[x] <a href="http://api.jquery.com/first/" rel="noreferrer">$selection.first</a></li>
<li>[x] <a href="http://api.jquery.com/get/" rel="noreferrer">$selection.get</a></li>
<li>[x] <a href="http://api.jquery.com/insertAfter/" rel="noreferrer">$selection.insertAfter</a></li>
<li>[x] <a href="http://api.jquery.com/insertBefore/" rel="noreferrer">$selection.insertBefore</a></li>
<li>[x] <a href="http://api.jquery.com/last/" rel="noreferrer">$selection.last</a></li>
<li>[x] <a href="http://api.jquery.com/parent/" rel="noreferrer">$selection.parent</a></li>
<li>[x] <a href="http://api.jquery.com/parents/" rel="noreferrer">$selection.parents</a></li>
<li>[x] <a href="http://api.jquery.com/remove/" rel="noreferrer">$selection.remove</a></li>
<li>[x] <a href="http://api.jquery.com/removeAttr/" rel="noreferrer">$selection.removeAttr</a></li>
<li>[x] <a href="http://api.jquery.com/removeClass/" rel="noreferrer">$selection.removeClass</a></li>
<li>[x] <a href="http://api.jquery.com/text/" rel="noreferrer">$selection.text</a></li>
<li>[x] <a href="http://api.jquery.com/wrap/" rel="noreferrer">$selection.wrap</a></li>
</ul>
<hr>
<ol>
<li><em>Renamed 'select', for obvious reasons</em></li>
<li><em>Renamed 'void', since 'empty' is a reserved word in PHP</em></li>
</ol>
<hr>
<h3>NOTE :</h3>
<p><em>The library also includes its own zero-configuration autoloader for PSR-0 compatible libraries. The example included should work out of the box without any additional configuration. Alternatively, you can use it with composer.</em></p>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 19</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/html-parsing">html-parsing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You could try using something like <a href="http://en.wikipedia.org/wiki/HTML_Tidy" rel="noreferrer">HTML Tidy</a> to cleanup any "broken" HTML and convert the HTML to XHTML, which you can then parse with a XML parser.</p>
    </div></div></div></div><div id="solution20" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 20</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/html-parsing">html-parsing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I have written a general purpose XML parser that can easily handle GB files. It's based on XMLReader and it's very easy to use:</p>

<pre class="default s-code-block"><code class="hljs language-php"><span class="hljs-variable">$source</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlExtractor</span>(<span class="hljs-string">"path/to/tag"</span>, <span class="hljs-string">"/path/to/file.xml"</span>);
<span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$source</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$tag</span>) {
    <span class="hljs-keyword">echo</span> <span class="hljs-variable">$tag</span>-&gt;field1;
    <span class="hljs-keyword">echo</span> <span class="hljs-variable">$tag</span>-&gt;field2-&gt;subfield1;
}
</code></pre>

<p>Here's the github repo: <a href="https://github.com/pwarelis/XmlExtractor">XmlExtractor</a></p>
    </div></div></div></div><div id="solution21" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 21</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/html-parsing">html-parsing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Another option you can try is <a href="http://querypath.org/" rel="nofollow noreferrer">QueryPath</a>. It's inspired by jQuery, but on the server in PHP and used in <a href="http://en.wikipedia.org/wiki/Drupal" rel="nofollow noreferrer">Drupal</a>.</p>
    </div></div></div></div><div id="solution22" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 22</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/html-parsing">html-parsing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><a href="http://pear.php.net/package/XML_HTMLSax" rel="noreferrer"><code>XML_HTMLSax</code></a> is rather stable - even if it's not maintained any more. Another option could be to pipe you HTML through <a href="http://docs.php.net/manual/en/book.tidy.php" rel="noreferrer">Html Tidy</a> and then parse it with standard XML tools.</p>
    </div></div></div></div><div id="solution23" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 23</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/html-parsing">html-parsing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There are many ways to process HTML/XML DOM of which most have already been mentioned. Hence, I won't make any attempt to list those myself.</p>

<p>I merely want to add that I personally prefer using the DOM extension and why :</p>

<ul>
<li>iit makes optimal use of the performance advantage of the underlying C code</li>
<li>it's OO PHP (and allows me to subclass it)</li>
<li>it's rather low level (which allows me to use it as a non-bloated foundation for more advanced behavior)</li>
<li>it provides access to every part of the DOM (unlike eg. SimpleXml, which ignores some of the lesser known XML features)</li>
<li>it has a syntax used for DOM crawling that's similar to the syntax used in native Javascript.</li>
</ul>

<p>And while I miss the ability to use CSS selectors for <code>DOMDocument</code>, there is a rather simple and convenient way to add this feature: subclassing the <code>DOMDocument</code> and adding JS-like <code>querySelectorAll</code> and <code>querySelector</code> methods to your subclass.</p>

<p>For parsing the selectors, I recommend using the very minimalistic <a href="http://symfony.com/doc/current/components/css_selector.html" rel="noreferrer">CssSelector component</a> from the <a href="http://symfony.com/" rel="noreferrer">Symfony framework</a>. This component just translates CSS selectors to XPath selectors, which can then be fed into a <code>DOMXpath</code> to retrieve the corresponding Nodelist.</p>

<p>You can then use this (still very low level) subclass as a foundation for more high level classes, intended to eg. parse very specific types of XML or add more jQuery-like behavior.</p>

<p>The code below comes straight out my <a href="https://github.com/PHPPowertools/DOM-Query" rel="noreferrer">DOM-Query library</a> and uses the technique I described.</p>

<p>For HTML parsing :</p>

<pre class="default s-code-block"><code class="hljs language-php"><span class="hljs-keyword">namespace</span> <span class="hljs-title class_">PowerTools</span>;

<span class="hljs-keyword">use</span> \<span class="hljs-title">Symfony</span>\<span class="hljs-title">Component</span>\<span class="hljs-title">CssSelector</span>\<span class="hljs-title">CssSelector</span> <span class="hljs-keyword">as</span> <span class="hljs-title">CssSelector</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DOM_Document</span> <span class="hljs-keyword">extends</span> \<span class="hljs-title">DOMDocument</span> </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$data</span> = <span class="hljs-literal">false</span>, <span class="hljs-variable">$doctype</span> = <span class="hljs-string">'html'</span>, <span class="hljs-variable">$encoding</span> = <span class="hljs-string">'UTF-8'</span>, <span class="hljs-variable">$version</span> = <span class="hljs-string">'1.0'</span></span>) </span>{
        <span class="hljs-built_in">parent</span>::<span class="hljs-title function_ invoke__">__construct</span>(<span class="hljs-variable">$version</span>, <span class="hljs-variable">$encoding</span>);
        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$doctype</span> &amp;&amp; <span class="hljs-variable">$doctype</span> === <span class="hljs-string">'html'</span>) {
            @<span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">loadHTML</span>(<span class="hljs-variable">$data</span>);
        } <span class="hljs-keyword">else</span> {
            @<span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">loadXML</span>(<span class="hljs-variable">$data</span>);
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">querySelectorAll</span>(<span class="hljs-params"><span class="hljs-variable">$selector</span>, <span class="hljs-variable">$contextnode</span> = <span class="hljs-literal">null</span></span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable language_">$this</span>-&gt;doctype-&gt;name) &amp;&amp; <span class="hljs-variable language_">$this</span>-&gt;doctype-&gt;name == <span class="hljs-string">'html'</span>) {
            <span class="hljs-title class_">CssSelector</span>::<span class="hljs-title function_ invoke__">enableHtmlExtension</span>();
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-title class_">CssSelector</span>::<span class="hljs-title function_ invoke__">disableHtmlExtension</span>();
        }
        <span class="hljs-variable">$xpath</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">\DOMXpath</span>(<span class="hljs-variable language_">$this</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-variable">$xpath</span>-&gt;<span class="hljs-title function_ invoke__">query</span>(<span class="hljs-title class_">CssSelector</span>::<span class="hljs-title function_ invoke__">toXPath</span>(<span class="hljs-variable">$selector</span>, <span class="hljs-string">'descendant::'</span>), <span class="hljs-variable">$contextnode</span>);
    }

    [...]

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadHTMLFile</span>(<span class="hljs-params"><span class="hljs-variable">$filename</span>, <span class="hljs-variable">$options</span> = <span class="hljs-number">0</span></span>) </span>{
        <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">loadHTML</span>(<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-variable">$filename</span>), <span class="hljs-variable">$options</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadHTML</span>(<span class="hljs-params"><span class="hljs-variable">$source</span>, <span class="hljs-variable">$options</span> = <span class="hljs-number">0</span></span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$source</span> &amp;&amp; <span class="hljs-variable">$source</span> != <span class="hljs-string">''</span>) {
            <span class="hljs-variable">$data</span> = <span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$source</span>);
            <span class="hljs-variable">$html5</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HTML5</span>(<span class="hljs-keyword">array</span>(<span class="hljs-string">'targetDocument'</span> =&gt; <span class="hljs-variable language_">$this</span>, <span class="hljs-string">'disableHtmlNsInDom'</span> =&gt; <span class="hljs-literal">true</span>));
            <span class="hljs-variable">$data_start</span> = <span class="hljs-title function_ invoke__">mb_substr</span>(<span class="hljs-variable">$data</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>);
            <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strpos</span>(<span class="hljs-variable">$data_start</span>, <span class="hljs-string">'&lt;!DOCTYPE '</span>) === <span class="hljs-number">0</span> || <span class="hljs-title function_ invoke__">strpos</span>(<span class="hljs-variable">$data_start</span>, <span class="hljs-string">'&lt;html&gt;'</span>) === <span class="hljs-number">0</span>) {
                <span class="hljs-variable">$html5</span>-&gt;<span class="hljs-title function_ invoke__">loadHTML</span>(<span class="hljs-variable">$data</span>);
            } <span class="hljs-keyword">else</span> {
                @<span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">loadHTML</span>(<span class="hljs-string">'&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="'</span> . <span class="hljs-variable">$encoding</span> . <span class="hljs-string">'" /&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;'</span>);
                <span class="hljs-variable">$t</span> = <span class="hljs-variable">$html5</span>-&gt;<span class="hljs-title function_ invoke__">loadHTMLFragment</span>(<span class="hljs-variable">$data</span>);
                <span class="hljs-variable">$docbody</span> = <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">getElementsByTagName</span>(<span class="hljs-string">'body'</span>)-&gt;<span class="hljs-title function_ invoke__">item</span>(<span class="hljs-number">0</span>);
                <span class="hljs-keyword">while</span> (<span class="hljs-variable">$t</span>-&gt;<span class="hljs-title function_ invoke__">hasChildNodes</span>()) {
                    <span class="hljs-variable">$docbody</span>-&gt;<span class="hljs-title function_ invoke__">appendChild</span>(<span class="hljs-variable">$t</span>-&gt;firstChild);
                }
            }
        }
    }

    [...]
}
</code></pre>

<p>See also <a href="http://fabien.potencier.org/article/42/parsing-xml-documents-with-css-selectors" rel="noreferrer">Parsing XML documents with CSS selectors</a> by Symfony's creator Fabien Potencier on his decision to create the CssSelector component for Symfony and how to use it.</p>
    </div></div></div></div><div id="solution24" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 24</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/html-parsing">html-parsing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The <a href="http://en.wikipedia.org/wiki/Symfony" rel="noreferrer">Symfony</a> framework has bundles which can parse the HTML, and you can use CSS style to select the <a href="http://en.wikipedia.org/wiki/Document_Object_Model" rel="noreferrer">DOMs</a> instead of using <a href="http://en.wikipedia.org/wiki/XPath" rel="noreferrer">XPath</a>.</p>
    </div></div></div></div><div id="solution25" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 25</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/html-parsing">html-parsing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>With <a href="https://github.com/servo-php/fluidxml" rel="noreferrer"><strong>FluidXML</strong></a> you can query and iterate XML using <strong>XPath</strong> and <strong>CSS Selectors</strong>.</p>

<pre class="default s-code-block"><code class="hljs language-perl">$doc = fluidxml(<span class="hljs-string">'&lt;html&gt;...&lt;/html&gt;'</span>);

$title = $doc-&gt;query(<span class="hljs-string">'//head/title'</span>)[<span class="hljs-number">0</span>]-&gt;nodeValue;

$doc-&gt;query(<span class="hljs-string">'//body/p'</span>, <span class="hljs-string">'div.active'</span>, <span class="hljs-string">'#bgId'</span>)
        -&gt;<span class="hljs-keyword">each</span>(function($i, $node) {
            <span class="hljs-regexp">//</span> $node is a DOMNode.
            $tag   = $node-&gt;nodeName;
            $text  = $node-&gt;nodeValue;
            $class = $node-&gt;getAttribute(<span class="hljs-string">'class'</span>);
        });
</code></pre>

<p><a href="https://github.com/servo-php/fluidxml" rel="noreferrer">https://github.com/servo-php/fluidxml</a></p>
    </div></div></div></div><div id="solution26" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 26</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/html-parsing">html-parsing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>JSON and array from XML in three lines:</p>

<pre class="default s-code-block"><code class="hljs language-php"><span class="hljs-variable">$xml</span> = <span class="hljs-title function_ invoke__">simplexml_load_string</span>(<span class="hljs-variable">$xml_string</span>);
<span class="hljs-variable">$json</span> = <span class="hljs-title function_ invoke__">json_encode</span>(<span class="hljs-variable">$xml</span>);
<span class="hljs-variable">$array</span> = <span class="hljs-title function_ invoke__">json_decode</span>(<span class="hljs-variable">$json</span>,<span class="hljs-literal">TRUE</span>);
</code></pre>

<p>Ta da!</p>
    </div></div></div></div><div id="solution27" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 27</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/html-parsing">html-parsing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There are several reasons to not parse HTML by regular expression. But, if you have total control of what HTML will be generated, then you can do with simple regular expression.</p>

<p>Above it's a function that parses HTML by regular expression. Note that this function is very sensitive and demands that the HTML obey certain rules, but it works very well in many scenarios. If you want a simple parser, and don't want to install libraries, give this a shot:</p>

<pre class="default s-code-block"><code class="hljs language-php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">array_combine_</span>(<span class="hljs-params"><span class="hljs-variable">$keys</span>, <span class="hljs-variable">$values</span></span>) </span>{
    <span class="hljs-variable">$result</span> = <span class="hljs-keyword">array</span>();
    <span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$keys</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$i</span> =&gt; <span class="hljs-variable">$k</span>) {
        <span class="hljs-variable">$result</span>[<span class="hljs-variable">$k</span>][] = <span class="hljs-variable">$values</span>[<span class="hljs-variable">$i</span>];
    }
    <span class="hljs-title function_ invoke__">array_walk</span>(<span class="hljs-variable">$result</span>, <span class="hljs-title function_ invoke__">create_function</span>(<span class="hljs-string">'&amp;$v'</span>, <span class="hljs-string">'$v = (count($v) == 1)? array_pop($v): $v;'</span>));

    <span class="hljs-keyword">return</span> <span class="hljs-variable">$result</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extract_data</span>(<span class="hljs-params"><span class="hljs-variable">$str</span></span>) </span>{
    <span class="hljs-keyword">return</span> (<span class="hljs-title function_ invoke__">is_array</span>(<span class="hljs-variable">$str</span>))
        ? <span class="hljs-title function_ invoke__">array_map</span>(<span class="hljs-string">'extract_data'</span>, <span class="hljs-variable">$str</span>)
        : ((!<span class="hljs-title function_ invoke__">preg_match_all</span>(<span class="hljs-string">'#&lt;([A-Za-z0-9_]*)[^&gt;]*&gt;(.*?)&lt;/\1&gt;#s'</span>, <span class="hljs-variable">$str</span>, <span class="hljs-variable">$matches</span>))
            ? <span class="hljs-variable">$str</span>
            : <span class="hljs-title function_ invoke__">array_map</span>((<span class="hljs-string">'extract_data'</span>), <span class="hljs-title function_ invoke__">array_combine_</span>(<span class="hljs-variable">$matches</span>[<span class="hljs-number">1</span>], <span class="hljs-variable">$matches</span>[<span class="hljs-number">2</span>])));
}

<span class="hljs-title function_ invoke__">print_r</span>(<span class="hljs-title function_ invoke__">extract_data</span>(<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">"http://www.google.com/"</span>)));
</code></pre>
    </div></div></div></div><div id="solution28" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 28</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/html-parsing">html-parsing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I've created a library called HTML5DOMDocument that is freely available at <a href="https://github.com/ivopetkov/html5-dom-document-php" rel="nofollow noreferrer">https://github.com/ivopetkov/html5-dom-document-php</a></p>

<p>It supports query selectors too that I think will be extremely helpful in your case. Here is some example code:</p>

<pre class="default s-code-block"><code class="hljs language-xml">$dom = new IvoPetkov\HTML5DOMDocument();
$dom-&gt;loadHTML('<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"content"</span>&gt;</span>This is some text<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>');
echo $dom-&gt;querySelector('h1')-&gt;innerHTML;
</code></pre>
    </div></div></div></div><div id="solution29" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 29</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/html-parsing">html-parsing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The best method for parse xml:</p>

<pre class="default s-code-block"><code class="hljs language-php"><span class="hljs-variable">$xml</span>=<span class="hljs-string">'http://www.example.com/rss.xml'</span>;
<span class="hljs-variable">$rss</span> = <span class="hljs-title function_ invoke__">simplexml_load_string</span>(<span class="hljs-variable">$xml</span>);
<span class="hljs-variable">$i</span> = <span class="hljs-number">0</span>;
<span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$rss</span>-&gt;channel-&gt;item <span class="hljs-keyword">as</span> <span class="hljs-variable">$feedItem</span>) {
  <span class="hljs-variable">$i</span>++;
  <span class="hljs-keyword">echo</span> <span class="hljs-variable">$title</span>=<span class="hljs-variable">$feedItem</span>-&gt;title;
  <span class="hljs-keyword">echo</span> <span class="hljs-string">'&lt;br&gt;'</span>;
  <span class="hljs-keyword">echo</span> <span class="hljs-variable">$link</span>=<span class="hljs-variable">$feedItem</span>-&gt;link;
  <span class="hljs-keyword">echo</span> <span class="hljs-string">'&lt;br&gt;'</span>;
  <span class="hljs-keyword">if</span>(<span class="hljs-variable">$feedItem</span>-&gt;description !=<span class="hljs-string">''</span>) {
    <span class="hljs-variable">$des</span>=<span class="hljs-variable">$feedItem</span>-&gt;description;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-variable">$des</span>=<span class="hljs-string">''</span>;
  }
  <span class="hljs-keyword">echo</span> <span class="hljs-variable">$des</span>;
  <span class="hljs-keyword">echo</span> <span class="hljs-string">'&lt;br&gt;'</span>;
  <span class="hljs-keyword">if</span>(<span class="hljs-variable">$i</span>&gt;<span class="hljs-number">5</span>) <span class="hljs-keyword">break</span>;
}
</code></pre>
    </div></div></div></div><div id="solution30" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 30</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml">xml</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xml-parsing">xml-parsing</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/html-parsing">html-parsing</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you're familiar with jQuery selector, you can use <a href="https://github.com/ScarletsFiction/ScarletsQuery" rel="nofollow noreferrer">ScarletsQuery</a> for PHP</p>

<pre class="default s-code-block"><code class="hljs language-php-template"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span></span><span class="language-php"><span class="hljs-meta">&lt;?php</span>
<span class="hljs-keyword">include</span> <span class="hljs-string">"ScarletsQuery.php"</span>;

<span class="hljs-comment">// Load the HTML content and parse it</span>
<span class="hljs-variable">$html</span> = <span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">'https://www.lipsum.com'</span>);
<span class="hljs-variable">$dom</span> = <span class="hljs-title class_">Scarlets\Library\MarkupLanguage</span>::<span class="hljs-title function_ invoke__">parseText</span>(<span class="hljs-variable">$html</span>);

<span class="hljs-comment">// Select meta tag on the HTML header</span>
<span class="hljs-variable">$description</span> = <span class="hljs-variable">$dom</span>-&gt;<span class="hljs-title function_ invoke__">selector</span>(<span class="hljs-string">'head meta[name="description"]'</span>)[<span class="hljs-number">0</span>];

<span class="hljs-comment">// Get 'content' attribute value from meta tag</span>
<span class="hljs-title function_ invoke__">print_r</span>(<span class="hljs-variable">$description</span>-&gt;<span class="hljs-title function_ invoke__">attr</span>(<span class="hljs-string">'content'</span>));

<span class="hljs-variable">$description</span> = <span class="hljs-variable">$dom</span>-&gt;<span class="hljs-title function_ invoke__">selector</span>(<span class="hljs-string">'#Content p'</span>);

<span class="hljs-comment">// Get element array</span>
<span class="hljs-title function_ invoke__">print_r</span>(<span class="hljs-variable">$description</span>-&gt;view);
</span></code></pre>

<p>This library usually taking less than 1 second to process offline html.<br>
It also accept invalid HTML or missing quote on tag attributes.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/how-do-i-make-a-redirect-in-php-1657387381903">How do I make a redirect in PHP?</a><a href="/questions/selecting-and-manipulating-css-pseudo-elements-such-as-::before-and-::after-using-javascript-(or-jquery)-1657387406132">Selecting and manipulating CSS pseudo-elements such as ::before and ::after using javascript (or jQuery)</a><a href="/questions/split-array-into-chunks-1657387896420">Split array into chunks</a><a href="/questions/how-do-i-set-clear-and-toggle-a-single-bit-1657388227052">How do I set, clear, and toggle a single bit?</a><a href="/questions/how-do-i-generate-random-integers-within-a-specific-range-in-java-1657385458888">How do I generate random integers within a specific range in Java?</a><a href="/questions/the-difference-between-bracket-and-double-bracket-for-accessing-the-elements-of-a-list-or-dataframe-1657388451711">The difference between bracket [ ] and double bracket [[ ]] for accessing the elements of a list or dataframe</a><a href="/questions/why-is-my-spring-@autowired-field-null-1657384705291">Why is my Spring @Autowired field null?</a><a href="/questions/how-to-access-a-local-variable-from-a-different-function-using-pointers-1657388159760">How to access a local variable from a different function using pointers?</a><a href="/questions/correctly-allocating-multi-dimensional-arrays-1657387733756">Correctly allocating multi-dimensional arrays</a><a href="/questions/truth-value-of-a-series-is-ambiguous.-use-a.empty-a.bool()-a.item()-a.any()-or-a.all()-1657387724259">Truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all()</a><a href="/questions/what-is-the-best-regular-expression-to-check-if-a-string-is-a-valid-url-1657387618306">What is the best regular expression to check if a string is a valid URL?</a><a href="/questions/what-does-**-(double-starasterisk)-and-*-(starasterisk)-do-for-parameters-1657384800967">What does ** (double star/asterisk) and * (star/asterisk) do for parameters?</a><a href="/questions/when-should-i-wrap-quotes-around-a-shell-variable-1657384659265">When should I wrap quotes around a shell variable?</a><a href="/questions/what-happens-if-you-use-the-32-bit-int-0x80-linux-abi-in-64-bit-code-1657388560485">What happens if you use the 32-bit int 0x80 Linux ABI in 64-bit code?</a><a href="/questions/the-3-different-equals-1657385490242">The 3 different equals</a><a href="/questions/how-do-i-determine-the-correct-path-for-fxml-files-css-files-images-and-other-resources-needed-by-my-javafx-application-1657388143988">How do I determine the correct path for FXML files, CSS files, Images, and other resources needed by my JavaFX Application?</a><a href="/questions/what-is-move-semantics-1657387702625">What is move semantics?</a><a href="/questions/what-do-&#x27;lazy&#x27;-and-&#x27;greedy&#x27;-mean-in-the-context-of-regular-expressions-1657388200552">What do &#x27;lazy&#x27; and &#x27;greedy&#x27; mean in the context of regular expressions?</a><a href="/questions/what-does-the-comma-operator-do-1657388258021">What does the comma operator , do?</a><a href="/questions/can-you-provide-some-examples-of-why-it-is-hard-to-parse-xml-and-html-with-a-regex-closed-1657388410824">Can you provide some examples of why it is hard to parse XML and HTML with a regex? [closed]</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;h2\u0026gt;Native XML Extensions\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;I prefer using one of the \u0026lt;a href=\u0026quot;https://php.net/manual/en/refs.xml.php\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;native XML extensions\u0026lt;/a\u0026gt; since they come bundled with PHP, are usually faster than all the 3rd party libs and give me all the control I need over the markup.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;\u0026lt;a href=\u0026quot;https://php.net/manual/en/book.dom.php\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;DOM\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;The DOM extension allows you to operate on XML documents through the DOM API with PHP 5. It is an implementation of the W3C\u0026apos;s Document Object Model Core Level 3, a platform- and language-neutral interface that allows programs and scripts to dynamically access and update the content, structure and style of documents.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;DOM is capable of parsing and modifying real world (broken) HTML and it can do \u0026lt;a href=\u0026quot;http://schlitt.info/opensource/blog/0704_xpath.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;XPath queries\u0026lt;/a\u0026gt;. It is based on \u0026lt;a href=\u0026quot;http://xmlsoft.org/html/libxml-HTMLparser.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;libxml\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;It takes some time to get productive with DOM, but that time is well worth it IMO. Since DOM is a language-agnostic interface, you\u0026apos;ll find implementations in many languages, so if you need to change your programming language, chances are you will already know how to use that language\u0026apos;s DOM API then.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;How to use the DOM extension has been \u0026lt;a href=\u0026quot;https://stackoverflow.com/search?q=DOM+HTML+%5BPHP%5D\u0026amp;amp;submit=search\u0026quot;\u0026gt;covered extensively\u0026lt;/a\u0026gt; on StackOverflow, so if you choose to use it, you can be sure most of the issues you run into can be solved by searching/browsing Stack Overflow.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/3820783\u0026quot;\u0026gt;basic usage example\u0026lt;/a\u0026gt; and a \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/4983721\u0026quot;\u0026gt;general conceptual overview\u0026lt;/a\u0026gt; are available in other answers.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;\u0026lt;a href=\u0026quot;https://php.net/manual/en/book.xmlreader.php\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;XMLReader\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;The XMLReader extension is an XML pull parser. The reader acts as a cursor going forward on the document stream and stopping at each node on the way.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;XMLReader, like DOM, is based on libxml. I am not aware of how to trigger the HTML Parser Module, so chances are using XMLReader for parsing broken HTML might be less robust than using DOM where you can explicitly tell it to use libxml\u0026apos;s HTML Parser Module.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/3299140\u0026quot;\u0026gt;basic usage example\u0026lt;/a\u0026gt; is available in another answer.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;\u0026lt;a href=\u0026quot;https://php.net/manual/en/book.xml.php\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;XML Parser\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;This extension lets you create XML parsers and then define handlers for different XML events. Each XML parser also has a few parameters you can adjust.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;The XML Parser library is also based on libxml, and implements a \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Simple_API_for_XML\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;SAX\u0026lt;/a\u0026gt; style XML push parser. It may be a better choice for memory management than DOM or SimpleXML, but will be more difficult to work with than the pull parser implemented by XMLReader.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;\u0026lt;a href=\u0026quot;https://php.net/manual/en/book.simplexml.php\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;SimpleXml\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;The SimpleXML extension provides a very simple and easily usable toolset to convert XML to an object that can be processed with normal property selectors and array iterators.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;SimpleXML is an option when you know the HTML is valid XHTML. If you need to parse broken HTML, don\u0026apos;t even consider SimpleXml because it will choke.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/4906459\u0026quot;\u0026gt;basic usage example\u0026lt;/a\u0026gt; is available, and there are \u0026lt;a href=\u0026quot;https://php.net/manual/en/simplexml.examples-basic.php\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;lots of additional examples in the PHP Manual\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;3rd Party Libraries (libxml based)\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;If you prefer to use a 3rd-party lib, I\u0026apos;d suggest using a lib that actually uses \u0026lt;a href=\u0026quot;http://php.net/manual/en/book.dom.php\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;DOM\u0026lt;/a\u0026gt;/\u0026lt;a href=\u0026quot;http://xmlsoft.org/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;libxml\u0026lt;/a\u0026gt; underneath instead of string parsing.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/ThomasWeinert/FluentDOM\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;FluentDom\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;FluentDOM provides a jQuery-like fluent XML interface for the DOMDocument in PHP. Selectors are written in XPath or CSS (using a CSS to XPath converter). Current versions extend the DOM implementing standard interfaces and add features from the DOM Living Standard. FluentDOM can load formats like JSON, CSV, JsonML, RabbitFish and others. Can be installed via Composer.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;h3\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/wasinger/htmlpagedom\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;HtmlPageDom\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;Wa72\\HtmlPageDom\u0026lt;/code\u0026gt; is a PHP library for easy manipulation of HTML\ndocuments using DOM. It requires \u0026lt;a href=\u0026quot;https://github.com/symfony/DomCrawler\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;DomCrawler from Symfony2\ncomponents\u0026lt;/a\u0026gt; for traversing\nthe DOM tree and extends it by adding methods for manipulating the\nDOM tree of HTML documents.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;h3\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/electrolinux/phpquery\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;phpQuery\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;phpQuery is a server-side, chainable, CSS3 selector driven Document Object Model (DOM) API based on jQuery JavaScript Library.\nThe library is written in PHP5 and provides additional Command Line Interface (CLI).\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;This is described as \u0026quot;abandonware and buggy: use at your own risk\u0026quot; but does appear to be minimally maintained.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;\u0026lt;a href=\u0026quot;https://docs.laminas.dev/laminas-dom/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;laminas-dom\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;The Laminas\\Dom component (formerly Zend_DOM) provides tools for working with DOM documents and structures. Currently, we offer \u0026lt;code\u0026gt;Laminas\\Dom\\Query\u0026lt;/code\u0026gt;, which provides a unified interface for querying DOM documents utilizing both XPath and CSS selectors.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This package is considered feature-complete, and is now in security-only maintenance mode.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;h3\u0026gt;\u0026lt;a href=\u0026quot;http://github.com/theseer/fDOMDocument\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;fDOMDocument\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;fDOMDocument extends the standard DOM to use exceptions at all occasions of errors instead of PHP warnings or notices. They also add various custom methods and shortcuts for convenience and to simplify the usage of DOM.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;h3\u0026gt;\u0026lt;a href=\u0026quot;http://sabre.io/xml/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;sabre/xml\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;sabre/xml is a library that wraps and extends the XMLReader and XMLWriter classes to create a simple \u0026quot;xml to object/array\u0026quot; mapping system and design pattern. Writing and reading XML is single-pass and can therefore be fast and require low memory on large xml files.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;h3\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/servo-php/fluidxml\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;FluidXML\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;FluidXML is a PHP library for manipulating XML with a concise and fluent API.\nIt leverages XPath and the fluent programming pattern to be fun and effective.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;3rd-Party (not libxml-based)\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;The benefit of building upon DOM/libxml is that you get good performance out of the box because you are based on a native extension. However, not all 3rd-party libs go down this route. Some of them listed below\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;\u0026lt;a href=\u0026quot;https://simplehtmldom.sourceforge.io/docs/1.9/index.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;PHP Simple HTML DOM Parser\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;An HTML DOM parser written in PHP5+ lets you manipulate HTML in a very easy way!\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Require PHP 5+.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Supports invalid HTML.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Find tags on an HTML page with selectors just like jQuery.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Extract contents from HTML in a single line.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;I generally do not recommend this parser. The codebase is horrible and the parser itself is rather slow and memory hungry. Not all jQuery Selectors (such as \u0026lt;a href=\u0026quot;https://api.jquery.com/child-selector/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;child selectors\u0026lt;/a\u0026gt;) are possible. Any of the libxml based libraries should outperform this easily.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/paquettg/php-html-parser\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;PHP Html Parser\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;PHPHtmlParser is a simple, flexible, html parser which allows you to select tags using any css selector, like jQuery. The goal is to assiste in the development of tools which require a quick, easy way to scrape html, whether it\u0026apos;s valid or not! This project was original supported by sunra/php-simple-html-dom-parser but the support seems to have stopped so this project is my adaptation of his previous work.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Again, I would not recommend this parser. It is rather slow with high CPU usage. There is also no function to clear memory of created DOM objects. These problems scale particularly with nested loops. The documentation itself is inaccurate and misspelled, with no responses to fixes since 14 Apr 16.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;HTML 5\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;You can use the above for parsing HTML5, but \u0026lt;a href=\u0026quot;https://stackoverflow.com/q/4029341\u0026quot;\u0026gt;there can be quirks\u0026lt;/a\u0026gt; due to the markup HTML5 allows. So for HTML5 you may want to consider using a dedicated parser. Note that these are written in PHP, so suffer from slower performance and increased memory usage compared to a compiled extension in a lower-level language.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/ivopetkov/html5-dom-document-php/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;HTML5DomDocument\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;HTML5DOMDocument extends the native DOMDocument library. It fixes some bugs and adds some new functionality.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Preserves html entities (DOMDocument does not)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Preserves void tags (DOMDocument does not)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Allows inserting HTML code that moves the correct parts to their proper places (head elements are inserted in the head, body elements in the body)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Allows querying the DOM with CSS selectors (currently available: \u0026lt;code\u0026gt;*\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;tagname\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;tagname#id\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;#id\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;tagname.classname\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;.classname\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;tagname.classname.classname2\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;.classname.classname2\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;tagname[attribute-selector]\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;[attribute-selector]\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;div, p\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;div p\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;div \u0026amp;gt; p\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;div + p\u0026lt;/code\u0026gt;, and \u0026lt;code\u0026gt;p ~ ul\u0026lt;/code\u0026gt;.)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Adds support for element-\u0026amp;gt;classList.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Adds support for element-\u0026amp;gt;innerHTML.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Adds support for element-\u0026amp;gt;outerHTML.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;h3\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/Masterminds/html5-php\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;HTML5\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;HTML5 is a standards-compliant HTML5 parser and writer written entirely in PHP. It is stable and used in many production websites, and has well over five million downloads.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;HTML5 provides the following features.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;An HTML5 serializer\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Support for PHP namespaces\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Composer support\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Event-based (SAX-like) parser\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;A DOM tree builder\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Interoperability with QueryPath\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Runs on PHP 5.3.0 or newer\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;Regular Expressions\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Last and \u0026lt;strong\u0026gt;least recommended\u0026lt;/strong\u0026gt;, you can extract data from HTML with \u0026lt;a href=\u0026quot;https://stackoverflow.com/search?q=regular%20expression%20tutorials\u0026quot;\u0026gt;regular expressions\u0026lt;/a\u0026gt;. In general using Regular Expressions on HTML is discouraged.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Most of the snippets you will find on the web to match markup are brittle. In most cases they are only working for a very particular piece of HTML. Tiny markup changes, like adding whitespace somewhere, or adding, or changing attributes in a tag, can make the RegEx fails when it\u0026apos;s not properly written. You should know what you are doing before using RegEx on HTML.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;HTML parsers already know the syntactical rules of HTML. Regular expressions have to be taught for each new RegEx you write. RegEx are fine in some cases, but it really depends on your use-case.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;You \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/4234491\u0026quot;\u0026gt;can write more reliable parsers\u0026lt;/a\u0026gt;, but writing a \u0026lt;em\u0026gt;complete and reliable\u0026lt;/em\u0026gt; custom parser with regular expressions is a waste of time when the aforementioned libraries already exist and do a much better job on this.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Also see \u0026lt;a href=\u0026quot;http://www.codinghorror.com/blog/2009/11/parsing-html-the-cthulhu-way.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Parsing Html The Cthulhu Way\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;Books\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;If you want to spend some money, have a look at\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://www.phparch.com/books/phparchitects-guide-to-web-scraping-with-php\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;PHP Architect\u0026apos;s Guide to Webscraping with PHP\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;I am not affiliated with PHP Architect or the authors.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Try \u0026lt;a href=\u0026quot;https://simplehtmldom.sourceforge.io/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;Simple HTML DOM Parser\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;A HTML DOM parser written in PHP\u0026amp;nbsp;5+ that lets you manipulate HTML in a very easy way!\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Require PHP 5+.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Supports invalid HTML.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Find tags on an HTML page with selectors just like jQuery.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Extract contents from HTML in a single line.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://sourceforge.net/projects/simplehtmldom/files/simplehtmldom/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Download\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Note: as the name suggests, it can be useful for simple tasks. It uses regular expressions instead of an HTML parser, so will be considerably slower for more complex tasks. The bulk of its codebase was written in 2008, with only small improvements made since then. It does not follow modern PHP coding standards and would be challenging to incorporate into a modern PSR-compliant project.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;\u0026lt;a href=\u0026quot;https://simplehtmldom.sourceforge.io/manual.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Examples:\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt;\n\u0026lt;h3\u0026gt;How to get HTML elements:\u0026lt;/h3\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Create DOM from URL or file\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$html\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;file_get_html\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;http://www.example.com/\u0026apos;\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Find all images\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;foreach\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$html\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;img\u0026apos;\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$element\u0026lt;/span\u0026gt;)\n       \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$element\u0026lt;/span\u0026gt;-\u0026amp;gt;src . \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026amp;lt;br\u0026amp;gt;\u0026apos;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Find all links\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;foreach\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$html\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$element\u0026lt;/span\u0026gt;)\n       \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$element\u0026lt;/span\u0026gt;-\u0026amp;gt;href . \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026amp;lt;br\u0026amp;gt;\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h3\u0026gt;How to modify HTML elements:\u0026lt;/h3\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;// Create DOM from string\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$html\u0026lt;/span\u0026gt; = str_get_html(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026amp;lt;div id=\u0026quot;hello\u0026quot;\u0026amp;gt;Hello\u0026amp;lt;/div\u0026amp;gt;\u0026amp;lt;div id=\u0026quot;world\u0026quot;\u0026amp;gt;World\u0026amp;lt;/div\u0026amp;gt;\u0026apos;\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$html\u0026lt;/span\u0026gt;-\u0026amp;gt;find(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;div\u0026apos;\u0026lt;/span\u0026gt;, 1)-\u0026amp;gt;class = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;bar\u0026apos;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$html\u0026lt;/span\u0026gt;-\u0026amp;gt;find(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;div[id=hello]\u0026apos;\u0026lt;/span\u0026gt;, 0)-\u0026amp;gt;innertext = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;foo\u0026apos;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$html\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h3\u0026gt;Extract content from HTML:\u0026lt;/h3\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-lisp\u0026quot;\u0026gt;// Dump contents (\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;without\u0026lt;/span\u0026gt; tags) from HTML\necho file_get_html(\u0026apos;http\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;://www\u0026lt;/span\u0026gt;.google.com/\u0026apos;)-\u0026amp;gt;plaintext\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h3\u0026gt;Scraping Slashdot:\u0026lt;/h3\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Create DOM from URL\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$html\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;file_get_html\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;http://slashdot.org/\u0026apos;\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Find all article blocks\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;foreach\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$html\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;div.article\u0026apos;\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$article\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$item\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;title\u0026apos;\u0026lt;/span\u0026gt;]     = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$article\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;div.title\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)-\u0026amp;gt;plaintext;\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$item\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;intro\u0026apos;\u0026lt;/span\u0026gt;]    = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$article\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;div.intro\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)-\u0026amp;gt;plaintext;\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$item\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;details\u0026apos;\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$article\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;div.details\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)-\u0026amp;gt;plaintext;\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$articles\u0026lt;/span\u0026gt;[] = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$item\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;print_r\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$articles\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Just use \u0026lt;a href=\u0026quot;http://docs.php.net/manual/en/domdocument.loadhtml.php\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;DOMDocument-\u0026amp;gt;loadHTML()\u0026lt;/a\u0026gt; and be done with it. libxml\u0026apos;s HTML parsing algorithm is quite good and fast, and contrary to popular belief, does not choke on malformed HTML.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Why you shouldn\u0026apos;t and \u0026lt;em\u0026gt;when you should\u0026lt;/em\u0026gt; use regular expressions?\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;First off, a common misnomer: Regexps are not for \u0026lt;em\u0026gt;\u0026quot;\u0026lt;strong\u0026gt;parsing\u0026lt;/strong\u0026gt;\u0026quot;\u0026lt;/em\u0026gt; HTML. Regexes can however \u0026lt;em\u0026gt;\u0026quot;\u0026lt;strong\u0026gt;extract\u0026lt;/strong\u0026gt;\u0026quot;\u0026lt;/em\u0026gt; data. Extracting is what they\u0026apos;re made for. The major drawback of regex HTML extraction over proper SGML toolkits or baseline XML parsers are their syntactic effort and varying reliability.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Consider that making a somewhat dependable HTML extraction regex:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;\u0026amp;lt;a\\s+class=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;?playbutton\\d?[^\u0026amp;gt;]+id=\u0026quot;\u0026lt;/span\u0026gt;(\\d+)\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;.+?    \u0026amp;lt;a\\s+class=\u0026quot;\u0026lt;/span\u0026gt;[\\w\\s]*title\n[\\w\\s]*\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;[^\u0026amp;gt;]+href=\u0026quot;\u0026lt;/span\u0026gt;(http://[^\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026amp;gt;]+)\u0026quot;\u0026lt;/span\u0026gt;[^\u0026amp;gt;]*\u0026amp;gt;([^\u0026amp;lt;\u0026amp;gt;]+)\u0026amp;lt;/a\u0026amp;gt;.+?\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;is way less readable than a simple phpQuery or QueryPath equivalent:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-rust\u0026quot;\u0026gt;$div\u0026lt;span class=\u0026quot;hljs-punctuation\u0026quot;\u0026gt;-\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;.stationcool a\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;span class=\u0026quot;hljs-punctuation\u0026quot;\u0026gt;-\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;attr\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;title\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;There are however specific use cases where they can help.\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Many DOM traversal frontends don\u0026apos;t reveal HTML comments \u0026lt;code\u0026gt;\u0026amp;lt;!--\u0026lt;/code\u0026gt;, which however are sometimes the more useful anchors for extraction. In particular pseudo-HTML variations \u0026lt;code\u0026gt;\u0026amp;lt;$var\u0026amp;gt;\u0026lt;/code\u0026gt; or SGML residues are easy to tame with regexps.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Oftentimes regular expressions can save post-processing. However HTML entities often require manual caretaking.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;And lastly, for e\u0026lt;em\u0026gt;xtremely simple tasks\u0026lt;/em\u0026gt; like extracting \u0026amp;lt;img src= urls, they are in fact a probable tool. The speed advantage over SGML/XML parsers mostly just comes to play for these very basic extraction procedures.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;It\u0026apos;s sometimes even advisable to pre-extract a snippet of HTML using regular expressions \u0026lt;code\u0026gt;/\u0026amp;lt;!--CONTENT--\u0026amp;gt;(.+?)\u0026amp;lt;!--END--\u0026amp;gt;/\u0026lt;/code\u0026gt; and process the remainder using the simpler HTML parser frontends.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Note:\u0026lt;/strong\u0026gt; I actually have this \u0026lt;a href=\u0026quot;http://fossil.include-once.org/streamtuner2/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;app\u0026lt;/a\u0026gt;, where I employ XML parsing and regular expressions alternatively. Just last week the PyQuery parsing broke, and the regex still worked. Yes weird, and I can\u0026apos;t explain it myself. But so it happened.\u0026lt;br\u0026gt;\nSo please don\u0026apos;t vote real-world considerations down, just because it doesn\u0026apos;t match the regex=evil meme. \u0026lt;strong\u0026gt;But let\u0026apos;s also not vote this up too much. It\u0026apos;s just a sidenote for this topic.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;Note, this answer recommends libraries that have now been abandoned for 10+ years.\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/TobiaszCudnik/phpquery\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;phpQuery\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;https://github.com/technosophos/querypath\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;QueryPath\u0026lt;/a\u0026gt; are extremely similar in replicating the fluent jQuery API. That\u0026apos;s also why they\u0026apos;re two of the easiest approaches to \u0026lt;em\u0026gt;properly\u0026lt;/em\u0026gt; parse HTML in PHP.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Examples for QueryPath\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Basically you first create a queryable DOM tree from an HTML string:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt; $qp = qp(\u0026quot;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;html\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;body\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;h1\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;title\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;h1\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;...\u0026quot;); // or give filename or URL\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The resulting object contains a complete tree representation of the HTML document. It can be traversed using DOM methods. But the common approach is to use CSS selectors like in jQuery:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$qp\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;div.classname\u0026quot;\u0026lt;/span\u0026gt;)-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;children\u0026lt;/span\u0026gt;()-\u0026amp;gt;...;\n\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;foreach\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$qp\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;p img\u0026quot;\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$img\u0026lt;/span\u0026gt;) {\n     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;qp\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$img\u0026lt;/span\u0026gt;)-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;attr\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;src\u0026quot;\u0026lt;/span\u0026gt;);\n }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Mostly you want to use simple \u0026lt;code\u0026gt;#id\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;.class\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;DIV\u0026lt;/code\u0026gt; tag selectors for \u0026lt;code\u0026gt;-\u0026amp;gt;find()\u0026lt;/code\u0026gt;. But you can also use \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/XPath\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;XPath\u0026lt;/a\u0026gt; statements, which sometimes are faster. Also typical jQuery methods like \u0026lt;code\u0026gt;-\u0026amp;gt;children()\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;-\u0026amp;gt;text()\u0026lt;/code\u0026gt; and particularly \u0026lt;code\u0026gt;-\u0026amp;gt;attr()\u0026lt;/code\u0026gt; simplify extracting the right HTML snippets. (And already have their SGML entities decoded.)\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$qp\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;xpath\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;//div/p[1]\u0026quot;\u0026lt;/span\u0026gt;);  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// get first paragraph in a div\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;QueryPath also allows injecting new tags into the stream (\u0026lt;code\u0026gt;-\u0026amp;gt;append\u0026lt;/code\u0026gt;), and later output and prettify an updated document (\u0026lt;code\u0026gt;-\u0026amp;gt;writeHTML\u0026lt;/code\u0026gt;). It can not only parse malformed HTML, but also various XML dialects (with namespaces), and even extract data from HTML microformats (XFN, vCard).\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-rust\u0026quot;\u0026gt; $qp\u0026lt;span class=\u0026quot;hljs-punctuation\u0026quot;\u0026gt;-\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a[target=_blank]\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;span class=\u0026quot;hljs-punctuation\u0026quot;\u0026gt;-\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;toggleClass\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;usability-blunder\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;phpQuery or QueryPath?\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Generally QueryPath is better suited for manipulation of documents. While phpQuery also implements some pseudo AJAX methods (just HTTP requests) to more closely resemble jQuery. It is said that phpQuery is often faster than QueryPath (because of fewer overall features).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For further information on the differences see \u0026lt;a href=\u0026quot;https://web.archive.org/web/20101230230134/http://www.tagbytag.org/articles/phpquery-vs-querypath\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;this comparison on the wayback machine from tagbyte.org\u0026lt;/a\u0026gt;. (Original source went missing, so here\u0026apos;s an internet archive link. Yes, you can still locate missing pages, people.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Advantages\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Simplicity and Reliability\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Simple to use alternatives \u0026lt;code\u0026gt;-\u0026amp;gt;find(\u0026quot;a img, a object, div a\u0026quot;)\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Proper data unescaping (in comparison to regular expression grepping)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Simple HTML DOM is a great open-source parser:  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://simplehtmldom.sourceforge.net/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;simplehtmldom.sourceforge\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It treats DOM elements in an object-oriented way, and the new iteration has a lot of coverage for non-compliant code. There are also some great functions like you\u0026apos;d see in JavaScript, such as the \u0026quot;find\u0026quot; function, which will return all instances of elements of that tag name.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;ve used this in a number of tools, testing it on many different types of web pages, and I think it works great.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;One general approach I haven\u0026apos;t seen mentioned here is to run HTML through \u0026lt;a href=\u0026quot;http://php.net/manual/en/book.tidy.php\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Tidy\u0026lt;/a\u0026gt;, which can be set to spit out guaranteed-valid XHTML. Then you can use any old XML library on it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But to your specific problem, you should take a look at this project: \u0026lt;a href=\u0026quot;http://fivefilters.org/content-only/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://fivefilters.org/content-only/\u0026lt;/a\u0026gt; -- it\u0026apos;s a modified version of the \u0026lt;a href=\u0026quot;http://lab.arc90.com/2009/03/02/readability/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Readability\u0026lt;/a\u0026gt; algorithm, which is designed to extract just the textual content (not headers and footers) from a page. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;For 1a and 2: I would vote for the new Symfony Componet class DOMCrawler ( \u0026lt;a href=\u0026quot;http://github.com/symfony/symfony/tree/master/src/Symfony/Component/DomCrawler/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;DomCrawler\u0026lt;/a\u0026gt; ).\nThis class allows queries similar to CSS Selectors. Take a look at this presentation for real-world examples: \u0026lt;a href=\u0026quot;http://www.slideshare.net/fabpot/news-of-the-symfony2-world\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;news-of-the-symfony2-world\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The component is designed to work standalone and can be used without Symfony.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The only drawback is that it will only work with PHP 5.3 or newer.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is commonly referred to as \u0026lt;strong\u0026gt;screen scraping\u0026lt;/strong\u0026gt;, by the way. The library I have used for this is \u0026lt;a href=\u0026quot;http://sourceforge.net/projects/simplehtmldom/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Simple HTML Dom Parser\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;We have created quite a few crawlers for our needs before. At the end of the day, it is usually simple regular expressions that do the thing best. While libraries listed above are good for the reason they are created, if you know what you are looking for, regular expressions is a safer way to go, as you can handle also non-valid \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/HTML\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;HTML\u0026lt;/a\u0026gt;/\u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/XHTML\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;XHTML\u0026lt;/a\u0026gt; structures, which would fail, if loaded via most of the parsers.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I recommend \u0026lt;a href=\u0026quot;http://sourceforge.net/projects/simplehtmldom/\u0026quot;\u0026gt;PHP Simple HTML DOM Parser\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It really has nice features, like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;foreach\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$html\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;img\u0026apos;\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$element\u0026lt;/span\u0026gt;)\n       \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$element\u0026lt;/span\u0026gt;-\u0026amp;gt;src . \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026amp;lt;br\u0026amp;gt;\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This sounds like a good task description of W3C \u0026lt;a href=\u0026quot;http://www.w3.org/TR/xpath/\u0026quot;\u0026gt;XPath\u0026lt;/a\u0026gt; technology. It\u0026apos;s easy to express queries like \u0026quot;return all \u0026lt;code\u0026gt;href\u0026lt;/code\u0026gt; attributes in \u0026lt;code\u0026gt;img\u0026lt;/code\u0026gt; tags that are nested in \u0026lt;code\u0026gt;\u0026amp;lt;foo\u0026amp;gt;\u0026amp;lt;bar\u0026amp;gt;\u0026amp;lt;baz\u0026amp;gt; elements\u0026lt;/code\u0026gt;.\u0026quot; Not being a PHP buff, I can\u0026apos;t tell you in what form XPath may be available. If you can call an external program to process the HTML file you should be able to use a command line version of XPath.\nFor a quick intro, see \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/XPath\u0026quot;\u0026gt;http://en.wikipedia.org/wiki/XPath\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Third party alternatives to SimpleHtmlDom that use DOM instead of String Parsing: \u0026lt;a href=\u0026quot;http://code.google.com/p/phpquery/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;phpQuery\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;http://framework.zend.com/manual/en/zend.dom.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Zend_Dom\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;http://querypath.org/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;QueryPath\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;http://www.fluentdom.org/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;FluentDom\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Yes you can use simple_html_dom for the purpose. However I have worked quite a lot with the simple_html_dom, particularly for web scraping and have found it to be too vulnerable. It does the basic job but I won\u0026apos;t recommend it anyways.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I have never used curl for the purpose but what I have learned is that curl can do the job much more efficiently and is much more solid.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Kindly check out this link:\u0026lt;a href=\u0026quot;http://spyderwebtech.wordpress.com/2008/08/07/scraping-websites-with-curl/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;scraping-websites-with-curl\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;QueryPath\u0026lt;/em\u0026gt; is good, but be careful of \u0026quot;tracking state\u0026quot; cause if you didn\u0026apos;t realise what it means, it can mean you waste a lot of debugging time trying to find out what happened and why the code doesn\u0026apos;t work.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;What it means is that each call on the result set modifies the result set in the object, it\u0026apos;s not chainable like in jquery where each link is a new set, you have a single set which is the results from your query and each function call modifies that single set.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;in order to get jquery-like behaviour, you need to branch before you do a filter/modify like operation, that means it\u0026apos;ll mirror what happens in jquery much more closely.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$results\u0026lt;/span\u0026gt; = qp(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;div p\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$forename\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$results\u0026lt;/span\u0026gt;-\u0026amp;gt;find(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;input[name=\u0026apos;forename\u0026apos;]\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;$results\u0026lt;/code\u0026gt; now contains the result set for \u0026lt;code\u0026gt;input[name=\u0026apos;forename\u0026apos;]\u0026lt;/code\u0026gt; NOT the original query \u0026lt;code\u0026gt;\u0026quot;div p\u0026quot;\u0026lt;/code\u0026gt; this tripped me up a lot, what I found was that \u0026lt;em\u0026gt;QueryPath\u0026lt;/em\u0026gt; tracks the filters and finds and everything which modifies your results and stores them in the object.  you need to do this instead\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$forename\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$results\u0026lt;/span\u0026gt;-\u0026amp;gt;branch()-\u0026amp;gt;find(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;input[name=\u0026apos;forname\u0026apos;]\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;then \u0026lt;code\u0026gt;$results\u0026lt;/code\u0026gt; won\u0026apos;t be modified and you can reuse the result set again and again, perhaps somebody with much more knowledge can clear this up a bit, but it\u0026apos;s basically like this from what I\u0026apos;ve found.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/monkeysuffrage/advanced_html_dom\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Advanced Html Dom\u0026lt;/a\u0026gt; is a simple HTML \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Document_Object_Model\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;DOM\u0026lt;/a\u0026gt; replacement that offers the same interface, but it\u0026apos;s DOM-based which means none of the associated memory issues occur.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It also has full CSS support, including \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/JQuery\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;jQuery\u0026lt;/a\u0026gt; extensions.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;For \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/HTML5\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;HTML5\u0026lt;/a\u0026gt;, html5 lib has been abandoned for years now. The only HTML5 library I can find with a recent update and maintenance records is \u0026lt;a href=\u0026quot;https://github.com/Masterminds/html5-php/releases/1.0.0-beta1\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;html5-php\u0026lt;/a\u0026gt; which was just brought to beta 1.0 a little over a week ago.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I created a library named \u0026lt;a href=\u0026quot;https://github.com/PHPPowertools/DOM-Query\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;PHPPowertools/DOM-Query\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt;, which allows you to crawl HTML5 and XML documents just like you do with jQuery.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Under the hood, it uses \u0026lt;a href=\u0026quot;https://github.com/symfony/DomCrawler\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;symfony/DomCrawler\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt; for conversion of CSS selectors to \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/XPath\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;XPath\u0026lt;/a\u0026gt; selectors. It always uses the same DomDocument, even when passing one object to another, to ensure decent performance.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;Example use :\u0026lt;/h3\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;PowerTools\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Get file content\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$htmlcode\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;file_get_contents\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;https://github.com\u0026apos;\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Define your DOMCrawler based on file string\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$H\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;DOM_Query\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$htmlcode\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Define your DOMCrawler based on an existing DOM_Query instance\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$H\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;DOM_Query\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$H\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;select\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;body\u0026apos;\u0026lt;/span\u0026gt;));\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Passing a string (CSS selector)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$s\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$H\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;select\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;div.foo\u0026apos;\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Passing an element object (DOM Element)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$s\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$H\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;select\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$documentBody\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Passing a DOM Query object\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$s\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$H\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;select\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$H\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;select\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;p + p\u0026apos;\u0026lt;/span\u0026gt;));\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Select the body tag\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$body\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$H\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;select\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;body\u0026apos;\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Combine different classes as one selector to get all site blocks\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$siteblocks\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$body\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;select\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;.site-header, .masthead, .site-body, .site-footer\u0026apos;\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Nest your methods just like you would with jQuery\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$siteblocks\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;select\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;button\u0026apos;\u0026lt;/span\u0026gt;)-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;add\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;span\u0026apos;\u0026lt;/span\u0026gt;)-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;addClass\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;icon icon-printer\u0026apos;\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Use a lambda function to set the text of all site blocks\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$siteblocks\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;text\u0026lt;/span\u0026gt;(function( \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$i\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$val\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$i\u0026lt;/span\u0026gt; . \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; - \u0026quot;\u0026lt;/span\u0026gt; . \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$val\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;attr\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;class\u0026apos;\u0026lt;/span\u0026gt;);\n});\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Append the following HTML to all site blocks\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$siteblocks\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;append\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026amp;lt;div class=\u0026quot;site-center\u0026quot;\u0026amp;gt;\u0026amp;lt;/div\u0026amp;gt;\u0026apos;\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Use a descendant selector to select the site\u0026apos;s footer\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$sitefooter\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$body\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;select\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;.site-footer \u0026amp;gt; .site-center\u0026apos;\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Set some attributes for the site\u0026apos;s footer\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$sitefooter\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;attr\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;array\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;id\u0026apos;\u0026lt;/span\u0026gt; =\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;aweeesome\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;data-val\u0026apos;\u0026lt;/span\u0026gt; =\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;see\u0026apos;\u0026lt;/span\u0026gt;));\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Use a lambda function to set the attributes of all site blocks\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$siteblocks\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;attr\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;data-val\u0026apos;\u0026lt;/span\u0026gt;, function( \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$i\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$val\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$i\u0026lt;/span\u0026gt; . \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; - \u0026quot;\u0026lt;/span\u0026gt; . \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$val\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;attr\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;class\u0026apos;\u0026lt;/span\u0026gt;) . \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; - photo by Kelly Clark\u0026quot;\u0026lt;/span\u0026gt;;\n});\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Select the parent of the site\u0026apos;s footer\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$sitefooterparent\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$sitefooter\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;parent\u0026lt;/span\u0026gt;();\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Remove the class of all i-tags within the site\u0026apos;s footer\u0026apos;s parent\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$sitefooterparent\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;select\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;i\u0026apos;\u0026lt;/span\u0026gt;)-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;removeAttr\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;class\u0026apos;\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Wrap the site\u0026apos;s footer within two nex selectors\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$sitefooter\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;wrap\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026amp;lt;section\u0026amp;gt;\u0026amp;lt;div class=\u0026quot;footer-wrapper\u0026quot;\u0026amp;gt;\u0026amp;lt;/div\u0026amp;gt;\u0026amp;lt;/section\u0026amp;gt;\u0026apos;\u0026lt;/span\u0026gt;);\n\n[...]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;Supported methods :\u0026lt;/h3\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;[x] \u0026lt;a href=\u0026quot;http://api.jquery.com/jQuery/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;$\u0026lt;/a\u0026gt; \u0026lt;em\u0026gt;(1)\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[x] \u0026lt;a href=\u0026quot;http://api.jquery.com/jQuery.parseHTML/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;$.parseHTML\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[x] \u0026lt;a href=\u0026quot;http://api.jquery.com/jQuery.parseXML/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;$.parseXML\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[x] \u0026lt;a href=\u0026quot;http://api.jquery.com/jQuery.parseJSON/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;$.parseJSON\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[x] \u0026lt;a href=\u0026quot;http://api.jquery.com/add/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;$selection.add\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[x] \u0026lt;a href=\u0026quot;http://api.jquery.com/addClass/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;$selection.addClass\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[x] \u0026lt;a href=\u0026quot;http://api.jquery.com/after/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;$selection.after\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[x] \u0026lt;a href=\u0026quot;http://api.jquery.com/append/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;$selection.append\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[x] \u0026lt;a href=\u0026quot;http://api.jquery.com/attr/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;$selection.attr\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[x] \u0026lt;a href=\u0026quot;http://api.jquery.com/before/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;$selection.before\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[x] \u0026lt;a href=\u0026quot;http://api.jquery.com/children/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;$selection.children\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[x] \u0026lt;a href=\u0026quot;http://api.jquery.com/closest/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;$selection.closest\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[x] \u0026lt;a href=\u0026quot;http://api.jquery.com/contents/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;$selection.contents\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[x] \u0026lt;a href=\u0026quot;http://api.jquery.com/detach/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;$selection.detach\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[x] \u0026lt;a href=\u0026quot;http://api.jquery.com/each/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;$selection.each\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[x] \u0026lt;a href=\u0026quot;http://api.jquery.com/eq/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;$selection.eq\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[x] \u0026lt;a href=\u0026quot;http://api.jquery.com/empty/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;$selection.empty\u0026lt;/a\u0026gt; \u0026lt;em\u0026gt;(2)\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[x] \u0026lt;a href=\u0026quot;http://api.jquery.com/find/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;$selection.find\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[x] \u0026lt;a href=\u0026quot;http://api.jquery.com/first/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;$selection.first\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[x] \u0026lt;a href=\u0026quot;http://api.jquery.com/get/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;$selection.get\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[x] \u0026lt;a href=\u0026quot;http://api.jquery.com/insertAfter/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;$selection.insertAfter\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[x] \u0026lt;a href=\u0026quot;http://api.jquery.com/insertBefore/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;$selection.insertBefore\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[x] \u0026lt;a href=\u0026quot;http://api.jquery.com/last/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;$selection.last\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[x] \u0026lt;a href=\u0026quot;http://api.jquery.com/parent/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;$selection.parent\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[x] \u0026lt;a href=\u0026quot;http://api.jquery.com/parents/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;$selection.parents\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[x] \u0026lt;a href=\u0026quot;http://api.jquery.com/remove/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;$selection.remove\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[x] \u0026lt;a href=\u0026quot;http://api.jquery.com/removeAttr/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;$selection.removeAttr\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[x] \u0026lt;a href=\u0026quot;http://api.jquery.com/removeClass/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;$selection.removeClass\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[x] \u0026lt;a href=\u0026quot;http://api.jquery.com/text/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;$selection.text\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;[x] \u0026lt;a href=\u0026quot;http://api.jquery.com/wrap/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;$selection.wrap\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;em\u0026gt;Renamed \u0026apos;select\u0026apos;, for obvious reasons\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;em\u0026gt;Renamed \u0026apos;void\u0026apos;, since \u0026apos;empty\u0026apos; is a reserved word in PHP\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;NOTE :\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;The library also includes its own zero-configuration autoloader for PSR-0 compatible libraries. The example included should work out of the box without any additional configuration. Alternatively, you can use it with composer.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You could try using something like \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/HTML_Tidy\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;HTML Tidy\u0026lt;/a\u0026gt; to cleanup any \u0026quot;broken\u0026quot; HTML and convert the HTML to XHTML, which you can then parse with a XML parser.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I have written a general purpose XML parser that can easily handle GB files. It\u0026apos;s based on XMLReader and it\u0026apos;s very easy to use:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$source\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;XmlExtractor\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;path/to/tag\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/path/to/file.xml\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;foreach\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$source\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$tag\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$tag\u0026lt;/span\u0026gt;-\u0026amp;gt;field1;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$tag\u0026lt;/span\u0026gt;-\u0026amp;gt;field2-\u0026amp;gt;subfield1;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here\u0026apos;s the github repo: \u0026lt;a href=\u0026quot;https://github.com/pwarelis/XmlExtractor\u0026quot;\u0026gt;XmlExtractor\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Another option you can try is \u0026lt;a href=\u0026quot;http://querypath.org/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;QueryPath\u0026lt;/a\u0026gt;. It\u0026apos;s inspired by jQuery, but on the server in PHP and used in \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Drupal\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Drupal\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://pear.php.net/package/XML_HTMLSax\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;XML_HTMLSax\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; is rather stable - even if it\u0026apos;s not maintained any more. Another option could be to pipe you HTML through \u0026lt;a href=\u0026quot;http://docs.php.net/manual/en/book.tidy.php\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Html Tidy\u0026lt;/a\u0026gt; and then parse it with standard XML tools.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are many ways to process HTML/XML DOM of which most have already been mentioned. Hence, I won\u0026apos;t make any attempt to list those myself.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I merely want to add that I personally prefer using the DOM extension and why :\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;iit makes optimal use of the performance advantage of the underlying C code\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;it\u0026apos;s OO PHP (and allows me to subclass it)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;it\u0026apos;s rather low level (which allows me to use it as a non-bloated foundation for more advanced behavior)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;it provides access to every part of the DOM (unlike eg. SimpleXml, which ignores some of the lesser known XML features)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;it has a syntax used for DOM crawling that\u0026apos;s similar to the syntax used in native Javascript.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;And while I miss the ability to use CSS selectors for \u0026lt;code\u0026gt;DOMDocument\u0026lt;/code\u0026gt;, there is a rather simple and convenient way to add this feature: subclassing the \u0026lt;code\u0026gt;DOMDocument\u0026lt;/code\u0026gt; and adding JS-like \u0026lt;code\u0026gt;querySelectorAll\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;querySelector\u0026lt;/code\u0026gt; methods to your subclass.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For parsing the selectors, I recommend using the very minimalistic \u0026lt;a href=\u0026quot;http://symfony.com/doc/current/components/css_selector.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;CssSelector component\u0026lt;/a\u0026gt; from the \u0026lt;a href=\u0026quot;http://symfony.com/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Symfony framework\u0026lt;/a\u0026gt;. This component just translates CSS selectors to XPath selectors, which can then be fed into a \u0026lt;code\u0026gt;DOMXpath\u0026lt;/code\u0026gt; to retrieve the corresponding Nodelist.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can then use this (still very low level) subclass as a foundation for more high level classes, intended to eg. parse very specific types of XML or add more jQuery-like behavior.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The code below comes straight out my \u0026lt;a href=\u0026quot;https://github.com/PHPPowertools/DOM-Query\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;DOM-Query library\u0026lt;/a\u0026gt; and uses the technique I described.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For HTML parsing :\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;PowerTools\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;use\u0026lt;/span\u0026gt; \\\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Symfony\u0026lt;/span\u0026gt;\\\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Component\u0026lt;/span\u0026gt;\\\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;CssSelector\u0026lt;/span\u0026gt;\\\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;CssSelector\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;CssSelector\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-class\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;DOM_Document\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \\\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;DOMDocument\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;__construct\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$data\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$doctype\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;html\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$encoding\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;UTF-8\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$version\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;1.0\u0026apos;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;) \u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;parent\u0026lt;/span\u0026gt;::\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;__construct\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$version\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$encoding\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$doctype\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$doctype\u0026lt;/span\u0026gt; === \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;html\u0026apos;\u0026lt;/span\u0026gt;) {\n            @\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;$this\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;loadHTML\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$data\u0026lt;/span\u0026gt;);\n        } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n            @\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;$this\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;loadXML\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$data\u0026lt;/span\u0026gt;);\n        }\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;querySelectorAll\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$selector\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$contextnode\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;) \u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;isset\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;$this\u0026lt;/span\u0026gt;-\u0026amp;gt;doctype-\u0026amp;gt;name) \u0026amp;amp;\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;$this\u0026lt;/span\u0026gt;-\u0026amp;gt;doctype-\u0026amp;gt;name == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;html\u0026apos;\u0026lt;/span\u0026gt;) {\n            \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;CssSelector\u0026lt;/span\u0026gt;::\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;enableHtmlExtension\u0026lt;/span\u0026gt;();\n        } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n            \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;CssSelector\u0026lt;/span\u0026gt;::\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;disableHtmlExtension\u0026lt;/span\u0026gt;();\n        }\n        \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$xpath\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;\\DOMXpath\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;$this\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$xpath\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;query\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;CssSelector\u0026lt;/span\u0026gt;::\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;toXPath\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$selector\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;descendant::\u0026apos;\u0026lt;/span\u0026gt;), \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$contextnode\u0026lt;/span\u0026gt;);\n    }\n\n    [...]\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;loadHTMLFile\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$filename\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$options\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;) \u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;$this\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;loadHTML\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;file_get_contents\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$filename\u0026lt;/span\u0026gt;), \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$options\u0026lt;/span\u0026gt;);\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;loadHTML\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$source\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$options\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;) \u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$source\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$source\u0026lt;/span\u0026gt; != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026apos;\u0026lt;/span\u0026gt;) {\n            \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$data\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;trim\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$source\u0026lt;/span\u0026gt;);\n            \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$html5\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;HTML5\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;array\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;targetDocument\u0026apos;\u0026lt;/span\u0026gt; =\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;$this\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;disableHtmlNsInDom\u0026apos;\u0026lt;/span\u0026gt; =\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;));\n            \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$data_start\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;mb_substr\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$data\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;);\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;strpos\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$data_start\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026amp;lt;!DOCTYPE \u0026apos;\u0026lt;/span\u0026gt;) === \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; || \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;strpos\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$data_start\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026amp;lt;html\u0026amp;gt;\u0026apos;\u0026lt;/span\u0026gt;) === \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) {\n                \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$html5\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;loadHTML\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$data\u0026lt;/span\u0026gt;);\n            } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n                @\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;$this\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;loadHTML\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026amp;lt;!DOCTYPE html\u0026amp;gt;\u0026amp;lt;html\u0026amp;gt;\u0026amp;lt;head\u0026amp;gt;\u0026amp;lt;meta charset=\u0026quot;\u0026apos;\u0026lt;/span\u0026gt; . \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$encoding\u0026lt;/span\u0026gt; . \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot; /\u0026amp;gt;\u0026amp;lt;/head\u0026amp;gt;\u0026amp;lt;body\u0026amp;gt;\u0026amp;lt;/body\u0026amp;gt;\u0026amp;lt;/html\u0026amp;gt;\u0026apos;\u0026lt;/span\u0026gt;);\n                \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$t\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$html5\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;loadHTMLFragment\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$data\u0026lt;/span\u0026gt;);\n                \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$docbody\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;$this\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;getElementsByTagName\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;body\u0026apos;\u0026lt;/span\u0026gt;)-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;item\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$t\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;hasChildNodes\u0026lt;/span\u0026gt;()) {\n                    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$docbody\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;appendChild\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$t\u0026lt;/span\u0026gt;-\u0026amp;gt;firstChild);\n                }\n            }\n        }\n    }\n\n    [...]\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;See also \u0026lt;a href=\u0026quot;http://fabien.potencier.org/article/42/parsing-xml-documents-with-css-selectors\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Parsing XML documents with CSS selectors\u0026lt;/a\u0026gt; by Symfony\u0026apos;s creator Fabien Potencier on his decision to create the CssSelector component for Symfony and how to use it.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Symfony\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Symfony\u0026lt;/a\u0026gt; framework has bundles which can parse the HTML, and you can use CSS style to select the \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Document_Object_Model\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;DOMs\u0026lt;/a\u0026gt; instead of using \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/XPath\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;XPath\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;With \u0026lt;a href=\u0026quot;https://github.com/servo-php/fluidxml\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;FluidXML\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt; you can query and iterate XML using \u0026lt;strong\u0026gt;XPath\u0026lt;/strong\u0026gt; and \u0026lt;strong\u0026gt;CSS Selectors\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-perl\u0026quot;\u0026gt;$doc = fluidxml(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026amp;lt;html\u0026amp;gt;...\u0026amp;lt;/html\u0026amp;gt;\u0026apos;\u0026lt;/span\u0026gt;);\n\n$title = $doc-\u0026amp;gt;query(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;//head/title\u0026apos;\u0026lt;/span\u0026gt;)[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]-\u0026amp;gt;nodeValue;\n\n$doc-\u0026amp;gt;query(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;//body/p\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;div.active\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;#bgId\u0026apos;\u0026lt;/span\u0026gt;)\n        -\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;each\u0026lt;/span\u0026gt;(function($i, $node) {\n            \u0026lt;span class=\u0026quot;hljs-regexp\u0026quot;\u0026gt;//\u0026lt;/span\u0026gt; $node is a DOMNode.\n            $tag   = $node-\u0026amp;gt;nodeName;\n            $text  = $node-\u0026amp;gt;nodeValue;\n            $class = $node-\u0026amp;gt;getAttribute(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;class\u0026apos;\u0026lt;/span\u0026gt;);\n        });\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/servo-php/fluidxml\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://github.com/servo-php/fluidxml\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;JSON and array from XML in three lines:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$xml\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;simplexml_load_string\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$xml_string\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$json\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;json_encode\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$xml\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$array\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;json_decode\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$json\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;TRUE\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Ta da!\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are several reasons to not parse HTML by regular expression. But, if you have total control of what HTML will be generated, then you can do with simple regular expression.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Above it\u0026apos;s a function that parses HTML by regular expression. Note that this function is very sensitive and demands that the HTML obey certain rules, but it works very well in many scenarios. If you want a simple parser, and don\u0026apos;t want to install libraries, give this a shot:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;array_combine_\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$keys\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$values\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;) \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$result\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;array\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;foreach\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$keys\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$i\u0026lt;/span\u0026gt; =\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$k\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$result\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$k\u0026lt;/span\u0026gt;][] = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$values\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$i\u0026lt;/span\u0026gt;];\n    }\n    \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;array_walk\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$result\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;create_function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026amp;amp;$v\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;$v = (count($v) == 1)? array_pop($v): $v;\u0026apos;\u0026lt;/span\u0026gt;));\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$result\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;extract_data\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$str\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;) \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;is_array\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$str\u0026lt;/span\u0026gt;))\n        ? \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;array_map\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;extract_data\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$str\u0026lt;/span\u0026gt;)\n        : ((!\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;preg_match_all\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;#\u0026amp;lt;([A-Za-z0-9_]*)[^\u0026amp;gt;]*\u0026amp;gt;(.*?)\u0026amp;lt;/\\1\u0026amp;gt;#s\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$str\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$matches\u0026lt;/span\u0026gt;))\n            ? \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$str\u0026lt;/span\u0026gt;\n            : \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;array_map\u0026lt;/span\u0026gt;((\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;extract_data\u0026apos;\u0026lt;/span\u0026gt;), \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;array_combine_\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$matches\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;], \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$matches\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;])));\n}\n\n\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;print_r\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;extract_data\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;file_get_contents\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;http://www.google.com/\u0026quot;\u0026lt;/span\u0026gt;)));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I\u0026apos;ve created a library called HTML5DOMDocument that is freely available at \u0026lt;a href=\u0026quot;https://github.com/ivopetkov/html5-dom-document-php\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://github.com/ivopetkov/html5-dom-document-php\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It supports query selectors too that I think will be extremely helpful in your case. Here is some example code:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;$dom = new IvoPetkov\\HTML5DOMDocument();\n$dom-\u0026amp;gt;loadHTML(\u0026apos;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;lt;!DOCTYPE \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;html\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;html\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;body\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;h1\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;Hello\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;h1\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;content\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;This is some text\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;body\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;html\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026apos;);\necho $dom-\u0026amp;gt;querySelector(\u0026apos;h1\u0026apos;)-\u0026amp;gt;innerHTML;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The best method for parse xml:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$xml\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;http://www.example.com/rss.xml\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$rss\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;simplexml_load_string\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$xml\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$i\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;foreach\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$rss\u0026lt;/span\u0026gt;-\u0026amp;gt;channel-\u0026amp;gt;item \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$feedItem\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$i\u0026lt;/span\u0026gt;++;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$title\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$feedItem\u0026lt;/span\u0026gt;-\u0026amp;gt;title;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026amp;lt;br\u0026amp;gt;\u0026apos;\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$link\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$feedItem\u0026lt;/span\u0026gt;-\u0026amp;gt;link;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026amp;lt;br\u0026amp;gt;\u0026apos;\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$feedItem\u0026lt;/span\u0026gt;-\u0026amp;gt;description !=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026apos;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$des\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$feedItem\u0026lt;/span\u0026gt;-\u0026amp;gt;description;\n  } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$des\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026apos;\u0026lt;/span\u0026gt;;\n  }\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$des\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026amp;lt;br\u0026amp;gt;\u0026apos;\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$i\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you\u0026apos;re familiar with jQuery selector, you can use \u0026lt;a href=\u0026quot;https://github.com/ScarletsFiction/ScarletsQuery\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;ScarletsQuery\u0026lt;/a\u0026gt; for PHP\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php-template\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;pre\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;lt;?php\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;ScarletsQuery.php\u0026quot;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Load the HTML content and parse it\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$html\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;file_get_contents\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;https://www.lipsum.com\u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$dom\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Scarlets\\Library\\MarkupLanguage\u0026lt;/span\u0026gt;::\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;parseText\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$html\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Select meta tag on the HTML header\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$description\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$dom\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;selector\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;head meta[name=\u0026quot;description\u0026quot;]\u0026apos;\u0026lt;/span\u0026gt;)[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;];\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Get \u0026apos;content\u0026apos; attribute value from meta tag\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;print_r\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$description\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;attr\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;content\u0026apos;\u0026lt;/span\u0026gt;));\n\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$description\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$dom\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;selector\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;#Content p\u0026apos;\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Get element array\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;print_r\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$description\u0026lt;/span\u0026gt;-\u0026amp;gt;view);\n\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This library usually taking less than 1 second to process offline html.\u0026lt;br\u0026gt;\nIt also accept invalid HTML or missing quote on tag attributes.\u0026lt;/p\u0026gt;\n    "],"id":33,"title":"How do you parse and process HTML/XML in PHP?","content":"\n                \n\u0026lt;p\u0026gt;How can one parse HTML/XML and extract information from it?\u0026lt;/p\u0026gt;\n    ","slug":"how-do-you-parse-and-process-htmlxml-in-php-1657384351267","postType":"QUESTION","createdAt":"2022-07-09T16:32:31.000Z","updatedAt":"2022-07-09T16:32:31.000Z","tags":[{"id":114,"name":"xml","slug":"xml","createdAt":"2022-07-09T16:32:31.000Z","updatedAt":"2022-07-09T16:32:31.000Z","Questions_Tags":{"questionId":33,"tagId":114}},{"id":115,"name":"xml-parsing","slug":"xml-parsing","createdAt":"2022-07-09T16:32:31.000Z","updatedAt":"2022-07-09T16:32:31.000Z","Questions_Tags":{"questionId":33,"tagId":115}},{"id":116,"name":"html-parsing","slug":"html-parsing","createdAt":"2022-07-09T16:32:31.000Z","updatedAt":"2022-07-09T16:32:31.000Z","Questions_Tags":{"questionId":33,"tagId":116}}],"relatedQuestions":[{"title":"How do you parse and process HTML/XML in PHP?","slug":"how-do-you-parse-and-process-htmlxml-in-php-1657384351267","tags":[{"name":"xml","Questions_Tags":{"questionId":33,"tagId":114}},{"name":"xml-parsing","Questions_Tags":{"questionId":33,"tagId":115}},{"name":"html-parsing","Questions_Tags":{"questionId":33,"tagId":116}}]}]},"randomQuestions":[{"title":"How do I make a redirect in PHP?","slug":"how-do-i-make-a-redirect-in-php-1657387381903"},{"title":"Selecting and manipulating CSS pseudo-elements such as ::before and ::after using javascript (or jQuery)","slug":"selecting-and-manipulating-css-pseudo-elements-such-as-::before-and-::after-using-javascript-(or-jquery)-1657387406132"},{"title":"Split array into chunks","slug":"split-array-into-chunks-1657387896420"},{"title":"How do I set, clear, and toggle a single bit?","slug":"how-do-i-set-clear-and-toggle-a-single-bit-1657388227052"},{"title":"How do I generate random integers within a specific range in Java?","slug":"how-do-i-generate-random-integers-within-a-specific-range-in-java-1657385458888"},{"title":"The difference between bracket [ ] and double bracket [[ ]] for accessing the elements of a list or dataframe","slug":"the-difference-between-bracket-and-double-bracket-for-accessing-the-elements-of-a-list-or-dataframe-1657388451711"},{"title":"Why is my Spring @Autowired field null?","slug":"why-is-my-spring-@autowired-field-null-1657384705291"},{"title":"How to access a local variable from a different function using pointers?","slug":"how-to-access-a-local-variable-from-a-different-function-using-pointers-1657388159760"},{"title":"Correctly allocating multi-dimensional arrays","slug":"correctly-allocating-multi-dimensional-arrays-1657387733756"},{"title":"Truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all()","slug":"truth-value-of-a-series-is-ambiguous.-use-a.empty-a.bool()-a.item()-a.any()-or-a.all()-1657387724259"},{"title":"What is the best regular expression to check if a string is a valid URL?","slug":"what-is-the-best-regular-expression-to-check-if-a-string-is-a-valid-url-1657387618306"},{"title":"What does ** (double star/asterisk) and * (star/asterisk) do for parameters?","slug":"what-does-**-(double-starasterisk)-and-*-(starasterisk)-do-for-parameters-1657384800967"},{"title":"When should I wrap quotes around a shell variable?","slug":"when-should-i-wrap-quotes-around-a-shell-variable-1657384659265"},{"title":"What happens if you use the 32-bit int 0x80 Linux ABI in 64-bit code?","slug":"what-happens-if-you-use-the-32-bit-int-0x80-linux-abi-in-64-bit-code-1657388560485"},{"title":"The 3 different equals","slug":"the-3-different-equals-1657385490242"},{"title":"How do I determine the correct path for FXML files, CSS files, Images, and other resources needed by my JavaFX Application?","slug":"how-do-i-determine-the-correct-path-for-fxml-files-css-files-images-and-other-resources-needed-by-my-javafx-application-1657388143988"},{"title":"What is move semantics?","slug":"what-is-move-semantics-1657387702625"},{"title":"What do 'lazy' and 'greedy' mean in the context of regular expressions?","slug":"what-do-'lazy'-and-'greedy'-mean-in-the-context-of-regular-expressions-1657388200552"},{"title":"What does the comma operator , do?","slug":"what-does-the-comma-operator-do-1657388258021"},{"title":"Can you provide some examples of why it is hard to parse XML and HTML with a regex? [closed]","slug":"can-you-provide-some-examples-of-why-it-is-hard-to-parse-xml-and-html-with-a-regex-closed-1657388410824"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"how-do-you-parse-and-process-htmlxml-in-php-1657384351267"},"buildId":"BnkbnjkWYxefPXjTJLVVv","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>