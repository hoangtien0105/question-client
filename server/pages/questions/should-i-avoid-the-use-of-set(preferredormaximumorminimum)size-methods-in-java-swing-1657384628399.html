<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>Should I avoid the use of set(Preferred|Maximum|Minimum)Size methods in Java Swing? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="Several times I&#x27;ve been criticized for having suggested the use of the following methods:


setPreferredSize
setMinimumSize
setMaximumSize


on Swing components. I don&#x27;t see any alternative to their use when I want to define proportions between displayed components. I have been told this:


  With layouts the answer is always the same: use a suitable
  LayoutManager


I have searched the web a little bit, but I haven&#x27;t found any comprehensive analysis of the subject. So I have the following questions:


Should I completely avoid the use of those methods?
The methods have been defined for a reason. So when should I use them? In which context? For what purposes? 
What exactly are the negative consequences of using those methods? (I can only think adding portability between systems with different screen resolution).
I don&#x27;t think any LayoutManager can exactly satisfy all desired layout needs. Do I really need to implement a new LayoutManager for every little variation on my layout ? 
If the answer to 4 is &quot;yes&quot;, won&#x27;t this lead to a proliferation of LayoutManager classes which will become difficult to maintain?
In a situation where I need to define proportions between children of a Component (eg, child1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom LayoutManager?

    "/><meta property="og:title" content="Should I avoid the use of set(Preferred|Maximum|Minimum)Size methods in Java Swing? | Solutions Checker"/><meta property="og:description" content="Several times I&#x27;ve been criticized for having suggested the use of the following methods:


setPreferredSize
setMinimumSize
setMaximumSize


on Swing components. I don&#x27;t see any alternative to their use when I want to define proportions between displayed components. I have been told this:


  With layouts the answer is always the same: use a suitable
  LayoutManager


I have searched the web a little bit, but I haven&#x27;t found any comprehensive analysis of the subject. So I have the following questions:


Should I completely avoid the use of those methods?
The methods have been defined for a reason. So when should I use them? In which context? For what purposes? 
What exactly are the negative consequences of using those methods? (I can only think adding portability between systems with different screen resolution).
I don&#x27;t think any LayoutManager can exactly satisfy all desired layout needs. Do I really need to implement a new LayoutManager for every little variation on my layout ? 
If the answer to 4 is &quot;yes&quot;, won&#x27;t this lead to a proliferation of LayoutManager classes which will become difficult to maintain?
In a situation where I need to define proportions between children of a Component (eg, child1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom LayoutManager?

    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Should I avoid the use of set(Preferred|Maximum|Minimum)Size methods in Java Swing?","text":"Several times I&apos;ve been criticized for having suggested the use of the following methods:\n\n\nsetPreferredSize\nsetMinimumSize\nsetMaximumSize\n\n\non Swing components. I don&apos;t see any alternative to their use when I want to define proportions between displayed components. I have been told this:\n\n\n  With layouts the answer is always the same: use a suitable\n  LayoutManager\n\n\nI have searched the web a little bit, but I haven&apos;t found any comprehensive analysis of the subject. So I have the following questions:\n\n\nShould I completely avoid the use of those methods?\nThe methods have been defined for a reason. So when should I use them? In which context? For what purposes? \nWhat exactly are the negative consequences of using those methods? (I can only think adding portability between systems with different screen resolution).\nI don&apos;t think any LayoutManager can exactly satisfy all desired layout needs. Do I really need to implement a new LayoutManager for every little variation on my layout ? \nIf the answer to 4 is &quot;yes&quot;, won&apos;t this lead to a proliferation of LayoutManager classes which will become difficult to maintain?\nIn a situation where I need to define proportions between children of a Component (eg, child1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom LayoutManager?\n\n    ","answerCount":9,"upVoteCount":500,"suggestedAnswer":[{"text":"\n\n  Should I completely avoid the use of those methods?\n\n\nYes for application code.\n\n  The methods have been defined for a reason. So when should I use them? In which context? For what purposes?\n\n\nI don&apos;t know, personally I think of it as an API design accident. Slightly forced by compound components having special ideas about child sizes. &quot;Slightly&quot;, because they should have implemented their needs with a custom LayoutManager.\n\n  What exactly are the negative consequences of using those methods? (I can only think adding portability between systems with different screen resolution.)\n\n\nSome (incomplete, and unfortunately the links are broken due to migration of SwingLabs to java.net) technical reasons are for instance mentioned in the Rules (hehe) or in the link @bendicott found in his/her comment to my answer. Socially, posing tons of work onto your unfortunate fellow who has to maintain the code and has to track down a broken layout.\n\n  I don&apos;t think any LayoutManager can exactly satisfy all desired layout needs. Do I really need to implement a new LayoutManager for every little variation on my layout?\n\n\nYes, there are LayoutManagers powerful enough to satisfy a very good approximation to &quot;all layout needs&quot;. The big three are JGoodies FormLayout, MigLayout, DesignGridLayout. So no, in practice, you rarely write LayoutManagers except for simple highly specialized environments.\n\n  If the answer to 4 is &quot;yes&quot;, won&apos;t this lead to a proliferation of LayoutManager classes which will become difficult to maintain? \n\n\n(The answer to 4 is &quot;no&quot;.)\n\n  In a situation where I need to define proportions between children of a Component (for example, child 1 should use 10% of space, child 2 40%, child 3 50%), is it possible to achieve that without implementing a custom LayoutManager?\n\n\nAny of the Big-Three can, can&apos;t even GridBag (never bothered to really master, too much trouble for too little power).\n\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"A few heuristics:\n\n\nDon&apos;t use set[Preferred|Maximum|Minimum]Size() when you really mean to override get[Preferred|Maximum|Minimum]Size(), as might be done in creating your own component, shown here.\nDon&apos;t use set[Preferred|Maximum|Minimum]Size() when you could rely on a component&apos;s carefully overridden getPreferred|Maximum|Minimum]Size, as shown here and below.\nDo use set[Preferred|Maximum|Minimum]Size() to derive post-validate() geometry, as shown below and here.\nIf a component has no preferred size, e.g. JDesktopPane, you may have to size the container, but any such choice is arbitrary. A comment may help clarify the intent.\nConsider alternate or custom layouts when you find that you would have to loop through many components to obtain derived sizes, as mentioned in these comments.\n\n\n\n\nimport java.awt.Component;\nimport java.awt.Dimension;\nimport java.awt.EventQueue;\nimport java.awt.GridLayout;\nimport java.awt.KeyboardFocusManager;\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.util.ArrayList;\nimport java.util.List;\nimport javax.swing.JComponent;\nimport javax.swing.JDesktopPane;\nimport javax.swing.JFrame;\nimport javax.swing.JInternalFrame;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTextField;\nimport javax.swing.SwingUtilities;\n\n/**\n * @see https://stackoverflow.com/questions/7229226\n * @see https://stackoverflow.com/questions/7228843\n */\npublic class DesignTest {\n\n    private List&lt;JTextField&gt; list = new ArrayList&lt;JTextField&gt;();\n    private JPanel panel = new JPanel();\n    private JScrollPane sp = new JScrollPane(panel);\n\n    public static void main(String args[]) {\n        EventQueue.invokeLater(new Runnable() {\n\n            @Override\n            public void run() {\n                DesignTest id = new DesignTest();\n                id.create(&quot;My Project&quot;);\n            }\n        });\n    }\n\n    private void addField(String name) {\n        JTextField jtf = new JTextField(16);\n        panel.add(new JLabel(name, JLabel.LEFT));\n        panel.add(jtf);\n        list.add(jtf);\n    }\n\n    private void create(String strProjectName) {\n        panel.setLayout(new GridLayout(0, 1));\n        addField(&quot;First Name:&quot;);\n        addField(&quot;Last Name:&quot;);\n        addField(&quot;Address:&quot;);\n        addField(&quot;City:&quot;);\n        addField(&quot;Zip Code:&quot;);\n        addField(&quot;Phone:&quot;);\n        addField(&quot;Email Id:&quot;);\n        KeyboardFocusManager.getCurrentKeyboardFocusManager()\n            .addPropertyChangeListener(&quot;permanentFocusOwner&quot;,\n            new FocusDrivenScroller(panel));\n        // Show half the fields\n        sp.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);\n        sp.validate();\n        Dimension d = sp.getPreferredSize();\n        d.setSize(d.width, d.height / 2);\n        sp.setPreferredSize(d);\n\n        JInternalFrame internaFrame = new JInternalFrame();\n        internaFrame.add(sp);\n        internaFrame.pack();\n        internaFrame.setVisible(true);\n\n        JDesktopPane desktopPane = new JDesktopPane();\n        desktopPane.add(internaFrame);\n\n        JFrame frmtest = new JFrame();\n        frmtest.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frmtest.add(desktopPane);\n        frmtest.pack();\n        // User&apos;s preference should be read from java.util.prefs.Preferences\n        frmtest.setSize(400, 300);\n        frmtest.setLocationRelativeTo(null);\n        frmtest.setVisible(true);\n        list.get(0).requestFocusInWindow();\n    }\n\n    private static class FocusDrivenScroller implements PropertyChangeListener {\n\n        private JComponent parent;\n\n        public FocusDrivenScroller(JComponent parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public void propertyChange(PropertyChangeEvent evt) {\n            Component focused = (Component) evt.getNewValue();\n            if (focused != null\n                &amp;&amp; SwingUtilities.isDescendingFrom(focused, parent)) {\n                parent.scrollRectToVisible(focused.getBounds());\n            }\n        }\n    }\n}\n\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"\n  Should I completely avoid the use of those methods?\n\n\nNo, there is no formal evidence to suggest calling or overriding these methods is not allowed. In fact, Oracle says these methods are used for giving size hints: http://docs.oracle.com/javase/tutorial/uiswing/layout/using.html#sizealignment.\n\nThey may also be overridden (which is the best practice for Swing) when extending a Swing component (rather than calling the method on the custom component instance)\n\nMost importantly no matter how you specify your component&apos;s size, be sure that your component&apos;s container uses a layout manager that respects the requested size of the component. \n\n\n  The methods have been defined for a reason. So when should I use them?\n  In which context? For what purposes?\n\n\nWhen you need to provide customized size hints to the containers Layout manager so that the component will be laid out well\n\n\n  What exactly are the negative consequences of using those methods? (I\n  can only think to add portability between systems with different\n  screen resolution).\n\n\n\nMany layout managers do not pay attention to a component&apos;s requested maximum size. However, BoxLayout and SpringLayout do. Furthermore, GroupLayout provides the ability to set the minimum, preferred or maximum size explicitly, without touching the component.\nMake sure that you really need to set the component&apos;s exact size. Each Swing component has a different preferred size, depending on the font it uses and the look and feel. Thus having a set size might produce varied looks of the UI on different Systems\nsometimes problems can be encountered with GridBagLayout and text fields, wherein if the size of the container is smaller than the preferred size, the minimum size gets used, which can cause text fields to shrink quite substantially.\nJFrame does not enforce overriden getMinimumSize() only calling setMinimumSize(..) on its works\n\n\n\n  I don&apos;t think any LayoutManager can exactly satisfy all desired layout\n  needs. Do I really need to implement a new LayoutManager for every\n  little variation on my layout?\n\n\nIf by implementing you mean using then yes. Not one LayoutManger can handle everything, each LayoutManager has its pros and cons thus each can be used together to produce the final layout.\n\nReference:\n\n\nhttp://docs.oracle.com/javase/tutorial/uiswing/layout/problems.html\n\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"There are a lot of good answers here but I want to add a little more about the reasons why you should normally avoid these (the question just came up again in a duplicate topic):\n\nWith few exceptions, if you are using these methods you are probably fine-tuning your GUI to look good on a specific look-and-feel (and with your system-specific settings, e.g. your preferred desktop font, etc.). The methods themselves aren&apos;t inherently evil, but the typical reasons for using them are. As soon as you start tuning pixel positions and sizes in a layout you run the risk of your GUI breaking (or at minimum, looking bad), on other platforms.\n\nAs an example of this, try changing your application&apos;s default look-and-feel. Even just with the options available on your platform, you may be surprised at how poorly the results can be rendered.\n\nSo, in the name of keeping your GUI functional and nice-looking on all platforms (remember, one of the major benefits of Java is its cross-platformness), you should rely on layout managers, etc., to automatically adjust the sizes of your components so that it renders correctly outside of your specific development environment.\n\nAll that said, you can certainly conceive of situations where these methods are justified. Again, they aren&apos;t inherently evil, but their usage is normally a big red flag indicating potential GUI issues. Just make sure you are aware of the high potential for complications if/when you use them, and always try and think if there is another look-and-feel-independent solution to your problems -- more often than not you will find that these methods are not necessary.\n\nBy the way, if you find yourself getting frustrated with standard layout managers, there are a lot of good free, open-source third-party ones, for example JGoodies&apos; FormLayout, or MigLayout. Some GUI builders even have built-in support for third-party layout managers -- Eclipse&apos;s WindowBuilder GUI editor, for example, ships with support for FormLayout and MigLayout.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"If you are having trouble with layouts in Java Swing, then I can highly recommend the JGoodies FormLayout provided freely as part of the Forms freeware library by Karsten Lentzsch here.\n\nThis very popular layout manager is extremely flexible, allowing for very polished Java UIs to be developed.\n\nYou&apos;ll find Karsten&apos;s documentation in here, and some rather good documentation from eclipse here.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"These methods are poorly understood by most people. You should absolutely not ignore these methods. It is up to the layout manager if they honor these methods. This page has a table that shows which layout managers honor which of those methods:\n\nhttp://thebadprogrammer.com/swing-layout-manager-sizing/\n\nI have been writing Swing code for 8+ years and the layout managers included in the JDK have always served my needs. I have never needed a 3rd party layout manager to achieve my layouts.\n\nI will say that you shouldn&apos;t try to give the layout manager hints with these methods until you are sure you need them. Do your layout without giving any sizing hints (i.e. let the layout manager do its job) and then you can make minor corrections if you need to.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"\n  In a situation where I need to define proportions between children of a Component (child 1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom layout manager?\n\n\nMaybe GridBagLayout would satisfy your needs. Besides that, there&apos;s a ton of layout managers on the web, and I bet there&apos;s one that fits your requirements.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"I am seeing it differenty than the accepted answer.\n1) Should I completely avoid the use of those methods?\nNever avoid! They&apos;re there to express the size constraints of your components to the layout manager. You can avoid using them if you&apos;re not using any layout manager and try to manage the visual layout on your own.\nUnfortunately, Swing is not coming with reasonable default dimensions. However, instead of setting the dimensions of a component, it is better OOP to descend your own component with reasonable defaults. (In that case you call setXXX in your descendant class.) Alternatively, you can override the getXXX methods for the same effect.\n2) The methods have been defined for a reason. So when should I use them? In which context? For what purposes?\nAlways. When you create a component, set its realistic min/preferred/max size according to the use of that component. For example, if you have a JTextField for entering country symbols such as UK, its preferred size shall be as wide to fit two chars (with the current font, etc.) but probably it is meaningless to let it grow any bigger. After all, country symbols are two chars.\nAs opposite, if you have a JTextField for entering e.g. a customer name, it can have a preferred size for like the pixel size for 20 chars, but can grow to bigger if the layout is resized, so set the maximum size to more. At the same time, having a 0px wide JTextField is pointless, so set a realistic minimum size (I would say the pixel size of 2 chars).\n3) What exactly are the negative consequences of using those methods?\n(I can only think adding portability between systems with different screen resolution).\nNo negative consequences. These are hints for the layout manager.\n4) I don&apos;t think any LayoutManager can exactly satisfy all desired layout needs.\nDo I really need to implement a new LayoutManager for every little variation on my layout ?\nNo, definitely not. The usual approach is to cascade different basic layoutmanagers such as horizontal and vertical layout.\nFor example, the layout below:\n&lt;pre&gt;\n+--------------+--------+\n| ###JTABLE### | [Add]  | \n| ...data...   |[Remove]|\n| ...data...   |        |\n| ...data...   |        |\n+--------------+--------+\n&lt;/pre&gt;\n\nis having two parts. The left and right parts are a horizontal layout. The right part is a JPanel added to the horizontal layout, and this JPanel is having a vertical layout which lays out the buttons vertically.\nOf course, this can grow tricky with a real life layout. Therefore grid-based layout managers such as MigLayout are much better if you&apos;re about to develop anything serious.\n5) If the answer to 4 is &quot;yes&quot;, won&apos;t this lead to a proliferation of LayoutManager classes which will become difficult to maintain?\nNo, you definitely shall not develop layout managers, unless you need something very special.\n6) In a situation where I need to define proportions...\nbetween children of a Component (eg, child1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom LayoutManager?\nBasically, once the preferred sizes are set right, you may not want to do anything in percentage. Simply, because percentages are pointless (e.g. it is pointless to have a JTextField 10% of the window size - since one can shrink the window so that JTextField becomes 0px wide, or can expand the window so that the JTextField is across two displays on a multi-display setup).\nBut, may times you may use the percentages to control sizes of bigger building blocks of your gui (panels, for example).\nYou can use JSplitPane where you can pre-set the ratio of the two sides. Or, you can use MigLayout which allows you to set such constraints in percentage, pixels, and other units.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"Should I completely avoid the use of those methods?\nI wouldn&apos;t say &quot;avoid&quot; them. I&apos;d say that if you think you need them, you&apos;re probably doing something wrong. Component sizes are determined in context. For example, Text component sizes are determined by the number of rows and columns you specify, combined with the font you may have chosen. Your button and label size will be the size of the graphic, if you set one, or the space needed to display the text you set. Each component has a natural size, and the layout managers will use those to lay everything out without you needing to specify sizes. The main exception is the JScrollPane, which has a size independent of whatever it contains. For those, I will sometimes call setSize(), and let that size determine the initial window size, by calling JFrame.pack(). Usually, I will let the window size determine the JScrollPane size. The user will determine the size of the window. Many layout managers ignore the sizes you set anyway, so they often don&apos;t do much good.\n\nThe methods have been defined for a reason. So when should I use them? In which context? For what purposes?\nI believe they were added to provide hints to the layout managers. They may have been written for historical reasons, because layout managers were new, and people didn&apos;t fully trust them. I know a few developers who avoided layout managers and placed everything manually, just because they didn&apos;t want to bother with learning a new paradigm. It&apos;s a terrible idea.\n\nWhat exactly are the negative consequences of using those methods? (I can only think adding portability between systems with different screen resolution).\nThey&apos;re ineffective, and they produce bad layouts, with objects getting squeezed or stretched to non-natural sizes. And the layouts will be brittle. Changes to the window size will sometimes break the layout and put things in the wrong places.\n\nI don&apos;t think any LayoutManager can exactly satisfy all desired layout needs. Do I really need to implement a new LayoutManager for every little variation on my layout ? You shouldn&apos;t &quot;implement&quot; a new LayoutManager. You should instantiate existing ones. I often use several layout managers in a single window. Each JPanel will have its own layout manager. Some people balk at nested layouts, because they&apos;re hard to maintain. When I use them, I give each one its own creation method to make it easier to see what each one does. But I never &quot;implement&quot; a layout manager. I just instantiate them. \n\nIf the answer to 4 is &quot;yes&quot;, won&apos;t this lead to a proliferation of LayoutManager classes which will become difficult to maintain?\nIf you&apos;re implementing new layout manager classes for slight variations in layout, you&apos;re using them wrong. If you&apos;re just implementing new layout managers, you&apos;re probably doing something wrong. The only time I&apos;ve extended a LayoutManager class, it was to add a zoom slider to a JScrollPane.\n\nIn a situation where I need to define proportions between children of a Component (eg, child1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom LayoutManager?\nThe JSplitPane has a way of specifying the percentage each component should get. The divider is movable by default, but you can turn that off if you want. I don&apos;t use that feature much. I usually have some components that take up a set size, and the rest of the space is taken up by a scroll pane. The scroll pane size will adjust with the window size. If you have two scroll panes side by side, you can put them in a JSplitPane and specify the percentage of new space given to each one as the user expands and contracts the windows.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-12e9794e898cd5f3.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-928c5d1eb8fb0bba.js" defer=""></script><script src="/_next/static/BnkbnjkWYxefPXjTJLVVv/_buildManifest.js" defer=""></script><script src="/_next/static/BnkbnjkWYxefPXjTJLVVv/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/should-i-avoid-the-use-of-set(preferredormaximumorminimum)size-methods-in-java-swing-1657384628399#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/should-i-avoid-the-use-of-set(preferredormaximumorminimum)size-methods-in-java-swing-1657384628399"><h1>Should I avoid the use of set(Preferred|Maximum|Minimum)Size methods in Java Swing?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"></div></div><div class="question-content mt-5">
                
<p>Several times I've been criticized for having suggested the use of the following methods:</p>

<ol>
<li><strong>setPreferredSize</strong></li>
<li><strong>setMinimumSize</strong></li>
<li><strong>setMaximumSize</strong></li>
</ol>

<p>on <code>Swing</code> components. I don't see any alternative to their use when I want to define proportions between displayed components. I have been told this:</p>

<blockquote>
  <p>With layouts the answer is always the same: use a suitable
  LayoutManager</p>
</blockquote>

<p>I have searched the web a little bit, but I haven't found any comprehensive analysis of the subject. So I have the following questions:</p>

<ol>
<li>Should I completely avoid the use of those methods?</li>
<li>The methods have been defined for a reason. So when should I use them? In which context? For what purposes? </li>
<li>What exactly are the negative consequences of using those methods? (I can only think adding portability between systems with different screen resolution).</li>
<li>I don't think any LayoutManager can exactly satisfy all desired layout needs. Do I really need to implement a new LayoutManager for every little variation on my layout ? </li>
<li>If the answer to 4 is "yes", won't this lead to a proliferation of LayoutManager classes which will become difficult to maintain?</li>
<li>In a situation where I need to define proportions between children of a Component (eg, child1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom LayoutManager?</li>
</ol>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<ol>
<li><blockquote>
  <p>Should I completely avoid the use of those methods?</p>
</blockquote>

<p>Yes for application code.</p></li>
<li><blockquote>
  <p>The methods have been defined for a reason. So when should I use them? In which context? For what purposes?</p>
</blockquote>

<p>I don't know, personally I think of it as an API design accident. Slightly forced by compound components having special ideas about child sizes. "Slightly", because they should have implemented their needs with a custom LayoutManager.</p></li>
<li><blockquote>
  <p>What exactly are the negative consequences of using those methods? (I can only think adding portability between systems with different screen resolution.)</p>
</blockquote>

<p>Some (incomplete, and unfortunately the links are broken due to migration of SwingLabs to java.net) technical reasons are for instance mentioned in the <a href="http://web.archive.org/web/20110614145256/http://wiki.java.net/twiki/bin/view/Javadesktop/SwingLabsImperialRules?TWIKISID=e1a6667476691b56753dc9b0744828c6#Do_not_use_component_setXXSize" rel="noreferrer">Rules (hehe)</a> or in the <a href="http://web.archive.org/web/20100207211337/http://www.jguru.com/faq/view.jsp?EID=237070" rel="noreferrer">link</a> @bendicott found in his/her comment to <a href="https://stackoverflow.com/questions/7074514/images-in-jtable-cells-off-by-one-pixel">my answer</a>. Socially, posing tons of work onto your unfortunate fellow who has to maintain the code and has to track down a broken layout.</p></li>
<li><blockquote>
  <p>I don't think any LayoutManager can exactly satisfy all desired layout needs. Do I really need to implement a new LayoutManager for every little variation on my layout?</p>
</blockquote>

<p>Yes, there are LayoutManagers powerful enough to satisfy a very good approximation to "all layout needs". The big three are JGoodies FormLayout, MigLayout, DesignGridLayout. So no, in practice, you rarely write LayoutManagers except for simple highly specialized environments.</p></li>
<li><blockquote>
  <p>If the answer to 4 is "yes", won't this lead to a proliferation of LayoutManager classes which will become difficult to maintain? </p>
</blockquote>

<p>(The answer to 4 is "no".)</p></li>
<li><blockquote>
  <p>In a situation where I need to define proportions between children of a Component (for example, child 1 should use 10% of space, child 2 40%, child 3 50%), is it possible to achieve that without implementing a custom LayoutManager?</p>
</blockquote>

<p>Any of the Big-Three can, can't even GridBag (never bothered to really master, too much trouble for too little power).</p></li>
</ol>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A few heuristics:</p>

<ul>
<li><p>Don't use <code>set[Preferred|Maximum|Minimum]Size()</code> when you really mean to override <code>get[Preferred|Maximum|Minimum]Size()</code>, as might be done in creating your own component, shown <a href="https://stackoverflow.com/a/10110232/230513">here</a>.</p></li>
<li><p>Don't use <code>set[Preferred|Maximum|Minimum]Size()</code> when you could rely on a component's carefully overridden <code>getPreferred|Maximum|Minimum]Size</code>, as shown <a href="https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280">here</a> and below.</p></li>
<li><p>Do use <code>set[Preferred|Maximum|Minimum]Size()</code> to derive post-<code>validate()</code> geometry, as shown below and <a href="https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280">here</a>.</p></li>
<li><p>If a component has no preferred size, e.g. <code>JDesktopPane</code>, you may have to size the container, but any such choice is arbitrary. A comment may help clarify the intent.</p></li>
<li><p>Consider alternate or custom layouts when you find that you would have to loop through many components to obtain derived sizes, as mentioned in these <a href="https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280">comments</a>.</p></li>
</ul>

<p><img src="https://i.stack.imgur.com/hYh36.png" alt="enter image description here"></p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">import</span> java.awt.Component;
<span class="hljs-keyword">import</span> java.awt.Dimension;
<span class="hljs-keyword">import</span> java.awt.EventQueue;
<span class="hljs-keyword">import</span> java.awt.GridLayout;
<span class="hljs-keyword">import</span> java.awt.KeyboardFocusManager;
<span class="hljs-keyword">import</span> java.beans.PropertyChangeEvent;
<span class="hljs-keyword">import</span> java.beans.PropertyChangeListener;
<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> javax.swing.JComponent;
<span class="hljs-keyword">import</span> javax.swing.JDesktopPane;
<span class="hljs-keyword">import</span> javax.swing.JFrame;
<span class="hljs-keyword">import</span> javax.swing.JInternalFrame;
<span class="hljs-keyword">import</span> javax.swing.JLabel;
<span class="hljs-keyword">import</span> javax.swing.JPanel;
<span class="hljs-keyword">import</span> javax.swing.JScrollPane;
<span class="hljs-keyword">import</span> javax.swing.JTextField;
<span class="hljs-keyword">import</span> javax.swing.SwingUtilities;

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@see</span> https://stackoverflow.com/questions/7229226
 * <span class="hljs-doctag">@see</span> https://stackoverflow.com/questions/7228843
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DesignTest</span> {

    <span class="hljs-keyword">private</span> List&lt;JTextField&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;JTextField&gt;();
    <span class="hljs-keyword">private</span> <span class="hljs-type">JPanel</span> <span class="hljs-variable">panel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JPanel</span>();
    <span class="hljs-keyword">private</span> <span class="hljs-type">JScrollPane</span> <span class="hljs-variable">sp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JScrollPane</span>(panel);

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> {
        EventQueue.invokeLater(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() {

            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {
                <span class="hljs-type">DesignTest</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DesignTest</span>();
                id.create(<span class="hljs-string">"My Project"</span>);
            }
        });
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addField</span><span class="hljs-params">(String name)</span> {
        <span class="hljs-type">JTextField</span> <span class="hljs-variable">jtf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JTextField</span>(<span class="hljs-number">16</span>);
        panel.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JLabel</span>(name, JLabel.LEFT));
        panel.add(jtf);
        list.add(jtf);
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">create</span><span class="hljs-params">(String strProjectName)</span> {
        panel.setLayout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GridLayout</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>));
        addField(<span class="hljs-string">"First Name:"</span>);
        addField(<span class="hljs-string">"Last Name:"</span>);
        addField(<span class="hljs-string">"Address:"</span>);
        addField(<span class="hljs-string">"City:"</span>);
        addField(<span class="hljs-string">"Zip Code:"</span>);
        addField(<span class="hljs-string">"Phone:"</span>);
        addField(<span class="hljs-string">"Email Id:"</span>);
        KeyboardFocusManager.getCurrentKeyboardFocusManager()
            .addPropertyChangeListener(<span class="hljs-string">"permanentFocusOwner"</span>,
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">FocusDrivenScroller</span>(panel));
        <span class="hljs-comment">// Show half the fields</span>
        sp.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
        sp.validate();
        <span class="hljs-type">Dimension</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> sp.getPreferredSize();
        d.setSize(d.width, d.height / <span class="hljs-number">2</span>);
        sp.setPreferredSize(d);

        <span class="hljs-type">JInternalFrame</span> <span class="hljs-variable">internaFrame</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JInternalFrame</span>();
        internaFrame.add(sp);
        internaFrame.pack();
        internaFrame.setVisible(<span class="hljs-literal">true</span>);

        <span class="hljs-type">JDesktopPane</span> <span class="hljs-variable">desktopPane</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JDesktopPane</span>();
        desktopPane.add(internaFrame);

        <span class="hljs-type">JFrame</span> <span class="hljs-variable">frmtest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JFrame</span>();
        frmtest.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frmtest.add(desktopPane);
        frmtest.pack();
        <span class="hljs-comment">// User's preference should be read from java.util.prefs.Preferences</span>
        frmtest.setSize(<span class="hljs-number">400</span>, <span class="hljs-number">300</span>);
        frmtest.setLocationRelativeTo(<span class="hljs-literal">null</span>);
        frmtest.setVisible(<span class="hljs-literal">true</span>);
        list.get(<span class="hljs-number">0</span>).requestFocusInWindow();
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FocusDrivenScroller</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PropertyChangeListener</span> {

        <span class="hljs-keyword">private</span> JComponent parent;

        <span class="hljs-keyword">public</span> <span class="hljs-title function_">FocusDrivenScroller</span><span class="hljs-params">(JComponent parent)</span> {
            <span class="hljs-built_in">this</span>.parent = parent;
        }

        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">propertyChange</span><span class="hljs-params">(PropertyChangeEvent evt)</span> {
            <span class="hljs-type">Component</span> <span class="hljs-variable">focused</span> <span class="hljs-operator">=</span> (Component) evt.getNewValue();
            <span class="hljs-keyword">if</span> (focused != <span class="hljs-literal">null</span>
                &amp;&amp; SwingUtilities.isDescendingFrom(focused, parent)) {
                parent.scrollRectToVisible(focused.getBounds());
            }
        }
    }
}
</code></pre>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<blockquote>
  <p>Should I completely avoid the use of those methods?</p>
</blockquote>

<p>No, there is no formal evidence to suggest calling or overriding these methods is not allowed. In fact, Oracle says these methods are used for giving size hints: <a href="http://docs.oracle.com/javase/tutorial/uiswing/layout/using.html#sizealignment" rel="noreferrer">http://docs.oracle.com/javase/tutorial/uiswing/layout/using.html#sizealignment</a>.</p>

<p>They may also be overridden (which is the best practice for Swing) when <em>extending</em> a Swing component (rather than calling the method on the custom component instance)</p>

<p>Most importantly no matter how you specify your component's size, be sure that your component's container uses a layout manager that respects the requested size of the component. </p>

<blockquote>
  <p>The methods have been defined for a reason. So when should I use them?
  In which context? For what purposes?</p>
</blockquote>

<p>When you need to provide customized size hints to the containers Layout manager so that the component will be laid out well</p>

<blockquote>
  <p>What exactly are the negative consequences of using those methods? (I
  can only think to add portability between systems with different
  screen resolution).</p>
</blockquote>

<ul>
<li><p>Many layout managers do not pay attention to a component's requested maximum size. However, <code>BoxLayout</code> and <code>SpringLayout</code> do. Furthermore, <code>GroupLayout</code> provides the ability to set the minimum, preferred or maximum size explicitly, without touching the component.</p></li>
<li><p>Make sure that you really need to set the component's exact size. Each Swing component has a different preferred size, depending on the font it uses and the look and feel. Thus having a set size might produce varied <em>looks</em> of the UI on different Systems</p></li>
<li><p>sometimes problems can be encountered with <code>GridBagLayout</code> and text fields, wherein if the size of the container is smaller than the preferred size, the minimum size gets used, which can cause text fields to shrink quite substantially.</p></li>
<li><p><code>JFrame</code> does not enforce overriden <code>getMinimumSize()</code> only calling <code>setMinimumSize(..)</code> on its works</p></li>
</ul>

<blockquote>
  <p>I don't think any LayoutManager can exactly satisfy all desired layout
  needs. Do I really need to implement a new LayoutManager for every
  little variation on my layout?</p>
</blockquote>

<p>If by implementing you mean using then yes. Not one <code>LayoutManger</code> can handle everything, each <code>LayoutManager</code> has its pros and cons thus each can be used together to produce the final layout.</p>

<p><strong>Reference:</strong></p>

<ul>
<li><a href="http://docs.oracle.com/javase/tutorial/uiswing/layout/problems.html" rel="noreferrer">http://docs.oracle.com/javase/tutorial/uiswing/layout/problems.html</a></li>
</ul>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There are a lot of good answers here but I want to add a little more about the reasons <em>why</em> you should normally avoid these (the question just came up again in a duplicate topic):</p>

<p>With few exceptions, if you are using these methods you are probably fine-tuning your GUI to look good on a specific look-and-feel (and with your system-specific settings, e.g. your preferred desktop font, etc.). The methods themselves aren't inherently evil, but the typical reasons for using them <em>are</em>. As soon as you start tuning pixel positions and sizes in a layout you run the risk of your GUI breaking (or at minimum, looking bad), on other platforms.</p>

<p>As an example of this, try changing your application's default look-and-feel. Even just with the options available on your platform, you may be surprised at how poorly the results can be rendered.</p>

<p>So, in the name of keeping your GUI functional and nice-looking on all platforms (remember, one of the major benefits of Java is its cross-platformness), you should rely on layout managers, etc., to automatically adjust the sizes of your components so that it renders correctly outside of your specific development environment.</p>

<p>All that said, you can certainly conceive of situations where these methods are justified. Again, they aren't inherently evil, but their usage is normally a <strong>big</strong> red flag indicating potential GUI issues. Just make sure you are aware of the high potential for complications if/when you use them, and always try and think if there is another look-and-feel-independent solution to your problems -- more often than not you will find that these methods are not necessary.</p>

<p>By the way, if you find yourself getting frustrated with standard layout managers, there are a lot of good free, open-source third-party ones, for example <a href="http://www.jgoodies.com/freeware/libraries/forms/">JGoodies' <code>FormLayout</code></a>, or <a href="http://www.miglayout.com/"><code>MigLayout</code></a>. Some GUI builders even have built-in support for third-party layout managers -- Eclipse's WindowBuilder GUI editor, for example, ships with support for <code>FormLayout</code> and <code>MigLayout</code>.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you are having trouble with layouts in Java Swing, then I can highly recommend the JGoodies <code>FormLayout</code> provided freely as part of the Forms freeware library by Karsten Lentzsch <a href="http://www.jgoodies.com/freeware/libraries/forms/" rel="nofollow noreferrer">here</a>.</p>

<p>This very popular layout manager is extremely flexible, allowing for very polished Java UIs to be developed.</p>

<p>You'll find Karsten's documentation in <a href="http://manual.openestate.org/extern/forms-1.2.1/tutorial/introduction.html" rel="nofollow noreferrer">here</a>, and some rather good documentation from eclipse <a href="http://help.eclipse.org/oxygen/topic/org.eclipse.wb.swing.doc.user/html/layoutmanagers/swing/jgoodies_formlayout.html" rel="nofollow noreferrer">here</a>.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>These methods are poorly understood by most people. You should absolutely not ignore these methods. It is up to the layout manager if they honor these methods. This page has a table that shows which layout managers honor which of those methods:</p>

<p><a href="http://thebadprogrammer.com/swing-layout-manager-sizing/">http://thebadprogrammer.com/swing-layout-manager-sizing/</a></p>

<p>I have been writing Swing code for 8+ years and the layout managers included in the JDK have always served my needs. I have never needed a 3rd party layout manager to achieve my layouts.</p>

<p>I will say that you shouldn't try to give the layout manager hints with these methods until you are sure you need them. Do your layout without giving any sizing hints (i.e. let the layout manager do its job) and then you can make minor corrections if you need to.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<blockquote>
  <p>In a situation where I need to define proportions between children of a Component (child 1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom layout manager?</p>
</blockquote>

<p>Maybe <code>GridBagLayout</code> would satisfy your needs. Besides that, there's a ton of layout managers on the web, and I bet there's one that fits your requirements.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I am seeing it differenty than the accepted answer.</p>
<h3>1) Should I completely avoid the use of those methods?</h3>
<p>Never avoid! They're there to express the size constraints of your components to the layout manager. You can avoid using them if you're not using any layout manager and try to manage the visual layout on your own.</p>
<p>Unfortunately, Swing is not coming with reasonable default dimensions. However, instead of setting the dimensions of a component, it is better OOP to descend your own component with reasonable defaults. (In that case you call setXXX in your descendant class.) Alternatively, you can override the getXXX methods for the same effect.</p>
<h3>2) The methods have been defined for a reason. So when should I use them? In which context? For what purposes?</h3>
<p>Always. When you create a component, set its realistic min/preferred/max size according to the use of that component. For example, if you have a JTextField for entering country symbols such as UK, its preferred size shall be as wide to fit two chars (with the current font, etc.) but probably it is meaningless to let it grow any bigger. After all, country symbols are two chars.
As opposite, if you have a JTextField for entering e.g. a customer name, it can have a preferred size for like the pixel size for 20 chars, but can grow to bigger if the layout is resized, so set the maximum size to more. At the same time, having a 0px wide JTextField is pointless, so set a realistic minimum size (I would say the pixel size of 2 chars).</p>
<h3>3) What exactly are the negative consequences of using those methods?</h3>
<p>(I can only think adding portability between systems with different screen resolution).</p>
<p>No negative consequences. These are hints for the layout manager.</p>
<h3>4) I don't think any LayoutManager can exactly satisfy all desired layout needs.</h3>
<p>Do I really need to implement a new LayoutManager for every little variation on my layout ?</p>
<p>No, definitely not. The usual approach is to cascade different basic layoutmanagers such as horizontal and vertical layout.</p>
<p>For example, the layout below:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java">&lt;pre&gt;
+--------------+--------+
| ###JTABLE### | [Add]  | 
| ...data...   |[Remove]|
| ...data...   |        |
| ...data...   |        |
+--------------+--------+
&lt;/pre&gt;
</code></pre>
<p>is having two parts. The left and right parts are a horizontal layout. The right part is a JPanel added to the horizontal layout, and this JPanel is having a vertical layout which lays out the buttons vertically.</p>
<p>Of course, this can grow tricky with a real life layout. Therefore grid-based layout managers such as MigLayout are much better if you're about to develop anything serious.</p>
<h3>5) If the answer to 4 is "yes", won't this lead to a proliferation of LayoutManager classes which will become difficult to maintain?</h3>
<p>No, you definitely shall not develop layout managers, unless you need something very special.</p>
<h3>6) In a situation where I need to define proportions...</h3>
<p>between children of a Component (eg, child1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom LayoutManager?</p>
<p>Basically, once the preferred sizes are set right, you may not want to do anything in percentage. Simply, because percentages are pointless (e.g. it is pointless to have a JTextField 10% of the window size - since one can shrink the window so that JTextField becomes 0px wide, or can expand the window so that the JTextField is across two displays on a multi-display setup).</p>
<p>But, may times you may use the percentages to control sizes of bigger building blocks of your gui (panels, for example).</p>
<p>You can use JSplitPane where you can pre-set the ratio of the two sides. Or, you can use MigLayout which allows you to set such constraints in percentage, pixels, and other units.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Should I completely avoid the use of those methods?</strong>
I wouldn't say "avoid" them. I'd say that if you think you need them, you're probably doing something wrong. Component sizes are determined in context. For example, Text component sizes are determined by the number of rows and columns you specify, combined with the font you may have chosen. Your button and label size will be the size of the graphic, if you set one, or the space needed to display the text you set. Each component has a natural size, and the layout managers will use those to lay everything out without you needing to specify sizes. The main exception is the JScrollPane, which has a size independent of whatever it contains. For those, I will sometimes call <code>setSize()</code>, and let that size determine the initial window size, by calling <code>JFrame.pack()</code>. Usually, I will let the window size determine the JScrollPane size. The user will determine the size of the window. Many layout managers ignore the sizes you set anyway, so they often don't do much good.</p>

<p><strong>The methods have been defined for a reason. So when should I use them? In which context? For what purposes?</strong>
I believe they were added to provide hints to the layout managers. They may have been written for historical reasons, because layout managers were new, and people didn't fully trust them. I know a few developers who avoided layout managers and placed everything manually, just because they didn't want to bother with learning a new paradigm. It's a terrible idea.</p>

<p><strong>What exactly are the negative consequences of using those methods? (I can only think adding portability between systems with different screen resolution).</strong>
They're ineffective, and they produce bad layouts, with objects getting squeezed or stretched to non-natural sizes. And the layouts will be brittle. Changes to the window size will sometimes break the layout and put things in the wrong places.</p>

<p><strong>I don't think any LayoutManager can exactly satisfy all desired layout needs. Do I really need to implement a new LayoutManager for every little variation on my layout ?</strong> You shouldn't "implement" a new LayoutManager. You should instantiate existing ones. I often use several layout managers in a single window. Each JPanel will have its own layout manager. Some people balk at nested layouts, because they're hard to maintain. When I use them, I give each one its own creation method to make it easier to see what each one does. But I never "implement" a layout manager. I just instantiate them. </p>

<p><strong>If the answer to 4 is "yes", won't this lead to a proliferation of LayoutManager classes which will become difficult to maintain?</strong>
If you're implementing new layout manager classes for slight variations in layout, you're using them wrong. If you're just implementing new layout managers, you're probably doing something wrong. The only time I've extended a LayoutManager class, it was to add a zoom slider to a JScrollPane.</p>

<p><strong>In a situation where I need to define proportions between children of a Component (eg, child1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom LayoutManager?</strong>
The JSplitPane has a way of specifying the percentage each component should get. The divider is movable by default, but you can turn that off if you want. I don't use that feature much. I usually have some components that take up a set size, and the rest of the space is taken up by a scroll pane. The scroll pane size will adjust with the window size. If you have two scroll panes side by side, you can put them in a JSplitPane and specify the percentage of new space given to each one as the user expands and contracts the windows.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/why-does-a-regexp-with-global-flag-give-wrong-results-1657387788550">Why does a RegExp with global flag give wrong results?</a><a href="/questions/sort-a-maplesskey-valuegreater-by-values-1657387443904">Sort a Map&lt;Key, Value&gt; by values</a><a href="/questions/what-is-the-difference-between-client-side-and-server-side-programming-1657384372926">What is the difference between client-side and server-side programming?</a><a href="/questions/performance-optimization-strategies-of-last-resort-closed-1657388420614">Performance optimization strategies of last resort [closed]</a><a href="/questions/retrieving-the-last-record-in-each-group-mysql-1657384887369">Retrieving the last record in each group - MySQL</a><a href="/questions/xmlhttprequest-cannot-load-xxx-no-&#x27;access-control-allow-origin&#x27;-header-1657384758362">XMLHttpRequest cannot load XXX No &#x27;Access-Control-Allow-Origin&#x27; header</a><a href="/questions/is-there-a-css-parent-selector-1657384430692">Is there a CSS parent selector?</a><a href="/questions/what&#x27;s-the-meaning-of-%22greater%22-(an-arrow-formed-from-equals-and-greater-than)-in-javascript-1657387977118">What&#x27;s the meaning of &quot;=&gt;&quot; (an arrow formed from equals &amp; greater than) in JavaScript?</a><a href="/questions/unboundlocalerror-on-local-variable-when-reassigned-after-first-use-1657387685248">UnboundLocalError on local variable when reassigned after first use</a><a href="/questions/selecting-and-manipulating-css-pseudo-elements-such-as-::before-and-::after-using-javascript-(or-jquery)-1657387406132">Selecting and manipulating CSS pseudo-elements such as ::before and ::after using javascript (or jQuery)</a><a href="/questions/php-code-is-not-being-executed-but-the-code-shows-in-the-browser-source-code-1657384553581">PHP code is not being executed, but the code shows in the browser source code</a><a href="/questions/grouping-functions-(tapply-by-aggregate)-and-the-*apply-family-1657387844286">Grouping functions (tapply, by, aggregate) and the *apply family</a><a href="/questions/actual-meaning-of-&#x27;shelltrue&#x27;-in-subprocess-1657388470341">Actual meaning of &#x27;shell=True&#x27; in subprocess</a><a href="/questions/copy-array-by-value-1657387649531">Copy array by value</a><a href="/questions/why-is-24.0000-not-equal-to-24.0000-in-matlab-1657388376753">Why is 24.0000 not equal to 24.0000 in MATLAB?</a><a href="/questions/how-do-i-pass-data-between-activities-in-android-application-1657384739839">How do I pass data between Activities in Android application?</a><a href="/questions/how-do-i-use-reflection-to-call-a-generic-method-1657387256751">How do I use reflection to call a generic method?</a><a href="/questions/accessing-nested-javascript-objects-and-arrays-by-string-path-1657387321754">Accessing nested JavaScript objects and arrays by string path</a><a href="/questions/what-is-a-raw-type-and-why-shouldn&#x27;t-we-use-it-1657384481079">What is a raw type and why shouldn&#x27;t we use it?</a><a href="/questions/split-comma-separated-strings-in-a-column-into-separate-rows-1657387785823">Split comma-separated strings in a column into separate rows</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Should I completely avoid the use of those methods?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Yes for application code.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The methods have been defined for a reason. So when should I use them? In which context? For what purposes?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;I don\u0026apos;t know, personally I think of it as an API design accident. Slightly forced by compound components having special ideas about child sizes. \u0026quot;Slightly\u0026quot;, because they should have implemented their needs with a custom LayoutManager.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;What exactly are the negative consequences of using those methods? (I can only think adding portability between systems with different screen resolution.)\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Some (incomplete, and unfortunately the links are broken due to migration of SwingLabs to java.net) technical reasons are for instance mentioned in the \u0026lt;a href=\u0026quot;http://web.archive.org/web/20110614145256/http://wiki.java.net/twiki/bin/view/Javadesktop/SwingLabsImperialRules?TWIKISID=e1a6667476691b56753dc9b0744828c6#Do_not_use_component_setXXSize\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Rules (hehe)\u0026lt;/a\u0026gt; or in the \u0026lt;a href=\u0026quot;http://web.archive.org/web/20100207211337/http://www.jguru.com/faq/view.jsp?EID=237070\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;link\u0026lt;/a\u0026gt; @bendicott found in his/her comment to \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/7074514/images-in-jtable-cells-off-by-one-pixel\u0026quot;\u0026gt;my answer\u0026lt;/a\u0026gt;. Socially, posing tons of work onto your unfortunate fellow who has to maintain the code and has to track down a broken layout.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;I don\u0026apos;t think any LayoutManager can exactly satisfy all desired layout needs. Do I really need to implement a new LayoutManager for every little variation on my layout?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Yes, there are LayoutManagers powerful enough to satisfy a very good approximation to \u0026quot;all layout needs\u0026quot;. The big three are JGoodies FormLayout, MigLayout, DesignGridLayout. So no, in practice, you rarely write LayoutManagers except for simple highly specialized environments.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;If the answer to 4 is \u0026quot;yes\u0026quot;, won\u0026apos;t this lead to a proliferation of LayoutManager classes which will become difficult to maintain? \u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;(The answer to 4 is \u0026quot;no\u0026quot;.)\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;In a situation where I need to define proportions between children of a Component (for example, child 1 should use 10% of space, child 2 40%, child 3 50%), is it possible to achieve that without implementing a custom LayoutManager?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Any of the Big-Three can, can\u0026apos;t even GridBag (never bothered to really master, too much trouble for too little power).\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A few heuristics:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Don\u0026apos;t use \u0026lt;code\u0026gt;set[Preferred|Maximum|Minimum]Size()\u0026lt;/code\u0026gt; when you really mean to override \u0026lt;code\u0026gt;get[Preferred|Maximum|Minimum]Size()\u0026lt;/code\u0026gt;, as might be done in creating your own component, shown \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/10110232/230513\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Don\u0026apos;t use \u0026lt;code\u0026gt;set[Preferred|Maximum|Minimum]Size()\u0026lt;/code\u0026gt; when you could rely on a component\u0026apos;s carefully overridden \u0026lt;code\u0026gt;getPreferred|Maximum|Minimum]Size\u0026lt;/code\u0026gt;, as shown \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt; and below.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Do use \u0026lt;code\u0026gt;set[Preferred|Maximum|Minimum]Size()\u0026lt;/code\u0026gt; to derive post-\u0026lt;code\u0026gt;validate()\u0026lt;/code\u0026gt; geometry, as shown below and \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If a component has no preferred size, e.g. \u0026lt;code\u0026gt;JDesktopPane\u0026lt;/code\u0026gt;, you may have to size the container, but any such choice is arbitrary. A comment may help clarify the intent.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Consider alternate or custom layouts when you find that you would have to loop through many components to obtain derived sizes, as mentioned in these \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280\u0026quot;\u0026gt;comments\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/hYh36.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.awt.Component;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.awt.Dimension;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.awt.EventQueue;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.awt.GridLayout;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.awt.KeyboardFocusManager;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.beans.PropertyChangeEvent;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.beans.PropertyChangeListener;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.ArrayList;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.List;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; javax.swing.JComponent;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; javax.swing.JDesktopPane;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; javax.swing.JFrame;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; javax.swing.JInternalFrame;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; javax.swing.JLabel;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; javax.swing.JPanel;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; javax.swing.JScrollPane;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; javax.swing.JTextField;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; javax.swing.SwingUtilities;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/**\n * \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@see\u0026lt;/span\u0026gt; https://stackoverflow.com/questions/7229226\n * \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@see\u0026lt;/span\u0026gt; https://stackoverflow.com/questions/7228843\n */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;DesignTest\u0026lt;/span\u0026gt; {\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; List\u0026amp;lt;JTextField\u0026amp;gt; list = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;JTextField\u0026amp;gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;JPanel\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;panel\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;JPanel\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;JScrollPane\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;sp\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;JScrollPane\u0026lt;/span\u0026gt;(panel);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String args[])\u0026lt;/span\u0026gt; {\n        EventQueue.invokeLater(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Runnable\u0026lt;/span\u0026gt;() {\n\n            \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Override\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;run\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n                \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;DesignTest\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;DesignTest\u0026lt;/span\u0026gt;();\n                id.create(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;My Project\u0026quot;\u0026lt;/span\u0026gt;);\n            }\n        });\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;addField\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String name)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;JTextField\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;jtf\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;JTextField\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;16\u0026lt;/span\u0026gt;);\n        panel.add(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;JLabel\u0026lt;/span\u0026gt;(name, JLabel.LEFT));\n        panel.add(jtf);\n        list.add(jtf);\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;create\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String strProjectName)\u0026lt;/span\u0026gt; {\n        panel.setLayout(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;GridLayout\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;));\n        addField(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;First Name:\u0026quot;\u0026lt;/span\u0026gt;);\n        addField(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Last Name:\u0026quot;\u0026lt;/span\u0026gt;);\n        addField(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Address:\u0026quot;\u0026lt;/span\u0026gt;);\n        addField(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;City:\u0026quot;\u0026lt;/span\u0026gt;);\n        addField(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Zip Code:\u0026quot;\u0026lt;/span\u0026gt;);\n        addField(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Phone:\u0026quot;\u0026lt;/span\u0026gt;);\n        addField(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Email Id:\u0026quot;\u0026lt;/span\u0026gt;);\n        KeyboardFocusManager.getCurrentKeyboardFocusManager()\n            .addPropertyChangeListener(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;permanentFocusOwner\u0026quot;\u0026lt;/span\u0026gt;,\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;FocusDrivenScroller\u0026lt;/span\u0026gt;(panel));\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Show half the fields\u0026lt;/span\u0026gt;\n        sp.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);\n        sp.validate();\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Dimension\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;d\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; sp.getPreferredSize();\n        d.setSize(d.width, d.height / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;);\n        sp.setPreferredSize(d);\n\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;JInternalFrame\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;internaFrame\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;JInternalFrame\u0026lt;/span\u0026gt;();\n        internaFrame.add(sp);\n        internaFrame.pack();\n        internaFrame.setVisible(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;);\n\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;JDesktopPane\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;desktopPane\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;JDesktopPane\u0026lt;/span\u0026gt;();\n        desktopPane.add(internaFrame);\n\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;JFrame\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;frmtest\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;JFrame\u0026lt;/span\u0026gt;();\n        frmtest.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frmtest.add(desktopPane);\n        frmtest.pack();\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// User\u0026apos;s preference should be read from java.util.prefs.Preferences\u0026lt;/span\u0026gt;\n        frmtest.setSize(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;400\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;300\u0026lt;/span\u0026gt;);\n        frmtest.setLocationRelativeTo(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;);\n        frmtest.setVisible(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;);\n        list.get(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;).requestFocusInWindow();\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;FocusDrivenScroller\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;implements\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;PropertyChangeListener\u0026lt;/span\u0026gt; {\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; JComponent parent;\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;FocusDrivenScroller\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(JComponent parent)\u0026lt;/span\u0026gt; {\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.parent = parent;\n        }\n\n        \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Override\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;propertyChange\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(PropertyChangeEvent evt)\u0026lt;/span\u0026gt; {\n            \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Component\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;focused\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; (Component) evt.getNewValue();\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (focused != \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;\n                \u0026amp;amp;\u0026amp;amp; SwingUtilities.isDescendingFrom(focused, parent)) {\n                parent.scrollRectToVisible(focused.getBounds());\n            }\n        }\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Should I completely avoid the use of those methods?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;No, there is no formal evidence to suggest calling or overriding these methods is not allowed. In fact, Oracle says these methods are used for giving size hints: \u0026lt;a href=\u0026quot;http://docs.oracle.com/javase/tutorial/uiswing/layout/using.html#sizealignment\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://docs.oracle.com/javase/tutorial/uiswing/layout/using.html#sizealignment\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;They may also be overridden (which is the best practice for Swing) when \u0026lt;em\u0026gt;extending\u0026lt;/em\u0026gt; a Swing component (rather than calling the method on the custom component instance)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Most importantly no matter how you specify your component\u0026apos;s size, be sure that your component\u0026apos;s container uses a layout manager that respects the requested size of the component. \u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The methods have been defined for a reason. So when should I use them?\n  In which context? For what purposes?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;When you need to provide customized size hints to the containers Layout manager so that the component will be laid out well\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;What exactly are the negative consequences of using those methods? (I\n  can only think to add portability between systems with different\n  screen resolution).\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Many layout managers do not pay attention to a component\u0026apos;s requested maximum size. However, \u0026lt;code\u0026gt;BoxLayout\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;SpringLayout\u0026lt;/code\u0026gt; do. Furthermore, \u0026lt;code\u0026gt;GroupLayout\u0026lt;/code\u0026gt; provides the ability to set the minimum, preferred or maximum size explicitly, without touching the component.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Make sure that you really need to set the component\u0026apos;s exact size. Each Swing component has a different preferred size, depending on the font it uses and the look and feel. Thus having a set size might produce varied \u0026lt;em\u0026gt;looks\u0026lt;/em\u0026gt; of the UI on different Systems\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;sometimes problems can be encountered with \u0026lt;code\u0026gt;GridBagLayout\u0026lt;/code\u0026gt; and text fields, wherein if the size of the container is smaller than the preferred size, the minimum size gets used, which can cause text fields to shrink quite substantially.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;JFrame\u0026lt;/code\u0026gt; does not enforce overriden \u0026lt;code\u0026gt;getMinimumSize()\u0026lt;/code\u0026gt; only calling \u0026lt;code\u0026gt;setMinimumSize(..)\u0026lt;/code\u0026gt; on its works\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;I don\u0026apos;t think any LayoutManager can exactly satisfy all desired layout\n  needs. Do I really need to implement a new LayoutManager for every\n  little variation on my layout?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;If by implementing you mean using then yes. Not one \u0026lt;code\u0026gt;LayoutManger\u0026lt;/code\u0026gt; can handle everything, each \u0026lt;code\u0026gt;LayoutManager\u0026lt;/code\u0026gt; has its pros and cons thus each can be used together to produce the final layout.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Reference:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://docs.oracle.com/javase/tutorial/uiswing/layout/problems.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://docs.oracle.com/javase/tutorial/uiswing/layout/problems.html\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are a lot of good answers here but I want to add a little more about the reasons \u0026lt;em\u0026gt;why\u0026lt;/em\u0026gt; you should normally avoid these (the question just came up again in a duplicate topic):\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;With few exceptions, if you are using these methods you are probably fine-tuning your GUI to look good on a specific look-and-feel (and with your system-specific settings, e.g. your preferred desktop font, etc.). The methods themselves aren\u0026apos;t inherently evil, but the typical reasons for using them \u0026lt;em\u0026gt;are\u0026lt;/em\u0026gt;. As soon as you start tuning pixel positions and sizes in a layout you run the risk of your GUI breaking (or at minimum, looking bad), on other platforms.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As an example of this, try changing your application\u0026apos;s default look-and-feel. Even just with the options available on your platform, you may be surprised at how poorly the results can be rendered.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So, in the name of keeping your GUI functional and nice-looking on all platforms (remember, one of the major benefits of Java is its cross-platformness), you should rely on layout managers, etc., to automatically adjust the sizes of your components so that it renders correctly outside of your specific development environment.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;All that said, you can certainly conceive of situations where these methods are justified. Again, they aren\u0026apos;t inherently evil, but their usage is normally a \u0026lt;strong\u0026gt;big\u0026lt;/strong\u0026gt; red flag indicating potential GUI issues. Just make sure you are aware of the high potential for complications if/when you use them, and always try and think if there is another look-and-feel-independent solution to your problems -- more often than not you will find that these methods are not necessary.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;By the way, if you find yourself getting frustrated with standard layout managers, there are a lot of good free, open-source third-party ones, for example \u0026lt;a href=\u0026quot;http://www.jgoodies.com/freeware/libraries/forms/\u0026quot;\u0026gt;JGoodies\u0026apos; \u0026lt;code\u0026gt;FormLayout\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;, or \u0026lt;a href=\u0026quot;http://www.miglayout.com/\u0026quot;\u0026gt;\u0026lt;code\u0026gt;MigLayout\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;. Some GUI builders even have built-in support for third-party layout managers -- Eclipse\u0026apos;s WindowBuilder GUI editor, for example, ships with support for \u0026lt;code\u0026gt;FormLayout\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;MigLayout\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you are having trouble with layouts in Java Swing, then I can highly recommend the JGoodies \u0026lt;code\u0026gt;FormLayout\u0026lt;/code\u0026gt; provided freely as part of the Forms freeware library by Karsten Lentzsch \u0026lt;a href=\u0026quot;http://www.jgoodies.com/freeware/libraries/forms/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This very popular layout manager is extremely flexible, allowing for very polished Java UIs to be developed.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You\u0026apos;ll find Karsten\u0026apos;s documentation in \u0026lt;a href=\u0026quot;http://manual.openestate.org/extern/forms-1.2.1/tutorial/introduction.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt;, and some rather good documentation from eclipse \u0026lt;a href=\u0026quot;http://help.eclipse.org/oxygen/topic/org.eclipse.wb.swing.doc.user/html/layoutmanagers/swing/jgoodies_formlayout.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;These methods are poorly understood by most people. You should absolutely not ignore these methods. It is up to the layout manager if they honor these methods. This page has a table that shows which layout managers honor which of those methods:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://thebadprogrammer.com/swing-layout-manager-sizing/\u0026quot;\u0026gt;http://thebadprogrammer.com/swing-layout-manager-sizing/\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I have been writing Swing code for 8+ years and the layout managers included in the JDK have always served my needs. I have never needed a 3rd party layout manager to achieve my layouts.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I will say that you shouldn\u0026apos;t try to give the layout manager hints with these methods until you are sure you need them. Do your layout without giving any sizing hints (i.e. let the layout manager do its job) and then you can make minor corrections if you need to.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;In a situation where I need to define proportions between children of a Component (child 1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom layout manager?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Maybe \u0026lt;code\u0026gt;GridBagLayout\u0026lt;/code\u0026gt; would satisfy your needs. Besides that, there\u0026apos;s a ton of layout managers on the web, and I bet there\u0026apos;s one that fits your requirements.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I am seeing it differenty than the accepted answer.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;1) Should I completely avoid the use of those methods?\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Never avoid! They\u0026apos;re there to express the size constraints of your components to the layout manager. You can avoid using them if you\u0026apos;re not using any layout manager and try to manage the visual layout on your own.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Unfortunately, Swing is not coming with reasonable default dimensions. However, instead of setting the dimensions of a component, it is better OOP to descend your own component with reasonable defaults. (In that case you call setXXX in your descendant class.) Alternatively, you can override the getXXX methods for the same effect.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;2) The methods have been defined for a reason. So when should I use them? In which context? For what purposes?\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Always. When you create a component, set its realistic min/preferred/max size according to the use of that component. For example, if you have a JTextField for entering country symbols such as UK, its preferred size shall be as wide to fit two chars (with the current font, etc.) but probably it is meaningless to let it grow any bigger. After all, country symbols are two chars.\nAs opposite, if you have a JTextField for entering e.g. a customer name, it can have a preferred size for like the pixel size for 20 chars, but can grow to bigger if the layout is resized, so set the maximum size to more. At the same time, having a 0px wide JTextField is pointless, so set a realistic minimum size (I would say the pixel size of 2 chars).\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;3) What exactly are the negative consequences of using those methods?\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;(I can only think adding portability between systems with different screen resolution).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;No negative consequences. These are hints for the layout manager.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;4) I don\u0026apos;t think any LayoutManager can exactly satisfy all desired layout needs.\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Do I really need to implement a new LayoutManager for every little variation on my layout ?\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;No, definitely not. The usual approach is to cascade different basic layoutmanagers such as horizontal and vertical layout.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For example, the layout below:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026amp;lt;pre\u0026amp;gt;\n+--------------+--------+\n| ###JTABLE### | [Add]  | \n| ...data...   |[Remove]|\n| ...data...   |        |\n| ...data...   |        |\n+--------------+--------+\n\u0026amp;lt;/pre\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;is having two parts. The left and right parts are a horizontal layout. The right part is a JPanel added to the horizontal layout, and this JPanel is having a vertical layout which lays out the buttons vertically.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Of course, this can grow tricky with a real life layout. Therefore grid-based layout managers such as MigLayout are much better if you\u0026apos;re about to develop anything serious.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;5) If the answer to 4 is \u0026quot;yes\u0026quot;, won\u0026apos;t this lead to a proliferation of LayoutManager classes which will become difficult to maintain?\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;No, you definitely shall not develop layout managers, unless you need something very special.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;6) In a situation where I need to define proportions...\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;between children of a Component (eg, child1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom LayoutManager?\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Basically, once the preferred sizes are set right, you may not want to do anything in percentage. Simply, because percentages are pointless (e.g. it is pointless to have a JTextField 10% of the window size - since one can shrink the window so that JTextField becomes 0px wide, or can expand the window so that the JTextField is across two displays on a multi-display setup).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;But, may times you may use the percentages to control sizes of bigger building blocks of your gui (panels, for example).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;You can use JSplitPane where you can pre-set the ratio of the two sides. Or, you can use MigLayout which allows you to set such constraints in percentage, pixels, and other units.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Should I completely avoid the use of those methods?\u0026lt;/strong\u0026gt;\nI wouldn\u0026apos;t say \u0026quot;avoid\u0026quot; them. I\u0026apos;d say that if you think you need them, you\u0026apos;re probably doing something wrong. Component sizes are determined in context. For example, Text component sizes are determined by the number of rows and columns you specify, combined with the font you may have chosen. Your button and label size will be the size of the graphic, if you set one, or the space needed to display the text you set. Each component has a natural size, and the layout managers will use those to lay everything out without you needing to specify sizes. The main exception is the JScrollPane, which has a size independent of whatever it contains. For those, I will sometimes call \u0026lt;code\u0026gt;setSize()\u0026lt;/code\u0026gt;, and let that size determine the initial window size, by calling \u0026lt;code\u0026gt;JFrame.pack()\u0026lt;/code\u0026gt;. Usually, I will let the window size determine the JScrollPane size. The user will determine the size of the window. Many layout managers ignore the sizes you set anyway, so they often don\u0026apos;t do much good.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;The methods have been defined for a reason. So when should I use them? In which context? For what purposes?\u0026lt;/strong\u0026gt;\nI believe they were added to provide hints to the layout managers. They may have been written for historical reasons, because layout managers were new, and people didn\u0026apos;t fully trust them. I know a few developers who avoided layout managers and placed everything manually, just because they didn\u0026apos;t want to bother with learning a new paradigm. It\u0026apos;s a terrible idea.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;What exactly are the negative consequences of using those methods? (I can only think adding portability between systems with different screen resolution).\u0026lt;/strong\u0026gt;\nThey\u0026apos;re ineffective, and they produce bad layouts, with objects getting squeezed or stretched to non-natural sizes. And the layouts will be brittle. Changes to the window size will sometimes break the layout and put things in the wrong places.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;I don\u0026apos;t think any LayoutManager can exactly satisfy all desired layout needs. Do I really need to implement a new LayoutManager for every little variation on my layout ?\u0026lt;/strong\u0026gt; You shouldn\u0026apos;t \u0026quot;implement\u0026quot; a new LayoutManager. You should instantiate existing ones. I often use several layout managers in a single window. Each JPanel will have its own layout manager. Some people balk at nested layouts, because they\u0026apos;re hard to maintain. When I use them, I give each one its own creation method to make it easier to see what each one does. But I never \u0026quot;implement\u0026quot; a layout manager. I just instantiate them. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;If the answer to 4 is \u0026quot;yes\u0026quot;, won\u0026apos;t this lead to a proliferation of LayoutManager classes which will become difficult to maintain?\u0026lt;/strong\u0026gt;\nIf you\u0026apos;re implementing new layout manager classes for slight variations in layout, you\u0026apos;re using them wrong. If you\u0026apos;re just implementing new layout managers, you\u0026apos;re probably doing something wrong. The only time I\u0026apos;ve extended a LayoutManager class, it was to add a zoom slider to a JScrollPane.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;In a situation where I need to define proportions between children of a Component (eg, child1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom LayoutManager?\u0026lt;/strong\u0026gt;\nThe JSplitPane has a way of specifying the percentage each component should get. The divider is movable by default, but you can turn that off if you want. I don\u0026apos;t use that feature much. I usually have some components that take up a set size, and the rest of the space is taken up by a scroll pane. The scroll pane size will adjust with the window size. If you have two scroll panes side by side, you can put them in a JSplitPane and specify the percentage of new space given to each one as the user expands and contracts the windows.\u0026lt;/p\u0026gt;\n    "],"id":106,"title":"Should I avoid the use of set(Preferred|Maximum|Minimum)Size methods in Java Swing?","content":"\n                \n\u0026lt;p\u0026gt;Several times I\u0026apos;ve been criticized for having suggested the use of the following methods:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;setPreferredSize\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;setMinimumSize\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;setMaximumSize\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;on \u0026lt;code\u0026gt;Swing\u0026lt;/code\u0026gt; components. I don\u0026apos;t see any alternative to their use when I want to define proportions between displayed components. I have been told this:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;With layouts the answer is always the same: use a suitable\n  LayoutManager\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;I have searched the web a little bit, but I haven\u0026apos;t found any comprehensive analysis of the subject. So I have the following questions:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Should I completely avoid the use of those methods?\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The methods have been defined for a reason. So when should I use them? In which context? For what purposes? \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;What exactly are the negative consequences of using those methods? (I can only think adding portability between systems with different screen resolution).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;I don\u0026apos;t think any LayoutManager can exactly satisfy all desired layout needs. Do I really need to implement a new LayoutManager for every little variation on my layout ? \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the answer to 4 is \u0026quot;yes\u0026quot;, won\u0026apos;t this lead to a proliferation of LayoutManager classes which will become difficult to maintain?\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;In a situation where I need to define proportions between children of a Component (eg, child1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom LayoutManager?\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n    ","slug":"should-i-avoid-the-use-of-set(preferredormaximumorminimum)size-methods-in-java-swing-1657384628399","postType":"QUESTION","createdAt":"2022-07-09T16:37:08.000Z","updatedAt":"2022-07-09T16:37:08.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"Why does a RegExp with global flag give wrong results?","slug":"why-does-a-regexp-with-global-flag-give-wrong-results-1657387788550"},{"title":"Sort a Map\u003cKey, Value\u003e by values","slug":"sort-a-maplesskey-valuegreater-by-values-1657387443904"},{"title":"What is the difference between client-side and server-side programming?","slug":"what-is-the-difference-between-client-side-and-server-side-programming-1657384372926"},{"title":"Performance optimization strategies of last resort [closed]","slug":"performance-optimization-strategies-of-last-resort-closed-1657388420614"},{"title":"Retrieving the last record in each group - MySQL","slug":"retrieving-the-last-record-in-each-group-mysql-1657384887369"},{"title":"XMLHttpRequest cannot load XXX No 'Access-Control-Allow-Origin' header","slug":"xmlhttprequest-cannot-load-xxx-no-'access-control-allow-origin'-header-1657384758362"},{"title":"Is there a CSS parent selector?","slug":"is-there-a-css-parent-selector-1657384430692"},{"title":"What's the meaning of \"=\u003e\" (an arrow formed from equals \u0026 greater than) in JavaScript?","slug":"what's-the-meaning-of-\"greater\"-(an-arrow-formed-from-equals-and-greater-than)-in-javascript-1657387977118"},{"title":"UnboundLocalError on local variable when reassigned after first use","slug":"unboundlocalerror-on-local-variable-when-reassigned-after-first-use-1657387685248"},{"title":"Selecting and manipulating CSS pseudo-elements such as ::before and ::after using javascript (or jQuery)","slug":"selecting-and-manipulating-css-pseudo-elements-such-as-::before-and-::after-using-javascript-(or-jquery)-1657387406132"},{"title":"PHP code is not being executed, but the code shows in the browser source code","slug":"php-code-is-not-being-executed-but-the-code-shows-in-the-browser-source-code-1657384553581"},{"title":"Grouping functions (tapply, by, aggregate) and the *apply family","slug":"grouping-functions-(tapply-by-aggregate)-and-the-*apply-family-1657387844286"},{"title":"Actual meaning of 'shell=True' in subprocess","slug":"actual-meaning-of-'shelltrue'-in-subprocess-1657388470341"},{"title":"Copy array by value","slug":"copy-array-by-value-1657387649531"},{"title":"Why is 24.0000 not equal to 24.0000 in MATLAB?","slug":"why-is-24.0000-not-equal-to-24.0000-in-matlab-1657388376753"},{"title":"How do I pass data between Activities in Android application?","slug":"how-do-i-pass-data-between-activities-in-android-application-1657384739839"},{"title":"How do I use reflection to call a generic method?","slug":"how-do-i-use-reflection-to-call-a-generic-method-1657387256751"},{"title":"Accessing nested JavaScript objects and arrays by string path","slug":"accessing-nested-javascript-objects-and-arrays-by-string-path-1657387321754"},{"title":"What is a raw type and why shouldn't we use it?","slug":"what-is-a-raw-type-and-why-shouldn't-we-use-it-1657384481079"},{"title":"Split comma-separated strings in a column into separate rows","slug":"split-comma-separated-strings-in-a-column-into-separate-rows-1657387785823"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"should-i-avoid-the-use-of-set(preferredormaximumorminimum)size-methods-in-java-swing-1657384628399"},"buildId":"BnkbnjkWYxefPXjTJLVVv","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>