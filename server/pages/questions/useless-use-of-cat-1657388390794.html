<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>Useless use of cat? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="This is probably in many FAQs - instead of using:

cat file | command


(which is called useless use of cat), correct way supposed to be:

command &lt; file


In the 2nd, &quot;correct&quot; way - OS does not have to spawn an extra process.
Despite knowing that, I continued to use useless cat for 2 reasons.


more aesthetic - I like when data moves uniformly only from left to right. And it easier to replace cat with something else (gzcat, echo, ...), add a 2nd file or insert new filter (pv, mbuffer, grep ...).
I &quot;felt&quot; that it might be faster in some cases.  Faster because there are 2 processes, 1st (cat) does the reading and the second does whatever.   And they can run in parallel, which means sometimes faster execution.


Is my logic correct (for 2nd reason)?
    "/><meta property="og:title" content="Useless use of cat? | Solutions Checker"/><meta property="og:description" content="This is probably in many FAQs - instead of using:

cat file | command


(which is called useless use of cat), correct way supposed to be:

command &lt; file


In the 2nd, &quot;correct&quot; way - OS does not have to spawn an extra process.
Despite knowing that, I continued to use useless cat for 2 reasons.


more aesthetic - I like when data moves uniformly only from left to right. And it easier to replace cat with something else (gzcat, echo, ...), add a 2nd file or insert new filter (pv, mbuffer, grep ...).
I &quot;felt&quot; that it might be faster in some cases.  Faster because there are 2 processes, 1st (cat) does the reading and the second does whatever.   And they can run in parallel, which means sometimes faster execution.


Is my logic correct (for 2nd reason)?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Useless use of cat?","text":"This is probably in many FAQs - instead of using:\n\ncat file | command\n\n\n(which is called useless use of cat), correct way supposed to be:\n\ncommand &lt; file\n\n\nIn the 2nd, &quot;correct&quot; way - OS does not have to spawn an extra process.\nDespite knowing that, I continued to use useless cat for 2 reasons.\n\n\nmore aesthetic - I like when data moves uniformly only from left to right. And it easier to replace cat with something else (gzcat, echo, ...), add a 2nd file or insert new filter (pv, mbuffer, grep ...).\nI &quot;felt&quot; that it might be faster in some cases.  Faster because there are 2 processes, 1st (cat) does the reading and the second does whatever.   And they can run in parallel, which means sometimes faster execution.\n\n\nIs my logic correct (for 2nd reason)?\n    ","answerCount":9,"upVoteCount":500,"suggestedAnswer":[{"text":"I was not aware of the award until today when some rookie tried to pin the UUOC on me for one of my answers. It was a cat file.txt | grep foo | cut ... | cut .... I gave him a piece of my mind, and only after doing so visited the link he gave me referring to the origins of the award and the practice of doing so. Further searching led me to this question. Somewhat unfortunately despite conscious consideration, none of the answers included my rationale.\n\nI had not meant to be defensive in responding to him. After all, in my younger years, I would have written the command as grep foo file.txt | cut ... | cut ... because whenever you do the frequent single greps you learn the placement of the file argument and it is ready knowledge that the first is the pattern and the later ones are file names.\n\nIt was a conscious choice to use cat when I answered the question, partly because of a reason of &quot;good taste&quot; (in the words of Linus Torvalds) but chiefly for a compelling reason of function.\n\nThe latter reason is more important so I will put it out first. When I offer a pipeline as a solution I expect it to be reusable. It is quite likely that a pipeline would be added at the end of or spliced into another pipeline. In that case having a file argument to grep screws up reusability, and quite possibly do so silently without an error message if the file argument exists. I. e. grep foo xyz | grep bar xyz | wc will give you how many lines in xyz contain bar while you are expecting the number of lines that contain both foo and bar. Having to change arguments to a command in a pipeline before using it is prone to errors. Add to it the possibility of silent failures and it becomes a particularly insidious practice.\n\nThe former reason is not unimportant either since a lot of &quot;good taste&quot;\n merely is an intuitive subconscious rationale for things like the silent failures above that you cannot think of right at the moment when some person in need of education says &quot;but isn&apos;t that cat useless&quot;.\n\nHowever, I will try to also make conscious the former &quot;good taste&quot; reason I mentioned. That reason has to do with the orthogonal design spirit of Unix. grep does not cut and ls does not grep. Therefore at the very least grep foo file1 file2 file3 goes against the design spirit. The orthogonal way of doing it is cat file1 file2 file3 | grep foo. Now, grep foo file1 is merely a special case of grep foo file1 file2 file3, and if you do not treat it the same you are at least using up brain clock cycles trying to avoid the useless cat award.\n\nThat leads us to the argument that grep foo file1 file2 file3 is concatenating, and cat concatenates so it is proper to cat file1 file2 file3 but because cat is not concatenating in cat file1 | grep foo therefore we are violating the spirit of both the cat and the almighty Unix. Well, if that were the case then Unix would need a different command to read the output of one file and spit it to stdout (not paginate it or anything just a pure spit to stdout). So you would have the situation where you say cat file1 file2 or you say dog file1 and conscientiously remember to avoid cat file1 to avoid getting the award, while also avoiding dog file1 file2 since hopefully the design of dog would throw an error if multiple files are specified.\n\nHopefully, at this point, you sympathize with the Unix designers for not including a separate command to spit a file to stdout, while also naming cat for concatenate rather than giving it some other name. &lt;edit&gt; removed incorrect comments on &lt;, in fact, &lt; is an efficient no-copy facility to spit a file to stdout which you can position at the beginning of a pipeline so the Unix designers did include something specifically for this &lt;/edit&gt;\n\nThe next question is why is it important to have commands that merely spit a file or the concatenation of several files to stdout, without any further processing? One reason is to avoid having every single Unix command that operates on standard input to know how to parse at least one command line file argument and use it as input if it exists. The second reason is to avoid users having to remember: (a) where the filename arguments go; and (b) avoid the silent pipeline bug as mentioned above.\n\nThat brings us to why grep does have the extra logic. The rationale is to allow user-fluency for commands that are used frequently and on a stand-alone basis (rather than as a pipeline). It is a slight compromise of orthogonality for a significant gain in usability. Not all commands should be designed this way and commands that are not frequently used should completely avoid the extra logic of file arguments (remember extra logic leads to unnecessary fragility (the possibility of a bug)). The exception is to allow file arguments like in the case of grep. (By the way, note that ls has a completely different reason to not just accept but pretty much require file arguments)\n\nFinally, what could have been done better is if such exceptional commands as grep (but not necessarily ls) generate an error if the standard input is also available when file arguments are specified.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"Nope! \n\nFirst of all, it doesn&apos;t matter where in a command the redirection happens. So if you like your redirection to the left of your command, that&apos;s fine:\n\n&lt; somefile command\n\n\nis the same as\n\ncommand &lt; somefile\n\n\nSecond, there are n + 1 processes and a subshell happening when you use a pipe. It is most decidedly slower. In some cases n would&apos;ve been zero (for example, when you&apos;re redirecting to a shell builtin), so by using cat you&apos;re adding a new process entirely unnecessarily.\n\nAs a generalization, whenever you find yourself using a pipe it&apos;s worth taking 30 seconds to see if you can eliminate it. (But probably not worth taking much longer than 30 seconds.) Here are some examples where pipes and processes are frequently used unnecessarily:\n\nfor word in $(cat somefile);  # for word in $(&lt;somefile);  (or better yet, while read &lt; somefile)\n\ngrep something | awk stuff; # awk &apos;/something/ stuff&apos; (similar for sed)\n\necho something | command; # command &lt;&lt;&lt; something (although echo would be necessary for pure POSIX)\n\n\nFeel free to edit to add more examples.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"In defense of cat:\nYes,\n   &lt; input process &gt; output \n\nor\n   process &lt; input &gt; output \n\nis more efficient, but many invocations don&apos;t have performance issues, so you don&apos;t care.\nergonomic reasons:\nWe are used to read from left to right, so a command like\n    cat infile | process1 | process2 &gt; outfile\n\nis trivial to understand.\n    process1 &lt; infile | process2 &gt; outfile\n\nhas to jump over process1, and then read left to right. This can be healed by:\n    &lt; infile process1 | process2 &gt; outfile\n\nlooks somehow, as if there were an arrow pointing to the left, where nothing is. More confusing and looking like fancy quoting is:\n    process1 &gt; outfile &lt; infile\n\nand generating scripts is often an iterative process,\n    cat file \n    cat file | process1\n    cat file | process1 | process2 \n    cat file | process1 | process2 &gt; outfile\n\nwhere you see your progress stepwise, while\n    &lt; file \n\nnot even works. Simple ways are less error prone and ergonomic command catenation is simple with cat.\nAnother topic is, that most people were exposed to &gt; and &lt; as comparison operators, long before using a computer and when using a computer as programmers, are far more often exposed to these as such.\nAnd comparing two operands with &lt; and &gt; is contra commutative, which means\n(a &gt; b) == (b &lt; a)\n\nI remember the first time using &lt; for input redirection, I feared\na.sh &lt; file \n\ncould mean the same as\nfile &gt; a.sh\n\nand somehow overwrite my a.sh script. Maybe this is an issue for many beginners.\nrare differences\nwc -c journal.txt\n15666 journal.txt\ncat journal.txt | wc -c \n15666\n\nThe latter can be used in calculations directly.\nfactor $(cat journal.txt | wc -c)\n\nOf course the &lt; can be used here too, instead of a file parameter:\n&lt; journal.txt wc -c \n15666\nwc -c &lt; journal.txt\n15666\n    \n\nbut who cares - 15k?\nIf I would run occasionally into issues, surely I would change my habit of invocing cat.\nWhen using very large or many, many files, avoiding cat is fine. To most questions the use of cat is orthogonal, off topic, not an issue.\nStarting these useless useless use of cat discussion on every second shell topic is only annoying and boring. Get a life and wait for your minute of fame, when dealing with performance questions.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"I disagree with most instances of the excessively smug UUOC Award because, when teaching someone else, cat is a convenient place-holder for any command or crusty complicated pipeline of commands that produce output suitable for the problem or task being discussed.\n\nThis is especially true on sites like Stack Overflow, ServerFault, Unix &amp; Linux or any of the SE sites.\n\nIf someone specifically asks about optimisation, or if you feel like adding extra information about it then, great, talk about how using cat is inefficient.  But don&apos;t berate people because they chose to aim for simplicity and ease-of-understanding in their examples rather than look-at-me-how-cool-am-i! complexity.\n\nIn short, because cat isn&apos;t always cat.\n\nAlso because most people who enjoy going around awarding UUOCs do it because they&apos;re more concerned with showing off about how &apos;clever&apos; they are than they are about helping or teaching people.  In reality, they demonstrate that they&apos;re probably just another newbie who has found a tiny stick to beat their peers with.\n\n\n\nUpdate\n\nHere&apos;s another UUOC that I posted in an answer at https://unix.stackexchange.com/a/301194/7696:\n\nsqlq() {\n  local filter\n  filter=&apos;cat&apos;\n\n  # very primitive, use getopts for real option handling.\n  if [ &quot;$1&quot; == &quot;--delete-blank-lines&quot; ] ; then\n    filter=&apos;grep -v &quot;^$&quot;&apos;\n    shift\n  fi\n\n  # each arg is piped into sqlplus as a separate command\n  printf &quot;%s\\n&quot; &quot;$@&quot; | sqlplus -S sss/eee@sid | $filter\n}\n\n\nUUOC pedants would say that that&apos;s a UUOC because it&apos;s easily possible to make $filter default to the empty string and have the if statement do filter=&apos;| grep -v &quot;^$&quot;&apos; but IMO, by not embedding the pipe character in $filter, this &quot;useless&quot; cat serves the extremely useful purpose of self-documenting the fact that $filter on the printf line isn&apos;t just another argument to sqlplus, it&apos;s an optional user-selectable output filter.\n\nIf there&apos;s any need to have multiple optional output filters, the option processing could just append | whatever to $filter as often as needed - one extra cat in the pipeline isn&apos;t going to hurt anything or cause any noticeable loss of performance.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"With the UUoC version, cat has to read the file into memory, then write it out to the pipe, and the command has to read the data from the pipe, so the kernel has to copy the whole file three times whereas in the redirected case, the kernel only has to copy the file once.  It is quicker to do something once than to do it three times.\n\nUsing:\n\ncat &quot;$@&quot; | command\n\n\nis a wholly different and not necessarily useless use of cat.  It is still useless if the command is a standard filter that accepts zero or more filename arguments and processes them in turn.  Consider the tr command: it is a pure filter that ignores or rejects filename arguments.  To feed multiple files to it, you have to use cat as shown.  (Of course, there&apos;s a separate discussion that the design of tr is not very good; there&apos;s no real reason it could not have been designed as a standard filter.)  This might also be valid if you want the command to treat all the input as a single file rather than as multiple separate files, even if the command would accept multiple separate files: for example, wc is such a command.\n\nIt is the cat single-file case that is unconditionally useless.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"An additional problem is that the pipe can silently mask a subshell. For this example, I&apos;ll replace cat with echo, but the same problem exists.\n\necho &quot;foo&quot; | while read line; do\n    x=$line\ndone\n\necho &quot;$x&quot;\n\n\nYou might expect x to contain foo, but it doesn&apos;t. The x you set was in a subshell spawned to execute the while loop. x in the shell that started the pipeline has an unrelated value, or is not set at all.\n\nIn bash4, you can configure some shell options so that the last command of a pipeline executes in the same shell as the one that starts the pipeline, but then you might try this\n\necho &quot;foo&quot; | while read line; do\n    x=$line\ndone | awk &apos;...&apos;\n\n\nand x is once again local to the while&apos;s subshell.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"As someone who regularly points out this and a number of other shell programming antipatterns, I feel obliged to, belatedly, weigh in.\n\nShell script is very much a copy/paste language. For most people who write shell scripts, they are not in it to learn the language; it&apos;s just an obstacle they have to overcome in order to continue to do things in the language(s) they are actually somewhat familiar with.\n\nIn that context, I see it as disruptive and potentially even destructive to propagate various shell scripting anti-patterns.  The code that someone finds on Stack Overflow should ideally be possible to copy/paste into their  environment with minimal changes, and incomplete understanding.\n\nAmong the many shell scripting resources on the net, Stack Overflow is unusual in that users can help shape the quality of the site by editing the questions and answers on the site.  However, code edits can be problematic because it&apos;s easy to make changes which were not intended by the code author.  Hence, we tend to leave comments to suggest changes to the code.\n\nThe UUCA and related antipattern comments are not just for the authors of the code we comment on; they are as much a caveat emptor to help readers of the site become aware of problems in the code they find here.\n\nWe can&apos;t hope to achieve a situation where no answers on Stack Overflow recommend useless cats (or unquoted variables, or chmod 777, or a large variety of other antipattern plagues), but we can at least help educate the user who is about to copy/paste this code into the innermost tight loop of their script which executes millions of times.\n\nAs far as technical reasons go, the traditional wisdom is that we should try to minimize the number of external processes; this continues to hold as a good general guidance when writing shell scripts.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"I often use cat file | myprogram in examples. Sometime I am being accused of Useless use of cat (http://porkmail.org/era/unix/award.html). I disagree for the following reasons:\n\n\nIt is easy to understand what is going on.\n\nWhen reading a UNIX command you expect a command followed by arguments followed by redirection. It is possible to put the redirection anywhere but it is rarely seen - thus people will have a harder time reading the example. I believe\n\ncat foo | program1 -o option -b option | program2\n\n\nis easier to read than\n\nprogram1 -o option -b option &lt; foo | program2\n\n\nIf you move the redirection to the start you are confusing people who are not used to this syntax:\n\n&lt; foo program1 -o option -b option | program2\n\n\nand examples should be easy to understand.\nIt is easy to change.\n\nIf you know the program can read from cat, you can normally assume it can read the output from any program that outputs to STDOUT, and thus you can adapt it for your own needs and get predictable results.\nIt stresses that the program does not fail, if STDIN is not a file.\n\nIt is not safe to assume that if program1 &lt; foo works then cat foo | program1 will also work. However, it is safe to assume the opposite. This program works if STDIN is a file, but fails if the input is a pipe, because it uses seek:\n\n# works\n&lt; foo perl -e &apos;seek(STDIN,1,1) || die;print &lt;STDIN&gt;&apos;\n\n# fails\ncat foo | perl -e &apos;seek(STDIN,1,1) || die;print &lt;STDIN&gt;&apos;\n\n\n\nPerformance cost\n\nThere is a cost of doing the additional cat. To give an idea of how much I ran a few tests to simulate baseline (cat), low throughput (bzip2), medium throughput (gzip), and high throughput (grep).\n\ncat $ISO | cat\n&lt; $ISO cat\ncat $ISO | bzip2\n&lt; $ISO | bzip2\ncat $ISO | gzip\n&lt; $ISO gzip\ncat $ISO | grep no_such_string\n&lt; $ISO grep no_such_string\n\n\nThe tests were run on a low end system (0.6 GHz) and an ordinary laptop (2.2 GHz). They were run 10 times on each system and the best timing was chosen to mimic the optimal situation for each test. The $ISO was ubuntu-11.04-desktop-i386.iso.\n(Prettier tables here: http://oletange.blogspot.com/2013/10/useless-use-of-cat.html)\n\nCPU                       0.6 GHz ARM\nCommand                   cat $ISO|                        &lt;$ISO                            Diff                             Diff (pct)\nThroughput \\ Time (ms)    User       Sys        Real       User       Sys        Real       User       Sys        Real       User       Sys        Real\nBaseline (cat)                     55      14453      33090         23       6937      33126         32       7516        -36        239        208         99\nLow (bzip2)                   1945148      16094    1973754    1941727       5664    1959982       3420      10430      13772        100        284        100\nMedium (gzip)                  413914      13383     431812     407016       5477     416760       6898       7906      15052        101        244        103\nHigh (grep no_such_string)      80656      15133      99049      79180       4336      86885       1476      10797      12164        101        349        114\n\nCPU                       Core i7 2.2 GHz\nCommand                   cat $ISO|           &lt;$ISO             Diff          Diff (pct)\nThroughput \\ Time (ms)    User     Sys Real   User   Sys Real   User Sys Real User       Sys Real\nBaseline (cat)                    0 356    215      1  84     88    0 272  127          0 423  244\nLow (bzip2)                  136184 896 136765 136728 160 137131 -545 736 -366         99 560   99\nMedium (gzip)                 26564 788  26791  26332 108  26492  232 680  298        100 729  101\nHigh (grep no_such_string)      264 392    483    216  84    304   48 308  179        122 466  158\n\n\nThe results show that for low and medium throughput the cost is in the order of 1%. This is well within the uncertainty of the measurements, so in practice there is no difference.\n\nFor high throughput the difference is bigger and there is a clear difference between the two.\n\nThat leads to the conclusion: You should use &lt; instead of cat | if:\n\n\nthe complexity of the processing is similar to a simple grep\nperformance matters more than readability.\n\n\nOtherwise it does not matter whether you use &lt; or cat |.\n\nAnd thus you should only give a UUoC-award if and only if:\n\n\nyou can measure a significant difference in the performance (publish your measurements when you give the award)\nperformance matters more than readability.\n\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"I think that (the traditional way) using pipe is a bit more faster; on my box I used strace command to see what&apos;s going on:\n\nWithout pipe:\n\ntoc@UnixServer:~$ strace wc -l &lt; wrong_output.c\nexecve(&quot;/usr/bin/wc&quot;, [&quot;wc&quot;, &quot;-l&quot;], [/* 18 vars */]) = 0\nbrk(0)                                  = 0x8b50000\naccess(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)\nmmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb77ad000\naccess(&quot;/etc/ld.so.preload&quot;, R_OK)      = -1 ENOENT (No such file or directory)\nopen(&quot;/etc/ld.so.cache&quot;, O_RDONLY)      = 3\nfstat64(3, {st_mode=S_IFREG|0644, st_size=29107, ...}) = 0\nmmap2(NULL, 29107, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb77a5000\nclose(3)                                = 0\naccess(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)\nopen(&quot;/lib/i386-linux-gnu/libc.so.6&quot;, O_RDONLY) = 3\nread(3, &quot;\\177ELF\\1\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\3\\0\\1\\0\\0\\0p\\222\\1\\0004\\0\\0\\0&quot;..., 512) = 512\nfstat64(3, {st_mode=S_IFREG|0755, st_size=1552584, ...}) = 0\nmmap2(NULL, 1563160, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xb7627000\nmmap2(0xb779f000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x178) = 0xb779f000\nmmap2(0xb77a2000, 10776, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb77a2000\nclose(3)                                = 0\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7626000\nset_thread_area({entry_number:-1 -&gt; 6, base_addr:0xb76268d0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0\nmprotect(0xb779f000, 8192, PROT_READ)   = 0\nmprotect(0x804f000, 4096, PROT_READ)    = 0\nmprotect(0xb77ce000, 4096, PROT_READ)   = 0\nmunmap(0xb77a5000, 29107)               = 0\nbrk(0)                                  = 0x8b50000\nbrk(0x8b71000)                          = 0x8b71000\nopen(&quot;/usr/lib/locale/locale-archive&quot;, O_RDONLY|O_LARGEFILE) = 3\nfstat64(3, {st_mode=S_IFREG|0644, st_size=5540198, ...}) = 0\nmmap2(NULL, 2097152, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7426000\nmmap2(NULL, 1507328, PROT_READ, MAP_PRIVATE, 3, 0x2a8) = 0xb72b6000\nclose(3)                                = 0\nopen(&quot;/usr/share/locale/locale.alias&quot;, O_RDONLY) = 3\nfstat64(3, {st_mode=S_IFREG|0644, st_size=2570, ...}) = 0\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb77ac000\nread(3, &quot;# Locale name alias data base.\\n#&quot;..., 4096) = 2570\nread(3, &quot;&quot;, 4096)                       = 0\nclose(3)                                = 0\nmunmap(0xb77ac000, 4096)                = 0\nopen(&quot;/usr/share/locale/fr_FR.UTF-8/LC_MESSAGES/coreutils.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)\nopen(&quot;/usr/share/locale/fr_FR.utf8/LC_MESSAGES/coreutils.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)\nopen(&quot;/usr/share/locale/fr_FR/LC_MESSAGES/coreutils.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)\nopen(&quot;/usr/share/locale/fr.UTF-8/LC_MESSAGES/coreutils.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)\nopen(&quot;/usr/share/locale/fr.utf8/LC_MESSAGES/coreutils.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)\nopen(&quot;/usr/share/locale/fr/LC_MESSAGES/coreutils.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)\nopen(&quot;/usr/share/locale-langpack/fr_FR.UTF-8/LC_MESSAGES/coreutils.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)\nopen(&quot;/usr/share/locale-langpack/fr_FR.utf8/LC_MESSAGES/coreutils.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)\nopen(&quot;/usr/share/locale-langpack/fr_FR/LC_MESSAGES/coreutils.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)\nopen(&quot;/usr/share/locale-langpack/fr.UTF-8/LC_MESSAGES/coreutils.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)\nopen(&quot;/usr/share/locale-langpack/fr.utf8/LC_MESSAGES/coreutils.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)\nopen(&quot;/usr/share/locale-langpack/fr/LC_MESSAGES/coreutils.mo&quot;, O_RDONLY) = 3\nfstat64(3, {st_mode=S_IFREG|0644, st_size=316721, ...}) = 0\nmmap2(NULL, 316721, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7268000\nclose(3)                                = 0\nopen(&quot;/usr/lib/i386-linux-gnu/gconv/gconv-modules.cache&quot;, O_RDONLY) = 3\nfstat64(3, {st_mode=S_IFREG|0644, st_size=26064, ...}) = 0\nmmap2(NULL, 26064, PROT_READ, MAP_SHARED, 3, 0) = 0xb7261000\nclose(3)                                = 0\nread(0, &quot;#include&lt;stdio.h&gt;\\n\\nint main(int &quot;..., 16384) = 180\nread(0, &quot;&quot;, 16384)                      = 0\nfstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 2), ...}) = 0\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7260000\nwrite(1, &quot;13\\n&quot;, 313\n)                     = 3\nclose(0)                                = 0\nclose(1)                                = 0\nmunmap(0xb7260000, 4096)                = 0\nclose(2)                                = 0\nexit_group(0)                           = ?\n\n\nAnd with pipe:\n\ntoc@UnixServer:~$ strace cat wrong_output.c | wc -l\nexecve(&quot;/bin/cat&quot;, [&quot;cat&quot;, &quot;wrong_output.c&quot;], [/* 18 vars */]) = 0\nbrk(0)                                  = 0xa017000\naccess(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)\nmmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb774b000\naccess(&quot;/etc/ld.so.preload&quot;, R_OK)      = -1 ENOENT (No such file or directory)\nopen(&quot;/etc/ld.so.cache&quot;, O_RDONLY)      = 3\nfstat64(3, {st_mode=S_IFREG|0644, st_size=29107, ...}) = 0\nmmap2(NULL, 29107, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7743000\nclose(3)                                = 0\naccess(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)\nopen(&quot;/lib/i386-linux-gnu/libc.so.6&quot;, O_RDONLY) = 3\nread(3, &quot;\\177ELF\\1\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\3\\0\\1\\0\\0\\0p\\222\\1\\0004\\0\\0\\0&quot;..., 512) = 512\nfstat64(3, {st_mode=S_IFREG|0755, st_size=1552584, ...}) = 0\nmmap2(NULL, 1563160, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xb75c5000\nmmap2(0xb773d000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x178) = 0xb773d000\nmmap2(0xb7740000, 10776, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7740000\nclose(3)                                = 0\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb75c4000\nset_thread_area({entry_number:-1 -&gt; 6, base_addr:0xb75c48d0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0\nmprotect(0xb773d000, 8192, PROT_READ)   = 0\nmprotect(0x8051000, 4096, PROT_READ)    = 0\nmprotect(0xb776c000, 4096, PROT_READ)   = 0\nmunmap(0xb7743000, 29107)               = 0\nbrk(0)                                  = 0xa017000\nbrk(0xa038000)                          = 0xa038000\nopen(&quot;/usr/lib/locale/locale-archive&quot;, O_RDONLY|O_LARGEFILE) = 3\nfstat64(3, {st_mode=S_IFREG|0644, st_size=5540198, ...}) = 0\nmmap2(NULL, 2097152, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb73c4000\nmmap2(NULL, 1507328, PROT_READ, MAP_PRIVATE, 3, 0x2a8) = 0xb7254000\nclose(3)                                = 0\nfstat64(1, {st_mode=S_IFIFO|0600, st_size=0, ...}) = 0\nopen(&quot;wrong_output.c&quot;, O_RDONLY|O_LARGEFILE) = 3\nfstat64(3, {st_mode=S_IFREG|0664, st_size=180, ...}) = 0\nread(3, &quot;#include&lt;stdio.h&gt;\\n\\nint main(int &quot;..., 32768) = 180\nwrite(1, &quot;#include&lt;stdio.h&gt;\\n\\nint main(int &quot;..., 180) = 180\nread(3, &quot;&quot;, 32768)                      = 0\nclose(3)                                = 0\nclose(1)                                = 0\nclose(2)                                = 0\nexit_group(0)                           = ?\n13\n\n\nYou can do some testing with strace and time command with more and longer commands for good benchmarking.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-12e9794e898cd5f3.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-928c5d1eb8fb0bba.js" defer=""></script><script src="/_next/static/BnkbnjkWYxefPXjTJLVVv/_buildManifest.js" defer=""></script><script src="/_next/static/BnkbnjkWYxefPXjTJLVVv/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/useless-use-of-cat-1657388390794#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/useless-use-of-cat-1657388390794"><h1>Useless use of cat?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/cat">cat</a></div></div><div class="question-content mt-5">
                
<p>This is probably in many FAQs - instead of using:</p>

<pre class="lang-bash s-code-block"><code class="hljs language-bash"><span class="hljs-built_in">cat</span> file | <span class="hljs-built_in">command</span>
</code></pre>

<p>(which is called useless use of cat), correct way supposed to be:</p>

<pre class="lang-bash s-code-block"><code class="hljs language-bash"><span class="hljs-built_in">command</span> &lt; file
</code></pre>

<p>In the 2nd, "correct" way - OS does not have to spawn an extra process.<br>
Despite knowing that, I continued to use useless cat for 2 reasons.</p>

<ol>
<li><p>more aesthetic - I like when data moves uniformly only from left to right. And it easier to replace <code>cat</code> with something else (<code>gzcat</code>, <code>echo</code>, ...), add a 2nd file or insert new filter (<code>pv</code>, <code>mbuffer</code>, <code>grep</code> ...).</p></li>
<li><p>I "felt" that it might be faster in some cases.  Faster because there are 2 processes, 1st (<code>cat</code>) does the reading and the second does whatever.   And they can run in parallel, which means sometimes faster execution.</p></li>
</ol>

<p>Is my logic correct (for 2nd reason)?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/cat">cat</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I was not aware of the award until today when some rookie tried to pin the <a href="https://en.wikipedia.org/wiki/Cat_(Unix)#Useless_use_of_cat" rel="noreferrer" title="UUOC">UUOC</a> on me for one of my answers. It was a <code>cat file.txt | grep foo | cut ... | cut ...</code>. I gave him a piece of my mind, and only after doing so visited the link he gave me referring to the origins of the award and the practice of doing so. Further searching led me to this question. Somewhat unfortunately despite conscious consideration, none of the answers included my rationale.</p>

<p>I had not meant to be defensive in responding to him. After all, in my younger years, I would have written the command as <code>grep foo file.txt | cut ... | cut ...</code> because whenever you do the frequent single <code>grep</code>s you learn the placement of the file argument and it is ready knowledge that the first is the pattern and the later ones are file names.</p>

<p>It was a conscious choice to use <code>cat</code> when I answered the question, partly because of a reason of "good taste" (in the words of Linus Torvalds) but chiefly for a compelling reason of function.</p>

<p>The latter reason is more important so I will put it out first. When I offer a pipeline as a solution I expect it to be reusable. It is quite likely that a pipeline would be added at the end of or spliced into another pipeline. In that case having a file argument to grep screws up reusability, and quite possibly do so <em>silently</em> without an error message if the file argument exists. I. e. <code>grep foo xyz | grep bar xyz | wc</code> will give you how many lines in <code>xyz</code> contain <code>bar</code> while you are expecting the number of lines that contain both <code>foo</code> and <code>bar</code>. Having to change arguments to a command in a pipeline before using it is prone to errors. Add to it the possibility of silent failures and it becomes a particularly insidious practice.</p>

<p>The former reason is not unimportant either since a lot of "<a href="https://medium.com/@bartobri/applying-the-linus-tarvolds-good-taste-coding-requirement-99749f37684a" rel="noreferrer">good taste</a>"
 merely is an intuitive subconscious rationale for things like the silent failures above that you cannot think of right at the moment when some person in need of education says "but isn't that cat useless".</p>

<p>However, I will try to also make conscious the former "good taste" reason I mentioned. That reason has to do with the orthogonal design spirit of Unix. <code>grep</code> does not <code>cut</code> and <code>ls</code> does not <code>grep</code>. Therefore at the very least <code>grep foo file1 file2 file3</code> goes against the design spirit. The orthogonal way of doing it is <code>cat file1 file2 file3 | grep foo</code>. Now, <code>grep foo file1</code> is merely a special case of <code>grep foo file1 file2 file3</code>, and if you do not treat it the same you are at least using up brain clock cycles trying to avoid the useless cat award.</p>

<p>That leads us to the argument that <code>grep foo file1 file2 file3</code> is concatenating, and <code>cat</code> concatenates so it is proper to <code>cat file1 file2 file3</code> but because <code>cat</code> is not concatenating in <code>cat file1 | grep foo</code> therefore we are violating the spirit of both the <code>cat</code> and the almighty Unix. Well, if that were the case then Unix would need a different command to read the output of one file and spit it to stdout (not paginate it or anything just a pure spit to stdout). So you would have the situation where you say <code>cat file1 file2</code> or you say <code>dog file1</code> and conscientiously remember to avoid <code>cat file1</code> to avoid getting the award, while also avoiding <code>dog file1 file2</code> since hopefully the design of <code>dog</code> would throw an error if multiple files are specified.</p>

<p>Hopefully, at this point, you sympathize with the Unix designers for not including a separate command to spit a file to stdout, while also naming <code>cat</code> for concatenate rather than giving it some other name. <strong><code>&lt;edit&gt;</code></strong> removed incorrect comments on <code>&lt;</code>, in fact, <code>&lt;</code> is an efficient no-copy facility to spit a file to stdout which you can position at the beginning of a pipeline so the Unix designers did include something specifically for this <strong><code>&lt;/edit&gt;</code></strong></p>

<p>The next question is why is it important to have commands that merely spit a file or the concatenation of several files to stdout, without any further processing? One reason is to avoid having every single Unix command that operates on standard input to know how to parse at least one command line file argument and use it as input if it exists. The second reason is to avoid users having to remember: (a) where the filename arguments go; and (b) avoid the silent pipeline bug as mentioned above.</p>

<p>That brings us to why <code>grep</code> does have the extra logic. The rationale is to allow user-fluency for commands that are used frequently and on a <em>stand-alone</em> basis (rather than as a pipeline). It is a slight compromise of orthogonality for a significant gain in usability. Not all commands should be designed this way and commands that are not frequently used should completely avoid the extra logic of file arguments (remember extra logic leads to unnecessary fragility (the possibility of a bug)). The exception is to allow file arguments like in the case of <code>grep</code>. (By the way, note that <code>ls</code> has a completely different reason to not just accept but pretty much require file arguments)</p>

<p>Finally, what could have been done better is if such exceptional commands as <code>grep</code> (but not necessarily <code>ls</code>) generate an error if the standard input is also available when file arguments are specified.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/cat">cat</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Nope! </p>

<p>First of all, it doesn't matter where in a command the redirection happens. So if you like your redirection to the left of your command, that's fine:</p>

<pre class="lang-bash s-code-block"><code class="hljs language-bash">&lt; somefile <span class="hljs-built_in">command</span>
</code></pre>

<p>is the same as</p>

<pre class="lang-bash s-code-block"><code class="hljs language-bash"><span class="hljs-built_in">command</span> &lt; somefile
</code></pre>

<p>Second, there are <em>n + 1</em> processes and a subshell happening when you use a pipe. It is most decidedly slower. In some cases <em>n</em> would've been zero (for example, when you're redirecting to a shell builtin), so by using <code>cat</code> you're adding a new process entirely unnecessarily.</p>

<p>As a generalization, whenever you find yourself using a pipe it's worth taking 30 seconds to see if you can eliminate it. (But probably not worth taking much longer than 30 seconds.) Here are some examples where pipes and processes are frequently used unnecessarily:</p>

<pre class="lang-bash s-code-block"><code class="hljs language-bash"><span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">cat</span> somefile);  <span class="hljs-comment"># for word in $(&lt;somefile);  (or better yet, while read &lt; somefile)</span>

grep something | awk stuff; <span class="hljs-comment"># awk '/something/ stuff' (similar for sed)</span>

<span class="hljs-built_in">echo</span> something | <span class="hljs-built_in">command</span>; <span class="hljs-comment"># command &lt;&lt;&lt; something (although echo would be necessary for pure POSIX)</span>
</code></pre>

<p>Feel free to edit to add more examples.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/cat">cat</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In <strong>defense</strong> of cat:</p>
<p>Yes,</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash">   &lt; input process &gt; output 
</code></pre>
<p>or</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash">   process &lt; input &gt; output 
</code></pre>
<p>is more efficient, but many invocations don't have performance issues, so you don't care.</p>
<h3>ergonomic reasons:</h3>
<p>We are used to read from left to right, so a command like</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash">    <span class="hljs-built_in">cat</span> infile | process1 | process2 &gt; outfile
</code></pre>
<p>is trivial to understand.</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash">    process1 &lt; infile | process2 &gt; outfile
</code></pre>
<p>has to jump over process1, and then read left to right. This can be healed by:</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash">    &lt; infile process1 | process2 &gt; outfile
</code></pre>
<p>looks somehow, as if there were an arrow pointing to the left, where nothing is. More confusing and looking like fancy quoting is:</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash">    process1 &gt; outfile &lt; infile
</code></pre>
<p>and generating scripts is often an iterative process,</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash">    <span class="hljs-built_in">cat</span> file 
    <span class="hljs-built_in">cat</span> file | process1
    <span class="hljs-built_in">cat</span> file | process1 | process2 
    <span class="hljs-built_in">cat</span> file | process1 | process2 &gt; outfile
</code></pre>
<p>where you see your progress stepwise, while</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash">    &lt; file 
</code></pre>
<p>not even works. Simple ways are less error prone and ergonomic command catenation is simple with cat.</p>
<p>Another topic is, that most people were exposed to &gt; and &lt; as comparison operators, long before using a computer and when using a computer as programmers, are far more often exposed to these as such.</p>
<p>And comparing two operands with &lt; and &gt; is contra commutative, which means</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash">(a &gt; b) == (b &lt; a)
</code></pre>
<p>I remember the first time using &lt; for input redirection, I feared</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash">a.sh &lt; file 
</code></pre>
<p>could mean the same as</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash">file &gt; a.sh
</code></pre>
<p>and somehow overwrite my a.sh script. Maybe this is an issue for many beginners.</p>
<h3>rare differences</h3>
<pre class="lang-bash s-code-block"><code class="hljs language-bash"><span class="hljs-built_in">wc</span> -c journal.txt
15666 journal.txt
<span class="hljs-built_in">cat</span> journal.txt | <span class="hljs-built_in">wc</span> -c 
15666
</code></pre>
<p>The latter can be used in calculations directly.</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash"><span class="hljs-built_in">factor</span> $(<span class="hljs-built_in">cat</span> journal.txt | <span class="hljs-built_in">wc</span> -c)
</code></pre>
<p>Of course the &lt; can be used here too, instead of a file parameter:</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash">&lt; journal.txt <span class="hljs-built_in">wc</span> -c 
15666
<span class="hljs-built_in">wc</span> -c &lt; journal.txt
15666
    
</code></pre>
<p>but who cares - 15k?</p>
<p>If I would run occasionally into issues, surely I would change my habit of invocing cat.</p>
<p>When using very large or many, many files, avoiding cat is fine. To most questions the use of cat is orthogonal, off topic, not an issue.</p>
<p>Starting these useless useless use of cat discussion on every second shell topic is only annoying and boring. Get a life and wait for your minute of fame, when dealing with performance questions.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/cat">cat</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I disagree with most instances of the excessively smug UUOC Award because, when teaching someone else, <code>cat</code> is a convenient place-holder for any command or crusty complicated pipeline of commands that produce output suitable for the problem or task being discussed.</p>

<p>This is especially true on sites like Stack Overflow, ServerFault, Unix &amp; Linux or any of the SE sites.</p>

<p>If someone specifically asks about optimisation, or if you feel like adding extra information about it then, great, talk about how using cat is inefficient.  But don't berate people because they chose to aim for simplicity and ease-of-understanding in their examples rather than look-at-me-how-cool-am-i! complexity.</p>

<p>In short, because cat isn't always cat.</p>

<p>Also because most people who enjoy going around awarding UUOCs do it because they're more concerned with showing off about how 'clever' they are than they are about helping or teaching people.  In reality, they demonstrate that they're probably just another newbie who has found a tiny stick to beat their peers with.</p>

<hr>

<p><strong>Update</strong></p>

<p>Here's another UUOC that I posted in an answer at <a href="https://unix.stackexchange.com/a/301194/7696">https://unix.stackexchange.com/a/301194/7696</a>:</p>

<pre class="lang-bash s-code-block"><code class="hljs language-bash"><span class="hljs-function"><span class="hljs-title">sqlq</span></span>() {
  <span class="hljs-built_in">local</span> filter
  filter=<span class="hljs-string">'cat'</span>

  <span class="hljs-comment"># very primitive, use getopts for real option handling.</span>
  <span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span> == <span class="hljs-string">"--delete-blank-lines"</span> ] ; <span class="hljs-keyword">then</span>
    filter=<span class="hljs-string">'grep -v "^$"'</span>
    <span class="hljs-built_in">shift</span>
  <span class="hljs-keyword">fi</span>

  <span class="hljs-comment"># each arg is piped into sqlplus as a separate command</span>
  <span class="hljs-built_in">printf</span> <span class="hljs-string">"%s\n"</span> <span class="hljs-string">"<span class="hljs-variable">$@</span>"</span> | sqlplus -S sss/eee@sid | <span class="hljs-variable">$filter</span>
}
</code></pre>

<p>UUOC pedants would say that that's a UUOC because it's easily possible to make <code>$filter</code> default to the empty string and have the <code>if</code> statement do <code>filter='| grep -v "^$"'</code> but IMO, by not embedding the pipe character in <code>$filter</code>, this "useless" <code>cat</code> serves the extremely useful purpose of self-documenting the fact that <code>$filter</code> on the <code>printf</code> line isn't just another argument to <code>sqlplus</code>, it's an optional user-selectable output filter.</p>

<p>If there's any need to have multiple optional output filters, the option processing could just append <code>| whatever</code> to <code>$filter</code> as often as needed - one extra <code>cat</code> in the pipeline isn't going to hurt anything or cause any noticeable loss of performance.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/cat">cat</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>With the UUoC version, <code>cat</code> has to read the file into memory, then write it out to the pipe, and the command has to read the data from the pipe, so the kernel has to copy the whole file <em>three</em> times whereas in the redirected case, the kernel only has to copy the file once.  It is quicker to do something once than to do it three times.</p>

<p>Using:</p>

<pre class="lang-bash s-code-block"><code class="hljs language-bash"><span class="hljs-built_in">cat</span> <span class="hljs-string">"<span class="hljs-variable">$@</span>"</span> | <span class="hljs-built_in">command</span>
</code></pre>

<p>is a wholly different and not necessarily useless use of <code>cat</code>.  It is still useless if the command is a standard filter that accepts zero or more filename arguments and processes them in turn.  Consider the <code>tr</code> command: it is a pure filter that ignores or rejects filename arguments.  To feed multiple files to it, you have to use <code>cat</code> as shown.  (Of course, there's a separate discussion that the design of <code>tr</code> is not very good; there's no real reason it could not have been designed as a standard filter.)  This might also be valid if you want the command to treat all the input as a single file rather than as multiple separate files, even if the command would accept multiple separate files: for example, <code>wc</code> is such a command.</p>

<p>It is the <code>cat single-file</code> case that is unconditionally useless.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/cat">cat</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>An additional problem is that the pipe can silently mask a subshell. For this example, I'll replace <code>cat</code> with <code>echo</code>, but the same problem exists.</p>

<pre class="lang-bash s-code-block"><code class="hljs language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">"foo"</span> | <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line; <span class="hljs-keyword">do</span>
    x=<span class="hljs-variable">$line</span>
<span class="hljs-keyword">done</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$x</span>"</span>
</code></pre>

<p>You might expect <code>x</code> to contain <code>foo</code>, but it doesn't. The <code>x</code> you set was in a subshell spawned to execute the <code>while</code> loop. <code>x</code> in the shell that started the pipeline has an unrelated value, or is not set at all.</p>

<p>In bash4, you can configure some shell options so that the last command of a pipeline executes in the same shell as the one that starts the pipeline, but then you might try this</p>

<pre class="lang-bash s-code-block"><code class="hljs language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">"foo"</span> | <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line; <span class="hljs-keyword">do</span>
    x=<span class="hljs-variable">$line</span>
<span class="hljs-keyword">done</span> | awk <span class="hljs-string">'...'</span>
</code></pre>

<p>and <code>x</code> is once again local to the <code>while</code>'s subshell.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/cat">cat</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As someone who regularly points out this and a number of other shell programming antipatterns, I feel obliged to, belatedly, weigh in.</p>

<p>Shell script is very much a copy/paste language. For most people who write shell scripts, they are not in it to learn the language; it's just an obstacle they have to overcome in order to continue to do things in the language(s) they are actually somewhat familiar with.</p>

<p>In that context, I see it as disruptive and potentially even destructive to propagate various shell scripting anti-patterns.  The code that someone finds on Stack Overflow should ideally be possible to copy/paste into their  environment with minimal changes, and incomplete understanding.</p>

<p>Among the many shell scripting resources on the net, Stack Overflow is unusual in that users can help shape the quality of the site by editing the questions and answers on the site.  However, <a href="https://meta.stackoverflow.com/questions/260245/when-should-i-make-edits-to-code">code edits can be problematic</a> because it's easy to make changes which were not intended by the code author.  Hence, we tend to leave comments to suggest changes to the code.</p>

<p>The UUCA and related antipattern comments are not just for the authors of the code we comment on; they are as much a <em>caveat emptor</em> to help <em>readers</em> of the site become aware of problems in the code they find here.</p>

<p>We can't hope to achieve a situation where no answers on Stack Overflow recommend useless <code>cat</code>s (or unquoted variables, or <code>chmod 777</code>, or a large variety of other antipattern plagues), but we can at least help educate the user who is about to copy/paste this code into the innermost tight loop of their script which executes millions of times.</p>

<p>As far as technical reasons go, the traditional wisdom is that we should try to minimize the number of external processes; this continues to hold as a good general guidance when writing shell scripts.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/cat">cat</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I often use <code>cat file | myprogram</code> in examples. Sometime I am being accused of Useless use of cat (<a href="http://porkmail.org/era/unix/award.html" rel="noreferrer">http://porkmail.org/era/unix/award.html</a>). I disagree for the following reasons:</p>

<ul>
<li><p>It is easy to understand what is going on.</p>

<p>When reading a UNIX command you expect a command followed by arguments followed by redirection. It is possible to put the redirection anywhere but it is rarely seen - thus people will have a harder time reading the example. I believe</p>

<pre class="lang-bash s-code-block"><code class="hljs language-bash"><span class="hljs-built_in">cat</span> foo | program1 -o option -b option | program2
</code></pre>

<p>is easier to read than</p>

<pre class="lang-bash s-code-block"><code class="hljs language-bash">program1 -o option -b option &lt; foo | program2
</code></pre>

<p>If you move the redirection to the start you are confusing people who are not used to this syntax:</p>

<pre class="lang-bash s-code-block"><code class="hljs language-bash">&lt; foo program1 -o option -b option | program2
</code></pre>

<p>and examples should be easy to understand.</p></li>
<li><p>It is easy to change.</p>

<p>If you know the program can read from <code>cat</code>, you can normally assume it can read the output from any program that outputs to STDOUT, and thus you can adapt it for your own needs and get predictable results.</p></li>
<li><p>It stresses that the program does not fail, if STDIN is not a file.</p>

<p>It is not safe to assume that if <code>program1 &lt; foo</code> works then <code>cat foo | program1</code> will also work. However, it is safe to assume the opposite. This program works if STDIN is a file, but fails if the input is a pipe, because it uses seek:</p>

<pre class="lang-bash s-code-block"><code class="hljs language-bash"><span class="hljs-comment"># works</span>
&lt; foo perl -e <span class="hljs-string">'seek(STDIN,1,1) || die;print &lt;STDIN&gt;'</span>

<span class="hljs-comment"># fails</span>
<span class="hljs-built_in">cat</span> foo | perl -e <span class="hljs-string">'seek(STDIN,1,1) || die;print &lt;STDIN&gt;'</span>
</code></pre></li>
</ul>

<h1>Performance cost</h1>

<p>There is a cost of doing the additional <code>cat</code>. To give an idea of how much I ran a few tests to simulate baseline (<code>cat</code>), low throughput (<code>bzip2</code>), medium throughput (<code>gzip</code>), and high throughput (<code>grep</code>).</p>

<pre class="lang-bash s-code-block"><code class="hljs language-bash"><span class="hljs-built_in">cat</span> <span class="hljs-variable">$ISO</span> | <span class="hljs-built_in">cat</span>
&lt; <span class="hljs-variable">$ISO</span> <span class="hljs-built_in">cat</span>
<span class="hljs-built_in">cat</span> <span class="hljs-variable">$ISO</span> | bzip2
&lt; <span class="hljs-variable">$ISO</span> | bzip2
<span class="hljs-built_in">cat</span> <span class="hljs-variable">$ISO</span> | gzip
&lt; <span class="hljs-variable">$ISO</span> gzip
<span class="hljs-built_in">cat</span> <span class="hljs-variable">$ISO</span> | grep no_such_string
&lt; <span class="hljs-variable">$ISO</span> grep no_such_string
</code></pre>

<p>The tests were run on a low end system (0.6 GHz) and an ordinary laptop (2.2 GHz). They were run 10 times on each system and the best timing was chosen to mimic the optimal situation for each test. The $ISO was ubuntu-11.04-desktop-i386.iso.
(Prettier tables here: <a href="http://oletange.blogspot.com/2013/10/useless-use-of-cat.html" rel="noreferrer">http://oletange.blogspot.com/2013/10/useless-use-of-cat.html</a>)</p>

<pre class="lang-bash s-code-block"><code class="hljs language-bash">CPU                       0.6 GHz ARM
Command                   <span class="hljs-built_in">cat</span> <span class="hljs-variable">$ISO</span>|                        &lt;<span class="hljs-variable">$ISO</span>                            Diff                             Diff (pct)
Throughput \ Time (ms)    User       Sys        Real       User       Sys        Real       User       Sys        Real       User       Sys        Real
Baseline (<span class="hljs-built_in">cat</span>)                     55      14453      33090         23       6937      33126         32       7516        -36        239        208         99
Low (bzip2)                   1945148      16094    1973754    1941727       5664    1959982       3420      10430      13772        100        284        100
Medium (gzip)                  413914      13383     431812     407016       5477     416760       6898       7906      15052        101        244        103
High (grep no_such_string)      80656      15133      99049      79180       4336      86885       1476      10797      12164        101        349        114

CPU                       Core i7 2.2 GHz
Command                   <span class="hljs-built_in">cat</span> <span class="hljs-variable">$ISO</span>|           &lt;<span class="hljs-variable">$ISO</span>             Diff          Diff (pct)
Throughput \ Time (ms)    User     Sys Real   User   Sys Real   User Sys Real User       Sys Real
Baseline (<span class="hljs-built_in">cat</span>)                    0 356    215      1  84     88    0 272  127          0 423  244
Low (bzip2)                  136184 896 136765 136728 160 137131 -545 736 -366         99 560   99
Medium (gzip)                 26564 788  26791  26332 108  26492  232 680  298        100 729  101
High (grep no_such_string)      264 392    483    216  84    304   48 308  179        122 466  158
</code></pre>

<p>The results show that for low and medium throughput the cost is in the order of 1%. This is well within the uncertainty of the measurements, so in practice there is no difference.</p>

<p>For high throughput the difference is bigger and there is a clear difference between the two.</p>

<p>That leads to the conclusion: You should use <code>&lt;</code> instead of <code>cat |</code> if:</p>

<ul>
<li>the complexity of the processing is similar to a simple grep</li>
<li>performance matters more than readability.</li>
</ul>

<p>Otherwise it does not matter whether you use <code>&lt;</code> or <code>cat |</code>.</p>

<p>And thus you should only give a UUoC-award if and only if:</p>

<ul>
<li>you can measure a significant difference in the performance (publish your measurements when you give the award)</li>
<li>performance matters more than readability.</li>
</ul>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/cat">cat</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I think that (the traditional way) using pipe is a bit more faster; on my box I used <code>strace</code> command to see what's going on:</p>

<p>Without pipe:</p>

<pre class="lang-bash s-code-block"><code class="hljs language-bash">toc@UnixServer:~$ strace <span class="hljs-built_in">wc</span> -l &lt; wrong_output.c
execve(<span class="hljs-string">"/usr/bin/wc"</span>, [<span class="hljs-string">"wc"</span>, <span class="hljs-string">"-l"</span>], [/* 18 vars */]) = 0
brk(0)                                  = 0x8b50000
access(<span class="hljs-string">"/etc/ld.so.nohwcap"</span>, F_OK)      = -1 ENOENT (No such file or directory)
mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb77ad000
access(<span class="hljs-string">"/etc/ld.so.preload"</span>, R_OK)      = -1 ENOENT (No such file or directory)
open(<span class="hljs-string">"/etc/ld.so.cache"</span>, O_RDONLY)      = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=29107, ...}) = 0
mmap2(NULL, 29107, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb77a5000
close(3)                                = 0
access(<span class="hljs-string">"/etc/ld.so.nohwcap"</span>, F_OK)      = -1 ENOENT (No such file or directory)
open(<span class="hljs-string">"/lib/i386-linux-gnu/libc.so.6"</span>, O_RDONLY) = 3
<span class="hljs-built_in">read</span>(3, <span class="hljs-string">"\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\222\1\0004\0\0\0"</span>..., 512) = 512
fstat64(3, {st_mode=S_IFREG|0755, st_size=1552584, ...}) = 0
mmap2(NULL, 1563160, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xb7627000
mmap2(0xb779f000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x178) = 0xb779f000
mmap2(0xb77a2000, 10776, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb77a2000
close(3)                                = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7626000
set_thread_area({entry_number:-1 -&gt; 6, base_addr:0xb76268d0, <span class="hljs-built_in">limit</span>:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
mprotect(0xb779f000, 8192, PROT_READ)   = 0
mprotect(0x804f000, 4096, PROT_READ)    = 0
mprotect(0xb77ce000, 4096, PROT_READ)   = 0
munmap(0xb77a5000, 29107)               = 0
brk(0)                                  = 0x8b50000
brk(0x8b71000)                          = 0x8b71000
open(<span class="hljs-string">"/usr/lib/locale/locale-archive"</span>, O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=5540198, ...}) = 0
mmap2(NULL, 2097152, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7426000
mmap2(NULL, 1507328, PROT_READ, MAP_PRIVATE, 3, 0x2a8) = 0xb72b6000
close(3)                                = 0
open(<span class="hljs-string">"/usr/share/locale/locale.alias"</span>, O_RDONLY) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2570, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb77ac000
<span class="hljs-built_in">read</span>(3, <span class="hljs-string">"# Locale name alias data base.\n#"</span>..., 4096) = 2570
<span class="hljs-built_in">read</span>(3, <span class="hljs-string">""</span>, 4096)                       = 0
close(3)                                = 0
munmap(0xb77ac000, 4096)                = 0
open(<span class="hljs-string">"/usr/share/locale/fr_FR.UTF-8/LC_MESSAGES/coreutils.mo"</span>, O_RDONLY) = -1 ENOENT (No such file or directory)
open(<span class="hljs-string">"/usr/share/locale/fr_FR.utf8/LC_MESSAGES/coreutils.mo"</span>, O_RDONLY) = -1 ENOENT (No such file or directory)
open(<span class="hljs-string">"/usr/share/locale/fr_FR/LC_MESSAGES/coreutils.mo"</span>, O_RDONLY) = -1 ENOENT (No such file or directory)
open(<span class="hljs-string">"/usr/share/locale/fr.UTF-8/LC_MESSAGES/coreutils.mo"</span>, O_RDONLY) = -1 ENOENT (No such file or directory)
open(<span class="hljs-string">"/usr/share/locale/fr.utf8/LC_MESSAGES/coreutils.mo"</span>, O_RDONLY) = -1 ENOENT (No such file or directory)
open(<span class="hljs-string">"/usr/share/locale/fr/LC_MESSAGES/coreutils.mo"</span>, O_RDONLY) = -1 ENOENT (No such file or directory)
open(<span class="hljs-string">"/usr/share/locale-langpack/fr_FR.UTF-8/LC_MESSAGES/coreutils.mo"</span>, O_RDONLY) = -1 ENOENT (No such file or directory)
open(<span class="hljs-string">"/usr/share/locale-langpack/fr_FR.utf8/LC_MESSAGES/coreutils.mo"</span>, O_RDONLY) = -1 ENOENT (No such file or directory)
open(<span class="hljs-string">"/usr/share/locale-langpack/fr_FR/LC_MESSAGES/coreutils.mo"</span>, O_RDONLY) = -1 ENOENT (No such file or directory)
open(<span class="hljs-string">"/usr/share/locale-langpack/fr.UTF-8/LC_MESSAGES/coreutils.mo"</span>, O_RDONLY) = -1 ENOENT (No such file or directory)
open(<span class="hljs-string">"/usr/share/locale-langpack/fr.utf8/LC_MESSAGES/coreutils.mo"</span>, O_RDONLY) = -1 ENOENT (No such file or directory)
open(<span class="hljs-string">"/usr/share/locale-langpack/fr/LC_MESSAGES/coreutils.mo"</span>, O_RDONLY) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=316721, ...}) = 0
mmap2(NULL, 316721, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7268000
close(3)                                = 0
open(<span class="hljs-string">"/usr/lib/i386-linux-gnu/gconv/gconv-modules.cache"</span>, O_RDONLY) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=26064, ...}) = 0
mmap2(NULL, 26064, PROT_READ, MAP_SHARED, 3, 0) = 0xb7261000
close(3)                                = 0
<span class="hljs-built_in">read</span>(0, <span class="hljs-string">"#include&lt;stdio.h&gt;\n\nint main(int "</span>..., 16384) = 180
<span class="hljs-built_in">read</span>(0, <span class="hljs-string">""</span>, 16384)                      = 0
fstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 2), ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7260000
write(1, <span class="hljs-string">"13\n"</span>, 313
)                     = 3
close(0)                                = 0
close(1)                                = 0
munmap(0xb7260000, 4096)                = 0
close(2)                                = 0
exit_group(0)                           = ?
</code></pre>

<p>And with pipe:</p>

<pre class="lang-bash s-code-block"><code class="hljs language-bash">toc@UnixServer:~$ strace <span class="hljs-built_in">cat</span> wrong_output.c | <span class="hljs-built_in">wc</span> -l
execve(<span class="hljs-string">"/bin/cat"</span>, [<span class="hljs-string">"cat"</span>, <span class="hljs-string">"wrong_output.c"</span>], [/* 18 vars */]) = 0
brk(0)                                  = 0xa017000
access(<span class="hljs-string">"/etc/ld.so.nohwcap"</span>, F_OK)      = -1 ENOENT (No such file or directory)
mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb774b000
access(<span class="hljs-string">"/etc/ld.so.preload"</span>, R_OK)      = -1 ENOENT (No such file or directory)
open(<span class="hljs-string">"/etc/ld.so.cache"</span>, O_RDONLY)      = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=29107, ...}) = 0
mmap2(NULL, 29107, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7743000
close(3)                                = 0
access(<span class="hljs-string">"/etc/ld.so.nohwcap"</span>, F_OK)      = -1 ENOENT (No such file or directory)
open(<span class="hljs-string">"/lib/i386-linux-gnu/libc.so.6"</span>, O_RDONLY) = 3
<span class="hljs-built_in">read</span>(3, <span class="hljs-string">"\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\222\1\0004\0\0\0"</span>..., 512) = 512
fstat64(3, {st_mode=S_IFREG|0755, st_size=1552584, ...}) = 0
mmap2(NULL, 1563160, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xb75c5000
mmap2(0xb773d000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x178) = 0xb773d000
mmap2(0xb7740000, 10776, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7740000
close(3)                                = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb75c4000
set_thread_area({entry_number:-1 -&gt; 6, base_addr:0xb75c48d0, <span class="hljs-built_in">limit</span>:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
mprotect(0xb773d000, 8192, PROT_READ)   = 0
mprotect(0x8051000, 4096, PROT_READ)    = 0
mprotect(0xb776c000, 4096, PROT_READ)   = 0
munmap(0xb7743000, 29107)               = 0
brk(0)                                  = 0xa017000
brk(0xa038000)                          = 0xa038000
open(<span class="hljs-string">"/usr/lib/locale/locale-archive"</span>, O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=5540198, ...}) = 0
mmap2(NULL, 2097152, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb73c4000
mmap2(NULL, 1507328, PROT_READ, MAP_PRIVATE, 3, 0x2a8) = 0xb7254000
close(3)                                = 0
fstat64(1, {st_mode=S_IFIFO|0600, st_size=0, ...}) = 0
open(<span class="hljs-string">"wrong_output.c"</span>, O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0664, st_size=180, ...}) = 0
<span class="hljs-built_in">read</span>(3, <span class="hljs-string">"#include&lt;stdio.h&gt;\n\nint main(int "</span>..., 32768) = 180
write(1, <span class="hljs-string">"#include&lt;stdio.h&gt;\n\nint main(int "</span>..., 180) = 180
<span class="hljs-built_in">read</span>(3, <span class="hljs-string">""</span>, 32768)                      = 0
close(3)                                = 0
close(1)                                = 0
close(2)                                = 0
exit_group(0)                           = ?
13
</code></pre>

<p>You can do some testing with <code>strace</code> and <code>time</code> command with more and longer commands for good benchmarking.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/reference-what-does-this-symbol-mean-in-php-1657384561666">Reference  What does this symbol mean in PHP?</a><a href="/questions/what&#x27;s-the-difference-between-inner-join-left-join-right-join-and-full-join-duplicate-1657388082887">What&#x27;s the difference between INNER JOIN, LEFT JOIN, RIGHT JOIN and FULL JOIN? [duplicate]</a><a href="/questions/the-difference-between-bracket-and-double-bracket-for-accessing-the-elements-of-a-list-or-dataframe-1657388451711">The difference between bracket [ ] and double bracket [[ ]] for accessing the elements of a list or dataframe</a><a href="/questions/which-equals-operator-(-vs-)-should-be-used-in-javascript-comparisons-1657384663105">Which equals operator (== vs ===) should be used in JavaScript comparisons?</a><a href="/questions/what&#x27;s-the-simplest-way-to-print-a-java-array-1657384702397">What&#x27;s the simplest way to print a Java array?</a><a href="/questions/post-an-html-table-to-ado.net-datatable-1657387462723">Post an HTML Table to ADO.NET DataTable</a><a href="/questions/how-do-i-copy-to-the-clipboard-in-javascript-1657385501223">How do I copy to the clipboard in JavaScript?</a><a href="/questions/alternatives-to-gprof-closed-1657388336554">Alternatives to gprof [closed]</a><a href="/questions/how-to-replace-all-occurrences-of-a-string-in-javascript-1657384895467">How to replace all occurrences of a string in JavaScript</a><a href="/questions/how-to-remove-items-from-a-list-while-iterating-1657384496375">How to remove items from a list while iterating?</a><a href="/questions/re.findall-behaves-weird-1657388408049">re.findall behaves weird</a><a href="/questions/what-and-where-are-the-stack-and-heap-1657387415361">What and where are the stack and heap?</a><a href="/questions/sending-email-in-android-using-javamail-api-without-using-the-defaultbuilt-in-app-1657387883400">Sending Email in Android using JavaMail API without using the default/built-in app</a><a href="/questions/how-do-i-revert-a-git-repository-to-a-previous-commit-1657387714717">How do I revert a Git repository to a previous commit?</a><a href="/questions/how-does-javascript-.prototype-work-1657388169270">How does JavaScript .prototype work?</a><a href="/questions/var-functionname-function()-vs-function-functionname()-1657384724077">var functionName = function() {} vs function functionName() {}</a><a href="/questions/my-regex-is-matching-too-much.-how-do-i-make-it-stop-duplicate-1657384845028">My regex is matching too much. How do I make it stop? [duplicate]</a><a href="/questions/how-do-you-get-the-footer-to-stay-at-the-bottom-of-a-web-page-1657387817544">How do you get the footer to stay at the bottom of a Web page?</a><a href="/questions/how-does-the-java-&#x27;for-each&#x27;-loop-work-1657388423749">How does the Java &#x27;for each&#x27; loop work?</a><a href="/questions/order-bars-in-ggplot2-bar-graph-1657388099080">Order Bars in ggplot2 bar graph</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;I was not aware of the award until today when some rookie tried to pin the \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Cat_(Unix)#Useless_use_of_cat\u0026quot; rel=\u0026quot;noreferrer\u0026quot; title=\u0026quot;UUOC\u0026quot;\u0026gt;UUOC\u0026lt;/a\u0026gt; on me for one of my answers. It was a \u0026lt;code\u0026gt;cat file.txt | grep foo | cut ... | cut ...\u0026lt;/code\u0026gt;. I gave him a piece of my mind, and only after doing so visited the link he gave me referring to the origins of the award and the practice of doing so. Further searching led me to this question. Somewhat unfortunately despite conscious consideration, none of the answers included my rationale.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I had not meant to be defensive in responding to him. After all, in my younger years, I would have written the command as \u0026lt;code\u0026gt;grep foo file.txt | cut ... | cut ...\u0026lt;/code\u0026gt; because whenever you do the frequent single \u0026lt;code\u0026gt;grep\u0026lt;/code\u0026gt;s you learn the placement of the file argument and it is ready knowledge that the first is the pattern and the later ones are file names.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It was a conscious choice to use \u0026lt;code\u0026gt;cat\u0026lt;/code\u0026gt; when I answered the question, partly because of a reason of \u0026quot;good taste\u0026quot; (in the words of Linus Torvalds) but chiefly for a compelling reason of function.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The latter reason is more important so I will put it out first. When I offer a pipeline as a solution I expect it to be reusable. It is quite likely that a pipeline would be added at the end of or spliced into another pipeline. In that case having a file argument to grep screws up reusability, and quite possibly do so \u0026lt;em\u0026gt;silently\u0026lt;/em\u0026gt; without an error message if the file argument exists. I. e. \u0026lt;code\u0026gt;grep foo xyz | grep bar xyz | wc\u0026lt;/code\u0026gt; will give you how many lines in \u0026lt;code\u0026gt;xyz\u0026lt;/code\u0026gt; contain \u0026lt;code\u0026gt;bar\u0026lt;/code\u0026gt; while you are expecting the number of lines that contain both \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;bar\u0026lt;/code\u0026gt;. Having to change arguments to a command in a pipeline before using it is prone to errors. Add to it the possibility of silent failures and it becomes a particularly insidious practice.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The former reason is not unimportant either since a lot of \u0026quot;\u0026lt;a href=\u0026quot;https://medium.com/@bartobri/applying-the-linus-tarvolds-good-taste-coding-requirement-99749f37684a\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;good taste\u0026lt;/a\u0026gt;\u0026quot;\n merely is an intuitive subconscious rationale for things like the silent failures above that you cannot think of right at the moment when some person in need of education says \u0026quot;but isn\u0026apos;t that cat useless\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However, I will try to also make conscious the former \u0026quot;good taste\u0026quot; reason I mentioned. That reason has to do with the orthogonal design spirit of Unix. \u0026lt;code\u0026gt;grep\u0026lt;/code\u0026gt; does not \u0026lt;code\u0026gt;cut\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;ls\u0026lt;/code\u0026gt; does not \u0026lt;code\u0026gt;grep\u0026lt;/code\u0026gt;. Therefore at the very least \u0026lt;code\u0026gt;grep foo file1 file2 file3\u0026lt;/code\u0026gt; goes against the design spirit. The orthogonal way of doing it is \u0026lt;code\u0026gt;cat file1 file2 file3 | grep foo\u0026lt;/code\u0026gt;. Now, \u0026lt;code\u0026gt;grep foo file1\u0026lt;/code\u0026gt; is merely a special case of \u0026lt;code\u0026gt;grep foo file1 file2 file3\u0026lt;/code\u0026gt;, and if you do not treat it the same you are at least using up brain clock cycles trying to avoid the useless cat award.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;That leads us to the argument that \u0026lt;code\u0026gt;grep foo file1 file2 file3\u0026lt;/code\u0026gt; is concatenating, and \u0026lt;code\u0026gt;cat\u0026lt;/code\u0026gt; concatenates so it is proper to \u0026lt;code\u0026gt;cat file1 file2 file3\u0026lt;/code\u0026gt; but because \u0026lt;code\u0026gt;cat\u0026lt;/code\u0026gt; is not concatenating in \u0026lt;code\u0026gt;cat file1 | grep foo\u0026lt;/code\u0026gt; therefore we are violating the spirit of both the \u0026lt;code\u0026gt;cat\u0026lt;/code\u0026gt; and the almighty Unix. Well, if that were the case then Unix would need a different command to read the output of one file and spit it to stdout (not paginate it or anything just a pure spit to stdout). So you would have the situation where you say \u0026lt;code\u0026gt;cat file1 file2\u0026lt;/code\u0026gt; or you say \u0026lt;code\u0026gt;dog file1\u0026lt;/code\u0026gt; and conscientiously remember to avoid \u0026lt;code\u0026gt;cat file1\u0026lt;/code\u0026gt; to avoid getting the award, while also avoiding \u0026lt;code\u0026gt;dog file1 file2\u0026lt;/code\u0026gt; since hopefully the design of \u0026lt;code\u0026gt;dog\u0026lt;/code\u0026gt; would throw an error if multiple files are specified.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Hopefully, at this point, you sympathize with the Unix designers for not including a separate command to spit a file to stdout, while also naming \u0026lt;code\u0026gt;cat\u0026lt;/code\u0026gt; for concatenate rather than giving it some other name. \u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;\u0026amp;lt;edit\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt; removed incorrect comments on \u0026lt;code\u0026gt;\u0026amp;lt;\u0026lt;/code\u0026gt;, in fact, \u0026lt;code\u0026gt;\u0026amp;lt;\u0026lt;/code\u0026gt; is an efficient no-copy facility to spit a file to stdout which you can position at the beginning of a pipeline so the Unix designers did include something specifically for this \u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;\u0026amp;lt;/edit\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The next question is why is it important to have commands that merely spit a file or the concatenation of several files to stdout, without any further processing? One reason is to avoid having every single Unix command that operates on standard input to know how to parse at least one command line file argument and use it as input if it exists. The second reason is to avoid users having to remember: (a) where the filename arguments go; and (b) avoid the silent pipeline bug as mentioned above.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;That brings us to why \u0026lt;code\u0026gt;grep\u0026lt;/code\u0026gt; does have the extra logic. The rationale is to allow user-fluency for commands that are used frequently and on a \u0026lt;em\u0026gt;stand-alone\u0026lt;/em\u0026gt; basis (rather than as a pipeline). It is a slight compromise of orthogonality for a significant gain in usability. Not all commands should be designed this way and commands that are not frequently used should completely avoid the extra logic of file arguments (remember extra logic leads to unnecessary fragility (the possibility of a bug)). The exception is to allow file arguments like in the case of \u0026lt;code\u0026gt;grep\u0026lt;/code\u0026gt;. (By the way, note that \u0026lt;code\u0026gt;ls\u0026lt;/code\u0026gt; has a completely different reason to not just accept but pretty much require file arguments)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Finally, what could have been done better is if such exceptional commands as \u0026lt;code\u0026gt;grep\u0026lt;/code\u0026gt; (but not necessarily \u0026lt;code\u0026gt;ls\u0026lt;/code\u0026gt;) generate an error if the standard input is also available when file arguments are specified.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Nope! \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;First of all, it doesn\u0026apos;t matter where in a command the redirection happens. So if you like your redirection to the left of your command, that\u0026apos;s fine:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;\u0026amp;lt; somefile \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;command\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;is the same as\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;command\u0026lt;/span\u0026gt; \u0026amp;lt; somefile\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Second, there are \u0026lt;em\u0026gt;n + 1\u0026lt;/em\u0026gt; processes and a subshell happening when you use a pipe. It is most decidedly slower. In some cases \u0026lt;em\u0026gt;n\u0026lt;/em\u0026gt; would\u0026apos;ve been zero (for example, when you\u0026apos;re redirecting to a shell builtin), so by using \u0026lt;code\u0026gt;cat\u0026lt;/code\u0026gt; you\u0026apos;re adding a new process entirely unnecessarily.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As a generalization, whenever you find yourself using a pipe it\u0026apos;s worth taking 30 seconds to see if you can eliminate it. (But probably not worth taking much longer than 30 seconds.) Here are some examples where pipes and processes are frequently used unnecessarily:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; word \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; $(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cat\u0026lt;/span\u0026gt; somefile);  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# for word in $(\u0026amp;lt;somefile);  (or better yet, while read \u0026amp;lt; somefile)\u0026lt;/span\u0026gt;\n\ngrep something | awk stuff; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# awk \u0026apos;/something/ stuff\u0026apos; (similar for sed)\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; something | \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;command\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# command \u0026amp;lt;\u0026amp;lt;\u0026amp;lt; something (although echo would be necessary for pure POSIX)\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Feel free to edit to add more examples.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In \u0026lt;strong\u0026gt;defense\u0026lt;/strong\u0026gt; of cat:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Yes,\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;   \u0026amp;lt; input process \u0026amp;gt; output \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;or\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;   process \u0026amp;lt; input \u0026amp;gt; output \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;is more efficient, but many invocations don\u0026apos;t have performance issues, so you don\u0026apos;t care.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;ergonomic reasons:\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;We are used to read from left to right, so a command like\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cat\u0026lt;/span\u0026gt; infile | process1 | process2 \u0026amp;gt; outfile\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;is trivial to understand.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;    process1 \u0026amp;lt; infile | process2 \u0026amp;gt; outfile\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;has to jump over process1, and then read left to right. This can be healed by:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;    \u0026amp;lt; infile process1 | process2 \u0026amp;gt; outfile\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;looks somehow, as if there were an arrow pointing to the left, where nothing is. More confusing and looking like fancy quoting is:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;    process1 \u0026amp;gt; outfile \u0026amp;lt; infile\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;and generating scripts is often an iterative process,\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cat\u0026lt;/span\u0026gt; file \n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cat\u0026lt;/span\u0026gt; file | process1\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cat\u0026lt;/span\u0026gt; file | process1 | process2 \n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cat\u0026lt;/span\u0026gt; file | process1 | process2 \u0026amp;gt; outfile\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;where you see your progress stepwise, while\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;    \u0026amp;lt; file \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;not even works. Simple ways are less error prone and ergonomic command catenation is simple with cat.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Another topic is, that most people were exposed to \u0026amp;gt; and \u0026amp;lt; as comparison operators, long before using a computer and when using a computer as programmers, are far more often exposed to these as such.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;And comparing two operands with \u0026amp;lt; and \u0026amp;gt; is contra commutative, which means\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;(a \u0026amp;gt; b) == (b \u0026amp;lt; a)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;I remember the first time using \u0026amp;lt; for input redirection, I feared\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;a.sh \u0026amp;lt; file \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;could mean the same as\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;file \u0026amp;gt; a.sh\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;and somehow overwrite my a.sh script. Maybe this is an issue for many beginners.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;rare differences\u0026lt;/h3\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wc\u0026lt;/span\u0026gt; -c journal.txt\n15666 journal.txt\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cat\u0026lt;/span\u0026gt; journal.txt | \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wc\u0026lt;/span\u0026gt; -c \n15666\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The latter can be used in calculations directly.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;factor\u0026lt;/span\u0026gt; $(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cat\u0026lt;/span\u0026gt; journal.txt | \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wc\u0026lt;/span\u0026gt; -c)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Of course the \u0026amp;lt; can be used here too, instead of a file parameter:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;\u0026amp;lt; journal.txt \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wc\u0026lt;/span\u0026gt; -c \n15666\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wc\u0026lt;/span\u0026gt; -c \u0026amp;lt; journal.txt\n15666\n    \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;but who cares - 15k?\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If I would run occasionally into issues, surely I would change my habit of invocing cat.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;When using very large or many, many files, avoiding cat is fine. To most questions the use of cat is orthogonal, off topic, not an issue.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Starting these useless useless use of cat discussion on every second shell topic is only annoying and boring. Get a life and wait for your minute of fame, when dealing with performance questions.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I disagree with most instances of the excessively smug UUOC Award because, when teaching someone else, \u0026lt;code\u0026gt;cat\u0026lt;/code\u0026gt; is a convenient place-holder for any command or crusty complicated pipeline of commands that produce output suitable for the problem or task being discussed.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is especially true on sites like Stack Overflow, ServerFault, Unix \u0026amp;amp; Linux or any of the SE sites.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If someone specifically asks about optimisation, or if you feel like adding extra information about it then, great, talk about how using cat is inefficient.  But don\u0026apos;t berate people because they chose to aim for simplicity and ease-of-understanding in their examples rather than look-at-me-how-cool-am-i! complexity.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In short, because cat isn\u0026apos;t always cat.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Also because most people who enjoy going around awarding UUOCs do it because they\u0026apos;re more concerned with showing off about how \u0026apos;clever\u0026apos; they are than they are about helping or teaching people.  In reality, they demonstrate that they\u0026apos;re probably just another newbie who has found a tiny stick to beat their peers with.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Update\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here\u0026apos;s another UUOC that I posted in an answer at \u0026lt;a href=\u0026quot;https://unix.stackexchange.com/a/301194/7696\u0026quot;\u0026gt;https://unix.stackexchange.com/a/301194/7696\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;sqlq\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;() {\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;local\u0026lt;/span\u0026gt; filter\n  filter=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;cat\u0026apos;\u0026lt;/span\u0026gt;\n\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# very primitive, use getopts for real option handling.\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; [ \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$1\u0026lt;/span\u0026gt;\u0026quot;\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;--delete-blank-lines\u0026quot;\u0026lt;/span\u0026gt; ] ; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;\n    filter=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;grep -v \u0026quot;^$\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;shift\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fi\u0026lt;/span\u0026gt;\n\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# each arg is piped into sqlplus as a separate command\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%s\\n\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$@\u0026lt;/span\u0026gt;\u0026quot;\u0026lt;/span\u0026gt; | sqlplus -S sss/eee@sid | \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$filter\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;UUOC pedants would say that that\u0026apos;s a UUOC because it\u0026apos;s easily possible to make \u0026lt;code\u0026gt;$filter\u0026lt;/code\u0026gt; default to the empty string and have the \u0026lt;code\u0026gt;if\u0026lt;/code\u0026gt; statement do \u0026lt;code\u0026gt;filter=\u0026apos;| grep -v \u0026quot;^$\u0026quot;\u0026apos;\u0026lt;/code\u0026gt; but IMO, by not embedding the pipe character in \u0026lt;code\u0026gt;$filter\u0026lt;/code\u0026gt;, this \u0026quot;useless\u0026quot; \u0026lt;code\u0026gt;cat\u0026lt;/code\u0026gt; serves the extremely useful purpose of self-documenting the fact that \u0026lt;code\u0026gt;$filter\u0026lt;/code\u0026gt; on the \u0026lt;code\u0026gt;printf\u0026lt;/code\u0026gt; line isn\u0026apos;t just another argument to \u0026lt;code\u0026gt;sqlplus\u0026lt;/code\u0026gt;, it\u0026apos;s an optional user-selectable output filter.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If there\u0026apos;s any need to have multiple optional output filters, the option processing could just append \u0026lt;code\u0026gt;| whatever\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;$filter\u0026lt;/code\u0026gt; as often as needed - one extra \u0026lt;code\u0026gt;cat\u0026lt;/code\u0026gt; in the pipeline isn\u0026apos;t going to hurt anything or cause any noticeable loss of performance.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;With the UUoC version, \u0026lt;code\u0026gt;cat\u0026lt;/code\u0026gt; has to read the file into memory, then write it out to the pipe, and the command has to read the data from the pipe, so the kernel has to copy the whole file \u0026lt;em\u0026gt;three\u0026lt;/em\u0026gt; times whereas in the redirected case, the kernel only has to copy the file once.  It is quicker to do something once than to do it three times.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Using:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cat\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$@\u0026lt;/span\u0026gt;\u0026quot;\u0026lt;/span\u0026gt; | \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;command\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;is a wholly different and not necessarily useless use of \u0026lt;code\u0026gt;cat\u0026lt;/code\u0026gt;.  It is still useless if the command is a standard filter that accepts zero or more filename arguments and processes them in turn.  Consider the \u0026lt;code\u0026gt;tr\u0026lt;/code\u0026gt; command: it is a pure filter that ignores or rejects filename arguments.  To feed multiple files to it, you have to use \u0026lt;code\u0026gt;cat\u0026lt;/code\u0026gt; as shown.  (Of course, there\u0026apos;s a separate discussion that the design of \u0026lt;code\u0026gt;tr\u0026lt;/code\u0026gt; is not very good; there\u0026apos;s no real reason it could not have been designed as a standard filter.)  This might also be valid if you want the command to treat all the input as a single file rather than as multiple separate files, even if the command would accept multiple separate files: for example, \u0026lt;code\u0026gt;wc\u0026lt;/code\u0026gt; is such a command.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It is the \u0026lt;code\u0026gt;cat single-file\u0026lt;/code\u0026gt; case that is unconditionally useless.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;An additional problem is that the pipe can silently mask a subshell. For this example, I\u0026apos;ll replace \u0026lt;code\u0026gt;cat\u0026lt;/code\u0026gt; with \u0026lt;code\u0026gt;echo\u0026lt;/code\u0026gt;, but the same problem exists.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;foo\u0026quot;\u0026lt;/span\u0026gt; | \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read\u0026lt;/span\u0026gt; line; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;do\u0026lt;/span\u0026gt;\n    x=\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$line\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;done\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$x\u0026lt;/span\u0026gt;\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You might expect \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; to contain \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt;, but it doesn\u0026apos;t. The \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; you set was in a subshell spawned to execute the \u0026lt;code\u0026gt;while\u0026lt;/code\u0026gt; loop. \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; in the shell that started the pipeline has an unrelated value, or is not set at all.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In bash4, you can configure some shell options so that the last command of a pipeline executes in the same shell as the one that starts the pipeline, but then you might try this\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;foo\u0026quot;\u0026lt;/span\u0026gt; | \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read\u0026lt;/span\u0026gt; line; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;do\u0026lt;/span\u0026gt;\n    x=\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$line\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;done\u0026lt;/span\u0026gt; | awk \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;...\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; is once again local to the \u0026lt;code\u0026gt;while\u0026lt;/code\u0026gt;\u0026apos;s subshell.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As someone who regularly points out this and a number of other shell programming antipatterns, I feel obliged to, belatedly, weigh in.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Shell script is very much a copy/paste language. For most people who write shell scripts, they are not in it to learn the language; it\u0026apos;s just an obstacle they have to overcome in order to continue to do things in the language(s) they are actually somewhat familiar with.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In that context, I see it as disruptive and potentially even destructive to propagate various shell scripting anti-patterns.  The code that someone finds on Stack Overflow should ideally be possible to copy/paste into their  environment with minimal changes, and incomplete understanding.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Among the many shell scripting resources on the net, Stack Overflow is unusual in that users can help shape the quality of the site by editing the questions and answers on the site.  However, \u0026lt;a href=\u0026quot;https://meta.stackoverflow.com/questions/260245/when-should-i-make-edits-to-code\u0026quot;\u0026gt;code edits can be problematic\u0026lt;/a\u0026gt; because it\u0026apos;s easy to make changes which were not intended by the code author.  Hence, we tend to leave comments to suggest changes to the code.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The UUCA and related antipattern comments are not just for the authors of the code we comment on; they are as much a \u0026lt;em\u0026gt;caveat emptor\u0026lt;/em\u0026gt; to help \u0026lt;em\u0026gt;readers\u0026lt;/em\u0026gt; of the site become aware of problems in the code they find here.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;We can\u0026apos;t hope to achieve a situation where no answers on Stack Overflow recommend useless \u0026lt;code\u0026gt;cat\u0026lt;/code\u0026gt;s (or unquoted variables, or \u0026lt;code\u0026gt;chmod 777\u0026lt;/code\u0026gt;, or a large variety of other antipattern plagues), but we can at least help educate the user who is about to copy/paste this code into the innermost tight loop of their script which executes millions of times.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As far as technical reasons go, the traditional wisdom is that we should try to minimize the number of external processes; this continues to hold as a good general guidance when writing shell scripts.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I often use \u0026lt;code\u0026gt;cat file | myprogram\u0026lt;/code\u0026gt; in examples. Sometime I am being accused of Useless use of cat (\u0026lt;a href=\u0026quot;http://porkmail.org/era/unix/award.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://porkmail.org/era/unix/award.html\u0026lt;/a\u0026gt;). I disagree for the following reasons:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;It is easy to understand what is going on.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When reading a UNIX command you expect a command followed by arguments followed by redirection. It is possible to put the redirection anywhere but it is rarely seen - thus people will have a harder time reading the example. I believe\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cat\u0026lt;/span\u0026gt; foo | program1 -o option -b option | program2\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;is easier to read than\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;program1 -o option -b option \u0026amp;lt; foo | program2\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If you move the redirection to the start you are confusing people who are not used to this syntax:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;\u0026amp;lt; foo program1 -o option -b option | program2\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and examples should be easy to understand.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;It is easy to change.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you know the program can read from \u0026lt;code\u0026gt;cat\u0026lt;/code\u0026gt;, you can normally assume it can read the output from any program that outputs to STDOUT, and thus you can adapt it for your own needs and get predictable results.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;It stresses that the program does not fail, if STDIN is not a file.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It is not safe to assume that if \u0026lt;code\u0026gt;program1 \u0026amp;lt; foo\u0026lt;/code\u0026gt; works then \u0026lt;code\u0026gt;cat foo | program1\u0026lt;/code\u0026gt; will also work. However, it is safe to assume the opposite. This program works if STDIN is a file, but fails if the input is a pipe, because it uses seek:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# works\u0026lt;/span\u0026gt;\n\u0026amp;lt; foo perl -e \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;seek(STDIN,1,1) || die;print \u0026amp;lt;STDIN\u0026amp;gt;\u0026apos;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# fails\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cat\u0026lt;/span\u0026gt; foo | perl -e \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;seek(STDIN,1,1) || die;print \u0026amp;lt;STDIN\u0026amp;gt;\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;h1\u0026gt;Performance cost\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;There is a cost of doing the additional \u0026lt;code\u0026gt;cat\u0026lt;/code\u0026gt;. To give an idea of how much I ran a few tests to simulate baseline (\u0026lt;code\u0026gt;cat\u0026lt;/code\u0026gt;), low throughput (\u0026lt;code\u0026gt;bzip2\u0026lt;/code\u0026gt;), medium throughput (\u0026lt;code\u0026gt;gzip\u0026lt;/code\u0026gt;), and high throughput (\u0026lt;code\u0026gt;grep\u0026lt;/code\u0026gt;).\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cat\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$ISO\u0026lt;/span\u0026gt; | \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cat\u0026lt;/span\u0026gt;\n\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$ISO\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cat\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cat\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$ISO\u0026lt;/span\u0026gt; | bzip2\n\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$ISO\u0026lt;/span\u0026gt; | bzip2\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cat\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$ISO\u0026lt;/span\u0026gt; | gzip\n\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$ISO\u0026lt;/span\u0026gt; gzip\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cat\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$ISO\u0026lt;/span\u0026gt; | grep no_such_string\n\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$ISO\u0026lt;/span\u0026gt; grep no_such_string\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The tests were run on a low end system (0.6 GHz) and an ordinary laptop (2.2 GHz). They were run 10 times on each system and the best timing was chosen to mimic the optimal situation for each test. The $ISO was ubuntu-11.04-desktop-i386.iso.\n(Prettier tables here: \u0026lt;a href=\u0026quot;http://oletange.blogspot.com/2013/10/useless-use-of-cat.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://oletange.blogspot.com/2013/10/useless-use-of-cat.html\u0026lt;/a\u0026gt;)\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;CPU                       0.6 GHz ARM\nCommand                   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cat\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$ISO\u0026lt;/span\u0026gt;|                        \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$ISO\u0026lt;/span\u0026gt;                            Diff                             Diff (pct)\nThroughput \\ Time (ms)    User       Sys        Real       User       Sys        Real       User       Sys        Real       User       Sys        Real\nBaseline (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cat\u0026lt;/span\u0026gt;)                     55      14453      33090         23       6937      33126         32       7516        -36        239        208         99\nLow (bzip2)                   1945148      16094    1973754    1941727       5664    1959982       3420      10430      13772        100        284        100\nMedium (gzip)                  413914      13383     431812     407016       5477     416760       6898       7906      15052        101        244        103\nHigh (grep no_such_string)      80656      15133      99049      79180       4336      86885       1476      10797      12164        101        349        114\n\nCPU                       Core i7 2.2 GHz\nCommand                   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cat\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$ISO\u0026lt;/span\u0026gt;|           \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$ISO\u0026lt;/span\u0026gt;             Diff          Diff (pct)\nThroughput \\ Time (ms)    User     Sys Real   User   Sys Real   User Sys Real User       Sys Real\nBaseline (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cat\u0026lt;/span\u0026gt;)                    0 356    215      1  84     88    0 272  127          0 423  244\nLow (bzip2)                  136184 896 136765 136728 160 137131 -545 736 -366         99 560   99\nMedium (gzip)                 26564 788  26791  26332 108  26492  232 680  298        100 729  101\nHigh (grep no_such_string)      264 392    483    216  84    304   48 308  179        122 466  158\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The results show that for low and medium throughput the cost is in the order of 1%. This is well within the uncertainty of the measurements, so in practice there is no difference.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For high throughput the difference is bigger and there is a clear difference between the two.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;That leads to the conclusion: You should use \u0026lt;code\u0026gt;\u0026amp;lt;\u0026lt;/code\u0026gt; instead of \u0026lt;code\u0026gt;cat |\u0026lt;/code\u0026gt; if:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;the complexity of the processing is similar to a simple grep\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;performance matters more than readability.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Otherwise it does not matter whether you use \u0026lt;code\u0026gt;\u0026amp;lt;\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;cat |\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;And thus you should only give a UUoC-award if and only if:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;you can measure a significant difference in the performance (publish your measurements when you give the award)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;performance matters more than readability.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I think that (the traditional way) using pipe is a bit more faster; on my box I used \u0026lt;code\u0026gt;strace\u0026lt;/code\u0026gt; command to see what\u0026apos;s going on:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Without pipe:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;toc@UnixServer:~$ strace \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wc\u0026lt;/span\u0026gt; -l \u0026amp;lt; wrong_output.c\nexecve(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/usr/bin/wc\u0026quot;\u0026lt;/span\u0026gt;, [\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;wc\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;-l\u0026quot;\u0026lt;/span\u0026gt;], [/* 18 vars */]) = 0\nbrk(0)                                  = 0x8b50000\naccess(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/etc/ld.so.nohwcap\u0026quot;\u0026lt;/span\u0026gt;, F_OK)      = -1 ENOENT (No such file or directory)\nmmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb77ad000\naccess(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/etc/ld.so.preload\u0026quot;\u0026lt;/span\u0026gt;, R_OK)      = -1 ENOENT (No such file or directory)\nopen(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/etc/ld.so.cache\u0026quot;\u0026lt;/span\u0026gt;, O_RDONLY)      = 3\nfstat64(3, {st_mode=S_IFREG|0644, st_size=29107, ...}) = 0\nmmap2(NULL, 29107, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb77a5000\nclose(3)                                = 0\naccess(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/etc/ld.so.nohwcap\u0026quot;\u0026lt;/span\u0026gt;, F_OK)      = -1 ENOENT (No such file or directory)\nopen(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/lib/i386-linux-gnu/libc.so.6\u0026quot;\u0026lt;/span\u0026gt;, O_RDONLY) = 3\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read\u0026lt;/span\u0026gt;(3, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\177ELF\\1\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\3\\0\\1\\0\\0\\0p\\222\\1\\0004\\0\\0\\0\u0026quot;\u0026lt;/span\u0026gt;..., 512) = 512\nfstat64(3, {st_mode=S_IFREG|0755, st_size=1552584, ...}) = 0\nmmap2(NULL, 1563160, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xb7627000\nmmap2(0xb779f000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x178) = 0xb779f000\nmmap2(0xb77a2000, 10776, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb77a2000\nclose(3)                                = 0\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7626000\nset_thread_area({entry_number:-1 -\u0026amp;gt; 6, base_addr:0xb76268d0, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;limit\u0026lt;/span\u0026gt;:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0\nmprotect(0xb779f000, 8192, PROT_READ)   = 0\nmprotect(0x804f000, 4096, PROT_READ)    = 0\nmprotect(0xb77ce000, 4096, PROT_READ)   = 0\nmunmap(0xb77a5000, 29107)               = 0\nbrk(0)                                  = 0x8b50000\nbrk(0x8b71000)                          = 0x8b71000\nopen(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/usr/lib/locale/locale-archive\u0026quot;\u0026lt;/span\u0026gt;, O_RDONLY|O_LARGEFILE) = 3\nfstat64(3, {st_mode=S_IFREG|0644, st_size=5540198, ...}) = 0\nmmap2(NULL, 2097152, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7426000\nmmap2(NULL, 1507328, PROT_READ, MAP_PRIVATE, 3, 0x2a8) = 0xb72b6000\nclose(3)                                = 0\nopen(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/usr/share/locale/locale.alias\u0026quot;\u0026lt;/span\u0026gt;, O_RDONLY) = 3\nfstat64(3, {st_mode=S_IFREG|0644, st_size=2570, ...}) = 0\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb77ac000\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read\u0026lt;/span\u0026gt;(3, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;# Locale name alias data base.\\n#\u0026quot;\u0026lt;/span\u0026gt;..., 4096) = 2570\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read\u0026lt;/span\u0026gt;(3, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;, 4096)                       = 0\nclose(3)                                = 0\nmunmap(0xb77ac000, 4096)                = 0\nopen(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/usr/share/locale/fr_FR.UTF-8/LC_MESSAGES/coreutils.mo\u0026quot;\u0026lt;/span\u0026gt;, O_RDONLY) = -1 ENOENT (No such file or directory)\nopen(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/usr/share/locale/fr_FR.utf8/LC_MESSAGES/coreutils.mo\u0026quot;\u0026lt;/span\u0026gt;, O_RDONLY) = -1 ENOENT (No such file or directory)\nopen(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/usr/share/locale/fr_FR/LC_MESSAGES/coreutils.mo\u0026quot;\u0026lt;/span\u0026gt;, O_RDONLY) = -1 ENOENT (No such file or directory)\nopen(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/usr/share/locale/fr.UTF-8/LC_MESSAGES/coreutils.mo\u0026quot;\u0026lt;/span\u0026gt;, O_RDONLY) = -1 ENOENT (No such file or directory)\nopen(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/usr/share/locale/fr.utf8/LC_MESSAGES/coreutils.mo\u0026quot;\u0026lt;/span\u0026gt;, O_RDONLY) = -1 ENOENT (No such file or directory)\nopen(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/usr/share/locale/fr/LC_MESSAGES/coreutils.mo\u0026quot;\u0026lt;/span\u0026gt;, O_RDONLY) = -1 ENOENT (No such file or directory)\nopen(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/usr/share/locale-langpack/fr_FR.UTF-8/LC_MESSAGES/coreutils.mo\u0026quot;\u0026lt;/span\u0026gt;, O_RDONLY) = -1 ENOENT (No such file or directory)\nopen(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/usr/share/locale-langpack/fr_FR.utf8/LC_MESSAGES/coreutils.mo\u0026quot;\u0026lt;/span\u0026gt;, O_RDONLY) = -1 ENOENT (No such file or directory)\nopen(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/usr/share/locale-langpack/fr_FR/LC_MESSAGES/coreutils.mo\u0026quot;\u0026lt;/span\u0026gt;, O_RDONLY) = -1 ENOENT (No such file or directory)\nopen(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/usr/share/locale-langpack/fr.UTF-8/LC_MESSAGES/coreutils.mo\u0026quot;\u0026lt;/span\u0026gt;, O_RDONLY) = -1 ENOENT (No such file or directory)\nopen(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/usr/share/locale-langpack/fr.utf8/LC_MESSAGES/coreutils.mo\u0026quot;\u0026lt;/span\u0026gt;, O_RDONLY) = -1 ENOENT (No such file or directory)\nopen(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/usr/share/locale-langpack/fr/LC_MESSAGES/coreutils.mo\u0026quot;\u0026lt;/span\u0026gt;, O_RDONLY) = 3\nfstat64(3, {st_mode=S_IFREG|0644, st_size=316721, ...}) = 0\nmmap2(NULL, 316721, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7268000\nclose(3)                                = 0\nopen(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/usr/lib/i386-linux-gnu/gconv/gconv-modules.cache\u0026quot;\u0026lt;/span\u0026gt;, O_RDONLY) = 3\nfstat64(3, {st_mode=S_IFREG|0644, st_size=26064, ...}) = 0\nmmap2(NULL, 26064, PROT_READ, MAP_SHARED, 3, 0) = 0xb7261000\nclose(3)                                = 0\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read\u0026lt;/span\u0026gt;(0, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;#include\u0026amp;lt;stdio.h\u0026amp;gt;\\n\\nint main(int \u0026quot;\u0026lt;/span\u0026gt;..., 16384) = 180\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read\u0026lt;/span\u0026gt;(0, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;, 16384)                      = 0\nfstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 2), ...}) = 0\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7260000\nwrite(1, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;13\\n\u0026quot;\u0026lt;/span\u0026gt;, 313\n)                     = 3\nclose(0)                                = 0\nclose(1)                                = 0\nmunmap(0xb7260000, 4096)                = 0\nclose(2)                                = 0\nexit_group(0)                           = ?\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And with pipe:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;toc@UnixServer:~$ strace \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cat\u0026lt;/span\u0026gt; wrong_output.c | \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wc\u0026lt;/span\u0026gt; -l\nexecve(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/bin/cat\u0026quot;\u0026lt;/span\u0026gt;, [\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;cat\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;wrong_output.c\u0026quot;\u0026lt;/span\u0026gt;], [/* 18 vars */]) = 0\nbrk(0)                                  = 0xa017000\naccess(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/etc/ld.so.nohwcap\u0026quot;\u0026lt;/span\u0026gt;, F_OK)      = -1 ENOENT (No such file or directory)\nmmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb774b000\naccess(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/etc/ld.so.preload\u0026quot;\u0026lt;/span\u0026gt;, R_OK)      = -1 ENOENT (No such file or directory)\nopen(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/etc/ld.so.cache\u0026quot;\u0026lt;/span\u0026gt;, O_RDONLY)      = 3\nfstat64(3, {st_mode=S_IFREG|0644, st_size=29107, ...}) = 0\nmmap2(NULL, 29107, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7743000\nclose(3)                                = 0\naccess(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/etc/ld.so.nohwcap\u0026quot;\u0026lt;/span\u0026gt;, F_OK)      = -1 ENOENT (No such file or directory)\nopen(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/lib/i386-linux-gnu/libc.so.6\u0026quot;\u0026lt;/span\u0026gt;, O_RDONLY) = 3\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read\u0026lt;/span\u0026gt;(3, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\177ELF\\1\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\3\\0\\1\\0\\0\\0p\\222\\1\\0004\\0\\0\\0\u0026quot;\u0026lt;/span\u0026gt;..., 512) = 512\nfstat64(3, {st_mode=S_IFREG|0755, st_size=1552584, ...}) = 0\nmmap2(NULL, 1563160, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xb75c5000\nmmap2(0xb773d000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x178) = 0xb773d000\nmmap2(0xb7740000, 10776, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7740000\nclose(3)                                = 0\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb75c4000\nset_thread_area({entry_number:-1 -\u0026amp;gt; 6, base_addr:0xb75c48d0, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;limit\u0026lt;/span\u0026gt;:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0\nmprotect(0xb773d000, 8192, PROT_READ)   = 0\nmprotect(0x8051000, 4096, PROT_READ)    = 0\nmprotect(0xb776c000, 4096, PROT_READ)   = 0\nmunmap(0xb7743000, 29107)               = 0\nbrk(0)                                  = 0xa017000\nbrk(0xa038000)                          = 0xa038000\nopen(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/usr/lib/locale/locale-archive\u0026quot;\u0026lt;/span\u0026gt;, O_RDONLY|O_LARGEFILE) = 3\nfstat64(3, {st_mode=S_IFREG|0644, st_size=5540198, ...}) = 0\nmmap2(NULL, 2097152, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb73c4000\nmmap2(NULL, 1507328, PROT_READ, MAP_PRIVATE, 3, 0x2a8) = 0xb7254000\nclose(3)                                = 0\nfstat64(1, {st_mode=S_IFIFO|0600, st_size=0, ...}) = 0\nopen(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;wrong_output.c\u0026quot;\u0026lt;/span\u0026gt;, O_RDONLY|O_LARGEFILE) = 3\nfstat64(3, {st_mode=S_IFREG|0664, st_size=180, ...}) = 0\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read\u0026lt;/span\u0026gt;(3, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;#include\u0026amp;lt;stdio.h\u0026amp;gt;\\n\\nint main(int \u0026quot;\u0026lt;/span\u0026gt;..., 32768) = 180\nwrite(1, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;#include\u0026amp;lt;stdio.h\u0026amp;gt;\\n\\nint main(int \u0026quot;\u0026lt;/span\u0026gt;..., 180) = 180\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read\u0026lt;/span\u0026gt;(3, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;, 32768)                      = 0\nclose(3)                                = 0\nclose(1)                                = 0\nclose(2)                                = 0\nexit_group(0)                           = ?\n13\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You can do some testing with \u0026lt;code\u0026gt;strace\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;time\u0026lt;/code\u0026gt; command with more and longer commands for good benchmarking.\u0026lt;/p\u0026gt;\n    "],"id":550,"title":"Useless use of cat?","content":"\n                \n\u0026lt;p\u0026gt;This is probably in many FAQs - instead of using:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cat\u0026lt;/span\u0026gt; file | \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;command\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;(which is called useless use of cat), correct way supposed to be:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;command\u0026lt;/span\u0026gt; \u0026amp;lt; file\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In the 2nd, \u0026quot;correct\u0026quot; way - OS does not have to spawn an extra process.\u0026lt;br\u0026gt;\nDespite knowing that, I continued to use useless cat for 2 reasons.\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;more aesthetic - I like when data moves uniformly only from left to right. And it easier to replace \u0026lt;code\u0026gt;cat\u0026lt;/code\u0026gt; with something else (\u0026lt;code\u0026gt;gzcat\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;echo\u0026lt;/code\u0026gt;, ...), add a 2nd file or insert new filter (\u0026lt;code\u0026gt;pv\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;mbuffer\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;grep\u0026lt;/code\u0026gt; ...).\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;I \u0026quot;felt\u0026quot; that it might be faster in some cases.  Faster because there are 2 processes, 1st (\u0026lt;code\u0026gt;cat\u0026lt;/code\u0026gt;) does the reading and the second does whatever.   And they can run in parallel, which means sometimes faster execution.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;Is my logic correct (for 2nd reason)?\u0026lt;/p\u0026gt;\n    ","slug":"useless-use-of-cat-1657388390794","postType":"QUESTION","createdAt":"2022-07-09T17:39:50.000Z","updatedAt":"2022-07-09T17:39:50.000Z","tags":[{"id":2676,"name":"cat","slug":"cat","createdAt":"2022-07-09T17:39:50.000Z","updatedAt":"2022-07-09T17:39:50.000Z","Questions_Tags":{"questionId":550,"tagId":2676}}],"relatedQuestions":[{"title":"Useless use of cat?","slug":"useless-use-of-cat-1657388390794","tags":[{"name":"cat","Questions_Tags":{"questionId":550,"tagId":2676}}]}]},"randomQuestions":[{"title":"Reference  What does this symbol mean in PHP?","slug":"reference-what-does-this-symbol-mean-in-php-1657384561666"},{"title":"What's the difference between INNER JOIN, LEFT JOIN, RIGHT JOIN and FULL JOIN? [duplicate]","slug":"what's-the-difference-between-inner-join-left-join-right-join-and-full-join-duplicate-1657388082887"},{"title":"The difference between bracket [ ] and double bracket [[ ]] for accessing the elements of a list or dataframe","slug":"the-difference-between-bracket-and-double-bracket-for-accessing-the-elements-of-a-list-or-dataframe-1657388451711"},{"title":"Which equals operator (== vs ===) should be used in JavaScript comparisons?","slug":"which-equals-operator-(-vs-)-should-be-used-in-javascript-comparisons-1657384663105"},{"title":"What's the simplest way to print a Java array?","slug":"what's-the-simplest-way-to-print-a-java-array-1657384702397"},{"title":"Post an HTML Table to ADO.NET DataTable","slug":"post-an-html-table-to-ado.net-datatable-1657387462723"},{"title":"How do I copy to the clipboard in JavaScript?","slug":"how-do-i-copy-to-the-clipboard-in-javascript-1657385501223"},{"title":"Alternatives to gprof [closed]","slug":"alternatives-to-gprof-closed-1657388336554"},{"title":"How to replace all occurrences of a string in JavaScript","slug":"how-to-replace-all-occurrences-of-a-string-in-javascript-1657384895467"},{"title":"How to remove items from a list while iterating?","slug":"how-to-remove-items-from-a-list-while-iterating-1657384496375"},{"title":"re.findall behaves weird","slug":"re.findall-behaves-weird-1657388408049"},{"title":"What and where are the stack and heap?","slug":"what-and-where-are-the-stack-and-heap-1657387415361"},{"title":"Sending Email in Android using JavaMail API without using the default/built-in app","slug":"sending-email-in-android-using-javamail-api-without-using-the-defaultbuilt-in-app-1657387883400"},{"title":"How do I revert a Git repository to a previous commit?","slug":"how-do-i-revert-a-git-repository-to-a-previous-commit-1657387714717"},{"title":"How does JavaScript .prototype work?","slug":"how-does-javascript-.prototype-work-1657388169270"},{"title":"var functionName = function() {} vs function functionName() {}","slug":"var-functionname-function()-vs-function-functionname()-1657384724077"},{"title":"My regex is matching too much. How do I make it stop? [duplicate]","slug":"my-regex-is-matching-too-much.-how-do-i-make-it-stop-duplicate-1657384845028"},{"title":"How do you get the footer to stay at the bottom of a Web page?","slug":"how-do-you-get-the-footer-to-stay-at-the-bottom-of-a-web-page-1657387817544"},{"title":"How does the Java 'for each' loop work?","slug":"how-does-the-java-'for-each'-loop-work-1657388423749"},{"title":"Order Bars in ggplot2 bar graph","slug":"order-bars-in-ggplot2-bar-graph-1657388099080"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"useless-use-of-cat-1657388390794"},"buildId":"BnkbnjkWYxefPXjTJLVVv","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>