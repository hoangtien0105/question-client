{"pageProps":{"data":{"answer":["\n&lt;p&gt;A typical situation where you encounter strict aliasing problems is when overlaying a struct (like a device/network msg) onto a buffer of the word size of your system (like a pointer to &lt;code&gt;uint32_t&lt;/code&gt;s or &lt;code&gt;uint16_t&lt;/code&gt;s). When you overlay a struct onto such a buffer, or a buffer onto such a struct through pointer casting you can easily violate strict aliasing rules.&lt;/p&gt;\n&lt;p&gt;So in this kind of setup, if I want to send a message to something I&apos;d have to have two incompatible pointers pointing to the same chunk of memory. I might then naively code something like this:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Msg&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a;\n    &lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b;\n} Msg;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;SendWord&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;uint32_t&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Get a 32-bit buffer from the system&lt;/span&gt;\n    &lt;span class=&quot;hljs-type&quot;&gt;uint32_t&lt;/span&gt;* buff = &lt;span class=&quot;hljs-built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;(Msg));\n    \n    &lt;span class=&quot;hljs-comment&quot;&gt;// Alias that buffer through message&lt;/span&gt;\n    Msg* msg = (Msg*)(buff);\n    \n    &lt;span class=&quot;hljs-comment&quot;&gt;// Send a bunch of messages    &lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;; ++i)\n    {\n        msg-&amp;gt;a = i;\n        msg-&amp;gt;b = i+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n        &lt;span class=&quot;hljs-built_in&quot;&gt;SendWord&lt;/span&gt;(buff[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]);\n        &lt;span class=&quot;hljs-built_in&quot;&gt;SendWord&lt;/span&gt;(buff[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]);   \n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The strict aliasing rule makes this setup illegal: dereferencing a pointer that aliases an object that is not of a &lt;a href=&quot;http://en.cppreference.com/w/c/language/type&quot; rel=&quot;noreferrer&quot;&gt;compatible type&lt;/a&gt; or one of the other types allowed by C 2011 6.5 paragraph 7&lt;sup&gt;1&lt;/sup&gt; is undefined behavior. Unfortunately, you can still code this way, &lt;em&gt;maybe&lt;/em&gt; get some warnings, have it compile fine, only to have weird unexpected behavior when you run the code.&lt;/p&gt;\n&lt;p&gt;(GCC appears somewhat inconsistent in its ability to give aliasing warnings, sometimes giving us a friendly warning and sometimes not.)&lt;/p&gt;\n&lt;p&gt;To see why this behavior is undefined, we have to think about what the strict aliasing rule buys the compiler. Basically, with this rule, it doesn&apos;t have to think about inserting instructions to refresh the contents of &lt;code&gt;buff&lt;/code&gt; every run of the loop. Instead, when optimizing, with some annoyingly unenforced assumptions about aliasing, it can omit those instructions, load &lt;code&gt;buff[0]&lt;/code&gt; and &lt;code&gt;buff[1]&lt;/code&gt; into CPU registers once before the loop is run, and speed up the body of the loop. Before strict aliasing was introduced, the compiler had to live in a state of paranoia that the contents of &lt;code&gt;buff&lt;/code&gt; could change by any preceding memory stores. So to get an extra performance edge, and assuming most people don&apos;t type-pun pointers, the strict aliasing rule was introduced.&lt;/p&gt;\n&lt;p&gt;Keep in mind, if you think the example is contrived, this might even happen if you&apos;re passing a buffer to another function doing the sending for you, if instead you have.&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;SendMessage&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;uint32_t&lt;/span&gt;* buff, &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; size32)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; size32; ++i) \n    {\n        &lt;span class=&quot;hljs-built_in&quot;&gt;SendWord&lt;/span&gt;(buff[i]);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;And rewrote our earlier loop to take advantage of this convenient function&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-erlang&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(int i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;; ++i)&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-title&quot;&gt;msg&lt;/span&gt;-&amp;gt;&lt;/span&gt;a = i;\n    msg-&amp;gt;b = i+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    SendMessage(buff, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The compiler may or may not be able to or smart enough to try to inline SendMessage and it may or may not decide to load or not load buff again. If &lt;code&gt;SendMessage&lt;/code&gt; is part of another API that&apos;s compiled separately, it probably has instructions to load buff&apos;s contents. Then again, maybe you&apos;re in C++ and this is some templated header only implementation that the compiler thinks it can inline. Or maybe it&apos;s just something you wrote in your .c file for your own convenience. Anyway undefined behavior might still ensue. Even when we know some of what&apos;s happening under the hood, it&apos;s still a violation of the rule so no well defined behavior is guaranteed. So just by wrapping in a function that takes our word delimited buffer doesn&apos;t necessarily help.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;So how do I get around this?&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;Use a union. Most compilers support this without complaining about strict aliasing. This is allowed in C99 and explicitly allowed in C11.&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-objectivec&quot;&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;union&lt;/span&gt; {\n      Msg msg;\n      &lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; asBuffer[&lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(Msg)/&lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;)];\n  };\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;You can disable strict aliasing in your compiler (&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc-4.6.1/gcc/Optimize-Options.html#index-fstrict_002daliasing-825&quot; rel=&quot;noreferrer&quot;&gt;f[no-]strict-aliasing&lt;/a&gt; in gcc))&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;You can use &lt;code&gt;char*&lt;/code&gt; for aliasing instead of your system&apos;s word. The rules allow an exception for &lt;code&gt;char*&lt;/code&gt; (including &lt;code&gt;signed char&lt;/code&gt; and &lt;code&gt;unsigned char&lt;/code&gt;). It&apos;s always assumed that &lt;code&gt;char*&lt;/code&gt; aliases other types. However this won&apos;t work the other way: there&apos;s no assumption that your struct aliases a buffer of chars.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;Beginner beware&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;This is only one potential minefield when overlaying two types onto each other. You should also learn about &lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot; rel=&quot;noreferrer&quot;&gt;endianness&lt;/a&gt;, &lt;a href=&quot;http://web.archive.org/web/20170708093042/http://www.cs.umd.edu:80/class/sum2003/cmsc311/Notes/Data/aligned.html&quot; rel=&quot;noreferrer&quot;&gt;word alignment&lt;/a&gt;, and how to deal with alignment issues through &lt;a href=&quot;http://grok2.com/structure_packing.html&quot; rel=&quot;noreferrer&quot;&gt;packing structs&lt;/a&gt; correctly.&lt;/p&gt;\n&lt;h2&gt;Footnote&lt;/h2&gt;\n&lt;p&gt;&lt;sup&gt;1&lt;/sup&gt; The types that C 2011 6.5 7 allows an lvalue to access are:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;a type compatible with the effective type of the object,&lt;/li&gt;\n&lt;li&gt;a qualified version of a type compatible with the effective type of the object,&lt;/li&gt;\n&lt;li&gt;a type that is the signed or unsigned type corresponding to the effective type of the object,&lt;/li&gt;\n&lt;li&gt;a type that is the signed or unsigned type corresponding to a qualified version of the effective type of the object,&lt;/li&gt;\n&lt;li&gt;an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union), or&lt;/li&gt;\n&lt;li&gt;a character type.&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;The best explanation I have found is by Mike Acton, &lt;a href=&quot;http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html&quot; rel=&quot;noreferrer&quot;&gt;Understanding Strict Aliasing&lt;/a&gt;. It&apos;s focused a little on PS3 development, but that&apos;s basically just GCC.&lt;/p&gt;\n\n&lt;p&gt;From the article:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;&quot;Strict aliasing is an assumption, made by the C (or C++) compiler, that dereferencing pointers to objects of different types will never refer to the same memory location (i.e. alias each other.)&quot;&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;So basically if you have an &lt;code&gt;int*&lt;/code&gt; pointing to some memory containing an &lt;code&gt;int&lt;/code&gt; and then you point a &lt;code&gt;float*&lt;/code&gt; to that memory and use it as a &lt;code&gt;float&lt;/code&gt; you break the rule. If your code does not respect this, then the compiler&apos;s optimizer will most likely break your code.&lt;/p&gt;\n\n&lt;p&gt;The exception to the rule is a &lt;code&gt;char*&lt;/code&gt;, which is allowed to point to any type.&lt;/p&gt;\n    ","\n&lt;h2&gt;Note&lt;/h2&gt;\n&lt;p&gt;This is excerpted from my &lt;a href=&quot;https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8&quot; rel=&quot;nofollow noreferrer&quot;&gt;&quot;What is the Strict Aliasing Rule and Why do we care?&quot;&lt;/a&gt; write-up.&lt;/p&gt;\n&lt;h2&gt;What is strict aliasing?&lt;/h2&gt;\n&lt;p&gt;In C and C++ aliasing has to do with what expression types we are allowed to access stored values through. In both C and C++ the standard specifies which expression types are allowed to alias which types. The compiler and optimizer are allowed to assume we follow the aliasing rules strictly, hence the term &lt;em&gt;strict aliasing rule&lt;/em&gt;. If we attempt to access a value using a type not allowed it is classified as &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/ub&quot; rel=&quot;nofollow noreferrer&quot;&gt;undefined behavior&lt;/a&gt; (&lt;strong&gt;UB&lt;/strong&gt;). Once we have undefined behavior all bets are off, the results of our program are no longer reliable.&lt;/p&gt;\n&lt;p&gt;Unfortunately with strict aliasing violations, we will often obtain the results we expect, leaving the possibility the a future version of a compiler with a new optimization will break code we thought was valid. This is undesirable and it is a worthwhile goal to understand the strict aliasing rules and how to avoid violating them.&lt;/p&gt;\n&lt;p&gt;To understand more about why we care, we will discuss issues that come up when violating strict aliasing rules, type punning since common techniques used in type punning often violate strict aliasing rules and how to type pun correctly.&lt;/p&gt;\n&lt;h3&gt;Preliminary examples&lt;/h3&gt;\n&lt;p&gt;Let&apos;s look at some examples, then we can talk about exactly what the standard(s) say, examine some further examples and then see how to avoid strict aliasing and catch violations we missed. Here is an example that should not be surprising (&lt;a href=&quot;https://wandbox.org/permlink/7sCJTAyrifZ0zfFA&quot; rel=&quot;nofollow noreferrer&quot;&gt;live example&lt;/a&gt;):&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *ip = &amp;amp;x;\n\nstd::cout &amp;lt;&amp;lt; *ip &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n&quot;&lt;/span&gt;;\n*ip = &lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;;\nstd::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;We have a &lt;em&gt;int*&lt;/em&gt; pointing to memory occupied by an &lt;em&gt;int&lt;/em&gt; and this is a valid aliasing. The optimizer must assume that assignments through &lt;strong&gt;ip&lt;/strong&gt; could update the value occupied by &lt;strong&gt;x&lt;/strong&gt;.&lt;/p&gt;\n&lt;p&gt;The next example shows aliasing that leads to undefined behavior (&lt;a href=&quot;https://wandbox.org/permlink/8qA8JyJRVHtS9LPf&quot; rel=&quot;nofollow noreferrer&quot;&gt;live example&lt;/a&gt;):&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;( &lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt; *f, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *i )&lt;/span&gt; &lt;/span&gt;{ \n    *i = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    *f = &lt;span class=&quot;hljs-number&quot;&gt;0.f&lt;/span&gt;;\n    \n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; *i;\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n    \n    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n&quot;&lt;/span&gt;;   &lt;span class=&quot;hljs-comment&quot;&gt;// Expect 0&lt;/span&gt;\n    x = &lt;span class=&quot;hljs-built_in&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt;*&amp;gt;(&amp;amp;x), &amp;amp;x);\n    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n&quot;&lt;/span&gt;;   &lt;span class=&quot;hljs-comment&quot;&gt;// Expect 0?&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In the function &lt;strong&gt;foo&lt;/strong&gt; we take an &lt;em&gt;int*&lt;/em&gt; and a &lt;em&gt;float*&lt;/em&gt;, in this example we call &lt;strong&gt;foo&lt;/strong&gt; and set both parameters to point to the same memory location which in this example contains an &lt;em&gt;int&lt;/em&gt;. Note, the &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/reinterpret_cast&quot; rel=&quot;nofollow noreferrer&quot;&gt;reinterpret_cast&lt;/a&gt; is telling the compiler to treat the expression as if it had the type specified by its template parameter. In this case we are telling it to treat the expression &lt;strong&gt;&amp;amp;x&lt;/strong&gt; as if it had type &lt;em&gt;float*&lt;/em&gt;. We may naively expect the result of the second &lt;strong&gt;cout&lt;/strong&gt; to be &lt;strong&gt;0&lt;/strong&gt; but with optimization enabled using &lt;strong&gt;-O2&lt;/strong&gt; both gcc and clang produce the following result:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-undefined&quot;&gt;0\n1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Which may not be expected but is perfectly valid since we have invoked undefined behavior. A &lt;em&gt;float&lt;/em&gt; can not validly alias an &lt;em&gt;int&lt;/em&gt; object. Therefore the optimizer can assume the &lt;em&gt;constant 1&lt;/em&gt; stored when dereferencing &lt;strong&gt;i&lt;/strong&gt; will be the return value since a store through &lt;strong&gt;f&lt;/strong&gt; could not validly affect an &lt;em&gt;int&lt;/em&gt; object. Plugging the code in Compiler Explorer shows this is exactly what is happening(&lt;a href=&quot;https://godbolt.org/g/yNV5aj&quot; rel=&quot;nofollow noreferrer&quot;&gt;live example&lt;/a&gt;):&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-sql&quot;&gt;foo(&lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;hljs-operator&quot;&gt;*&lt;/span&gt;, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;hljs-operator&quot;&gt;*&lt;/span&gt;): # &lt;span class=&quot;hljs-variable&quot;&gt;@foo&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;hljs-operator&quot;&gt;*&lt;/span&gt;, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;hljs-operator&quot;&gt;*&lt;/span&gt;)\nmov dword ptr [rsi], &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\nmov dword ptr [rdi], &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;\nmov eax, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\nret\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The optimizer using &lt;a href=&quot;http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/DDJ/2000/0010/0010d/0010d.htm&quot; rel=&quot;nofollow noreferrer&quot;&gt;Type-Based Alias Analysis (TBAA)&lt;/a&gt; assumes &lt;strong&gt;1&lt;/strong&gt; will be returned and directly moves the constant value into register &lt;strong&gt;eax&lt;/strong&gt; which carries the return value. TBAA uses the languages rules about what types are allowed to alias to optimize loads and stores. In this case TBAA knows that a &lt;em&gt;float&lt;/em&gt; can not alias an &lt;em&gt;int&lt;/em&gt; and optimizes away the load of &lt;strong&gt;i&lt;/strong&gt;.&lt;/p&gt;\n&lt;h2&gt;Now, to the Rule-Book&lt;/h2&gt;\n&lt;p&gt;What exactly does the standard say we are allowed and not allowed to do? The standard language is not straightforward, so for each item I will try to provide code examples that demonstrates the meaning.&lt;/p&gt;\n&lt;h3&gt;What does the C11 standard say?&lt;/h3&gt;\n&lt;p&gt;The &lt;strong&gt;C11&lt;/strong&gt; standard says the following in section &lt;em&gt;6.5 Expressions paragraph 7&lt;/em&gt;:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;An object shall have its stored value accessed only by an lvalue expression that has one of the following types:&lt;sup&gt;88)&lt;/sup&gt;\n a type compatible with the effective type of the object,&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-perl&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;x&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; *p = &amp;amp;&lt;span class=&quot;hljs-keyword&quot;&gt;x&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, *p); &lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;/span&gt; *p gives us an lvalue expression of type &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; which is compatible with &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt; a qualified version of a type compatible with the effective type of the object,&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *p = &amp;amp;x;\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, *p); &lt;span class=&quot;hljs-comment&quot;&gt;// *p gives us an lvalue expression of type const int which is compatible with int&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt; a type that is the signed or unsigned type corresponding to the effective type of the object,&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *p = (&lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*)&amp;amp;x;\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%u\\n&quot;&lt;/span&gt;, *p ); &lt;span class=&quot;hljs-comment&quot;&gt;// *p gives us an lvalue expression of type unsigned int which corresponds to &lt;/span&gt;\n                     &lt;span class=&quot;hljs-comment&quot;&gt;// the effective type of the object&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;a href=&quot;https://twitter.com/shafikyaghmour/status/957702383810658304&quot; rel=&quot;nofollow noreferrer&quot;&gt;gcc/clang has an extension&lt;/a&gt; and &lt;a href=&quot;https://gcc.gnu.org/ml/gcc/2003-10/msg00184.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;also&lt;/a&gt; that allows assigning &lt;em&gt;unsigned int*&lt;/em&gt; to &lt;em&gt;int*&lt;/em&gt; even though they are not compatible types.&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt; a type that is the signed or unsigned type corresponding to a qualified version of the effective type of the object,&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *p = (&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*)&amp;amp;x;\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%u\\n&quot;&lt;/span&gt;, *p ); &lt;span class=&quot;hljs-comment&quot;&gt;// *p gives us an lvalue expression of type const unsigned int which is a unsigned type &lt;/span&gt;\n                     &lt;span class=&quot;hljs-comment&quot;&gt;// that corresponds with to a qualified version of the effective type of the object&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt; an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union), or&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; foo {\n    &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; x;\n};\n    \n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foobar&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; foo *fp, &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; *ip &lt;/span&gt;)&lt;/span&gt;;  &lt;span class=&quot;hljs-comment&quot;&gt;// struct foo is an aggregate that includes int among its members so it&lt;/span&gt;\n                                         &lt;span class=&quot;hljs-comment&quot;&gt;// can alias with *ip&lt;/span&gt;\n\nfoo f;\nfoobar( &amp;amp;f, &amp;amp;f.x );\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt; a character type.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;65&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *p = (&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *)&amp;amp;x;\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%c\\n&quot;&lt;/span&gt;, *p );  &lt;span class=&quot;hljs-comment&quot;&gt;// *p gives us an lvalue expression of type char which is a character type.&lt;/span&gt;\n                      &lt;span class=&quot;hljs-comment&quot;&gt;// The results are not portable due to endianness issues.&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;What the C++17 Draft Standard says&lt;/h3&gt;\n&lt;p&gt;The C++17 draft standard in section &lt;em&gt;[basic.lval] paragraph 11&lt;/em&gt; says:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:&lt;sup&gt;63&lt;/sup&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;(11.1)  the dynamic type of the object,&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; *p = &lt;span class=&quot;hljs-built_in&quot;&gt;malloc&lt;/span&gt;( &lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;) ); &lt;span class=&quot;hljs-comment&quot;&gt;// We have allocated storage but not started the lifetime of an object&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *ip = &lt;span class=&quot;hljs-built_in&quot;&gt;new&lt;/span&gt; (p) &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;{&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;};        &lt;span class=&quot;hljs-comment&quot;&gt;// Placement new changes the dynamic type of the object to int&lt;/span&gt;\nstd::cout &amp;lt;&amp;lt; *ip &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n&quot;&lt;/span&gt;;        &lt;span class=&quot;hljs-comment&quot;&gt;// *ip gives us a glvalue expression of type int which matches the dynamic type &lt;/span&gt;\n                                 &lt;span class=&quot;hljs-comment&quot;&gt;// of the allocated object&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;(11.2)  a cv-qualified version of the dynamic type of the object,&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *cip = &amp;amp;x;\nstd::cout &amp;lt;&amp;lt; *cip &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n&quot;&lt;/span&gt;;  &lt;span class=&quot;hljs-comment&quot;&gt;// *cip gives us a glvalue expression of type const int which is a cv-qualified &lt;/span&gt;\n                            &lt;span class=&quot;hljs-comment&quot;&gt;// version of the dynamic type of x&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;(11.3)  a type similar (as defined in 7.5) to the dynamic type of the object,&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;(11.4)  a type that is the signed or unsigned type corresponding to the dynamic type of the object,&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Both si and ui are signed or unsigned types corresponding to each others dynamic types&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// We can see from this godbolt(https://godbolt.org/g/KowGXB) the optimizer assumes aliasing.&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;signed&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;( &lt;span class=&quot;hljs-type&quot;&gt;signed&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &amp;amp;si, &lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &amp;amp;ui )&lt;/span&gt; &lt;/span&gt;{\n    si = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    ui = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; si;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;(11.5)  a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;signed&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;( &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;signed&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &amp;amp;si1, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &amp;amp;si2)&lt;/span&gt;&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// Hard to show this one assumes aliasing&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;(11.6)  an aggregate or union type that includes one of the aforementioned types among its elements or nonstatic data members (including, recursively, an element or non-static data member of a subaggregate or contained union),&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; foo {\n    &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; x;\n};\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// Compiler Explorer example(https://godbolt.org/g/z2wJTC) shows aliasing assumption&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foobar&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt; foo &amp;amp;fp, &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &amp;amp;ip &lt;/span&gt;)&lt;/span&gt; {\n    fp.x = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    ip = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; fp.x;\n}\n\nfoo f;\nfoobar( f, f.x );\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;(11.7)  a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; foo { &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; x; };\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; bar : &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; foo {};\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foobar&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt; foo &amp;amp;f, bar &amp;amp;b &lt;/span&gt;)&lt;/span&gt; {\n    f.x = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    b.x = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; f.x;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;(11.8)  a char, unsigned char, or std::byte type.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;( std::&lt;span class=&quot;hljs-type&quot;&gt;byte&lt;/span&gt; &amp;amp;b, uint32_t &amp;amp;ui )&lt;/span&gt; {\n    b = static_cast&amp;lt;std::&lt;span class=&quot;hljs-type&quot;&gt;byte&lt;/span&gt;&amp;gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;);\n    ui = &lt;span class=&quot;hljs-number&quot;&gt;0xFFFFFFFF&lt;/span&gt;;\n  \n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; std::to_integer&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;( b );  &lt;span class=&quot;hljs-comment&quot;&gt;// b gives us a glvalue expression of type std::byte which can alias&lt;/span&gt;\n                                       &lt;span class=&quot;hljs-comment&quot;&gt;// an object of type uint32_t&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Worth noting &lt;em&gt;signed char&lt;/em&gt; is not included in the list above, this is a notable difference from &lt;em&gt;C&lt;/em&gt; which says &lt;em&gt;a character type&lt;/em&gt;.&lt;/p&gt;\n&lt;h2&gt;What is Type Punning&lt;/h2&gt;\n&lt;p&gt;We have gotten to this point and we may be wondering, why would we want to alias for? The answer typically is to &lt;em&gt;type pun&lt;/em&gt;, often the methods used violate strict aliasing rules.&lt;/p&gt;\n&lt;p&gt;Sometimes we want to circumvent the type system and interpret an object as a different type. This is called &lt;em&gt;type punning&lt;/em&gt;, to reinterpret a segment of memory as another type. &lt;em&gt;Type punning&lt;/em&gt; is useful for tasks that want access to the underlying representation of an object to view, transport or manipulate. Typical areas we find type punning being used are compilers, serialization, networking code, etc&lt;/p&gt;\n&lt;p&gt;Traditionally this has been accomplished by taking the address of the object, casting it to a pointer of the type we want to reinterpret it as and then accessing the value, or in other words by aliasing. For example:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// In C&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt; *fp = (&lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt;*)&amp;amp;x;  &lt;span class=&quot;hljs-comment&quot;&gt;// Not a valid aliasing&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// In C++&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt; *fp = &lt;span class=&quot;hljs-built_in&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt;*&amp;gt;(&amp;amp;x);  &lt;span class=&quot;hljs-comment&quot;&gt;// Not a valid aliasing&lt;/span&gt;\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;( &lt;span class=&quot;hljs-string&quot;&gt;&quot;%f\\n&quot;&lt;/span&gt;, *fp );\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;As we have seen earlier this is not a valid aliasing, so we are invoking undefined behavior. But traditionally compilers did not take advantage of strict aliasing rules and this type of code usually just worked, developers have unfortunately gotten used to doing things this way. A common alternate method for type punning is through unions, which is valid in C but &lt;em&gt;undefined behavior&lt;/em&gt; in C++ (&lt;a href=&quot;https://wandbox.org/permlink/oOf9bPlcWDYrYqPF&quot; rel=&quot;nofollow noreferrer&quot;&gt;see live example&lt;/a&gt;):&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;u1&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; n;\n    &lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt; f;\n};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;u1&lt;/span&gt; u;\nu.f = &lt;span class=&quot;hljs-number&quot;&gt;1.0f&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;( &lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, u.n );  &lt;span class=&quot;hljs-comment&quot;&gt;// UB in C++ n is not the active member&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This is not valid in C++ and some consider the purpose of unions to be solely for implementing variant types and feel using unions for type punning is an abuse.&lt;/p&gt;\n&lt;h3&gt;How do we Type Pun correctly?&lt;/h3&gt;\n&lt;p&gt;The standard method for &lt;em&gt;type punning&lt;/em&gt; in both C and C++ is &lt;strong&gt;memcpy&lt;/strong&gt;. This may seem a little heavy handed but the optimizer should recognize the use of &lt;strong&gt;memcpy&lt;/strong&gt; for &lt;em&gt;type punning&lt;/em&gt; and optimize it away and generate a register to register move. For example if we know &lt;em&gt;int64_t&lt;/em&gt; is the same size as &lt;em&gt;double&lt;/em&gt;:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;static_assert( &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;( &lt;span class=&quot;hljs-built_in&quot;&gt;double&lt;/span&gt; ) == &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;( int64_t ) );  &lt;span class=&quot;hljs-comment&quot;&gt;// C++17 does not require a message&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;we can use &lt;strong&gt;memcpy&lt;/strong&gt;:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;func1&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;( &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; d )&lt;/span&gt; &lt;/span&gt;{\n    std::&lt;span class=&quot;hljs-type&quot;&gt;int64_t&lt;/span&gt; n;\n    std::&lt;span class=&quot;hljs-built_in&quot;&gt;memcpy&lt;/span&gt;(&amp;amp;n, &amp;amp;d, &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; d);\n    &lt;span class=&quot;hljs-comment&quot;&gt;//...&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;At a sufficient optimization level any decent modern compiler generates identical code to the previously mentioned &lt;strong&gt;reinterpret_cast&lt;/strong&gt; method or &lt;em&gt;union&lt;/em&gt; method for &lt;em&gt;type punning&lt;/em&gt;. Examining the generated code we see it uses just register mov (&lt;a href=&quot;https://godbolt.org/g/BfZGwX&quot; rel=&quot;nofollow noreferrer&quot;&gt;live Compiler Explorer Example&lt;/a&gt;).&lt;/p&gt;\n&lt;h2&gt;C++20 and bit_cast&lt;/h2&gt;\n&lt;p&gt;In C++20 we may gain &lt;strong&gt;bit_cast&lt;/strong&gt; (&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0476r2.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;implementation available in link from proposal&lt;/a&gt;) which gives a simple and safe way to type-pun as well as being usable in a constexpr context.&lt;/p&gt;\n&lt;p&gt;The following is an example of how to use &lt;strong&gt;bit_cast&lt;/strong&gt; to type pun a &lt;em&gt;unsigned int&lt;/em&gt; to &lt;em&gt;float&lt;/em&gt;, (&lt;a href=&quot;https://wandbox.org/permlink/i5l0g4IYuCFgLzzl&quot; rel=&quot;nofollow noreferrer&quot;&gt;see it live&lt;/a&gt;):&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;bit_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt;&amp;gt;(&lt;span class=&quot;hljs-number&quot;&gt;0x447a0000&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n&quot;&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;//assuming sizeof(float) == sizeof(unsigned int)&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In the case where &lt;em&gt;To&lt;/em&gt; and &lt;em&gt;From&lt;/em&gt; types don&apos;t have the same size, it requires us to use an intermediate struct15. We will use a struct containing a &lt;strong&gt;sizeof( unsigned int )&lt;/strong&gt; character array (&lt;em&gt;assumes 4 byte unsigned int&lt;/em&gt;) to be the &lt;em&gt;From&lt;/em&gt; type and &lt;em&gt;unsigned int&lt;/em&gt; as the &lt;em&gt;To&lt;/em&gt; type.:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;uint_chars&lt;/span&gt; {\n    &lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; arr[&lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;( &lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; )] = {};  &lt;span class=&quot;hljs-comment&quot;&gt;// Assume sizeof( unsigned int ) == 4&lt;/span&gt;\n};\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// Assume len is a multiple of 4 &lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;( &lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *p, &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; len )&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; result = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;( &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; index = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; index &amp;lt; len; index += &lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;) ) {\n        uint_chars f;\n        std::&lt;span class=&quot;hljs-built_in&quot;&gt;memcpy&lt;/span&gt;( f.arr, &amp;amp;p[index], &lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;));\n        &lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; result = &lt;span class=&quot;hljs-built_in&quot;&gt;bit_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;(f);\n\n        result += &lt;span class=&quot;hljs-built_in&quot;&gt;foo&lt;/span&gt;( result );\n    }\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; result;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;It is unfortunate that we need this intermediate type but that is the current constraint of &lt;strong&gt;bit_cast&lt;/strong&gt;.&lt;/p&gt;\n&lt;h2&gt;Catching Strict Aliasing Violations&lt;/h2&gt;\n&lt;p&gt;We don&apos;t have a lot of good tools for catching strict aliasing in C++, the tools we have will catch some cases of strict aliasing violations and some cases of misaligned loads and stores.&lt;/p&gt;\n&lt;p&gt;gcc using the flag &lt;strong&gt;-fstrict-aliasing&lt;/strong&gt; and &lt;strong&gt;-Wstrict-aliasing&lt;/strong&gt; can catch some cases although not without false positives/negatives. For example the following cases will generate a warning in gcc (&lt;a href=&quot;https://wandbox.org/permlink/cfckjTgwNTYHDIry&quot; rel=&quot;nofollow noreferrer&quot;&gt;see it live&lt;/a&gt;):&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;short&lt;/span&gt; j;\n&lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt; f = &lt;span class=&quot;hljs-number&quot;&gt;1.f&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// Originally not initialized but tis-kernel caught &lt;/span&gt;\n               &lt;span class=&quot;hljs-comment&quot;&gt;// it was being accessed w/ an indeterminate value below&lt;/span&gt;\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%i\\n&quot;&lt;/span&gt;, j = *(&lt;span class=&quot;hljs-built_in&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;short&lt;/span&gt;*&amp;gt;(&amp;amp;a)));\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%i\\n&quot;&lt;/span&gt;, j = *(&lt;span class=&quot;hljs-built_in&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*&amp;gt;(&amp;amp;f)));\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;although it will not catch this additional case (&lt;a href=&quot;https://wandbox.org/permlink/dwd9jhy53AF7a2D0&quot; rel=&quot;nofollow noreferrer&quot;&gt;see it live&lt;/a&gt;):&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *p;\n\np = &amp;amp;a;\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%i\\n&quot;&lt;/span&gt;, j = *(&lt;span class=&quot;hljs-built_in&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;short&lt;/span&gt;*&amp;gt;(p)));\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Although clang allows these flags it apparently does not actually implement the warnings.&lt;/p&gt;\n&lt;p&gt;Another tool we have available to us is ASan which can catch misaligned loads and stores. Although these are not directly strict aliasing violations they are a common result of strict aliasing violations. For example the following cases will generate runtime errors when built with clang using &lt;strong&gt;-fsanitize=address&lt;/strong&gt;&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *x = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;];               &lt;span class=&quot;hljs-comment&quot;&gt;// 8 bytes: [0,7].&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *u = (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*)((&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;*)x + &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;);     &lt;span class=&quot;hljs-comment&quot;&gt;// regardless of alignment of x this will not be an aligned address&lt;/span&gt;\n*u = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;                            &lt;span class=&quot;hljs-comment&quot;&gt;// Access to range [6-9]&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;( &lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, *u );              &lt;span class=&quot;hljs-comment&quot;&gt;// Access to range [6-9]&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The last tool I will recommend is C++ specific and not strictly a tool but a coding practice, don&apos;t allow C-style casts. Both gcc and clang will produce a diagnostic for C-style casts using &lt;strong&gt;-Wold-style-cast&lt;/strong&gt;. This will force any undefined type puns to use reinterpret_cast, in general reinterpret_cast should be a flag for closer code review. It is also easier to search your code base for reinterpret_cast to perform an audit.&lt;/p&gt;\n&lt;p&gt;For C we have all the tools already covered and we also have tis-interpreter, a static analyzer that exhaustively analyzes a program for a large subset of the C language. Given a C version of the earlier example where using &lt;strong&gt;-fstrict-aliasing&lt;/strong&gt; misses one case (&lt;a href=&quot;https://wandbox.org/permlink/ebLBJ17Pg7TsnIgY&quot; rel=&quot;nofollow noreferrer&quot;&gt;see it live&lt;/a&gt;)&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;short&lt;/span&gt; j;\n&lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt; f = &lt;span class=&quot;hljs-number&quot;&gt;1.0&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%i\\n&quot;&lt;/span&gt;, j = *((&lt;span class=&quot;hljs-type&quot;&gt;short&lt;/span&gt;*)&amp;amp;a));\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%i\\n&quot;&lt;/span&gt;, j = *((&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*)&amp;amp;f));\n    \n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *p;\n\np = &amp;amp;a;\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%i\\n&quot;&lt;/span&gt;, j = *((&lt;span class=&quot;hljs-type&quot;&gt;short&lt;/span&gt;*)p));\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;tis-interpeter is able to catch all three, the following example invokes tis-kernel as tis-interpreter (output is edited for brevity):&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;./bin/tis-kernel -sa example1.c \n...\nexample1.c:&lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;:[sa] warning: &lt;span class=&quot;hljs-function&quot;&gt;The &lt;span class=&quot;hljs-title&quot;&gt;pointer&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;short&lt;/span&gt; *&lt;/span&gt;)(&lt;span class=&quot;hljs-params&quot;&gt;&amp;amp; a&lt;/span&gt;) has type &lt;span class=&quot;hljs-built_in&quot;&gt;short&lt;/span&gt; *. It violates strict aliasing\n              rules &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; accessing a cell &lt;span class=&quot;hljs-keyword&quot;&gt;with&lt;/span&gt; effective type &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;.\n...\n\nexample1.c:10:[sa] warning: The &lt;span class=&quot;hljs-title&quot;&gt;pointer&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; *&lt;/span&gt;)(&lt;span class=&quot;hljs-params&quot;&gt;&amp;amp; f&lt;/span&gt;) has type &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; *. It violates strict aliasing rules &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt;\n              accessing a cell &lt;span class=&quot;hljs-keyword&quot;&gt;with&lt;/span&gt; effective type &lt;span class=&quot;hljs-built_in&quot;&gt;float&lt;/span&gt;.\n              Callstack: main\n...\n\nexample1.c:15:[sa] warning: The &lt;span class=&quot;hljs-title&quot;&gt;pointer&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;short&lt;/span&gt; *&lt;/span&gt;)p has type &lt;span class=&quot;hljs-built_in&quot;&gt;short&lt;/span&gt; *. It violates strict aliasing rules &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt;\n              accessing a cell &lt;span class=&quot;hljs-keyword&quot;&gt;with&lt;/span&gt; effective type &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;.\n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Finally there is &lt;a href=&quot;https://www.youtube.com/watch?v=vAXJeN7k32Y&quot; rel=&quot;nofollow noreferrer&quot;&gt;TySan&lt;/a&gt; which is currently in development. This sanitizer adds type checking information in a shadow memory segment and checks accesses to see if they violate aliasing rules. The tool potentially should be able to catch all aliasing violations but may have a large run-time overhead.&lt;/p&gt;\n    ","\n&lt;p&gt;This is the strict aliasing rule, found in section 3.10 of the &lt;strong&gt;C++03&lt;/strong&gt; standard (other answers provide good explanation, but none provided the rule itself):&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;If a program attempts to access the stored value of an object through an lvalue of other than one of the following types the behavior is undefined:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;the dynamic type of the object,&lt;/li&gt;\n&lt;li&gt;a cv-qualified version of the dynamic type of the object,&lt;/li&gt;\n&lt;li&gt;a type that is the signed or unsigned type corresponding to the dynamic type of the object,&lt;/li&gt;\n&lt;li&gt;a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,&lt;/li&gt;\n&lt;li&gt;an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union),&lt;/li&gt;\n&lt;li&gt;a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,&lt;/li&gt;\n&lt;li&gt;a &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt; type.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;strong&gt;C++11&lt;/strong&gt; and &lt;strong&gt;C++14&lt;/strong&gt; wording (changes emphasized):&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;If a program attempts to access the stored value of an object through a &lt;em&gt;glvalue&lt;/em&gt; of other than one of the following types the behavior is undefined:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;the dynamic type of the object,&lt;/li&gt;\n&lt;li&gt;a cv-qualified version of the dynamic type of the object,&lt;/li&gt;\n&lt;li&gt;&lt;em&gt;a type similar (as defined in 4.4) to the dynamic type of the object,&lt;/em&gt;&lt;/li&gt;\n&lt;li&gt;a type that is the signed or unsigned type corresponding to the dynamic type of the object,&lt;/li&gt;\n&lt;li&gt;a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,&lt;/li&gt;\n&lt;li&gt;an aggregate or union type that includes one of the aforementioned types among its &lt;em&gt;elements or non-static data members&lt;/em&gt; (including, recursively, an &lt;em&gt;element or non-static data member&lt;/em&gt; of a subaggregate or contained union),&lt;/li&gt;\n&lt;li&gt;a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,&lt;/li&gt;\n&lt;li&gt;a &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt; type.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Two changes were small: &lt;em&gt;glvalue&lt;/em&gt; instead of &lt;em&gt;lvalue&lt;/em&gt;, and clarification of the aggregate/union case.&lt;/p&gt;\n&lt;p&gt;The third change makes a stronger guarantee (relaxes the strong aliasing rule): The new concept of &lt;em&gt;similar types&lt;/em&gt; that are now safe to alias.&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;Also the &lt;strong&gt;C&lt;/strong&gt; wording (C99; ISO/IEC 9899:1999 6.5/7; the exact same wording is used in ISO/IEC 9899:2011 §6.5 ¶7):&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;An object shall have its stored value accessed only by an lvalue\nexpression that has one of the following types &lt;sup&gt; 73) or 88)&lt;/sup&gt;:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;a type compatible with the effective type of the object,&lt;/li&gt;\n&lt;li&gt;a qualied version of a type compatible with the effective type of\nthe object,&lt;/li&gt;\n&lt;li&gt;a type that is the signed or unsigned type corresponding to the\neffective type of the object,&lt;/li&gt;\n&lt;li&gt;a type that is the signed or unsigned type corresponding to a\nqualied version of the effective type of the object,&lt;/li&gt;\n&lt;li&gt;an aggregate or union type that includes one of the aforementioned\ntypes among its members (including, recursively, a member of a\nsubaggregate or contained union), or&lt;/li&gt;\n&lt;li&gt;a character type.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;sup&gt; 73) or 88)&lt;/sup&gt; The intent of this list is to specify those circumstances in which an object may or may not be aliased.&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;Strict aliasing doesn&apos;t refer only to pointers, it affects references as well, I wrote a paper about it for the boost developer wiki and it was so well received that I turned it into a page on my consulting web site.  It explains completely what it is, why it confuses people so much and what to do about it. &lt;a href=&quot;http://dbp-consulting.com/tutorials/StrictAliasing.html&quot;&gt;Strict Aliasing White Paper&lt;/a&gt;.  In particular it explains why unions are risky behavior for C++, and why using memcpy is the only fix portable across both C and C++.  Hope this is helpful.&lt;/p&gt;\n    ","\n&lt;p&gt;As addendum to what Doug T. already wrote, here\nis a simple test case which probably triggers it with gcc :&lt;/p&gt;\n\n&lt;p&gt;check.c&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;check&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;short&lt;/span&gt; *h,&lt;span class=&quot;hljs-type&quot;&gt;long&lt;/span&gt; *k)&lt;/span&gt;\n&lt;/span&gt;{\n    *h=&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;\n    *k=&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (*h == &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;)\n        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;strict aliasing problem\\n&quot;&lt;/span&gt;);\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;long&lt;/span&gt;      k[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;];\n    &lt;span class=&quot;hljs-built_in&quot;&gt;check&lt;/span&gt;((&lt;span class=&quot;hljs-type&quot;&gt;short&lt;/span&gt; *)k,k);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Compile with &lt;code&gt;gcc -O2 -o check check.c&lt;/code&gt; .\nUsually (with most gcc versions I tried) this outputs &quot;strict aliasing problem&quot;, because the compiler assumes that &quot;h&quot; cannot be the same address as &quot;k&quot; in the &quot;check&quot; function. Because of that the compiler optimizes the &lt;code&gt;if (*h == 5)&lt;/code&gt; away and always calls the printf.&lt;/p&gt;\n\n&lt;p&gt;For those who are interested here is the x64 assembler code, produced by gcc 4.6.3, running on ubuntu 12.04.2 for x64:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-perl&quot;&gt;movw    $5, (%rdi)\nmovq    $6, (%rsi)\nmovl    $.LC&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, %edi\njmp puts\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So the if condition is completely gone from the assembler code.&lt;/p&gt;\n    ","\n&lt;p&gt;According to the C89 rationale, the authors of the Standard did not want to require that compilers given code like:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; x;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;double&lt;/span&gt; *p&lt;/span&gt;)&lt;/span&gt;\n{\n  x=&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;\n  *p = &lt;span class=&quot;hljs-number&quot;&gt;1.0&lt;/span&gt;;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; x;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;should be required to reload the value of &lt;code&gt;x&lt;/code&gt; between the assignment and return statement so as to allow for the possibility that &lt;code&gt;p&lt;/code&gt; might point to &lt;code&gt;x&lt;/code&gt;, and the assignment to &lt;code&gt;*p&lt;/code&gt; might consequently alter the value of &lt;code&gt;x&lt;/code&gt;.  The notion that a compiler should be entitled to presume that there won&apos;t be aliasing &lt;em&gt;in situations like the above&lt;/em&gt; was non-controversial.&lt;/p&gt;\n\n&lt;p&gt;Unfortunately, the authors of the C89 wrote their rule in a way that, if read literally, would make even the following function invoke Undefined Behavior:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;\n{\n  &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; S {&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; x;} s;\n  s.x = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;because it uses an lvalue of type &lt;code&gt;int&lt;/code&gt; to access an object of type &lt;code&gt;struct S&lt;/code&gt;, and &lt;code&gt;int&lt;/code&gt; is not among the types that may be used accessing a &lt;code&gt;struct S&lt;/code&gt;.  Because it would be absurd to treat all use of non-character-type members of structs and unions as Undefined Behavior, almost everyone recognizes that there are at least some circumstances where an lvalue of one type may be used to access an object of another type.  Unfortunately, the C Standards Committee has failed to define what those circumstances are.&lt;/p&gt;\n\n&lt;p&gt;Much of the problem is a result of Defect Report #028, which asked about the behavior of a program like:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *ip, &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; *dp)&lt;/span&gt;\n&lt;/span&gt;{\n  *ip = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n  *dp = &lt;span class=&quot;hljs-number&quot;&gt;1.23&lt;/span&gt;;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; *ip;\n}\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;test2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;\n&lt;/span&gt;{\n  &lt;span class=&quot;hljs-keyword&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;U&lt;/span&gt; { &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i; &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; d; } u;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;(&amp;amp;u.i, &amp;amp;u.d);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Defect Report #28 states that the program invokes Undefined Behavior because the action of writing a union member of type &quot;double&quot; and reading one of type &quot;int&quot; invokes Implementation-Defined behavior.  Such reasoning is nonsensical, but forms the basis for the Effective Type rules which needlessly complicate the language while doing nothing to address the original problem.&lt;/p&gt;\n\n&lt;p&gt;The best way to resolve the original problem would probably be to treat the\nfootnote about the purpose of the rule as though it were normative, and made\nthe rule unenforceable except in cases which actually involve conflicting accesses using aliases.  Given something like:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;inc_int&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; *p&lt;/span&gt;)&lt;/span&gt; { *p = &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;; }\n &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;\n {\n   &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; *p;\n   &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; S { &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; x; } s;\n   s.x = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n   p = &amp;amp;s.x;\n   inc_int(p);\n   &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; s.x;\n }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;There&apos;s no conflict within &lt;code&gt;inc_int&lt;/code&gt; because all accesses to the storage accessed through &lt;code&gt;*p&lt;/code&gt; are done with an lvalue of type &lt;code&gt;int&lt;/code&gt;, and there&apos;s no conflict in &lt;code&gt;test&lt;/code&gt; because &lt;code&gt;p&lt;/code&gt; is visibly derived from a &lt;code&gt;struct S&lt;/code&gt;, and by the next time &lt;code&gt;s&lt;/code&gt; is used, all accesses to that storage that will ever be made through &lt;code&gt;p&lt;/code&gt; will have already happened.&lt;/p&gt;\n\n&lt;p&gt;If the code were changed slightly...&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;inc_int&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; *p&lt;/span&gt;)&lt;/span&gt; { *p = &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;; }\n &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;\n {\n   &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; *p;\n   &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; S { &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; x; } s;\n   p = &amp;amp;s.x;\n   s.x = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;  &lt;span class=&quot;hljs-comment&quot;&gt;//  !!*!!&lt;/span&gt;\n   *p += &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n   &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; s.x;\n }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here, there is an aliasing conflict between &lt;code&gt;p&lt;/code&gt; and the access to &lt;code&gt;s.x&lt;/code&gt; on the marked line because at that point in execution another reference exists &lt;em&gt;that will be used to access the same storage&lt;/em&gt;.&lt;/p&gt;\n\n&lt;p&gt;Had Defect Report 028 said the original example invoked UB because of the overlap between the creation and use of the two pointers, that would have made things a lot more clear without having to add &quot;Effective Types&quot; or other such complexity.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Type_punning&quot; rel=&quot;noreferrer&quot;&gt;Type punning&lt;/a&gt; via pointer casts (as opposed to using a union) is a major example of breaking strict aliasing.&lt;/p&gt;\n    ","\n&lt;p&gt;After reading many of the answers, I feel the need to add something:&lt;/p&gt;\n\n&lt;p&gt;Strict aliasing (which I&apos;ll describe in a bit) &lt;strong&gt;is important because&lt;/strong&gt;:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;Memory access can be expensive (performance wise), which is why &lt;strong&gt;data is manipulated in CPU registers&lt;/strong&gt; before being written back to the physical memory.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;If data in two different CPU registers will be written to the same memory space, &lt;strong&gt;we can&apos;t predict which data will &quot;survive&quot;&lt;/strong&gt; when we code in C.&lt;/p&gt;\n\n&lt;p&gt;In assembly, where we code the loading and unloading of CPU registers manually, we will know which data remains intact. But C (thankfully) abstracts this detail away.&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;Since two pointers can point to the same location in the memory, this could result in &lt;strong&gt;complex code that handles possible collisions&lt;/strong&gt;.&lt;/p&gt;\n\n&lt;p&gt;This extra code is slow and &lt;strong&gt;hurts performance&lt;/strong&gt; since it performs extra memory read / write operations which are both slower and (possibly) unnecessary.&lt;/p&gt;\n\n&lt;p&gt;The &lt;strong&gt;Strict aliasing rule allows us to avoid redundant machine code&lt;/strong&gt; in cases in which it &lt;em&gt;should be&lt;/em&gt; safe to assume that two pointers don&apos;t point to the same memory block (see also the &lt;code&gt;restrict&lt;/code&gt; keyword).&lt;/p&gt;\n\n&lt;p&gt;The Strict aliasing states it&apos;s safe to assume that pointers to different types point to different locations in the memory.&lt;/p&gt;\n\n&lt;p&gt;If a compiler notices that two pointers point to different types (for example, an &lt;code&gt;int *&lt;/code&gt; and a &lt;code&gt;float *&lt;/code&gt;), it will assume the memory address is different and it &lt;strong&gt;will not&lt;/strong&gt; protect against memory address collisions, resulting in faster machine code.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;For example&lt;/strong&gt;:&lt;/p&gt;\n\n&lt;p&gt;Lets assume the following function:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;merge_two_ints&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; *a, &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; *b&lt;/span&gt;)&lt;/span&gt; {\n  *b += *a;\n  *a += *b;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In order to handle the case in which &lt;code&gt;a == b&lt;/code&gt; (both pointers point to the same memory), we need to order and test the way we load data from the memory to the CPU registers, so the code might end up like this:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;load &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; from memory.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;add &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;save&lt;/strong&gt; &lt;code&gt;b&lt;/code&gt; and &lt;strong&gt;reload&lt;/strong&gt; &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;(save from CPU register to the memory and load from the memory to the CPU register). &lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;add &lt;code&gt;b&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;save &lt;code&gt;a&lt;/code&gt; (from the CPU register) to the memory.&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;Step 3 is very slow because it needs to access the physical memory. However, it&apos;s required to protect against instances where &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; point to the same memory address.&lt;/p&gt;\n\n&lt;p&gt;Strict aliasing would allow us to prevent this by telling the compiler that these memory addresses are distinctly different (which, in this case, will allow even further optimization which can&apos;t be performed if the pointers share a memory address).&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;This can be told to the compiler in two ways, by using different types to point to. i.e.:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;merge_two_numbers&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; *a, &lt;span class=&quot;hljs-built_in&quot;&gt;long&lt;/span&gt; *b&lt;/span&gt;)&lt;/span&gt; {...}\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Using the &lt;code&gt;restrict&lt;/code&gt; keyword. i.e.:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;merge_two_ints&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; * restrict a, &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; * restrict b&lt;/span&gt;)&lt;/span&gt; {...}\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;Now, by satisfying the Strict Aliasing rule, step 3 can be avoided and the code will run significantly faster.&lt;/p&gt;\n\n&lt;p&gt;In fact, by adding the &lt;code&gt;restrict&lt;/code&gt; keyword, the whole function could be optimized to:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;load &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; from memory.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;add &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;save result both to &lt;code&gt;a&lt;/code&gt; and to &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;This optimization couldn&apos;t have been done before, because of the possible collision (where &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; would be tripled instead of doubled).&lt;/p&gt;\n    ","\n&lt;p&gt;Strict aliasing is not allowing different pointer types to the same data.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html&quot; rel=&quot;noreferrer&quot;&gt;This article&lt;/a&gt; should help you understand the issue in full detail.&lt;/p&gt;\n    ","\n&lt;p&gt;Technically in C++, the strict aliasing rule is probably never applicable.&lt;/p&gt;\n\n&lt;p&gt;Note the definition of indirection (&lt;a href=&quot;http://eel.is/c++draft/expr.unary.op#def:indirection&quot; rel=&quot;nofollow noreferrer&quot;&gt;* operator&lt;/a&gt;):&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;The unary * operator performs indirection: the expression to which it\n  is applied shall be a pointer to an object type, or a pointer to a\n  function type and &lt;strong&gt;the result is an lvalue referring to the object&lt;/strong&gt; or\n  function &lt;strong&gt;to which the expression points&lt;/strong&gt;.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Also from &lt;a href=&quot;http://eel.is/c++draft/basic.lval#1.1&quot; rel=&quot;nofollow noreferrer&quot;&gt;the definition of glvalue&lt;/a&gt;&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;A glvalue is an expression whose evaluation determines the identity of\n  an object, (...snip)&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;So in any well defined program trace, a glvalue refers to an object. &lt;strong&gt;So the so called strict aliasing rule doesn&apos;t apply, ever.&lt;/strong&gt; This may not be what the designers wanted.&lt;/p&gt;\n    "],"comment":["\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;May also want to see an article I wrote recently &lt;a href=&quot;https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8&quot; rel=&quot;nofollow noreferrer&quot;&gt;What is the Strict Aliasing Rule and Why do we care?&lt;/a&gt;. It covers a lot of material not covered here or in some areas a more modern approach.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1708801/shafik-yaghmour&quot; title=&quot;148,993 reputation&quot; class=&quot;comment-user&quot;&gt;Shafik Yaghmour&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment86940881_98650&quot;&gt;&lt;span title=&quot;2018-04-22 04:06:43Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 22, 2018 at 4:06&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;I am coming after the battle it seems.. may &lt;code&gt;unsigned char*&lt;/code&gt; be used far &lt;code&gt;char*&lt;/code&gt; instead ? I tend to use &lt;code&gt;unsigned char&lt;/code&gt; rather than &lt;code&gt;char&lt;/code&gt; as the underlying type for &lt;code&gt;byte&lt;/code&gt; because my bytes are not signed and I don&apos;t want the weirdness of signed behavior (notably wrt to overflow)&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/147192/matthieu-m&quot; title=&quot;269,974 reputation&quot; class=&quot;comment-user&quot;&gt;Matthieu M.&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment4496197_99010&quot;&gt;&lt;span title=&quot;2010-11-12 12:48:06Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Nov 12, 2010 at 12:48&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Matthieu: Signedness makes no difference to alias rules, so using &lt;code&gt;unsigned char *&lt;/code&gt; is okay.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/239916/thomas-eding&quot; title=&quot;33,589 reputation&quot; class=&quot;comment-user&quot;&gt;Thomas Eding&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment7226492_99010&quot;&gt;&lt;span title=&quot;2011-06-01 21:24:08Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 1, 2011 at 21:24&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Isn&apos;t it undefined behaviour to read from an union member different from the last one written to?&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/46642/r-martinho-fernandes&quot; title=&quot;219,978 reputation&quot; class=&quot;comment-user&quot;&gt;R. Martinho Fernandes&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment8826384_99010&quot;&gt;&lt;span title=&quot;2011-09-06 14:41:25Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Sep 6, 2011 at 14:41&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Bollocks, this answer is &lt;i&gt;completely backwards&lt;/i&gt;. The example it shows as illegal is actually legal, and the example it shows as legal is actually illegal.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/46642/r-martinho-fernandes&quot; title=&quot;219,978 reputation&quot; class=&quot;comment-user&quot;&gt;R. Martinho Fernandes&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment9093646_99010&quot;&gt;&lt;span title=&quot;2011-09-22 03:08:33Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Sep 22, 2011 at 3:08&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Your &lt;code&gt;uint32_t* buff = malloc(sizeof(Msg));&lt;/code&gt; and the subsequent union &lt;code&gt;unsigned int asBuffer[sizeof(Msg)];&lt;/code&gt; buffer declarations will have different sizes and neither is correct. The &lt;code&gt;malloc&lt;/code&gt; call is relying on the 4 byte alignment under the hood (don&apos;t do it) and the union will be 4 times bigger than it needs to be... I understand that it is for clarity but it bugs me none-the-less...&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1667513/nonsensickle&quot; title=&quot;4,318 reputation&quot; class=&quot;comment-user&quot;&gt;nonsensickle&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment33152570_99010&quot;&gt;&lt;span title=&quot;2014-02-19 21:24:32Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Feb 19, 2014 at 21:24&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;So what is the canonical way to legally use the same memory with variables of 2 different types? or does everyone just copy?&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/4627134/jiggunjer&quot; title=&quot;1,682 reputation&quot; class=&quot;comment-user&quot;&gt;jiggunjer&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment50833657_98702&quot;&gt;&lt;span title=&quot;2015-07-15 13:24:27Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jul 15, 2015 at 13:24&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Mike Acton&apos;s page is flawed. The part of &quot;Casting through a union (2)&quot;, at least, is downright wrong; the code he claims is legal is not.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/388661/davmac&quot; title=&quot;19,635 reputation&quot; class=&quot;comment-user&quot;&gt;davmac&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment52712135_98702&quot;&gt;&lt;span title=&quot;2015-09-06 12:13:48Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Sep 6, 2015 at 12:13&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@davmac: The authors of C89 never intended that it should force programmers to jump through hoops.  I find thoroughly bizarre the notion that a rule that exists for the sole purpose of optimization should be interpreted in such fashion as to require programmers to write code that redundantly copies data in the hopes that an optimizer will remove the redundant code.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment63067047_98702&quot;&gt;&lt;span title=&quot;2016-06-13 23:30:35Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 13, 2016 at 23:30&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@curiousguy: False. Firstly, the original conceptual idea behind unions was that at any moment there&apos;s &lt;b&gt;only one&lt;/b&gt; member object &quot;active&quot; in the given union object, while the others simply don&apos;t exist. So, there are no &quot;different objects at the same address&quot; as you seem to believe. Secondly, aliasing violations everyone is talking about is about &lt;b&gt;accessing&lt;/b&gt; one object as a different object, not about simply &lt;i&gt;having&lt;/i&gt; two objects with the same address. As long as there is no type-punning &lt;b&gt;access&lt;/b&gt;, there no problem. That was the original idea. Later, type-punning through unions was allowed.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/187690/ant-stop-the-ukronazis&quot; title=&quot;302,970 reputation&quot; class=&quot;comment-user&quot;&gt;AnT - Stop the UkroNazis&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment81962571_98702&quot;&gt;&lt;span title=&quot;2017-11-27 03:01:57Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Nov 27, 2017 at 3:01&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 3 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;The exception is wider than &lt;code&gt;char *&lt;/code&gt; --&amp;gt; Applies to any character type.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/2410359/chux-reinstate-monica&quot; title=&quot;128,312 reputation&quot; class=&quot;comment-user&quot;&gt;chux - Reinstate Monica&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment109112928_98702&quot;&gt;&lt;span title=&quot;2020-05-08 18:51:49Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;May 8, 2020 at 18:51&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Comments are not for extended discussion; this conversation has been &lt;a href=&quot;https://chat.stackoverflow.com/rooms/177456/discussion-on-answer-by-shafik-yaghmour-what-is-the-strict-aliasing-rule&quot;&gt;moved to chat&lt;/a&gt;.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/4099593/bhargav-rao&quot; title=&quot;46,221 reputation&quot; class=&quot;comment-user&quot;&gt;Bhargav Rao&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment90358503_51228315&quot;&gt;&lt;span title=&quot;2018-08-05 21:51:33Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Aug 5, 2018 at 21:51&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;If I could, +10, well written and explained, also from both sides, compiler writers and programmers... the only criticism: It would be nice to have counter examples above, to see what is prohibited by the standard, its not obvious kind of :-)&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/293195/gabriel&quot; title=&quot;8,201 reputation&quot; class=&quot;comment-user&quot;&gt;Gabriel&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment93961184_51228315&quot;&gt;&lt;span title=&quot;2018-11-29 20:45:41Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Nov 29, 2018 at 20:45&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Very good answer. I only regret that the initial examples are given in C++, which makes it hard to follow for people like me who only know or care about C and have no idea what &lt;code&gt;reinterpret_cast&lt;/code&gt; might do or what &lt;code&gt;cout&lt;/code&gt; might mean. (It&apos;s all right to mention C++ but the original question was about C and IIUC these examples could just as validly be written in C.)&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/2647466/gro-tsen&quot; title=&quot;211 reputation&quot; class=&quot;comment-user&quot;&gt;Gro-Tsen&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment104025073_51228315&quot;&gt;&lt;span title=&quot;2019-11-15 14:25:16Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Nov 15, 2019 at 14:25&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Regarding type puning: so if I write an array of some type X into file  , then read from that file this array into memory  pointed with  void*  , then I cast that pointer to the real type of the data in order to use it - that&apos;s undefined behavior?&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/507043/michael-iv&quot; title=&quot;10,527 reputation&quot; class=&quot;comment-user&quot;&gt;Michael IV&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment108104397_51228315&quot;&gt;&lt;span title=&quot;2020-04-08 17:09:43Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 8, 2020 at 17:09&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Why &lt;code&gt;cip&lt;/code&gt; is glvalue in the example of (11.2) in the section &lt;b&gt;What the C++17 Draft Standard say&lt;/b&gt;? It looks like the lvalue, does it? It looks equal with the 2nd example in the section &lt;b&gt;What does the C11 standard say?&lt;/b&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/5441023/bogdan&quot; title=&quot;548 reputation&quot; class=&quot;comment-user&quot;&gt;Bogdan&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment115517938_51228315&quot;&gt;&lt;span title=&quot;2020-12-17 13:40:30Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Dec 17, 2020 at 13:40&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Look at the C89 Rationale &lt;a href=&quot;http://www.cs.technion.ac.il/users/yechiel/CS/C++draft/rationale.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;cs.technion.ac.il/users/yechiel/CS/C++draft/rationale.pdf&lt;/a&gt; section 3.3 which talks about it.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/805830/phorgan1&quot; title=&quot;1,574 reputation&quot; class=&quot;comment-user&quot;&gt;phorgan1&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment10881081_7005988&quot;&gt;&lt;span title=&quot;2012-01-05 01:44:36Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jan 5, 2012 at 1:44&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;If one has an lvalue of a structure type, takes the address of a member, and passes that to a function that uses it as a pointer to the member type, would that be regarded as accessing an object of the member type (legal), or an object of the structure type (forbidden)?  A &lt;i&gt;lot&lt;/i&gt; of code assumes it&apos;s legal to access structures in such fashion, and I think a lot of people would squawk at a rule which was understood as forbidding such actions, but it&apos;s unclear what the exact rules are.  Further, unions and structures are treated the same, but sensible rules for each should be different.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment55685166_7005988&quot;&gt;&lt;span title=&quot;2015-11-27 19:45:40Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Nov 27, 2015 at 19:45&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@supercat: The way the rule for structures is worded, the actual access is always to the primitive type.  Then access via a reference to the primitive type is legal because the types match, and access via a reference to the containing structure type is legal because it&apos;s specially permitted.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/103167/ben-voigt&quot; title=&quot;270,533 reputation&quot; class=&quot;comment-user&quot;&gt;Ben Voigt&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment55686143_7005988&quot;&gt;&lt;span title=&quot;2015-11-27 20:27:27Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Nov 27, 2015 at 20:27&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@BenVoigt: Under that interpretation, if &lt;code&gt;S1&lt;/code&gt; and &lt;code&gt;S2&lt;/code&gt; are structures with &lt;code&gt;int x;&lt;/code&gt; as their first field, and which require nothing coarser than &lt;code&gt;int&lt;/code&gt; alignment, then given &lt;code&gt;void blah(S1 *p1, S2, *p2&lt;/code&gt;);` a compiler would not be allowed to make any assumptions about aliasing between &lt;code&gt;p1-&amp;gt;x&lt;/code&gt; and &lt;code&gt;p2-&amp;gt;x&lt;/code&gt;.  because they could both identify storage of type &lt;code&gt;int&lt;/code&gt;.  I don&apos;t think that&apos;s what was intended.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment55686387_7005988&quot;&gt;&lt;span title=&quot;2015-11-27 20:39:47Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Nov 27, 2015 at 20:39&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 2 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@BenVoigt: I don&apos;t think the common initial sequence works unless accesses are done via the union.  See &lt;a href=&quot;http://goo.gl/HGOyoK&quot; rel=&quot;nofollow noreferrer&quot;&gt;goo.gl/HGOyoK&lt;/a&gt; to see what gcc is doing.  If accessing an lvalue of union type via an lvalue of a member type (not using union-member-access operator) was legal, then &lt;code&gt;wow(&amp;amp;u-&amp;gt;s1,&amp;amp;u-&amp;gt;s2)&lt;/code&gt; would need to be legal even when a pointer is used to modify &lt;code&gt;u&lt;/code&gt;, and that would negate most optimizations that the aliasing rule was designed to facilitate.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment55705164_7005988&quot;&gt;&lt;span title=&quot;2015-11-28 17:50:39Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Nov 28, 2015 at 17:50&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;&quot;&lt;i&gt;Strict aliasing doesn&apos;t refer only to pointers, it affects references as well&lt;/i&gt;&quot; Actually, it refers to &lt;b&gt;lvalues&lt;/b&gt;. &quot;&lt;i&gt;using memcpy is the only fix portable&lt;/i&gt;&quot; Hear!&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/963864/curiousguy&quot; title=&quot;7,758 reputation&quot; class=&quot;comment-user&quot;&gt;curiousguy&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment10469576_6405776&quot;&gt;&lt;span title=&quot;2011-12-11 18:05:25Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Dec 11, 2011 at 18:05&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Good paper. My take: (1) this aliasing-&apos;problem&apos; is an over-reaction to bad programming - trying to protect the bad programmer from his/her bad habits. If the programmer has good habits then this aliasing is just a nuisance and the checks can safely be turned off. (2) Compiler-side optimization should only be done in well-known cases and should when in doubt strictly follow the source-code; forcing the programmer to write code to cater for the compiler&apos;s idiosyncrasies is, simply put, wrong. Even worse to make it part of the standard.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/15161/slashmais&quot; title=&quot;6,953 reputation&quot; class=&quot;comment-user&quot;&gt;slashmais&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment44902202_6405776&quot;&gt;&lt;span title=&quot;2015-02-02 08:29:04Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Feb 2, 2015 at 8:29&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@slashmais (1) &quot;&lt;i&gt;is an over-reaction to bad programming&lt;/i&gt;&quot; Nonsense. It is a rejection of the bad habits. &lt;i&gt;You do that? You pay the price: no guarantee for you!&lt;/i&gt; (2) Well known cases? Which ones? The strict aliasing rule should be &quot;well known&quot;!&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/963864/curiousguy&quot; title=&quot;7,758 reputation&quot; class=&quot;comment-user&quot;&gt;curiousguy&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment51963484_6405776&quot;&gt;&lt;span title=&quot;2015-08-16 01:45:12Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Aug 16, 2015 at 1:45&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@curiousguy: Having cleared up a few points of confusion, it is clear that the C language with the aliasing rules makes it impossible for programs to implement type-agnostic memory pools.  Some kinds of program can get by with malloc/free, but others need memory management logic better tailored to the tasks at hand.  I wonder why the C89 rationale used such a crummy example of the reason for the aliasing rule, since their example makes it seem like the rule won&apos;t pose any major difficulty in performing any reasonable task.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment55447598_6405776&quot;&gt;&lt;span title=&quot;2015-11-21 08:53:30Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Nov 21, 2015 at 8:53&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@curiousguy, most compiler suites out there are including -fstrict-aliasing as default on -O3 and this hidden contract is forced on the users who&apos;ve never heard of the TBAA and wrote code like how a system programmer might. I don&apos;t mean to sound disingenuous to system programmers, but this kind of optimization should be left outside of default opt of -O3 and should be an opt-in optimization for those that know what TBAA is. It is not fun looking at compiler &apos;bug&apos; that turns out to be user code violating TBAA, especially tracking down the source level violation in user code.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1911412/kchoi&quot; title=&quot;473 reputation&quot; class=&quot;comment-user&quot;&gt;kchoi&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment64168321_6405776&quot;&gt;&lt;span title=&quot;2016-07-14 16:09:21Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jul 14, 2016 at 16:09&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;if you add a second short * j to check() and use it ( *j = 7 ) then optimization disapear since ggc does not not if h and j are not actualy point to same value. yes optimisation is really smart.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1521926/philippe-lhardy&quot; title=&quot;2,982 reputation&quot; class=&quot;comment-user&quot;&gt;philippe lhardy&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment31270543_16534243&quot;&gt;&lt;span title=&quot;2013-12-30 20:30:52Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Dec 30, 2013 at 20:30&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;To make things more fun, use pointers to types which aren&apos;t compatible but have the same size and representation (on some systems that&apos;s true of e.g. &lt;code&gt;long long*&lt;/code&gt; and &lt;code&gt;int64_t&lt;/code&gt;*).  One might expect that a sane compiler should recognize that a &lt;code&gt;long long*&lt;/code&gt; and &lt;code&gt;int64_t*&lt;/code&gt; could access the same storage if they&apos;re stored identically, but such treatment is no longer fashionable.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment73017086_16534243&quot;&gt;&lt;span title=&quot;2017-03-22 19:54:41Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 22, 2017 at 19:54&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Grr... x64 is a Microsoft convention. Use amd64 or x86_64 instead.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/10795151/s-s-anne&quot; title=&quot;14,447 reputation&quot; class=&quot;comment-user&quot;&gt;S.S. Anne&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment101055846_16534243&quot;&gt;&lt;span title=&quot;2019-07-30 20:39:24Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Jul 30, 2019 at 20:39&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Well put, it would be interesting to read a proposal of sorts that was more or less &quot;what the standards committee could have done&quot; that achieved their goals without introducing as much complexity.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/4975230/jrh&quot; title=&quot;395 reputation&quot; class=&quot;comment-user&quot;&gt;jrh&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment90194854_43645721&quot;&gt;&lt;span title=&quot;2018-07-31 13:40:51Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Jul 31, 2018 at 13:40&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@jrh: I think it would be pretty simple.  Recognize that 1. For aliasing to occur during a particular execution of a function or loop, two different pointers or lvalues must be used &lt;i&gt;during that execution&lt;/i&gt; to address the same storage in conflicting fashon; 2. Recognize that in contexts where one pointer or lvalue is freshly visibly derived from another, an access to the second is an access to the first; 3. Recognize that the rule is not intended to apply in cases that don&apos;t actually involve aliasing.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment90197755_43645721&quot;&gt;&lt;span title=&quot;2018-07-31 14:47:27Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Jul 31, 2018 at 14:47&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;The exact circumstances where a compiler recognizes a freshly-derived lvalue may be a Quality-of-Implementation issue, but any remotely-decent compiler should be able to recognize forms that gcc and clang deliberately ignore.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment90197860_43645721&quot;&gt;&lt;span title=&quot;2018-07-31 14:49:47Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Jul 31, 2018 at 14:49&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;See my &lt;a href=&quot;http://stackoverflow.com/a/20956250/1708801&quot;&gt;answer here for the relevant quotes, especially the footnotes&lt;/a&gt; but type punning through unions has always been allowed in C although it was poorly worded at first. You my want to clarify your answer.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1708801/shafik-yaghmour&quot; title=&quot;148,993 reputation&quot; class=&quot;comment-user&quot;&gt;Shafik Yaghmour&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment38111968_98700&quot;&gt;&lt;span title=&quot;2014-07-06 18:18:37Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jul 6, 2014 at 18:18&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@ShafikYaghmour: C89 clearly allowed implementers to select the cases in which they would or would not usefully recognize type punning through unions.  An implementation could, for example, specify that for a write to one type followed by a read of another to be recognized as type punning, if the programmer did either of the following &lt;i&gt;between the write and the read&lt;/i&gt;: (1) evaluate an lvalue containing the union type [taking the address of a member would qualify, if done at the right point in the sequence]; (2) convert a pointer to one type into a pointer to the other, and access via that ptr.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment73016646_98700&quot;&gt;&lt;span title=&quot;2017-03-22 19:42:37Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 22, 2017 at 19:42&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 2 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@ShafikYaghmour: An implementation could also specify e.g. that type punning between integer and floating-point values would only work reliably if code executed an &lt;code&gt;fpsync()&lt;/code&gt; directive between writing as fp and reading as int or vice versa [on implementations with separate integer and FPU pipelines and caches, such a directive might be expensive, but not as costly as having the compiler perform such synchronization on every union access].  Or an implementation could specify that the resulting value will never be usable except in circumstances using Common Initial Sequences.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment73016839_98700&quot;&gt;&lt;span title=&quot;2017-03-22 19:48:01Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 22, 2017 at 19:48&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@ShafikYaghmour: Under C89, implementations &lt;i&gt;could&lt;/i&gt; forbid most forms of type punning, including via unions, but the equivalence between pointers to unions and pointers to their members implied that type punning was allowed in implementations that didn&apos;t &lt;i&gt;expressly&lt;/i&gt; forbid it.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment73017005_98700&quot;&gt;&lt;span title=&quot;2017-03-22 19:52:25Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 22, 2017 at 19:52&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;with restrict keyword, at step 3, shouldn&apos;t it be save result to &apos;b&apos; only?  It sounds as if the result of the summation will be stored in &apos;a&apos; as well.  Does it &apos;b&apos; need to be reloaded again?&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/5420223/neilb&quot; title=&quot;323 reputation&quot; class=&quot;comment-user&quot;&gt;NeilB&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment83550054_47960435&quot;&gt;&lt;span title=&quot;2018-01-16 14:08:35Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jan 16, 2018 at 14:08&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@NeilB - Yap you&apos;re right. We&apos;re only saving &lt;code&gt;b&lt;/code&gt; (not reloading it) and reloading &lt;code&gt;a&lt;/code&gt;. I hope it&apos;s clearer now.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/4025095/myst&quot; title=&quot;17,546 reputation&quot; class=&quot;comment-user&quot;&gt;Myst&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment83550252_47960435&quot;&gt;&lt;span title=&quot;2018-01-16 14:13:28Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jan 16, 2018 at 14:13&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Type-based aliasing may have offered some benefits prior to &lt;code&gt;restrict&lt;/code&gt;, but I would think that the latter would in most circumstances be more effective, and loosening some constraints on &lt;code&gt;register&lt;/code&gt; would allow it to fill in some of the cases where &lt;code&gt;restrict&lt;/code&gt; wouldn&apos;t help.  I&apos;m not sure it was ever &quot;important&quot; to treat the Standard as fully describing all cases where programmers should expect compilers to recognize evidence of aliasing, rather than merely describing places where compilers must presume aliasing &lt;i&gt;even when no particular evidence of it exists&lt;/i&gt;.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment83806295_47960435&quot;&gt;&lt;span title=&quot;2018-01-23 18:33:47Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jan 23, 2018 at 18:33&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Note that although loading from main RAM is very slow (and can stall the CPU core for a long time if following operations depend on the result), loading from L1 cache is pretty fast, and so is writing to a cache line that was recently writing to by the same core. So all but the first read or write to an address will usually be reasonably fast: the difference between reg/mem addr access is smaller than the difference between cached/uncached mem addr.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/963864/curiousguy&quot; title=&quot;7,758 reputation&quot; class=&quot;comment-user&quot;&gt;curiousguy&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment103418214_47960435&quot;&gt;&lt;span title=&quot;2019-10-24 20:23:04Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Oct 24, 2019 at 20:23&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@curiousguy - although you&apos;re correct, &quot;fast&quot; in this case is relative. The L1 cache is probably still an order of magnitude slower than CPU registers (I think more than 10 times slower). In addition, the &lt;code&gt;restrict&lt;/code&gt; keyword minimizes not only the speed of the operations but their number as well, which could be meaningful... I mean, after all, the fastest operation is no operation at all :)&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/4025095/myst&quot; title=&quot;17,546 reputation&quot; class=&quot;comment-user&quot;&gt;Myst&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment103418613_47960435&quot;&gt;&lt;span title=&quot;2019-10-24 20:40:50Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Oct 24, 2019 at 20:40&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;You can alias between references and between a reference and a pointer as well.  See my tutorial &lt;a href=&quot;http://dbp-consulting.com/tutorials/StrictAliasing.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;dbp-consulting.com/tutorials/StrictAliasing.html&lt;/a&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/805830/phorgan1&quot; title=&quot;1,574 reputation&quot; class=&quot;comment-user&quot;&gt;phorgan1&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment8467116_98666&quot;&gt;&lt;span title=&quot;2011-08-16 08:47:43Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Aug 16, 2011 at 8:47&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;It is permitted to have different pointer types to the same data. Where strict aliasing comes in is when the same memory location is written through one pointer type and read through another.  Also, some different types are permitted (e.g. &lt;code&gt;int&lt;/code&gt; and a struct which contains an &lt;code&gt;int&lt;/code&gt;).&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1505939/m-m&quot; title=&quot;135,063 reputation&quot; class=&quot;comment-user&quot;&gt;M.M&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment44224175_98666&quot;&gt;&lt;span title=&quot;2015-01-12 23:11:33Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jan 12, 2015 at 23:11&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;The C Standard uses the term &quot;object&quot; to refer to a number of different concepts.  Among them, a sequence of bytes that are exclusively allocated to some purpose, a not-necessarily-exclusive reference to a sequence of bytes to/from which a value of a particular type &lt;i&gt;could be&lt;/i&gt; written or read, or such a reference that &lt;i&gt;actually&lt;/i&gt; has been or will be accessed in some context.  I don&apos;t think there&apos;s any sensible way to define the term &quot;Object&quot; that would be consistent with all the way the Standard uses it.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment89485280_51237865&quot;&gt;&lt;span title=&quot;2018-07-09 20:01:26Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Jul 9, 2018 at 20:01&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@supercat Incorrect. Despite your imagination, it is actually fairly consistent. In ISO C it is defined as &quot;region of data storage in the execution environment, the contents of which can represent values&quot;. In ISO C++ there is a similar definition. Your comment is even more irrelevant than the answer because all you mentioned are ways of &lt;i&gt;representation&lt;/i&gt; to refer objects&apos; &lt;i&gt;content&lt;/i&gt;, while the answer illustrates the C++ concept (glvalue) of a kind of expressions that tightly relates to the &lt;i&gt;identity&lt;/i&gt; of objects. And all aliasing rules are basically relevant to the identity but not the content.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/2307646/frankhb&quot; title=&quot;2,002 reputation&quot; class=&quot;comment-user&quot;&gt;FrankHB&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment107340177_51237865&quot;&gt;&lt;span title=&quot;2020-03-13 12:21:50Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 13, 2020 at 12:21&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@FrankHB: If one declares &lt;code&gt;int foo;&lt;/code&gt;, what is accessed by the lvalue expression &lt;code&gt;*(char*)&amp;amp;foo&lt;/code&gt;?  Is that an object of type &lt;code&gt;char&lt;/code&gt;?  Does that object come into existence at the same time as &lt;code&gt;foo&lt;/code&gt;?  Would writing to &lt;code&gt;foo&lt;/code&gt; change the stored value of that aforementioned object of type &lt;code&gt;char&lt;/code&gt;?  If so, is there any rule that would allow the stored value of an object of type &lt;code&gt;char&lt;/code&gt; to be accessed using an lvalue of type &lt;code&gt;int&lt;/code&gt;?&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment107344016_51237865&quot;&gt;&lt;span title=&quot;2020-03-13 14:35:14Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 13, 2020 at 14:35&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@FrankHB: In the absence of 6.5p7, one could simply say that every region of storage simultaneously contains all objects of every type that could fit in that region of storage, and that accessing that region of storage simultaneously accesses all of them.  Interpreting in such fashion the use of the term &quot;object&quot; in 6.5p7, however, would forbid doing much of anything with non-character-type lvalues, which would clearly be an absurd result and totally defeat the purpose of the rule.  Further, the concept of &quot;object&quot; used everywhere other than 6.5p6 has a static compile-time type, but...&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment107344105_51237865&quot;&gt;&lt;span title=&quot;2020-03-13 14:38:26Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 13, 2020 at 14:38&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;sizeof(int) is 4, does the declaration &lt;code&gt;int i;&lt;/code&gt; create four objects of each character type &lt;code&gt;in addition to one of type &lt;/code&gt;int&lt;code&gt;?  I see no way to apply a consistent definition of &quot;object&quot; which would allow for operations on both &lt;/code&gt;*(char*)&amp;amp;i` and &lt;code&gt;i&lt;/code&gt;.  Finally, there&apos;s nothing in the Standard that allows even a &lt;code&gt;volatile&lt;/code&gt;-qualified pointer to access hardware registers that don&apos;t meet the definition of &quot;object&quot;.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment107385643_51237865&quot;&gt;&lt;span title=&quot;2020-03-15 17:03:41Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 15, 2020 at 17:03&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        "],"id":140,"title":"What is the strict aliasing rule?","content":"\n                \n&lt;p&gt;When asking about &lt;a href=&quot;https://stackoverflow.com/questions/98340/what-are-the-common-undefinedunspecified-behavior-for-c-that-you-run-into&quot;&gt;common undefined behavior in C&lt;/a&gt;, people sometimes refer to the strict aliasing rule.&lt;br&gt;\nWhat are they talking about?&lt;/p&gt;\n    ","slug":"what-is-the-strict-aliasing-rule-1657384742852","postType":"QUESTION","createdAt":"2022-07-09T16:39:02.000Z","updatedAt":"2022-07-09T16:39:02.000Z","tags":[{"id":511,"name":"strict-aliasing","slug":"strict-aliasing","createdAt":"2022-07-09T16:39:02.000Z","updatedAt":"2022-07-09T16:39:02.000Z","Questions_Tags":{"questionId":140,"tagId":511}},{"id":512,"name":"type-punning","slug":"type-punning","createdAt":"2022-07-09T16:39:02.000Z","updatedAt":"2022-07-09T16:39:02.000Z","Questions_Tags":{"questionId":140,"tagId":512}}]}},"__N_SSG":true}