<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2eccd4d47c856f2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2eccd4d47c856f2b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/471-84c36aa98dd4107c.js" defer=""></script><script src="/_next/static/chunks/81-096e453de8a27667.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-e3d1b60e109d3ba1.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_buildManifest.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.hFcsiD code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-6e32c308-0"]{content:"hFcsiD,"}/*!sc*/
.ljvTUN .comment-item .comment-body .d-inline-flex.ai-center{text-align:right;}/*!sc*/
.ljvTUN .comment-item .comment-body .comment-date{float:right;}/*!sc*/
data-styled.g6[id="sc-6e32c308-1"]{content:"ljvTUN,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="https://flowbite.com/docs/images/logo.svg" class="mr-3 h-6 sm:h-9" alt="Flowbite Logo"/><span class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Hunter</span></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/can-a-local-variable&#x27;s-memory-be-accessed-outside-its-scope-1657384460386#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-6e32c308-0 hFcsiD flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/can-a-local-variable&#x27;s-memory-be-accessed-outside-its-scope-1657384460386">Can a local variable&#x27;s memory be accessed outside its scope?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/memory-management">memory-management</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/local-variables">local-variables</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/dangling-pointer">dangling-pointer</a></div></div><div class="question-content mt-5">
                
<p>I have the following code.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> * <span class="hljs-title">foo</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">return</span> &amp;a;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">int</span>* p = <span class="hljs-built_in">foo</span>();
    std::cout &lt;&lt; *p;
    *p = <span class="hljs-number">8</span>;
    std::cout &lt;&lt; *p;
}
</code></pre>

<p>And the code is just running with no runtime exceptions!</p>

<p>The output was <code>58</code></p>

<p>How can it be? Isn't the memory of a local variable inaccessible outside its function?</p>
    </div></div></div><div class="sc-6e32c308-1 ljvTUN flex text-xs pl-10 flex-col comment items-center justify-center"><h4 class="text-left mt-10 text-lg font-semibold">Comments</h4><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy">this won't even compile as is; if you fix the nonforming business, gcc will still warn <code>address of local variable a returned</code>; valgrind shows <code>Invalid write of size 4 [...] Address 0xbefd7114 is just below the stack ptr</code></span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/85371/sehe" title="351,900 reputation" class="comment-user">sehe</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment7561705_6441218"><span title="2011-06-22 14:34:08Z, License: CC BY-SA 3.0" class="relativetime-clean">Jun 22, 2011 at 14:34</span></a></span>
            </div>
        </div><span class="divide-x-8 "></span><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy">@Serge: Back in my youth I once worked on some kinda tricky zero-ring code that ran on the Netware operating system that involved cleverly moving around the stack pointer in a way not exactly sanctioned by the operating system. I'd know when I'd made a mistake because often the stack would end up overlapping the screen memory and I could just watch the bytes get written right onto the display. You can't get away with that sort of thing these days.</span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/88656/eric-lippert" title="632,289 reputation" class="comment-user">Eric Lippert</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment7573092_6441218"><span title="2011-06-23 04:23:38Z, License: CC BY-SA 3.0" class="relativetime-clean">Jun 23, 2011 at 4:23</span></a></span>
            </div>
        </div><span class="divide-x-8 "></span><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy">lol. I needed to read the question and some answers before I even understood where the problem is. Is that actually a question about variable's access scope? You don't even use 'a' outside your function. And that is all there is to it. Throwing around some memory references is a totally different topic from variable scope.</span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/131120/erikbstack" title="12,392 reputation" class="comment-user">erikbstack</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment7574165_6441218"><span title="2011-06-23 06:23:14Z, License: CC BY-SA 3.0" class="relativetime-clean">Jun 23, 2011 at 6:23</span></a></span>
            </div>
        </div><span class="divide-x-8 "></span><button class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">See more</button></div><div class="sc-6e32c308-2 bFXWFO"><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<blockquote>
  <p>How can it be? Isn't the memory of a local variable inaccessible outside its function?</p>
</blockquote>

<p>You rent a hotel room. You put a book in the top drawer of the bedside table and go to sleep.  You check out the next morning, but "forget" to give back your key. You steal the key!</p>

<p>A week later, you return to the hotel, do not check in, sneak into your old room with your stolen key, and look in the drawer. Your book is still there. Astonishing!</p>

<p><strong>How can that be? Aren't the contents of a hotel room drawer inaccessible if you haven't rented the room?</strong></p>

<p>Well, obviously that scenario can happen in the real world no problem. There is no mysterious force that causes your book to disappear when you are no longer authorized to be in the room. Nor is there a mysterious force that prevents you from entering a room with a stolen key.</p>

<p>The hotel management is not <em>required</em> to remove your book. You didn't make a contract with them that said that if you leave stuff behind, they'll shred it for you. If you illegally re-enter your room with a stolen key to get it back, the hotel security staff is not <em>required</em> to catch you sneaking in. You didn't make a contract with them that said "if I try to sneak back into my room later, you are required to stop me." Rather, you signed a contract with them that said "I promise not to sneak back into my room later", a contract which <em>you broke</em>.</p>

<p>In this situation <strong>anything can happen</strong>. The book can be there -- you got lucky. Someone else's book can be there and yours could be in the hotel's furnace. Someone could be there right when you come in, tearing your book to pieces. The hotel could have removed the table and book entirely and replaced it with a wardrobe. The entire hotel could be just about to be torn down and replaced with a football stadium, and you are going to die in an explosion while you are sneaking around. </p>

<p>You don't know what is going to happen; when you checked out of the hotel and stole a key to illegally use later, you gave up the right to live in a predictable, safe world because <em>you</em> chose to break the rules of the system.</p>

<p><strong>C++ is not a safe language</strong>. It will cheerfully allow you to break the rules of the system. If you try to do something illegal and foolish like going back into a room you're not authorized to be in and rummaging through a desk that might not even be there anymore, C++ is not going to stop you. Safer languages than C++ solve this problem by restricting your power -- by having much stricter control over keys, for example.</p>

<h2>UPDATE</h2>

<p>Holy goodness, this answer is getting a lot of attention. (I'm not sure why -- I considered it to be just a "fun" little analogy, but whatever.)</p>

<p>I thought it might be germane to update this a bit with a few more technical thoughts.</p>

<p>Compilers are in the business of generating code which manages the storage of the data manipulated by that program. There are lots of different ways of generating code to manage memory, but over time two basic techniques have become entrenched. </p>

<p>The first is to have some sort of "long lived" storage area where the "lifetime" of each byte in the storage -- that is, the period of time when it is validly associated with some program variable -- cannot be easily predicted ahead of time. The compiler generates calls into a "heap manager" that knows how to dynamically allocate storage when it is needed and reclaim it when it is no longer needed.</p>

<p>The second method is to have a short-lived storage area where the lifetime of each byte is well known. Here, the lifetimes follow a nesting pattern. The longest-lived of these short-lived variables will be allocated before any other short-lived variables, and will be freed last. Shorter-lived variables will be allocated after the longest-lived ones, and will be freed before them. The lifetime of these shorter-lived variables is nested within the lifetime of longer-lived ones.</p>

<p>Local variables follow the latter pattern; when a method is entered, its local variables come alive. When that method calls another method, the new method's local variables come alive. They'll be dead before the first method's local variables are dead.  The relative order of the beginnings and endings of lifetimes of storages associated with local variables can be worked out ahead of time.</p>

<p>For this reason, local variables are usually generated as storage on a "stack" data structure, because a stack has the property that the first thing pushed on it is going to be the last thing popped off. </p>

<p>It's like the hotel decides to only rent out rooms sequentially, and you can't check out until everyone with a room number higher than you has checked out. </p>

<p>So let's think about the stack. In many operating systems you get one stack per thread and the stack is allocated to be a certain fixed size. When you call a method, stuff is pushed onto the stack. If you then pass a pointer to the stack back out of your method, as the original poster does here, that's just a pointer to the middle of some entirely valid million-byte memory block. In our analogy, you check out of the hotel; when you do, you just checked out of the highest-numbered occupied room.  If no one else checks in after you, and you go back to your room illegally, all your stuff is guaranteed to still be there <em>in this particular hotel</em>.</p>

<p>We use stacks for temporary stores because they are really cheap and easy. An implementation of C++ is not required to use a stack for storage of locals; it could use the heap. It doesn't, because that would make the program slower. </p>

<p>An implementation of C++ is not required to leave the garbage you left on the stack untouched so that you can come back for it later illegally; it is perfectly legal for the compiler to generate code that turns back to zero everything in the "room" that you just vacated. It doesn't because again, that would be expensive.</p>

<p>An implementation of C++ is not required to ensure that when the stack logically shrinks, the addresses that used to be valid are still mapped into memory. The implementation is allowed to tell the operating system "we're done using this page of stack now. Until I say otherwise, issue an exception that destroys the process if anyone touches the previously-valid stack page".  Again, implementations do not actually do that because it is slow and unnecessary.</p>

<p>Instead, implementations let you make mistakes and get away with it. Most of the time. Until one day something truly awful goes wrong and the process explodes.</p>

<p>This is problematic. There are a lot of rules and it is very easy to break them accidentally. I certainly have many times. And worse, the problem often only surfaces when memory is detected to be corrupt billions of nanoseconds after the corruption happened, when it is very hard to figure out who messed it up.</p>

<p>More memory-safe languages solve this problem by restricting your power. In "normal" C# there simply is no way to take the address of a local and return it or store it for later. You can take the address of a local, but the language is cleverly designed so that it is impossible to use it after the lifetime of the local ends. In order to take the address of a local and pass it back, you have to put the compiler in a special "unsafe" mode, <em>and</em> put the word "unsafe" in your program, to call attention to the fact that you are probably doing something dangerous that could be breaking the rules. </p>

<p>For further reading:</p>

<ul>
<li><p>What if C# did allow returning references? Coincidentally that is the subject of today's blog post:</p>

<p><a href="https://ericlippert.com/2011/06/23/ref-returns-and-ref-locals/" rel="noreferrer">https://ericlippert.com/2011/06/23/ref-returns-and-ref-locals/</a></p></li>
<li><p>Why do we use stacks to manage memory? Are value types in C# always stored on the stack? How does virtual memory work? And many more topics in how the C# memory manager works. Many of these articles are also germane to C++ programmers:</p>

<p><a href="https://ericlippert.com/tag/memory-management/" rel="noreferrer">https://ericlippert.com/tag/memory-management/</a></p></li>
</ul>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>What you're doing here is simply reading and writing to memory that <i>used to</i> be the address of <code>a</code>. Now that you're outside of <code>foo</code>, it's just a pointer to some random memory area. It just so happens that in your example, that memory area does exist and nothing else is using it at the moment. You don't break anything by continuing to use it, and nothing else has overwritten it yet. Therefore, the <code>5</code> is still there. In a real program, that memory would be re-used almost immediately and you'd break something by doing this (though the symptoms may not appear until much later!)</p>

<p>When you return from <code>foo</code>, you tell the OS that you're no longer using that memory and it can be reassigned to something else. If you're lucky and it never does get reassigned, and the OS doesn't catch you using it again, then you'll get away with the lie. Chances are though you'll end up writing over whatever else ends up with that address.</p>

<p>Now if you're wondering why the compiler doesn't complain, it's probably because <code>foo</code> got eliminated by optimization. It usually will warn you about this sort of thing. C assumes you know what you're doing though, and technically you haven't violated scope here (there's no reference to <code>a</code> itself outside of <code>foo</code>), only memory access rules, which only triggers a warning rather than an error.</p>

<p>In short: this won't usually work, but sometimes will by chance.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Because the storage space wasn't stomped on just yet. Don't count on that behavior.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A little addition to all the answers:</p>

<p>if you do something like that:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> * <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>{
    <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">return</span> &amp;a;
}
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">boo</span><span class="hljs-params">()</span></span>{
    <span class="hljs-type">int</span> a = <span class="hljs-number">7</span>;

}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-type">int</span> * p = <span class="hljs-built_in">foo</span>();
    <span class="hljs-built_in">boo</span>();
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,*p);
}
</code></pre>

<p>the output probably will be: 7</p>

<p>That is because after returning from foo() the stack is freed and then reused by boo().
If you deassemble the executable you will see it clearly.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In C++, you <em>can</em> access any address, but it doesn't mean you <em>should</em>. The address you are accessing is no longer valid. It <em>works</em> because nothing else scrambled the memory after foo returned, but it could crash under many circumstances. Try analyzing your program with <a href="http://en.wikipedia.org/wiki/Valgrind" rel="noreferrer">Valgrind</a>, or even just compiling it optimized, and see...</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You never throw a C++ exception by accessing invalid memory. You are just giving an example of the general idea of referencing an arbitrary memory location. I could do the same like this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> q = <span class="hljs-number">123456</span>;

*(<span class="hljs-type">double</span>*)(q) = <span class="hljs-number">1.2</span>;
</code></pre>

<p>Here I am simply treating 123456 as the address of a double and write to it. Any number of things could happen: </p>

<ol>
<li><code>q</code> might in fact genuinely be a valid address of a double, e.g. <code>double p; q = &amp;p;</code>. </li>
<li><code>q</code> might point somewhere inside allocated memory and I just overwrite 8 bytes in there. </li>
<li><code>q</code> points outside allocated memory and the operating system's memory manager sends a segmentation fault signal to my program, causing the runtime to terminate it. </li>
<li>You win the lottery.</li>
</ol>

<p>The way you set it up it is a bit more reasonable that the returned address points into a valid area of memory, as it will probably just be a little further down the stack, but it is still an invalid location that you cannot access in a deterministic fashion.</p>

<p>Nobody will automatically check the semantic validity of memory addresses like that for you during normal program execution. However, a memory debugger such as <code>valgrind</code> will happily do this, so you should run your program through it and witness the errors.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Did you compile your program with the optimiser enabled? The <code>foo()</code> function is quite simple and might have been inlined or replaced in the resulting code.</p>

<p>But I agree with Mark B that the resulting behavior is undefined.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Your problem has nothing to do with <em>scope</em>. In the code you show, the function <code>main</code> does not see the names in the function <code>foo</code>, so you can't access <code>a</code> in foo directly with <em>this</em> name outside <code>foo</code>.</p>

<p>The problem you are having is why the program doesn't signal an error when referencing illegal memory. This is because C++ standards does not specify a very clear boundary between illegal memory and legal memory. Referencing something in popped out stack sometimes causes error and sometimes not. It depends. Don't count on this behavior. Assume it will always result in error when you program, but assume it will never signal error when you debug.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Pay attention to  all warnings . Do not only solve errors.<br>
GCC shows this Warning </p>

<blockquote>
  <p>warning: address of local variable 'a' returned </p>
</blockquote>

<p>This is  power of C++. You should care about memory. With the <code>-Werror</code> flag, this warning becames an error and now you have to debug it.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It works because the stack has not been altered (yet) since a was put there. 
Call a few other functions (which are also calling other functions) before accessing <code>a</code> again and you will probably not be so lucky anymore... ;-)</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You are just returning a memory address, it's allowed but probably an error.  </p>

<p>Yes if you try to dereference that memory address you will have undefined behavior.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> * <span class="hljs-title">ref</span> <span class="hljs-params">()</span> </span>{

 <span class="hljs-type">int</span> tmp = <span class="hljs-number">100</span>;
 <span class="hljs-keyword">return</span> &amp;tmp;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>{

 <span class="hljs-type">int</span> * a = <span class="hljs-built_in">ref</span>();
 <span class="hljs-comment">//Up until this point there is defined results</span>
 <span class="hljs-comment">//You can even print the address returned</span>
 <span class="hljs-comment">// but yes probably a bug</span>

 cout &lt;&lt; *a &lt;&lt; endl;<span class="hljs-comment">//Undefined results</span>
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This behavior is undefined, as Alex pointed out--in fact, most compilers will warn against doing this, because it's an easy way to get crashes.</p>

<p>For an example of the kind of spooky behavior you are <em>likely</em> to get, try this sample:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> *<span class="hljs-title">a</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;
   <span class="hljs-keyword">return</span> &amp;x;
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">b</span><span class="hljs-params">( <span class="hljs-type">int</span> *c )</span>
</span>{
   <span class="hljs-type">int</span> y = <span class="hljs-number">29</span>;
   *c = <span class="hljs-number">123</span>;
   cout &lt;&lt; <span class="hljs-string">"y="</span> &lt;&lt; y &lt;&lt; endl;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-built_in">b</span>( <span class="hljs-built_in">a</span>() );
   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>This prints out "y=123", but your results may vary (really!). Your pointer is clobbering other, unrelated local variables.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>That's classic <strong>undefined behaviour</strong> that's been discussed here not two days ago -- search around the site for a bit. In a nutshell, you were lucky, but anything could have happened and your code is making invalid access to memory.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You actually invoked undefined behaviour.</p>

<p>Returning the address of a temporary works, but as temporaries are destroyed at the end of a function the results of accessing them will be undefined.</p>

<p>So you did not modify <code>a</code> but rather the memory location where <code>a</code> once was. This difference is very similar to the difference between crashing and not crashing. </p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In typical compiler implementations, you can think of the code as "print out the value of the memory block with adress that <em>used to be</em> occupied by a". Also, if you add a new function invocation to a function that constains a local <code>int</code> it's a good chance that the value of <code>a</code> (or the memory address that <code>a</code> used to point to) changes. This happens because the stack will be overwritten with a new frame containing different data.</p>

<p>However, this is <em>undefined</em> behaviour and you should not rely on it to work!</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It can, because <code>a</code> is a variable allocated temporarily for the lifetime of its scope (<code>foo</code> function). After you return from <code>foo</code> the memory is free and can be overwritten.</p>

<p>What you're doing is described as <em>undefined behavior</em>. The result cannot be predicted.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The things with correct (?) console output can change dramatically if you use ::printf but not cout. 
You can play around with debugger within below code (tested on x86, 32-bit, MSVisual Studio):</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">foo</span><span class="hljs-params">()</span> 
</span>{
  <span class="hljs-type">char</span> buf[<span class="hljs-number">10</span>];
  ::<span class="hljs-built_in">strcpy</span>(buf, <span class="hljs-string">"TEST);
  return buf;
}

int main() 
{
  char* s = foo();    //place breakpoint &amp; check 's' varialbe here
  ::printf("</span>%s\n<span class="hljs-string">", s); 
}
</span></code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 18</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It's 'Dirty' way of using memory addresses. When you return an address (pointer) you don't know whether it belongs to local scope of a function. It's just an address. Now that you invoked the 'foo' function, that address (memory location) of 'a' was already allocated there in the (safely, for now at least) addressable memory of your application (process). After the 'foo' function returned, the address of 'a' can be considered 'dirty' but it's there, not cleaned up, nor disturbed/modified by expressions in other part of program (in this specific case at least). A C/C++ compiler doesn't stop you from such 'dirty' access (might warn you though, if you care). You can safely use (update) any memory location that is in the data segment of your program instance (process) unless you protect the address by some means.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 19</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>After returning from a function, all identifiers are destroyed instead of kept values in a memory location and we can not locate the values without having an identifier.But that location still contains the value stored by previous function.</p>

<p>So, here function <code>foo()</code> is returning the address of <code>a</code> and <code>a</code> is destroyed after returning its address. And you can access the modified value through that returned address.</p>

<p><strong><em>Let me take a real world example:</em></strong></p>

<p>Suppose a man hides money at a location and tells you the location. After some time, the man who had told you the money location dies. But still you have the access of that hidden money.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 20</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Your code is very risky. You are creating a local variable (wich is considered destroyed after function ends) and you return the address of memory of that variable after it is destoyed.</p>

<p>That means the memory address could be valid or not, and your code will be vulnerable to possible memory address issues (for example segmentation fault).</p>

<p>This means that you are doing a very bad thing, becouse you are passing a memory address to a pointer wich is not trustable at all. </p>

<p>Consider this example, instead, and test it:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> * <span class="hljs-title">foo</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-type">int</span> *x = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;
   *x = <span class="hljs-number">5</span>;
   <span class="hljs-keyword">return</span> x;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">int</span>* p = <span class="hljs-built_in">foo</span>();
    std::cout &lt;&lt; *p &lt;&lt; <span class="hljs-string">"\n"</span>; <span class="hljs-comment">//better to put a new-line in the output, IMO</span>
    *p = <span class="hljs-number">8</span>;
    std::cout &lt;&lt; *p;
    <span class="hljs-keyword">delete</span> p;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>Unlike your example, with this example you are:</p>

<ul>
<li>allocating memory for int into a local function</li>
<li>that memory address is still valid also when function expires, (it is not deleted by anyone)</li>
<li>the memory address is trustable (that memory block is not considered free, so it will be not overridden until it is deleted)</li>
<li>the memory address should be deleted when not used. (see the delete at the end of the program)</li>
</ul>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;How can it be? Isn\u0026apos;t the memory of a local variable inaccessible outside its function?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;You rent a hotel room. You put a book in the top drawer of the bedside table and go to sleep.  You check out the next morning, but \u0026quot;forget\u0026quot; to give back your key. You steal the key!\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A week later, you return to the hotel, do not check in, sneak into your old room with your stolen key, and look in the drawer. Your book is still there. Astonishing!\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;How can that be? Aren\u0026apos;t the contents of a hotel room drawer inaccessible if you haven\u0026apos;t rented the room?\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Well, obviously that scenario can happen in the real world no problem. There is no mysterious force that causes your book to disappear when you are no longer authorized to be in the room. Nor is there a mysterious force that prevents you from entering a room with a stolen key.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The hotel management is not \u0026lt;em\u0026gt;required\u0026lt;/em\u0026gt; to remove your book. You didn\u0026apos;t make a contract with them that said that if you leave stuff behind, they\u0026apos;ll shred it for you. If you illegally re-enter your room with a stolen key to get it back, the hotel security staff is not \u0026lt;em\u0026gt;required\u0026lt;/em\u0026gt; to catch you sneaking in. You didn\u0026apos;t make a contract with them that said \u0026quot;if I try to sneak back into my room later, you are required to stop me.\u0026quot; Rather, you signed a contract with them that said \u0026quot;I promise not to sneak back into my room later\u0026quot;, a contract which \u0026lt;em\u0026gt;you broke\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In this situation \u0026lt;strong\u0026gt;anything can happen\u0026lt;/strong\u0026gt;. The book can be there -- you got lucky. Someone else\u0026apos;s book can be there and yours could be in the hotel\u0026apos;s furnace. Someone could be there right when you come in, tearing your book to pieces. The hotel could have removed the table and book entirely and replaced it with a wardrobe. The entire hotel could be just about to be torn down and replaced with a football stadium, and you are going to die in an explosion while you are sneaking around. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You don\u0026apos;t know what is going to happen; when you checked out of the hotel and stole a key to illegally use later, you gave up the right to live in a predictable, safe world because \u0026lt;em\u0026gt;you\u0026lt;/em\u0026gt; chose to break the rules of the system.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;C++ is not a safe language\u0026lt;/strong\u0026gt;. It will cheerfully allow you to break the rules of the system. If you try to do something illegal and foolish like going back into a room you\u0026apos;re not authorized to be in and rummaging through a desk that might not even be there anymore, C++ is not going to stop you. Safer languages than C++ solve this problem by restricting your power -- by having much stricter control over keys, for example.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;UPDATE\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Holy goodness, this answer is getting a lot of attention. (I\u0026apos;m not sure why -- I considered it to be just a \u0026quot;fun\u0026quot; little analogy, but whatever.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I thought it might be germane to update this a bit with a few more technical thoughts.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Compilers are in the business of generating code which manages the storage of the data manipulated by that program. There are lots of different ways of generating code to manage memory, but over time two basic techniques have become entrenched. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The first is to have some sort of \u0026quot;long lived\u0026quot; storage area where the \u0026quot;lifetime\u0026quot; of each byte in the storage -- that is, the period of time when it is validly associated with some program variable -- cannot be easily predicted ahead of time. The compiler generates calls into a \u0026quot;heap manager\u0026quot; that knows how to dynamically allocate storage when it is needed and reclaim it when it is no longer needed.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The second method is to have a short-lived storage area where the lifetime of each byte is well known. Here, the lifetimes follow a nesting pattern. The longest-lived of these short-lived variables will be allocated before any other short-lived variables, and will be freed last. Shorter-lived variables will be allocated after the longest-lived ones, and will be freed before them. The lifetime of these shorter-lived variables is nested within the lifetime of longer-lived ones.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Local variables follow the latter pattern; when a method is entered, its local variables come alive. When that method calls another method, the new method\u0026apos;s local variables come alive. They\u0026apos;ll be dead before the first method\u0026apos;s local variables are dead.  The relative order of the beginnings and endings of lifetimes of storages associated with local variables can be worked out ahead of time.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For this reason, local variables are usually generated as storage on a \u0026quot;stack\u0026quot; data structure, because a stack has the property that the first thing pushed on it is going to be the last thing popped off. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It\u0026apos;s like the hotel decides to only rent out rooms sequentially, and you can\u0026apos;t check out until everyone with a room number higher than you has checked out. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So let\u0026apos;s think about the stack. In many operating systems you get one stack per thread and the stack is allocated to be a certain fixed size. When you call a method, stuff is pushed onto the stack. If you then pass a pointer to the stack back out of your method, as the original poster does here, that\u0026apos;s just a pointer to the middle of some entirely valid million-byte memory block. In our analogy, you check out of the hotel; when you do, you just checked out of the highest-numbered occupied room.  If no one else checks in after you, and you go back to your room illegally, all your stuff is guaranteed to still be there \u0026lt;em\u0026gt;in this particular hotel\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;We use stacks for temporary stores because they are really cheap and easy. An implementation of C++ is not required to use a stack for storage of locals; it could use the heap. It doesn\u0026apos;t, because that would make the program slower. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;An implementation of C++ is not required to leave the garbage you left on the stack untouched so that you can come back for it later illegally; it is perfectly legal for the compiler to generate code that turns back to zero everything in the \u0026quot;room\u0026quot; that you just vacated. It doesn\u0026apos;t because again, that would be expensive.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;An implementation of C++ is not required to ensure that when the stack logically shrinks, the addresses that used to be valid are still mapped into memory. The implementation is allowed to tell the operating system \u0026quot;we\u0026apos;re done using this page of stack now. Until I say otherwise, issue an exception that destroys the process if anyone touches the previously-valid stack page\u0026quot;.  Again, implementations do not actually do that because it is slow and unnecessary.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Instead, implementations let you make mistakes and get away with it. Most of the time. Until one day something truly awful goes wrong and the process explodes.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is problematic. There are a lot of rules and it is very easy to break them accidentally. I certainly have many times. And worse, the problem often only surfaces when memory is detected to be corrupt billions of nanoseconds after the corruption happened, when it is very hard to figure out who messed it up.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;More memory-safe languages solve this problem by restricting your power. In \u0026quot;normal\u0026quot; C# there simply is no way to take the address of a local and return it or store it for later. You can take the address of a local, but the language is cleverly designed so that it is impossible to use it after the lifetime of the local ends. In order to take the address of a local and pass it back, you have to put the compiler in a special \u0026quot;unsafe\u0026quot; mode, \u0026lt;em\u0026gt;and\u0026lt;/em\u0026gt; put the word \u0026quot;unsafe\u0026quot; in your program, to call attention to the fact that you are probably doing something dangerous that could be breaking the rules. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For further reading:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;What if C# did allow returning references? Coincidentally that is the subject of today\u0026apos;s blog post:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://ericlippert.com/2011/06/23/ref-returns-and-ref-locals/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://ericlippert.com/2011/06/23/ref-returns-and-ref-locals/\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Why do we use stacks to manage memory? Are value types in C# always stored on the stack? How does virtual memory work? And many more topics in how the C# memory manager works. Many of these articles are also germane to C++ programmers:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://ericlippert.com/tag/memory-management/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://ericlippert.com/tag/memory-management/\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;What you\u0026apos;re doing here is simply reading and writing to memory that \u0026lt;i\u0026gt;used to\u0026lt;/i\u0026gt; be the address of \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;. Now that you\u0026apos;re outside of \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt;, it\u0026apos;s just a pointer to some random memory area. It just so happens that in your example, that memory area does exist and nothing else is using it at the moment. You don\u0026apos;t break anything by continuing to use it, and nothing else has overwritten it yet. Therefore, the \u0026lt;code\u0026gt;5\u0026lt;/code\u0026gt; is still there. In a real program, that memory would be re-used almost immediately and you\u0026apos;d break something by doing this (though the symptoms may not appear until much later!)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When you return from \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt;, you tell the OS that you\u0026apos;re no longer using that memory and it can be reassigned to something else. If you\u0026apos;re lucky and it never does get reassigned, and the OS doesn\u0026apos;t catch you using it again, then you\u0026apos;ll get away with the lie. Chances are though you\u0026apos;ll end up writing over whatever else ends up with that address.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now if you\u0026apos;re wondering why the compiler doesn\u0026apos;t complain, it\u0026apos;s probably because \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; got eliminated by optimization. It usually will warn you about this sort of thing. C assumes you know what you\u0026apos;re doing though, and technically you haven\u0026apos;t violated scope here (there\u0026apos;s no reference to \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; itself outside of \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt;), only memory access rules, which only triggers a warning rather than an error.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In short: this won\u0026apos;t usually work, but sometimes will by chance.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Because the storage space wasn\u0026apos;t stomped on just yet. Don\u0026apos;t count on that behavior.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A little addition to all the answers:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;if you do something like that:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdlib.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; * \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026amp;amp;a;\n}\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;boo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;;\n\n}\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; * p = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;boo\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;,*p);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;the output probably will be: 7\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;That is because after returning from foo() the stack is freed and then reused by boo().\nIf you deassemble the executable you will see it clearly.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In C++, you \u0026lt;em\u0026gt;can\u0026lt;/em\u0026gt; access any address, but it doesn\u0026apos;t mean you \u0026lt;em\u0026gt;should\u0026lt;/em\u0026gt;. The address you are accessing is no longer valid. It \u0026lt;em\u0026gt;works\u0026lt;/em\u0026gt; because nothing else scrambled the memory after foo returned, but it could crash under many circumstances. Try analyzing your program with \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Valgrind\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Valgrind\u0026lt;/a\u0026gt;, or even just compiling it optimized, and see...\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You never throw a C++ exception by accessing invalid memory. You are just giving an example of the general idea of referencing an arbitrary memory location. I could do the same like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; q = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;123456\u0026lt;/span\u0026gt;;\n\n*(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;*)(q) = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1.2\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here I am simply treating 123456 as the address of a double and write to it. Any number of things could happen: \u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;q\u0026lt;/code\u0026gt; might in fact genuinely be a valid address of a double, e.g. \u0026lt;code\u0026gt;double p; q = \u0026amp;amp;p;\u0026lt;/code\u0026gt;. \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;q\u0026lt;/code\u0026gt; might point somewhere inside allocated memory and I just overwrite 8 bytes in there. \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;q\u0026lt;/code\u0026gt; points outside allocated memory and the operating system\u0026apos;s memory manager sends a segmentation fault signal to my program, causing the runtime to terminate it. \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;You win the lottery.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;The way you set it up it is a bit more reasonable that the returned address points into a valid area of memory, as it will probably just be a little further down the stack, but it is still an invalid location that you cannot access in a deterministic fashion.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Nobody will automatically check the semantic validity of memory addresses like that for you during normal program execution. However, a memory debugger such as \u0026lt;code\u0026gt;valgrind\u0026lt;/code\u0026gt; will happily do this, so you should run your program through it and witness the errors.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Did you compile your program with the optimiser enabled? The \u0026lt;code\u0026gt;foo()\u0026lt;/code\u0026gt; function is quite simple and might have been inlined or replaced in the resulting code.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But I agree with Mark B that the resulting behavior is undefined.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Your problem has nothing to do with \u0026lt;em\u0026gt;scope\u0026lt;/em\u0026gt;. In the code you show, the function \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; does not see the names in the function \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt;, so you can\u0026apos;t access \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; in foo directly with \u0026lt;em\u0026gt;this\u0026lt;/em\u0026gt; name outside \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The problem you are having is why the program doesn\u0026apos;t signal an error when referencing illegal memory. This is because C++ standards does not specify a very clear boundary between illegal memory and legal memory. Referencing something in popped out stack sometimes causes error and sometimes not. It depends. Don\u0026apos;t count on this behavior. Assume it will always result in error when you program, but assume it will never signal error when you debug.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Pay attention to  all warnings . Do not only solve errors.\u0026lt;br\u0026gt;\nGCC shows this Warning \u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;warning: address of local variable \u0026apos;a\u0026apos; returned \u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;This is  power of C++. You should care about memory. With the \u0026lt;code\u0026gt;-Werror\u0026lt;/code\u0026gt; flag, this warning becames an error and now you have to debug it.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It works because the stack has not been altered (yet) since a was put there. \nCall a few other functions (which are also calling other functions) before accessing \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; again and you will probably not be so lucky anymore... ;-)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You are just returning a memory address, it\u0026apos;s allowed but probably an error.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Yes if you try to dereference that memory address you will have undefined behavior.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; * \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ref\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n\n \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; tmp = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;;\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026amp;amp;tmp;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n\n \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; * a = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ref\u0026lt;/span\u0026gt;();\n \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Up until this point there is defined results\u0026lt;/span\u0026gt;\n \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//You can even print the address returned\u0026lt;/span\u0026gt;\n \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// but yes probably a bug\u0026lt;/span\u0026gt;\n\n cout \u0026amp;lt;\u0026amp;lt; *a \u0026amp;lt;\u0026amp;lt; endl;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Undefined results\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This behavior is undefined, as Alex pointed out--in fact, most compilers will warn against doing this, because it\u0026apos;s an easy way to get crashes.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For an example of the kind of spooky behavior you are \u0026lt;em\u0026gt;likely\u0026lt;/em\u0026gt; to get, try this sample:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026amp;amp;x;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *c )\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; y = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;29\u0026lt;/span\u0026gt;;\n   *c = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;123\u0026lt;/span\u0026gt;;\n   cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;y=\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; y \u0026amp;lt;\u0026amp;lt; endl;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;() );\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This prints out \u0026quot;y=123\u0026quot;, but your results may vary (really!). Your pointer is clobbering other, unrelated local variables.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;That\u0026apos;s classic \u0026lt;strong\u0026gt;undefined behaviour\u0026lt;/strong\u0026gt; that\u0026apos;s been discussed here not two days ago -- search around the site for a bit. In a nutshell, you were lucky, but anything could have happened and your code is making invalid access to memory.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You actually invoked undefined behaviour.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Returning the address of a temporary works, but as temporaries are destroyed at the end of a function the results of accessing them will be undefined.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So you did not modify \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; but rather the memory location where \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; once was. This difference is very similar to the difference between crashing and not crashing. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In typical compiler implementations, you can think of the code as \u0026quot;print out the value of the memory block with adress that \u0026lt;em\u0026gt;used to be\u0026lt;/em\u0026gt; occupied by a\u0026quot;. Also, if you add a new function invocation to a function that constains a local \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; it\u0026apos;s a good chance that the value of \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; (or the memory address that \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; used to point to) changes. This happens because the stack will be overwritten with a new frame containing different data.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However, this is \u0026lt;em\u0026gt;undefined\u0026lt;/em\u0026gt; behaviour and you should not rely on it to work!\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It can, because \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is a variable allocated temporarily for the lifetime of its scope (\u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; function). After you return from \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; the memory is free and can be overwritten.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;What you\u0026apos;re doing is described as \u0026lt;em\u0026gt;undefined behavior\u0026lt;/em\u0026gt;. The result cannot be predicted.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The things with correct (?) console output can change dramatically if you use ::printf but not cout. \nYou can play around with debugger within below code (tested on x86, 32-bit, MSVisual Studio):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \n\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; buf[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;];\n  ::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strcpy\u0026lt;/span\u0026gt;(buf, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;TEST);\n  return buf;\n}\n\nint main() \n{\n  char* s = foo();    //place breakpoint \u0026amp;amp; check \u0026apos;s\u0026apos; varialbe here\n  ::printf(\u0026quot;\u0026lt;/span\u0026gt;%s\\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;, s); \n}\n\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It\u0026apos;s \u0026apos;Dirty\u0026apos; way of using memory addresses. When you return an address (pointer) you don\u0026apos;t know whether it belongs to local scope of a function. It\u0026apos;s just an address. Now that you invoked the \u0026apos;foo\u0026apos; function, that address (memory location) of \u0026apos;a\u0026apos; was already allocated there in the (safely, for now at least) addressable memory of your application (process). After the \u0026apos;foo\u0026apos; function returned, the address of \u0026apos;a\u0026apos; can be considered \u0026apos;dirty\u0026apos; but it\u0026apos;s there, not cleaned up, nor disturbed/modified by expressions in other part of program (in this specific case at least). A C/C++ compiler doesn\u0026apos;t stop you from such \u0026apos;dirty\u0026apos; access (might warn you though, if you care). You can safely use (update) any memory location that is in the data segment of your program instance (process) unless you protect the address by some means.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;After returning from a function, all identifiers are destroyed instead of kept values in a memory location and we can not locate the values without having an identifier.But that location still contains the value stored by previous function.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So, here function \u0026lt;code\u0026gt;foo()\u0026lt;/code\u0026gt; is returning the address of \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is destroyed after returning its address. And you can access the modified value through that returned address.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;Let me take a real world example:\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Suppose a man hides money at a location and tells you the location. After some time, the man who had told you the money location dies. But still you have the access of that hidden money.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Your code is very risky. You are creating a local variable (wich is considered destroyed after function ends) and you return the address of memory of that variable after it is destoyed.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;That means the memory address could be valid or not, and your code will be vulnerable to possible memory address issues (for example segmentation fault).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This means that you are doing a very bad thing, becouse you are passing a memory address to a pointer wich is not trustable at all. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Consider this example, instead, and test it:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; * \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *x = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;;\n   *x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; x;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;* p = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;();\n    std::cout \u0026amp;lt;\u0026amp;lt; *p \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//better to put a new-line in the output, IMO\u0026lt;/span\u0026gt;\n    *p = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;;\n    std::cout \u0026amp;lt;\u0026amp;lt; *p;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; p;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Unlike your example, with this example you are:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;allocating memory for int into a local function\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;that memory address is still valid also when function expires, (it is not deleted by anyone)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;the memory address is trustable (that memory block is not considered free, so it will be not overridden until it is deleted)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;the memory address should be deleted when not used. (see the delete at the end of the program)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    "],"comment":["\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;this won\u0026apos;t even compile as is; if you fix the nonforming business, gcc will still warn \u0026lt;code\u0026gt;address of local variable a returned\u0026lt;/code\u0026gt;; valgrind shows \u0026lt;code\u0026gt;Invalid write of size 4 [...] Address 0xbefd7114 is just below the stack ptr\u0026lt;/code\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/85371/sehe\u0026quot; title=\u0026quot;351,900 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;sehe\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment7561705_6441218\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-06-22 14:34:08Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 22, 2011 at 14:34\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Serge: Back in my youth I once worked on some kinda tricky zero-ring code that ran on the Netware operating system that involved cleverly moving around the stack pointer in a way not exactly sanctioned by the operating system. I\u0026apos;d know when I\u0026apos;d made a mistake because often the stack would end up overlapping the screen memory and I could just watch the bytes get written right onto the display. You can\u0026apos;t get away with that sort of thing these days.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/88656/eric-lippert\u0026quot; title=\u0026quot;632,289 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Eric Lippert\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment7573092_6441218\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-06-23 04:23:38Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 23, 2011 at 4:23\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;lol. I needed to read the question and some answers before I even understood where the problem is. Is that actually a question about variable\u0026apos;s access scope? You don\u0026apos;t even use \u0026apos;a\u0026apos; outside your function. And that is all there is to it. Throwing around some memory references is a totally different topic from variable scope.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/131120/erikbstack\u0026quot; title=\u0026quot;12,392 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;erikbstack\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment7574165_6441218\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-06-23 06:23:14Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 23, 2011 at 6:23\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Dupe answer doesn\u0026apos;t mean dupe question. A lot of the dupe questions that people proposed here are completely different questions that happen to refer to the same underlying symptom... but the questioner has know way of knowing that so they should remain open. I closed an older dupe and merged it into this question which should stay open because it has a very good answer.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/4/joel-spolsky\u0026quot; title=\u0026quot;32,984 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Joel Spolsky\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment7581906_6441218\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-06-23 14:36:33Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 23, 2011 at 14:36\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Joel: If the answer here is good, it should be \u0026lt;b\u0026gt;\u0026lt;i\u0026gt;merged into older questions\u0026lt;/i\u0026gt;\u0026lt;/b\u0026gt;, of which this is a dupe, not the other way around. And this \u0026lt;b\u0026gt;\u0026lt;i\u0026gt;question\u0026lt;/i\u0026gt;\u0026lt;/b\u0026gt; is indeed a dupe of the other questions proposed here and then some (even though some of the proposed are a better fit than others). Note that I think Eric\u0026apos;s answer is good. (In fact, I flagged this question for merging the answers into one of the older questions in order to salvage the older questions.)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/140719/sbi\u0026quot; title=\u0026quot;213,029 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;sbi\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment7582869_6441218\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-06-23 15:20:03Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 23, 2011 at 15:20\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@muntoo: Unfortunately it\u0026apos;s not like the operating system sounds a warning siren before it decommits or deallocates a page of virtual memory. If you\u0026apos;re mucking around with that memory when you don\u0026apos;t own it anymore the operating system is perfectly within its rights to take down the entire process when you touch a deallocated page.  Boom!\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/88656/eric-lippert\u0026quot; title=\u0026quot;632,289 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Eric Lippert\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment7572778_6445794\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-06-23 03:41:06Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 23, 2011 at 3:41\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Kyle: Only safe hotels do that. The unsafe hotels get measurable profit gains from not having to waste time on programming keys.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/83741/alexander-torstling\u0026quot; title=\u0026quot;18,036 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Alexander Torstling\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment7573695_6445794\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-06-23 05:35:49Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 23, 2011 at 5:35\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@cyberguijarro: That C++ is not memory safe is simply a fact. It\u0026apos;s not \u0026quot;bashing\u0026quot; anything. Had I said, for example, \u0026quot;C++ is a horrid mishmash of under-specified, overly-complex features piled on top of a brittle, dangerous memory model and I am thankful every day I no longer work in it for my own sanity\u0026quot;, that would be bashing C++. Pointing out that it\u0026apos;s not memory safe is \u0026lt;i\u0026gt;explaining\u0026lt;/i\u0026gt; why the original poster is seeing this issue; it\u0026apos;s answering the question, not editorializing.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/88656/eric-lippert\u0026quot; title=\u0026quot;632,289 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Eric Lippert\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment7575025_6445794\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-06-23 07:27:15Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 23, 2011 at 7:27\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Strictly speaking the analogy should mention that the receptionist at the hotel was quite happy for you to take the key with you. \u0026quot;Oh, do you mind if I take this key with me?\u0026quot; \u0026quot;Go ahead. Why would I care? I only work here\u0026quot;. It doesn\u0026apos;t become illegal until you try to use it.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/32136/philsquared\u0026quot; title=\u0026quot;22,210 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;philsquared\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment7579255_6445794\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-06-23 12:24:57Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 23, 2011 at 12:24\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Please, please at least consider writing a book one day. I would buy it even if it was just a collection of revised and expanded blog posts, and I\u0026apos;m sure so would a lot of people. But a book with your original thoughts on various programming-related matters would be a great read. I know that it\u0026apos;s incredible hard to find the time for it, but please consider writing one.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/501518/dyppl\u0026quot; title=\u0026quot;11,815 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Dyppl\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment7594306_6445794\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-06-24 06:43:24Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 24, 2011 at 6:43\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Man, that was the longest wait for a comment since, \u0026quot;What is truth? said jesting Pilate.\u0026quot; Maybe it was a Gideon\u0026apos;s Bible in that hotel drawer. And what happened to them, anyway? Notice they are no longer present, in London at least. I guess that under the Equalities legislation, you would need a library of religious tracts.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/81317/rob-kent\u0026quot; title=\u0026quot;5,173 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Rob Kent\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment50886916_2862501\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-07-16 16:47:28Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 16, 2015 at 16:47\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I could have sworn that I wrote that long ago, but it popped up recently and found my response wasn\u0026apos;t there. Now I have to go figure out your allusions above as I expect I\u0026apos;ll be amused when I do \u0026amp;gt;.\u0026amp;lt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/282912/msw\u0026quot; title=\u0026quot;41,669 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;msw\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment50901679_2862501\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-07-17 03:17:12Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 17, 2015 at 3:17\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Haha. Francis Bacon, one of Britain\u0026apos;s greatest essayists, whom some people suspect wrote Shakespeare\u0026apos;s plays, because they can\u0026apos;t accept that a grammar school kid from the country, son of a glover, could be a genius. Such is the English class system. Jesus said, \u0026apos;I am the Truth\u0026apos;. \u0026lt;a href=\u0026quot;http://oregonstate.edu/instruct/phl302/texts/bacon/bacon_essays.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;oregonstate.edu/instruct/phl302/texts/bacon/bacon_essays.html\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/81317/rob-kent\u0026quot; title=\u0026quot;5,173 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Rob Kent\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment50913679_2862501\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-07-17 11:00:50Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 17, 2015 at 11:00\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Simple, but great example to understand the underlying stack theory.Just one test addition, declaring \u0026quot;int a = 5;\u0026quot; in foo() as  \u0026quot;static int a = 5;\u0026quot; can be used to understand the scope and life time of a static variable.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/851806/proton\u0026quot; title=\u0026quot;648 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;proton\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment23556354_6478323\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-05-07 19:02:43Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 7, 2013 at 19:02\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;-1 \u0026quot;for will \u0026lt;b\u0026gt;probably be 7\u0026lt;/b\u0026gt;\u0026quot;. The compiler might enregister a in boo. It might remove it because it\u0026apos;s unnecessary. There is a good chance that *p will \u0026lt;b\u0026gt;not be 5\u0026lt;/b\u0026gt;, but that doesn\u0026apos;t mean that there is any particularly good reason why it will \u0026lt;b\u0026gt;probably be 7\u0026lt;/b\u0026gt;.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2134079/matt\u0026quot; title=\u0026quot;104 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Matt\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment28548185_6478323\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-10-09 19:16:40Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 9, 2013 at 19:16\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;It is called undefined behavior!\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1757805/francis-cugler\u0026quot; title=\u0026quot;7,614 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Francis Cugler\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment46787821_6478323\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-03-27 08:24:38Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 27, 2015 at 8:24\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;why and how \u0026lt;code\u0026gt;boo\u0026lt;/code\u0026gt; reuses the \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; stack ? aren\u0026apos;t function stacks separated from each other, also I get garbage running this code on Visual Studio 2015\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3450869/ampawd\u0026quot; title=\u0026quot;883 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;ampawd\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment65501054_6478323\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-08-22 10:07:57Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 22, 2016 at 10:07\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@ampawd it\u0026apos;s almost a year old, but no, \u0026quot;function stacks\u0026quot; are not separated from each other.  A CONTEXT has a stack.   That context uses its stack to enter main, then descends into \u0026lt;code\u0026gt;foo()\u0026lt;/code\u0026gt;, exists, then descends into \u0026lt;code\u0026gt;boo()\u0026lt;/code\u0026gt;.   \u0026lt;code\u0026gt;Foo()\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;Boo()\u0026lt;/code\u0026gt; both enter with the stack pointer at the same location.  This isn\u0026apos;t however, behavior that should be relied upon.  Other \u0026apos;stuff\u0026apos; (like interrupts, or the OS) can use the stack between the call of \u0026lt;code\u0026gt;boo()\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;foo()\u0026lt;/code\u0026gt;, modifying it\u0026apos;s contents...\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/550235/russ-schultz\u0026quot; title=\u0026quot;2,240 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Russ Schultz\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment77218773_6478323\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-07-16 01:07:54Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 16, 2017 at 1:07\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;You probably mean you can attempt to access any address. Because most of the operating systems today will not let any program access any address; there are tons of safeguards to protect the address space. This is why there will not be another LOADLIN.EXE out there.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2893496/v010dya\u0026quot; title=\u0026quot;4,896 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;v010dya\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment48489320_6441367\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-05-12 13:21:45Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 12, 2015 at 13:21\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I\u0026apos;m just going to write a program now that keeps on running this program so that \u0026lt;code\u0026gt;4) I win the lottery\u0026lt;/code\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/613176/aidiakapi\u0026quot; title=\u0026quot;5,858 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Aidiakapi\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment46204248_6441371\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-03-11 00:37:01Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 11, 2015 at 0:37\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;That\u0026apos;s my bet.   Optimizer dumped the function call.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/627042/erik-aronesty\u0026quot; title=\u0026quot;10,395 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Erik Aronesty\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment7565293_6441340\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-06-22 17:34:48Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 22, 2011 at 17:34\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;That is not necessary. Since no new function is called after foo(), the functions local stack frame is simply not yet overwritten. Add another function invocation after foo(), and the \u0026lt;code\u0026gt;5\u0026lt;/code\u0026gt; will be changed...\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/181894/tomas\u0026quot; title=\u0026quot;5,006 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Tomas\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment7577970_6441340\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-06-23 11:02:21Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 23, 2011 at 11:02\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I ran the program with GCC 4.8, replacing cout with printf (and including stdio). Rightfully warns \u0026quot;warning: address of local variable a returned [-Wreturn-local-addr]\u0026quot;. Outputs 58 with no optimization and 08 with -O3. Strangely P does have an address, even though its value is 0. I expected NULL (0) as address.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1170023/kevin\u0026quot; title=\u0026quot;2,551 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Kevin\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment74588159_6441340\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-05-04 03:55:26Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 4, 2017 at 3:55\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I recall from an old copy of \u0026lt;i\u0026gt;Turbo C Programming for the IBM\u0026lt;/i\u0026gt;, which I used to play around with some way back when, how directly manipulating the graphics memory, and the layout of the IBM\u0026apos;s text mode video memory, was described in great detail. Of course then, the system that the code ran on clearly defined what writing to those addresses meant, so as long as you didn\u0026apos;t worry about portability to other systems, everything was fine. IIRC, pointers to void were a common theme in that book.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/486504/user\u0026quot; title=\u0026quot;6,807 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;user\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment7575585_6449426\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-06-23 08:05:31Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 23, 2011 at 8:05\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Michael Kjörling: Sure! People like to do some dirty work once in a while ;)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/752150/chang-peng\u0026quot; title=\u0026quot;1,022 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Chang Peng\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment7576168_6449426\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-06-23 08:47:40Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 23, 2011 at 8:47\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;This is the most practical answer. Think of default compiler flags as \u0026apos;compatibility mode\u0026apos;. Don\u0026apos;t use this mode unless dealing with legacy code. Instead turn on warnings. (\u0026lt;code\u0026gt;-Werror -Wall -Wextra\u0026lt;/code\u0026gt; is a good start.) Further, add run-time checking with \u0026lt;code\u0026gt;-fsanitize=address,undefined\u0026lt;/code\u0026gt; if you\u0026apos;re not sure your program is correct, \u0026lt;a href=\u0026quot;https://godbolt.org/z/6jKGzhaox\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;like this\u0026lt;/a\u0026gt;.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/671509/john-mcfarlane\u0026quot; title=\u0026quot;4,963 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;John McFarlane\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment125376459_32044028\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2022-01-31 06:10:15Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 31 at 6:10\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I disagree: There is a problem before the \u0026lt;code\u0026gt;cout\u0026lt;/code\u0026gt;. \u0026lt;code\u0026gt;*a\u0026lt;/code\u0026gt; points to unallocated (freed) memory. Even if you don\u0026apos;t derefence it, it is still dangerous (and likely bogus).\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/279259/ereon\u0026quot; title=\u0026quot;51,158 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;ereOn\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment2908170_2862503\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-05-19 07:15:13Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 19, 2010 at 7:15\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@ereOn: I clarified more what I meant by problem, but no it is not dangerous in terms of valid c++ code.  But it is dangerous in terms of likely the user made a mistake and will do something bad.   Maybe for example you are trying to see how the stack grows, and you only care about the address value and will never dereference it.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3153/brian-r-bondy\u0026quot; title=\u0026quot;328,464 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Brian R. Bondy\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment2910285_2862503\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-05-19 13:02:37Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 19, 2010 at 13:02\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026quot;print out the value of the memory block with address that \u0026lt;i\u0026gt;used to be\u0026lt;/i\u0026gt; occupied by a\u0026quot; isn\u0026apos;t quite right. This makes it sound like his code has some well-defined meaning, which is not the case. You are right that this is probably how most compilers would implement it, though.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/242814/brennan-vincent\u0026quot; title=\u0026quot;10,204 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Brennan Vincent\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment7569308_6441417\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-06-22 21:23:46Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 22, 2011 at 21:23\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@BrennanVincent: While the storage was occupied by \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;, the pointer held the address of \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;.  Although the Standard does not require that implementations define the behavior of addresses after the lifetime of their target has ended, it also recognizes that on some platforms UB is processed in a documented manner characteristic of the environment.  While the address of a local variable won\u0026apos;t generally be of much use after it has gone out of scope, some other kinds of addresses may still be meaningful after the lifetime of their respective targets.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/363751/supercat\u0026quot; title=\u0026quot;73,697 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;supercat\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment89095317_6441417\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-06-26 22:21:44Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 26, 2018 at 22:21\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@BrennanVincent: For example, while the Standard may not require that implementations allow a pointer passed to \u0026lt;code\u0026gt;realloc\u0026lt;/code\u0026gt; to be compared against the return value, nor allow pointers to addresses within the old block to be adjusted to point to the new one, some implementations do so, and code which exploits such a feature may be more efficient than code which has to avoid any action--even comparisons--involving pointers to the allocation that was given to \u0026lt;code\u0026gt;realloc\u0026lt;/code\u0026gt;.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/363751/supercat\u0026quot; title=\u0026quot;73,697 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;supercat\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment89095480_6441417\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-06-26 22:30:53Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 26, 2018 at 22:30\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Did you add something not already covered by the existing answers? And please don\u0026apos;t use raw pointers/\u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt;.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/560648/lightness-races-in-orbit\u0026quot; title=\u0026quot;369,871 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Lightness Races in Orbit\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment98552869_55950265\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-05-02 10:20:24Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 2, 2019 at 10:20\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;The asker used raw pointers. I did an example wich reflected exactly the example he did in order to allow him to see the difference between untrusty pointer and trusty one. Actually there is another answer similar to mine, but it uses strcpy wich, IMHO, could be less clear to a novice coder than my example that uses new.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/5470892/nobun\u0026quot; title=\u0026quot;141 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Nobun\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment98553095_55950265\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-05-02 10:28:14Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 2, 2019 at 10:28\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;They didn\u0026apos;t use \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt;. You\u0026apos;re teaching them to use \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt;. But you shouldn\u0026apos;t use \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt;.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/560648/lightness-races-in-orbit\u0026quot; title=\u0026quot;369,871 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Lightness Races in Orbit\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment98553291_55950265\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-05-02 10:34:07Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 2, 2019 at 10:34\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;So in your opinion it is better to pass an address to a local variable wich is destroyed in a function than actually allocating memory? This makes no sense. Understanding the concept of allocating e deallocating memory is important, imho, mainly if you are asking about pointers (asker didn\u0026apos;t use new, but used pointers).\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/5470892/nobun\u0026quot; title=\u0026quot;141 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Nobun\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment98553340_55950265\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-05-02 10:36:24Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 2, 2019 at 10:36\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;When did I say that? No, it is better to use smart pointers to properly indicate ownership of the referenced resource. Don\u0026apos;t use \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; in 2019 (unless you\u0026apos;re writing library code) and don\u0026apos;t teach newcomers to do so either! Cheers.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/560648/lightness-races-in-orbit\u0026quot; title=\u0026quot;369,871 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Lightness Races in Orbit\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment98553605_55950265\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-05-02 10:45:14Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 2, 2019 at 10:45\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        "],"id":63,"title":"Can a local variable's memory be accessed outside its scope?","content":"\n                \n\u0026lt;p\u0026gt;I have the following code.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; * \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026amp;amp;a;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;* p = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;();\n    std::cout \u0026amp;lt;\u0026amp;lt; *p;\n    *p = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;;\n    std::cout \u0026amp;lt;\u0026amp;lt; *p;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And the code is just running with no runtime exceptions!\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The output was \u0026lt;code\u0026gt;58\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;How can it be? Isn\u0026apos;t the memory of a local variable inaccessible outside its function?\u0026lt;/p\u0026gt;\n    ","slug":"can-a-local-variable's-memory-be-accessed-outside-its-scope-1657384460386","postType":"QUESTION","createdAt":"2022-07-09T16:34:20.000Z","updatedAt":"2022-07-09T16:34:20.000Z","tags":[{"id":229,"name":"memory-management","slug":"memory-management","createdAt":"2022-07-09T16:34:20.000Z","updatedAt":"2022-07-09T16:34:20.000Z","Questions_Tags":{"questionId":63,"tagId":229}},{"id":230,"name":"local-variables","slug":"local-variables","createdAt":"2022-07-09T16:34:20.000Z","updatedAt":"2022-07-09T16:34:20.000Z","Questions_Tags":{"questionId":63,"tagId":230}},{"id":231,"name":"dangling-pointer","slug":"dangling-pointer","createdAt":"2022-07-09T16:34:20.000Z","updatedAt":"2022-07-09T16:34:20.000Z","Questions_Tags":{"questionId":63,"tagId":231}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"can-a-local-variable's-memory-be-accessed-outside-its-scope-1657384460386"},"buildId":"4Y8KGE-c2lolBeBmcum_I","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>