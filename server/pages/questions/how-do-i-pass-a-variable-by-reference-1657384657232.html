<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>How do I pass a variable by reference? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="Are parameters passed by reference or by value? How do I pass by reference so that the code below outputs &#x27;Changed&#x27; instead of &#x27;Original&#x27;?
class PassByReference:
    def __init__(self):
        self.variable = &#x27;Original&#x27;
        self.change(self.variable)
        print(self.variable)

    def change(self, var):
        var = &#x27;Changed&#x27;

    "/><meta property="og:title" content="How do I pass a variable by reference? | Solutions Checker"/><meta property="og:description" content="Are parameters passed by reference or by value? How do I pass by reference so that the code below outputs &#x27;Changed&#x27; instead of &#x27;Original&#x27;?
class PassByReference:
    def __init__(self):
        self.variable = &#x27;Original&#x27;
        self.change(self.variable)
        print(self.variable)

    def change(self, var):
        var = &#x27;Changed&#x27;

    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"How do I pass a variable by reference?","text":"Are parameters passed by reference or by value? How do I pass by reference so that the code below outputs &apos;Changed&apos; instead of &apos;Original&apos;?\nclass PassByReference:\n    def __init__(self):\n        self.variable = &apos;Original&apos;\n        self.change(self.variable)\n        print(self.variable)\n\n    def change(self, var):\n        var = &apos;Changed&apos;\n\n    ","answerCount":30,"upVoteCount":500,"suggestedAnswer":[{"text":"Arguments are passed by assignment. The rationale behind this is twofold:\n\n\nthe parameter passed in is actually a reference to an object (but the reference is passed by value)\nsome data types are mutable, but others aren&apos;t\n\n\nSo:\n\n\nIf you pass a mutable object into a method, the method gets a reference to that same object and you can mutate it to your heart&apos;s delight, but if you rebind the reference in the method, the outer scope will know nothing about it, and after you&apos;re done, the outer reference will still point at the original object. \nIf you pass an immutable object to a method, you still can&apos;t rebind the outer reference, and you can&apos;t even mutate the object.\n\n\nTo make it even more clear, let&apos;s have some examples. \n\nList - a mutable type\n\nLet&apos;s try to modify the list that was passed to a method:\n\ndef try_to_change_list_contents(the_list):\n    print(&apos;got&apos;, the_list)\n    the_list.append(&apos;four&apos;)\n    print(&apos;changed to&apos;, the_list)\n\nouter_list = [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]\n\nprint(&apos;before, outer_list =&apos;, outer_list)\ntry_to_change_list_contents(outer_list)\nprint(&apos;after, outer_list =&apos;, outer_list)\n\n\nOutput:\n\nbefore, outer_list = [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]\ngot [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]\nchanged to [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;, &apos;four&apos;]\nafter, outer_list = [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;, &apos;four&apos;]\n\n\nSince the parameter passed in is a reference to outer_list, not a copy of it, we can use the mutating list methods to change it and have the changes reflected in the outer scope.\n\nNow let&apos;s see what happens when we try to change the reference that was passed in as a parameter:\n\ndef try_to_change_list_reference(the_list):\n    print(&apos;got&apos;, the_list)\n    the_list = [&apos;and&apos;, &apos;we&apos;, &apos;can&apos;, &apos;not&apos;, &apos;lie&apos;]\n    print(&apos;set to&apos;, the_list)\n\nouter_list = [&apos;we&apos;, &apos;like&apos;, &apos;proper&apos;, &apos;English&apos;]\n\nprint(&apos;before, outer_list =&apos;, outer_list)\ntry_to_change_list_reference(outer_list)\nprint(&apos;after, outer_list =&apos;, outer_list)\n\n\nOutput:\n\nbefore, outer_list = [&apos;we&apos;, &apos;like&apos;, &apos;proper&apos;, &apos;English&apos;]\ngot [&apos;we&apos;, &apos;like&apos;, &apos;proper&apos;, &apos;English&apos;]\nset to [&apos;and&apos;, &apos;we&apos;, &apos;can&apos;, &apos;not&apos;, &apos;lie&apos;]\nafter, outer_list = [&apos;we&apos;, &apos;like&apos;, &apos;proper&apos;, &apos;English&apos;]\n\n\nSince the the_list parameter was passed by value, assigning a new list to it had no effect that the code outside the method could see. The the_list was a copy of the outer_list reference, and we had the_list point to a new list, but there was no way to change where outer_list pointed.\n\nString - an immutable type\n\nIt&apos;s immutable, so there&apos;s nothing we can do to change the contents of the string\n\nNow, let&apos;s try to change the reference\n\ndef try_to_change_string_reference(the_string):\n    print(&apos;got&apos;, the_string)\n    the_string = &apos;In a kingdom by the sea&apos;\n    print(&apos;set to&apos;, the_string)\n\nouter_string = &apos;It was many and many a year ago&apos;\n\nprint(&apos;before, outer_string =&apos;, outer_string)\ntry_to_change_string_reference(outer_string)\nprint(&apos;after, outer_string =&apos;, outer_string)\n\n\nOutput:\n\nbefore, outer_string = It was many and many a year ago\ngot It was many and many a year ago\nset to In a kingdom by the sea\nafter, outer_string = It was many and many a year ago\n\n\nAgain, since the the_string parameter was passed by value, assigning a new string to it had no effect that the code outside the method could see. The the_string was a copy of the outer_string reference, and we had the_string point to a new string, but there was no way to change where outer_string pointed.\n\nI hope this clears things up a little.\n\nEDIT: It&apos;s been noted that this doesn&apos;t answer the question that @David originally asked, &quot;Is there something I can do to pass the variable by actual reference?&quot;. Let&apos;s work on that.\n\nHow do we get around this?\n\nAs @Andrea&apos;s answer shows, you could return the new value. This doesn&apos;t change the way things are passed in, but does let you get the information you want back out:\n\ndef return_a_whole_new_string(the_string):\n    new_string = something_to_do_with_the_old_string(the_string)\n    return new_string\n\n# then you could call it like\nmy_string = return_a_whole_new_string(my_string)\n\n\nIf you really wanted to avoid using a return value, you could create a class to hold your value and pass it into the function or use an existing class, like a list:\n\ndef use_a_wrapper_to_simulate_pass_by_reference(stuff_to_change):\n    new_string = something_to_do_with_the_old_string(stuff_to_change[0])\n    stuff_to_change[0] = new_string\n\n# then you could call it like\nwrapper = [my_string]\nuse_a_wrapper_to_simulate_pass_by_reference(wrapper)\n\ndo_something_with(wrapper[0])\n\n\nAlthough this seems a little cumbersome.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"The problem comes from a misunderstanding of what variables are in Python. If you&apos;re used to most traditional languages, you have a mental model of what happens in the following sequence:\n\na = 1\na = 2\n\n\nYou believe that a is a memory location that stores the value 1, then is updated to store the value 2. That&apos;s not how things work in Python. Rather, a starts as a reference to an object with the value 1, then gets reassigned as a reference to an object with the value 2. Those two objects may continue to coexist even though a doesn&apos;t refer to the first one anymore; in fact they may be shared by any number of other references within the program.\n\nWhen you call a function with a parameter, a new reference is created that refers to the object passed in. This is separate from the reference that was used in the function call, so there&apos;s no way to update that reference and make it refer to a new object. In your example:\n\ndef __init__(self):\n    self.variable = &apos;Original&apos;\n    self.Change(self.variable)\n\ndef Change(self, var):\n    var = &apos;Changed&apos;\n\n\nself.variable is a reference to the string object &apos;Original&apos;. When you call Change you create a second reference var to the object. Inside the function you reassign the reference var to a different string object &apos;Changed&apos;, but the reference self.variable is separate and does not change.\n\nThe only way around this is to pass a mutable object. Because both references refer to the same object, any changes to the object are reflected in both places.\n\ndef __init__(self):         \n    self.variable = [&apos;Original&apos;]\n    self.Change(self.variable)\n\ndef Change(self, var):\n    var[0] = &apos;Changed&apos;\n\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"I found the other answers rather long and complicated, so I created this simple diagram to explain the way Python treats variables and parameters.\n\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"It is neither pass-by-value or pass-by-reference - it is call-by-object. See this, by Fredrik Lundh:\nhttp://effbot.org/zone/call-by-object.htm\nHere is a significant quote:\n\n&quot;...variables [names] are not objects; they cannot be denoted by other variables or referred to by objects.&quot;\n\nIn your example, when the Change method is called--a namespace is created for it; and var becomes a name, within that namespace, for the string object &apos;Original&apos;. That object then has a name in two namespaces. Next, var = &apos;Changed&apos; binds var to a new string object, and thus the method&apos;s namespace forgets about &apos;Original&apos;. Finally, that namespace is forgotten, and the string &apos;Changed&apos; along with it.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"Think of stuff being passed by assignment instead of by reference/by value. That way, it is always clear, what is happening as long as you understand what happens during the normal assignment.\n\nSo, when passing a list to a function/method, the list is assigned to the parameter name. Appending to the list will result in the list being modified. Reassigning the list inside the function will not change the original list, since:\n\na = [1, 2, 3]\nb = a\nb.append(4)\nb = [&apos;a&apos;, &apos;b&apos;]\nprint a, b      # prints [1, 2, 3, 4] [&apos;a&apos;, &apos;b&apos;]\n\n\nSince immutable types cannot be modified, they seem like being passed by value - passing an int into a function means assigning the int to the function&apos;s parameter. You can only ever reassign that, but it won&apos;t change the original variables value.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"There are no variables in Python\n\nThe key to understanding parameter passing is to stop thinking about &quot;variables&quot;. There are names and objects in Python and together they\nappear like variables, but it is useful to always distinguish the three.\n\n\nPython has names and objects.\nAssignment binds a name to an object.\nPassing an argument into a function also binds a name (the parameter name of the function) to an object.\n\n\nThat is all there is to it. Mutability is irrelevant to this question.\n\nExample:\n\na = 1\n\n\nThis binds the name a to an object of type integer that holds the value 1.\n\nb = x\n\n\nThis binds the name b to the same object that the name x is currently bound to.\nAfterward, the name b has nothing to do with the name x anymore.\n\nSee sections 3.1 and 4.2 in the Python 3 language reference.\n\nHow to read the example in the question\n\nIn the code shown in the question, the statement self.Change(self.variable) binds the name var (in the scope of function Change) to the object that holds the value &apos;Original&apos; and the assignment var = &apos;Changed&apos; (in the body of function Change) assigns that same name again: to some other object (that happens to hold a string as well but could have been something else entirely).\n\nHow to pass by reference\n\nSo if the thing you want to change is a mutable object, there is no problem, as everything is effectively passed by reference.\n\nIf it is an immutable object (e.g. a bool, number, string), the way to go is to wrap it in a mutable object.\nThe quick-and-dirty solution for this is a one-element list (instead of self.variable, pass [self.variable] and in the function modify var[0]).\nThe more pythonic approach would be to introduce a trivial, one-attribute class. The function receives an instance of the class and manipulates the attribute.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"Effbot (aka Fredrik Lundh) has described Python&apos;s variable passing style as call-by-object:  http://effbot.org/zone/call-by-object.htm\n\nObjects are allocated on the heap and pointers to them can be passed around anywhere.  \n\n\nWhen you make an assignment such as x = 1000, a dictionary entry is created that maps the string &quot;x&quot; in the current namespace to a pointer to the integer object containing one thousand.   \nWhen you update &quot;x&quot; with x = 2000, a new integer object is created and the dictionary is updated to point at the new object.  The old one thousand object is unchanged (and may or may not be alive depending on whether anything else refers to the object).\nWhen you do a new assignment such as y = x, a new dictionary entry &quot;y&quot; is created that points to the same object as the entry for &quot;x&quot;.\nObjects like strings and integers are immutable.  This simply means that there are no methods that can change the object after it has been created.  For example, once the integer object one-thousand is created, it will never change.  Math is done by creating new integer objects.\nObjects like lists are mutable.  This means that the contents of the object can be changed by anything pointing to the object.  For example, x = []; y = x; x.append(10); print y will print [10].  The empty list was created.  Both &quot;x&quot; and &quot;y&quot; point to the same list.  The append method mutates (updates) the list object (like adding a record to a database) and the result is visible to both &quot;x&quot; and &quot;y&quot; (just as a database update would be visible to every connection to that database).\n\n\nHope that clarifies the issue for you. \n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"Technically, Python always uses pass by reference values. I am going to repeat my other answer to support my statement.\n\nPython always uses pass-by-reference values. There isn&apos;t any exception. Any variable assignment means copying the reference value. No exception. Any variable is the name bound to the reference value. Always.\n\nYou can think about a reference value as the address of the target object. The address is automatically dereferenced when used. This way, working with the reference value, it seems you work directly with the target object. But there always is a reference in between, one step more to jump to the target.\n\nHere is the example that proves that Python uses passing by reference:\n\n\n\nIf the argument was passed by value, the outer lst could not be modified. The green are the target objects (the black is the value stored inside, the red is the object type), the yellow is the memory with the reference value inside -- drawn as the arrow. The blue solid arrow is the reference value that was passed to the function (via the dashed blue arrow path). The ugly dark yellow is the internal dictionary. (It actually could be drawn also as a green ellipse. The colour and the shape only says it is internal.)\n\nYou can use the id() built-in function to learn what the reference value is (that is, the address of the target object).\n\nIn compiled languages, a variable is a memory space that is able to capture the value of the type. In Python, a variable is a name (captured internally as a string) bound to the reference variable that holds the reference value to the target object. The name of the variable is the key in the internal dictionary, the value part of that dictionary item stores the reference value to the target.\n\nReference values are hidden in Python. There isn&apos;t any explicit user type for storing the reference value. However, you can use a list element (or element in any other suitable container type) as the reference variable, because all containers do store the elements also as references to the target objects. In other words, elements are actually not contained inside the container -- only the references to elements are.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"A simple trick I normally use is to just wrap it in a list:\n\ndef Change(self, var):\n    var[0] = &apos;Changed&apos;\n\nvariable = [&apos;Original&apos;]\nself.Change(variable)      \nprint variable[0]\n\n\n(Yeah I know this can be inconvenient, but sometimes it is simple enough to do this.)\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"(edit - Blair has updated his enormously popular answer so that it is now accurate)\n\nI think it is important to note that the current post with the most votes (by Blair Conrad), while being correct with respect to its result, is misleading and is borderline incorrect based on its definitions.  While there are many languages (like C) that allow the user to either pass by reference or pass by value, Python is not one of them.\n\nDavid Cournapeau&apos;s answer points to the real answer and explains why the behavior in Blair Conrad&apos;s post seems to be correct while the definitions are not.\n\nTo the extent that Python is pass by value, all languages are pass by value since some piece of data (be it a &quot;value&quot; or a &quot;reference&quot;) must be sent. However, that does not mean that Python is pass by value in the sense that a C programmer would think of it.\n\nIf you want the behavior, Blair Conrad&apos;s answer is fine.  But if you want to know the nuts and bolts of why Python is neither pass by value or pass by reference, read David Cournapeau&apos;s answer.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"You got some really good answers here.\n\nx = [ 2, 4, 4, 5, 5 ]\nprint x  # 2, 4, 4, 5, 5\n\ndef go( li ) :\n  li = [ 5, 6, 7, 8 ]  # re-assigning what li POINTS TO, does not\n  # change the value of the ORIGINAL variable x\n\ngo( x ) \nprint x  # 2, 4, 4, 5, 5  [ STILL! ]\n\n\nraw_input( &apos;press any key to continue&apos; )\n\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"Pythons pass-by-assignment scheme isnt quite the same as C++s reference parameters option, but it turns out to be very similar to the argument-passing model of the C language (and others) in practice:\n\n\nImmutable arguments are effectively passed by value. Objects such as integers and strings are passed by object reference instead of by copying, but because you cant change immutable objects in place anyhow, the effect is much like making a copy.\nMutable arguments are effectively passed by pointer. Objects such as lists\nand dictionaries are also passed by object reference, which is similar to the way C\npasses arrays as pointersmutable objects can be changed in place in the function,\nmuch like C arrays.\n\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"In this case the variable titled var in the method Change is assigned a reference to self.variable, and you immediately assign a string to var. It&apos;s no longer pointing to self.variable. The following code snippet shows what would happen if you modify the data structure pointed to by var and self.variable, in this case a list:\n\n&gt;&gt;&gt; class PassByReference:\n...     def __init__(self):\n...         self.variable = [&apos;Original&apos;]\n...         self.change(self.variable)\n...         print self.variable\n...         \n...     def change(self, var):\n...         var.append(&apos;Changed&apos;)\n... \n&gt;&gt;&gt; q = PassByReference()\n[&apos;Original&apos;, &apos;Changed&apos;]\n&gt;&gt;&gt; \n\n\nI&apos;m sure someone else could clarify this further.\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"A lot of insights in answers here, but i think an additional point is not clearly mentioned here explicitly.   Quoting from python documentation https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python  \n\n&quot;In Python, variables that are only referenced inside a function are implicitly global. If a variable is assigned a new value anywhere within the functions body, its assumed to be a local. If a variable is ever assigned a new value inside the function, the variable is implicitly local, and you need to explicitly declare it as global.\nThough a bit surprising at first, a moments consideration explains this. On one hand, requiring global for assigned variables provides a bar against unintended side-effects. On the other hand, if global was required for all global references, youd be using global all the time. Youd have to declare as global every reference to a built-in function or to a component of an imported module. This clutter would defeat the usefulness of the global declaration for identifying side-effects.&quot;\n\nEven when passing a mutable object to a function this still applies. And to me clearly explains the reason for the difference in behavior between assigning to the object and operating on the object in the function.\n\ndef test(l):\n    print &quot;Received&quot;, l , id(l)\n    l = [0, 0, 0]\n    print &quot;Changed to&quot;, l, id(l)  # New local object created, breaking link to global l\n\nl= [1,2,3]\nprint &quot;Original&quot;, l, id(l)\ntest(l)\nprint &quot;After&quot;, l, id(l)\n\n\ngives:\n\nOriginal [1, 2, 3] 4454645632\nReceived [1, 2, 3] 4454645632\nChanged to [0, 0, 0] 4474591928\nAfter [1, 2, 3] 4454645632\n\n\nThe assignment to an global variable that is not declared global therefore creates a new local object and breaks the link to the original object.\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"As you can state you need to have a mutable object, but let me suggest you to check over the global variables as they can help you or even solve this kind of issue!\n\nhttp://docs.python.org/3/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python\n\nexample:\n\n&gt;&gt;&gt; def x(y):\n...     global z\n...     z = y\n...\n\n&gt;&gt;&gt; x\n&lt;function x at 0x00000000020E1730&gt;\n&gt;&gt;&gt; y\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nNameError: name &apos;y&apos; is not defined\n&gt;&gt;&gt; z\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nNameError: name &apos;z&apos; is not defined\n\n&gt;&gt;&gt; x(2)\n&gt;&gt;&gt; x\n&lt;function x at 0x00000000020E1730&gt;\n&gt;&gt;&gt; y\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nNameError: name &apos;y&apos; is not defined\n&gt;&gt;&gt; z\n2\n\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"Here is the simple (I hope) explanation of the concept pass by object used in Python.\nWhenever you pass an object to the function, the object itself is passed (object in Python is actually what you&apos;d call a value in other programming languages) not the reference to this object. In other words, when you call:\n\ndef change_me(list):\n   list = [1, 2, 3]\n\nmy_list = [0, 1]\nchange_me(my_list)\n\n\nThe actual object - [0, 1] (which would be called a value in other programming languages) is being passed. So in fact the function change_me will try to do something like:\n\n[0, 1] = [1, 2, 3]\n\n\nwhich obviously will not change the object passed to the function. If the function looked like this:\n\ndef change_me(list):\n   list.append(2)\n\n\nThen the call would result in:\n\n[0, 1].append(2)\n\n\nwhich obviously will change the object. This answer explains it well.\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"Aside from all the great explanations on how this stuff works in Python, I don&apos;t see a simple suggestion for the problem. As you seem to do create objects and instances, the pythonic way of handling instance variables and changing them is the following:\n\nclass PassByReference:\n    def __init__(self):\n        self.variable = &apos;Original&apos;\n        self.Change()\n        print self.variable\n\n    def Change(self):\n        self.variable = &apos;Changed&apos;\n\n\nIn instance methods, you normally refer to self to access instance attributes. It is normal to set instance attributes in __init__ and read or change them in instance methods. That is also why you pass self als the first argument to def Change.\n\nAnother solution would be to create a static method like this:\n\nclass PassByReference:\n    def __init__(self):\n        self.variable = &apos;Original&apos;\n        self.variable = PassByReference.Change(self.variable)\n        print self.variable\n\n    @staticmethod\n    def Change(var):\n        var = &apos;Changed&apos;\n        return var\n\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"I used the following method to quickly convert a couple of Fortran codes to Python.  True, it&apos;s not pass by reference as the original question was posed, but is a simple work around in some cases.\n\na=0\nb=0\nc=0\ndef myfunc(a,b,c):\n    a=1\n    b=2\n    c=3\n    return a,b,c\n\na,b,c = myfunc(a,b,c)\nprint a,b,c\n\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0},{"text":"There is a little trick to pass an object by reference, even though the language doesn&apos;t make it possible. It works in Java too, it&apos;s the list with one item. ;-)\n\nclass PassByReference:\n    def __init__(self, name):\n        self.name = name\n\ndef changeRef(ref):\n    ref[0] = PassByReference(&apos;Michael&apos;)\n\nobj = PassByReference(&apos;Peter&apos;)\nprint obj.name\n\np = [obj] # A pointer to obj! ;-)\nchangeRef(p)\n\nprint p[0].name # p-&gt;name\n\n\nIt&apos;s an ugly hack, but it works. ;-P\n    ","url":"/questions/[slug]#solution19","@type":"Answer","upvoteCount":0},{"text":"given the way python handles values and references to them, the only way you can reference an arbitrary instance attribute is by name:\n\nclass PassByReferenceIsh:\n    def __init__(self):\n        self.variable = &apos;Original&apos;\n        self.change(&apos;variable&apos;)\n        print self.variable\n\n    def change(self, var):\n        self.__dict__[var] = &apos;Changed&apos;\n\n\nin real code you would, of course, add error checking on the dict lookup.\n    ","url":"/questions/[slug]#solution20","@type":"Answer","upvoteCount":0},{"text":"Since your example happens to be object-oriented, you could make the following change to achieve a similar result:\n\nclass PassByReference:\n    def __init__(self):\n        self.variable = &apos;Original&apos;\n        self.change(&apos;variable&apos;)\n        print(self.variable)\n\n    def change(self, var):\n        setattr(self, var, &apos;Changed&apos;)\n\n# o.variable will equal &apos;Changed&apos;\no = PassByReference()\nassert o.variable == &apos;Changed&apos;\n\n    ","url":"/questions/[slug]#solution21","@type":"Answer","upvoteCount":0},{"text":"Since it seems to be nowhere mentioned an approach to simulate references as known from e.g. C++ is to use an &quot;update&quot; function and pass that instead of the actual variable (or rather, &quot;name&quot;):\n\ndef need_to_modify(update):\n    update(42) # set new value 42\n    # other code\n\ndef call_it():\n    value = 21\n    def update_value(new_value):\n        nonlocal value\n        value = new_value\n    need_to_modify(update_value)\n    print(value) # prints 42\n\n\nThis is mostly useful for &quot;out-only references&quot; or in a situation with multiple threads / processes (by making the update function thread / multiprocessing safe).\n\nObviously the above does not allow reading the value, only updating it.\n    ","url":"/questions/[slug]#solution22","@type":"Answer","upvoteCount":0},{"text":"Since dictionaries are passed by reference, you can use a dict variable to store any referenced values inside it.\n# returns the result of adding numbers `a` and `b`\ndef AddNumbers(a, b, ref): # using a dict for reference\n    result = a + b\n    ref[&apos;multi&apos;] = a * b # reference the multi. ref[&apos;multi&apos;] is number\n    ref[&apos;msg&apos;] = &quot;The result: &quot; + str(result) + &quot; was nice!&quot;\n    return result\n\nnumber1 = 5\nnumber2 = 10\nref = {} # init a dict like that so it can save all the referenced values. this is because all dictionaries are passed by reference, while strings and numbers do not.\n\nsum = AddNumbers(number1, number2, ref)\nprint(&quot;sum: &quot;, sum)             # the returned value\nprint(&quot;multi: &quot;, ref[&apos;multi&apos;])  # a referenced value\nprint(&quot;msg: &quot;, ref[&apos;msg&apos;])      # a referenced value\n\n    ","url":"/questions/[slug]#solution23","@type":"Answer","upvoteCount":0},{"text":"While pass by reference is nothing that fits well into python and should be rarely used there are some workarounds that actually can work to get the object currently assigned to a local variable or even reassign a local variable from inside of a called function.\n\nThe basic idea is to have a function that can do that access and can be passed as object into other functions or stored in a class.\n\nOne way is to use global (for global variables) or nonlocal (for local variables in a function) in a wrapper function.\n\ndef change(wrapper):\n    wrapper(7)\n\nx = 5\ndef setter(val):\n    global x\n    x = val\nprint(x)\n\n\nThe same idea works for reading and deleting a variable.\n\nFor just reading there is even a shorter way of just using lambda: x which returns a callable that when called returns the current value of x. This is somewhat like &quot;call by name&quot; used in languages in the distant past.\n\nPassing 3 wrappers to access a variable is a bit unwieldy so those can be wrapped into a class that has a proxy attribute:\n\nclass ByRef:\n    def __init__(self, r, w, d):\n        self._read = r\n        self._write = w\n        self._delete = d\n    def set(self, val):\n        self._write(val)\n    def get(self):\n        return self._read()\n    def remove(self):\n        self._delete()\n    wrapped = property(get, set, remove)\n\n# left as an exercise for the reader: define set, get, remove as local functions using global / nonlocal\nr = ByRef(get, set, remove)\nr.wrapped = 15\n\n\nPythons &quot;reflection&quot; support makes it possible to get a object that is capable of reassigning a name/variable in a given scope without defining functions explicitly in that scope:\n\nclass ByRef:\n    def __init__(self, locs, name):\n        self._locs = locs\n        self._name = name\n    def set(self, val):\n        self._locs[self._name] = val\n    def get(self):\n        return self._locs[self._name]\n    def remove(self):\n        del self._locs[self._name]\n    wrapped = property(get, set, remove)\n\ndef change(x):\n    x.wrapped = 7\n\ndef test_me():\n    x = 6\n    print(x)\n    change(ByRef(locals(), &quot;x&quot;))\n    print(x)\n\n\nHere the ByRef class wraps a dictionary access. So attribute access to wrapped is translated to a item access in the passed dictionary. By passing the result of the builtin locals and the name of a local variable this ends up accessing a local variable. The python documentation as of 3.5 advises that changing the dictionary might not work but it seems to work for me.\n    ","url":"/questions/[slug]#solution24","@type":"Answer","upvoteCount":0},{"text":"You can merely use an empty class as an instance to store reference objects because internally object attributes are stored in an instance dictionary. See the example.\n\nclass RefsObj(object):\n    &quot;A class which helps to create references to variables.&quot;\n    pass\n\n...\n\n# an example of usage\ndef change_ref_var(ref_obj):\n    ref_obj.val = 24\n\nref_obj = RefsObj()\nref_obj.val = 1\nprint(ref_obj.val) # or print ref_obj.val for python2\nchange_ref_var(ref_obj)\nprint(ref_obj.val)\n\n    ","url":"/questions/[slug]#solution25","@type":"Answer","upvoteCount":0},{"text":"Pass-By-Reference in Python is quite different from the concept of pass by reference in C++/Java. \n\n\nJava&amp;C#: primitive types(include string)pass by value(copy), Reference type is passed by reference(address copy) so all changes made in the parameter in the called function are visible to the caller.\nC++: Both pass-by-reference or pass-by-value are allowed. If a parameter is passed by reference, you can either modify it or not depending upon whether the parameter was passed as const or not. However, const or not, the parameter maintains the reference to the object and reference cannot be assigned to point to a different object within the called function.\nPython: \nPython is pass-by-object-reference, of which it is often said: Object references are passed by value.[Read here]1. Both the caller and the function refer to the same object but the parameter in the function is a new variable which is just holding a copy of the object in the caller. Like C++, a parameter can be either modified or not in function - This depends upon the type of object passed. eg; An immutable object type cannot be modified in the called function whereas a mutable object can be either updated or re-initialized. A crucial difference between updating or re-assigning/re-initializing the mutable variable is that updated value gets reflected back in the called function whereas the reinitialized value does not. Scope of any assignment of new object to a mutable variable is local to the function in the python. Examples provided by @blair-conrad are great to understand this.\n\n    ","url":"/questions/[slug]#solution26","@type":"Answer","upvoteCount":0},{"text":"I am new to Python, started yesterday (though I have been programming for 45 years).\nI came here because I was writing a function where I wanted to have two so called out-parameters. If it would have been only one out-parameter, I wouldn&apos;t get hung up right now on checking how reference/value works in Python. I would just have used the return value of the function instead. But since I needed two such out-parameters I felt I needed to sort it out.\nIn this post I am going to show how I solved my situation. Perhaps others coming here can find it valuable, even though it is not exactly an answer to the topic question. Experienced Python programmers of course already know about the solution I used, but it was new to me.\nFrom the answers here I could quickly see that Python works a bit like Javascript in this regard, and that you need to use workarounds if you want the reference functionality.\nBut then I found something neat in Python that I don&apos;t think I have seen in other languages before, namely that you can return more than one value from a function, in a simple comma separated way, like this:\ndef somefunction(p):\n    a=p+1\n    b=p+2\n    c=-p\n    return a, b, c\n\nand that you can handle that on the calling side similarly, like this\nx, y, z = somefunction(w)\n\nThat was good enough for me and I was satisfied. No need to use some workaround.\nIn other languages you can of course also return many values, but then usually in the from of an object, and you need to adjust the calling side accordingly.\nThe Python way of doing it was nice and simple.\nIf you want to mimic by reference even more, you could do as follows:\ndef somefunction(a, b, c):\n    a = a * 2\n    b = b + a\n    c = a * b * c\n    return a, b, c\n\nx = 3\ny = 5\nz = 10\nprint(F&quot;Before : {x}, {y}, {z}&quot;)\n\nx, y, z = somefunction(x, y, z)\n\nprint(F&quot;After  : {x}, {y}, {z}&quot;)\n\nwhich gives this result\nBefore : 3, 5, 10  \nAfter  : 6, 11, 660  \n\n    ","url":"/questions/[slug]#solution27","@type":"Answer","upvoteCount":0},{"text":"alternatively you could use ctypes witch would look something like this\nimport ctypes\n\ndef f(a):\n    a.value=2398 ## resign the value in a function\n\na = ctypes.c_int(0)\nprint(&quot;pre f&quot;, a)\nf(a)\nprint(&quot;post f&quot;, a)\n\nas a is a c int and not a python integer and apperently passed by reference. however you have to be carefull as strange things could happen and is therefor not advised\n    ","url":"/questions/[slug]#solution28","@type":"Answer","upvoteCount":0},{"text":"Most likely not the most reliable method but this works, keep in mind that you are overloading the built-in str function which is typically something you don&apos;t want to do:\nimport builtins\n\nclass sstr(str):\n    def __str__(self):\n        if hasattr(self, &apos;changed&apos;):\n            return self.changed\n\n        return self\n\n    def change(self, value):\n        self.changed = value\n\nbuiltins.str = sstr\n\ndef change_the_value(val):\n    val.change(&apos;After&apos;)\n\nval = str(&apos;Before&apos;)\nprint (val)\nchange_the_value(val)\nprint (val)\n\n    ","url":"/questions/[slug]#solution29","@type":"Answer","upvoteCount":0},{"text":"What about dataclasses? Also, it allows you to apply type restriction (aka &quot;type hint&quot;).\nfrom dataclasses import dataclass\n\n@dataclass\nclass Holder:\n    obj: your_type # Need any type? Use &quot;obj: object&quot; then.\n\ndef foo(ref: Holder):\n    ref.obj = do_something()\n\nI agree with folks that in most cases you&apos;d better consider not to use it.\nAnd yet, when we&apos;re talking about contexts it&apos;s worth to know that way.\nYou can design explicit context class though. When prototyping I prefer dataclasses, just because it&apos;s easy to serialize them back and forth.\nCheers!\n    ","url":"/questions/[slug]#solution30","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-12e9794e898cd5f3.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-928c5d1eb8fb0bba.js" defer=""></script><script src="/_next/static/BnkbnjkWYxefPXjTJLVVv/_buildManifest.js" defer=""></script><script src="/_next/static/BnkbnjkWYxefPXjTJLVVv/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/how-do-i-pass-a-variable-by-reference-1657384657232#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/how-do-i-pass-a-variable-by-reference-1657384657232"><h1>How do I pass a variable by reference?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"></div></div><div class="question-content mt-5">
                
<p>Are parameters passed by reference or by value? How do I pass by reference so that the code below outputs <code>'Changed'</code> instead of <code>'Original'</code>?</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PassByReference</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        self.variable = <span class="hljs-string">'Original'</span>
        self.change(self.variable)
        <span class="hljs-built_in">print</span>(self.variable)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">change</span>(<span class="hljs-params">self, var</span>):
        var = <span class="hljs-string">'Changed'</span>
</code></pre>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li><li class="pagination-solution-item"><span data-id="#solution19" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">19</span></li><li class="pagination-solution-item"><span data-id="#solution20" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">20</span></li><li class="pagination-solution-item"><span data-id="#solution21" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">21</span></li><li class="pagination-solution-item"><span data-id="#solution22" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">22</span></li><li class="pagination-solution-item"><span data-id="#solution23" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">23</span></li><li class="pagination-solution-item"><span data-id="#solution24" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">24</span></li><li class="pagination-solution-item"><span data-id="#solution25" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">25</span></li><li class="pagination-solution-item"><span data-id="#solution26" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">26</span></li><li class="pagination-solution-item"><span data-id="#solution27" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">27</span></li><li class="pagination-solution-item"><span data-id="#solution28" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">28</span></li><li class="pagination-solution-item"><span data-id="#solution29" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">29</span></li><li class="pagination-solution-item"><span data-id="#solution30" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">30</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Arguments are <a href="http://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference" rel="noreferrer">passed by assignment</a>. The rationale behind this is twofold:</p>

<ol>
<li>the parameter passed in is actually a <em>reference</em> to an object (but the reference is passed by value)</li>
<li>some data types are mutable, but others aren't</li>
</ol>

<p>So:</p>

<ul>
<li><p>If you pass a <em>mutable</em> object into a method, the method gets a reference to that same object and you can mutate it to your heart's delight, but if you rebind the reference in the method, the outer scope will know nothing about it, and after you're done, the outer reference will still point at the original object. </p></li>
<li><p>If you pass an <em>immutable</em> object to a method, you still can't rebind the outer reference, and you can't even mutate the object.</p></li>
</ul>

<p>To make it even more clear, let's have some examples. </p>

<h2>List - a mutable type</h2>

<p><strong>Let's try to modify the list that was passed to a method:</strong></p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">try_to_change_list_contents</span>(<span class="hljs-params">the_list</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'got'</span>, the_list)
    the_list.append(<span class="hljs-string">'four'</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'changed to'</span>, the_list)

outer_list = [<span class="hljs-string">'one'</span>, <span class="hljs-string">'two'</span>, <span class="hljs-string">'three'</span>]

<span class="hljs-built_in">print</span>(<span class="hljs-string">'before, outer_list ='</span>, outer_list)
try_to_change_list_contents(outer_list)
<span class="hljs-built_in">print</span>(<span class="hljs-string">'after, outer_list ='</span>, outer_list)
</code></pre>

<p>Output:</p>

<pre class="lang-none s-code-block"><code>before, outer_list = ['one', 'two', 'three']
got ['one', 'two', 'three']
changed to ['one', 'two', 'three', 'four']
after, outer_list = ['one', 'two', 'three', 'four']
</code></pre>

<p>Since the parameter passed in is a reference to <code>outer_list</code>, not a copy of it, we can use the mutating list methods to change it and have the changes reflected in the outer scope.</p>

<p><strong>Now let's see what happens when we try to change the reference that was passed in as a parameter:</strong></p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">try_to_change_list_reference</span>(<span class="hljs-params">the_list</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'got'</span>, the_list)
    the_list = [<span class="hljs-string">'and'</span>, <span class="hljs-string">'we'</span>, <span class="hljs-string">'can'</span>, <span class="hljs-string">'not'</span>, <span class="hljs-string">'lie'</span>]
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'set to'</span>, the_list)

outer_list = [<span class="hljs-string">'we'</span>, <span class="hljs-string">'like'</span>, <span class="hljs-string">'proper'</span>, <span class="hljs-string">'English'</span>]

<span class="hljs-built_in">print</span>(<span class="hljs-string">'before, outer_list ='</span>, outer_list)
try_to_change_list_reference(outer_list)
<span class="hljs-built_in">print</span>(<span class="hljs-string">'after, outer_list ='</span>, outer_list)
</code></pre>

<p>Output:</p>

<pre class="lang-none s-code-block"><code>before, outer_list = ['we', 'like', 'proper', 'English']
got ['we', 'like', 'proper', 'English']
set to ['and', 'we', 'can', 'not', 'lie']
after, outer_list = ['we', 'like', 'proper', 'English']
</code></pre>

<p>Since the <code>the_list</code> parameter was passed by value, assigning a new list to it had no effect that the code outside the method could see. The <code>the_list</code> was a copy of the <code>outer_list</code> reference, and we had <code>the_list</code> point to a new list, but there was no way to change where <code>outer_list</code> pointed.</p>

<h2>String - an immutable type</h2>

<p><strong>It's immutable, so there's nothing we can do to change the contents of the string</strong></p>

<p><strong>Now, let's try to change the reference</strong></p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">try_to_change_string_reference</span>(<span class="hljs-params">the_string</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'got'</span>, the_string)
    the_string = <span class="hljs-string">'In a kingdom by the sea'</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'set to'</span>, the_string)

outer_string = <span class="hljs-string">'It was many and many a year ago'</span>

<span class="hljs-built_in">print</span>(<span class="hljs-string">'before, outer_string ='</span>, outer_string)
try_to_change_string_reference(outer_string)
<span class="hljs-built_in">print</span>(<span class="hljs-string">'after, outer_string ='</span>, outer_string)
</code></pre>

<p>Output:</p>

<pre class="lang-none s-code-block"><code>before, outer_string = It was many and many a year ago
got It was many and many a year ago
set to In a kingdom by the sea
after, outer_string = It was many and many a year ago
</code></pre>

<p>Again, since the <code>the_string</code> parameter was passed by value, assigning a new string to it had no effect that the code outside the method could see. The <code>the_string</code> was a copy of the <code>outer_string</code> reference, and we had <code>the_string</code> point to a new string, but there was no way to change where <code>outer_string</code> pointed.</p>

<p>I hope this clears things up a little.</p>

<p><strong>EDIT:</strong> It's been noted that this doesn't answer the question that @David originally asked, "Is there something I can do to pass the variable by actual reference?". Let's work on that.</p>

<h2>How do we get around this?</h2>

<p>As @Andrea's answer shows, you could return the new value. This doesn't change the way things are passed in, but does let you get the information you want back out:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">return_a_whole_new_string</span>(<span class="hljs-params">the_string</span>):
    new_string = something_to_do_with_the_old_string(the_string)
    <span class="hljs-keyword">return</span> new_string

<span class="hljs-comment"># then you could call it like</span>
my_string = return_a_whole_new_string(my_string)
</code></pre>

<p>If you really wanted to avoid using a return value, you could create a class to hold your value and pass it into the function or use an existing class, like a list:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">use_a_wrapper_to_simulate_pass_by_reference</span>(<span class="hljs-params">stuff_to_change</span>):
    new_string = something_to_do_with_the_old_string(stuff_to_change[<span class="hljs-number">0</span>])
    stuff_to_change[<span class="hljs-number">0</span>] = new_string

<span class="hljs-comment"># then you could call it like</span>
wrapper = [my_string]
use_a_wrapper_to_simulate_pass_by_reference(wrapper)

do_something_with(wrapper[<span class="hljs-number">0</span>])
</code></pre>

<p>Although this seems a little cumbersome.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The problem comes from a misunderstanding of what variables are in Python. If you're used to most traditional languages, you have a mental model of what happens in the following sequence:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">a = <span class="hljs-number">1</span>
a = <span class="hljs-number">2</span>
</code></pre>

<p>You believe that <code>a</code> is a memory location that stores the value <code>1</code>, then is updated to store the value <code>2</code>. That's not how things work in Python. Rather, <code>a</code> starts as a reference to an object with the value <code>1</code>, then gets reassigned as a reference to an object with the value <code>2</code>. Those two objects may continue to coexist even though <code>a</code> doesn't refer to the first one anymore; in fact they may be shared by any number of other references within the program.</p>

<p>When you call a function with a parameter, a new reference is created that refers to the object passed in. This is separate from the reference that was used in the function call, so there's no way to update that reference and make it refer to a new object. In your example:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
    self.variable = <span class="hljs-string">'Original'</span>
    self.Change(self.variable)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">Change</span>(<span class="hljs-params">self, var</span>):
    var = <span class="hljs-string">'Changed'</span>
</code></pre>

<p><code>self.variable</code> is a reference to the string object <code>'Original'</code>. When you call <code>Change</code> you create a second reference <code>var</code> to the object. Inside the function you reassign the reference <code>var</code> to a different string object <code>'Changed'</code>, but the reference <code>self.variable</code> is separate and does not change.</p>

<p>The only way around this is to pass a mutable object. Because both references refer to the same object, any changes to the object are reflected in both places.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):         
    self.variable = [<span class="hljs-string">'Original'</span>]
    self.Change(self.variable)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">Change</span>(<span class="hljs-params">self, var</span>):
    var[<span class="hljs-number">0</span>] = <span class="hljs-string">'Changed'</span>
</code></pre>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I found the other answers rather long and complicated, so I created this simple diagram to explain the way Python treats variables and parameters.
<a href="https://i.stack.imgur.com/FdaCu.png"><img src="https://i.stack.imgur.com/FdaCu.png" alt="enter image description here"></a></p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It is neither pass-by-value or pass-by-reference - it is call-by-object. See this, by Fredrik Lundh:</p>
<p><a href="http://web.archive.org/web/20201111195827/http://www.effbot.org/zone/call-by-object.htm" rel="noreferrer">http://effbot.org/zone/call-by-object.htm</a></p>
<p>Here is a significant quote:</p>
<blockquote>
<p>"...variables [names] are <em>not</em> objects; they cannot be denoted by other variables or referred to by objects."</p>
</blockquote>
<p>In your example, when the <code>Change</code> method is called--a <a href="http://docs.python.org/2/tutorial/classes.html#python-scopes-and-namespaces" rel="noreferrer">namespace</a> is created for it; and <code>var</code> becomes a name, within that namespace, for the string object <code>'Original'</code>. That object then has a name in two namespaces. Next, <code>var = 'Changed'</code> binds <code>var</code> to a new string object, and thus the method's namespace forgets about <code>'Original'</code>. Finally, that namespace is forgotten, and the string <code>'Changed'</code> along with it.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Think of stuff being passed <strong>by assignment</strong> instead of by reference/by value. That way, it is always clear, what is happening as long as you understand what happens during the normal assignment.</p>

<p>So, when passing a list to a function/method, the list is assigned to the parameter name. Appending to the list will result in the list being modified. Reassigning the list <em>inside</em> the function will not change the original list, since:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
b = a
b.append(<span class="hljs-number">4</span>)
b = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]
<span class="hljs-built_in">print</span> a, b      <span class="hljs-comment"># prints [1, 2, 3, 4] ['a', 'b']</span>
</code></pre>

<p>Since immutable types cannot be modified, they <em>seem</em> like being passed by value - passing an int into a function means assigning the int to the function's parameter. You can only ever reassign that, but it won't change the original variables value.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>There are no variables in Python</h1>

<p>The key to understanding parameter passing is to stop thinking about "variables". There are names and objects in Python and together they
appear like variables, but it is useful to always distinguish the three.</p>

<ol>
<li>Python has names and objects.</li>
<li>Assignment binds a name to an object.</li>
<li>Passing an argument into a function also binds a name (the parameter name of the function) to an object.</li>
</ol>

<p>That is all there is to it. Mutability is irrelevant to this question.</p>

<p>Example:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">a = <span class="hljs-number">1</span>
</code></pre>

<p>This binds the name <code>a</code> to an object of type integer that holds the value 1.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">b = x
</code></pre>

<p>This binds the name <code>b</code> to the same object that the name <code>x</code> is currently bound to.
Afterward, the name <code>b</code> has nothing to do with the name <code>x</code> anymore.</p>

<p>See sections <a href="https://docs.python.org/3/reference/datamodel.html#objects-values-and-types" rel="noreferrer">3.1</a> and <a href="https://docs.python.org/3/reference/executionmodel.html#naming-and-binding" rel="noreferrer">4.2</a> in the Python 3 language reference.</p>

<h1>How to read the example in the question</h1>

<p>In the code shown in the question, the statement <code>self.Change(self.variable)</code> binds the name <code>var</code> (in the scope of function <code>Change</code>) to the object that holds the value <code>'Original'</code> and the assignment <code>var = 'Changed'</code> (in the body of function <code>Change</code>) assigns that same name again: to some other object (that happens to hold a string as well but could have been something else entirely).</p>

<h1>How to pass by reference</h1>

<p>So if the thing you want to change is a mutable object, there is no problem, as everything is effectively passed by reference.</p>

<p>If it is an <a href="https://docs.python.org/3/reference/datamodel.html#objects-values-and-types" rel="noreferrer">immutable</a> object (e.g. a bool, number, string), the way to go is to wrap it in a mutable object.<br>
The quick-and-dirty solution for this is a one-element list (instead of <code>self.variable</code>, pass <code>[self.variable]</code> and in the function modify <code>var[0]</code>).<br>
The more <a href="https://www.python.org/dev/peps/pep-0020/" rel="noreferrer">pythonic</a> approach would be to introduce a trivial, one-attribute class. The function receives an instance of the class and manipulates the attribute.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Effbot (aka Fredrik Lundh) has described Python's variable passing style as call-by-object:  <a href="http://effbot.org/zone/call-by-object.htm">http://effbot.org/zone/call-by-object.htm</a></p>

<p>Objects are allocated on the heap and pointers to them can be passed around anywhere.  </p>

<ul>
<li><p>When you make an assignment such as <code>x = 1000</code>, a dictionary entry is created that maps the string "x" in the current namespace to a pointer to the integer object containing one thousand.   </p></li>
<li><p>When you update "x" with <code>x = 2000</code>, a new integer object is created and the dictionary is updated to point at the new object.  The old one thousand object is unchanged (and may or may not be alive depending on whether anything else refers to the object).</p></li>
<li><p>When you do a new assignment such as <code>y = x</code>, a new dictionary entry "y" is created that points to the same object as the entry for "x".</p></li>
<li><p>Objects like strings and integers are <em>immutable</em>.  This simply means that there are no methods that can change the object after it has been created.  For example, once the integer object one-thousand is created, it will never change.  Math is done by creating new integer objects.</p></li>
<li><p>Objects like lists are <em>mutable</em>.  This means that the contents of the object can be changed by anything pointing to the object.  For example, <code>x = []; y = x; x.append(10); print y</code> will print <code>[10]</code>.  The empty list was created.  Both "x" and "y" point to the same list.  The <em>append</em> method mutates (updates) the list object (like adding a record to a database) and the result is visible to both "x" and "y" (just as a database update would be visible to every connection to that database).</p></li>
</ul>

<p>Hope that clarifies the issue for you. </p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Technically, <strong>Python always uses pass by reference values</strong>. I am going to repeat <a href="https://stackoverflow.com/a/12438316/1346705">my other answer</a> to support my statement.</p>

<p>Python always uses pass-by-reference values. There isn't any exception. Any variable assignment means copying the reference value. No exception. Any variable is the name bound to the reference value. Always.</p>

<p>You can think about a reference value as the address of the target object. The address is automatically dereferenced when used. This way, working with the reference value, it seems you work directly with the target object. But there always is a reference in between, one step more to jump to the target.</p>

<p>Here is the example that proves that Python uses passing by reference:</p>

<p><img src="https://i.stack.imgur.com/uzXcP.png" alt="Illustrated example of passing the argument"></p>

<p>If the argument was passed by value, the outer <code>lst</code> could not be modified. The green are the target objects (the black is the value stored inside, the red is the object type), the yellow is the memory with the reference value inside -- drawn as the arrow. The blue solid arrow is the reference value that was passed to the function (via the dashed blue arrow path). The ugly dark yellow is the internal dictionary. (It actually could be drawn also as a green ellipse. The colour and the shape only says it is internal.)</p>

<p>You can use the <a href="http://docs.python.org/3.3/library/functions.html#id" rel="noreferrer"><code>id()</code></a> built-in function to learn what the reference value is (that is, the address of the target object).</p>

<p>In compiled languages, a variable is a memory space that is able to capture the value of the type. In Python, a variable is a name (captured internally as a string) bound to the reference variable that holds the reference value to the target object. The name of the variable is the key in the internal dictionary, the value part of that dictionary item stores the reference value to the target.</p>

<p>Reference values are hidden in Python. There isn't any explicit user type for storing the reference value. However, you can use a list element (or element in any other suitable container type) as the reference variable, because all containers do store the elements also as references to the target objects. In other words, elements are actually not contained inside the container -- only the references to elements are.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A simple trick I normally use is to just wrap it in a list:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">Change</span>(<span class="hljs-params">self, var</span>):
    var[<span class="hljs-number">0</span>] = <span class="hljs-string">'Changed'</span>

variable = [<span class="hljs-string">'Original'</span>]
self.Change(variable)      
<span class="hljs-built_in">print</span> variable[<span class="hljs-number">0</span>]
</code></pre>

<p>(Yeah I know this can be inconvenient, but sometimes it is simple enough to do this.)</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>(edit - Blair has updated his enormously popular answer so that it is now accurate)</p>

<p>I think it is important to note that the current post with the most votes (by Blair Conrad), while being correct with respect to its result, is misleading and is borderline incorrect based on its definitions.  While there are many languages (like C) that allow the user to either pass by reference or pass by value, Python is not one of them.</p>

<p>David Cournapeau's answer points to the real answer and explains why the behavior in Blair Conrad's post seems to be correct while the definitions are not.</p>

<p>To the extent that Python is pass by value, all languages are pass by value since some piece of data (be it a "value" or a "reference") must be sent. However, that does not mean that Python is pass by value in the sense that a C programmer would think of it.</p>

<p>If you want the behavior, Blair Conrad's answer is fine.  But if you want to know the nuts and bolts of why Python is neither pass by value or pass by reference, read David Cournapeau's answer.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You got some really good answers here.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">x = [ <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span> ]
<span class="hljs-built_in">print</span> x  <span class="hljs-comment"># 2, 4, 4, 5, 5</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">go</span>(<span class="hljs-params"> li </span>) :
  li = [ <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span> ]  <span class="hljs-comment"># re-assigning what li POINTS TO, does not</span>
  <span class="hljs-comment"># change the value of the ORIGINAL variable x</span>

go( x ) 
<span class="hljs-built_in">print</span> x  <span class="hljs-comment"># 2, 4, 4, 5, 5  [ STILL! ]</span>


raw_input( <span class="hljs-string">'press any key to continue'</span> )
</code></pre>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Pythons pass-by-assignment scheme isnt quite the same as C++s reference parameters option, but it turns out to be very similar to the argument-passing model of the C language (and others) in practice:</p>

<ul>
<li>Immutable arguments are effectively passed <strong>by value</strong>. Objects such as integers and strings are passed by object reference instead of by copying, but because you cant change immutable objects in place anyhow, the effect is much like making a copy.</li>
<li>Mutable arguments are effectively passed <strong>by pointer</strong>. Objects such as lists
and dictionaries are also passed by object reference, which is similar to the way C
passes arrays as pointersmutable objects can be changed in place in the function,
much like C arrays.</li>
</ul>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In this case the variable titled <code>var</code> in the method <code>Change</code> is assigned a reference to <code>self.variable</code>, and you immediately assign a string to <code>var</code>. It's no longer pointing to <code>self.variable</code>. The following code snippet shows what would happen if you modify the data structure pointed to by <code>var</code> and <code>self.variable</code>, in this case a list:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">PassByReference</span>:
<span class="hljs-meta">... </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
<span class="hljs-meta">... </span>        self.variable = [<span class="hljs-string">'Original'</span>]
<span class="hljs-meta">... </span>        self.change(self.variable)
<span class="hljs-meta">... </span>        <span class="hljs-built_in">print</span> self.variable
<span class="hljs-meta">... </span>        
<span class="hljs-meta">... </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">change</span>(<span class="hljs-params">self, var</span>):
<span class="hljs-meta">... </span>        var.append(<span class="hljs-string">'Changed'</span>)
<span class="hljs-meta">... </span>
<span class="hljs-meta">&gt;&gt;&gt; </span>q = PassByReference()
[<span class="hljs-string">'Original'</span>, <span class="hljs-string">'Changed'</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>
</code></pre>

<p>I'm sure someone else could clarify this further.</p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A lot of insights in answers here, but i think an additional point is not clearly mentioned here explicitly.   Quoting from python documentation <a href="https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python" rel="noreferrer">https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python</a>  </p>

<p>"In Python, variables that are only referenced inside a function are implicitly global. If a variable is assigned a new value anywhere within the functions body, its assumed to be a local. If a variable is ever assigned a new value inside the function, the variable is implicitly local, and you need to explicitly declare it as global.
Though a bit surprising at first, a moments consideration explains this. On one hand, requiring global for assigned variables provides a bar against unintended side-effects. On the other hand, if global was required for all global references, youd be using global all the time. Youd have to declare as global every reference to a built-in function or to a component of an imported module. This clutter would defeat the usefulness of the global declaration for identifying side-effects."</p>

<p>Even when passing a mutable object to a function this still applies. And to me clearly explains the reason for the difference in behavior between assigning to the object and operating on the object in the function.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">l</span>):
    <span class="hljs-built_in">print</span> <span class="hljs-string">"Received"</span>, l , <span class="hljs-built_in">id</span>(l)
    l = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]
    <span class="hljs-built_in">print</span> <span class="hljs-string">"Changed to"</span>, l, <span class="hljs-built_in">id</span>(l)  <span class="hljs-comment"># New local object created, breaking link to global l</span>

l= [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
<span class="hljs-built_in">print</span> <span class="hljs-string">"Original"</span>, l, <span class="hljs-built_in">id</span>(l)
test(l)
<span class="hljs-built_in">print</span> <span class="hljs-string">"After"</span>, l, <span class="hljs-built_in">id</span>(l)
</code></pre>

<p>gives:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">Original [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-number">4454645632</span>
Received [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-number">4454645632</span>
Changed to [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>] <span class="hljs-number">4474591928</span>
After [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-number">4454645632</span>
</code></pre>

<p>The assignment to an global variable that is not declared global therefore creates a new local object and breaks the link to the original object.</p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As you can state you need to have a mutable object, but let me suggest you to check over the global variables as they can help you or even solve this kind of issue!</p>

<p><a href="http://docs.python.org/3/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python" rel="noreferrer">http://docs.python.org/3/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python</a></p>

<p>example:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">x</span>(<span class="hljs-params">y</span>):
<span class="hljs-meta">... </span>    <span class="hljs-keyword">global</span> z
<span class="hljs-meta">... </span>    z = y
...

<span class="hljs-meta">&gt;&gt;&gt; </span>x
&lt;function x at <span class="hljs-number">0x00000000020E1730</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>y
Traceback (most recent call last):
  File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
NameError: name <span class="hljs-string">'y'</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> defined
<span class="hljs-meta">&gt;&gt;&gt; </span>z
Traceback (most recent call last):
  File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
NameError: name <span class="hljs-string">'z'</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> defined

<span class="hljs-meta">&gt;&gt;&gt; </span>x(<span class="hljs-number">2</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>x
&lt;function x at <span class="hljs-number">0x00000000020E1730</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>y
Traceback (most recent call last):
  File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
NameError: name <span class="hljs-string">'y'</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> defined
<span class="hljs-meta">&gt;&gt;&gt; </span>z
<span class="hljs-number">2</span>
</code></pre>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is the simple (I hope) explanation of the concept <code>pass by object</code> used in Python.<br>
Whenever you pass an object to the function, the object itself is passed (object in Python is actually what you'd call a value in other programming languages) not the reference to this object. In other words, when you call:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">change_me</span>(<span class="hljs-params"><span class="hljs-built_in">list</span></span>):
   <span class="hljs-built_in">list</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]

my_list = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]
change_me(my_list)
</code></pre>

<p>The actual object - [0, 1] (which would be called a value in other programming languages) is being passed. So in fact the function <code>change_me</code> will try to do something like:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
</code></pre>

<p>which obviously will not change the object passed to the function. If the function looked like this:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">change_me</span>(<span class="hljs-params"><span class="hljs-built_in">list</span></span>):
   <span class="hljs-built_in">list</span>.append(<span class="hljs-number">2</span>)
</code></pre>

<p>Then the call would result in:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>].append(<span class="hljs-number">2</span>)
</code></pre>

<p>which obviously will change the object. <a href="https://stackoverflow.com/a/534509/831531">This answer</a> explains it well.</p>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Aside from all the great explanations on how this stuff works in Python, I don't see a simple suggestion for the problem. As you seem to do create objects and instances, the pythonic way of handling instance variables and changing them is the following:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PassByReference</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        self.variable = <span class="hljs-string">'Original'</span>
        self.Change()
        <span class="hljs-built_in">print</span> self.variable

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">Change</span>(<span class="hljs-params">self</span>):
        self.variable = <span class="hljs-string">'Changed'</span>
</code></pre>

<p>In instance methods, you normally refer to <code>self</code> to access instance attributes. It is normal to set instance attributes in <code>__init__</code> and read or change them in instance methods. That is also why you pass <code>self</code> als the first argument to <code>def Change</code>.</p>

<p>Another solution would be to create a static method like this:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PassByReference</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        self.variable = <span class="hljs-string">'Original'</span>
        self.variable = PassByReference.Change(self.variable)
        <span class="hljs-built_in">print</span> self.variable

<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">Change</span>(<span class="hljs-params">var</span>):
        var = <span class="hljs-string">'Changed'</span>
        <span class="hljs-keyword">return</span> var
</code></pre>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 18</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I used the following method to quickly convert a couple of Fortran codes to Python.  True, it's not pass by reference as the original question was posed, but is a simple work around in some cases.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">a=<span class="hljs-number">0</span>
b=<span class="hljs-number">0</span>
c=<span class="hljs-number">0</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">myfunc</span>(<span class="hljs-params">a,b,c</span>):
    a=<span class="hljs-number">1</span>
    b=<span class="hljs-number">2</span>
    c=<span class="hljs-number">3</span>
    <span class="hljs-keyword">return</span> a,b,c

a,b,c = myfunc(a,b,c)
<span class="hljs-built_in">print</span> a,b,c
</code></pre>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 19</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There is a little trick to pass an object by reference, even though the language doesn't make it possible. It works in Java too, it's the list with one item. ;-)</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PassByReference</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):
        self.name = name

<span class="hljs-keyword">def</span> <span class="hljs-title function_">changeRef</span>(<span class="hljs-params">ref</span>):
    ref[<span class="hljs-number">0</span>] = PassByReference(<span class="hljs-string">'Michael'</span>)

obj = PassByReference(<span class="hljs-string">'Peter'</span>)
<span class="hljs-built_in">print</span> obj.name

p = [obj] <span class="hljs-comment"># A pointer to obj! ;-)</span>
changeRef(p)

<span class="hljs-built_in">print</span> p[<span class="hljs-number">0</span>].name <span class="hljs-comment"># p-&gt;name</span>
</code></pre>

<p>It's an ugly hack, but it works. ;-P</p>
    </div></div></div></div><div id="solution20" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 20</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>given the way python handles values and references to them, the only way you can reference an arbitrary instance attribute is by name:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PassByReferenceIsh</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        self.variable = <span class="hljs-string">'Original'</span>
        self.change(<span class="hljs-string">'variable'</span>)
        <span class="hljs-built_in">print</span> self.variable

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">change</span>(<span class="hljs-params">self, var</span>):
        self.__dict__[var] = <span class="hljs-string">'Changed'</span>
</code></pre>

<p>in real code you would, of course, add error checking on the dict lookup.</p>
    </div></div></div></div><div id="solution21" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 21</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Since your example happens to be object-oriented, you could make the following change to achieve a similar result:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PassByReference</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        self.variable = <span class="hljs-string">'Original'</span>
        self.change(<span class="hljs-string">'variable'</span>)
        <span class="hljs-built_in">print</span>(self.variable)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">change</span>(<span class="hljs-params">self, var</span>):
        <span class="hljs-built_in">setattr</span>(self, var, <span class="hljs-string">'Changed'</span>)

<span class="hljs-comment"># o.variable will equal 'Changed'</span>
o = PassByReference()
<span class="hljs-keyword">assert</span> o.variable == <span class="hljs-string">'Changed'</span>
</code></pre>
    </div></div></div></div><div id="solution22" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 22</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Since it seems to be nowhere mentioned an approach to simulate references as known from e.g. C++ is to use an "update" function and pass that instead of the actual variable (or rather, "name"):</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">need_to_modify</span>(<span class="hljs-params">update</span>):
    update(<span class="hljs-number">42</span>) <span class="hljs-comment"># set new value 42</span>
    <span class="hljs-comment"># other code</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">call_it</span>():
    value = <span class="hljs-number">21</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update_value</span>(<span class="hljs-params">new_value</span>):
        <span class="hljs-keyword">nonlocal</span> value
        value = new_value
    need_to_modify(update_value)
    <span class="hljs-built_in">print</span>(value) <span class="hljs-comment"># prints 42</span>
</code></pre>

<p>This is mostly useful for "out-only references" or in a situation with multiple threads / processes (by making the update function thread / multiprocessing safe).</p>

<p>Obviously the above does not allow <em>reading</em> the value, only updating it.</p>
    </div></div></div></div><div id="solution23" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 23</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Since dictionaries are passed by reference, you can use a dict variable to store any referenced values inside it.</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment"># returns the result of adding numbers `a` and `b`</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">AddNumbers</span>(<span class="hljs-params">a, b, ref</span>): <span class="hljs-comment"># using a dict for reference</span>
    result = a + b
    ref[<span class="hljs-string">'multi'</span>] = a * b <span class="hljs-comment"># reference the multi. ref['multi'] is number</span>
    ref[<span class="hljs-string">'msg'</span>] = <span class="hljs-string">"The result: "</span> + <span class="hljs-built_in">str</span>(result) + <span class="hljs-string">" was nice!"</span>
    <span class="hljs-keyword">return</span> result

number1 = <span class="hljs-number">5</span>
number2 = <span class="hljs-number">10</span>
ref = {} <span class="hljs-comment"># init a dict like that so it can save all the referenced values. this is because all dictionaries are passed by reference, while strings and numbers do not.</span>

<span class="hljs-built_in">sum</span> = AddNumbers(number1, number2, ref)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"sum: "</span>, <span class="hljs-built_in">sum</span>)             <span class="hljs-comment"># the returned value</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"multi: "</span>, ref[<span class="hljs-string">'multi'</span>])  <span class="hljs-comment"># a referenced value</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"msg: "</span>, ref[<span class="hljs-string">'msg'</span>])      <span class="hljs-comment"># a referenced value</span>
</code></pre>
    </div></div></div></div><div id="solution24" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 24</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>While pass by reference is nothing that fits well into python and should be rarely used there are some workarounds that actually can work to get the object currently assigned to a local variable or even reassign a local variable from inside of a called function.</p>

<p>The basic idea is to have a function that can do that access and can be passed as object into other functions or stored in a class.</p>

<p>One way is to use <code>global</code> (for global variables) or <code>nonlocal</code> (for local variables in a function) in a wrapper function.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">change</span>(<span class="hljs-params">wrapper</span>):
    wrapper(<span class="hljs-number">7</span>)

x = <span class="hljs-number">5</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">setter</span>(<span class="hljs-params">val</span>):
    <span class="hljs-keyword">global</span> x
    x = val
<span class="hljs-built_in">print</span>(x)
</code></pre>

<p>The same idea works for reading and <code>del</code>eting a variable.</p>

<p>For just reading there is even a shorter way of just using <code>lambda: x</code> which returns a callable that when called returns the current value of x. This is somewhat like "call by name" used in languages in the distant past.</p>

<p>Passing 3 wrappers to access a variable is a bit unwieldy so those can be wrapped into a class that has a proxy attribute:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ByRef</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, r, w, d</span>):
        self._read = r
        self._write = w
        self._delete = d
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set</span>(<span class="hljs-params">self, val</span>):
        self._write(val)
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self._read()
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self</span>):
        self._delete()
    wrapped = <span class="hljs-built_in">property</span>(get, <span class="hljs-built_in">set</span>, remove)

<span class="hljs-comment"># left as an exercise for the reader: define set, get, remove as local functions using global / nonlocal</span>
r = ByRef(get, <span class="hljs-built_in">set</span>, remove)
r.wrapped = <span class="hljs-number">15</span>
</code></pre>

<p>Pythons "reflection" support makes it possible to get a object that is capable of reassigning a name/variable in a given scope without defining functions explicitly in that scope:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ByRef</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, locs, name</span>):
        self._locs = locs
        self._name = name
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set</span>(<span class="hljs-params">self, val</span>):
        self._locs[self._name] = val
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self._locs[self._name]
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">del</span> self._locs[self._name]
    wrapped = <span class="hljs-built_in">property</span>(get, <span class="hljs-built_in">set</span>, remove)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">change</span>(<span class="hljs-params">x</span>):
    x.wrapped = <span class="hljs-number">7</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">test_me</span>():
    x = <span class="hljs-number">6</span>
    <span class="hljs-built_in">print</span>(x)
    change(ByRef(<span class="hljs-built_in">locals</span>(), <span class="hljs-string">"x"</span>))
    <span class="hljs-built_in">print</span>(x)
</code></pre>

<p>Here the <code>ByRef</code> class wraps a dictionary access. So attribute access to <code>wrapped</code> is translated to a item access in the passed dictionary. By passing the result of the builtin <code>locals</code> and the name of a local variable this ends up accessing a local variable. The python documentation as of 3.5 advises that changing the dictionary might not work but it seems to work for me.</p>
    </div></div></div></div><div id="solution25" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 25</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You can merely use <strong>an empty class</strong> as an instance to store reference objects because internally object attributes are stored in an instance dictionary. See the example.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RefsObj</span>(<span class="hljs-title class_ inherited__">object</span>):
    <span class="hljs-string">"A class which helps to create references to variables."</span>
    <span class="hljs-keyword">pass</span>

...

<span class="hljs-comment"># an example of usage</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">change_ref_var</span>(<span class="hljs-params">ref_obj</span>):
    ref_obj.val = <span class="hljs-number">24</span>

ref_obj = RefsObj()
ref_obj.val = <span class="hljs-number">1</span>
<span class="hljs-built_in">print</span>(ref_obj.val) <span class="hljs-comment"># or print ref_obj.val for python2</span>
change_ref_var(ref_obj)
<span class="hljs-built_in">print</span>(ref_obj.val)
</code></pre>
    </div></div></div></div><div id="solution26" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 26</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Pass-By-Reference in Python is quite different from the concept of pass by reference in C++/Java. </p>

<ul>
<li><strong>Java&amp;C#:</strong> primitive types(include string)pass by value(copy), Reference type is passed by reference(address copy) so all changes made in the parameter in the called function are visible to the caller.</li>
<li><strong>C++:</strong> Both pass-by-reference or pass-by-value are allowed. If a parameter is passed by reference, you can either modify it or not depending upon whether the parameter was passed as const or not. However, const or not, the parameter maintains the reference to the object and reference cannot be assigned to point to a different object within the called function.</li>
<li><strong>Python:</strong> 
Python is pass-by-object-reference, of which it is often said: Object references are passed by value.[Read here]<a href="https://robertheaton.com/2014/02/09/pythons-pass-by-object-reference-as-explained-by-philip-k-dick/" rel="nofollow noreferrer">1</a>. Both the caller and the function refer to the same object but the parameter in the function is a new variable which is just holding a copy of the object in the caller. Like C++, a parameter can be either modified or not in function - This depends upon the type of object passed. eg; An immutable object type cannot be modified in the called function whereas a mutable object can be either updated or re-initialized. A crucial difference between updating or re-assigning/re-initializing the mutable variable is that updated value gets reflected back in the called function whereas the reinitialized value does not. Scope of any assignment of new object to a mutable variable is local to the function in the python. Examples provided by @blair-conrad are great to understand this.</li>
</ul>
    </div></div></div></div><div id="solution27" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 27</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I am new to Python, started yesterday (though I have been programming for 45 years).</p>
<p>I came here because I was writing a function where I wanted to have two so called out-parameters. If it would have been only one out-parameter, I wouldn't get hung up right now on checking how reference/value works in Python. I would just have used the return value of the function instead. But since I needed <em>two</em> such out-parameters I felt I needed to sort it out.</p>
<p>In this post I am going to show how I solved my situation. Perhaps others coming here can find it valuable, even though it is not exactly an answer to the topic question. Experienced Python programmers of course already know about the solution I used, but it was new to me.</p>
<p>From the answers here I could quickly see that Python works a bit like Javascript in this regard, and that you need to use workarounds if you want the reference functionality.</p>
<p>But then I found something neat in Python that I don't think I have seen in other languages before, namely that you can return more than one value from a function, in a simple comma separated way, like this:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">somefunction</span>(<span class="hljs-params">p</span>):
    a=p+<span class="hljs-number">1</span>
    b=p+<span class="hljs-number">2</span>
    c=-p
    <span class="hljs-keyword">return</span> a, b, c
</code></pre>
<p>and that you can handle that on the calling side similarly, like this</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">x, y, z = somefunction(w)
</code></pre>
<p>That was good enough for me and I was satisfied. No need to use some workaround.</p>
<p>In other languages you can of course also return many values, but then usually in the from of an object, and you need to adjust the calling side accordingly.</p>
<p>The Python way of doing it was nice and simple.</p>
<p>If you want to mimic <em>by reference</em> even more, you could do as follows:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">somefunction</span>(<span class="hljs-params">a, b, c</span>):
    a = a * <span class="hljs-number">2</span>
    b = b + a
    c = a * b * c
    <span class="hljs-keyword">return</span> a, b, c

x = <span class="hljs-number">3</span>
y = <span class="hljs-number">5</span>
z = <span class="hljs-number">10</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">F"Before : <span class="hljs-subst">{x}</span>, <span class="hljs-subst">{y}</span>, <span class="hljs-subst">{z}</span>"</span>)

x, y, z = somefunction(x, y, z)

<span class="hljs-built_in">print</span>(<span class="hljs-string">F"After  : <span class="hljs-subst">{x}</span>, <span class="hljs-subst">{y}</span>, <span class="hljs-subst">{z}</span>"</span>)
</code></pre>
<p>which gives this result</p>
<pre>Before : 3, 5, 10  
After  : 6, 11, 660  
</pre>
    </div></div></div></div><div id="solution28" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 28</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>alternatively you could use ctypes witch would look something like this</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> ctypes

<span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">a</span>):
    a.value=<span class="hljs-number">2398</span> <span class="hljs-comment">## resign the value in a function</span>

a = ctypes.c_int(<span class="hljs-number">0</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"pre f"</span>, a)
f(a)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"post f"</span>, a)
</code></pre>
<p>as a is a c int and not a python integer and apperently passed by reference. however you have to be carefull as strange things could happen and is therefor not advised</p>
    </div></div></div></div><div id="solution29" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 29</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Most likely not the most reliable method but this works, keep in mind that you are overloading the built-in str function which is typically something you don't want to do:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> builtins

<span class="hljs-keyword">class</span> <span class="hljs-title class_">sstr</span>(<span class="hljs-title class_ inherited__">str</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(self, <span class="hljs-string">'changed'</span>):
            <span class="hljs-keyword">return</span> self.changed

        <span class="hljs-keyword">return</span> self

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">change</span>(<span class="hljs-params">self, value</span>):
        self.changed = value

builtins.<span class="hljs-built_in">str</span> = sstr

<span class="hljs-keyword">def</span> <span class="hljs-title function_">change_the_value</span>(<span class="hljs-params">val</span>):
    val.change(<span class="hljs-string">'After'</span>)

val = <span class="hljs-built_in">str</span>(<span class="hljs-string">'Before'</span>)
<span class="hljs-built_in">print</span> (val)
change_the_value(val)
<span class="hljs-built_in">print</span> (val)
</code></pre>
    </div></div></div></div><div id="solution30" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 30</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>What about <a href="https://docs.python.org/3/library/dataclasses.html" rel="nofollow noreferrer">dataclasses</a>? Also, it allows you to apply type restriction (aka "type hint").</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">from</span> dataclasses <span class="hljs-keyword">import</span> dataclass

<span class="hljs-meta">@dataclass</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Holder</span>:
    obj: your_type <span class="hljs-comment"># Need any type? Use "obj: object" then.</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">ref: Holder</span>):
    ref.obj = do_something()
</code></pre>
<p>I agree with folks that in most cases you'd better consider not to use it.</p>
<p>And yet, when we're talking about <a href="https://en.wikipedia.org/wiki/State_pattern" rel="nofollow noreferrer"><em>contexts</em></a> it's worth to know that way.</p>
<p>You can design explicit context class though. When prototyping I prefer dataclasses, just because it's easy to serialize them back and forth.</p>
<p>Cheers!</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/what-is-a-clearfix-1657387337825">What is a clearfix?</a><a href="/questions/what-is-the-difference-between-%22px%22-%22dip%22-%22dp%22-and-%22sp%22-1657388093250">What is the difference between &quot;px&quot;, &quot;dip&quot;, &quot;dp&quot; and &quot;sp&quot;?</a><a href="/questions/how-can-i-remove-a-specific-item-from-an-array-1657387552077">How can I remove a specific item from an array?</a><a href="/questions/randomize-a-listlesstgreater-1657388172793">Randomize a List&lt;T&gt;</a><a href="/questions/how-do-i-add-a-delay-in-a-javascript-loop-1657388544679">How do I add a delay in a JavaScript loop?</a><a href="/questions/string.equals-versus-duplicate-1657387599972">String.equals versus == [duplicate]</a><a href="/questions/are-&#x27;arrow-functions&#x27;-and-&#x27;functions&#x27;-equivalent-interchangeable-1657384527873">Are &#x27;Arrow Functions&#x27; and &#x27;Functions&#x27; equivalent / interchangeable?</a><a href="/questions/jquery-dollar-is-not-defined-1657388385731">JQuery - $ is not defined</a><a href="/questions/%22cross-origin-requests-are-only-supported-for-http.%22-error-when-loading-a-local-file-1657387942403">&quot;Cross origin requests are only supported for HTTP.&quot; error when loading a local file</a><a href="/questions/why-is-the-gets-function-so-dangerous-that-it-should-not-be-used-1657384544362">Why is the gets function so dangerous that it should not be used?</a><a href="/questions/how-do-javascript-closures-work-1657384418555">How do JavaScript closures work?</a><a href="/questions/why-does-spring-mvc-respond-with-a-404-and-report-%22no-mapping-found-for-http-request-with-uri-...-in-dispatcherservlet%22-1657387995250">Why does Spring MVC respond with a 404 and report &quot;No mapping found for HTTP request with URI [...] in DispatcherServlet&quot;?</a><a href="/questions/transpose-reshape-dataframe-without-%22timevar%22-from-long-to-wide-format-1657388213347">Transpose / reshape dataframe without &quot;timevar&quot; from long to wide format</a><a href="/questions/xmlhttprequest-cannot-load-xxx-no-&#x27;access-control-allow-origin&#x27;-header-1657384758362">XMLHttpRequest cannot load XXX No &#x27;Access-Control-Allow-Origin&#x27; header</a><a href="/questions/what-is-an-undefined-referenceunresolved-external-symbol-error-and-how-do-i-fix-it-1657384255179">What is an undefined reference/unresolved external symbol error and how do I fix it?</a><a href="/questions/why-does-my-recursive-function-return-none-1657387792894">Why does my recursive function return None?</a><a href="/questions/what-is-the-(function()-)()-construct-in-javascript-1657385508348">What is the (function() { } )() construct in JavaScript?</a><a href="/questions/how-do-i-use-extern-to-share-variables-between-source-files-1657387453605">How do I use extern to share variables between source files?</a><a href="/questions/how-do-i-format-a-date-in-javascript-1657384649498">How do I format a date in JavaScript?</a><a href="/questions/how-do-i-use-shell-variables-in-an-awk-script-1657387754261">How do I use shell variables in an awk script?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;Arguments are \u0026lt;a href=\u0026quot;http://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;passed by assignment\u0026lt;/a\u0026gt;. The rationale behind this is twofold:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;the parameter passed in is actually a \u0026lt;em\u0026gt;reference\u0026lt;/em\u0026gt; to an object (but the reference is passed by value)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;some data types are mutable, but others aren\u0026apos;t\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;So:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If you pass a \u0026lt;em\u0026gt;mutable\u0026lt;/em\u0026gt; object into a method, the method gets a reference to that same object and you can mutate it to your heart\u0026apos;s delight, but if you rebind the reference in the method, the outer scope will know nothing about it, and after you\u0026apos;re done, the outer reference will still point at the original object. \u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If you pass an \u0026lt;em\u0026gt;immutable\u0026lt;/em\u0026gt; object to a method, you still can\u0026apos;t rebind the outer reference, and you can\u0026apos;t even mutate the object.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;To make it even more clear, let\u0026apos;s have some examples. \u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;List - a mutable type\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Let\u0026apos;s try to modify the list that was passed to a method:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;try_to_change_list_contents\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;the_list\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;got\u0026apos;\u0026lt;/span\u0026gt;, the_list)\n    the_list.append(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;four\u0026apos;\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;changed to\u0026apos;\u0026lt;/span\u0026gt;, the_list)\n\nouter_list = [\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;one\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;two\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;three\u0026apos;\u0026lt;/span\u0026gt;]\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;before, outer_list =\u0026apos;\u0026lt;/span\u0026gt;, outer_list)\ntry_to_change_list_contents(outer_list)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;after, outer_list =\u0026apos;\u0026lt;/span\u0026gt;, outer_list)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Output:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-none s-code-block\u0026quot;\u0026gt;\u0026lt;code\u0026gt;before, outer_list = [\u0026apos;one\u0026apos;, \u0026apos;two\u0026apos;, \u0026apos;three\u0026apos;]\ngot [\u0026apos;one\u0026apos;, \u0026apos;two\u0026apos;, \u0026apos;three\u0026apos;]\nchanged to [\u0026apos;one\u0026apos;, \u0026apos;two\u0026apos;, \u0026apos;three\u0026apos;, \u0026apos;four\u0026apos;]\nafter, outer_list = [\u0026apos;one\u0026apos;, \u0026apos;two\u0026apos;, \u0026apos;three\u0026apos;, \u0026apos;four\u0026apos;]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Since the parameter passed in is a reference to \u0026lt;code\u0026gt;outer_list\u0026lt;/code\u0026gt;, not a copy of it, we can use the mutating list methods to change it and have the changes reflected in the outer scope.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Now let\u0026apos;s see what happens when we try to change the reference that was passed in as a parameter:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;try_to_change_list_reference\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;the_list\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;got\u0026apos;\u0026lt;/span\u0026gt;, the_list)\n    the_list = [\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;and\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;we\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;can\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;not\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;lie\u0026apos;\u0026lt;/span\u0026gt;]\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;set to\u0026apos;\u0026lt;/span\u0026gt;, the_list)\n\nouter_list = [\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;we\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;like\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;proper\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;English\u0026apos;\u0026lt;/span\u0026gt;]\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;before, outer_list =\u0026apos;\u0026lt;/span\u0026gt;, outer_list)\ntry_to_change_list_reference(outer_list)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;after, outer_list =\u0026apos;\u0026lt;/span\u0026gt;, outer_list)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Output:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-none s-code-block\u0026quot;\u0026gt;\u0026lt;code\u0026gt;before, outer_list = [\u0026apos;we\u0026apos;, \u0026apos;like\u0026apos;, \u0026apos;proper\u0026apos;, \u0026apos;English\u0026apos;]\ngot [\u0026apos;we\u0026apos;, \u0026apos;like\u0026apos;, \u0026apos;proper\u0026apos;, \u0026apos;English\u0026apos;]\nset to [\u0026apos;and\u0026apos;, \u0026apos;we\u0026apos;, \u0026apos;can\u0026apos;, \u0026apos;not\u0026apos;, \u0026apos;lie\u0026apos;]\nafter, outer_list = [\u0026apos;we\u0026apos;, \u0026apos;like\u0026apos;, \u0026apos;proper\u0026apos;, \u0026apos;English\u0026apos;]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Since the \u0026lt;code\u0026gt;the_list\u0026lt;/code\u0026gt; parameter was passed by value, assigning a new list to it had no effect that the code outside the method could see. The \u0026lt;code\u0026gt;the_list\u0026lt;/code\u0026gt; was a copy of the \u0026lt;code\u0026gt;outer_list\u0026lt;/code\u0026gt; reference, and we had \u0026lt;code\u0026gt;the_list\u0026lt;/code\u0026gt; point to a new list, but there was no way to change where \u0026lt;code\u0026gt;outer_list\u0026lt;/code\u0026gt; pointed.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;String - an immutable type\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;It\u0026apos;s immutable, so there\u0026apos;s nothing we can do to change the contents of the string\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Now, let\u0026apos;s try to change the reference\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;try_to_change_string_reference\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;the_string\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;got\u0026apos;\u0026lt;/span\u0026gt;, the_string)\n    the_string = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;In a kingdom by the sea\u0026apos;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;set to\u0026apos;\u0026lt;/span\u0026gt;, the_string)\n\nouter_string = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;It was many and many a year ago\u0026apos;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;before, outer_string =\u0026apos;\u0026lt;/span\u0026gt;, outer_string)\ntry_to_change_string_reference(outer_string)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;after, outer_string =\u0026apos;\u0026lt;/span\u0026gt;, outer_string)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Output:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-none s-code-block\u0026quot;\u0026gt;\u0026lt;code\u0026gt;before, outer_string = It was many and many a year ago\ngot It was many and many a year ago\nset to In a kingdom by the sea\nafter, outer_string = It was many and many a year ago\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Again, since the \u0026lt;code\u0026gt;the_string\u0026lt;/code\u0026gt; parameter was passed by value, assigning a new string to it had no effect that the code outside the method could see. The \u0026lt;code\u0026gt;the_string\u0026lt;/code\u0026gt; was a copy of the \u0026lt;code\u0026gt;outer_string\u0026lt;/code\u0026gt; reference, and we had \u0026lt;code\u0026gt;the_string\u0026lt;/code\u0026gt; point to a new string, but there was no way to change where \u0026lt;code\u0026gt;outer_string\u0026lt;/code\u0026gt; pointed.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I hope this clears things up a little.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;EDIT:\u0026lt;/strong\u0026gt; It\u0026apos;s been noted that this doesn\u0026apos;t answer the question that @David originally asked, \u0026quot;Is there something I can do to pass the variable by actual reference?\u0026quot;. Let\u0026apos;s work on that.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;How do we get around this?\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;As @Andrea\u0026apos;s answer shows, you could return the new value. This doesn\u0026apos;t change the way things are passed in, but does let you get the information you want back out:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;return_a_whole_new_string\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;the_string\u0026lt;/span\u0026gt;):\n    new_string = something_to_do_with_the_old_string(the_string)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; new_string\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# then you could call it like\u0026lt;/span\u0026gt;\nmy_string = return_a_whole_new_string(my_string)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If you really wanted to avoid using a return value, you could create a class to hold your value and pass it into the function or use an existing class, like a list:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;use_a_wrapper_to_simulate_pass_by_reference\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;stuff_to_change\u0026lt;/span\u0026gt;):\n    new_string = something_to_do_with_the_old_string(stuff_to_change[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;])\n    stuff_to_change[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = new_string\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# then you could call it like\u0026lt;/span\u0026gt;\nwrapper = [my_string]\nuse_a_wrapper_to_simulate_pass_by_reference(wrapper)\n\ndo_something_with(wrapper[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;])\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Although this seems a little cumbersome.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The problem comes from a misunderstanding of what variables are in Python. If you\u0026apos;re used to most traditional languages, you have a mental model of what happens in the following sequence:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\na = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You believe that \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is a memory location that stores the value \u0026lt;code\u0026gt;1\u0026lt;/code\u0026gt;, then is updated to store the value \u0026lt;code\u0026gt;2\u0026lt;/code\u0026gt;. That\u0026apos;s not how things work in Python. Rather, \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; starts as a reference to an object with the value \u0026lt;code\u0026gt;1\u0026lt;/code\u0026gt;, then gets reassigned as a reference to an object with the value \u0026lt;code\u0026gt;2\u0026lt;/code\u0026gt;. Those two objects may continue to coexist even though \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; doesn\u0026apos;t refer to the first one anymore; in fact they may be shared by any number of other references within the program.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When you call a function with a parameter, a new reference is created that refers to the object passed in. This is separate from the reference that was used in the function call, so there\u0026apos;s no way to update that reference and make it refer to a new object. In your example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__init__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n    self.variable = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Original\u0026apos;\u0026lt;/span\u0026gt;\n    self.Change(self.variable)\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Change\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, var\u0026lt;/span\u0026gt;):\n    var = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Changed\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;self.variable\u0026lt;/code\u0026gt; is a reference to the string object \u0026lt;code\u0026gt;\u0026apos;Original\u0026apos;\u0026lt;/code\u0026gt;. When you call \u0026lt;code\u0026gt;Change\u0026lt;/code\u0026gt; you create a second reference \u0026lt;code\u0026gt;var\u0026lt;/code\u0026gt; to the object. Inside the function you reassign the reference \u0026lt;code\u0026gt;var\u0026lt;/code\u0026gt; to a different string object \u0026lt;code\u0026gt;\u0026apos;Changed\u0026apos;\u0026lt;/code\u0026gt;, but the reference \u0026lt;code\u0026gt;self.variable\u0026lt;/code\u0026gt; is separate and does not change.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The only way around this is to pass a mutable object. Because both references refer to the same object, any changes to the object are reflected in both places.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__init__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):         \n    self.variable = [\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Original\u0026apos;\u0026lt;/span\u0026gt;]\n    self.Change(self.variable)\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Change\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, var\u0026lt;/span\u0026gt;):\n    var[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Changed\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I found the other answers rather long and complicated, so I created this simple diagram to explain the way Python treats variables and parameters.\n\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/FdaCu.png\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/FdaCu.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It is neither pass-by-value or pass-by-reference - it is call-by-object. See this, by Fredrik Lundh:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://web.archive.org/web/20201111195827/http://www.effbot.org/zone/call-by-object.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://effbot.org/zone/call-by-object.htm\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Here is a significant quote:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026quot;...variables [names] are \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; objects; they cannot be denoted by other variables or referred to by objects.\u0026quot;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;In your example, when the \u0026lt;code\u0026gt;Change\u0026lt;/code\u0026gt; method is called--a \u0026lt;a href=\u0026quot;http://docs.python.org/2/tutorial/classes.html#python-scopes-and-namespaces\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;namespace\u0026lt;/a\u0026gt; is created for it; and \u0026lt;code\u0026gt;var\u0026lt;/code\u0026gt; becomes a name, within that namespace, for the string object \u0026lt;code\u0026gt;\u0026apos;Original\u0026apos;\u0026lt;/code\u0026gt;. That object then has a name in two namespaces. Next, \u0026lt;code\u0026gt;var = \u0026apos;Changed\u0026apos;\u0026lt;/code\u0026gt; binds \u0026lt;code\u0026gt;var\u0026lt;/code\u0026gt; to a new string object, and thus the method\u0026apos;s namespace forgets about \u0026lt;code\u0026gt;\u0026apos;Original\u0026apos;\u0026lt;/code\u0026gt;. Finally, that namespace is forgotten, and the string \u0026lt;code\u0026gt;\u0026apos;Changed\u0026apos;\u0026lt;/code\u0026gt; along with it.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Think of stuff being passed \u0026lt;strong\u0026gt;by assignment\u0026lt;/strong\u0026gt; instead of by reference/by value. That way, it is always clear, what is happening as long as you understand what happens during the normal assignment.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So, when passing a list to a function/method, the list is assigned to the parameter name. Appending to the list will result in the list being modified. Reassigning the list \u0026lt;em\u0026gt;inside\u0026lt;/em\u0026gt; the function will not change the original list, since:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;a = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;]\nb = a\nb.append(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;)\nb = [\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; a, b      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# prints [1, 2, 3, 4] [\u0026apos;a\u0026apos;, \u0026apos;b\u0026apos;]\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Since immutable types cannot be modified, they \u0026lt;em\u0026gt;seem\u0026lt;/em\u0026gt; like being passed by value - passing an int into a function means assigning the int to the function\u0026apos;s parameter. You can only ever reassign that, but it won\u0026apos;t change the original variables value.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;There are no variables in Python\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;The key to understanding parameter passing is to stop thinking about \u0026quot;variables\u0026quot;. There are names and objects in Python and together they\nappear like variables, but it is useful to always distinguish the three.\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Python has names and objects.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Assignment binds a name to an object.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Passing an argument into a function also binds a name (the parameter name of the function) to an object.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;That is all there is to it. Mutability is irrelevant to this question.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This binds the name \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; to an object of type integer that holds the value 1.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;b = x\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This binds the name \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; to the same object that the name \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; is currently bound to.\nAfterward, the name \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; has nothing to do with the name \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; anymore.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;See sections \u0026lt;a href=\u0026quot;https://docs.python.org/3/reference/datamodel.html#objects-values-and-types\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;3.1\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;https://docs.python.org/3/reference/executionmodel.html#naming-and-binding\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;4.2\u0026lt;/a\u0026gt; in the Python 3 language reference.\u0026lt;/p\u0026gt;\n\n\u0026lt;h1\u0026gt;How to read the example in the question\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;In the code shown in the question, the statement \u0026lt;code\u0026gt;self.Change(self.variable)\u0026lt;/code\u0026gt; binds the name \u0026lt;code\u0026gt;var\u0026lt;/code\u0026gt; (in the scope of function \u0026lt;code\u0026gt;Change\u0026lt;/code\u0026gt;) to the object that holds the value \u0026lt;code\u0026gt;\u0026apos;Original\u0026apos;\u0026lt;/code\u0026gt; and the assignment \u0026lt;code\u0026gt;var = \u0026apos;Changed\u0026apos;\u0026lt;/code\u0026gt; (in the body of function \u0026lt;code\u0026gt;Change\u0026lt;/code\u0026gt;) assigns that same name again: to some other object (that happens to hold a string as well but could have been something else entirely).\u0026lt;/p\u0026gt;\n\n\u0026lt;h1\u0026gt;How to pass by reference\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;So if the thing you want to change is a mutable object, there is no problem, as everything is effectively passed by reference.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If it is an \u0026lt;a href=\u0026quot;https://docs.python.org/3/reference/datamodel.html#objects-values-and-types\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;immutable\u0026lt;/a\u0026gt; object (e.g. a bool, number, string), the way to go is to wrap it in a mutable object.\u0026lt;br\u0026gt;\nThe quick-and-dirty solution for this is a one-element list (instead of \u0026lt;code\u0026gt;self.variable\u0026lt;/code\u0026gt;, pass \u0026lt;code\u0026gt;[self.variable]\u0026lt;/code\u0026gt; and in the function modify \u0026lt;code\u0026gt;var[0]\u0026lt;/code\u0026gt;).\u0026lt;br\u0026gt;\nThe more \u0026lt;a href=\u0026quot;https://www.python.org/dev/peps/pep-0020/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;pythonic\u0026lt;/a\u0026gt; approach would be to introduce a trivial, one-attribute class. The function receives an instance of the class and manipulates the attribute.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Effbot (aka Fredrik Lundh) has described Python\u0026apos;s variable passing style as call-by-object:  \u0026lt;a href=\u0026quot;http://effbot.org/zone/call-by-object.htm\u0026quot;\u0026gt;http://effbot.org/zone/call-by-object.htm\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Objects are allocated on the heap and pointers to them can be passed around anywhere.  \u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;When you make an assignment such as \u0026lt;code\u0026gt;x = 1000\u0026lt;/code\u0026gt;, a dictionary entry is created that maps the string \u0026quot;x\u0026quot; in the current namespace to a pointer to the integer object containing one thousand.   \u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;When you update \u0026quot;x\u0026quot; with \u0026lt;code\u0026gt;x = 2000\u0026lt;/code\u0026gt;, a new integer object is created and the dictionary is updated to point at the new object.  The old one thousand object is unchanged (and may or may not be alive depending on whether anything else refers to the object).\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;When you do a new assignment such as \u0026lt;code\u0026gt;y = x\u0026lt;/code\u0026gt;, a new dictionary entry \u0026quot;y\u0026quot; is created that points to the same object as the entry for \u0026quot;x\u0026quot;.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Objects like strings and integers are \u0026lt;em\u0026gt;immutable\u0026lt;/em\u0026gt;.  This simply means that there are no methods that can change the object after it has been created.  For example, once the integer object one-thousand is created, it will never change.  Math is done by creating new integer objects.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Objects like lists are \u0026lt;em\u0026gt;mutable\u0026lt;/em\u0026gt;.  This means that the contents of the object can be changed by anything pointing to the object.  For example, \u0026lt;code\u0026gt;x = []; y = x; x.append(10); print y\u0026lt;/code\u0026gt; will print \u0026lt;code\u0026gt;[10]\u0026lt;/code\u0026gt;.  The empty list was created.  Both \u0026quot;x\u0026quot; and \u0026quot;y\u0026quot; point to the same list.  The \u0026lt;em\u0026gt;append\u0026lt;/em\u0026gt; method mutates (updates) the list object (like adding a record to a database) and the result is visible to both \u0026quot;x\u0026quot; and \u0026quot;y\u0026quot; (just as a database update would be visible to every connection to that database).\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Hope that clarifies the issue for you. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Technically, \u0026lt;strong\u0026gt;Python always uses pass by reference values\u0026lt;/strong\u0026gt;. I am going to repeat \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/12438316/1346705\u0026quot;\u0026gt;my other answer\u0026lt;/a\u0026gt; to support my statement.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Python always uses pass-by-reference values. There isn\u0026apos;t any exception. Any variable assignment means copying the reference value. No exception. Any variable is the name bound to the reference value. Always.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can think about a reference value as the address of the target object. The address is automatically dereferenced when used. This way, working with the reference value, it seems you work directly with the target object. But there always is a reference in between, one step more to jump to the target.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here is the example that proves that Python uses passing by reference:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/uzXcP.png\u0026quot; alt=\u0026quot;Illustrated example of passing the argument\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If the argument was passed by value, the outer \u0026lt;code\u0026gt;lst\u0026lt;/code\u0026gt; could not be modified. The green are the target objects (the black is the value stored inside, the red is the object type), the yellow is the memory with the reference value inside -- drawn as the arrow. The blue solid arrow is the reference value that was passed to the function (via the dashed blue arrow path). The ugly dark yellow is the internal dictionary. (It actually could be drawn also as a green ellipse. The colour and the shape only says it is internal.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can use the \u0026lt;a href=\u0026quot;http://docs.python.org/3.3/library/functions.html#id\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;id()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; built-in function to learn what the reference value is (that is, the address of the target object).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In compiled languages, a variable is a memory space that is able to capture the value of the type. In Python, a variable is a name (captured internally as a string) bound to the reference variable that holds the reference value to the target object. The name of the variable is the key in the internal dictionary, the value part of that dictionary item stores the reference value to the target.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Reference values are hidden in Python. There isn\u0026apos;t any explicit user type for storing the reference value. However, you can use a list element (or element in any other suitable container type) as the reference variable, because all containers do store the elements also as references to the target objects. In other words, elements are actually not contained inside the container -- only the references to elements are.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A simple trick I normally use is to just wrap it in a list:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Change\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, var\u0026lt;/span\u0026gt;):\n    var[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Changed\u0026apos;\u0026lt;/span\u0026gt;\n\nvariable = [\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Original\u0026apos;\u0026lt;/span\u0026gt;]\nself.Change(variable)      \n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; variable[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;(Yeah I know this can be inconvenient, but sometimes it is simple enough to do this.)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;(edit - Blair has updated his enormously popular answer so that it is now accurate)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I think it is important to note that the current post with the most votes (by Blair Conrad), while being correct with respect to its result, is misleading and is borderline incorrect based on its definitions.  While there are many languages (like C) that allow the user to either pass by reference or pass by value, Python is not one of them.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;David Cournapeau\u0026apos;s answer points to the real answer and explains why the behavior in Blair Conrad\u0026apos;s post seems to be correct while the definitions are not.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To the extent that Python is pass by value, all languages are pass by value since some piece of data (be it a \u0026quot;value\u0026quot; or a \u0026quot;reference\u0026quot;) must be sent. However, that does not mean that Python is pass by value in the sense that a C programmer would think of it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you want the behavior, Blair Conrad\u0026apos;s answer is fine.  But if you want to know the nuts and bolts of why Python is neither pass by value or pass by reference, read David Cournapeau\u0026apos;s answer.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You got some really good answers here.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;x = [ \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt; ]\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; x  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# 2, 4, 4, 5, 5\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;go\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt; li \u0026lt;/span\u0026gt;) :\n  li = [ \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt; ]  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# re-assigning what li POINTS TO, does not\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# change the value of the ORIGINAL variable x\u0026lt;/span\u0026gt;\n\ngo( x ) \n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; x  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# 2, 4, 4, 5, 5  [ STILL! ]\u0026lt;/span\u0026gt;\n\n\nraw_input( \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;press any key to continue\u0026apos;\u0026lt;/span\u0026gt; )\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Pythons pass-by-assignment scheme isnt quite the same as C++s reference parameters option, but it turns out to be very similar to the argument-passing model of the C language (and others) in practice:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Immutable arguments are effectively passed \u0026lt;strong\u0026gt;by value\u0026lt;/strong\u0026gt;. Objects such as integers and strings are passed by object reference instead of by copying, but because you cant change immutable objects in place anyhow, the effect is much like making a copy.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Mutable arguments are effectively passed \u0026lt;strong\u0026gt;by pointer\u0026lt;/strong\u0026gt;. Objects such as lists\nand dictionaries are also passed by object reference, which is similar to the way C\npasses arrays as pointersmutable objects can be changed in place in the function,\nmuch like C arrays.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In this case the variable titled \u0026lt;code\u0026gt;var\u0026lt;/code\u0026gt; in the method \u0026lt;code\u0026gt;Change\u0026lt;/code\u0026gt; is assigned a reference to \u0026lt;code\u0026gt;self.variable\u0026lt;/code\u0026gt;, and you immediately assign a string to \u0026lt;code\u0026gt;var\u0026lt;/code\u0026gt;. It\u0026apos;s no longer pointing to \u0026lt;code\u0026gt;self.variable\u0026lt;/code\u0026gt;. The following code snippet shows what would happen if you modify the data structure pointed to by \u0026lt;code\u0026gt;var\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;self.variable\u0026lt;/code\u0026gt;, in this case a list:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;PassByReference\u0026lt;/span\u0026gt;:\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__init__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;        self.variable = [\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Original\u0026apos;\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;        self.change(self.variable)\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; self.variable\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;        \n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;change\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, var\u0026lt;/span\u0026gt;):\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;        var.append(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Changed\u0026apos;\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;q = PassByReference()\n[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Original\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Changed\u0026apos;\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;m sure someone else could clarify this further.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A lot of insights in answers here, but i think an additional point is not clearly mentioned here explicitly.   Quoting from python documentation \u0026lt;a href=\u0026quot;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python\u0026lt;/a\u0026gt;  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026quot;In Python, variables that are only referenced inside a function are implicitly global. If a variable is assigned a new value anywhere within the functions body, its assumed to be a local. If a variable is ever assigned a new value inside the function, the variable is implicitly local, and you need to explicitly declare it as global.\nThough a bit surprising at first, a moments consideration explains this. On one hand, requiring global for assigned variables provides a bar against unintended side-effects. On the other hand, if global was required for all global references, youd be using global all the time. Youd have to declare as global every reference to a built-in function or to a component of an imported module. This clutter would defeat the usefulness of the global declaration for identifying side-effects.\u0026quot;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Even when passing a mutable object to a function this still applies. And to me clearly explains the reason for the difference in behavior between assigning to the object and operating on the object in the function.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;l\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Received\u0026quot;\u0026lt;/span\u0026gt;, l , \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(l)\n    l = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Changed to\u0026quot;\u0026lt;/span\u0026gt;, l, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(l)  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# New local object created, breaking link to global l\u0026lt;/span\u0026gt;\n\nl= [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Original\u0026quot;\u0026lt;/span\u0026gt;, l, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(l)\ntest(l)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;After\u0026quot;\u0026lt;/span\u0026gt;, l, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(l)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;gives:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;Original [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4454645632\u0026lt;/span\u0026gt;\nReceived [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4454645632\u0026lt;/span\u0026gt;\nChanged to [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4474591928\u0026lt;/span\u0026gt;\nAfter [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4454645632\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The assignment to an global variable that is not declared global therefore creates a new local object and breaks the link to the original object.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As you can state you need to have a mutable object, but let me suggest you to check over the global variables as they can help you or even solve this kind of issue!\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://docs.python.org/3/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://docs.python.org/3/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;y\u0026lt;/span\u0026gt;):\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;global\u0026lt;/span\u0026gt; z\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;    z = y\n...\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;x\n\u0026amp;lt;function x at \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x00000000020E1730\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;y\nTraceback (most recent call last):\n  File \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026amp;lt;stdin\u0026amp;gt;\u0026quot;\u0026lt;/span\u0026gt;, line \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026amp;lt;module\u0026amp;gt;\nNameError: name \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;y\u0026apos;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; defined\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;z\nTraceback (most recent call last):\n  File \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026amp;lt;stdin\u0026amp;gt;\u0026quot;\u0026lt;/span\u0026gt;, line \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026amp;lt;module\u0026amp;gt;\nNameError: name \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;z\u0026apos;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; defined\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;x(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;x\n\u0026amp;lt;function x at \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x00000000020E1730\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;y\nTraceback (most recent call last):\n  File \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026amp;lt;stdin\u0026amp;gt;\u0026quot;\u0026lt;/span\u0026gt;, line \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026amp;lt;module\u0026amp;gt;\nNameError: name \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;y\u0026apos;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; defined\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;z\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is the simple (I hope) explanation of the concept \u0026lt;code\u0026gt;pass by object\u0026lt;/code\u0026gt; used in Python.\u0026lt;br\u0026gt;\nWhenever you pass an object to the function, the object itself is passed (object in Python is actually what you\u0026apos;d call a value in other programming languages) not the reference to this object. In other words, when you call:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;change_me\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;list\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;):\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;list\u0026lt;/span\u0026gt; = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;]\n\nmy_list = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]\nchange_me(my_list)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The actual object - [0, 1] (which would be called a value in other programming languages) is being passed. So in fact the function \u0026lt;code\u0026gt;change_me\u0026lt;/code\u0026gt; will try to do something like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;which obviously will not change the object passed to the function. If the function looked like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;change_me\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;list\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;):\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;list\u0026lt;/span\u0026gt;.append(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Then the call would result in:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;].append(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;which obviously will change the object. \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/534509/831531\u0026quot;\u0026gt;This answer\u0026lt;/a\u0026gt; explains it well.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Aside from all the great explanations on how this stuff works in Python, I don\u0026apos;t see a simple suggestion for the problem. As you seem to do create objects and instances, the pythonic way of handling instance variables and changing them is the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;PassByReference\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__init__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n        self.variable = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Original\u0026apos;\u0026lt;/span\u0026gt;\n        self.Change()\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; self.variable\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Change\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n        self.variable = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Changed\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In instance methods, you normally refer to \u0026lt;code\u0026gt;self\u0026lt;/code\u0026gt; to access instance attributes. It is normal to set instance attributes in \u0026lt;code\u0026gt;__init__\u0026lt;/code\u0026gt; and read or change them in instance methods. That is also why you pass \u0026lt;code\u0026gt;self\u0026lt;/code\u0026gt; als the first argument to \u0026lt;code\u0026gt;def Change\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Another solution would be to create a static method like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;PassByReference\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__init__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n        self.variable = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Original\u0026apos;\u0026lt;/span\u0026gt;\n        self.variable = PassByReference.Change(self.variable)\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; self.variable\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;    @staticmethod\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Change\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt;):\n        var = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Changed\u0026apos;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; var\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I used the following method to quickly convert a couple of Fortran codes to Python.  True, it\u0026apos;s not pass by reference as the original question was posed, but is a simple work around in some cases.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;a=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\nb=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\nc=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;myfunc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a,b,c\u0026lt;/span\u0026gt;):\n    a=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n    b=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;\n    c=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; a,b,c\n\na,b,c = myfunc(a,b,c)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; a,b,c\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There is a little trick to pass an object by reference, even though the language doesn\u0026apos;t make it possible. It works in Java too, it\u0026apos;s the list with one item. ;-)\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;PassByReference\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__init__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, name\u0026lt;/span\u0026gt;):\n        self.name = name\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;changeRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;ref\u0026lt;/span\u0026gt;):\n    ref[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = PassByReference(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Michael\u0026apos;\u0026lt;/span\u0026gt;)\n\nobj = PassByReference(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Peter\u0026apos;\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; obj.name\n\np = [obj] \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# A pointer to obj! ;-)\u0026lt;/span\u0026gt;\nchangeRef(p)\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;].name \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# p-\u0026amp;gt;name\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It\u0026apos;s an ugly hack, but it works. ;-P\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;given the way python handles values and references to them, the only way you can reference an arbitrary instance attribute is by name:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;PassByReferenceIsh\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__init__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n        self.variable = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Original\u0026apos;\u0026lt;/span\u0026gt;\n        self.change(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;variable\u0026apos;\u0026lt;/span\u0026gt;)\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; self.variable\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;change\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, var\u0026lt;/span\u0026gt;):\n        self.__dict__[var] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Changed\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;in real code you would, of course, add error checking on the dict lookup.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Since your example happens to be object-oriented, you could make the following change to achieve a similar result:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;PassByReference\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__init__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n        self.variable = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Original\u0026apos;\u0026lt;/span\u0026gt;\n        self.change(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;variable\u0026apos;\u0026lt;/span\u0026gt;)\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(self.variable)\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;change\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, var\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;setattr\u0026lt;/span\u0026gt;(self, var, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Changed\u0026apos;\u0026lt;/span\u0026gt;)\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# o.variable will equal \u0026apos;Changed\u0026apos;\u0026lt;/span\u0026gt;\no = PassByReference()\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;assert\u0026lt;/span\u0026gt; o.variable == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Changed\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Since it seems to be nowhere mentioned an approach to simulate references as known from e.g. C++ is to use an \u0026quot;update\u0026quot; function and pass that instead of the actual variable (or rather, \u0026quot;name\u0026quot;):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;need_to_modify\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;update\u0026lt;/span\u0026gt;):\n    update(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# set new value 42\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# other code\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;call_it\u0026lt;/span\u0026gt;():\n    value = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;21\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;update_value\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;new_value\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;nonlocal\u0026lt;/span\u0026gt; value\n        value = new_value\n    need_to_modify(update_value)\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(value) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# prints 42\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This is mostly useful for \u0026quot;out-only references\u0026quot; or in a situation with multiple threads / processes (by making the update function thread / multiprocessing safe).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Obviously the above does not allow \u0026lt;em\u0026gt;reading\u0026lt;/em\u0026gt; the value, only updating it.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Since dictionaries are passed by reference, you can use a dict variable to store any referenced values inside it.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# returns the result of adding numbers `a` and `b`\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;AddNumbers\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a, b, ref\u0026lt;/span\u0026gt;): \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# using a dict for reference\u0026lt;/span\u0026gt;\n    result = a + b\n    ref[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;multi\u0026apos;\u0026lt;/span\u0026gt;] = a * b \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# reference the multi. ref[\u0026apos;multi\u0026apos;] is number\u0026lt;/span\u0026gt;\n    ref[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;msg\u0026apos;\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;The result: \u0026quot;\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt;(result) + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; was nice!\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; result\n\nnumber1 = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;\nnumber2 = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;\nref = {} \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# init a dict like that so it can save all the referenced values. this is because all dictionaries are passed by reference, while strings and numbers do not.\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sum\u0026lt;/span\u0026gt; = AddNumbers(number1, number2, ref)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;sum: \u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sum\u0026lt;/span\u0026gt;)             \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# the returned value\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;multi: \u0026quot;\u0026lt;/span\u0026gt;, ref[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;multi\u0026apos;\u0026lt;/span\u0026gt;])  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# a referenced value\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;msg: \u0026quot;\u0026lt;/span\u0026gt;, ref[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;msg\u0026apos;\u0026lt;/span\u0026gt;])      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# a referenced value\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;While pass by reference is nothing that fits well into python and should be rarely used there are some workarounds that actually can work to get the object currently assigned to a local variable or even reassign a local variable from inside of a called function.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The basic idea is to have a function that can do that access and can be passed as object into other functions or stored in a class.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;One way is to use \u0026lt;code\u0026gt;global\u0026lt;/code\u0026gt; (for global variables) or \u0026lt;code\u0026gt;nonlocal\u0026lt;/code\u0026gt; (for local variables in a function) in a wrapper function.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;change\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;wrapper\u0026lt;/span\u0026gt;):\n    wrapper(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;)\n\nx = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setter\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;val\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;global\u0026lt;/span\u0026gt; x\n    x = val\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(x)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The same idea works for reading and \u0026lt;code\u0026gt;del\u0026lt;/code\u0026gt;eting a variable.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For just reading there is even a shorter way of just using \u0026lt;code\u0026gt;lambda: x\u0026lt;/code\u0026gt; which returns a callable that when called returns the current value of x. This is somewhat like \u0026quot;call by name\u0026quot; used in languages in the distant past.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Passing 3 wrappers to access a variable is a bit unwieldy so those can be wrapped into a class that has a proxy attribute:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ByRef\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__init__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, r, w, d\u0026lt;/span\u0026gt;):\n        self._read = r\n        self._write = w\n        self._delete = d\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;set\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, val\u0026lt;/span\u0026gt;):\n        self._write(val)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; self._read()\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;remove\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n        self._delete()\n    wrapped = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;property\u0026lt;/span\u0026gt;(get, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;set\u0026lt;/span\u0026gt;, remove)\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# left as an exercise for the reader: define set, get, remove as local functions using global / nonlocal\u0026lt;/span\u0026gt;\nr = ByRef(get, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;set\u0026lt;/span\u0026gt;, remove)\nr.wrapped = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;15\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Pythons \u0026quot;reflection\u0026quot; support makes it possible to get a object that is capable of reassigning a name/variable in a given scope without defining functions explicitly in that scope:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ByRef\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__init__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, locs, name\u0026lt;/span\u0026gt;):\n        self._locs = locs\n        self._name = name\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;set\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, val\u0026lt;/span\u0026gt;):\n        self._locs[self._name] = val\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; self._locs[self._name]\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;remove\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;del\u0026lt;/span\u0026gt; self._locs[self._name]\n    wrapped = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;property\u0026lt;/span\u0026gt;(get, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;set\u0026lt;/span\u0026gt;, remove)\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;change\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;):\n    x.wrapped = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;test_me\u0026lt;/span\u0026gt;():\n    x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(x)\n    change(ByRef(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;locals\u0026lt;/span\u0026gt;(), \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;x\u0026quot;\u0026lt;/span\u0026gt;))\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(x)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here the \u0026lt;code\u0026gt;ByRef\u0026lt;/code\u0026gt; class wraps a dictionary access. So attribute access to \u0026lt;code\u0026gt;wrapped\u0026lt;/code\u0026gt; is translated to a item access in the passed dictionary. By passing the result of the builtin \u0026lt;code\u0026gt;locals\u0026lt;/code\u0026gt; and the name of a local variable this ends up accessing a local variable. The python documentation as of 3.5 advises that changing the dictionary might not work but it seems to work for me.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You can merely use \u0026lt;strong\u0026gt;an empty class\u0026lt;/strong\u0026gt; as an instance to store reference objects because internally object attributes are stored in an instance dictionary. See the example.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;RefsObj\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_ inherited__\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;A class which helps to create references to variables.\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;pass\u0026lt;/span\u0026gt;\n\n...\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# an example of usage\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;change_ref_var\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;ref_obj\u0026lt;/span\u0026gt;):\n    ref_obj.val = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;24\u0026lt;/span\u0026gt;\n\nref_obj = RefsObj()\nref_obj.val = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(ref_obj.val) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# or print ref_obj.val for python2\u0026lt;/span\u0026gt;\nchange_ref_var(ref_obj)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(ref_obj.val)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Pass-By-Reference in Python is quite different from the concept of pass by reference in C++/Java. \u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Java\u0026amp;amp;C#:\u0026lt;/strong\u0026gt; primitive types(include string)pass by value(copy), Reference type is passed by reference(address copy) so all changes made in the parameter in the called function are visible to the caller.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;C++:\u0026lt;/strong\u0026gt; Both pass-by-reference or pass-by-value are allowed. If a parameter is passed by reference, you can either modify it or not depending upon whether the parameter was passed as const or not. However, const or not, the parameter maintains the reference to the object and reference cannot be assigned to point to a different object within the called function.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Python:\u0026lt;/strong\u0026gt; \nPython is pass-by-object-reference, of which it is often said: Object references are passed by value.[Read here]\u0026lt;a href=\u0026quot;https://robertheaton.com/2014/02/09/pythons-pass-by-object-reference-as-explained-by-philip-k-dick/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;1\u0026lt;/a\u0026gt;. Both the caller and the function refer to the same object but the parameter in the function is a new variable which is just holding a copy of the object in the caller. Like C++, a parameter can be either modified or not in function - This depends upon the type of object passed. eg; An immutable object type cannot be modified in the called function whereas a mutable object can be either updated or re-initialized. A crucial difference between updating or re-assigning/re-initializing the mutable variable is that updated value gets reflected back in the called function whereas the reinitialized value does not. Scope of any assignment of new object to a mutable variable is local to the function in the python. Examples provided by @blair-conrad are great to understand this.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I am new to Python, started yesterday (though I have been programming for 45 years).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I came here because I was writing a function where I wanted to have two so called out-parameters. If it would have been only one out-parameter, I wouldn\u0026apos;t get hung up right now on checking how reference/value works in Python. I would just have used the return value of the function instead. But since I needed \u0026lt;em\u0026gt;two\u0026lt;/em\u0026gt; such out-parameters I felt I needed to sort it out.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In this post I am going to show how I solved my situation. Perhaps others coming here can find it valuable, even though it is not exactly an answer to the topic question. Experienced Python programmers of course already know about the solution I used, but it was new to me.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;From the answers here I could quickly see that Python works a bit like Javascript in this regard, and that you need to use workarounds if you want the reference functionality.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;But then I found something neat in Python that I don\u0026apos;t think I have seen in other languages before, namely that you can return more than one value from a function, in a simple comma separated way, like this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;somefunction\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;p\u0026lt;/span\u0026gt;):\n    a=p+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n    b=p+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;\n    c=-p\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; a, b, c\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;and that you can handle that on the calling side similarly, like this\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;x, y, z = somefunction(w)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;That was good enough for me and I was satisfied. No need to use some workaround.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In other languages you can of course also return many values, but then usually in the from of an object, and you need to adjust the calling side accordingly.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The Python way of doing it was nice and simple.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If you want to mimic \u0026lt;em\u0026gt;by reference\u0026lt;/em\u0026gt; even more, you could do as follows:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;somefunction\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a, b, c\u0026lt;/span\u0026gt;):\n    a = a * \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;\n    b = b + a\n    c = a * b * c\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; a, b, c\n\nx = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\ny = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;\nz = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;F\u0026quot;Before : \u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;{x}\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;{y}\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;{z}\u0026lt;/span\u0026gt;\u0026quot;\u0026lt;/span\u0026gt;)\n\nx, y, z = somefunction(x, y, z)\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;F\u0026quot;After  : \u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;{x}\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;{y}\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;{z}\u0026lt;/span\u0026gt;\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;which gives this result\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;Before : 3, 5, 10  \nAfter  : 6, 11, 660  \n\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;alternatively you could use ctypes witch would look something like this\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; ctypes\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;):\n    a.value=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2398\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;## resign the value in a function\u0026lt;/span\u0026gt;\n\na = ctypes.c_int(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;pre f\u0026quot;\u0026lt;/span\u0026gt;, a)\nf(a)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;post f\u0026quot;\u0026lt;/span\u0026gt;, a)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;as a is a c int and not a python integer and apperently passed by reference. however you have to be carefull as strange things could happen and is therefor not advised\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Most likely not the most reliable method but this works, keep in mind that you are overloading the built-in str function which is typically something you don\u0026apos;t want to do:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; builtins\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;sstr\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_ inherited__\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__str__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;hasattr\u0026lt;/span\u0026gt;(self, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;changed\u0026apos;\u0026lt;/span\u0026gt;):\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; self.changed\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; self\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;change\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, value\u0026lt;/span\u0026gt;):\n        self.changed = value\n\nbuiltins.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt; = sstr\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;change_the_value\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;val\u0026lt;/span\u0026gt;):\n    val.change(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;After\u0026apos;\u0026lt;/span\u0026gt;)\n\nval = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Before\u0026apos;\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; (val)\nchange_the_value(val)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; (val)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;What about \u0026lt;a href=\u0026quot;https://docs.python.org/3/library/dataclasses.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;dataclasses\u0026lt;/a\u0026gt;? Also, it allows you to apply type restriction (aka \u0026quot;type hint\u0026quot;).\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; dataclasses \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; dataclass\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@dataclass\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Holder\u0026lt;/span\u0026gt;:\n    obj: your_type \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Need any type? Use \u0026quot;obj: object\u0026quot; then.\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;ref: Holder\u0026lt;/span\u0026gt;):\n    ref.obj = do_something()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;I agree with folks that in most cases you\u0026apos;d better consider not to use it.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;And yet, when we\u0026apos;re talking about \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/State_pattern\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;em\u0026gt;contexts\u0026lt;/em\u0026gt;\u0026lt;/a\u0026gt; it\u0026apos;s worth to know that way.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;You can design explicit context class though. When prototyping I prefer dataclasses, just because it\u0026apos;s easy to serialize them back and forth.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Cheers!\u0026lt;/p\u0026gt;\n    "],"id":114,"title":"How do I pass a variable by reference?","content":"\n                \n\u0026lt;p\u0026gt;Are parameters passed by reference or by value? How do I pass by reference so that the code below outputs \u0026lt;code\u0026gt;\u0026apos;Changed\u0026apos;\u0026lt;/code\u0026gt; instead of \u0026lt;code\u0026gt;\u0026apos;Original\u0026apos;\u0026lt;/code\u0026gt;?\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;PassByReference\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__init__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n        self.variable = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Original\u0026apos;\u0026lt;/span\u0026gt;\n        self.change(self.variable)\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(self.variable)\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;change\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, var\u0026lt;/span\u0026gt;):\n        var = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Changed\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","slug":"how-do-i-pass-a-variable-by-reference-1657384657232","postType":"QUESTION","createdAt":"2022-07-09T16:37:37.000Z","updatedAt":"2022-07-09T16:37:37.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"What is a clearfix?","slug":"what-is-a-clearfix-1657387337825"},{"title":"What is the difference between \"px\", \"dip\", \"dp\" and \"sp\"?","slug":"what-is-the-difference-between-\"px\"-\"dip\"-\"dp\"-and-\"sp\"-1657388093250"},{"title":"How can I remove a specific item from an array?","slug":"how-can-i-remove-a-specific-item-from-an-array-1657387552077"},{"title":"Randomize a List\u003cT\u003e","slug":"randomize-a-listlesstgreater-1657388172793"},{"title":"How do I add a delay in a JavaScript loop?","slug":"how-do-i-add-a-delay-in-a-javascript-loop-1657388544679"},{"title":"String.equals versus == [duplicate]","slug":"string.equals-versus-duplicate-1657387599972"},{"title":"Are 'Arrow Functions' and 'Functions' equivalent / interchangeable?","slug":"are-'arrow-functions'-and-'functions'-equivalent-interchangeable-1657384527873"},{"title":"JQuery - $ is not defined","slug":"jquery-dollar-is-not-defined-1657388385731"},{"title":"\"Cross origin requests are only supported for HTTP.\" error when loading a local file","slug":"\"cross-origin-requests-are-only-supported-for-http.\"-error-when-loading-a-local-file-1657387942403"},{"title":"Why is the gets function so dangerous that it should not be used?","slug":"why-is-the-gets-function-so-dangerous-that-it-should-not-be-used-1657384544362"},{"title":"How do JavaScript closures work?","slug":"how-do-javascript-closures-work-1657384418555"},{"title":"Why does Spring MVC respond with a 404 and report \"No mapping found for HTTP request with URI [...] in DispatcherServlet\"?","slug":"why-does-spring-mvc-respond-with-a-404-and-report-\"no-mapping-found-for-http-request-with-uri-...-in-dispatcherservlet\"-1657387995250"},{"title":"Transpose / reshape dataframe without \"timevar\" from long to wide format","slug":"transpose-reshape-dataframe-without-\"timevar\"-from-long-to-wide-format-1657388213347"},{"title":"XMLHttpRequest cannot load XXX No 'Access-Control-Allow-Origin' header","slug":"xmlhttprequest-cannot-load-xxx-no-'access-control-allow-origin'-header-1657384758362"},{"title":"What is an undefined reference/unresolved external symbol error and how do I fix it?","slug":"what-is-an-undefined-referenceunresolved-external-symbol-error-and-how-do-i-fix-it-1657384255179"},{"title":"Why does my recursive function return None?","slug":"why-does-my-recursive-function-return-none-1657387792894"},{"title":"What is the (function() { } )() construct in JavaScript?","slug":"what-is-the-(function()-)()-construct-in-javascript-1657385508348"},{"title":"How do I use extern to share variables between source files?","slug":"how-do-i-use-extern-to-share-variables-between-source-files-1657387453605"},{"title":"How do I format a date in JavaScript?","slug":"how-do-i-format-a-date-in-javascript-1657384649498"},{"title":"How do I use shell variables in an awk script?","slug":"how-do-i-use-shell-variables-in-an-awk-script-1657387754261"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"how-do-i-pass-a-variable-by-reference-1657384657232"},"buildId":"BnkbnjkWYxefPXjTJLVVv","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>