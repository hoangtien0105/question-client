{"pageProps":{"data":{"count":1,"rows":[{"id":545,"title":"Why is 24.0000 not equal to 24.0000 in MATLAB?","slug":"why-is-24.0000-not-equal-to-24.0000-in-matlab-1657388376753","postType":"QUESTION","createdAt":"2022-07-09T17:39:36.000Z","updatedAt":"2022-07-09T17:39:36.000Z","tags":[{"id":2657,"name":"matlab","slug":"matlab","createdAt":"2022-07-09T17:39:36.000Z","updatedAt":"2022-07-09T17:39:36.000Z","Questions_Tags":{"questionId":545,"tagId":2657}}]}]},"slug":"matlab","page":"1","answers":{"545":["\n&lt;p&gt;The problem you&apos;re having relates to how &lt;a href=&quot;https://www.mathworks.com/help/matlab/matlab_prog/floating-point-numbers.html&quot; rel=&quot;noreferrer&quot;&gt;floating-point numbers&lt;/a&gt; are represented on a computer. A more detailed discussion of floating-point representations appears towards the end of my answer (The &quot;Floating-point representation&quot; section). The &lt;strong&gt;TL;DR&lt;/strong&gt; version: because computers have finite amounts of memory, numbers can only be represented with finite precision. Thus, the accuracy of floating-point numbers is limited to a certain number of decimal places (about 16 significant digits for &lt;a href=&quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot; rel=&quot;noreferrer&quot;&gt;double-precision values&lt;/a&gt;, the default used in MATLAB).&lt;/p&gt;\n\n&lt;h2&gt;Actual vs. displayed precision&lt;/h2&gt;\n\n&lt;p&gt;Now to address the specific example in the question... &lt;strong&gt;while &lt;code&gt;24.0000&lt;/code&gt; and &lt;code&gt;24.0000&lt;/code&gt; are &lt;em&gt;displayed&lt;/em&gt; in the same manner, it turns out that they actually differ by very small decimal amounts in this case. You don&apos;t see it because MATLAB &lt;a href=&quot;https://www.mathworks.com/help/matlab/ref/format.html&quot; rel=&quot;noreferrer&quot;&gt;only displays 4 significant digits by default&lt;/a&gt;, keeping the overall display neat and tidy.&lt;/strong&gt; If you want to see the full precision, you should either issue the &lt;code&gt;format long&lt;/code&gt; command or view a &lt;a href=&quot;https://www.mathworks.com/help/matlab/ref/num2hex.html&quot; rel=&quot;noreferrer&quot;&gt;hexadecimal representation&lt;/a&gt; of the number:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-matlab s-code-block&quot;&gt;&lt;code class=&quot;hljs language-matlab&quot;&gt;&amp;gt;&amp;gt; &lt;span class=&quot;hljs-built_in&quot;&gt;pi&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;ans&lt;/span&gt; =\n    &lt;span class=&quot;hljs-number&quot;&gt;3.1416&lt;/span&gt;\n&amp;gt;&amp;gt; format long\n&amp;gt;&amp;gt; &lt;span class=&quot;hljs-built_in&quot;&gt;pi&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;ans&lt;/span&gt; =\n   &lt;span class=&quot;hljs-number&quot;&gt;3.141592653589793&lt;/span&gt;\n&amp;gt;&amp;gt; num2hex(&lt;span class=&quot;hljs-built_in&quot;&gt;pi&lt;/span&gt;)\n&lt;span class=&quot;hljs-built_in&quot;&gt;ans&lt;/span&gt; =\n&lt;span class=&quot;hljs-number&quot;&gt;400921&lt;/span&gt;fb54442d18\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h2&gt;Initialized values vs. computed values&lt;/h2&gt;\n\n&lt;p&gt;Since there are only a finite number of values that can be represented for a floating-point number, it&apos;s possible for a computation to result in a value that falls between two of these representations. In such a case, the result has to be rounded off to one of them. This introduces a small &lt;a href=&quot;https://en.wikipedia.org/wiki/Machine_epsilon&quot; rel=&quot;noreferrer&quot;&gt;machine-precision error&lt;/a&gt;. This also means that initializing a value directly or by some computation can give slightly different results. For example, the value &lt;code&gt;0.1&lt;/code&gt; doesn&apos;t have an &lt;em&gt;exact&lt;/em&gt; floating-point representation (i.e. it gets slightly rounded off), and so you end up with counter-intuitive results like this due to the way round-off errors accumulate:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-matlab s-code-block&quot;&gt;&lt;code class=&quot;hljs language-matlab&quot;&gt;&amp;gt;&amp;gt; a=sum([&lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt;]);  &lt;span class=&quot;hljs-comment&quot;&gt;% Sum 10 0.1s&lt;/span&gt;\n&amp;gt;&amp;gt; b=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;                                               &lt;span class=&quot;hljs-comment&quot;&gt;% Initialize to 1&lt;/span&gt;\n&amp;gt;&amp;gt; a == b\n&lt;span class=&quot;hljs-built_in&quot;&gt;ans&lt;/span&gt; =\n  logical\n   &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;                &lt;span class=&quot;hljs-comment&quot;&gt;% They are unequal!&lt;/span&gt;\n&amp;gt;&amp;gt; num2hex(a)       &lt;span class=&quot;hljs-comment&quot;&gt;% Let&apos;s check their hex representation to confirm&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;ans&lt;/span&gt; =\n&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;fefffffffffffff\n&amp;gt;&amp;gt; num2hex(b)\n&lt;span class=&quot;hljs-built_in&quot;&gt;ans&lt;/span&gt; =\n&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;ff0000000000000\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h2&gt;How to correctly handle floating-point comparisons&lt;/h2&gt;\n\n&lt;p&gt;Since floating-point values can differ by very small amounts, any comparisons should be done by checking that the values are within some range (i.e. tolerance) of one another, as opposed to exactly equal to each other. For example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-matlab s-code-block&quot;&gt;&lt;code class=&quot;hljs language-matlab&quot;&gt;a = &lt;span class=&quot;hljs-number&quot;&gt;24&lt;/span&gt;;\nb = &lt;span class=&quot;hljs-number&quot;&gt;24.000001&lt;/span&gt;;\ntolerance = &lt;span class=&quot;hljs-number&quot;&gt;0.001&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;abs&lt;/span&gt;(a-b) &amp;lt; tolerance, &lt;span class=&quot;hljs-built_in&quot;&gt;disp&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Equal!&apos;&lt;/span&gt;); &lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;will display &quot;Equal!&quot;.&lt;/p&gt;\n\n&lt;p&gt;You could then change your code to something like:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-matlab s-code-block&quot;&gt;&lt;code class=&quot;hljs language-matlab&quot;&gt;points = points((&lt;span class=&quot;hljs-built_in&quot;&gt;abs&lt;/span&gt;(points(:,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)-vertex1(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)) &amp;gt; tolerance) | ...\n                (&lt;span class=&quot;hljs-built_in&quot;&gt;abs&lt;/span&gt;(points(:,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)-vertex1(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)) &amp;gt; tolerance),:)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;hr&gt;\n\n&lt;h1&gt;Floating-point representation&lt;/h1&gt;\n\n&lt;p&gt;A good overview of floating-point numbers (and specifically the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_floating_point&quot; rel=&quot;noreferrer&quot;&gt;IEEE 754 standard for floating-point arithmetic&lt;/a&gt;) is &lt;a href=&quot;http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;em&gt;What Every Computer Scientist Should Know About Floating-Point Arithmetic&lt;/em&gt;&lt;/a&gt; by David Goldberg.&lt;/p&gt;\n\n&lt;p&gt;A binary floating-point number is actually represented by three integers: a sign bit &lt;code&gt;s&lt;/code&gt;, a significand (or coefficient/fraction) &lt;code&gt;b&lt;/code&gt;, and an exponent &lt;code&gt;e&lt;/code&gt;. &lt;a href=&quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot; rel=&quot;noreferrer&quot;&gt;For double-precision floating-point format&lt;/a&gt;, each number is represented by 64 bits laid out in memory as follows:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/KTTPX.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/KTTPX.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;The real value can then be found with the following formula:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/nV0ly.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/nV0ly.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;This format allows for number representations in the range 10^-308 to 10^308. For MATLAB you can get these limits from &lt;a href=&quot;https://www.mathworks.com/help/matlab/ref/realmin.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;realmin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://www.mathworks.com/help/matlab/ref/realmax.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;realmax&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-matlab s-code-block&quot;&gt;&lt;code class=&quot;hljs language-matlab&quot;&gt;&amp;gt;&amp;gt; &lt;span class=&quot;hljs-built_in&quot;&gt;realmin&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;ans&lt;/span&gt; =\n    &lt;span class=&quot;hljs-number&quot;&gt;2.225073858507201e-308&lt;/span&gt;\n&amp;gt;&amp;gt; &lt;span class=&quot;hljs-built_in&quot;&gt;realmax&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;ans&lt;/span&gt; =\n    &lt;span class=&quot;hljs-number&quot;&gt;1.797693134862316e+308&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Since there are a finite number of bits used to represent a floating-point number, there are only so many finite numbers that can be represented within the above given range. Computations will often result in a value that doesn&apos;t exactly match one of these finite representations, so the values must be rounded off. These &lt;a href=&quot;https://en.wikipedia.org/wiki/Machine_epsilon&quot; rel=&quot;noreferrer&quot;&gt;machine-precision errors&lt;/a&gt; make themselves evident in different ways, as discussed in the above examples.&lt;/p&gt;\n\n&lt;p&gt;In order to better understand these round-off errors it&apos;s useful to look at the relative floating-point accuracy provided by the function &lt;a href=&quot;https://www.mathworks.com/help/matlab/ref/eps.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt;, which quantifies the distance from a given number to the next largest floating-point representation:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-matlab s-code-block&quot;&gt;&lt;code class=&quot;hljs language-matlab&quot;&gt;&amp;gt;&amp;gt; &lt;span class=&quot;hljs-built_in&quot;&gt;eps&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)\n&lt;span class=&quot;hljs-built_in&quot;&gt;ans&lt;/span&gt; =\n     &lt;span class=&quot;hljs-number&quot;&gt;2.220446049250313e-16&lt;/span&gt;\n&amp;gt;&amp;gt; &lt;span class=&quot;hljs-built_in&quot;&gt;eps&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;)\n&lt;span class=&quot;hljs-built_in&quot;&gt;ans&lt;/span&gt; =\n     &lt;span class=&quot;hljs-number&quot;&gt;1.136868377216160e-13&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Notice that the precision is &lt;em&gt;relative&lt;/em&gt; to the size of a given number being represented; larger numbers will have larger distances between floating-point representations, and will thus have fewer digits of precision following the decimal point. This can be an important consideration with some calculations. Consider the following example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-matlab s-code-block&quot;&gt;&lt;code class=&quot;hljs language-matlab&quot;&gt;&amp;gt;&amp;gt; format long              &lt;span class=&quot;hljs-comment&quot;&gt;% Display full precision&lt;/span&gt;\n&amp;gt;&amp;gt; x = &lt;span class=&quot;hljs-built_in&quot;&gt;rand&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;);         &lt;span class=&quot;hljs-comment&quot;&gt;% Get 10 random values between 0 and 1&lt;/span&gt;\n&amp;gt;&amp;gt; a = &lt;span class=&quot;hljs-built_in&quot;&gt;mean&lt;/span&gt;(x)              &lt;span class=&quot;hljs-comment&quot;&gt;% Take the mean&lt;/span&gt;\na =\n   &lt;span class=&quot;hljs-number&quot;&gt;0.587307428244141&lt;/span&gt;\n&amp;gt;&amp;gt; b = &lt;span class=&quot;hljs-built_in&quot;&gt;mean&lt;/span&gt;(x+&lt;span class=&quot;hljs-number&quot;&gt;10000&lt;/span&gt;)&lt;span class=&quot;hljs-number&quot;&gt;-10000&lt;/span&gt;  &lt;span class=&quot;hljs-comment&quot;&gt;% Take the mean at a different scale, then shift back&lt;/span&gt;\nb =\n   &lt;span class=&quot;hljs-number&quot;&gt;0.587307428244458&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Note that when we shift the values of &lt;code&gt;x&lt;/code&gt; from the range &lt;code&gt;[0 1]&lt;/code&gt; to the range &lt;code&gt;[10000 10001]&lt;/code&gt;, compute a mean, then subtract the mean offset for comparison, we get a value that differs for the last 3 significant digits. This illustrates how an offset or scaling of data can change the accuracy of calculations performed on it, which is something that has to be accounted for with certain problems.&lt;/p&gt;\n    ","\n&lt;p&gt;Look at this article: &lt;a href=&quot;http://www.lahey.com/float.htm&quot; rel=&quot;noreferrer&quot;&gt;The Perils of Floating Point&lt;/a&gt;. Though its examples are in FORTRAN it has sense for virtually any modern programming language, including MATLAB. Your problem (and solution for it) is described in &quot;Safe Comparisons&quot; section.&lt;/p&gt;\n    ","\n&lt;p&gt;type&lt;/p&gt;\n\n&lt;pre class=&quot;lang-matlab s-code-block&quot;&gt;&lt;code class=&quot;hljs language-matlab&quot;&gt;format long g\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This command will show the FULL value of the number. It&apos;s likely to be something like 24.00000021321 != 24.00000123124&lt;/p&gt;\n    ","\n&lt;p&gt;Try writing &lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;0.1 + 0.1 + 0.1 == 0.3. &lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Warning: You might be surprised about the result!&lt;/p&gt;\n    ","\n&lt;p&gt;Maybe the two numbers are really 24.0 and 24.000000001 but you&apos;re not seeing all the decimal places.&lt;/p&gt;\n    ","\n&lt;p&gt;Check out the &lt;a href=&quot;https://www.mathworks.com/help/matlab/ref/eps.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Matlab EPS function&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;Matlab uses floating point math up to 16 digits of precision (only 5 are displayed).&lt;/p&gt;\n    "]},"randomTags":[{"name":"pip","slug":"pip"},{"name":"full-outer-join","slug":"full-outer-join"},{"name":"selenium3","slug":"selenium3"},{"name":"protractor","slug":"protractor"},{"name":"spring-mvc","slug":"spring-mvc"},{"name":"addeventlistener","slug":"addeventlistener"},{"name":"parameter-passing","slug":"parameter-passing"},{"name":"substring","slug":"substring"},{"name":"equality","slug":"equality"},{"name":"sql-server","slug":"sql-server"},{"name":"security","slug":"security"},{"name":"3d","slug":"3d"},{"name":"facelets","slug":"facelets"},{"name":"shallow-copy","slug":"shallow-copy"},{"name":"git","slug":"git"},{"name":"variables","slug":"variables"},{"name":"algorithm","slug":"algorithm"},{"name":"python-module","slug":"python-module"},{"name":"database-normalization","slug":"database-normalization"},{"name":"printf","slug":"printf"}]},"__N_SSG":true}