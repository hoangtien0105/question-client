{"pageProps":{"data":{"count":1,"rows":[{"id":568,"title":"What is the difference between a deep copy and a shallow copy?","slug":"what-is-the-difference-between-a-deep-copy-and-a-shallow-copy-1657388445063","postType":"QUESTION","createdAt":"2022-07-09T17:40:45.000Z","updatedAt":"2022-07-09T17:40:45.000Z","tags":[{"id":2740,"name":"deep-copy","slug":"deep-copy","createdAt":"2022-07-09T17:40:45.000Z","updatedAt":"2022-07-09T17:40:45.000Z","Questions_Tags":{"questionId":568,"tagId":2740}}]}]},"slug":"deep-copy","page":"1","answers":{"568":["\n&lt;p&gt;Breadth vs Depth; think in terms of a tree of references with your object as the root node.&lt;/p&gt;\n&lt;p&gt;Shallow:&lt;/p&gt;\n&lt;p&gt;&lt;img src=&quot;https://i.stack.imgur.com/49psq.png&quot; alt=&quot;Before Copy&quot;&gt; &lt;img src=&quot;https://i.stack.imgur.com/qqE2L.png&quot; alt=&quot;Shallow Copying&quot;&gt; &lt;img src=&quot;https://i.stack.imgur.com/cys27.png&quot; alt=&quot;Shallow Done&quot;&gt;&lt;/p&gt;\n&lt;p&gt;The variables A and B refer to different areas of memory, when B is assigned to A the two variables refer to the same area of memory. Later modifications to the contents of either are instantly reflected in the contents of other, as they share contents.&lt;/p&gt;\n&lt;p&gt;Deep:&lt;/p&gt;\n&lt;p&gt;&lt;img src=&quot;https://i.stack.imgur.com/DRLn7.png&quot; alt=&quot;Before Copy&quot;&gt; &lt;img src=&quot;https://i.stack.imgur.com/yuURM.png&quot; alt=&quot;Deep Copying&quot;&gt; &lt;img src=&quot;https://i.stack.imgur.com/i6yAt.png&quot; alt=&quot;Deep Done&quot;&gt;&lt;/p&gt;\n&lt;p&gt;The variables A and B refer to different areas of memory, when B is assigned to A the values in the memory area which A points to are copied into the memory area to which B points. Later modifications to the contents of either remain unique to A or B; the contents are not shared.&lt;/p&gt;\n    ","\n&lt;p&gt;Shallow copies duplicate as little as possible.  A shallow copy of a collection is a copy of the collection structure, not the elements.  With a shallow copy, two collections now share the individual elements.&lt;/p&gt;\n\n&lt;p&gt;Deep copies duplicate everything.  A deep copy of a collection is two collections with all of the elements in the original collection duplicated.  &lt;/p&gt;\n    ","\n&lt;p&gt;Try to consider following image&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/AWKJa.jpg&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/AWKJa.jpg&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;For example &lt;strong&gt;Object.MemberwiseClone&lt;/strong&gt; creates a &lt;strong&gt;shallow&lt;/strong&gt; copy &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.object.memberwiseclone(v=vs.110).aspx&quot; rel=&quot;noreferrer&quot;&gt;link&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;and using &lt;strong&gt;ICloneable&lt;/strong&gt; interface you can get &lt;strong&gt;deep&lt;/strong&gt; copy as described &lt;a href=&quot;https://stackoverflow.com/a/78612/1074179&quot;&gt;here&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;In short, it depends on what points to what. In a shallow copy, object B points to object A&apos;s location in memory. In deep copy, all things in object A&apos;s memory location get copied to object B&apos;s memory location.&lt;/p&gt;\n\n&lt;p&gt;This wiki article has a great diagram.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Object_copy&quot; rel=&quot;noreferrer&quot;&gt;http://en.wikipedia.org/wiki/Object_copy&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Especially For iOS Developers:&lt;/strong&gt; &lt;/p&gt;\n\n&lt;p&gt;If &lt;code&gt;B&lt;/code&gt; is a &lt;strong&gt;shallow copy&lt;/strong&gt; of &lt;code&gt;A&lt;/code&gt;, then for primitive data it&apos;s like &lt;code&gt;B = [A assign];&lt;/code&gt; and for objects it&apos;s like &lt;code&gt;B = [A retain]&lt;/code&gt;;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;B and A point to the same memory location&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;If &lt;code&gt;B&lt;/code&gt; is a &lt;strong&gt;deep copy&lt;/strong&gt; of &lt;code&gt;A&lt;/code&gt;, then it is like &lt;code&gt;B = [A copy];&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;B and A point to different memory locations&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;B memory address is same as A&apos;s&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;B has same contents as A&apos;s&lt;/em&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Shallow copy:&amp;nbsp;Copies the member values from one object into another.&lt;/p&gt;\n\n&lt;p&gt;Deep Copy:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Copies the member values from one object into another.&lt;br&gt;\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Any pointer objects are duplicated and Deep Copied.&lt;/p&gt;\n\n&lt;p&gt;Example:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;class String\n{\n     int   size;\n     char* data;\n};\n\nString  s1(&quot;Ace&quot;);   // s1.size = 3 s1.data=0x0000F000\n\nString  s2 = shallowCopy(s1);\n // s2.size =3 s2.data = 0X0000F000\nString  s3 = deepCopy(s1);\n // s3.size =3 s3.data = 0x0000F00F\n //                      (With Ace copied to this location.)\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Just for the sake of easy understanding you could follow this article:\n&lt;a href=&quot;https://www.cs.utexas.edu/~scottm/cs307/handouts/deepCopying.htm&quot;&gt;https://www.cs.utexas.edu/~scottm/cs307/handouts/deepCopying.htm&lt;/a&gt;&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;Shallow Copy:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/nJJ6K.gif&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/nJJ6K.gif&quot; alt=&quot;Shallow Copy&quot;&gt;&lt;/a&gt; &lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;Deep Copy:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/R6Jlg.gif&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/R6Jlg.gif&quot; alt=&quot;Deep Copy&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;I haven&apos;t seen a short, easy to understand answer here--so I&apos;ll give it a try.&lt;/p&gt;\n\n&lt;p&gt;With a shallow copy, any object pointed to by the source is also pointed to by the destination (so that no referenced objects are copied).&lt;/p&gt;\n\n&lt;p&gt;With a deep copy, any object pointed to by the source is copied and the copy is pointed to by the destination (so there will now be 2 of each referenced object).  This recurses down the object tree.&lt;/p&gt;\n    ","\n&lt;p&gt;{Imagine two objects: A and B of same type _t(with respect to C++) and you are thinking about shallow/deep copying A to B}&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Shallow Copy:&lt;/strong&gt;\nSimply makes a copy of the reference to A into B. Think about it as a copy of A&apos;s Address.\nSo, the addresses of A and B will be the same i.e. they will be pointing to the same memory location i.e. data contents.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Deep copy:&lt;/strong&gt;\nSimply makes a copy of all the members of A, allocates memory in a different location for B and then assigns the copied members to B to achieve deep copy. In this way, if A becomes non-existant B is still valid in the memory. The correct term to use would be cloning, where you know that they both are totally the same, but yet different (i.e. stored as two different entities in the memory space). You can also provide your clone wrapper where you can decide via inclusion/exclusion list which properties to select during deep copy. This is quite a common practice when you create APIs.&lt;/p&gt;\n\n&lt;p&gt;You can choose to do a Shallow Copy &lt;strong&gt;ONLY_IF&lt;/strong&gt; you understand the stakes involved. When you have enormous number of pointers to deal with in C++ or C, doing a shallow copy of an object is &lt;strong&gt;REALLY&lt;/strong&gt; a bad idea. &lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;EXAMPLE_OF_DEEP COPY_&lt;/strong&gt; An example is, when you are trying to do image processing and object recognition you need to mask &quot;Irrelevant and Repetitive Motion&quot; out of your processing areas. If you are using image pointers, then you might have the specification to save those mask images. NOW... if you do a shallow copy of the image, when the pointer references are KILLED from the stack, you lost the reference and its copy i.e. there will be a runtime error of access violation at some point. In this case, what you need is a deep copy of your image by CLONING it. In this way you can retrieve the masks in case you need them in the future.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;EXAMPLE_OF_SHALLOW_COPY&lt;/strong&gt; I am not extremely knowledgeable compared to the users in StackOverflow so feel free to delete this part and put a good example if you can clarify. But I really think it is not a good idea to do shallow copy if you know that your program is gonna run for an infinite period of time i.e. continuous &quot;push-pop&quot; operation over the stack with function calls. If you are demonstrating something to an amateur or novice person (e.g. C/C++ tutorial stuff) then it is probably okay. But if you are running an application such as surveillance and detection system, or Sonar Tracking System, you are not supposed to keep shallow copying your objects around because it will kill your program sooner or later.&lt;/p&gt;\n    ","\n&lt;pre&gt;&lt;code&gt;char * Source = &quot;Hello, world.&quot;;\n\nchar * ShallowCopy = Source;    \n\nchar * DeepCopy = new char(strlen(Source)+1);\nstrcpy(DeepCopy,Source);        \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&apos;ShallowCopy&apos; points to the same location in memory as &apos;Source&apos; does.\n&apos;DeepCopy&apos; points to a different location in memory, but the contents are the same.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;What is Shallow Copy?&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Shallow copy is a bit-wise copy of an object. A new object is created that has an exact copy of the values in the original object. If any of the fields of the object are references to other objects, only the reference addresses are copied i.e., only the memory address is copied. &lt;img src=&quot;https://i.stack.imgur.com/LnDQh.png&quot; alt=&quot;Shallow Copy&quot;&gt;&lt;/p&gt;\n\n&lt;p&gt;In this figure, the &lt;code&gt;MainObject1&lt;/code&gt; has fields &lt;code&gt;field1&lt;/code&gt; of type int, and &lt;code&gt;ContainObject1&lt;/code&gt; of type &lt;code&gt;ContainObject&lt;/code&gt;. When you do a shallow copy of &lt;code&gt;MainObject1&lt;/code&gt;, &lt;code&gt;MainObject2&lt;/code&gt; is created with &lt;code&gt;field2&lt;/code&gt; containing the copied value of &lt;code&gt;field1&lt;/code&gt; and still pointing to &lt;code&gt;ContainObject1&lt;/code&gt; itself. Note that since &lt;code&gt;field1&lt;/code&gt; is of primitive type, its value is copied to &lt;code&gt;field2&lt;/code&gt; but since &lt;code&gt;ContainedObject1&lt;/code&gt; is an object, &lt;code&gt;MainObject2&lt;/code&gt; still points to &lt;code&gt;ContainObject1&lt;/code&gt;. So any changes made to &lt;code&gt;ContainObject1&lt;/code&gt; in &lt;code&gt;MainObject1&lt;/code&gt; will be reflected in &lt;code&gt;MainObject2&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;Now if this is shallow copy, lets see what&apos;s deep copy? &lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;What is Deep Copy?&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;A deep copy copies all fields, and makes copies of dynamically allocated memory pointed to by the fields. A deep copy occurs when an object is copied along with the objects to which it refers. \n&lt;img src=&quot;https://i.stack.imgur.com/kocda.png&quot; alt=&quot;Deep Copy&quot;&gt;&lt;/p&gt;\n\n&lt;p&gt;In this figure, the MainObject1 have fields &lt;code&gt;field1&lt;/code&gt; of type int, and &lt;code&gt;ContainObject1&lt;/code&gt; of type &lt;code&gt;ContainObject&lt;/code&gt;. When you do a deep copy of &lt;code&gt;MainObject1&lt;/code&gt;, &lt;code&gt;MainObject2&lt;/code&gt; is created with &lt;code&gt;field2&lt;/code&gt; containing the copied value of &lt;code&gt;field1&lt;/code&gt; and &lt;code&gt;ContainObject2&lt;/code&gt; containing the copied value of &lt;code&gt;ContainObject1&lt;/code&gt;. Note any changes made to &lt;code&gt;ContainObject1&lt;/code&gt; in &lt;code&gt;MainObject1&lt;/code&gt; will not reflect in &lt;code&gt;MainObject2&lt;/code&gt;. &lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://www.jusfortechies.com/java/core-java/deepcopy_and_shallowcopy.php&quot; rel=&quot;noreferrer&quot;&gt;good article&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;In object oriented programming, a type includes a collection of member fields. These fields may be stored either by value or by reference (i.e., a pointer to a value).&lt;/p&gt;\n\n&lt;p&gt;In a shallow copy, a new instance of the type is created and the values are copied into the new instance. The reference pointers are also copied just like the values. Therefore, the references are pointing to the original objects. Any changes to the members that are stored by reference appear in both the original and the copy, since no copy was made of the referenced object.&lt;/p&gt;\n\n&lt;p&gt;In a deep copy, the fields that are stored by value are copied as before, but the pointers to objects stored by reference are not copied. Instead, a deep copy is made of the referenced object, and a pointer to the new object is stored. Any changes that are made to those referenced objects will not affect other copies of the object.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Deep Copy&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;A deep copy copies all fields, and makes copies of dynamically allocated memory pointed to by the fields. A deep copy occurs when an object is copied along with the objects to which it refers. &lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Shallow Copy&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Shallow copy is a bit-wise copy of an object. A new object is created that has an exact copy of the values in the original object. If any of the fields of the object are references to other objects, just the reference addresses are copied i.e., only the memory address is copied.&lt;/p&gt;\n    ","\n&lt;p&gt;&apos;ShallowCopy&apos; points to the same location in memory as &apos;Source&apos; does. &apos;DeepCopy&apos; points to a different location in memory, but the contents are the same.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Shallow Cloning:&lt;/strong&gt;&lt;br&gt;\nDefinition: &quot;A shallow copy of an object copies the main object, but doesnt copy the inner objects.&quot; \nWhen a custom object (eg. Employee) has just primitive, String type variables then you use Shallow Cloning. &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;Employee e = new Employee(2, &quot;john cena&quot;);\nEmployee e2=e.clone();\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You return &lt;code&gt;super.clone();&lt;/code&gt; in the overridden clone() method and your job is over.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Deep Cloning&lt;/strong&gt;:&lt;br&gt;\nDefinition: &quot;Unlike the shallow copy, a deep copy is a fully independent copy of an object.&quot;&lt;br&gt;\nMeans when an Employee object holds another custom object:  &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;Employee e = new Employee(2, &quot;john cena&quot;, new Address(12, &quot;West Newbury&quot;, &quot;Massachusetts&quot;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Then you have to write the code to clone the &apos;Address&apos; object as well in the overridden clone() method. Otherwise the Address object won&apos;t clone and it causes a bug when you change value of Address in cloned Employee object, which reflects the original one too.&lt;/p&gt;\n    ","\n&lt;p&gt;I would like to give example rather than the formal definition.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;var originalObject = { \n    a : 1, \n    b : 2, \n    c : 3,\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This code shows a &lt;strong&gt;shallow copy&lt;/strong&gt;:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;var copyObject1 = originalObject;\n\nconsole.log(copyObject1.a);         // it will print 1 \nconsole.log(originalObject.a);       // it will also print 1 \ncopyObject1.a = 4; \nconsole.log(copyObject1.a);           //now it will print 4 \nconsole.log(originalObject.a);       // now it will also print 4\n\nvar copyObject2 = Object.assign({}, originalObject);\n\nconsole.log(copyObject2.a);        // it will print 1 \nconsole.log(originalObject.a);      // it will also print 1 \ncopyObject2.a = 4; \nconsole.log(copyObject2.a);        // now it will print 4 \nconsole.log(originalObject.a);      // now it will print 1\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This code shows a &lt;strong&gt;deep copy&lt;/strong&gt;:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;var copyObject2 = Object.assign({}, originalObject);\n\nconsole.log(copyObject2.a);        // it will print 1 \nconsole.log(originalObject.a);      // it will also print 1 \ncopyObject2.a = 4; \nconsole.log(copyObject2.a);        // now it will print 4 \nconsole.log(originalObject.a);      // !! now it will print 1 !!\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;pre&gt;&lt;code&gt;var source = { firstName=&quot;Jane&quot;, lastname=&quot;Jones&quot; };\nvar shallow = ShallowCopyOf(source);\nvar deep = DeepCopyOf(source);\nsource.lastName = &quot;Smith&quot;;\nWriteLine(source.lastName); // prints Smith\nWriteLine(shallow.lastName); // prints Smith\nWriteLine(deep.lastName); // prints Jones\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Shallow Copy&lt;/strong&gt;- Reference variable inside original and shallow-copied objects have reference to &lt;strong&gt;common&lt;/strong&gt; object.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Deep Copy&lt;/strong&gt;- Reference variable inside original and deep-copied objects have reference to &lt;strong&gt;different&lt;/strong&gt; object.&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;clone always does shallow copy.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code&gt;public class Language implements Cloneable{\n    \n    String name;\n    public Language(String name){\n        this.name=name;\n    }\n    \n    public String getName() {\n        return name;\n    }\n    \n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;main class is following-&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;public static void main(String args[]) throws ClassNotFoundException, CloneNotSupportedException{\n\n      ArrayList&amp;lt;Language&amp;gt; list=new ArrayList&amp;lt;Language&amp;gt;();\n      list.add(new Language(&quot;C&quot;));\n      list.add(new Language(&quot;JAVA&quot;));\n\n      ArrayList&amp;lt;Language&amp;gt; shallow=(ArrayList&amp;lt;Language&amp;gt;) list.clone();\n      //We used here clone since this always shallow copied.\n\n      System.out.println(list==shallow);\n      \n      for(int i=0;i&amp;lt;list.size();i++)\n      System.out.println(list.get(i)==shallow.get(i));//true\n      \n      ArrayList&amp;lt;Language&amp;gt; deep=new ArrayList&amp;lt;Language&amp;gt;();\n      for(Language language:list){\n          deep.add((Language) language.clone());\n      }\n      System.out.println(list==deep);\n      for(int i=0;i&amp;lt;list.size();i++)\n          System.out.println(list.get(i)==deep.get(i));//false\n      \n} \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;OutPut of above will be-&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;false true  true&lt;/p&gt;\n&lt;p&gt;false false false&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Any change made in origional object will reflect in shallow object not in deep object.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;  list.get(0).name=&quot;ViSuaLBaSiC&quot;;\n  System.out.println(shallow.get(0).getName()+&quot;  &quot;+deep.get(0).getName());\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;OutPut-&lt;/strong&gt; ViSuaLBaSiC    C&lt;/p&gt;\n    ","\n&lt;p&gt;Imagine there are two arrays called arr1 and arr2. &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;arr1 = arr2;   //shallow copy\narr1 = arr2.clone(); //deep copy\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;In Simple Terms, a Shallow Copy is similar to Call By Reference and a Deep Copy is similar to Call By Value&lt;/p&gt;\n\n&lt;p&gt;In Call By Reference, Both formal and actual parameters of a function refers to same memory location and the value.&lt;/p&gt;\n\n&lt;p&gt;In Call By Value, Both formal and actual parameters of a functions refers to different memory location but having the same value.&lt;/p&gt;\n    ","\n&lt;p&gt;A shallow copy constructs a new compound object and insert its references into it to the original object.&lt;/p&gt;\n\n&lt;p&gt;Unlike shallow copy, deepcopy constructs new compound object and also inserts copies of the original objects of original compound object.&lt;/p&gt;\n\n&lt;p&gt;Lets take an example.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;import copy\nx =[1,[2]]\ny=copy.copy(x)\nz= copy.deepcopy(x)\nprint(y is z)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Above code prints FALSE.&lt;/p&gt;\n\n&lt;p&gt;Let see how.&lt;/p&gt;\n\n&lt;p&gt;Original compound object &lt;code&gt;x=[1,[2]]&lt;/code&gt; (called as compound because it has object inside object (Inception))&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/QtsjW.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/QtsjW.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;as you can see in the image, there is a list inside list.&lt;/p&gt;\n\n&lt;p&gt;Then we create a shallow copy of it using &lt;code&gt;y = copy.copy(x)&lt;/code&gt;. What python does here is, it will create a new compound object but objects inside them are pointing to the orignal objects.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/QLeDN.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/QLeDN.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;In the image it has created a new copy for outer list. but the inner list remains same as the original one.&lt;/p&gt;\n\n&lt;p&gt;Now we create deepcopy of it using &lt;code&gt;z = copy.deepcopy(x)&lt;/code&gt;. what python does here is, it will create new object for outer list as well as inner list. as shown in the image below (red highlighted).&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/4fYHO.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/4fYHO.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;At the end code prints &lt;code&gt;False&lt;/code&gt;, as y and z are not same objects.&lt;/p&gt;\n\n&lt;p&gt;HTH.&lt;/p&gt;\n    ","\n&lt;pre&gt;&lt;code&gt;struct sample\n{\n    char * ptr;\n}\nvoid shallowcpy(sample &amp;amp; dest, sample &amp;amp; src)\n{\n    dest.ptr=src.ptr;\n}\nvoid deepcpy(sample &amp;amp; dest, sample &amp;amp; src)\n{\n    dest.ptr=malloc(strlen(src.ptr)+1);\n    memcpy(dest.ptr,src.ptr);\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;To add more to other answers, &lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;a Shallow Copy of an object performs copy by value for value types\nbased properties, and copy by reference for reference types based properties.&lt;/li&gt;\n&lt;li&gt;a Deep Copy of an object performs copy by value for value types based\nproperties, as well as copy by value for reference types based\nproperties deep in the hierarchy (of reference types)&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;Shallow copy will not create new reference but deep copy will create the new reference.&lt;/p&gt;\n\n&lt;p&gt;Here is the program to explain the deep and shallow copy.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;DeepAndShollowCopy&lt;/span&gt; {\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; id;\n    String name;\n    List&amp;lt;String&amp;gt; testlist = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ArrayList&lt;/span&gt;&amp;lt;&amp;gt;();\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;/*\n    // To performing Shallow Copy \n    // Note: Here we are not creating any references. \n      public DeepAndShollowCopy(int id, String name, List&amp;lt;String&amp;gt;testlist)\n       { \n\n       System.out.println(&quot;Shallow Copy for Object initialization&quot;);\n       this.id = id; \n       this.name = name; \n       this.testlist = testlist; \n\n       }\n    */&lt;/span&gt;  \n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// To performing Deep Copy &lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Note: Here we are creating one references( Al arraylist object ). &lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;DeepAndShollowCopy&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; id, String name, List&amp;lt;String&amp;gt; testlist)&lt;/span&gt; {\n        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Deep Copy for Object initialization&quot;&lt;/span&gt;);\n        &lt;span class=&quot;hljs-built_in&quot;&gt;this&lt;/span&gt;.id = id;\n        &lt;span class=&quot;hljs-built_in&quot;&gt;this&lt;/span&gt;.name = name;\n        String item;\n        List&amp;lt;String&amp;gt; Al = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ArrayList&lt;/span&gt;&amp;lt;&amp;gt;();\n        Iterator&amp;lt;String&amp;gt; itr = testlist.iterator();\n        &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (itr.hasNext()) {\n            item = itr.next();\n            Al.add(item);\n        }\n        &lt;span class=&quot;hljs-built_in&quot;&gt;this&lt;/span&gt;.testlist = Al;\n    }\n\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; {\n        List&amp;lt;String&amp;gt; list = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ArrayList&lt;/span&gt;&amp;lt;&amp;gt;();\n        list.add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Java&quot;&lt;/span&gt;);\n        list.add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Oracle&quot;&lt;/span&gt;);\n        list.add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;C++&quot;&lt;/span&gt;);\n        DeepAndShollowCopy copy=&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;DeepAndShollowCopy&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;Testing&quot;&lt;/span&gt;, list);\n        System.out.println(copy.toString());\n    }\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title function_&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;DeepAndShollowCopy [id=&quot;&lt;/span&gt; + id + &lt;span class=&quot;hljs-string&quot;&gt;&quot;, name=&quot;&lt;/span&gt; + name + &lt;span class=&quot;hljs-string&quot;&gt;&quot;, testlist=&quot;&lt;/span&gt; + testlist + &lt;span class=&quot;hljs-string&quot;&gt;&quot;]&quot;&lt;/span&gt;;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Taken from [blog]: &lt;a href=&quot;http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html&quot; rel=&quot;nofollow&quot;&gt;http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Deep copy&lt;/strong&gt; involves using the contents of one object to create another instance of the same class. In a deep copy, the two objects may contain ht same information but the target object will have its own buffers and resources. the destruction of either object will not affect the remaining object. The overloaded assignment operator would create a deep copy of objects.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Shallow copy&lt;/strong&gt; involves copying the contents of one object into another instance of the same class thus creating a mirror image. Owing to straight copying of references and pointers, the two objects will share the same externally contained contents of the other object to be unpredictable.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Explanation:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Using a copy constructor we simply copy the data values member by member. This method of copying is called shallow copy. If the object is a simple class, comprised of built in types and no pointers this would be acceptable. This function would use the values and the objects and its behavior would not be altered with a shallow copy, only the addresses of pointers that are members are copied and not the value the address is pointing to. The data values of the object would then be inadvertently altered by the function. When the function goes out of scope, the copy of the object with all its data is popped off the stack.&lt;/p&gt;\n\n&lt;p&gt;If the object has any pointers a deep copy needs to be executed. With the deep copy of an object, memory is allocated for the object in free store and the elements pointed to are copied. A deep copy is used for objects that are returned from a function.&lt;/p&gt;\n    ","\n&lt;p&gt;I came to understand from the following lines.&lt;/p&gt;\n\n&lt;p&gt;Shallow copy copies an object &lt;strong&gt;value type&lt;/strong&gt;(int, float, bool) fields in to target object and object&apos;s reference types(string, class etc) are copied as &lt;strong&gt;references&lt;/strong&gt; in target object. In this target reference types will be pointing to the memory location of source object.&lt;/p&gt;\n\n&lt;p&gt;Deep copy copies an object&apos;s value and reference types into a complete new copy of the target objects. This means both the value types and reference types will be allocated a new memory locations.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Shallow&lt;/strong&gt; copying is creating a new object and then copying the non-static fields of the current object to the new object. If a field is a value type --&amp;gt; a bit-by-bit copy of the field is performed; for a &lt;strong&gt;reference type&lt;/strong&gt; --&amp;gt; the reference is copied but the referred object is not; therefore the original object and its clone refer to the same object.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Deep&lt;/strong&gt; copy is creating a new object and then copying the nonstatic fields of the current object to the new object. If a field is a &lt;strong&gt;value type&lt;/strong&gt; --&amp;gt; a bit-by-bit copy of the field is performed. If a field is a &lt;strong&gt;reference type&lt;/strong&gt; --&amp;gt; a new copy of the referred object is performed. The classes to be cloned must be flagged as [Serializable].&lt;/p&gt;\n    ","\n&lt;p&gt;Copying ararys :&lt;/p&gt;\n\n&lt;p&gt;Array is a class, which means it is reference type so array1 = array2 results\nin two variables that reference the same array.&lt;/p&gt;\n\n&lt;p&gt;But look at this example:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;  static void Main()\n    {\n        int[] arr1 = new int[] { 1, 2, 3, 4, 5 }; \n        int[] arr2 = new int[] { 6, 7, 8, 9, 0 };\n\n        Console.WriteLine(arr1[2] + &quot; &quot; + arr2[2]);\n        arr2 = arr1;\n        Console.WriteLine(arr1[2] + &quot; &quot; + arr2[2]); \n        arr2 = (int[])arr1.Clone();\n        arr1[2] = 12;\n        Console.WriteLine(arr1[2] + &quot; &quot; + arr2[2]);\n    }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;shallow clone&lt;/strong&gt; means that only the memory represented by the cloned array is copied.  &lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;If  the  array  contains  value  type  objects,  the  values are copied&lt;/strong&gt;; &lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;if the array contains reference type, only the references are copied - so as a result there are two arrays whose members reference the same objects&lt;/strong&gt;. &lt;/p&gt;\n\n&lt;p&gt;To create a deep copywhere reference type are duplicated, you must loop through the array and clone each element manually. &lt;/p&gt;\n    ","\n&lt;p&gt;The copy constructor is used to initialize the new object with the previously created object of the same class. By default compiler wrote a shallow copy. Shallow copy works fine when dynamic memory allocation is not involved because when dynamic memory allocation is involved then both objects will points towards the same memory location in a heap, Therefore to remove this problem we wrote deep copy so both objects have their own copy of attributes in a memory.\nIn order to read the details with complete examples and explanations you could see the article &lt;a href=&quot;http://www.hellgeeks.com/constructors-and-destructors/&quot; rel=&quot;nofollow&quot;&gt;C++ constructors&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;To add just a little more for confusion between shallow copy and simply assign a new variable name to list.&lt;/p&gt;\n\n&lt;p&gt;&quot;Say we have:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;x = [\n    [1,2,3],\n    [4,5,6],\n    ]\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This statement creates 3 lists: 2 inner lists and one outer list. A reference to the outer list is then made available under the name x. If we do&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;y = x\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;no data gets copied. We still have the same 3 lists in memory somewhere. All this did is make the outer list available under the name y, in addition to its previous name x. If we do&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;y = list(x)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;y = x[:]\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This creates a new list with the same contents as x. List x contained a reference to the 2 inner lists, so the new list will also contain a reference to those same 2 inner lists. Only one list is copiedthe outer list.\nNow there are 4 lists in memory, the two inner lists, the outer list, and the copy of the outer list. The original outer list is available under the name x, and the new outer list is made available under the name y.&lt;/p&gt;\n\n&lt;p&gt;The inner lists have not been copied! You can access and edit the inner lists from either x or y at this point!&lt;/p&gt;\n\n&lt;p&gt;If you have a two dimensional (or higher) list, or any kind of nested data structure, and you want to make a full copy of everything, then you want to use the deepcopy() function in the copy module. Your solution also works for 2-D lists, as iterates over the items in the outer list and makes a copy of each of them, then builds a new outer list for all the inner copies.&quot;&lt;/p&gt;\n\n&lt;p&gt;source: &lt;a href=&quot;https://www.reddit.com/r/learnpython/comments/1afldr/why_is_copying_a_list_so_damn_difficult_in_python/&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://www.reddit.com/r/learnpython/comments/1afldr/why_is_copying_a_list_so_damn_difficult_in_python/&lt;/a&gt;&lt;/p&gt;\n    "]},"randomTags":[{"name":"kill","slug":"kill"},{"name":"event-delegation","slug":"event-delegation"},{"name":"client-side","slug":"client-side"},{"name":"model-view-controller","slug":"model-view-controller"},{"name":"dom","slug":"dom"},{"name":"winforms","slug":"winforms"},{"name":"application-state","slug":"application-state"},{"name":"dynamic-allocation","slug":"dynamic-allocation"},{"name":"move-semantics","slug":"move-semantics"},{"name":"cartesian-product","slug":"cartesian-product"},{"name":"pseudo-element","slug":"pseudo-element"},{"name":"srand","slug":"srand"},{"name":"shadowing","slug":"shadowing"},{"name":"memory-management","slug":"memory-management"},{"name":"prepared-statement","slug":"prepared-statement"},{"name":"python-decorators","slug":"python-decorators"},{"name":"static","slug":"static"},{"name":"promise","slug":"promise"},{"name":"null","slug":"null"},{"name":"language-lawyer","slug":"language-lawyer"}]},"__N_SSG":true}