{"pageProps":{"data":{"count":1,"rows":[{"answer":["\n&lt;h1&gt;The problem&lt;/h1&gt;\n&lt;p&gt;C++ includes useful generic functions like &lt;code&gt;std::for_each&lt;/code&gt; and &lt;code&gt;std::transform&lt;/code&gt;, which can be very handy. Unfortunately they can also be quite cumbersome to use, particularly if the &lt;a href=&quot;https://stackoverflow.com/questions/356950/c-functors-and-their-uses&quot;&gt;functor&lt;/a&gt; you would like to apply is unique to the particular function.&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;f&lt;/span&gt; {\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{\n      &lt;span class=&quot;hljs-comment&quot;&gt;// do something&lt;/span&gt;\n    }\n  };\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(std::vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; v)&lt;/span&gt; &lt;/span&gt;{\n  f f;\n  std::for_each(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(), f);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;If you only use &lt;code&gt;f&lt;/code&gt; once and in that specific place it seems overkill to be writing a whole class just to do something trivial and one off.&lt;/p&gt;\n&lt;p&gt;In C++03 you might be tempted to write something like the following, to keep the functor local:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;func2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(std::vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; v)&lt;/span&gt; &lt;/span&gt;{\n  &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{\n       &lt;span class=&quot;hljs-comment&quot;&gt;// do something&lt;/span&gt;\n    }\n  } f;\n  std::for_each(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(), f);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;however this is not allowed, &lt;code&gt;f&lt;/code&gt; cannot be passed to a &lt;a href=&quot;https://en.cppreference.com/w/cpp/language/function_template&quot; rel=&quot;noreferrer&quot;&gt;template&lt;/a&gt; function in C++03.&lt;/p&gt;\n&lt;h1&gt;The new solution&lt;/h1&gt;\n&lt;p&gt;C++11 introduces lambdas allow you to write an inline, anonymous functor to replace the &lt;code&gt;struct f&lt;/code&gt;. For small simple examples this can be cleaner to read (it keeps everything in one place) and potentially simpler to maintain, for example in the simplest form:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;func3&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(std::vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; v)&lt;/span&gt; &lt;/span&gt;{\n  std::for_each(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(), [](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;) { &lt;span class=&quot;hljs-comment&quot;&gt;/* do something here*/&lt;/span&gt; });\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Lambda functions are just syntactic sugar for anonymous functors.&lt;/p&gt;\n&lt;h2&gt;Return types&lt;/h2&gt;\n&lt;p&gt;In simple cases the return type of the lambda is deduced for you, e.g.:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;func4&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(std::vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt;&amp;gt;&amp;amp; v)&lt;/span&gt; &lt;/span&gt;{\n  std::&lt;span class=&quot;hljs-built_in&quot;&gt;transform&lt;/span&gt;(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(),\n                 [](&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; d) { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; d &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;0.00001&lt;/span&gt; ? &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; : d; }\n                 );\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;however when you start to write more complex lambdas you will quickly encounter cases where the return type cannot be deduced by the compiler, e.g.:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;func4&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(std::vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt;&amp;gt;&amp;amp; v)&lt;/span&gt; &lt;/span&gt;{\n    std::&lt;span class=&quot;hljs-built_in&quot;&gt;transform&lt;/span&gt;(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(),\n        [](&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; d) {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (d &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;0.0001&lt;/span&gt;) {\n                &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n            } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {\n                &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; d;\n            }\n        });\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;To resolve this you are allowed to explicitly specify a return type for a lambda function, using &lt;code&gt;-&amp;gt; T&lt;/code&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;func4&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(std::vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt;&amp;gt;&amp;amp; v)&lt;/span&gt; &lt;/span&gt;{\n    std::&lt;span class=&quot;hljs-built_in&quot;&gt;transform&lt;/span&gt;(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(),\n        [](&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; d) -&amp;gt; &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (d &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;0.0001&lt;/span&gt;) {\n                &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n            } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {\n                &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; d;\n            }\n        });\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2&gt;&quot;Capturing&quot; variables&lt;/h2&gt;\n&lt;p&gt;So far we&apos;ve not used anything other than what was passed to the lambda within it, but we can also use other variables, within the lambda. If you want to access other variables you can use the capture clause (the &lt;code&gt;[]&lt;/code&gt; of the expression), which has so far been unused in these examples, e.g.:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;func5&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(std::vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt;&amp;gt;&amp;amp; v, &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt;&amp;amp; epsilon)&lt;/span&gt; &lt;/span&gt;{\n    std::&lt;span class=&quot;hljs-built_in&quot;&gt;transform&lt;/span&gt;(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(),\n        [epsilon](&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; d) -&amp;gt; &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (d &amp;lt; epsilon) {\n                &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n            } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {\n                &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; d;\n            }\n        });\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;You can capture by both reference and value, which you can specify using &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;=&lt;/code&gt; respectively:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;[&amp;amp;epsilon, zeta]&lt;/code&gt; captures epsilon by reference and zeta by value&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;[&amp;amp;]&lt;/code&gt; captures all variables used in the lambda by reference&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;[=]&lt;/code&gt; captures all variables used in the lambda by value&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;[&amp;amp;, epsilon]&lt;/code&gt; captures all variables used in the lambda by reference but captures epsilon by value&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;[=, &amp;amp;epsilon]&lt;/code&gt; captures all variables used in the lambda by value but captures epsilon by reference&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;The generated &lt;code&gt;operator()&lt;/code&gt; is &lt;code&gt;const&lt;/code&gt; by default, with the implication that captures will be &lt;code&gt;const&lt;/code&gt; when you access them by default. This has the effect that each call with the same input would produce the same result, however you can &lt;a href=&quot;https://stackoverflow.com/questions/5501959/why-does-c0xs-lambda-require-mutable-keyword-for-capture-by-value-by-defaul&quot;&gt;mark the lambda as &lt;code&gt;mutable&lt;/code&gt;&lt;/a&gt; to request that the &lt;code&gt;operator()&lt;/code&gt; that is produced is not &lt;code&gt;const&lt;/code&gt;.&lt;/p&gt;\n\n    ","\n&lt;h1&gt;What is a lambda function?&lt;/h1&gt;\n\n&lt;p&gt;The C++ concept of a lambda function originates in the lambda calculus and functional programming. A lambda is an unnamed function that is useful (in actual programming, not theory) for short snippets of code that are impossible to reuse and are not worth naming.&lt;/p&gt;\n\n&lt;p&gt;In C++ a lambda function is defined like this&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;[]() { } &lt;span class=&quot;hljs-comment&quot;&gt;// barebone lambda&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or in all its glory&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;[]() &lt;span class=&quot;hljs-keyword&quot;&gt;mutable&lt;/span&gt; -&amp;gt; T { } &lt;span class=&quot;hljs-comment&quot;&gt;// T is the return type, still lacking throw()&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;[]&lt;/code&gt; is the capture list, &lt;code&gt;()&lt;/code&gt; the argument list and &lt;code&gt;{}&lt;/code&gt; the function body.&lt;/p&gt;\n\n&lt;h2&gt;The capture list&lt;/h2&gt;\n\n&lt;p&gt;The capture list defines what from the outside of the lambda should be available inside the function body and how.\nIt can be either:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;a value: [x]&lt;/li&gt;\n&lt;li&gt;a reference [&amp;amp;x]&lt;/li&gt;\n&lt;li&gt;any variable currently in scope by reference [&amp;amp;]&lt;/li&gt;\n&lt;li&gt;same as 3, but by value [=]&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;You can mix any of the above in a comma separated list &lt;code&gt;[x, &amp;amp;y]&lt;/code&gt;.&lt;/p&gt;\n\n&lt;h2&gt;The argument list&lt;/h2&gt;\n\n&lt;p&gt;The argument list is the same as in any other C++ function. &lt;/p&gt;\n\n&lt;h2&gt;The function body&lt;/h2&gt;\n\n&lt;p&gt;The code that will be executed when the lambda is actually called.&lt;/p&gt;\n\n&lt;h2&gt;Return type deduction&lt;/h2&gt;\n\n&lt;p&gt;If a lambda has only one return statement, the return type can be omitted and has the implicit type of &lt;code&gt;decltype(return_statement)&lt;/code&gt;.&lt;/p&gt;\n\n&lt;h2&gt;Mutable&lt;/h2&gt;\n\n&lt;p&gt;If a lambda is marked mutable (e.g. &lt;code&gt;[]() mutable { }&lt;/code&gt;) it is allowed to mutate the values that have been captured by value.&lt;/p&gt;\n\n&lt;h1&gt;Use cases&lt;/h1&gt;\n\n&lt;p&gt;The library defined by the ISO standard benefits heavily from lambdas and raises the usability several bars as now users don&apos;t have to clutter their code with small functors in some accessible scope.&lt;/p&gt;\n\n&lt;h1&gt;C++14&lt;/h1&gt;\n\n&lt;p&gt;In C++14 lambdas have been extended by various proposals.&lt;/p&gt;\n\n&lt;h2&gt;Initialized Lambda Captures&lt;/h2&gt;\n\n&lt;p&gt;An element of the capture list can now be initialized with &lt;code&gt;=&lt;/code&gt;. This allows renaming of variables and to capture by moving. An example taken from the standard:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; y = [&amp;amp;r = x, x = x+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]()-&amp;gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; {\n            r += &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; x+&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;\n         }();  &lt;span class=&quot;hljs-comment&quot;&gt;// Updates ::x to 6, and initializes y to 7.&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and one taken from Wikipedia showing how to capture with &lt;code&gt;std::move&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; ptr = std::&lt;span class=&quot;hljs-built_in&quot;&gt;make_unique&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;// See below for std::make_unique&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; lambda = [ptr = std::&lt;span class=&quot;hljs-built_in&quot;&gt;move&lt;/span&gt;(ptr)] {&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; *ptr;};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h2&gt;Generic Lambdas&lt;/h2&gt;\n\n&lt;p&gt;Lambdas can now be generic (&lt;code&gt;auto&lt;/code&gt; would be equivalent to &lt;code&gt;T&lt;/code&gt; here if\n&lt;code&gt;T&lt;/code&gt; were a type template argument somewhere in the surrounding scope):&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; lambda = [](&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; x, &lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; y) {&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; x + y;};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h2&gt;Improved Return Type Deduction&lt;/h2&gt;\n\n&lt;p&gt;C++14 allows deduced return types for every function and does not restrict it to functions of the form &lt;code&gt;return expression;&lt;/code&gt;. This is also extended to lambdas.&lt;/p&gt;\n    ","\n&lt;p&gt;Lambda expressions are typically used to encapsulate algorithms so that they can be passed to another function.  However, &lt;strong&gt;it is possible to execute a lambda immediately upon definition&lt;/strong&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;[&amp;amp;](){ ...your code... }(); &lt;span class=&quot;hljs-comment&quot;&gt;// immediately executed lambda expression&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;is functionally equivalent to&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;{ ...your code... } &lt;span class=&quot;hljs-comment&quot;&gt;// simple code block&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This makes lambda expressions &lt;strong&gt;a powerful tool for refactoring complex functions&lt;/strong&gt;.  You start by wrapping a code section in a lambda function as shown above.  The process of explicit parameterization can then be performed gradually with intermediate testing after each step.  Once you have the code-block fully parameterized (as demonstrated by the removal of the &lt;code&gt;&amp;amp;&lt;/code&gt;), you can move the code to an external location and make it a normal function.&lt;/p&gt;\n\n&lt;p&gt;Similarly, you can use lambda expressions to &lt;strong&gt;initialize variables based on the result of an algorithm&lt;/strong&gt;...&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a = []( &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b ){ &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; r=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (b&amp;gt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) r*=b--; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; r; }(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;// 5!&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;As &lt;strong&gt;a way of partitioning your program logic&lt;/strong&gt;, you might even find it useful to pass a lambda expression as an argument to another lambda expression...&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;[&amp;amp;]( std::function&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;void&lt;/span&gt;()&amp;gt; algorithm ) &lt;span class=&quot;hljs-comment&quot;&gt;// wrapper section&lt;/span&gt;\n   {\n   ...your wrapper code...\n   &lt;span class=&quot;hljs-built_in&quot;&gt;algorithm&lt;/span&gt;();\n   ...your wrapper code...\n   }\n([&amp;amp;]() &lt;span class=&quot;hljs-comment&quot;&gt;// algorithm section&lt;/span&gt;\n   {\n   ...your algorithm code...\n   });\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Lambda expressions also let you create named &lt;a href=&quot;http://en.wikipedia.org/wiki/Nested_function&quot; rel=&quot;noreferrer&quot;&gt;&lt;strong&gt;nested functions&lt;/strong&gt;&lt;/a&gt;, which can be a convenient way of avoiding duplicate logic.  Using named lambdas also tends to be a little easier on the eyes (compared to anonymous inline lambdas) when passing a non-trivial function as a parameter to another function.  &lt;em&gt;Note: don&apos;t forget the semicolon after the closing curly brace.&lt;/em&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; algorithm = [&amp;amp;]( &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; x, &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; m, &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; b ) -&amp;gt; &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt;\n   {\n   &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; m*x+b;\n   };\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a=&lt;span class=&quot;hljs-built_in&quot;&gt;algorithm&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;), b=&lt;span class=&quot;hljs-built_in&quot;&gt;algorithm&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;If subsequent profiling reveals significant initialization overhead for the function object, you might choose to rewrite this as a normal function.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Answers&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Q: What is a lambda expression in C++11?&lt;/p&gt;\n\n&lt;p&gt;A: Under the hood, it is the object of an autogenerated class with overloading &lt;strong&gt;operator() const&lt;/strong&gt;. Such object is called &lt;em&gt;closure&lt;/em&gt; and created by compiler.\nThis &apos;closure&apos; concept is near with the bind concept from C++11. \nBut lambdas typically generate better code. And calls through closures allow full inlining.&lt;/p&gt;\n\n&lt;p&gt;Q: When would I use one?&lt;/p&gt;\n\n&lt;p&gt;A: To define &quot;simple and small logic&quot; and ask compiler perform generation from previous question. You give a compiler some expressions which you want to be inside operator(). All other stuff compiler will generate to you.&lt;/p&gt;\n\n&lt;p&gt;Q: What class of problem do they solve that wasn&apos;t possible prior to their introduction?&lt;/p&gt;\n\n&lt;p&gt;A: It is some kind of syntax sugar like operators overloading instead of functions for custom &lt;em&gt;add, subrtact&lt;/em&gt; operations...But it save more lines of unneeded code to wrap 1-3 lines of real logic to some classes, and etc.! Some engineers think that if the number of lines is smaller then there is a less chance to make errors in it (I&apos;m also think so)&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Example of usage&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; x = [=](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; arg1){&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%i&quot;&lt;/span&gt;, arg1); };\n&lt;span class=&quot;hljs-built_in&quot;&gt;void&lt;/span&gt;(*f)(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;) = x;\n&lt;span class=&quot;hljs-built_in&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);\n&lt;span class=&quot;hljs-built_in&quot;&gt;x&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;Extras about lambdas, not covered by question. Ignore this section if you&apos;re not interest&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;1. Captured values. What you can to capture&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;1.1. You can reference to a variable with static storage duration in lambdas. They all are captured.&lt;/p&gt;\n\n&lt;p&gt;1.2. You can use lambda for capture values &quot;by value&quot;. In such case captured vars will be copied to the function object (closure).&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;[captureVar1,captureVar2](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; arg1){}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;1.3. You can capture be reference. &amp;amp; -- in this context mean reference, not pointers.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;   [&amp;amp;captureVar1,&amp;amp;captureVar2](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; arg1){}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;1.4. It exists notation to capture all non-static vars by value, or by reference&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;  [=](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; arg1){} &lt;span class=&quot;hljs-comment&quot;&gt;// capture all not-static vars by value&lt;/span&gt;\n\n  [&amp;amp;](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; arg1){} &lt;span class=&quot;hljs-comment&quot;&gt;// capture all not-static vars by reference&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;1.5.  It exists notation to capture all non-static vars by value, or by reference and specify smth. more.\nExamples:\nCapture all not-static vars by value, but by reference capture Param2&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;[=,&amp;amp;Param2](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; arg1){} \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Capture all not-static vars by reference, but by value capture Param2&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;[&amp;amp;,Param2](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; arg1){} \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;em&gt;2. Return type deduction&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;2.1. Lambda return type can be deduced if lambda is one expression. Or you can explicitly specify it.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;[=](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; arg1)-&amp;gt;trailing_return_type{&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;trailing_return_type&lt;/span&gt;();}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;If lambda has more then one expression, then return type must be specified via trailing return type. \n  Also, similar syntax can be applied to auto functions and member-functions&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;3. Captured values. What you can not capture&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;3.1. You can capture only local vars, not member variable of the object.&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;4. Ð¡onversions&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;4.1 !! Lambda is not a function pointer and it is not an anonymous function, but &lt;strong&gt;capture-less&lt;/strong&gt; lambdas can be implicitly converted to a function pointer.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;p.s.&lt;/strong&gt; &lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;More about lambda grammar information can be found in Working draft for Programming Language C++ #337, 2012-01-16, 5.1.2. Lambda Expressions, p.88&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;In C++14 the extra feature which has named as &quot;init capture&quot; have been added. It allow to perform arbitarily declaration of closure data members:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; toFloat = [](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; value) { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;float&lt;/span&gt;(value);};\n&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; interpolate = [min = &lt;span class=&quot;hljs-built_in&quot;&gt;toFloat&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;), max = &lt;span class=&quot;hljs-built_in&quot;&gt;toFloat&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;255&lt;/span&gt;)](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; value)-&amp;gt;&lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt; { &lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; (value - min) / (max - min);};\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;/ol&gt;\n    ","\n&lt;p&gt;A lambda function is an anonymous function that you create in-line. It can capture variables as some have explained, (e.g. &lt;a href=&quot;http://www.stroustrup.com/C++11FAQ.html#lambda&quot;&gt;http://www.stroustrup.com/C++11FAQ.html#lambda&lt;/a&gt;) but there are some limitations. For example, if there&apos;s a callback interface like this, &lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; (*f)(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;))&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-built_in&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;you can write a function on the spot to use it like the one passed to apply below:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; col=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-built_in&quot;&gt;apply&lt;/span&gt;([](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; data) {\n        cout &amp;lt;&amp;lt; data &amp;lt;&amp;lt; ((++col % &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;) ? &lt;span class=&quot;hljs-string&quot;&gt;&apos; &apos;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;);\n    });\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;But you can&apos;t do this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; col=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;apply&lt;/span&gt;([&amp;amp;col,n](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; data) {\n        cout &amp;lt;&amp;lt; data &amp;lt;&amp;lt; ((++col % &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;) ? &lt;span class=&quot;hljs-string&quot;&gt;&apos; &apos;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;);\n    });\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;because of limitations in the C++11 standard. If you want to use captures, you have to rely on the library and &lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;functional&amp;gt;&lt;/span&gt; &lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;(or some other STL library like algorithm to get it indirectly) and then work with std::function instead of passing normal functions as parameters like this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;functional&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(std::function&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;)&amp;gt; f)&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-built_in&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;);\n}\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; width)&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; col;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;apply&lt;/span&gt;([width,&amp;amp;col](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; data) {\n        cout &amp;lt;&amp;lt; data &amp;lt;&amp;lt; ((++col % width) ? &lt;span class=&quot;hljs-string&quot;&gt;&apos; &apos;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;);\n    });\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;One of the best explanation of &lt;code&gt;lambda expression&lt;/code&gt; is given from author of C++ &lt;strong&gt;Bjarne Stroustrup&lt;/strong&gt; in his book &lt;code&gt;***The C++ Programming Language***&lt;/code&gt; chapter 11 (&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0321563840&quot; rel=&quot;noreferrer&quot;&gt;ISBN-13: 978-0321563842&lt;/a&gt;):&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;code&gt;What is a lambda expression?&lt;/code&gt;&lt;/strong&gt; &lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;A &lt;em&gt;lambda expression&lt;/em&gt;, sometimes also referred to as a &lt;em&gt;lambda&lt;/em&gt;\n  function or (strictly speaking incorrectly, but colloquially) as a\n  &lt;em&gt;lambda&lt;/em&gt;, is a simplified notation for defining and using an &lt;strong&gt;anonymous function object&lt;/strong&gt;. Instead of defining a named class with an operator(), later making an object of that class, and finally\n  invoking it, we can use a shorthand.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;code&gt;When would I use one?&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;This is particularly useful when we want to pass an operation as an\n  argument to an algorithm. In the context of graphical user interfaces\n  (and elsewhere), such operations are often referred to as &lt;em&gt;callbacks&lt;/em&gt;.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;code&gt;What class of problem do they solve that wasn&apos;t possible prior to their introduction?&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Here i guess every action done with lambda expression can be solved without them, but with much more code and much bigger complexity. Lambda expression this is the way of optimization for your code and a way of making it more attractive. As sad by Stroustup :&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;effective ways of optimizing&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;code&gt;Some examples&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;via lambda expression&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;print_modulo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; v, ostream&amp;amp; os, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; m)&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;// output v[i] to os if v[i]%m==0&lt;/span&gt;\n&lt;/span&gt;{\n    for_each(&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(v),&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(v),\n        [&amp;amp;os,m](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x) { \n           &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (x%m==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) os &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;;\n         });\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or via function&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Modulo_print&lt;/span&gt; {\n         ostream&amp;amp; os; &lt;span class=&quot;hljs-comment&quot;&gt;// members to hold the capture list int m;&lt;/span&gt;\n     &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n         &lt;span class=&quot;hljs-built_in&quot;&gt;Modulo_print&lt;/span&gt;(ostream&amp;amp; s, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; mm) :&lt;span class=&quot;hljs-built_in&quot;&gt;os&lt;/span&gt;(s), &lt;span class=&quot;hljs-built_in&quot;&gt;m&lt;/span&gt;(mm) {} \n         &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;\n           &lt;/span&gt;{ \n             &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (x%m==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) os &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;; \n           }\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or even&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;print_modulo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; v, ostream&amp;amp; os, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; m)&lt;/span&gt; \n     &lt;span class=&quot;hljs-comment&quot;&gt;// output v[i] to os if v[i]%m==0&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Modulo_print&lt;/span&gt; {\n        ostream&amp;amp; os; &lt;span class=&quot;hljs-comment&quot;&gt;// members to hold the capture list&lt;/span&gt;\n        &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; m; \n        &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n           &lt;span class=&quot;hljs-built_in&quot;&gt;Modulo_print&lt;/span&gt; (ostream&amp;amp; s, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; mm) :&lt;span class=&quot;hljs-built_in&quot;&gt;os&lt;/span&gt;(s), &lt;span class=&quot;hljs-built_in&quot;&gt;m&lt;/span&gt;(mm) {}\n           &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;\n           &lt;/span&gt;{ \n               &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (x%m==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) os &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;;\n           }\n     };\n     for_each(&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(v),&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(v),Modulo_print{os,m}); \n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;if u need u can name &lt;code&gt;lambda expression&lt;/code&gt; like below:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;print_modulo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; v, ostream&amp;amp; os, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; m)&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// output v[i] to os if v[i]%m==0&lt;/span&gt;\n&lt;/span&gt;{\n      &lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; Modulo_print = [&amp;amp;os,m] (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x) { &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (x%m==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) os &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;; };\n      for_each(&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(v),&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(v),Modulo_print);\n }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Or assume another simple sample&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;TestFunctions::simpleLambda&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; sensitive = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;\n    std::vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt; v = std::&lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;({&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;33&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;});\n\n    &lt;span class=&quot;hljs-built_in&quot;&gt;sort&lt;/span&gt;(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(),v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(),\n         [sensitive](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; y) {\n             &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n%i\\n&quot;&lt;/span&gt;,  x &amp;lt; y);\n             &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; sensitive ? x &amp;lt; y : &lt;span class=&quot;hljs-built_in&quot;&gt;abs&lt;/span&gt;(x) &amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;abs&lt;/span&gt;(y);\n         });\n\n\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;sorted&quot;&lt;/span&gt;);\n    for_each(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(),\n             [](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x) {\n                 &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;x - %i;&quot;&lt;/span&gt;, x);\n             }\n             );\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;will generate next&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;0&lt;/p&gt;\n  \n  &lt;p&gt;1&lt;/p&gt;\n  \n  &lt;p&gt;0&lt;/p&gt;\n  \n  &lt;p&gt;1&lt;/p&gt;\n  \n  &lt;p&gt;0&lt;/p&gt;\n  \n  &lt;p&gt;1&lt;/p&gt;\n  \n  &lt;p&gt;0&lt;/p&gt;\n  \n  &lt;p&gt;1&lt;/p&gt;\n  \n  &lt;p&gt;0&lt;/p&gt;\n  \n  &lt;p&gt;1&lt;/p&gt;\n  \n  &lt;p&gt;0 sortedx - 1;x - 3;x - 4;x - 5;x - 6;x - 7;x - 33;&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;&lt;code&gt;[]&lt;/code&gt; - this is capture list or &lt;code&gt;lambda introducer&lt;/code&gt;: if &lt;code&gt;lambdas&lt;/code&gt; require no access to their local environment we can use it.&lt;/p&gt;\n\n&lt;p&gt;Quote from book:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;The first character of a lambda expression is always &lt;strong&gt;[&lt;/strong&gt;. A lambda\n  introducer can take various forms:&lt;/p&gt;\n  \n  &lt;p&gt; &lt;strong&gt;[]&lt;/strong&gt;: an empty capture list. This\n  implies that no local names from the surrounding context can be used\n  in the lambda body. For such lambda expressions, data is obtained from\n  arguments or from nonlocal variables. &lt;/p&gt;\n  \n  &lt;p&gt; &lt;strong&gt;[&amp;amp;]&lt;/strong&gt;: implicitly capture by\n  reference. All local names can be used. All local variables are\n  accessed by reference.&lt;/p&gt;\n  \n  &lt;p&gt; &lt;strong&gt;[=]&lt;/strong&gt;: implicitly capture by value. All local\n  names can be used. All names refer to copies of the local variables\n  taken at the point of call of the lambda expression.&lt;/p&gt;\n  \n  &lt;p&gt; &lt;strong&gt;[capture-list]:&lt;/strong&gt;  explicit capture; the capture-list is the list of names of local  variables to be captured (i.e., stored in the object) by reference or by value. Variables with names preceded by &amp;amp; are captured by\n  reference. Other variables are captured by value. A capture list can\n  also contain this and names followed by ... as elements. &lt;/p&gt;\n  \n  &lt;p&gt; &lt;strong&gt;[&amp;amp;,  capture-list]&lt;/strong&gt;: implicitly capture by reference all local variables  with names not men- tioned in the list. The capture list can contain  this. Listed names cannot be preceded by &amp;amp;. Variables named in the\n  capture list are captured by value. &lt;/p&gt;\n  \n  &lt;p&gt; &lt;strong&gt;[=, capture-list]&lt;/strong&gt;: implicitly capture by value all local variables with names not mentioned in the  list. The capture list cannot contain this. The listed names must be preceded by &amp;amp;. Vari- ables named in the capture list are captured by  reference. &lt;/p&gt;\n  \n  &lt;p&gt;Note that a local name preceded by &amp;amp; is always captured by\n  reference and a local name not pre- ceded by &amp;amp; is always captured by\n  value. Only capture by reference allows modification of variables in\n  the calling environment.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;code&gt;Additional&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;Lambda expression&lt;/code&gt; format&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/03yye.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/03yye.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Additional references:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Anonymous_function#C.2B.2B_.28since_C.2B.2B11.29&quot; rel=&quot;noreferrer&quot;&gt;Wiki&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf&quot; rel=&quot;noreferrer&quot;&gt;open-std.org&lt;/a&gt;, chapter 5.1.2&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;The lambda&apos;s in c++ are treated as &quot;on the go available function&quot;.\nyes its literally on the go, you define it; use it; and as the parent function scope finishes the lambda function is gone.&lt;/p&gt;\n\n&lt;p&gt;c++ introduced it in c++ 11 and everyone started using it like at every possible place.\nthe example and what is lambda can be find here &lt;a href=&quot;https://en.cppreference.com/w/cpp/language/lambda&quot; rel=&quot;noreferrer&quot;&gt;https://en.cppreference.com/w/cpp/language/lambda&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;em&gt;i will describe which is not there but essential to know for every c++ programmer&lt;/em&gt;&lt;/strong&gt; &lt;/p&gt;\n\n&lt;p&gt;Lambda is not meant to use everywhere and every function cannot be replaced with lambda. It&apos;s also not the fastest one compare to normal function. because it has some overhead which need to be handled by lambda.&lt;/p&gt;\n\n&lt;p&gt;it will surely help in reducing number of lines in some cases.\nit can be basically used for the section of code, which is getting called in same function one or more time and that piece of code is not needed anywhere else so that you can create standalone function for it.&lt;/p&gt;\n\n&lt;p&gt;Below is the basic example of lambda and what happens in background.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;User code:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n  &lt;span class=&quot;hljs-comment&quot;&gt;// Lambda &amp;amp; auto&lt;/span&gt;\n  &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; member=&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; endGame = [=](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b){ &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a+b+member;};\n\n  &lt;span class=&quot;hljs-built_in&quot;&gt;endGame&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;);\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;How compile expands it:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n  &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; member = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;__lambda_6_18&lt;/span&gt;\n  {\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; member;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;: \n    &lt;span class=&quot;hljs-keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;/*constexpr */&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b)&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;\n    &lt;/span&gt;{\n      &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a + b + member;\n    }\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;: __lambda_6_18(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; _member)\n    : member{_member}\n    {}\n\n  };\n\n  __lambda_6_18 endGame = __lambda_6_18{member};\n  endGame.&lt;span class=&quot;hljs-built_in&quot;&gt;operator&lt;/span&gt;()(&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;);\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;so as you can see, what kind of overhead it adds when you use it.\nso its not good idea to use them everywhere.\nit can be used at places where they are applicable.&lt;/p&gt;\n    ","\n&lt;p&gt;Well, one practical use I&apos;ve found out is reducing boiler plate code. For example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;process_z_vec&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; vec)&lt;/span&gt;\n&lt;/span&gt;{\n  &lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; print_2d = [](&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; board, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; bsize)\n  {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i&amp;lt;bsize; i++)\n    {\n      &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; j=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; j&amp;lt;bsize; j++)\n      {\n        cout &amp;lt;&amp;lt; board[bsize*i+j] &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt;;\n      }\n      cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n&quot;&lt;/span&gt;;\n    }\n  };\n  &lt;span class=&quot;hljs-comment&quot;&gt;// Do sth with the vec.&lt;/span&gt;\n  &lt;span class=&quot;hljs-built_in&quot;&gt;print_2d&lt;/span&gt;(vec,x_size);\n  &lt;span class=&quot;hljs-comment&quot;&gt;// Do sth else with the vec.&lt;/span&gt;\n  &lt;span class=&quot;hljs-built_in&quot;&gt;print_2d&lt;/span&gt;(vec,y_size);\n  &lt;span class=&quot;hljs-comment&quot;&gt;//... &lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Without lambda, you may need to do something for different &lt;code&gt;bsize&lt;/code&gt; cases. Of course you could create a function but what if you want to limit the usage within the scope of the soul user function? the nature of lambda fulfills this requirement and I use it for that case.&lt;/p&gt;\n    ","\n&lt;p&gt;C++ 11 introduced lambda expression to allow us write an inline function which can be used for short snippets of code&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;[ capture clause ] (parameters) -&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;-type\n{\n   definition of method\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Generally return-type in lambda expression are evaluated by compiler itself and we dont need to specify that explicitly and -&amp;gt; return-type part can be ignored but in some complex case as in conditional statement, compiler cant make out the return type and we need to specify that.&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// C++ program to demonstrate lambda expression in C++&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// Function to print vector&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;printVector&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt; v)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-comment&quot;&gt;// lambda expression to print vector&lt;/span&gt;\n    for_each(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(), [](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i)\n    {\n        std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt;;\n    });\n    cout &amp;lt;&amp;lt; endl;\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt; v {&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;};\n\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printVector&lt;/span&gt;(v);\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// below snippet find first number greater than 4&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// find_if searches for an element for which&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// function(third argument) returns true&lt;/span&gt;\n    vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;:: iterator p = &lt;span class=&quot;hljs-built_in&quot;&gt;find_if&lt;/span&gt;(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(), [](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i)\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; i &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;;\n    });\n    cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;First number greater than 4 is : &quot;&lt;/span&gt; &amp;lt;&amp;lt; *p &amp;lt;&amp;lt; endl;\n\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// function to sort vector, lambda expression is for sorting in&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// non-decreasing order Compiler can make out return type as&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// bool, but shown here just for explanation&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;sort&lt;/span&gt;(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(), [](&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;amp; a, &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;amp; b) -&amp;gt; &lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a &amp;gt; b;\n    });\n\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printVector&lt;/span&gt;(v);\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// function to count numbers greater than or equal to 5&lt;/span&gt;\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; count_5 = &lt;span class=&quot;hljs-built_in&quot;&gt;count_if&lt;/span&gt;(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(), [](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a)\n    {\n        &lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; (a &amp;gt;= &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;);\n    });\n    cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;The number of elements greater than or equal to 5 is : &quot;&lt;/span&gt;\n        &amp;lt;&amp;lt; count_5 &amp;lt;&amp;lt; endl;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// function for removing duplicate element (after sorting all&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// duplicate comes together)&lt;/span&gt;\n    p = &lt;span class=&quot;hljs-built_in&quot;&gt;unique&lt;/span&gt;(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(), [](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b)\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a == b;\n    });\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// resizing vector to make size equal to total different number&lt;/span&gt;\n    v.&lt;span class=&quot;hljs-built_in&quot;&gt;resize&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;distance&lt;/span&gt;(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), p));\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printVector&lt;/span&gt;(v);\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// accumulate function accumulate the container on the basis of&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// function provided as third argument&lt;/span&gt;\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; arr[] = {&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;};\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; f = &lt;span class=&quot;hljs-built_in&quot;&gt;accumulate&lt;/span&gt;(arr, arr + &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, [](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; j)\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; i * j;\n    });\n\n    cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Factorial of 10 is : &quot;&lt;/span&gt; &amp;lt;&amp;lt; f &amp;lt;&amp;lt; endl;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;//   We can also access function by storing this into variable&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; square = [](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i)\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; i * i;\n    };\n\n    cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Square of 5 is : &quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;square&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;) &amp;lt;&amp;lt; endl;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Output&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;\nFirst number greater than &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; is : &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\nThe number of elements greater than &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; equal to &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; is : &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\nFactorial of &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt; is : &lt;span class=&quot;hljs-number&quot;&gt;3628800&lt;/span&gt;\nSquare of &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; is : &lt;span class=&quot;hljs-number&quot;&gt;25&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;A lambda expression can have more power than an ordinary function by having access to variables from the enclosing scope. We can capture external variables from enclosing scope by three ways :&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Capture by reference&lt;/li&gt;\n&lt;li&gt;Capture by value&lt;/li&gt;\n&lt;li&gt;Capture by both (mixed capture)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;The syntax used for capturing variables :&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;[&amp;amp;] : capture all external variable by reference&lt;/li&gt;\n&lt;li&gt;[=] : capture all external variable by value&lt;/li&gt;\n&lt;li&gt;[a, &amp;amp;b] : capture a by value and b by reference\nA lambda with empty capture clause [ ] can access only those variable which are local to it.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;    &lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; std;\n    \n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n    &lt;/span&gt;{\n        vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt; v1 = {&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;};\n        vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt; v2 = {&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;16&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;};\n    \n        &lt;span class=&quot;hljs-comment&quot;&gt;// access v1 and v2 by reference&lt;/span&gt;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; pushinto = [&amp;amp;] (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; m)\n        {\n            v1.&lt;span class=&quot;hljs-built_in&quot;&gt;push_back&lt;/span&gt;(m);\n            v2.&lt;span class=&quot;hljs-built_in&quot;&gt;push_back&lt;/span&gt;(m);\n        };\n    \n        &lt;span class=&quot;hljs-comment&quot;&gt;// it pushes 20 in both v1 and v2&lt;/span&gt;\n        &lt;span class=&quot;hljs-built_in&quot;&gt;pushinto&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;);\n    \n        &lt;span class=&quot;hljs-comment&quot;&gt;// access v1 by copy&lt;/span&gt;\n        [v1]()\n        {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; p = v1.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(); p != v1.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(); p++)\n            {\n                cout &amp;lt;&amp;lt; *p &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt;;\n            }\n        };\n    \n        &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; N = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;\n    \n        &lt;span class=&quot;hljs-comment&quot;&gt;// below snippet find first number greater than N&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;// [N] denotes, can access only N by value&lt;/span&gt;\n        vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;:: iterator p = &lt;span class=&quot;hljs-built_in&quot;&gt;find_if&lt;/span&gt;(v1.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v1.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(), [N](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i)\n        {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; i &amp;gt; N;\n        });\n    \n        cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;First number greater than 5 is : &quot;&lt;/span&gt; &amp;lt;&amp;lt; *p &amp;lt;&amp;lt; endl;\n    \n        &lt;span class=&quot;hljs-comment&quot;&gt;// function to count numbers greater than or equal to N&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;// [=] denotes, can access all variable&lt;/span&gt;\n        &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; count_N = &lt;span class=&quot;hljs-built_in&quot;&gt;count_if&lt;/span&gt;(v1.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v1.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(), [=](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a)\n        {\n            &lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; (a &amp;gt;= N);\n        });\n    \n        cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;The number of elements greater than or equal to 5 is : &quot;&lt;/span&gt;\n            &amp;lt;&amp;lt; count_N &amp;lt;&amp;lt; endl;\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Output:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;   First number greater than &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; is : &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;\n   The number of elements greater than &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; equal to &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; is : &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;One problem it solves: &lt;a href=&quot;https://stackoverflow.com/questions/31078201/code-simpler-than-lambda-for-a-call-in-constructor-that-uses-an-output-parameter&quot;&gt;Code simpler than lambda for a call in constructor that uses an output parameter function for initializing a const member&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;You can initialize a const member of your class, with a call to a function that sets its value by giving back its output as an output parameter.&lt;/p&gt;\n    "],"comment":["\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;I&apos;ve seen a case where the lambda was very useful: A colleague of me was doing code that has millions of iterations to solve a space optimization problem. The algorithm was much more speedy when using a lambda than a proper function! The compiler is Visual C++ 2013.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/383779/sergiol&quot; title=&quot;3,926 reputation&quot; class=&quot;comment-user&quot;&gt;sergiol&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment75005551_7627098&quot;&gt;&lt;span title=&quot;2017-02-12 20:03:03Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Feb 12, 2017 at 20:03&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Here is another really good reference which explains very well what are lambda expressions in C++: &lt;a href=&quot;https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-160&quot; rel=&quot;nofollow noreferrer&quot;&gt;Microsoft.com: Lambda expressions in C++&lt;/a&gt;. I especially like how well it explains the &lt;i&gt;parts&lt;/i&gt; of a lambda expression, in particular: the &lt;i&gt;capture clause, parameter list, trailing-return-type, and lambda body&lt;/i&gt;.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/4561887/gabriel-staples&quot; title=&quot;22,961 reputation&quot; class=&quot;comment-user&quot;&gt;Gabriel Staples&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment123965102_7627098&quot;&gt;&lt;span title=&quot;2021-11-26 16:03:37Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Nov 26, 2021 at 16:03&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 2 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Yakk you have been trapped. lambdas without a capture have an implicit conversion to function type pointers. the conversion function is &lt;code&gt;const&lt;/code&gt; always...&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/34509/johannes-schaub-litb&quot; title=&quot;482,727 reputation&quot; class=&quot;comment-user&quot;&gt;Johannes Schaub - litb&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment22356477_7627218&quot;&gt;&lt;span title=&quot;2013-03-31 22:17:16Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 31, 2013 at 22:17&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Interesting - I originally thought that lambdas were anonymous &lt;i&gt;functions&lt;/i&gt; rather than functors, and was confused about how captures worked.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/106104/user253751&quot; title=&quot;50,715 reputation&quot; class=&quot;comment-user&quot;&gt;user253751&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment33841567_7627218&quot;&gt;&lt;span title=&quot;2014-03-09 01:39:54Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 9, 2014 at 1:39&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;If you want to use lambdas as variables in your program, you can use:  &lt;code&gt;std::function&amp;lt;double(int, bool)&amp;gt; f = [](int a, bool b) -&amp;gt; double { ... };&lt;/code&gt;  But usually, we let the compiler deduce the type:  &lt;code&gt;auto f = [](int a, bool b) -&amp;gt; double { ... };&lt;/code&gt;  (and don&apos;t forget to &lt;code&gt;#include &amp;lt;functional&amp;gt;&lt;/code&gt;)&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/2678118/evert-heylen&quot; title=&quot;920 reputation&quot; class=&quot;comment-user&quot;&gt;Evert Heylen&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment47281789_7627218&quot;&gt;&lt;span title=&quot;2015-04-10 16:15:38Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 10, 2015 at 16:15&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 3 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;I suppose not everyone understands why &lt;code&gt;return d &amp;lt; 0.00001 ? 0 : d;&lt;/code&gt; is guaranteed to return double, when one of the operands is an integer constant (it is because of an implicit promotion rule of the ?: operator where the 2nd and 3rd operand are balanced against each other through the usual arithmetic conversions no matter which one that gets picked). Changing to &lt;code&gt;0.0 : d&lt;/code&gt; would perhaps make the example easier to understand.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/584518/lundin&quot; title=&quot;175,730 reputation&quot; class=&quot;comment-user&quot;&gt;Lundin&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment56399339_7627218&quot;&gt;&lt;span title=&quot;2015-12-17 07:32:52Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Dec 17, 2015 at 7:32&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@MohammadMamunHossain use &lt;code&gt;std::array&lt;/code&gt; array instead of raw arrays and then it becomes trivial. (Which is good advice in most cases in C++ anyway)&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/168175/flexo&quot; title=&quot;85,154 reputation&quot; class=&quot;comment-user&quot;&gt;Flexo&lt;/a&gt;\n&lt;span class=&quot;mod-flair &quot; title=&quot;Moderator&quot;&gt;&lt;/span&gt;                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment84973013_7627218&quot;&gt;&lt;span title=&quot;2018-02-26 08:27:37Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Feb 26, 2018 at 8:27&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 2 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;In your example for initialized lambda captures above, why do you end the lamba function with the ();? This appears like [](){}(); instead of [](){};. Also shouldn&apos;t the value of x be 5?&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/2411292/ramakrishnan-kannan&quot; title=&quot;564 reputation&quot; class=&quot;comment-user&quot;&gt;Ramakrishnan Kannan&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment62925938_7627330&quot;&gt;&lt;span title=&quot;2016-06-09 13:25:45Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 9, 2016 at 13:25&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@RamakrishnanKannan: 1) the () are there to call the lambda right after defining it and give y its return value. The variable y is an integer, not the lambda. 2) No, x=5 is local to the lambda (a capture by value which just happens to have the same name as the outer scope variable x), and then x+2 = 5+2 is returned. The reassignment of the outer variable x happens through the reference r: &lt;code&gt;r = &amp;amp;x; r += 2;&lt;/code&gt;, but this happens to the original value of 4.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1537925/the-vee&quot; title=&quot;11,073 reputation&quot; class=&quot;comment-user&quot;&gt;The Vee&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment64161953_7627330&quot;&gt;&lt;span title=&quot;2016-07-14 13:40:13Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jul 14, 2016 at 13:40&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;hey, by saying &lt;code&gt;any variable currently in scope&lt;/code&gt;, what does it mean? it means capture all global variables globally and any local variables in this function?&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1356874/http8086&quot; title=&quot;964 reputation&quot; class=&quot;comment-user&quot;&gt;http8086&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment115210700_7627330&quot;&gt;&lt;span title=&quot;2020-12-06 12:58:43Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Dec 6, 2020 at 12:58&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;I saw in the documentation that a Throw has been added: &lt;a href=&quot;https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-160&quot; rel=&quot;nofollow noreferrer&quot;&gt;docs.microsoft.com/en-us/cpp/cpp/&lt;/a&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/4203412/sxubach&quot; title=&quot;174 reputation&quot; class=&quot;comment-user&quot;&gt;Sxubach&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment128456958_7627330&quot;&gt;&lt;span title=&quot;2022-06-23 05:22:12Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 23 at 5:22&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Have you realized that this question was asked 1.5 years ago and that the last activity was almost 1 year ago? Anyway, you&apos;re contributing some interesting ideas I haven&apos;t seen before!&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1101751/piotr99&quot; title=&quot;531 reputation&quot; class=&quot;comment-user&quot;&gt;Piotr99&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment21336530_15153194&quot;&gt;&lt;span title=&quot;2013-03-01 08:32:38Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 1, 2013 at 8:32&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Thanks for the simultaneous define-and-execute tip! I think it&apos;s worth noting that that works in as a contidion for &lt;code&gt;if&lt;/code&gt; statements: &lt;code&gt;if ([i]{ for (char j : i) if (!isspace(j)) return false ; return true ; }()) // i is all whitespace&lt;/code&gt;, assuming &lt;code&gt;i&lt;/code&gt; is an &lt;code&gt;std::string&lt;/code&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1561811/blacklight-shining&quot; title=&quot;1,358 reputation&quot; class=&quot;comment-user&quot;&gt;Blacklight Shining&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment21365262_15153194&quot;&gt;&lt;span title=&quot;2013-03-02 01:13:48Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 2, 2013 at 1:13&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 2 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;So the following is a legal expression: &lt;code&gt;[](){}();&lt;/code&gt;.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/86967/brent-bradburn&quot; title=&quot;47,117 reputation&quot; class=&quot;comment-user&quot;&gt;Brent Bradburn&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment22804015_15153194&quot;&gt;&lt;span title=&quot;2013-04-13 22:35:59Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 13, 2013 at 22:35&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Ugh!  Python&apos;s &lt;code&gt;(lambda: None)()&lt;/code&gt; syntax is so much more legible.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/287586/dan04&quot; title=&quot;83,099 reputation&quot; class=&quot;comment-user&quot;&gt;dan04&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment24261113_15153194&quot;&gt;&lt;span title=&quot;2013-05-30 03:28:54Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;May 30, 2013 at 3:28&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@nobar - you&apos;re right, I mistyped. This is legal (I tested it this time) &lt;code&gt;main() {{{{((([](){{}}())));}}}}&lt;/code&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/364818/mark-lakata&quot; title=&quot;19,077 reputation&quot; class=&quot;comment-user&quot;&gt;Mark Lakata&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment35912587_15153194&quot;&gt;&lt;span title=&quot;2014-05-02 16:05:40Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;May 2, 2014 at 16:05&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;This &lt;code&gt;[&amp;amp;,=Param2](int arg1){}&lt;/code&gt; doesn&apos;t seem to be valid syntax. The correct form would be &lt;code&gt;[&amp;amp;,Param2](int arg1){}&lt;/code&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/25700/getfree&quot; title=&quot;37,174 reputation&quot; class=&quot;comment-user&quot;&gt;GetFree&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment73905845_30625943&quot;&gt;&lt;span title=&quot;2017-04-15 08:00:24Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 15, 2017 at 8:00&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Thanks. First I tried to compile this snippet. And it seems strange assymetry in allowable modificators in capture list  // g++ -std=c++11 main.cpp -o test_bin; ./test_bin  #include &amp;lt;stdio.h&amp;gt;  int main() { #if 1   {     int param = 0;     auto f=[=,&amp;amp;param](int arg1) mutable {param = arg1;};     f(111);     printf(&quot;%i\\n&quot;, param);   } #endif  #if 0   {     int param = 0;     auto f=[&amp;amp;,=param](int arg1) mutable {param = arg1;};     f(111);     printf(&quot;%i\\n&quot;, param);   } #endif    return 0; }&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1154447/konstantin-burlachenko&quot; title=&quot;4,963 reputation&quot; class=&quot;comment-user&quot;&gt;Konstantin Burlachenko&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment73931956_30625943&quot;&gt;&lt;span title=&quot;2017-04-16 13:02:45Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 16, 2017 at 13:02&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Looks that new line in not supported in comment. Then I opened 5.1.2 Lambda expressions, p.88, &quot;Working Draft, Standard for Programming Language C ++&quot;, Dcoument Number: #337, 2012-01-16. And looked into grammar syntax. And you&apos;re right. There is no exist such thing like capture via &quot;=arg&quot;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1154447/konstantin-burlachenko&quot; title=&quot;4,963 reputation&quot; class=&quot;comment-user&quot;&gt;Konstantin Burlachenko&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment73932025_30625943&quot;&gt;&lt;span title=&quot;2017-04-16 13:07:05Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 16, 2017 at 13:07&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Big Thanks, fixed it in description and also acquire new knowledge w.r.t. to it.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1154447/konstantin-burlachenko&quot; title=&quot;4,963 reputation&quot; class=&quot;comment-user&quot;&gt;Konstantin Burlachenko&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment73932202_30625943&quot;&gt;&lt;span title=&quot;2017-04-16 13:17:02Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 16, 2017 at 13:17&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;the reason is, that a lambda can only convert to a function pointer, if it has no capture. if &lt;code&gt;apply&lt;/code&gt; was a template that accepted a functor, it would work&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/3202093/sp2danny&quot; title=&quot;7,182 reputation&quot; class=&quot;comment-user&quot;&gt;sp2danny&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment46203421_28975397&quot;&gt;&lt;span title=&quot;2015-03-10 23:50:06Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 10, 2015 at 23:50&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;But the problem is that if apply is an existing interface, you may not have the luxury of being able to declare it differently than a plain old function.   The standard could have been designed to allow a new instance of a plain old function to be generated each time such a lambda expression is executed, with generated hard-coded references to the captured variables.   It seems a lambda function is generated at compile time. There are other consequences as well. e.g., If you declare a static variable, even if you re-evaluate the lambda expression, you don&apos;t get a new static variable.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/4656097/ted&quot; title=&quot;181 reputation&quot; class=&quot;comment-user&quot;&gt;Ted&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment46204119_28975397&quot;&gt;&lt;span title=&quot;2015-03-11 00:29:58Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 11, 2015 at 0:29&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;function pointer are often meant to be saved, and a lambdas capture can go out of scope. that only capture-less lambdas convert to function-pointers was by design&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/3202093/sp2danny&quot; title=&quot;7,182 reputation&quot; class=&quot;comment-user&quot;&gt;sp2danny&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment46204256_28975397&quot;&gt;&lt;span title=&quot;2015-03-11 00:37:18Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 11, 2015 at 0:37&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;You still have to pay attention to stack variables being deallocated for the same reason either way. See &lt;a href=&quot;http://blogs.msdn.com/b/nativeconcurrency/archive/2012/01/29/perils-of-lambda-capture.aspx&quot; rel=&quot;nofollow noreferrer&quot;&gt;blogs.msdn.com/b/nativeconcurrency/archive/2012/01/29/&lt;/a&gt;  The example I wrote with output and apply is written so that if instead function pointers were allowed and used, they would work as well. The col remains allocated until after all of the function calls from apply have finished. How would you rewrite this code to work using the existing apply interface? Would you end up using global or static variables, or some more obscure transformation of the code?&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/4656097/ted&quot; title=&quot;181 reputation&quot; class=&quot;comment-user&quot;&gt;Ted&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment46205210_28975397&quot;&gt;&lt;span title=&quot;2015-03-11 01:34:26Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 11, 2015 at 1:34&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;or perhaps you simply mean that lambda expressions are rvalues and therefore temporary, yet the code remains constant (singleton/static) so that it can be called in the future. In that case, perhaps the function should remain allocated as long as its stack-allocated captures remain allocated. Of course it could get messy unwinding it if for example many variations of the function are allocated in a loop.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/4656097/ted&quot; title=&quot;181 reputation&quot; class=&quot;comment-user&quot;&gt;Ted&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment46205448_28975397&quot;&gt;&lt;span title=&quot;2015-03-11 01:49:20Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 11, 2015 at 1:49&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Nice explanation. Using range-based for loops, you can avoid lambdas and shorten the code &lt;code&gt;for (int x : v)\t{ if (x % m == 0) os &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &apos;\\n&apos;;}&lt;/code&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/7453065/dietrich-baumgarten&quot; title=&quot;544 reputation&quot; class=&quot;comment-user&quot;&gt;Dietrich Baumgarten&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment103234323_40505390&quot;&gt;&lt;span title=&quot;2019-10-18 09:42:23Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Oct 18, 2019 at 9:42&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;finally a catchable answer, like &quot;What is it?&quot;, &quot;What are the use cases?&quot; .&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/9437799/sam-ginrich&quot; title=&quot;512 reputation&quot; class=&quot;comment-user&quot;&gt;Sam Ginrich&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment126927604_40505390&quot;&gt;&lt;span title=&quot;2022-04-11 10:40:13Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 11 at 10:40&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;&lt;i&gt;yes its literally on the go, you define it; use it; and as the parent function scope finishes the lambda function is gone&lt;/i&gt; .. what if the function returns the lambda to the caller?&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/415784/nawaz&quot; title=&quot;342,529 reputation&quot; class=&quot;comment-user owner&quot;&gt;Nawaz&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment99499536_56441968&quot;&gt;&lt;span title=&quot;2019-06-05 01:53:38Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 5, 2019 at 1:53&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;&lt;i&gt;It&apos;s also not the fastest one compare to normal function. because it has some overhead which need to be handled by lambda.&lt;/i&gt; Have you ever &lt;i&gt;actually&lt;/i&gt; run any benchmark &lt;b&gt;to support this claim&lt;/b&gt;? On the contrary, lambda + templates often produce fastest code possible.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/415784/nawaz&quot; title=&quot;342,529 reputation&quot; class=&quot;comment-user owner&quot;&gt;Nawaz&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment99499574_56441968&quot;&gt;&lt;span title=&quot;2019-06-05 01:57:08Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 5, 2019 at 1:57&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 3 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Not sure that this is the best example of when to use lambdas. &lt;a href=&quot;https://godbolt.org/z/hfnsW1Ka4&quot; rel=&quot;nofollow noreferrer&quot;&gt;Here&apos;s a simpler and shorter way to write the same thing in old fashioned C++&lt;/a&gt;.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/8658157/elliott&quot; title=&quot;2,106 reputation&quot; class=&quot;comment-user&quot;&gt;Elliott&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment121929615_33867318&quot;&gt;&lt;span title=&quot;2021-08-30 21:01:57Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Aug 30, 2021 at 21:01&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;This can also be done with a plain function, which is even what the accepted answer to the question you linked to says to do.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1277769/sirguy&quot; title=&quot;10,510 reputation&quot; class=&quot;comment-user&quot;&gt;SirGuy&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment66131829_31083977&quot;&gt;&lt;span title=&quot;2016-09-09 02:50:47Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Sep 9, 2016 at 2:50&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        "],"id":445,"title":"What is a lambda expression in C++11?","content":"\n                \n&lt;p&gt;What is a lambda expression in C++11? When would I use one? What class of problem do they solve that wasn&apos;t possible prior to their introduction?&lt;/p&gt;\n\n&lt;p&gt;A few examples, and use cases would be useful. &lt;/p&gt;\n    ","slug":"what-is-a-lambda-expression-in-c++11-1657387999252","postType":"QUESTION","createdAt":"2022-07-09T17:33:19.000Z","updatedAt":"2022-07-09T17:33:19.000Z","tags":[{"id":2306,"name":"lambda","slug":"lambda","createdAt":"2022-07-09T17:33:19.000Z","updatedAt":"2022-07-09T17:33:19.000Z","Questions_Tags":{"questionId":445,"tagId":2306}}]}]}},"__N_SSG":true}