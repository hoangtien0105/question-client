<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>smart-pointers tags | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="All questions and solutions for smart-pointers tags"/><meta property="og:title" content="smart-pointers tags | Solutions Checker"/><meta property="og:description" content="All questions and solutions for smart-pointers tags"/><meta name="next-head-count" content="15"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-12e9794e898cd5f3.js" defer=""></script><script src="/_next/static/chunks/816-14d8d742fae4ce97.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/tag/%5Bslug%5D-f494fb3cd3632ed7.js" defer=""></script><script src="/_next/static/BnkbnjkWYxefPXjTJLVVv/_buildManifest.js" defer=""></script><script src="/_next/static/BnkbnjkWYxefPXjTJLVVv/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/tag/smart-pointers#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="pagination-page-wrapper"><span class="pagination-buttons previous bg-stone-500 cursor-not-allowed  hover:bg-stone-500 text-white font-bold py-2 px-4 rounded">Previous</span></div><div class="question my-5"><div class="flex items-center justify-center"><div class="rounded-xl border p-5 shadow-md post-layout-inner bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-is-a-smart-pointer-and-when-should-i-use-one-1657387905461">What is a smart pointer and when should I use one?</a></div></div></div><div class="tags-wrap h-max space-x-8"><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/smart-pointers">smart-pointers</a></div></div></div><div><div class="flex items-center justify-between text-slate-500"><div class="flex space-x-4 md:space-x-8"><span class="btn bg-stone-500 cursor-pointer  hover:bg-stone-500 text-white font-bold py-2 px-4 rounded">Show Solution</span></div></div></div></div></div></div><div class="pagination-page-wrapper"><span class="pagination-buttons next bg-stone-500 cursor-not-allowed  hover:bg-stone-500 text-white font-bold py-2 px-4 rounded">Next</span></div><div class="widget"><a href="/questions/tag/equality">equality</a><a href="/questions/tag/access-modifiers">access-modifiers</a><a href="/questions/tag/email">email</a><a href="/questions/tag/three.js">three.js</a><a href="/questions/tag/operator-precedence">operator-precedence</a><a href="/questions/tag/python-import">python-import</a><a href="/questions/tag/unity3d">unity3d</a><a href="/questions/tag/opengl">opengl</a><a href="/questions/tag/git-rm">git-rm</a><a href="/questions/tag/tkinter-canvas">tkinter-canvas</a><a href="/questions/tag/http-redirect">http-redirect</a><a href="/questions/tag/viewmodel">viewmodel</a><a href="/questions/tag/unicode">unicode</a><a href="/questions/tag/reference">reference</a><a href="/questions/tag/linux">linux</a><a href="/questions/tag/c++-faq">c++-faq</a><a href="/questions/tag/python-internals">python-internals</a><a href="/questions/tag/importerror">importerror</a><a href="/questions/tag/linked-list">linked-list</a><a href="/questions/tag/instance-variables">instance-variables</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"count":1,"rows":[{"id":414,"title":"What is a smart pointer and when should I use one?","slug":"what-is-a-smart-pointer-and-when-should-i-use-one-1657387905461","postType":"QUESTION","createdAt":"2022-07-09T17:31:45.000Z","updatedAt":"2022-07-09T17:31:45.000Z","tags":[{"id":2202,"name":"smart-pointers","slug":"smart-pointers","createdAt":"2022-07-09T17:31:45.000Z","updatedAt":"2022-07-09T17:31:45.000Z","Questions_Tags":{"questionId":414,"tagId":2202}}]}]},"slug":"smart-pointers","page":1,"answers":{"414":["\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;UPDATE\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This answer is rather old, and so describes what was \u0026apos;good\u0026apos; at the time, which was smart pointers provided by the Boost library. Since C++11, the standard library has provided sufficient smart pointers types, and so you should favour the use of \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/unique_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::unique_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/shared_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::shared_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/weak_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::weak_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There was also \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/auto_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::auto_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;. It was very much like a scoped pointer, except that it also had the \u0026quot;special\u0026quot; dangerous ability to be copied  which also unexpectedly transfers ownership.\u0026lt;br\u0026gt;\n\u0026lt;strong\u0026gt;It was deprecated in C++11 and removed in C++17\u0026lt;/strong\u0026gt;, so you shouldn\u0026apos;t use it.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::auto_ptr\u0026amp;lt;MyObject\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;p1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; MyObject())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\nstd::auto_ptr\u0026amp;lt;MyObject\u0026amp;gt; p2 = p1; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Copy and transfer ownership. \u0026lt;/span\u0026gt;\n                                 \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// p1 gets set to empty!\u0026lt;/span\u0026gt;\np2-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;DoSomething\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Works.\u0026lt;/span\u0026gt;\np1-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;DoSomething\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Oh oh. Hopefully raises some NULL pointer exception.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;OLD ANSWER\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A smart pointer is a class that wraps a \u0026apos;raw\u0026apos; (or \u0026apos;bare\u0026apos;) C++ pointer, to manage the lifetime of the object being pointed to. There is no single smart pointer type, but all of them try to abstract a raw pointer in a practical way.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Smart pointers should be preferred over raw pointers. If you feel you need to use pointers (first consider if you \u0026lt;em\u0026gt;really\u0026lt;/em\u0026gt; do), you would normally want to use a smart pointer as this can alleviate many of the problems with raw pointers, mainly forgetting to delete the object and leaking memory.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;With raw pointers, the programmer has to explicitly destroy the object when it is no longer useful.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Need to create the object to achieve some goal\u0026lt;/span\u0026gt;\nMyObject* ptr = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;MyObject\u0026lt;/span\u0026gt;(); \nptr-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;DoSomething\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Use the object in some way\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; ptr; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Destroy the object. Done with it.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Wait, what if DoSomething() raises an exception...?\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;A smart pointer by comparison defines a policy as to when the object is destroyed. You still have to create the object, but you no longer have to worry about destroying it.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;SomeSmartPtr\u0026amp;lt;MyObject\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ptr\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; MyObject())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\nptr-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;DoSomething\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Use the object in some way.\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Destruction of the object happens, depending \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// on the policy the smart pointer class uses.\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Destruction would happen even if DoSomething() \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// raises an exception\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The simplest policy in use involves the scope of the smart pointer wrapper object, such as implemented by \u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/release/libs/smart_ptr/scoped_ptr.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;boost::scoped_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; or \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/unique_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::unique_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    {\n       \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::unique_ptr\u0026amp;lt;MyObject\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ptr\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; MyObject())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n       ptr-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;DoSomethingUseful\u0026lt;/span\u0026gt;();\n    } \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ptr goes out of scope -- \u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// the MyObject is automatically destroyed.\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ptr-\u0026amp;gt;Oops(); // Compile error: \u0026quot;ptr\u0026quot; not defined\u0026lt;/span\u0026gt;\n                    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// since it is no longer in scope.\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that \u0026lt;code\u0026gt;std::unique_ptr\u0026lt;/code\u0026gt; instances cannot be copied. This prevents the pointer from being deleted multiple times (incorrectly). You can, however, pass references to it around to other functions you call.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;std::unique_ptr\u0026lt;/code\u0026gt;s are useful when you want to tie the lifetime of the object to a particular block of code, or if you embedded it as member data inside another object, the lifetime of that other object. The object exists until the containing block of code is exited, or until the containing object is itself destroyed.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A more complex smart pointer policy involves reference counting the pointer. This does allow the pointer to be copied. When the last \u0026quot;reference\u0026quot; to the object is destroyed, the object is deleted. This policy is implemented by \u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;boost::shared_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/shared_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::shared_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; std::shared_ptr\u0026amp;lt;MyObject\u0026amp;gt; MyObjectPtr; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// nice short alias\u0026lt;/span\u0026gt;\n    MyObjectPtr p1; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Empty\u0026lt;/span\u0026gt;\n\n    {\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;MyObjectPtr \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;p2\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; MyObject())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// There is now one \u0026quot;reference\u0026quot; to the created object\u0026lt;/span\u0026gt;\n        p1 = p2; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Copy the pointer.\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// There are now two references to the object.\u0026lt;/span\u0026gt;\n    } \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// p2 is destroyed, leaving one reference to the object.\u0026lt;/span\u0026gt;\n} \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// p1 is destroyed, leaving a reference count of zero. \u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// The object is deleted.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Reference counted pointers are very useful when the lifetime of your object is much more complicated, and is not tied directly to a particular section of code or to another object.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There is one drawback to reference counted pointers  the possibility of creating a dangling reference:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Create the smart pointer on the heap\u0026lt;/span\u0026gt;\nMyObjectPtr* pp = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;MyObjectPtr\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;MyObject\u0026lt;/span\u0026gt;())\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Hmm, we forgot to destroy the smart pointer,\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// because of that, the object is never destroyed!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Another possibility is creating circular references:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Owner\u0026lt;/span\u0026gt; {\n   std::shared_ptr\u0026amp;lt;Owner\u0026amp;gt; other;\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::shared_ptr\u0026amp;lt;Owner\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;p1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Owner())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::shared_ptr\u0026amp;lt;Owner\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;p2\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Owner())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\np1-\u0026amp;gt;other = p2; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// p1 references p2\u0026lt;/span\u0026gt;\np2-\u0026amp;gt;other = p1; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// p2 references p1\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Oops, the reference count of of p1 and p2 never goes to zero!\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// The objects are never destroyed!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;To work around this problem, both Boost and C++11 have defined a \u0026lt;code\u0026gt;weak_ptr\u0026lt;/code\u0026gt; to define a weak (uncounted) reference to a \u0026lt;code\u0026gt;shared_ptr\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here\u0026apos;s a simple answer for these days of modern C++ (C++11 and later):\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026quot;What is a smart pointer?\u0026quot;\u0026lt;/strong\u0026gt; \u0026lt;br\u0026gt;\nIt\u0026apos;s a type whose values can be used like pointers, but which provides the additional feature of automatic memory management: When a smart pointer is no longer in use, the memory it points to is deallocated (see also \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Smart_pointer\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;the more detailed definition on Wikipedia\u0026lt;/a\u0026gt;).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026quot;When should I use one?\u0026quot;\u0026lt;/strong\u0026gt; \u0026lt;br\u0026gt;\nIn code which involves tracking the ownership of a piece of memory, allocating or de-allocating; the smart pointer often saves you the need to do these things explicitly.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026quot;But which smart pointer should I use in which of those cases?\u0026quot;\u0026lt;/strong\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Use \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/unique_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::unique_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; when you want your object to live just as long as a single owning reference to it lives. For example, use it for a pointer to memory which gets allocated on entering some scope and de-allocated on exiting the scope.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Use \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/shared_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::shared_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; when you do want to refer to your object from multiple places - and do not want your object to be de-allocated until all these references are themselves gone.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Use \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/weak_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::weak_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; when you do want to refer to your object from multiple places - for those references for which it\u0026apos;s ok to ignore and deallocate (so they\u0026apos;ll just note the object is gone when you try to dereference).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Don\u0026apos;t use the \u0026lt;code\u0026gt;boost::\u0026lt;/code\u0026gt; smart pointers or \u0026lt;code\u0026gt;std::auto_ptr\u0026lt;/code\u0026gt; except in special cases which you can read up on if you must.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026quot;Hey, I didn\u0026apos;t ask which one to use!\u0026quot;\u0026lt;/strong\u0026gt; \u0026lt;br\u0026gt;\nAh, but you really wanted to, admit it.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026quot;So when should I use regular pointers then?\u0026quot;\u0026lt;/strong\u0026gt; \u0026lt;br\u0026gt;\nMostly in code that is oblivious to memory ownership. This would typically be in functions which get a pointer from someplace else and do not allocate nor de-allocate, and do not store a copy of the pointer which outlasts their execution.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Smart_pointer\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;smart pointer\u0026lt;/a\u0026gt; is a pointer-like type with some additional functionality, e.g. automatic memory deallocation, reference counting etc.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A small intro is available on the page \u0026lt;a href=\u0026quot;http://ootips.org/yonat/4dev/smart-pointers.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Smart Pointers - What, Why, Which?\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;One of the simple smart-pointer types is \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/auto_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::auto_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; (chapter 20.4.5 of C++ standard), which allows one to deallocate memory automatically when it out of scope and which is more robust than simple pointer usage when exceptions are thrown, although less flexible.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Another convenient type is \u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/1_36_0/libs/smart_ptr/shared_ptr.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;boost::shared_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; which implements reference counting and automatically deallocates memory when no references to the object remains. This helps avoiding memory leaks and is easy to use to implement \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;RAII\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The subject is covered in depth in book \u0026lt;a href=\u0026quot;https://rads.stackoverflow.com/amzn/click/com/0201734842\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026quot;C++ Templates: The Complete Guide\u0026quot; by David Vandevoorde, Nicolai M. Josuttis\u0026lt;/a\u0026gt;, chapter Chapter 20. Smart Pointers.\nSome topics covered:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Protecting Against Exceptions\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Holders, (note, \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/auto_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;std::auto_ptr\u0026lt;/a\u0026gt; is implementation of such type of smart pointer)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Resource_acquisition_is_initialization\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Resource Acquisition Is Initialization\u0026lt;/a\u0026gt; (This is frequently used for exception-safe resource management in C++)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Holder Limitations\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Reference_counting\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Reference Counting\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Concurrent Counter Access\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Destruction and Deallocation\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Definitions provided by Chris, Sergdev and Llyod are correct. I prefer a simpler definition though, just to keep my life simple:\nA smart pointer is simply a class that overloads the \u0026lt;code\u0026gt;-\u0026amp;gt;\u0026lt;/code\u0026gt;  and \u0026lt;code\u0026gt;*\u0026lt;/code\u0026gt; operators. Which means that your object semantically looks like a pointer but you can make it do way cooler things, including reference counting, automatic destruction etc.\n\u0026lt;code\u0026gt;shared_ptr\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;auto_ptr\u0026lt;/code\u0026gt; are sufficient in most cases, but come along with their own set of small idiosyncrasies.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A smart pointer is like a regular (typed) pointer, like \u0026quot;char*\u0026quot;, except when the pointer itself goes out of scope then what it points to is deleted as well. You can use it like you would a regular pointer, by using \u0026quot;-\u0026amp;gt;\u0026quot;, but not if you need an actual pointer to the data. For that, you can use \u0026quot;\u0026amp;amp;*ptr\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It is useful for:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Objects that must be allocated with new, but that you\u0026apos;d like to have the same lifetime as something on that stack. If the object is assigned to a smart pointer, then they will be deleted when the program exits that function/block.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Data members of classes, so that when the object is deleted all the owned data is deleted as well, without any special code in the destructor (you will need to be sure the destructor is virtual, which is almost always a good thing to do).\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;You may \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; want to use a smart pointer when:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;... the pointer shouldn\u0026apos;t actually own the data... i.e., when you are just using the data, but you want it to survive the function where you are referencing it.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;... the smart pointer isn\u0026apos;t itself going to be destroyed at some point. You don\u0026apos;t want it to sit in memory that never gets destroyed (such as in an object that is dynamically allocated but won\u0026apos;t be explicitly deleted).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;... two smart pointers might point to the same data. (There are, however, even smarter pointers that will handle that... that is called \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Reference_counting\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;reference counting\u0026lt;/a\u0026gt;.)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;See also:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;garbage collection\u0026lt;/a\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/94227/smart-pointers-or-who-owns-you-baby\u0026quot;\u0026gt;This stack overflow question\u0026lt;/a\u0026gt; regarding data ownership\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A smart pointer is an object that acts like a pointer, but additionally provides control on construction, destruction, copying, moving and dereferencing.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;One can implement one\u0026apos;s own smart pointer, but many libraries also provide smart pointer implementations each with different advantages and drawbacks.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example, \u0026lt;a href=\u0026quot;http://www.boost.org/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Boost\u0026lt;/a\u0026gt; provides the following smart pointer implementations:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;shared_ptr\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; is a pointer to \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; using a reference count to determine when the object is no longer needed.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;scoped_ptr\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; is a pointer automatically deleted when it goes out of scope. No assignment is possible.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;intrusive_ptr\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; is another reference counting pointer. It provides better performance than \u0026lt;code\u0026gt;shared_ptr\u0026lt;/code\u0026gt;, but requires the type \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; to provide its own reference counting mechanism.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;weak_ptr\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; is a weak pointer, working in conjunction with \u0026lt;code\u0026gt;shared_ptr\u0026lt;/code\u0026gt; to avoid circular references.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;shared_array\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; is like \u0026lt;code\u0026gt;shared_ptr\u0026lt;/code\u0026gt;, but for arrays of \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;scoped_array\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; is like \u0026lt;code\u0026gt;scoped_ptr\u0026lt;/code\u0026gt;, but for arrays of \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;These are just one linear descriptions of each and can be used as per need, for further detail and examples one can look at the documentation of Boost.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Additionally, the C++ standard library provides three smart pointers; \u0026lt;code\u0026gt;std::unique_ptr\u0026lt;/code\u0026gt; for unique ownership, \u0026lt;code\u0026gt;std::shared_ptr\u0026lt;/code\u0026gt; for shared ownership and \u0026lt;code\u0026gt;std::weak_ptr\u0026lt;/code\u0026gt;. \u0026lt;code\u0026gt;std::auto_ptr\u0026lt;/code\u0026gt; existed in C++03 but is now deprecated.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Most kinds of smart pointers handle disposing of the pointer-to object for you. It\u0026apos;s very handy because you don\u0026apos;t have to think about disposing of objects manually anymore.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The most commonly-used smart pointers are \u0026lt;code\u0026gt;std::tr1::shared_ptr\u0026lt;/code\u0026gt; (or \u0026lt;code\u0026gt;boost::shared_ptr\u0026lt;/code\u0026gt;), and, less commonly, \u0026lt;code\u0026gt;std::auto_ptr\u0026lt;/code\u0026gt;. I recommend regular use of \u0026lt;code\u0026gt;shared_ptr\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;shared_ptr\u0026lt;/code\u0026gt; is very versatile and deals with a large variety of disposal scenarios, including cases where objects need to be \u0026quot;passed across DLL boundaries\u0026quot; (the common nightmare case if different \u0026lt;code\u0026gt;libc\u0026lt;/code\u0026gt;s are used between your code and the DLLs).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is the Link for similar answers : \u0026lt;a href=\u0026quot;http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html\u0026quot;\u0026gt;http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A smart pointer is an object that acts, looks and feels like a normal pointer but offers more functionality. In C++, smart pointers are implemented as template classes that encapsulate a pointer and override standard pointer operators. They have a number of advantages over regular pointers. They are guaranteed to be initialized as either null pointers or pointers to a heap object. Indirection through a null pointer is checked. No delete is ever necessary. Objects are automatically freed when the last pointer to them has gone away. One significant problem with these smart pointers is that unlike regular pointers, they don\u0026apos;t respect inheritance. Smart pointers are unattractive for polymorphic code. Given below is an example for the implementation of smart pointers.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Example:\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;smart_pointer\u0026lt;/span\u0026gt;\n{\n          \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n               \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;smart_pointer\u0026lt;/span\u0026gt;();                          \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// makes a null pointer\u0026lt;/span\u0026gt;\n               \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;smart_pointer\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; X\u0026amp;amp; x)            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// makes pointer to copy of x\u0026lt;/span\u0026gt;\n\n               X\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; *( );\n               \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; X\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;*( ) \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;;\n               X* \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;-\u0026amp;gt;() \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;;\n\n               \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;smart_pointer\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; smart_pointer \u0026amp;lt;X\u0026amp;gt; \u0026amp;amp;);\n               \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; smart_pointer \u0026amp;lt;X\u0026amp;gt; \u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; =(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; smart_pointer\u0026amp;lt;X\u0026amp;gt;\u0026amp;amp;);\n               ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;smart_pointer\u0026lt;/span\u0026gt;();\n          \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n               \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//...\u0026lt;/span\u0026gt;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This class implement a smart pointer to an object of type X. The object itself is located on the heap. Here is how to use it:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;smart_pointer \u0026amp;lt;employee\u0026amp;gt; p= \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;employee\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Harris\u0026quot;\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1333\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Like other overloaded operators, p will behave like a regular pointer,\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;cout\u0026amp;lt;\u0026amp;lt;*p;\np-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;raise_salary\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.5\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Let T be a class in this tutorial \nPointers in C++ can be divided into 3 types :\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;1) \u0026lt;strong\u0026gt;Raw pointers\u0026lt;/strong\u0026gt; :\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;T a;  \nT * _ptr = \u0026amp;amp;a; \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;They hold a memory address to a location in memory. Use with caution , as programs become complex hard to keep track. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Pointers with const data or address { Read backwards } \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;T a ; \n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T * ptr1 = \u0026amp;amp;a ; \nT \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; * ptr1 = \u0026amp;amp;a ;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Pointer to a data type T which is a const. Meaning you cannot change the data type using the pointer. ie \u0026lt;code\u0026gt;*ptr1 = 19\u0026lt;/code\u0026gt; ; will not work. But you can move the pointer. ie \u0026lt;code\u0026gt;ptr1++ , ptr1--\u0026lt;/code\u0026gt; ;  etc will work.\nRead backwards : pointer to type T which is const \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;  T * \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; ptr2 ;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;A const pointer to a data type T . Meaning you cannot move the pointer but you can change the value pointed to by the pointer. ie \u0026lt;code\u0026gt;*ptr2 = 19\u0026lt;/code\u0026gt; will work but \u0026lt;code\u0026gt;ptr2++ ; ptr2--\u0026lt;/code\u0026gt; etc will not work. Read backwards : const pointer to a type T \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T * \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; ptr3 ; \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;A const pointer to a const data type T . Meaning you cannot either move the pointer nor can you change the data type pointer to be the pointer. ie . \u0026lt;code\u0026gt;ptr3-- ; ptr3++ ; *ptr3 = 19;\u0026lt;/code\u0026gt; will not work \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;3) \u0026lt;strong\u0026gt;Smart Pointers\u0026lt;/strong\u0026gt; : { \u0026lt;code\u0026gt;#include \u0026amp;lt;memory\u0026amp;gt;\u0026lt;/code\u0026gt; } \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Shared Pointer\u0026lt;/strong\u0026gt;: \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;  T a ; \n     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//shared_ptr\u0026amp;lt;T\u0026amp;gt; shptr(new T) ; not recommended but works \u0026lt;/span\u0026gt;\n     shared_ptr\u0026amp;lt;T\u0026amp;gt; shptr = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;make_shared\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// faster + exception safe\u0026lt;/span\u0026gt;\n\n     std::cout \u0026amp;lt;\u0026amp;lt; shptr.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;use_count\u0026lt;/span\u0026gt;() ; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 1 //  gives the number of \u0026quot; \u0026lt;/span\u0026gt;\nthings \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; pointing to it. \n     T * temp = shptr.get(); // gives a pointer to object\n\n     // shared_pointer used like a regular pointer to call member functions\n      shptr-\u0026amp;gt;memFn();\n     (*shptr).memFn(); \n\n    //\n     shptr.reset() ; // frees the object pointed to be the ptr \n     shptr = nullptr ; // frees the object \n     shptr = make_shared\u0026amp;lt;T\u0026amp;gt;() ; // frees the original object and points to new object\n\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Implemented using reference counting to keep track of how many \u0026quot; things \u0026quot; point to the object pointed to by the pointer. When this count goes to 0 , the object is automatically deleted , ie objected is deleted when all the share_ptr pointing to the object goes out of scope. \nThis gets rid of the headache of having to delete objects which you have allocated using new. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Weak Pointer :\u0026lt;/strong\u0026gt; \n    Helps deal with cyclic reference which arises when using Shared Pointer\n    If you have two objects pointed to by two shared pointers and there is an internal shared pointer pointing to each others shared pointer then there will be a cyclic reference and the object will not be deleted when shared pointers go out of scope. To solve this , change the internal member from a shared_ptr to weak_ptr. Note : To access the element pointed to by a weak pointer use lock() , this returns a weak_ptr. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;T a ; \nshared_ptr\u0026amp;lt;T\u0026amp;gt; shr = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;make_shared\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;() ; \nweak_ptr\u0026amp;lt;T\u0026amp;gt; wk = shr ; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// initialize a weak_ptr from a shared_ptr \u0026lt;/span\u0026gt;\nwk.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;lock\u0026lt;/span\u0026gt;()-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;memFn\u0026lt;/span\u0026gt;() ; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// use lock to get a shared_ptr \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//   ^^^ Can lead to exception if the shared ptr has gone out of scope\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(!wk.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;expired\u0026lt;/span\u0026gt;()) wk.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;lock\u0026lt;/span\u0026gt;()-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;memFn\u0026lt;/span\u0026gt;() ;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Check if shared ptr has gone out of scope before access\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;See : \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful\u0026quot;\u0026gt;When is std::weak_ptr useful?\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Unique Pointer :\u0026lt;/strong\u0026gt; \n    Light weight smart pointer with exclusive ownership. Use when pointer points to unique objects without sharing the objects between the pointers.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;unique_ptr\u0026amp;lt;T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;uptr\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; T)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\nuptr-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;memFn\u0026lt;/span\u0026gt;(); \n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//T * ptr = uptr.release(); // uptr becomes null and object is pointed to by ptr\u0026lt;/span\u0026gt;\nuptr.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;reset\u0026lt;/span\u0026gt;() ; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// deletes the object pointed to by uptr \u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;To change the object pointed to by the unique ptr , use move semantics\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;unique_ptr\u0026amp;lt;T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;uptr1\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; T)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;unique_ptr\u0026amp;lt;T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;uptr2\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; T)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\nuptr2 = std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;move\u0026lt;/span\u0026gt;(uptr1); \n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// object pointed by uptr2 is deleted and \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// object pointed by uptr1 is pointed to by uptr2\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// uptr1 becomes null \u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;References : \n    They can essentially be though of as const pointers, ie a pointer which is const and cannot be moved with better syntax.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;See : \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in\u0026quot;\u0026gt;What are the differences between a pointer variable and a reference variable in C++?\u0026lt;/a\u0026gt;  \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;r-value reference : reference to a temporary object   \nl-value reference : reference to an object whose address can be obtained\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; reference : reference to a data type which is \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;and\u0026lt;/span\u0026gt; cannot be modified \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Reference : \n\u0026lt;a href=\u0026quot;https://www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ\u0026lt;/a\u0026gt; \nThanks to Andre for pointing out this question.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Smart_pointer\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://en.wikipedia.org/wiki/Smart_pointer\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;In computer science, a smart pointer\n  is an abstract data type that\n  simulates a pointer while providing\n  additional features, such as automatic\n  garbage collection or bounds checking.\n  These additional features are intended\n  to reduce bugs caused by the misuse of\n  pointers while retaining efficiency.\n  Smart pointers typically keep track of\n  the objects that point to them for the\n  purpose of memory management. The\n  misuse of pointers is a major source\n  of bugs: the constant allocation,\n  deallocation and referencing that must\n  be performed by a program written\n  using pointers makes it very likely\n  that some memory leaks will occur.\n  Smart pointers try to prevent memory\n  leaks by making the resource\n  deallocation automatic: when the\n  pointer to an object (or the last in a\n  series of pointers) is destroyed, for\n  example because it goes out of scope,\n  the pointed object is destroyed too.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A smart pointer is a class, a wrapper of a normal pointer. Unlike normal pointers, smart points life circle is based on a reference count (how many time the smart pointer object is assigned). So whenever a smart pointer is assigned to another one, the internal reference count plus plus. And whenever the object goes out of scope, the reference count minus minus.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Automatic pointer, though looks similar, is totally different from smart pointer. It is a convenient class that deallocates the resource whenever an automatic pointer object goes out of variable scope. To some extent, it makes a pointer (to dynamically allocated memory) works similar to a stack variable (statically allocated in compiling time).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;What is a smart pointer.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Long version, In principle:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://web.stanford.edu/class/archive/cs/cs106l/cs106l.1192/lectures/lecture15/15_RAII.pdf\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://web.stanford.edu/class/archive/cs/cs106l/cs106l.1192/lectures/lecture15/15_RAII.pdf\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A modern C++ idiom:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;RAII: Resource Acquisition Is Initialization.\n\n When you initialize an object, \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;it should already have \n  acquired any resources it \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;needs\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(in the constructor)\u0026lt;/span\u0026gt;.\n\n\n When an object goes out of scope, it should release every \n  resource it is \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; the destructor)\u0026lt;/span\u0026gt;.\n\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;key point:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt; There should never be a half-ready \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;or\u0026lt;/span\u0026gt; half-dead object.\n When an object is created, it should be in a ready state.\n When an object goes out of scope, it should release its resources. \n The user shouldnt have to \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;do\u0026lt;/span\u0026gt; anything more. \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Raw Pointers violate RAII\u0026lt;/strong\u0026gt;: It need user to delete manually when the pointers go out of scope.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;RAII solution is:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;Have a smart pointer \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;:\n Allocates the memory when initialized\n Frees the memory when destructor is called\n Allows access to underlying pointer\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;For smart pointer need copy and share, use shared_ptr:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt; use another memory to store Reference counting \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;and\u0026lt;/span\u0026gt; shared.\n increment when copy, decrement when destructor.\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; memory when Reference counting is \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.\u0026lt;/span\u0026gt; \n  also \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; memory that store Reference counting.\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;for smart pointer not own the raw pointer, use weak_ptr:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; change Reference counting.\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;shared_ptr usage:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;correct way:\nstd::shared_ptr\u0026amp;lt;T\u0026amp;gt; t1 = std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;make_shared\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;(TArgs);\nstd::shared_ptr\u0026amp;lt;T\u0026amp;gt; t2 = std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;shared_ptr\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;(Targs));\n\nwrong way:\nT* pt = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;(TArgs); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// never exposure the raw pointer\u0026lt;/span\u0026gt;\nshared_ptr\u0026amp;lt;T\u0026amp;gt; t1 = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;shared_ptr\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;(pt);\nshared_ptr\u0026amp;lt;T\u0026amp;gt; t2 = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;shared_ptr\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;(pt);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Always avoid using raw pointer.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For scenario that have to use raw pointer:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/a/19432062/2482283\u0026quot;\u0026gt;https://stackoverflow.com/a/19432062/2482283\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For raw pointer that not nullptr, use reference instead.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; use T*\nuse T\u0026amp;amp;  \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;For optional reference which maybe nullptr, use raw pointer, and which means:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;T* pt; is optional reference \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;and\u0026lt;/span\u0026gt; maybe \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;.\nNot own the raw pointer, \nRaw pointer is managed by some one \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;.\nI only know that the caller is sure it is \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; released now.\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Smart Pointers are those where you don\u0026apos;t have to worry about Memory De-Allocation, Resource Sharing and Transfer. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can very well use these pointer in the similar way as any allocation works in Java. In java Garbage Collector does the trick, while in Smart Pointers, the trick is done by Destructors.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The existing answers are good but don\u0026apos;t cover what to do when a smart pointer is not the (complete) answer to the problem you are trying to solve.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Among other things (explained well in other answers) using a smart pointer is a possible solution to \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/48454208/how-do-we-use-a-abstract-class-as-a-function-return-type\u0026quot;\u0026gt;How do we use a abstract class as a function return type?\u0026lt;/a\u0026gt; which has been marked as a duplicate of this question. However, the first question to ask if tempted to specify an abstract (or in fact, any) base class as a return type in C++ is \u0026quot;what do you really mean?\u0026quot;. There is a good discussion (with further references) of idiomatic object oriented programming in C++ (and how this is different to other languages) in the documentation of the \u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/1_66_0/libs/ptr_container/doc/guidelines.html#recommended-practice-for-object-oriented-programming\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;boost pointer container library\u0026lt;/a\u0026gt;. In summary, in C++ you have to think about ownership. Which smart pointers help you with, but are not the only solution, or always a complete solution (they don\u0026apos;t give you polymorphic copy) and are not always a solution you want to expose in your interface (and a function return sounds an awful lot like an interface). It might be sufficient to return a reference, for example. But in all of these cases (smart pointer, pointer container or simply returning a reference) you have changed the return from a \u0026lt;em\u0026gt;value\u0026lt;/em\u0026gt; to some form of \u0026lt;em\u0026gt;reference\u0026lt;/em\u0026gt;. If you really needed copy you may need to add more boilerplate \u0026quot;idiom\u0026quot; or move beyond idiomatic (or otherwise) OOP in C++ to more generic polymorphism using libraries like \u0026lt;a href=\u0026quot;http://stlab.adobe.com/group__poly__related.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Adobe Poly\u0026lt;/a\u0026gt; or \u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/1_66_0/doc/html/boost_typeerasure.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Boost.TypeErasure\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    "]},"randomTags":[{"name":"equality","slug":"equality"},{"name":"access-modifiers","slug":"access-modifiers"},{"name":"email","slug":"email"},{"name":"three.js","slug":"three.js"},{"name":"operator-precedence","slug":"operator-precedence"},{"name":"python-import","slug":"python-import"},{"name":"unity3d","slug":"unity3d"},{"name":"opengl","slug":"opengl"},{"name":"git-rm","slug":"git-rm"},{"name":"tkinter-canvas","slug":"tkinter-canvas"},{"name":"http-redirect","slug":"http-redirect"},{"name":"viewmodel","slug":"viewmodel"},{"name":"unicode","slug":"unicode"},{"name":"reference","slug":"reference"},{"name":"linux","slug":"linux"},{"name":"c++-faq","slug":"c++-faq"},{"name":"python-internals","slug":"python-internals"},{"name":"importerror","slug":"importerror"},{"name":"linked-list","slug":"linked-list"},{"name":"instance-variables","slug":"instance-variables"}]},"__N_SSG":true},"page":"/questions/tag/[slug]","query":{"slug":"smart-pointers"},"buildId":"BnkbnjkWYxefPXjTJLVVv","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>