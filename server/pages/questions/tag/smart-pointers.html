<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2eccd4d47c856f2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2eccd4d47c856f2b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/81-096e453de8a27667.js" defer=""></script><script src="/_next/static/chunks/pages/questions/tag/%5Bslug%5D-6802ea06aeddcbec.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_buildManifest.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5"></style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="https://flowbite.com/docs/images/logo.svg" class="mr-3 h-6 sm:h-9" alt="Flowbite Logo"/><span class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Hunter</span></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/tag/smart-pointers#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="flex items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-is-a-smart-pointer-and-when-should-i-use-one-1657387905461">What is a smart pointer and when should I use one?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/smart-pointers">smart-pointers</a></div></div><div class="mt-4 mb-6" style="height:100px;overflow:auto"><h4 class="font-semibold">Solution 1:</h4><div class="text-sm bg-green-100 text-neutral-600">
<p><strong>UPDATE</strong></p>

<p>This answer is rather old, and so describes what was 'good' at the time, which was smart pointers provided by the Boost library. Since C++11, the standard library has provided sufficient smart pointers types, and so you should favour the use of <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr" rel="noreferrer"><code>std::unique_ptr</code></a>, <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr" rel="noreferrer"><code>std::shared_ptr</code></a> and <a href="http://en.cppreference.com/w/cpp/memory/weak_ptr" rel="noreferrer"><code>std::weak_ptr</code></a>. </p>

<p>There was also <a href="http://en.cppreference.com/w/cpp/memory/auto_ptr" rel="noreferrer"><code>std::auto_ptr</code></a>. It was very much like a scoped pointer, except that it also had the "special" dangerous ability to be copied  which also unexpectedly transfers ownership.<br>
<strong>It was deprecated in C++11 and removed in C++17</strong>, so you shouldn't use it.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">std::auto_ptr&lt;MyObject&gt; <span class="hljs-title">p1</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> MyObject())</span></span>;
std::auto_ptr&lt;MyObject&gt; p2 = p1; <span class="hljs-comment">// Copy and transfer ownership. </span>
                                 <span class="hljs-comment">// p1 gets set to empty!</span>
p2-&gt;<span class="hljs-built_in">DoSomething</span>(); <span class="hljs-comment">// Works.</span>
p1-&gt;<span class="hljs-built_in">DoSomething</span>(); <span class="hljs-comment">// Oh oh. Hopefully raises some NULL pointer exception.</span>
</code></pre>

<hr>

<p><strong>OLD ANSWER</strong></p>

<p>A smart pointer is a class that wraps a 'raw' (or 'bare') C++ pointer, to manage the lifetime of the object being pointed to. There is no single smart pointer type, but all of them try to abstract a raw pointer in a practical way.</p>

<p>Smart pointers should be preferred over raw pointers. If you feel you need to use pointers (first consider if you <em>really</em> do), you would normally want to use a smart pointer as this can alleviate many of the problems with raw pointers, mainly forgetting to delete the object and leaking memory.</p>

<p>With raw pointers, the programmer has to explicitly destroy the object when it is no longer useful.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// Need to create the object to achieve some goal</span>
MyObject* ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyObject</span>(); 
ptr-&gt;<span class="hljs-built_in">DoSomething</span>(); <span class="hljs-comment">// Use the object in some way</span>
<span class="hljs-keyword">delete</span> ptr; <span class="hljs-comment">// Destroy the object. Done with it.</span>
<span class="hljs-comment">// Wait, what if DoSomething() raises an exception...?</span>
</code></pre>

<p>A smart pointer by comparison defines a policy as to when the object is destroyed. You still have to create the object, but you no longer have to worry about destroying it.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">SomeSmartPtr&lt;MyObject&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> MyObject())</span></span>;
ptr-&gt;<span class="hljs-built_in">DoSomething</span>(); <span class="hljs-comment">// Use the object in some way.</span>

<span class="hljs-comment">// Destruction of the object happens, depending </span>
<span class="hljs-comment">// on the policy the smart pointer class uses.</span>

<span class="hljs-comment">// Destruction would happen even if DoSomething() </span>
<span class="hljs-comment">// raises an exception</span>
</code></pre>

<p>The simplest policy in use involves the scope of the smart pointer wrapper object, such as implemented by <a href="http://www.boost.org/doc/libs/release/libs/smart_ptr/scoped_ptr.htm" rel="noreferrer"><code>boost::scoped_ptr</code></a> or <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr" rel="noreferrer"><code>std::unique_ptr</code></a>. </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{
    {
       <span class="hljs-function">std::unique_ptr&lt;MyObject&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> MyObject())</span></span>;
       ptr-&gt;<span class="hljs-built_in">DoSomethingUseful</span>();
    } <span class="hljs-comment">// ptr goes out of scope -- </span>
      <span class="hljs-comment">// the MyObject is automatically destroyed.</span>

    <span class="hljs-comment">// ptr-&gt;Oops(); // Compile error: "ptr" not defined</span>
                    <span class="hljs-comment">// since it is no longer in scope.</span>
}
</code></pre>

<p>Note that <code>std::unique_ptr</code> instances cannot be copied. This prevents the pointer from being deleted multiple times (incorrectly). You can, however, pass references to it around to other functions you call.</p>

<p><code>std::unique_ptr</code>s are useful when you want to tie the lifetime of the object to a particular block of code, or if you embedded it as member data inside another object, the lifetime of that other object. The object exists until the containing block of code is exited, or until the containing object is itself destroyed.</p>

<p>A more complex smart pointer policy involves reference counting the pointer. This does allow the pointer to be copied. When the last "reference" to the object is destroyed, the object is deleted. This policy is implemented by <a href="http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm" rel="noreferrer"><code>boost::shared_ptr</code></a> and <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr" rel="noreferrer"><code>std::shared_ptr</code></a>.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">typedef</span> std::shared_ptr&lt;MyObject&gt; MyObjectPtr; <span class="hljs-comment">// nice short alias</span>
    MyObjectPtr p1; <span class="hljs-comment">// Empty</span>

    {
        <span class="hljs-function">MyObjectPtr <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> MyObject())</span></span>;
        <span class="hljs-comment">// There is now one "reference" to the created object</span>
        p1 = p2; <span class="hljs-comment">// Copy the pointer.</span>
        <span class="hljs-comment">// There are now two references to the object.</span>
    } <span class="hljs-comment">// p2 is destroyed, leaving one reference to the object.</span>
} <span class="hljs-comment">// p1 is destroyed, leaving a reference count of zero. </span>
  <span class="hljs-comment">// The object is deleted.</span>
</code></pre>

<p>Reference counted pointers are very useful when the lifetime of your object is much more complicated, and is not tied directly to a particular section of code or to another object.</p>

<p>There is one drawback to reference counted pointers  the possibility of creating a dangling reference:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// Create the smart pointer on the heap</span>
MyObjectPtr* pp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyObjectPtr</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MyObject</span>())
<span class="hljs-comment">// Hmm, we forgot to destroy the smart pointer,</span>
<span class="hljs-comment">// because of that, the object is never destroyed!</span>
</code></pre>

<p>Another possibility is creating circular references:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Owner</span> {
   std::shared_ptr&lt;Owner&gt; other;
};

<span class="hljs-function">std::shared_ptr&lt;Owner&gt; <span class="hljs-title">p1</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> Owner())</span></span>;
<span class="hljs-function">std::shared_ptr&lt;Owner&gt; <span class="hljs-title">p2</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> Owner())</span></span>;
p1-&gt;other = p2; <span class="hljs-comment">// p1 references p2</span>
p2-&gt;other = p1; <span class="hljs-comment">// p2 references p1</span>

<span class="hljs-comment">// Oops, the reference count of of p1 and p2 never goes to zero!</span>
<span class="hljs-comment">// The objects are never destroyed!</span>
</code></pre>

<p>To work around this problem, both Boost and C++11 have defined a <code>weak_ptr</code> to define a weak (uncounted) reference to a <code>shared_ptr</code>.</p>
    </div></div><div><div class="flex items-center justify-between text-slate-500"><div class="flex space-x-4 md:space-x-8"><div class="flex cursor-pointer items-center transition hover:text-slate-600"><svg xmlns="http://www.w3.org/2000/svg" class="mr-1.5 h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M14 10h4.764a2 2 0 011.789 2.894l-3.5 7A2 2 0 0115.263 21h-4.017c-.163 0-.326-.02-.485-.06L7 20m7-10V5a2 2 0 00-2-2h-.095c-.5 0-.905.405-.905.905 0 .714-.211 1.412-.608 2.006L7 11v9m7-10h-2M7 20H5a2 2 0 01-2-2v-6a2 2 0 012-2h2.5"></path></svg><span>4</span></div></div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"count":1,"rows":[{"answer":["\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;UPDATE\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This answer is rather old, and so describes what was \u0026apos;good\u0026apos; at the time, which was smart pointers provided by the Boost library. Since C++11, the standard library has provided sufficient smart pointers types, and so you should favour the use of \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/unique_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::unique_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/shared_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::shared_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/weak_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::weak_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There was also \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/auto_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::auto_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;. It was very much like a scoped pointer, except that it also had the \u0026quot;special\u0026quot; dangerous ability to be copied  which also unexpectedly transfers ownership.\u0026lt;br\u0026gt;\n\u0026lt;strong\u0026gt;It was deprecated in C++11 and removed in C++17\u0026lt;/strong\u0026gt;, so you shouldn\u0026apos;t use it.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::auto_ptr\u0026amp;lt;MyObject\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;p1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; MyObject())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\nstd::auto_ptr\u0026amp;lt;MyObject\u0026amp;gt; p2 = p1; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Copy and transfer ownership. \u0026lt;/span\u0026gt;\n                                 \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// p1 gets set to empty!\u0026lt;/span\u0026gt;\np2-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;DoSomething\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Works.\u0026lt;/span\u0026gt;\np1-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;DoSomething\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Oh oh. Hopefully raises some NULL pointer exception.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;OLD ANSWER\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A smart pointer is a class that wraps a \u0026apos;raw\u0026apos; (or \u0026apos;bare\u0026apos;) C++ pointer, to manage the lifetime of the object being pointed to. There is no single smart pointer type, but all of them try to abstract a raw pointer in a practical way.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Smart pointers should be preferred over raw pointers. If you feel you need to use pointers (first consider if you \u0026lt;em\u0026gt;really\u0026lt;/em\u0026gt; do), you would normally want to use a smart pointer as this can alleviate many of the problems with raw pointers, mainly forgetting to delete the object and leaking memory.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;With raw pointers, the programmer has to explicitly destroy the object when it is no longer useful.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Need to create the object to achieve some goal\u0026lt;/span\u0026gt;\nMyObject* ptr = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;MyObject\u0026lt;/span\u0026gt;(); \nptr-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;DoSomething\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Use the object in some way\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; ptr; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Destroy the object. Done with it.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Wait, what if DoSomething() raises an exception...?\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;A smart pointer by comparison defines a policy as to when the object is destroyed. You still have to create the object, but you no longer have to worry about destroying it.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;SomeSmartPtr\u0026amp;lt;MyObject\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ptr\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; MyObject())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\nptr-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;DoSomething\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Use the object in some way.\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Destruction of the object happens, depending \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// on the policy the smart pointer class uses.\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Destruction would happen even if DoSomething() \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// raises an exception\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The simplest policy in use involves the scope of the smart pointer wrapper object, such as implemented by \u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/release/libs/smart_ptr/scoped_ptr.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;boost::scoped_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; or \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/unique_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::unique_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    {\n       \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::unique_ptr\u0026amp;lt;MyObject\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ptr\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; MyObject())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n       ptr-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;DoSomethingUseful\u0026lt;/span\u0026gt;();\n    } \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ptr goes out of scope -- \u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// the MyObject is automatically destroyed.\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ptr-\u0026amp;gt;Oops(); // Compile error: \u0026quot;ptr\u0026quot; not defined\u0026lt;/span\u0026gt;\n                    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// since it is no longer in scope.\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that \u0026lt;code\u0026gt;std::unique_ptr\u0026lt;/code\u0026gt; instances cannot be copied. This prevents the pointer from being deleted multiple times (incorrectly). You can, however, pass references to it around to other functions you call.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;std::unique_ptr\u0026lt;/code\u0026gt;s are useful when you want to tie the lifetime of the object to a particular block of code, or if you embedded it as member data inside another object, the lifetime of that other object. The object exists until the containing block of code is exited, or until the containing object is itself destroyed.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A more complex smart pointer policy involves reference counting the pointer. This does allow the pointer to be copied. When the last \u0026quot;reference\u0026quot; to the object is destroyed, the object is deleted. This policy is implemented by \u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;boost::shared_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/shared_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::shared_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; std::shared_ptr\u0026amp;lt;MyObject\u0026amp;gt; MyObjectPtr; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// nice short alias\u0026lt;/span\u0026gt;\n    MyObjectPtr p1; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Empty\u0026lt;/span\u0026gt;\n\n    {\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;MyObjectPtr \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;p2\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; MyObject())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// There is now one \u0026quot;reference\u0026quot; to the created object\u0026lt;/span\u0026gt;\n        p1 = p2; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Copy the pointer.\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// There are now two references to the object.\u0026lt;/span\u0026gt;\n    } \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// p2 is destroyed, leaving one reference to the object.\u0026lt;/span\u0026gt;\n} \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// p1 is destroyed, leaving a reference count of zero. \u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// The object is deleted.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Reference counted pointers are very useful when the lifetime of your object is much more complicated, and is not tied directly to a particular section of code or to another object.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There is one drawback to reference counted pointers  the possibility of creating a dangling reference:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Create the smart pointer on the heap\u0026lt;/span\u0026gt;\nMyObjectPtr* pp = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;MyObjectPtr\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;MyObject\u0026lt;/span\u0026gt;())\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Hmm, we forgot to destroy the smart pointer,\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// because of that, the object is never destroyed!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Another possibility is creating circular references:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Owner\u0026lt;/span\u0026gt; {\n   std::shared_ptr\u0026amp;lt;Owner\u0026amp;gt; other;\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::shared_ptr\u0026amp;lt;Owner\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;p1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Owner())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::shared_ptr\u0026amp;lt;Owner\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;p2\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Owner())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\np1-\u0026amp;gt;other = p2; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// p1 references p2\u0026lt;/span\u0026gt;\np2-\u0026amp;gt;other = p1; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// p2 references p1\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Oops, the reference count of of p1 and p2 never goes to zero!\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// The objects are never destroyed!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;To work around this problem, both Boost and C++11 have defined a \u0026lt;code\u0026gt;weak_ptr\u0026lt;/code\u0026gt; to define a weak (uncounted) reference to a \u0026lt;code\u0026gt;shared_ptr\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here\u0026apos;s a simple answer for these days of modern C++ (C++11 and later):\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026quot;What is a smart pointer?\u0026quot;\u0026lt;/strong\u0026gt; \u0026lt;br\u0026gt;\nIt\u0026apos;s a type whose values can be used like pointers, but which provides the additional feature of automatic memory management: When a smart pointer is no longer in use, the memory it points to is deallocated (see also \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Smart_pointer\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;the more detailed definition on Wikipedia\u0026lt;/a\u0026gt;).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026quot;When should I use one?\u0026quot;\u0026lt;/strong\u0026gt; \u0026lt;br\u0026gt;\nIn code which involves tracking the ownership of a piece of memory, allocating or de-allocating; the smart pointer often saves you the need to do these things explicitly.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026quot;But which smart pointer should I use in which of those cases?\u0026quot;\u0026lt;/strong\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Use \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/unique_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::unique_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; when you want your object to live just as long as a single owning reference to it lives. For example, use it for a pointer to memory which gets allocated on entering some scope and de-allocated on exiting the scope.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Use \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/shared_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::shared_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; when you do want to refer to your object from multiple places - and do not want your object to be de-allocated until all these references are themselves gone.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Use \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/weak_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::weak_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; when you do want to refer to your object from multiple places - for those references for which it\u0026apos;s ok to ignore and deallocate (so they\u0026apos;ll just note the object is gone when you try to dereference).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Don\u0026apos;t use the \u0026lt;code\u0026gt;boost::\u0026lt;/code\u0026gt; smart pointers or \u0026lt;code\u0026gt;std::auto_ptr\u0026lt;/code\u0026gt; except in special cases which you can read up on if you must.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026quot;Hey, I didn\u0026apos;t ask which one to use!\u0026quot;\u0026lt;/strong\u0026gt; \u0026lt;br\u0026gt;\nAh, but you really wanted to, admit it.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026quot;So when should I use regular pointers then?\u0026quot;\u0026lt;/strong\u0026gt; \u0026lt;br\u0026gt;\nMostly in code that is oblivious to memory ownership. This would typically be in functions which get a pointer from someplace else and do not allocate nor de-allocate, and do not store a copy of the pointer which outlasts their execution.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Smart_pointer\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;smart pointer\u0026lt;/a\u0026gt; is a pointer-like type with some additional functionality, e.g. automatic memory deallocation, reference counting etc.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A small intro is available on the page \u0026lt;a href=\u0026quot;http://ootips.org/yonat/4dev/smart-pointers.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Smart Pointers - What, Why, Which?\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;One of the simple smart-pointer types is \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/auto_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::auto_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; (chapter 20.4.5 of C++ standard), which allows one to deallocate memory automatically when it out of scope and which is more robust than simple pointer usage when exceptions are thrown, although less flexible.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Another convenient type is \u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/1_36_0/libs/smart_ptr/shared_ptr.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;boost::shared_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; which implements reference counting and automatically deallocates memory when no references to the object remains. This helps avoiding memory leaks and is easy to use to implement \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;RAII\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The subject is covered in depth in book \u0026lt;a href=\u0026quot;https://rads.stackoverflow.com/amzn/click/com/0201734842\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026quot;C++ Templates: The Complete Guide\u0026quot; by David Vandevoorde, Nicolai M. Josuttis\u0026lt;/a\u0026gt;, chapter Chapter 20. Smart Pointers.\nSome topics covered:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Protecting Against Exceptions\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Holders, (note, \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/auto_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;std::auto_ptr\u0026lt;/a\u0026gt; is implementation of such type of smart pointer)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Resource_acquisition_is_initialization\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Resource Acquisition Is Initialization\u0026lt;/a\u0026gt; (This is frequently used for exception-safe resource management in C++)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Holder Limitations\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Reference_counting\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Reference Counting\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Concurrent Counter Access\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Destruction and Deallocation\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Definitions provided by Chris, Sergdev and Llyod are correct. I prefer a simpler definition though, just to keep my life simple:\nA smart pointer is simply a class that overloads the \u0026lt;code\u0026gt;-\u0026amp;gt;\u0026lt;/code\u0026gt;  and \u0026lt;code\u0026gt;*\u0026lt;/code\u0026gt; operators. Which means that your object semantically looks like a pointer but you can make it do way cooler things, including reference counting, automatic destruction etc.\n\u0026lt;code\u0026gt;shared_ptr\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;auto_ptr\u0026lt;/code\u0026gt; are sufficient in most cases, but come along with their own set of small idiosyncrasies.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A smart pointer is like a regular (typed) pointer, like \u0026quot;char*\u0026quot;, except when the pointer itself goes out of scope then what it points to is deleted as well. You can use it like you would a regular pointer, by using \u0026quot;-\u0026amp;gt;\u0026quot;, but not if you need an actual pointer to the data. For that, you can use \u0026quot;\u0026amp;amp;*ptr\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It is useful for:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Objects that must be allocated with new, but that you\u0026apos;d like to have the same lifetime as something on that stack. If the object is assigned to a smart pointer, then they will be deleted when the program exits that function/block.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Data members of classes, so that when the object is deleted all the owned data is deleted as well, without any special code in the destructor (you will need to be sure the destructor is virtual, which is almost always a good thing to do).\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;You may \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; want to use a smart pointer when:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;... the pointer shouldn\u0026apos;t actually own the data... i.e., when you are just using the data, but you want it to survive the function where you are referencing it.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;... the smart pointer isn\u0026apos;t itself going to be destroyed at some point. You don\u0026apos;t want it to sit in memory that never gets destroyed (such as in an object that is dynamically allocated but won\u0026apos;t be explicitly deleted).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;... two smart pointers might point to the same data. (There are, however, even smarter pointers that will handle that... that is called \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Reference_counting\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;reference counting\u0026lt;/a\u0026gt;.)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;See also:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;garbage collection\u0026lt;/a\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/94227/smart-pointers-or-who-owns-you-baby\u0026quot;\u0026gt;This stack overflow question\u0026lt;/a\u0026gt; regarding data ownership\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A smart pointer is an object that acts like a pointer, but additionally provides control on construction, destruction, copying, moving and dereferencing.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;One can implement one\u0026apos;s own smart pointer, but many libraries also provide smart pointer implementations each with different advantages and drawbacks.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example, \u0026lt;a href=\u0026quot;http://www.boost.org/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Boost\u0026lt;/a\u0026gt; provides the following smart pointer implementations:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;shared_ptr\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; is a pointer to \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; using a reference count to determine when the object is no longer needed.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;scoped_ptr\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; is a pointer automatically deleted when it goes out of scope. No assignment is possible.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;intrusive_ptr\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; is another reference counting pointer. It provides better performance than \u0026lt;code\u0026gt;shared_ptr\u0026lt;/code\u0026gt;, but requires the type \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; to provide its own reference counting mechanism.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;weak_ptr\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; is a weak pointer, working in conjunction with \u0026lt;code\u0026gt;shared_ptr\u0026lt;/code\u0026gt; to avoid circular references.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;shared_array\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; is like \u0026lt;code\u0026gt;shared_ptr\u0026lt;/code\u0026gt;, but for arrays of \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;scoped_array\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; is like \u0026lt;code\u0026gt;scoped_ptr\u0026lt;/code\u0026gt;, but for arrays of \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;These are just one linear descriptions of each and can be used as per need, for further detail and examples one can look at the documentation of Boost.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Additionally, the C++ standard library provides three smart pointers; \u0026lt;code\u0026gt;std::unique_ptr\u0026lt;/code\u0026gt; for unique ownership, \u0026lt;code\u0026gt;std::shared_ptr\u0026lt;/code\u0026gt; for shared ownership and \u0026lt;code\u0026gt;std::weak_ptr\u0026lt;/code\u0026gt;. \u0026lt;code\u0026gt;std::auto_ptr\u0026lt;/code\u0026gt; existed in C++03 but is now deprecated.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Most kinds of smart pointers handle disposing of the pointer-to object for you. It\u0026apos;s very handy because you don\u0026apos;t have to think about disposing of objects manually anymore.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The most commonly-used smart pointers are \u0026lt;code\u0026gt;std::tr1::shared_ptr\u0026lt;/code\u0026gt; (or \u0026lt;code\u0026gt;boost::shared_ptr\u0026lt;/code\u0026gt;), and, less commonly, \u0026lt;code\u0026gt;std::auto_ptr\u0026lt;/code\u0026gt;. I recommend regular use of \u0026lt;code\u0026gt;shared_ptr\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;shared_ptr\u0026lt;/code\u0026gt; is very versatile and deals with a large variety of disposal scenarios, including cases where objects need to be \u0026quot;passed across DLL boundaries\u0026quot; (the common nightmare case if different \u0026lt;code\u0026gt;libc\u0026lt;/code\u0026gt;s are used between your code and the DLLs).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is the Link for similar answers : \u0026lt;a href=\u0026quot;http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html\u0026quot;\u0026gt;http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A smart pointer is an object that acts, looks and feels like a normal pointer but offers more functionality. In C++, smart pointers are implemented as template classes that encapsulate a pointer and override standard pointer operators. They have a number of advantages over regular pointers. They are guaranteed to be initialized as either null pointers or pointers to a heap object. Indirection through a null pointer is checked. No delete is ever necessary. Objects are automatically freed when the last pointer to them has gone away. One significant problem with these smart pointers is that unlike regular pointers, they don\u0026apos;t respect inheritance. Smart pointers are unattractive for polymorphic code. Given below is an example for the implementation of smart pointers.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Example:\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;smart_pointer\u0026lt;/span\u0026gt;\n{\n          \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n               \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;smart_pointer\u0026lt;/span\u0026gt;();                          \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// makes a null pointer\u0026lt;/span\u0026gt;\n               \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;smart_pointer\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; X\u0026amp;amp; x)            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// makes pointer to copy of x\u0026lt;/span\u0026gt;\n\n               X\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; *( );\n               \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; X\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;*( ) \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;;\n               X* \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;-\u0026amp;gt;() \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;;\n\n               \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;smart_pointer\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; smart_pointer \u0026amp;lt;X\u0026amp;gt; \u0026amp;amp;);\n               \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; smart_pointer \u0026amp;lt;X\u0026amp;gt; \u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; =(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; smart_pointer\u0026amp;lt;X\u0026amp;gt;\u0026amp;amp;);\n               ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;smart_pointer\u0026lt;/span\u0026gt;();\n          \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n               \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//...\u0026lt;/span\u0026gt;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This class implement a smart pointer to an object of type X. The object itself is located on the heap. Here is how to use it:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;smart_pointer \u0026amp;lt;employee\u0026amp;gt; p= \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;employee\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Harris\u0026quot;\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1333\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Like other overloaded operators, p will behave like a regular pointer,\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;cout\u0026amp;lt;\u0026amp;lt;*p;\np-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;raise_salary\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.5\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Let T be a class in this tutorial \nPointers in C++ can be divided into 3 types :\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;1) \u0026lt;strong\u0026gt;Raw pointers\u0026lt;/strong\u0026gt; :\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;T a;  \nT * _ptr = \u0026amp;amp;a; \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;They hold a memory address to a location in memory. Use with caution , as programs become complex hard to keep track. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Pointers with const data or address { Read backwards } \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;T a ; \n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T * ptr1 = \u0026amp;amp;a ; \nT \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; * ptr1 = \u0026amp;amp;a ;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Pointer to a data type T which is a const. Meaning you cannot change the data type using the pointer. ie \u0026lt;code\u0026gt;*ptr1 = 19\u0026lt;/code\u0026gt; ; will not work. But you can move the pointer. ie \u0026lt;code\u0026gt;ptr1++ , ptr1--\u0026lt;/code\u0026gt; ;  etc will work.\nRead backwards : pointer to type T which is const \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;  T * \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; ptr2 ;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;A const pointer to a data type T . Meaning you cannot move the pointer but you can change the value pointed to by the pointer. ie \u0026lt;code\u0026gt;*ptr2 = 19\u0026lt;/code\u0026gt; will work but \u0026lt;code\u0026gt;ptr2++ ; ptr2--\u0026lt;/code\u0026gt; etc will not work. Read backwards : const pointer to a type T \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T * \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; ptr3 ; \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;A const pointer to a const data type T . Meaning you cannot either move the pointer nor can you change the data type pointer to be the pointer. ie . \u0026lt;code\u0026gt;ptr3-- ; ptr3++ ; *ptr3 = 19;\u0026lt;/code\u0026gt; will not work \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;3) \u0026lt;strong\u0026gt;Smart Pointers\u0026lt;/strong\u0026gt; : { \u0026lt;code\u0026gt;#include \u0026amp;lt;memory\u0026amp;gt;\u0026lt;/code\u0026gt; } \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Shared Pointer\u0026lt;/strong\u0026gt;: \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;  T a ; \n     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//shared_ptr\u0026amp;lt;T\u0026amp;gt; shptr(new T) ; not recommended but works \u0026lt;/span\u0026gt;\n     shared_ptr\u0026amp;lt;T\u0026amp;gt; shptr = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;make_shared\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// faster + exception safe\u0026lt;/span\u0026gt;\n\n     std::cout \u0026amp;lt;\u0026amp;lt; shptr.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;use_count\u0026lt;/span\u0026gt;() ; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 1 //  gives the number of \u0026quot; \u0026lt;/span\u0026gt;\nthings \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; pointing to it. \n     T * temp = shptr.get(); // gives a pointer to object\n\n     // shared_pointer used like a regular pointer to call member functions\n      shptr-\u0026amp;gt;memFn();\n     (*shptr).memFn(); \n\n    //\n     shptr.reset() ; // frees the object pointed to be the ptr \n     shptr = nullptr ; // frees the object \n     shptr = make_shared\u0026amp;lt;T\u0026amp;gt;() ; // frees the original object and points to new object\n\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Implemented using reference counting to keep track of how many \u0026quot; things \u0026quot; point to the object pointed to by the pointer. When this count goes to 0 , the object is automatically deleted , ie objected is deleted when all the share_ptr pointing to the object goes out of scope. \nThis gets rid of the headache of having to delete objects which you have allocated using new. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Weak Pointer :\u0026lt;/strong\u0026gt; \n    Helps deal with cyclic reference which arises when using Shared Pointer\n    If you have two objects pointed to by two shared pointers and there is an internal shared pointer pointing to each others shared pointer then there will be a cyclic reference and the object will not be deleted when shared pointers go out of scope. To solve this , change the internal member from a shared_ptr to weak_ptr. Note : To access the element pointed to by a weak pointer use lock() , this returns a weak_ptr. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;T a ; \nshared_ptr\u0026amp;lt;T\u0026amp;gt; shr = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;make_shared\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;() ; \nweak_ptr\u0026amp;lt;T\u0026amp;gt; wk = shr ; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// initialize a weak_ptr from a shared_ptr \u0026lt;/span\u0026gt;\nwk.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;lock\u0026lt;/span\u0026gt;()-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;memFn\u0026lt;/span\u0026gt;() ; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// use lock to get a shared_ptr \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//   ^^^ Can lead to exception if the shared ptr has gone out of scope\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(!wk.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;expired\u0026lt;/span\u0026gt;()) wk.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;lock\u0026lt;/span\u0026gt;()-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;memFn\u0026lt;/span\u0026gt;() ;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Check if shared ptr has gone out of scope before access\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;See : \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful\u0026quot;\u0026gt;When is std::weak_ptr useful?\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Unique Pointer :\u0026lt;/strong\u0026gt; \n    Light weight smart pointer with exclusive ownership. Use when pointer points to unique objects without sharing the objects between the pointers.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;unique_ptr\u0026amp;lt;T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;uptr\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; T)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\nuptr-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;memFn\u0026lt;/span\u0026gt;(); \n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//T * ptr = uptr.release(); // uptr becomes null and object is pointed to by ptr\u0026lt;/span\u0026gt;\nuptr.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;reset\u0026lt;/span\u0026gt;() ; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// deletes the object pointed to by uptr \u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;To change the object pointed to by the unique ptr , use move semantics\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;unique_ptr\u0026amp;lt;T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;uptr1\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; T)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;unique_ptr\u0026amp;lt;T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;uptr2\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; T)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\nuptr2 = std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;move\u0026lt;/span\u0026gt;(uptr1); \n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// object pointed by uptr2 is deleted and \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// object pointed by uptr1 is pointed to by uptr2\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// uptr1 becomes null \u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;References : \n    They can essentially be though of as const pointers, ie a pointer which is const and cannot be moved with better syntax.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;See : \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in\u0026quot;\u0026gt;What are the differences between a pointer variable and a reference variable in C++?\u0026lt;/a\u0026gt;  \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;r-value reference : reference to a temporary object   \nl-value reference : reference to an object whose address can be obtained\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; reference : reference to a data type which is \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;and\u0026lt;/span\u0026gt; cannot be modified \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Reference : \n\u0026lt;a href=\u0026quot;https://www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ\u0026lt;/a\u0026gt; \nThanks to Andre for pointing out this question.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Smart_pointer\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://en.wikipedia.org/wiki/Smart_pointer\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;In computer science, a smart pointer\n  is an abstract data type that\n  simulates a pointer while providing\n  additional features, such as automatic\n  garbage collection or bounds checking.\n  These additional features are intended\n  to reduce bugs caused by the misuse of\n  pointers while retaining efficiency.\n  Smart pointers typically keep track of\n  the objects that point to them for the\n  purpose of memory management. The\n  misuse of pointers is a major source\n  of bugs: the constant allocation,\n  deallocation and referencing that must\n  be performed by a program written\n  using pointers makes it very likely\n  that some memory leaks will occur.\n  Smart pointers try to prevent memory\n  leaks by making the resource\n  deallocation automatic: when the\n  pointer to an object (or the last in a\n  series of pointers) is destroyed, for\n  example because it goes out of scope,\n  the pointed object is destroyed too.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A smart pointer is a class, a wrapper of a normal pointer. Unlike normal pointers, smart points life circle is based on a reference count (how many time the smart pointer object is assigned). So whenever a smart pointer is assigned to another one, the internal reference count plus plus. And whenever the object goes out of scope, the reference count minus minus.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Automatic pointer, though looks similar, is totally different from smart pointer. It is a convenient class that deallocates the resource whenever an automatic pointer object goes out of variable scope. To some extent, it makes a pointer (to dynamically allocated memory) works similar to a stack variable (statically allocated in compiling time).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;What is a smart pointer.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Long version, In principle:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://web.stanford.edu/class/archive/cs/cs106l/cs106l.1192/lectures/lecture15/15_RAII.pdf\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://web.stanford.edu/class/archive/cs/cs106l/cs106l.1192/lectures/lecture15/15_RAII.pdf\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A modern C++ idiom:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;RAII: Resource Acquisition Is Initialization.\n\n When you initialize an object, \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;it should already have \n  acquired any resources it \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;needs\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(in the constructor)\u0026lt;/span\u0026gt;.\n\n\n When an object goes out of scope, it should release every \n  resource it is \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; the destructor)\u0026lt;/span\u0026gt;.\n\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;key point:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt; There should never be a half-ready \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;or\u0026lt;/span\u0026gt; half-dead object.\n When an object is created, it should be in a ready state.\n When an object goes out of scope, it should release its resources. \n The user shouldnt have to \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;do\u0026lt;/span\u0026gt; anything more. \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Raw Pointers violate RAII\u0026lt;/strong\u0026gt;: It need user to delete manually when the pointers go out of scope.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;RAII solution is:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;Have a smart pointer \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;:\n Allocates the memory when initialized\n Frees the memory when destructor is called\n Allows access to underlying pointer\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;For smart pointer need copy and share, use shared_ptr:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt; use another memory to store Reference counting \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;and\u0026lt;/span\u0026gt; shared.\n increment when copy, decrement when destructor.\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; memory when Reference counting is \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.\u0026lt;/span\u0026gt; \n  also \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; memory that store Reference counting.\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;for smart pointer not own the raw pointer, use weak_ptr:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; change Reference counting.\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;shared_ptr usage:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;correct way:\nstd::shared_ptr\u0026amp;lt;T\u0026amp;gt; t1 = std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;make_shared\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;(TArgs);\nstd::shared_ptr\u0026amp;lt;T\u0026amp;gt; t2 = std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;shared_ptr\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;(Targs));\n\nwrong way:\nT* pt = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;(TArgs); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// never exposure the raw pointer\u0026lt;/span\u0026gt;\nshared_ptr\u0026amp;lt;T\u0026amp;gt; t1 = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;shared_ptr\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;(pt);\nshared_ptr\u0026amp;lt;T\u0026amp;gt; t2 = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;shared_ptr\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;(pt);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Always avoid using raw pointer.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For scenario that have to use raw pointer:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/a/19432062/2482283\u0026quot;\u0026gt;https://stackoverflow.com/a/19432062/2482283\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For raw pointer that not nullptr, use reference instead.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; use T*\nuse T\u0026amp;amp;  \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;For optional reference which maybe nullptr, use raw pointer, and which means:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;T* pt; is optional reference \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;and\u0026lt;/span\u0026gt; maybe \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;.\nNot own the raw pointer, \nRaw pointer is managed by some one \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;.\nI only know that the caller is sure it is \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; released now.\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Smart Pointers are those where you don\u0026apos;t have to worry about Memory De-Allocation, Resource Sharing and Transfer. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can very well use these pointer in the similar way as any allocation works in Java. In java Garbage Collector does the trick, while in Smart Pointers, the trick is done by Destructors.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The existing answers are good but don\u0026apos;t cover what to do when a smart pointer is not the (complete) answer to the problem you are trying to solve.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Among other things (explained well in other answers) using a smart pointer is a possible solution to \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/48454208/how-do-we-use-a-abstract-class-as-a-function-return-type\u0026quot;\u0026gt;How do we use a abstract class as a function return type?\u0026lt;/a\u0026gt; which has been marked as a duplicate of this question. However, the first question to ask if tempted to specify an abstract (or in fact, any) base class as a return type in C++ is \u0026quot;what do you really mean?\u0026quot;. There is a good discussion (with further references) of idiomatic object oriented programming in C++ (and how this is different to other languages) in the documentation of the \u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/1_66_0/libs/ptr_container/doc/guidelines.html#recommended-practice-for-object-oriented-programming\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;boost pointer container library\u0026lt;/a\u0026gt;. In summary, in C++ you have to think about ownership. Which smart pointers help you with, but are not the only solution, or always a complete solution (they don\u0026apos;t give you polymorphic copy) and are not always a solution you want to expose in your interface (and a function return sounds an awful lot like an interface). It might be sufficient to return a reference, for example. But in all of these cases (smart pointer, pointer container or simply returning a reference) you have changed the return from a \u0026lt;em\u0026gt;value\u0026lt;/em\u0026gt; to some form of \u0026lt;em\u0026gt;reference\u0026lt;/em\u0026gt;. If you really needed copy you may need to add more boilerplate \u0026quot;idiom\u0026quot; or move beyond idiomatic (or otherwise) OOP in C++ to more generic polymorphism using libraries like \u0026lt;a href=\u0026quot;http://stlab.adobe.com/group__poly__related.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Adobe Poly\u0026lt;/a\u0026gt; or \u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/1_66_0/doc/html/boost_typeerasure.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Boost.TypeErasure\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    "],"comment":["\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Check out this question:\u0026amp;lt;br\u0026amp;gt; \u0026lt;a href=\u0026quot;http://stackoverflow.com/questions/94227/smart-pointers-or-who-owns-you-baby\u0026quot;\u0026gt;Smart Pointers: Or who owns you baby\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/14065/martin-york\u0026quot; title=\u0026quot;247,789 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Martin York\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment14871949_106508\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2008-09-20 00:32:20Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 20, 2008 at 0:32\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Note that the implementation of std::auto_ptr in Visual Studio 2005 is horribly broken. \u0026amp;lt;br\u0026amp;gt;\u0026lt;a href=\u0026quot;http://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=98871\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;http://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=98871\u0026lt;/a\u0026gt;\u0026amp;lt;br\u0026amp;gt; \u0026lt;a href=\u0026quot;http://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=101842\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;http://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=101842\u0026lt;/a\u0026gt; Use the boost ones instead.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/19897/richard\u0026quot; title=\u0026quot;683 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Richard\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment43907532_106508\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2008-09-21 10:14:36Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 21, 2008 at 10:14\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Two excellent articles on the subject: - \u0026lt;a href=\u0026quot;http://ootips.org/yonat/4dev/smart-pointers.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Smart Pointers - What, Why, Which?\u0026lt;/a\u0026gt; - \u0026lt;a href=\u0026quot;http://www.gotw.ca/gotw/025.htm\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Guru of the Week #25\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/113124/lazer\u0026quot; title=\u0026quot;86,109 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Lazer\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment14882648_106508\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-06-25 19:15:43Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 25, 2010 at 19:15\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Here\u0026apos;s Alexandrescu\u0026apos;s (free) chapter on the nitty gritty of creating smart pointers of different flavors: \u0026lt;a href=\u0026quot;http://www.informit.com/articles/article.aspx?p=31529\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;informit.com/articles/article.aspx?p=31529\u0026lt;/a\u0026gt;  In his implementation, he uses template arguments as \u0026quot;policies\u0026quot; to specify which attributes he wants (e.g., reference counting), whereas the standard library uses separate classes. Note that he was also writing before rvalue references were available to make something like std::unique_ptr possible.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/201787/metal\u0026quot; title=\u0026quot;5,887 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;metal\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment21954744_106508\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-03-19 16:30:44Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 19, 2013 at 16:30\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I would like to add one more point to the above question, smart pointer std::shared_ptr doesnt have subscript operator and doesnt support ponter arithmetic, we can use get() to obtain a built in pointer.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/8654234/suresh-m\u0026quot; title=\u0026quot;565 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;suresh m\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment97219214_106508\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-02-07 13:57:49Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 7, 2018 at 13:57\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Do you mean \u0026lt;code\u0026gt;std::auto_ptr\u0026amp;lt;MyObject\u0026amp;gt; p1 (new MyObject());\u0026lt;/code\u0026gt; instead of \u0026lt;code\u0026gt;std::auto_ptr\u0026amp;lt;MyObject\u0026amp;gt; p1 (new Owner());\u0026lt;/code\u0026gt;?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/365102/mateen-ulhaq\u0026quot; title=\u0026quot;21,698 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Mateen Ulhaq\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment7959681_106614\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-07-16 23:06:45Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 16, 2011 at 23:06\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Awesome answer. It would be nice if it were updated for c++11. I found this answer looking for info about the new 11 standard and it would be nice if future visitors could find the updated info. I know auto_ptr has been deprecated. I believe shated_ptr and weak_ptr exist as described, and I think the scoped_ptr is now unique_ptr in the standard. If this is true, can this answer be updated please?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/256048/saulback\u0026quot; title=\u0026quot;1,396 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;SaulBack\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment16626843_106614\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-09-11 20:50:06Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 11, 2012 at 20:50\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;To say that the possibility of creating a dangling reference is a drawback to reference counted pointers is absolutely insane. Possible dangling references are a drawback of \u0026lt;b\u0026gt;any C++ pointer\u0026lt;/b\u0026gt;. In fact, it is \u0026lt;i\u0026gt;exactly that drawback\u0026lt;/i\u0026gt; which smart pointers are intended to \u0026lt;i\u0026gt;alleviate\u0026lt;/i\u0026gt;.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1291990/michael-dorst\u0026quot; title=\u0026quot;7,451 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Michael Dorst\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment39426140_106614\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-08-13 21:59:06Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 13, 2014 at 21:59\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 5 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;If you declare a pointer to a smart pointer (as was done in the example) you knowingly give up all benefits of the smart pointer. This is not a drawback or a design flaw, it is the most idiotic usage imaginable.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1291990/michael-dorst\u0026quot; title=\u0026quot;7,451 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Michael Dorst\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment39426222_106614\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-08-13 22:02:09Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 13, 2014 at 22:02\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;A \u0026lt;code\u0026gt;const std::auto_ptr\u0026lt;/code\u0026gt; is safe to use, if you\u0026apos;re stuck with C++03.  I used it for pimpl pattern quite a lot until I got access to C++11.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/4850040/toby-speight\u0026quot; title=\u0026quot;25,310 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Toby Speight\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment53108443_106614\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-09-17 11:55:31Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 17, 2015 at 11:55\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;It is worth noting that while smart (owning) pointers help with proper memory management, raw (non-owning) pointers are still useful for other organizational purposes in data structures.  Herb Sutter gave a great presentation upon this matter at CppCon 2016, that you can see on YouTube: \u0026lt;a href=\u0026quot;https://youtu.be/JfmTagWcqoE\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Leak-Freedom in C++... By Default.\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1442833/wiktor-wandachowicz\u0026quot; title=\u0026quot;85 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;wiktor.wandachowicz\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment68395522_30143936\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-11-13 23:22:55Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 13, 2016 at 23:22\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@wiktor.wandachowicz \u0026lt;code\u0026gt;T*\u0026lt;/code\u0026gt; is to \u0026lt;code\u0026gt;std::unique_ptr\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; what \u0026lt;code\u0026gt;std::weak_ptr\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; is to \u0026lt;code\u0026gt;std::shared_ptr\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2610810/caleth\u0026quot; title=\u0026quot;46,148 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Caleth\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment102358873_30143936\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-09-17 12:50:28Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 17, 2019 at 12:50\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Caleth: No, I wouldn\u0026apos;t say that.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1593077/einpoklum\u0026quot; title=\u0026quot;103,988 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;einpoklum\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment102362569_30143936\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-09-17 14:27:11Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 17, 2019 at 14:27\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Caleth That is not accurate. \u0026lt;code\u0026gt;T*\u0026lt;/code\u0026gt; is to \u0026lt;code\u0026gt;std::unique_ptr\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; what \u0026lt;code\u0026gt;T*\u0026lt;/code\u0026gt; is to \u0026lt;code\u0026gt;std::shared_ptr\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt;. In both cases, if you want a non-owning pointer to the managed object you should use a raw pointer. \u0026lt;code\u0026gt;weak_ptr\u0026lt;/code\u0026gt; is not well suited for that purpose.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/7359094/fran%c3%a7ois-andrieux\u0026quot; title=\u0026quot;26,541 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;François Andrieux\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment126497926_30143936\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2022-03-22 13:58:40Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 22 at 13:58\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Warning \u0026lt;code\u0026gt;std::auto_ptr\u0026lt;/code\u0026gt; is deprecated and highly discourage as you can accidentally transfer ownership. -- C++11 removes the need of Boost, use:  \u0026lt;code\u0026gt;std::unique_ptr\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;std::shared_ptr\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;std::weak_ptr\u0026lt;/code\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/341744/ninmonkey\u0026quot; title=\u0026quot;6,970 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;ninMonkey\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment99706639_106568\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-06-12 13:38:20Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 12, 2019 at 13:38\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Please explain why \u0026lt;code\u0026gt;scoped_ptr\u0026lt;/code\u0026gt; is not like a locally-declared \u0026lt;code\u0026gt;const unique_ptr\u0026lt;/code\u0026gt; - which also gets deleted on exiting the scope.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1593077/einpoklum\u0026quot; title=\u0026quot;103,988 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;einpoklum\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment56780656_15357935\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-12-29 21:54:07Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 29, 2015 at 21:54\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        "],"id":414,"title":"What is a smart pointer and when should I use one?","content":"\n                \n\u0026lt;p\u0026gt;What is a smart pointer and when should I use one?\u0026lt;/p\u0026gt;\n    ","slug":"what-is-a-smart-pointer-and-when-should-i-use-one-1657387905461","postType":"QUESTION","createdAt":"2022-07-09T17:31:45.000Z","updatedAt":"2022-07-09T17:31:45.000Z","tags":[{"id":2202,"name":"smart-pointers","slug":"smart-pointers","createdAt":"2022-07-09T17:31:45.000Z","updatedAt":"2022-07-09T17:31:45.000Z","Questions_Tags":{"questionId":414,"tagId":2202}}]}]}},"__N_SSG":true},"page":"/questions/tag/[slug]","query":{"slug":"smart-pointers"},"buildId":"4Y8KGE-c2lolBeBmcum_I","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>