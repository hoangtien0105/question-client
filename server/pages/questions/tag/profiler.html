<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2eccd4d47c856f2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2eccd4d47c856f2b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/81-096e453de8a27667.js" defer=""></script><script src="/_next/static/chunks/pages/questions/tag/%5Bslug%5D-6802ea06aeddcbec.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_buildManifest.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5"></style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="https://flowbite.com/docs/images/logo.svg" class="mr-3 h-6 sm:h-9" alt="Flowbite Logo"/><span class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Hunter</span></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/tag/profiler#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="flex items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/alternatives-to-gprof-closed-1657388336554">Alternatives to gprof [closed]</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/profiler">profiler</a></div></div><div class="mt-4 mb-6" style="height:100px;overflow:auto"><h4 class="font-semibold">Solution 1:</h4><div class="text-sm bg-green-100 text-neutral-600">
<p><strong>gprof</strong> <a href="http://docs.freebsd.org/44doc/psd/18.gprof/paper.pdf" rel="noreferrer">(read the paper)</a> exists for historical reasons. 
If you think it will help you find performance problems, it was never advertised as such.
Here's what the paper says:</p>

<blockquote>
  <p>The prole can be used to compare and assess the costs of
  various implementations.</p>
</blockquote>

<p>It does not say it can be used to <em>identify</em> the various implementations to be assessed, although it does <em>imply</em> that it could, under special circumstances:</p>

<blockquote>
  <p>especially if small portions of the program are found to dominate its
  execution time.</p>
</blockquote>

<p>What about problems that are not so localized?
Do those not matter?
Don't place expectations on <strong>gprof</strong> that were never claimed for it.
It is <em>only</em> a measurement tool, and only of CPU-bound operations.</p>

<p><a href="https://stackoverflow.com/questions/375913/what-can-i-use-to-profile-c-code-in-linux/378024#378024">Try this instead.</a><br>
<a href="https://stackoverflow.com/questions/926266/performance-optimization-strategies-of-last-resort/927773#927773">Here's an example of a 44x speedup.</a><br>
<a href="https://scicomp.stackexchange.com/a/1870/1262">Here's a 730x speedup.</a><br>
<a href="http://youtu.be/xPg3sRpdW1U" rel="noreferrer">Here's an 8-minute video demonstration.</a><br>
<a href="https://scicomp.stackexchange.com/a/2719/1262">Here's an explanation of the statistics.</a><br>
<a href="https://stackoverflow.com/a/18217639/23771">Here's an answer to critiques.</a>  </p>

<p>There's a simple observation about programs. In a given execution, every instruction is responsible for some fraction of the overall time (especially <code>call</code> instructions), in the sense that if it were not there, the time would not be spent. During that time, the instruction is on the stack **. When that is understood, you can see that -  </p>

<p><strong>gprof</strong> embodies certain myths about performance, such as:</p>

<ol>
<li><p><em>that program counter sampling is useful.</em><br>
It is only useful if you have an unnecessary hotspot bottleneck such as a bubble sort of a big array of scalar values. As soon as you, for example, change it into a sort using string-compare, it is still a bottleneck, but program counter sampling will not see it because now the hotspot is in string-compare. On the other hand if it were to sample the <strong>extended</strong> program counter (the call stack), the point at which the string-compare is called, the sort loop, is clearly displayed. <em>In fact, <strong>gprof</strong> was an attempt to remedy the limitations of pc-only sampling.</em></p></li>
<li><p><em>that timing functions is more important than capturing time-consuming lines of code.</em><br>
The reason for that myth is that <strong>gprof</strong> was not able to capture stack samples, so instead it times functions, counts their invocations, and tries to capture the call graph. However, once a costly function is identified, you still need to look inside it for the lines that are responsible for the time. If there were stack samples you would not need to look, those lines would be on the samples. (A typical function might have 100 - 1000 instructions. A function <em>call</em> is 1 instruction, so something that locates costly calls is 2-3 orders of magnitude more precise.)</p></li>
<li><p><em>that the call graph is important.</em><br>
What you need to know about a program is not <strong>where</strong> it spends its time, but <strong>why</strong>. When it is spending time in a function, every line of code on the stack gives one link in the chain of reasoning of why it is there. If you can only see part of the stack, you can only see part of the reason why, so you can't tell for sure if that time is actually necessary.
What does the call graph tell you? Each arc tells you that some function A was in the process of calling some function B for some fraction of the time. Even if A has only one such line of code calling B, that line only gives a small part of the reason why. If you are lucky enough, maybe that line has a poor reason. Usually, you need to see multiple simultaneous lines to find a poor reason if it is there. If A calls B in more than one place, then it tells you even less.</p></li>
<li><p><em>that recursion is a tricky confusing issue.</em><br>
That is only because <strong>gprof</strong> and other profilers perceive a need to generate a call-graph and then attribute times to the nodes. If one has samples of the stack, the time-cost of each line of code that appears on samples is a very simple number - the fraction of samples it is on. If there is recursion, then a given line can appear more than once on a sample. 
<em>No matter.</em> Suppose samples are taken every N ms, and the line appears on F% of them (singly or not). If that line can be made to take no time (such as by deleting it or branching around it), then those samples would <em>disappear</em>, and the time would be reduced by F%.</p></li>
<li><p><em>that accuracy of time measurement (and therefore a large number of samples) is important.</em><br>
Think about it for a second. If a line of code is on 3 samples out of five, then if you could shoot it out like a light bulb, that is roughly 60% less time that would be used. Now, you know that if you had taken a different 5 samples, you might have only seen it 2 times, or as many as 4. So that 60% measurement is more like a general range from 40% to 80%. If it were only 40%, would you say the problem is not worth fixing? So what's the point of time accuracy, when what you really want is to <strong>find the problems</strong>?
500 or 5000 samples would have measured the problem with greater precision, but would not have found it any more accurately.</p></li>
<li><p><em>that counting of statement or function invocations is useful.</em><br>
Suppose you know a function has been called 1000 times. Can you tell from that what fraction of time it costs? You also need to know how long it takes to run, on average, multiply it by the count, and divide by the total time. The average invocation time could vary from nanoseconds to seconds, so the count alone doesn't tell much. If there are stack samples, the cost of a routine or of any statement is just the fraction of samples it is on. That fraction of time is what could in principle be saved overall if the routine or statement could be made to take no time, so that is what has the most direct relationship to performance.</p></li>
<li><p><em>that samples need not be taken when blocked</em><br>
The reasons for this myth are twofold: 1) that PC sampling is meaningless when the program is waiting, and 2) the preoccupation with accuracy of timing. However, for (1) the program may very well be waiting for something that it asked for, such as file I/O, which you <em>need to know</em>, and which stack samples reveal. (Obviously you want to exclude samples while waiting for user input.) For (2) if the program is waiting simply because of competition with other processes, that presumably happens in a fairly random way while it's running.
So while the program may be taking longer, that will not have a large effect on the statistic that matters, the percentage of time that statements are on the stack.</p></li>
<li><p><em>that "self time" matters</em><br>
Self time only makes sense if you are measuring at the function level, not line level, and you think you need help in discerning if the function time goes into purely local computation versus in called routines. If summarizing at the line level, a line represents self time if it is at the end of the stack, otherwise it represents inclusive time. Either way, what it costs is the percentage of stack samples it is on, so that locates it for you in either case.</p></li>
<li><p><em>that samples have to be taken at high frequency</em><br>
This comes from the idea that a performance problem may be fast-acting, and that samples have to be frequent in order to hit it. But, if the problem is costing, 20%, say, out of a total running time of 10 sec (or whatever), then each sample in that total time will have a 20% chance of hitting it, no matter if the problem occurs in a single piece like this<br>
<code>.....XXXXXXXX...........................</code><br>
<code>.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^</code> (20 samples, 4 hits)<br>
or in many small pieces like this<br>
<code>X...X...X.X..X.........X.....X....X.....</code><br>
<code>.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^</code> (20 samples, 3 hits)<br>
Either way, the number of hits will average about 1 in 5, no matter how many samples are taken, or how few. (Average = 20 * 0.2 = 4. Standard deviation = +/- sqrt(20 * 0.2 * 0.8) = 1.8.)</p></li>
<li><p><em>that you are trying to find <strong>the</strong> bottleneck</em><br>
as if there were only one. Consider the following execution timeline: <code>vxvWvzvWvxvWvYvWvxvWv.vWvxvWvYvW</code><br>
It consists of real useful work, represented by <code>.</code>. There are performance problems <code>vWxYz</code> taking 1/2, 1/4, 1/8, 1/16, 1/32 of the time, respectively. Sampling finds <code>v</code> easily. It is removed, leaving<br>
<code>xWzWxWYWxW.WxWYW</code><br>
Now the program takes half as long to run, and now <code>W</code> takes half the time, and is found easily. It is removed, leaving<br>
<code>xzxYx.xY</code><br>
This process continues, each time removing the biggest, by percentage, performance problem, until nothing to remove can be found. Now the only thing executed is <code>.</code>, which executes in 1/32 of the time used by the original program. This is the <em>magnification effect</em>, by which removing any problem makes the remainder larger, by percent, because the denominator is reduced.<br>
Another crucial point is that <em>every single problem must be found</em> - missing none of the 5. Any problem not found and fixed severely reduces the final speedup ratio. Just finding some, but not all, is not "good enough".</p></li>
</ol>

<p>ADDED: I would just like to point out one reason why <em>gprof</em> is popular - it is being taught,
presumably because it's free, easy to teach, and it's been around a long time.
A quick Google search locates some academic institutions that teach it (or appear to):</p>

<blockquote>
  <p>berkeley bu clemson
  colorado duke earlham fsu indiana mit msu
  ncsa.illinois ncsu nyu ou princeton psu
  stanford ucsd umd umich utah utexas utk wustl</p>
</blockquote>

<p>** With the exception of other ways of requesting work to be done, that don't leave a trace telling <em>why</em>, such as by message posting.</p>
    </div></div><div><div class="flex items-center justify-between text-slate-500"><div class="flex space-x-4 md:space-x-8"><div class="flex cursor-pointer items-center transition hover:text-slate-600"><svg xmlns="http://www.w3.org/2000/svg" class="mr-1.5 h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M14 10h4.764a2 2 0 011.789 2.894l-3.5 7A2 2 0 0115.263 21h-4.017c-.163 0-.326-.02-.485-.06L7 20m7-10V5a2 2 0 00-2-2h-.095c-.5 0-.905.405-.905.905 0 .714-.211 1.412-.608 2.006L7 11v9m7-10h-2M7 20H5a2 2 0 01-2-2v-6a2 2 0 012-2h2.5"></path></svg><span>4</span></div></div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"count":1,"rows":[{"answer":["\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;gprof\u0026lt;/strong\u0026gt; \u0026lt;a href=\u0026quot;http://docs.freebsd.org/44doc/psd/18.gprof/paper.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;(read the paper)\u0026lt;/a\u0026gt; exists for historical reasons. \nIf you think it will help you find performance problems, it was never advertised as such.\nHere\u0026apos;s what the paper says:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The prole can be used to compare and assess the costs of\n  various implementations.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;It does not say it can be used to \u0026lt;em\u0026gt;identify\u0026lt;/em\u0026gt; the various implementations to be assessed, although it does \u0026lt;em\u0026gt;imply\u0026lt;/em\u0026gt; that it could, under special circumstances:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;especially if small portions of the program are found to dominate its\n  execution time.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;What about problems that are not so localized?\nDo those not matter?\nDon\u0026apos;t place expectations on \u0026lt;strong\u0026gt;gprof\u0026lt;/strong\u0026gt; that were never claimed for it.\nIt is \u0026lt;em\u0026gt;only\u0026lt;/em\u0026gt; a measurement tool, and only of CPU-bound operations.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/375913/what-can-i-use-to-profile-c-code-in-linux/378024#378024\u0026quot;\u0026gt;Try this instead.\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt;\n\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/926266/performance-optimization-strategies-of-last-resort/927773#927773\u0026quot;\u0026gt;Here\u0026apos;s an example of a 44x speedup.\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt;\n\u0026lt;a href=\u0026quot;https://scicomp.stackexchange.com/a/1870/1262\u0026quot;\u0026gt;Here\u0026apos;s a 730x speedup.\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt;\n\u0026lt;a href=\u0026quot;http://youtu.be/xPg3sRpdW1U\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Here\u0026apos;s an 8-minute video demonstration.\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt;\n\u0026lt;a href=\u0026quot;https://scicomp.stackexchange.com/a/2719/1262\u0026quot;\u0026gt;Here\u0026apos;s an explanation of the statistics.\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt;\n\u0026lt;a href=\u0026quot;https://stackoverflow.com/a/18217639/23771\u0026quot;\u0026gt;Here\u0026apos;s an answer to critiques.\u0026lt;/a\u0026gt;  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There\u0026apos;s a simple observation about programs. In a given execution, every instruction is responsible for some fraction of the overall time (especially \u0026lt;code\u0026gt;call\u0026lt;/code\u0026gt; instructions), in the sense that if it were not there, the time would not be spent. During that time, the instruction is on the stack **. When that is understood, you can see that -  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;gprof\u0026lt;/strong\u0026gt; embodies certain myths about performance, such as:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;that program counter sampling is useful.\u0026lt;/em\u0026gt;\u0026lt;br\u0026gt;\nIt is only useful if you have an unnecessary hotspot bottleneck such as a bubble sort of a big array of scalar values. As soon as you, for example, change it into a sort using string-compare, it is still a bottleneck, but program counter sampling will not see it because now the hotspot is in string-compare. On the other hand if it were to sample the \u0026lt;strong\u0026gt;extended\u0026lt;/strong\u0026gt; program counter (the call stack), the point at which the string-compare is called, the sort loop, is clearly displayed. \u0026lt;em\u0026gt;In fact, \u0026lt;strong\u0026gt;gprof\u0026lt;/strong\u0026gt; was an attempt to remedy the limitations of pc-only sampling.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;that timing functions is more important than capturing time-consuming lines of code.\u0026lt;/em\u0026gt;\u0026lt;br\u0026gt;\nThe reason for that myth is that \u0026lt;strong\u0026gt;gprof\u0026lt;/strong\u0026gt; was not able to capture stack samples, so instead it times functions, counts their invocations, and tries to capture the call graph. However, once a costly function is identified, you still need to look inside it for the lines that are responsible for the time. If there were stack samples you would not need to look, those lines would be on the samples. (A typical function might have 100 - 1000 instructions. A function \u0026lt;em\u0026gt;call\u0026lt;/em\u0026gt; is 1 instruction, so something that locates costly calls is 2-3 orders of magnitude more precise.)\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;that the call graph is important.\u0026lt;/em\u0026gt;\u0026lt;br\u0026gt;\nWhat you need to know about a program is not \u0026lt;strong\u0026gt;where\u0026lt;/strong\u0026gt; it spends its time, but \u0026lt;strong\u0026gt;why\u0026lt;/strong\u0026gt;. When it is spending time in a function, every line of code on the stack gives one link in the chain of reasoning of why it is there. If you can only see part of the stack, you can only see part of the reason why, so you can\u0026apos;t tell for sure if that time is actually necessary.\nWhat does the call graph tell you? Each arc tells you that some function A was in the process of calling some function B for some fraction of the time. Even if A has only one such line of code calling B, that line only gives a small part of the reason why. If you are lucky enough, maybe that line has a poor reason. Usually, you need to see multiple simultaneous lines to find a poor reason if it is there. If A calls B in more than one place, then it tells you even less.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;that recursion is a tricky confusing issue.\u0026lt;/em\u0026gt;\u0026lt;br\u0026gt;\nThat is only because \u0026lt;strong\u0026gt;gprof\u0026lt;/strong\u0026gt; and other profilers perceive a need to generate a call-graph and then attribute times to the nodes. If one has samples of the stack, the time-cost of each line of code that appears on samples is a very simple number - the fraction of samples it is on. If there is recursion, then a given line can appear more than once on a sample. \n\u0026lt;em\u0026gt;No matter.\u0026lt;/em\u0026gt; Suppose samples are taken every N ms, and the line appears on F% of them (singly or not). If that line can be made to take no time (such as by deleting it or branching around it), then those samples would \u0026lt;em\u0026gt;disappear\u0026lt;/em\u0026gt;, and the time would be reduced by F%.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;that accuracy of time measurement (and therefore a large number of samples) is important.\u0026lt;/em\u0026gt;\u0026lt;br\u0026gt;\nThink about it for a second. If a line of code is on 3 samples out of five, then if you could shoot it out like a light bulb, that is roughly 60% less time that would be used. Now, you know that if you had taken a different 5 samples, you might have only seen it 2 times, or as many as 4. So that 60% measurement is more like a general range from 40% to 80%. If it were only 40%, would you say the problem is not worth fixing? So what\u0026apos;s the point of time accuracy, when what you really want is to \u0026lt;strong\u0026gt;find the problems\u0026lt;/strong\u0026gt;?\n500 or 5000 samples would have measured the problem with greater precision, but would not have found it any more accurately.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;that counting of statement or function invocations is useful.\u0026lt;/em\u0026gt;\u0026lt;br\u0026gt;\nSuppose you know a function has been called 1000 times. Can you tell from that what fraction of time it costs? You also need to know how long it takes to run, on average, multiply it by the count, and divide by the total time. The average invocation time could vary from nanoseconds to seconds, so the count alone doesn\u0026apos;t tell much. If there are stack samples, the cost of a routine or of any statement is just the fraction of samples it is on. That fraction of time is what could in principle be saved overall if the routine or statement could be made to take no time, so that is what has the most direct relationship to performance.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;that samples need not be taken when blocked\u0026lt;/em\u0026gt;\u0026lt;br\u0026gt;\nThe reasons for this myth are twofold: 1) that PC sampling is meaningless when the program is waiting, and 2) the preoccupation with accuracy of timing. However, for (1) the program may very well be waiting for something that it asked for, such as file I/O, which you \u0026lt;em\u0026gt;need to know\u0026lt;/em\u0026gt;, and which stack samples reveal. (Obviously you want to exclude samples while waiting for user input.) For (2) if the program is waiting simply because of competition with other processes, that presumably happens in a fairly random way while it\u0026apos;s running.\nSo while the program may be taking longer, that will not have a large effect on the statistic that matters, the percentage of time that statements are on the stack.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;that \u0026quot;self time\u0026quot; matters\u0026lt;/em\u0026gt;\u0026lt;br\u0026gt;\nSelf time only makes sense if you are measuring at the function level, not line level, and you think you need help in discerning if the function time goes into purely local computation versus in called routines. If summarizing at the line level, a line represents self time if it is at the end of the stack, otherwise it represents inclusive time. Either way, what it costs is the percentage of stack samples it is on, so that locates it for you in either case.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;that samples have to be taken at high frequency\u0026lt;/em\u0026gt;\u0026lt;br\u0026gt;\nThis comes from the idea that a performance problem may be fast-acting, and that samples have to be frequent in order to hit it. But, if the problem is costing, 20%, say, out of a total running time of 10 sec (or whatever), then each sample in that total time will have a 20% chance of hitting it, no matter if the problem occurs in a single piece like this\u0026lt;br\u0026gt;\n\u0026lt;code\u0026gt;.....XXXXXXXX...........................\u0026lt;/code\u0026gt;\u0026lt;br\u0026gt;\n\u0026lt;code\u0026gt;.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\u0026lt;/code\u0026gt; (20 samples, 4 hits)\u0026lt;br\u0026gt;\nor in many small pieces like this\u0026lt;br\u0026gt;\n\u0026lt;code\u0026gt;X...X...X.X..X.........X.....X....X.....\u0026lt;/code\u0026gt;\u0026lt;br\u0026gt;\n\u0026lt;code\u0026gt;.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^\u0026lt;/code\u0026gt; (20 samples, 3 hits)\u0026lt;br\u0026gt;\nEither way, the number of hits will average about 1 in 5, no matter how many samples are taken, or how few. (Average = 20 * 0.2 = 4. Standard deviation = +/- sqrt(20 * 0.2 * 0.8) = 1.8.)\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;that you are trying to find \u0026lt;strong\u0026gt;the\u0026lt;/strong\u0026gt; bottleneck\u0026lt;/em\u0026gt;\u0026lt;br\u0026gt;\nas if there were only one. Consider the following execution timeline: \u0026lt;code\u0026gt;vxvWvzvWvxvWvYvWvxvWv.vWvxvWvYvW\u0026lt;/code\u0026gt;\u0026lt;br\u0026gt;\nIt consists of real useful work, represented by \u0026lt;code\u0026gt;.\u0026lt;/code\u0026gt;. There are performance problems \u0026lt;code\u0026gt;vWxYz\u0026lt;/code\u0026gt; taking 1/2, 1/4, 1/8, 1/16, 1/32 of the time, respectively. Sampling finds \u0026lt;code\u0026gt;v\u0026lt;/code\u0026gt; easily. It is removed, leaving\u0026lt;br\u0026gt;\n\u0026lt;code\u0026gt;xWzWxWYWxW.WxWYW\u0026lt;/code\u0026gt;\u0026lt;br\u0026gt;\nNow the program takes half as long to run, and now \u0026lt;code\u0026gt;W\u0026lt;/code\u0026gt; takes half the time, and is found easily. It is removed, leaving\u0026lt;br\u0026gt;\n\u0026lt;code\u0026gt;xzxYx.xY\u0026lt;/code\u0026gt;\u0026lt;br\u0026gt;\nThis process continues, each time removing the biggest, by percentage, performance problem, until nothing to remove can be found. Now the only thing executed is \u0026lt;code\u0026gt;.\u0026lt;/code\u0026gt;, which executes in 1/32 of the time used by the original program. This is the \u0026lt;em\u0026gt;magnification effect\u0026lt;/em\u0026gt;, by which removing any problem makes the remainder larger, by percent, because the denominator is reduced.\u0026lt;br\u0026gt;\nAnother crucial point is that \u0026lt;em\u0026gt;every single problem must be found\u0026lt;/em\u0026gt; - missing none of the 5. Any problem not found and fixed severely reduces the final speedup ratio. Just finding some, but not all, is not \u0026quot;good enough\u0026quot;.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;ADDED: I would just like to point out one reason why \u0026lt;em\u0026gt;gprof\u0026lt;/em\u0026gt; is popular - it is being taught,\npresumably because it\u0026apos;s free, easy to teach, and it\u0026apos;s been around a long time.\nA quick Google search locates some academic institutions that teach it (or appear to):\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;berkeley bu clemson\n  colorado duke earlham fsu indiana mit msu\n  ncsa.illinois ncsu nyu ou princeton psu\n  stanford ucsd umd umich utah utexas utk wustl\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;** With the exception of other ways of requesting work to be done, that don\u0026apos;t leave a trace telling \u0026lt;em\u0026gt;why\u0026lt;/em\u0026gt;, such as by message posting.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Valgrind\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Valgrind\u0026lt;/a\u0026gt; has an instruction-count profiler with a very nice visualizer called \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Valgrind#Tools\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;KCacheGrind\u0026lt;/a\u0026gt;.  As Mike Dunlavey recommends, Valgrind counts the fraction of instructions for which a procedure is live on the stack, although I\u0026apos;m sorry to say it appears to become confused in the presence of mutual recursion.  But the visualizer is very nice and light years ahead of \u0026lt;code\u0026gt;gprof\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Since I did\u0026apos;t see here anything about \u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;perf\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt; which is a relatively new tool for profiling the kernel and user applications on Linux I decided to add this information.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;First of all - this is a tutorial about \u0026lt;a href=\u0026quot;https://perf.wiki.kernel.org/index.php/Tutorial\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Linux profiling with \u0026lt;code\u0026gt;perf\u0026lt;/code\u0026gt; \u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can use \u0026lt;code\u0026gt;perf\u0026lt;/code\u0026gt; if your Linux Kernel is greater than 2.6.32 or \u0026lt;code\u0026gt;oprofile\u0026lt;/code\u0026gt; if it is older. Both programs don\u0026apos;t require from you to instrument your program (like \u0026lt;code\u0026gt;gprof\u0026lt;/code\u0026gt; requires). However in order to get call graph correctly in \u0026lt;code\u0026gt;perf\u0026lt;/code\u0026gt; you need to build you program with \u0026lt;code\u0026gt;-fno-omit-frame-pointer\u0026lt;/code\u0026gt;. For example: \u0026lt;code\u0026gt;g++ -fno-omit-frame-pointer -O2 main.cpp\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can see \u0026quot;live\u0026quot; analysis of your application with \u0026lt;code\u0026gt;perf top\u0026lt;/code\u0026gt;: \u0026lt;br\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;sudo perf top -p `pidof a.out` -K\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Or you can record performance data of a running application and analyze them after that:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;1) To record performance data:\u0026lt;br\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;perf record -p `pidof a.out`\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;or  to record for 10 secs:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;perf record -p `pidof a.out` sleep 10\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;or to record with call graph ()\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;perf record -g -p `pidof a.out` \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;2) To analyze the recorded data\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;perf report --stdio\nperf report --stdio --sort=dso -g none\nperf report --stdio -g none\nperf report --stdio -g\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Or you can record performace data of a application and analyze them after that just by launching the application in this way and waiting for it to exit:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;perf record ./a.out\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;This is an example of profiling a test program\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The test program is in file main.cpp (I will put main.cpp at the bottom of the message):\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I compile it in this way:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;g++ -m64 -fno-omit-frame-pointer -g main.cpp -L.  -ltcmalloc_minimal -o my_test\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I use \u0026lt;code\u0026gt;libmalloc_minimial.so\u0026lt;/code\u0026gt; since it is compiled with \u0026lt;code\u0026gt;-fno-omit-frame-pointer\u0026lt;/code\u0026gt; while libc malloc seems to be compiled without this option.\nThen I run my test program\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;./my_test 100000000 \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Then I record performance data of a running process:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;perf record -g  -p `pidof my_test` -o ./my_test.perf.data sleep 30\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Then I analyze load per module:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;perf report --stdio  -g none --sort comm,dso  -i ./my_test.perf.data\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;# Overhead  Command                 Shared Object\n# ........  .......  ............................\n#\n    70.06%  my_test  my_test\n    28.33%  my_test  libtcmalloc_minimal.so.0.1.0\n     1.61%  my_test  [kernel.kallsyms]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Then load per function is analyzed:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;perf report --stdio  -g none  -i ./my_test.perf.data | c++filt\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;# Overhead  Command                 Shared Object                       Symbol\n# ........  .......  ............................  ...........................\n#\n    29.30%  my_test  my_test                       [.] f2(long)\n    29.14%  my_test  my_test                       [.] f1(long)\n    15.17%  my_test  libtcmalloc_minimal.so.0.1.0  [.] operator new(unsigned long)\n    13.16%  my_test  libtcmalloc_minimal.so.0.1.0  [.] operator delete(void*)\n     9.44%  my_test  my_test                       [.] process_request(long)\n     1.01%  my_test  my_test                       [.] operator delete(void*)@plt\n     0.97%  my_test  my_test                       [.] operator new(unsigned long)@plt\n     0.20%  my_test  my_test                       [.] main\n     0.19%  my_test  [kernel.kallsyms]             [k] apic_timer_interrupt\n     0.16%  my_test  [kernel.kallsyms]             [k] _spin_lock\n     0.13%  my_test  [kernel.kallsyms]             [k] native_write_msr_safe\n\n     and so on ...\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Then call chains are analyzed:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;perf report --stdio  -g graph  -i ./my_test.perf.data | c++filt\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;# Overhead  Command                 Shared Object                       Symbol\n# ........  .......  ............................  ...........................\n#\n    29.30%  my_test  my_test                       [.] f2(long)\n            |\n            --- f2(long)\n               |\n                --29.01%-- process_request(long)\n                          main\n                          __libc_start_main\n\n    29.14%  my_test  my_test                       [.] f1(long)\n            |\n            --- f1(long)\n               |\n               |--15.05%-- process_request(long)\n               |          main\n               |          __libc_start_main\n               |\n                --13.79%-- f2(long)\n                          process_request(long)\n                          main\n                          __libc_start_main\n\n    15.17%  my_test  libtcmalloc_minimal.so.0.1.0  [.] operator new(unsigned long)\n            |\n            --- operator new(unsigned long)\n               |\n               |--11.44%-- f1(long)\n               |          |\n               |          |--5.75%-- process_request(long)\n               |          |          main\n               |          |          __libc_start_main\n               |          |\n               |           --5.69%-- f2(long)\n               |                     process_request(long)\n               |                     main\n               |                     __libc_start_main\n               |\n                --3.01%-- process_request(long)\n                          main\n                          __libc_start_main\n\n    13.16%  my_test  libtcmalloc_minimal.so.0.1.0  [.] operator delete(void*)\n            |\n            --- operator delete(void*)\n               |\n               |--9.13%-- f1(long)\n               |          |\n               |          |--4.63%-- f2(long)\n               |          |          process_request(long)\n               |          |          main\n               |          |          __libc_start_main\n               |          |\n               |           --4.51%-- process_request(long)\n               |                     main\n               |                     __libc_start_main\n               |\n               |--3.05%-- process_request(long)\n               |          main\n               |          __libc_start_main\n               |\n                --0.80%-- f2(long)\n                          process_request(long)\n                          main\n                          __libc_start_main\n\n     9.44%  my_test  my_test                       [.] process_request(long)\n            |\n            --- process_request(long)\n               |\n                --9.39%-- main\n                          __libc_start_main\n\n     1.01%  my_test  my_test                       [.] operator delete(void*)@plt\n            |\n            --- operator delete(void*)@plt\n\n     0.97%  my_test  my_test                       [.] operator new(unsigned long)@plt\n            |\n            --- operator new(unsigned long)@plt\n\n     0.20%  my_test  my_test                       [.] main\n     0.19%  my_test  [kernel.kallsyms]             [k] apic_timer_interrupt\n     0.16%  my_test  [kernel.kallsyms]             [k] _spin_lock\n     and so on ...\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So at this point you know where your program spends time.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;And this is main.cpp for the test:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;#include \u0026amp;lt;stdio.h\u0026amp;gt;\n#include \u0026amp;lt;stdlib.h\u0026amp;gt;\n#include \u0026amp;lt;time.h\u0026amp;gt;\n\ntime_t f1(time_t time_value)\n{\n  for (int j =0; j \u0026amp;lt; 10; ++j) {\n    ++time_value;\n    if (j%5 == 0) {\n      double *p = new double;\n      delete p;\n    }\n  }\n  return time_value;\n}\n\ntime_t f2(time_t time_value)\n{\n  for (int j =0; j \u0026amp;lt; 40; ++j) {\n    ++time_value;\n  }\n  time_value=f1(time_value);\n  return time_value;\n}\n\ntime_t process_request(time_t time_value)\n{\n\n  for (int j =0; j \u0026amp;lt; 10; ++j) {\n    int *p = new int;\n    delete p;\n    for (int m =0; m \u0026amp;lt; 10; ++m) {\n      ++time_value;\n    }\n  }\n  for (int i =0; i \u0026amp;lt; 10; ++i) {\n    time_value=f1(time_value);\n    time_value=f2(time_value);\n  }\n  return time_value;\n}\n\nint main(int argc, char* argv2[])\n{\n  int number_loops = argc \u0026amp;gt; 1 ? atoi(argv2[1]) : 1;\n  time_t time_value = time(0);\n  printf(\u0026quot;number loops %d\\n\u0026quot;, number_loops);\n  printf(\u0026quot;time_value: %d\\n\u0026quot;, time_value );\n\n  for (int i =0; i \u0026amp;lt; number_loops; ++i) {\n    time_value = process_request(time_value);\n  }\n  printf(\u0026quot;time_value: %ld\\n\u0026quot;, time_value );\n  return 0;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Try \u0026lt;a href=\u0026quot;http://oprofile.sourceforge.net/about/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;OProfile\u0026lt;/a\u0026gt;. It is a much better tool for profiling your code. I would also suggest Intel \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/VTune\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;VTune\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The two tools above can narrow down time spent in a particular line of code, annotate your code, show assembly and how much particular instruction takes.  Beside time metric, you can also query specific counters, i.e. cache hits, etc.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Unlike gprof, you can profile any process/binary running on your system using either of the two.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://code.google.com/p/google-perftools/\u0026quot;\u0026gt;Google performance tools\u0026lt;/a\u0026gt; include a simple to use profiler. CPU as well as heap profiler is available.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Take a look at \u0026lt;a href=\u0026quot;http://sysprof.com/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Sysprof\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Your distribution may have it already.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://lttng.org/\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;http://lttng.org/\u0026lt;/a\u0026gt; if you want a high performance tracer\u0026lt;/p\u0026gt;\n    "],"comment":["\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;what platforms you are interested in?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/196561/osgx\u0026quot; title=\u0026quot;86,289 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;osgx\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment2507999_1777556\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-03-24 22:10:02Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 24, 2010 at 22:10\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I\u0026apos;m interested in Linux.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/209512/neuromancer\u0026quot; title=\u0026quot;50,979 reputation\u0026quot; class=\u0026quot;comment-user owner\u0026quot;\u0026gt;neuromancer\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment2672253_1777556\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-04-16 19:37:27Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 16, 2010 at 19:37\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;possible duplicate of \u0026lt;a href=\u0026quot;http://stackoverflow.com/questions/375913/what-can-i-use-to-profile-c-code-in-linux\u0026quot; title=\u0026quot;what can i use to profile c code in linux\u0026quot;\u0026gt;stackoverflow.com/questions/375913/\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/22437/dour-high-arch\u0026quot; title=\u0026quot;21,111 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Dour High Arch\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment2699252_1777556\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-04-21 00:59:55Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 21, 2010 at 0:59\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Gregory - I\u0026apos;m inclined to agree, and maybe he should contribute with answers of his own, 229 vs 6, all 6 of those answers being to his own questions...\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/103959/jean-bernard-pellerin\u0026quot; title=\u0026quot;12,391 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Jean-Bernard Pellerin\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment3907968_1777556\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-09-14 01:18:48Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 14, 2010 at 1:18\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;How can this question don\u0026apos;t be constructive?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/973795/johntortugo\u0026quot; title=\u0026quot;5,964 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;JohnTortugo\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment23492577_1777556\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-05-05 23:04:13Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 5, 2013 at 23:04\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Norman: I made a profiler based on this, in C for DOS, around \u0026apos;93. I called it yet-another-performance-analyzer, and demo\u0026apos;ed it around at IEEE meetings, but that\u0026apos;s as far as it went. There is a product from RotateRight called Zoom that\u0026apos;s not too far off. On *nix, \u0026lt;b\u0026gt;pstack\u0026lt;/b\u0026gt; is good for doing it manually. My to-do list for work (pharmacometrics on Windows) is about a mile long which precludes fun projects, not to mention family. This might be useful: \u0026lt;a href=\u0026quot;http://stackoverflow.com/questions/1777669/how-to-modify-a-c-program-so-that-gprof-can-profile-it/1931042#1931042\u0026quot; title=\u0026quot;how to modify a c program so that gprof can profile it\u0026quot;\u0026gt;stackoverflow.com/questions/1777669/\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/23771/mike-dunlavey\u0026quot; title=\u0026quot;39,406 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Mike Dunlavey\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment1841716_1779343\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-12-19 13:16:47Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 19, 2009 at 13:16\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I\u0026apos;ve always found profilers not so useful for fixing slow code, and instead used selective bits of debugging code to measure the time taken by a group of statements of my choosing, often aided by some trivial little macros or whatever.  It\u0026apos;s never taken me too long to find the culprit, but I\u0026apos;ve always been embarrassed of my \u0026quot;bear skins and stone knives\u0026quot; approach when \u0026quot;everyone else\u0026quot; (as far as I know) uses the fancy tools.  Thank you for showing me why I could never get the information I needed from profiler.  This is one of the most important ideas I\u0026apos;ve seen on SO.  Well done!\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/238886/wayne-conrad\u0026quot; title=\u0026quot;97,398 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Wayne Conrad\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment2198680_1779343\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-02-11 02:44:35Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 11, 2010 at 2:44\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@osgx: I don\u0026apos;t mean to rip anything. It\u0026apos;s like an old favorite automobile, simple \u0026amp;amp; rugged, but there are things it doesn\u0026apos;t do, and we need to be aware of those, and not only that, we need to wake up from the myths. I appreciate that on some platforms it may be difficult to get stack samples, but if a problem is such that gprof will not find it, the fact that it is the only tool is small comfort.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/23771/mike-dunlavey\u0026quot; title=\u0026quot;39,406 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Mike Dunlavey\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment2508678_1779343\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-03-25 00:30:37Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 25, 2010 at 0:30\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Andrew: ... \u0026lt;i\u0026gt;and\u0026lt;/i\u0026gt; if that reason applies to some significant fraction of samples (like more than 1), then the line(s) of code that could eliminate that activity are on those samples. A graph can give you a \u0026lt;i\u0026gt;hint\u0026lt;/i\u0026gt; of this, but a not-large number of stack samples will simply show them to you.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/23771/mike-dunlavey\u0026quot; title=\u0026quot;39,406 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Mike Dunlavey\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment3480484_1779343\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-07-28 12:12:53Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 28, 2010 at 12:12\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Matt: Examples of IO performance problems found this way: 1) printing log messages to a file or the console, which was erroneously thought to be insignificant. 2) Converting between text and doubles in numeric IO. 3) Subterranean IO extracting internationalized strings during startup, strings that it turns out did not need to be internationalized. I\u0026apos;ve hit lots of examples like these.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/23771/mike-dunlavey\u0026quot; title=\u0026quot;39,406 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Mike Dunlavey\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment3914866_1779343\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-09-14 16:38:34Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 14, 2010 at 16:38\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Norman: ++ That confusion about recursion seems endemic to systems that have the concept of propogating times among nodes in a graph. Also I think wall-clock time is generally more useful than CPU instruction times, and code lines (call instructions) are more useful than procedures. If stack samples at random wall clock times are taken, then the fractional cost of a line (or procedure, or any other description you can make) is simply estimated by the fraction of samples that exhibit it.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/23771/mike-dunlavey\u0026quot; title=\u0026quot;39,406 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Mike Dunlavey\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment1845070_1932053\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-12-20 13:50:40Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 20, 2009 at 13:50\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;... I\u0026apos;m emphasizing call instructions, but it applies to any instructions. If one has an honest-to-goodness hotspot bottleneck, such as a bubble sort of a large array of numbers, then the compare/jump/swap/increment instructions of the inner loop will be at the top/bottom of nearly every stack sample. But (especially as software gets big and hardly any routine has much \u0026quot;self\u0026quot; time) many problems actually are call instructions, requesting work that, when it is clear how much it costs, doesn\u0026apos;t \u0026lt;i\u0026gt;really\u0026lt;/i\u0026gt; have to be done.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/23771/mike-dunlavey\u0026quot; title=\u0026quot;39,406 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Mike Dunlavey\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment1845111_1932053\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-12-20 14:07:09Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 20, 2009 at 14:07\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;... Check this out. I think they are nearly on the right track: \u0026lt;a href=\u0026quot;http://www.rotateright.com/zoom.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;rotateright.com/zoom.html\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/23771/mike-dunlavey\u0026quot; title=\u0026quot;39,406 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Mike Dunlavey\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment1845129_1932053\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-12-20 14:18:42Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 20, 2009 at 14:18\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I just ran your example \u0026amp;amp; took 5 stackshots. Here\u0026apos;s what they found: 40% (roughly) of the time \u0026lt;code\u0026gt;f1\u0026lt;/code\u0026gt; was calling \u0026lt;code\u0026gt;delete\u0026lt;/code\u0026gt;. 40% (roughly) of the time \u0026lt;code\u0026gt;process_request\u0026lt;/code\u0026gt; was calling \u0026lt;code\u0026gt;delete\u0026lt;/code\u0026gt;. A good part of the remainder was spent in \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt;. The measurements are rough, but the hotspots are pinpointed.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/23771/mike-dunlavey\u0026quot; title=\u0026quot;39,406 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Mike Dunlavey\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment19950088_10958510\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-01-16 01:55:40Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 16, 2013 at 1:55\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;What is a \u0026lt;code\u0026gt;stackshot\u0026lt;/code\u0026gt;? Is it that \u0026lt;code\u0026gt;pstack\u0026lt;/code\u0026gt; outputs?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;span class=\u0026quot;comment-user\u0026quot;\u0026gt;user184968\u0026lt;/span\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment19966886_10958510\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-01-16 14:36:10Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 16, 2013 at 14:36\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026lt;code\u0026gt;As in my answer, you run it under a debugger and hit ^C at a random time and capture the stack trace\u0026lt;/code\u0026gt;. 1) I think that your technique is  not useful when you need to analyze performance problems for a program running on your customer\u0026apos;s server. 2) I am not sure how you apply this technique to get information for a program having lots of threads that handle different requests. I mean when the general picture is quite complicated.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;span class=\u0026quot;comment-user\u0026quot;\u0026gt;user184968\u0026lt;/span\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment23330890_10958510\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-04-30 10:46:41Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 30, 2013 at 10:46\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;As for #1. Sometimes customers call and say that your program works slowly. You can\u0026apos;t say immediately that \u0026lt;code\u0026gt;the problem is outside your code\u0026lt;/code\u0026gt;, can you? Since you might need some information in order to support your point. In this situation you at some point might need to profile your application. You can\u0026apos;t just ask your customer to start gdb and press ^C and get call stacks. This was my point. This is an example \u0026lt;a href=\u0026quot;http://spielwiese.fontein.de/2012/01/22/a-problem-with-pthread_once-on-an-out-dated-solaris-installation\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;spielwiese.fontein.de/2012/01/22/\u0026lt;/a\u0026gt;. I had this problem and profiling helped a lot.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;span class=\u0026quot;comment-user\u0026quot;\u0026gt;user184968\u0026lt;/span\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment23338905_10958510\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-04-30 14:31:08Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 30, 2013 at 14:31\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;As for #2. Simplifying is a good approach, I agree. Sometimes it works. If a performance problem occur only on a customer\u0026apos;s server and you can\u0026apos;t reproduce them on your server then profiles are of use.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;span class=\u0026quot;comment-user\u0026quot;\u0026gt;user184968\u0026lt;/span\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment23342153_10958510\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-04-30 15:59:36Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 30, 2013 at 15:59\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;As also mentioned in the valgrind answer, Zoom from RotateRight ( \u0026lt;a href=\u0026quot;http://www.rotateright.com\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;rotateright.com\u0026lt;/a\u0026gt; ) provides a much nicer interface and allows remote profiling.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/250106/janephanie\u0026quot; title=\u0026quot;579 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;JanePhanie\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment2194138_1777585\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-02-10 15:32:41Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 10, 2010 at 15:32\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;didn\u0026apos;t like oprofile, it seemed haphazard\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/149482/matt-joiner\u0026quot; title=\u0026quot;107,240 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Matt Joiner\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment3911680_1777585\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-09-14 11:55:43Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 14, 2010 at 11:55\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Matt  any particular point?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/206328/anycorn\u0026quot; title=\u0026quot;48,791 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Anycorn\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment3918466_1777585\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-09-14 23:42:24Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 14, 2010 at 23:42\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;It wasn\u0026apos;t able to cope with more than 10s of execution before generating stat overflows, the output wasn\u0026apos;t particularly useful, and the documentation is dreadful.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/149482/matt-joiner\u0026quot; title=\u0026quot;107,240 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Matt Joiner\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment3919283_1777585\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-09-15 02:33:38Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 15, 2010 at 2:33\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Tho OProfile:  ARM, POWER, ia64, ...\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/206328/anycorn\u0026quot; title=\u0026quot;48,791 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Anycorn\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment5164291_1777585\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-01-13 18:03:38Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 13, 2011 at 18:03\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;They are now at \u0026lt;a href=\u0026quot;https://github.com/gperftools/gperftools\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;github.com/gperftools/gperftools\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/204658/thoni56\u0026quot; title=\u0026quot;2,894 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;thoni56\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment112345650_6164311\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2020-08-22 05:59:25Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 22, 2020 at 5:59\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;sysprof generated pretty useless output, and difficult to read\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/149482/matt-joiner\u0026quot; title=\u0026quot;107,240 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Matt Joiner\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment3911691_3503906\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-09-14 11:56:51Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 14, 2010 at 11:56\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        "],"id":534,"title":"Alternatives to gprof [closed]","content":"\n                    \u0026lt;div\u0026gt;\n            \u0026lt;aside class=\u0026quot;s-notice s-notice__info post-notice js-post-notice mb16\u0026quot; role=\u0026quot;status\u0026quot;\u0026gt;\n        \u0026lt;div class=\u0026quot;d-flex fd-column fw-nowrap\u0026quot;\u0026gt;\n            \u0026lt;div class=\u0026quot;d-flex fw-nowrap\u0026quot;\u0026gt;\n                    \u0026lt;div class=\u0026quot;flex--item mr8\u0026quot;\u0026gt;\n                        \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;svg-icon iconLightbulb\u0026quot; width=\u0026quot;18\u0026quot; height=\u0026quot;18\u0026quot; viewBox=\u0026quot;0 0 18 18\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;M15 6.38A6.48 6.48 0 0 0 7.78.04h-.02A6.49 6.49 0 0 0 2.05 5.6a6.31 6.31 0 0 0 2.39 5.75c.49.39.76.93.76 1.5v.24c0 1.07.89 1.9 1.92 1.9h2.75c1.04 0 1.92-.83 1.92-1.9v-.2c0-.6.26-1.15.7-1.48A6.32 6.32 0 0 0 15 6.37ZM4.03 5.85A4.49 4.49 0 0 1 8 2.02a4.48 4.48 0 0 1 5 4.36 4.3 4.3 0 0 1-1.72 3.44c-.98.74-1.5 1.9-1.5 3.08v.1H7.2v-.14c0-1.23-.6-2.34-1.53-3.07a4.32 4.32 0 0 1-1.64-3.94ZM10 18a1 1 0 0 0 0-2H7a1 1 0 1 0 0 2h3Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                    \u0026lt;/div\u0026gt;\n                \u0026lt;div class=\u0026quot;flex--item wmn0 fl1 lh-lg\u0026quot;\u0026gt;\n                    \u0026lt;div class=\u0026quot;flex--item fl1 lh-lg\u0026quot;\u0026gt;\n                        As it currently stands, this question is not a good fit for our Q\u0026amp;amp;A format. We expect answers to be supported by facts, references,  or expertise, but this question will likely solicit debate, arguments, polling, or extended discussion. If you feel that this question  can be improved and possibly reopened, \u0026lt;a href=\u0026quot;/help/reopen-questions\u0026quot;\u0026gt;visit the help center\u0026lt;/a\u0026gt; for guidance.\n                        \n                    \u0026lt;/div\u0026gt;\n                \u0026lt;/div\u0026gt;\n            \u0026lt;/div\u0026gt;\n                \u0026lt;div class=\u0026quot;flex--item mb0 mt8\u0026quot;\u0026gt;Closed \u0026lt;span title=\u0026quot;2013-01-05 06:46:45Z\u0026quot; class=\u0026quot;relativetime\u0026quot;\u0026gt;9 years ago\u0026lt;/span\u0026gt;.\u0026lt;/div\u0026gt;\n        \u0026lt;/div\u0026gt;\n\u0026lt;/aside\u0026gt;\n\n    \u0026lt;/div\u0026gt;\n\n\u0026lt;p\u0026gt;What other programs do the same thing as gprof?\u0026lt;/p\u0026gt;\n    ","slug":"alternatives-to-gprof-closed-1657388336554","postType":"QUESTION","createdAt":"2022-07-09T17:38:56.000Z","updatedAt":"2022-07-09T17:38:56.000Z","tags":[{"id":2619,"name":"profiler","slug":"profiler","createdAt":"2022-07-09T17:38:56.000Z","updatedAt":"2022-07-09T17:38:56.000Z","Questions_Tags":{"questionId":534,"tagId":2619}}]}]}},"__N_SSG":true},"page":"/questions/tag/[slug]","query":{"slug":"profiler"},"buildId":"4Y8KGE-c2lolBeBmcum_I","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>