{"pageProps":{"data":{"count":1,"rows":[{"answer":["\n&lt;p&gt;Because &lt;code&gt;iostream::eof&lt;/code&gt; will only return &lt;code&gt;true&lt;/code&gt; &lt;em&gt;after&lt;/em&gt; reading the end of the stream. It does &lt;em&gt;not&lt;/em&gt; indicate, that the next read will be the end of the stream.&lt;/p&gt;\n\n&lt;p&gt;Consider this (and assume then next read will be at the end of the stream):&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(!inStream.&lt;span class=&quot;hljs-built_in&quot;&gt;eof&lt;/span&gt;()){\n  &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; data;\n  &lt;span class=&quot;hljs-comment&quot;&gt;// yay, not end of stream yet, now read ...&lt;/span&gt;\n  inStream &amp;gt;&amp;gt; data;\n  &lt;span class=&quot;hljs-comment&quot;&gt;// oh crap, now we read the end and *only* now the eof bit will be set (as well as the fail bit)&lt;/span&gt;\n  &lt;span class=&quot;hljs-comment&quot;&gt;// do stuff with (now uninitialized) data&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Against this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; data;\n&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(inStream &amp;gt;&amp;gt; data){\n  &lt;span class=&quot;hljs-comment&quot;&gt;// when we land here, we can be sure that the read was successful.&lt;/span&gt;\n  &lt;span class=&quot;hljs-comment&quot;&gt;// if it wasn&apos;t, the returned stream from operator&amp;gt;&amp;gt; would be converted to false&lt;/span&gt;\n  &lt;span class=&quot;hljs-comment&quot;&gt;// and the loop wouldn&apos;t even be entered&lt;/span&gt;\n  &lt;span class=&quot;hljs-comment&quot;&gt;// do stuff with correctly initialized data (hopefully)&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And on your second question: Because&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;...&quot;&lt;/span&gt;,...)!=EOF)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;is the same as&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(!(inStream &amp;gt;&amp;gt; data).&lt;span class=&quot;hljs-built_in&quot;&gt;eof&lt;/span&gt;())\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and &lt;strong&gt;not&lt;/strong&gt; the same as&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(!inStream.&lt;span class=&quot;hljs-built_in&quot;&gt;eof&lt;/span&gt;())\n    inFile &amp;gt;&amp;gt; data\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Bottom-line top:&lt;/strong&gt;  With proper handling of white-space, the following is how &lt;code&gt;eof&lt;/code&gt; can be used (and even, be more reliable than &lt;code&gt;fail()&lt;/code&gt; for error checking):&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;( !(in&amp;gt;&amp;gt;std::ws).&lt;span class=&quot;hljs-built_in&quot;&gt;eof&lt;/span&gt;() ) {  \n   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; data;\n   in &amp;gt;&amp;gt; data;\n   &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ( in.&lt;span class=&quot;hljs-built_in&quot;&gt;fail&lt;/span&gt;() ) &lt;span class=&quot;hljs-comment&quot;&gt;/* handle with break or throw */&lt;/span&gt;; \n   &lt;span class=&quot;hljs-comment&quot;&gt;// now use data&lt;/span&gt;\n}    \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;(&lt;em&gt;Thanks Tony D for the suggestion to highlight the answer. See his comment below for an example to why this is more robust.&lt;/em&gt;)&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;The main argument against using &lt;code&gt;eof()&lt;/code&gt; seems to be missing an important subtlety about the role of white space. My proposition is that, checking &lt;code&gt;eof()&lt;/code&gt; explicitly is not only not &quot;&lt;em&gt;always wrong&lt;/em&gt;&quot; -- which seems to be an overriding opinion in this and similar SO threads --, but with proper handling of white-space, it provides for a cleaner and more reliable error handling, and is the &lt;em&gt;always correct&lt;/em&gt; solution (although, not necessarily the tersest).&lt;/p&gt;\n\n&lt;p&gt;To summarize what is being suggested as the &quot;proper&quot; termination and read order is the following:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; data;\n&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(in &amp;gt;&amp;gt; data) {  &lt;span class=&quot;hljs-comment&quot;&gt;/* ... */&lt;/span&gt; }\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// which is equivalent to &lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;( !(in &amp;gt;&amp;gt; data).&lt;span class=&quot;hljs-built_in&quot;&gt;fail&lt;/span&gt;() )  {  &lt;span class=&quot;hljs-comment&quot;&gt;/* ... */&lt;/span&gt; }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The failure due to read attempt beyond eof is taken as the termination condition.  This means is that there is no easy way to distinguish between a successful stream and one that really fails for reasons other than eof. Take the following streams: &lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;1 2 3 4 5&amp;lt;eof&amp;gt;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;1 2 a 3 4 5&amp;lt;eof&amp;gt;&lt;/code&gt; &lt;/li&gt;\n&lt;li&gt;&lt;code&gt;a&amp;lt;eof&amp;gt;&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&lt;code&gt;while(in&amp;gt;&amp;gt;data)&lt;/code&gt; terminates with a set &lt;code&gt;failbit&lt;/code&gt; for &lt;em&gt;all&lt;/em&gt; three input. In the first and third, &lt;code&gt;eofbit&lt;/code&gt; is also set. So past the loop one needs very ugly extra logic to distinguish a proper input (1st) from improper ones (2nd and 3rd).&lt;/p&gt;\n\n&lt;p&gt;Whereas, take the following: &lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;( !in.&lt;span class=&quot;hljs-built_in&quot;&gt;eof&lt;/span&gt;() ) \n{  \n   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; data;\n   in &amp;gt;&amp;gt; data;\n   &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ( in.&lt;span class=&quot;hljs-built_in&quot;&gt;fail&lt;/span&gt;() ) &lt;span class=&quot;hljs-comment&quot;&gt;/* handle with break or throw */&lt;/span&gt;; \n   &lt;span class=&quot;hljs-comment&quot;&gt;// now use data&lt;/span&gt;\n}    \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here, &lt;code&gt;in.fail()&lt;/code&gt; verifies that as long as there is something to read, it is the correct one. It&apos;s purpose is not a mere while-loop terminator. &lt;/p&gt;\n\n&lt;p&gt;So far so good, but what happens if there is trailing space in the stream -- what sounds like the major concern against &lt;code&gt;eof()&lt;/code&gt; as terminator?&lt;/p&gt;\n\n&lt;p&gt;We don&apos;t need to surrender our error handling; just eat up the white-space:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;( !in.&lt;span class=&quot;hljs-built_in&quot;&gt;eof&lt;/span&gt;() ) \n{  \n   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; data;\n   in &amp;gt;&amp;gt; data &amp;gt;&amp;gt; ws; &lt;span class=&quot;hljs-comment&quot;&gt;// eat whitespace with std::ws&lt;/span&gt;\n   &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ( in.&lt;span class=&quot;hljs-built_in&quot;&gt;fail&lt;/span&gt;() ) &lt;span class=&quot;hljs-comment&quot;&gt;/* handle with break or throw */&lt;/span&gt;; \n   &lt;span class=&quot;hljs-comment&quot;&gt;// now use data&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;std::ws&lt;/code&gt; skips any potential (zero or more) trailing space in the stream while setting the &lt;code&gt;eofbit&lt;/code&gt;, and &lt;strong&gt;not the &lt;code&gt;failbit&lt;/code&gt;&lt;/strong&gt;.  So, &lt;code&gt;in.fail()&lt;/code&gt; works as expected, as long as there is at least one data to read. If all-blank streams are also acceptable, then the correct form is:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;( !(in&amp;gt;&amp;gt;ws).&lt;span class=&quot;hljs-built_in&quot;&gt;eof&lt;/span&gt;() ) \n{  \n   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; data;\n   in &amp;gt;&amp;gt; data; \n   &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ( in.&lt;span class=&quot;hljs-built_in&quot;&gt;fail&lt;/span&gt;() ) &lt;span class=&quot;hljs-comment&quot;&gt;/* handle with break or throw */&lt;/span&gt;; \n   &lt;span class=&quot;hljs-comment&quot;&gt;/* this will never fire if the eof is reached cleanly */&lt;/span&gt;\n   &lt;span class=&quot;hljs-comment&quot;&gt;// now use data&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;Summary:&lt;/strong&gt; A properly constructed &lt;code&gt;while(!eof)&lt;/code&gt; is not only possible and not wrong, but allows data to be localized within scope, and provides a cleaner separation of error checking from business as usual.  That being said, &lt;code&gt;while(!fail)&lt;/code&gt; is inarguably a more common and terse idiom, and may be preferred in simple (single data per read type of) scenarios. &lt;/p&gt;\n    ","\n&lt;p&gt;Because if programmers don&apos;t write &lt;code&gt;while(stream &amp;gt;&amp;gt; n)&lt;/code&gt;, they possibly write this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(!stream.&lt;span class=&quot;hljs-built_in&quot;&gt;eof&lt;/span&gt;())\n{\n    stream &amp;gt;&amp;gt; n;\n    &lt;span class=&quot;hljs-comment&quot;&gt;//some work on n;&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here the problem is, you cannot do &lt;code&gt;some work on n&lt;/code&gt; without first checking if the stream read was successful, because if it was unsuccessful, your &lt;code&gt;some work on n&lt;/code&gt; would produce undesired result.&lt;/p&gt;\n\n&lt;p&gt;The whole point is that, &lt;code&gt;eofbit&lt;/code&gt;, &lt;code&gt;badbit&lt;/code&gt;, or &lt;code&gt;failbit&lt;/code&gt; are set &lt;strong&gt;after an attempt is made to read from the stream.&lt;/strong&gt; So if &lt;code&gt;stream &amp;gt;&amp;gt; n&lt;/code&gt; fails, then &lt;code&gt;eofbit&lt;/code&gt;, &lt;code&gt;badbit&lt;/code&gt;, or &lt;code&gt;failbit&lt;/code&gt; is set immediately, so its more idiomatic if you write &lt;code&gt;while (stream &amp;gt;&amp;gt; n)&lt;/code&gt;, because the returned object &lt;code&gt;stream&lt;/code&gt; converts to &lt;code&gt;false&lt;/code&gt; if there was some failure in reading from the stream and consequently the loop stops. And it converts to &lt;code&gt;true&lt;/code&gt; if the read was successful and the loop continues.&lt;/p&gt;\n    ","\n&lt;p&gt;The other answers have explained why the logic is wrong in &lt;code&gt;while (!stream.eof())&lt;/code&gt; and how to fix it. I want to focus on something different:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;why is checking for eof explicitly using &lt;code&gt;iostream::eof&lt;/code&gt; wrong?&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;In general terms, checking for &lt;code&gt;eof&lt;/code&gt; &lt;em&gt;only&lt;/em&gt; is wrong because stream extraction (&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;) can fail without hitting the end of the file. If you have e.g. &lt;code&gt;int n; cin &amp;gt;&amp;gt; n;&lt;/code&gt; and the stream contains &lt;code&gt;hello&lt;/code&gt;, then &lt;code&gt;h&lt;/code&gt; is not a valid digit, so extraction will fail without reaching the end of the input.&lt;/p&gt;\n\n&lt;p&gt;This issue, combined with the general logic error of checking the stream state &lt;em&gt;before&lt;/em&gt; attempting to read from it, which means for N input items the loop will run N+1 times, leads to the following symptoms:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;If the stream is empty, the loop will run once. &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; will fail (there is no input to be read) and all variables that were supposed to be set (by &lt;code&gt;stream &amp;gt;&amp;gt; x&lt;/code&gt;) are actually uninitialized. This leads to garbage data being processed, which can manifest as nonsensical results (often huge numbers).&lt;/p&gt;\n\n&lt;p&gt;(If your standard library conforms to C++11, things are a bit different now: A failed &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; now sets numeric variables to &lt;code&gt;0&lt;/code&gt; instead of leaving them uninitialized (except for &lt;code&gt;char&lt;/code&gt;s).)&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;If the stream is not empty, the loop will run again after the last valid input. Since in the last iteration all &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; operations fail, variables are likely to keep their value from the previous iteration. This can manifest as &quot;the last line is printed twice&quot; or &quot;the last input record is processed twice&quot;.&lt;/p&gt;\n\n&lt;p&gt;(This should manifest a bit differently since C++11 (see above): Now you get a &quot;phantom record&quot; of zeroes instead of a repeated last line.)&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;If the stream contains malformed data but you only check for &lt;code&gt;.eof&lt;/code&gt;, you end up with an infinite loop. &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; will fail to extract any data from the stream, so the loop spins in place without ever reaching the end.&lt;/p&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;To recap: The solution is to test the success of the &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; operation itself, not to use a separate &lt;code&gt;.eof()&lt;/code&gt; method: &lt;code&gt;while (stream &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m) { ... }&lt;/code&gt;, just as in C you test the success of the &lt;code&gt;scanf&lt;/code&gt; call itself: &lt;code&gt;while (scanf(&quot;%d%d&quot;, &amp;amp;n, &amp;amp;m) == 2) { ... }&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;The important thing to remember is that, &lt;code&gt;inFile.eof()&lt;/code&gt; doesnt become &lt;code&gt;True&lt;/code&gt; until &lt;em&gt;&lt;strong&gt;after&lt;/strong&gt;&lt;/em&gt; an attempted read fails, because youve reached the end of the file. So, in this example, youll get an error.&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (!inFile.&lt;span class=&quot;hljs-built_in&quot;&gt;eof&lt;/span&gt;()){\n    inFile &amp;gt;&amp;gt; x;\n        &lt;span class=&quot;hljs-built_in&quot;&gt;process&lt;/span&gt;(x);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The way to make this loop correct, is to combine reading and checking into a single operation, like so&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (inFile &amp;gt;&amp;gt; x)&amp;nbsp;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;process&lt;/span&gt;(x);&amp;nbsp;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;By convention, &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; returns the stream we read from, and a Boolean test on a stream returns &lt;code&gt;False&lt;/code&gt; when the stream fails (such as reaching end of file).&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;So this gives us the correct sequence :&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;read&lt;/li&gt;\n&lt;li&gt;test whether the read succeeds&lt;/li&gt;\n&lt;li&gt;if and only if the test succeeds, process what weve read&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;If you happen to encounter some &lt;em&gt;other&lt;/em&gt; problem that prevents you from reading from the file correctly, you will not be able to reach &lt;code&gt;eof()&lt;/code&gt; as such. For example, lets look at something like this&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x;&amp;nbsp;\n&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (!inFile.&lt;span class=&quot;hljs-built_in&quot;&gt;eof&lt;/span&gt;()) {&amp;nbsp;\n    inFile &amp;gt;&amp;gt; x;&amp;nbsp;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;process&lt;/span&gt;(x);\n}&amp;nbsp;\n    \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Let us trace through the working of the above code, with an example&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Assume the contents of the file are &lt;code&gt;&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;a&apos;, &apos;b&apos;&lt;/code&gt;.&lt;/li&gt;\n&lt;li&gt;The loop will read the 1, 2, and 3 correctly.&lt;/li&gt;\n&lt;li&gt;Then itll get to &lt;code&gt;a&lt;/code&gt;.&lt;/li&gt;\n&lt;li&gt;When it tries to extract &lt;code&gt;a&lt;/code&gt; as an int, itll fail.&lt;/li&gt;\n&lt;li&gt;The stream is now in a failed state, until or unless we &lt;code&gt;clear&lt;/code&gt; the stream, all attempts at reading from it will fail.&lt;/li&gt;\n&lt;li&gt;But, when we test for eof(), itll return &lt;code&gt;False&lt;/code&gt;, because were not at the end of the file, because theres still &lt;code&gt;a&lt;/code&gt; waiting to be read.&lt;/li&gt;\n&lt;li&gt;The loop will keep trying to read from the file, and fail every time, so it &lt;strong&gt;never&lt;/strong&gt; reaches the end of the file.&lt;/li&gt;\n&lt;li&gt;So, the loop above will run forever.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;But, if we use a loop like this, we will get the required output.&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (inFile &amp;gt;&amp;gt; x)\n    &lt;span class=&quot;hljs-built_in&quot;&gt;process&lt;/span&gt;(x);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In this case, the stream will convert to &lt;code&gt;False&lt;/code&gt; not only in case of end of file, but also in case of a failed conversion, such as the &lt;code&gt;a&lt;/code&gt; that we cant read as an integer.&lt;/p&gt;\n    "],"comment":["\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;&lt;code&gt;scanf(...) != EOF&lt;/code&gt; won&apos;t work in C either, because &lt;code&gt;scanf&lt;/code&gt; returns the number of fields successfully parsed and assigned.  The correct condition is &lt;code&gt;scanf(...) &amp;lt; n&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the number of fields in the format string.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/103167/ben-voigt&quot; title=&quot;270,533 reputation&quot; class=&quot;comment-user&quot;&gt;Ben Voigt&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment12832536_5605125&quot;&gt;&lt;span title=&quot;2012-04-05 16:50:42Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 5, 2012 at 16:50&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Ben Voigt, it will return a negative number (which EOF usually is defined as such) in case EOF is reached&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/281306/sebastian&quot; title=&quot;5,863 reputation&quot; class=&quot;comment-user&quot;&gt;Sebastian&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment18536882_5605125&quot;&gt;&lt;span title=&quot;2012-11-23 23:44:41Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Nov 23, 2012 at 23:44&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@SebastianGodelet: Actually, it will return &lt;code&gt;EOF&lt;/code&gt; if end of file is encountered before the first field conversion (successful or not).  If end-of-file is reached between fields, it will return the number of fields succcessfully converted and stored.  Which makes comparison to &lt;code&gt;EOF&lt;/code&gt; wrong.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/103167/ben-voigt&quot; title=&quot;270,533 reputation&quot; class=&quot;comment-user&quot;&gt;Ben Voigt&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment18545887_5605125&quot;&gt;&lt;span title=&quot;2012-11-24 15:06:27Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Nov 24, 2012 at 15:06&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@SebastianGodelet: No, not really.  He errs when he says that &quot;past the loop there is no (easy) way to distinguish a proper input from an improper one&quot;.  In fact it&apos;s as easy as checking &lt;code&gt;.eof()&lt;/code&gt; after the loop exits.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/103167/ben-voigt&quot; title=&quot;270,533 reputation&quot; class=&quot;comment-user&quot;&gt;Ben Voigt&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment18547414_5605125&quot;&gt;&lt;span title=&quot;2012-11-24 16:52:48Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Nov 24, 2012 at 16:52&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Ben Yes, for this case (reading a simple int). But one can easily come up with a scenario where &lt;code&gt;while(fail)&lt;/code&gt; loop terminates with both an actual failure and an eof. Think about if you require 3 ints per iteration (say you are reading an x-y-z point or something), but there is, erroneously, only two ints in the stream.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/108461/sly&quot; title=&quot;1,642 reputation&quot; class=&quot;comment-user&quot;&gt;sly&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment18550194_5605125&quot;&gt;&lt;span title=&quot;2012-11-24 19:47:17Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Nov 24, 2012 at 19:47&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Worth mentioning is that if (!(inStream &amp;gt;&amp;gt; data).eof()) doesn&apos;t do anything useful either. Fallacy 1: It&apos;ll not enter the condition if there was no whitespace after the last piece of data (last datum will not be processed). Fallacy 2: It will enter the condition even if reading data failed, as long as EOF was not reached (infinite loop, processing the same old data over and over again).&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/238233/tronic&quot; title=&quot;10,042 reputation&quot; class=&quot;comment-user&quot;&gt;Tronic&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment20081828_5605159&quot;&gt;&lt;span title=&quot;2013-01-20 16:20:10Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jan 20, 2013 at 16:20&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;I think it&apos;s worth pointing out that this answer is slightly misleading. When extracting &lt;code&gt;int&lt;/code&gt;s or &lt;code&gt;std::string&lt;/code&gt;s or similar, the EOF bit &lt;i&gt;is&lt;/i&gt; set when you extract the one right before the end and the extraction hits the end. You do not need to read again. The reason it doesn&apos;t get set when reading from files is because there&apos;s an extra &lt;code&gt;\\n&lt;/code&gt; at the end. I&apos;ve covered this in &lt;a href=&quot;http://stackoverflow.com/a/14615673/150634&quot;&gt;another answer&lt;/a&gt;. Reading &lt;code&gt;char&lt;/code&gt;s is a different matter because it only extracts one at a time and doesn&apos;t continue to hit the end.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/150634/joseph-mansfield&quot; title=&quot;105,003 reputation&quot; class=&quot;comment-user&quot;&gt;Joseph Mansfield&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment22561833_5605159&quot;&gt;&lt;span title=&quot;2013-04-06 16:59:44Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 6, 2013 at 16:59&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 2 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;The main problem is that &lt;b&gt;just because we haven&apos;t reached the EOF, doesn&apos;t mean the next read will succeed&lt;/b&gt;.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/150634/joseph-mansfield&quot; title=&quot;105,003 reputation&quot; class=&quot;comment-user&quot;&gt;Joseph Mansfield&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment22561896_5605159&quot;&gt;&lt;span title=&quot;2013-04-06 17:03:49Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 6, 2013 at 17:03&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@sftrabbit: all true but not very useful... even if there&apos;s no trailing &apos;\\n&apos; it&apos;s reasonable to want other trailing whitespace to be handled consistently with other whitespace throughout the file (i.e. skipped).  Further, a subtle consequence of &quot;when you extract the one right before&quot; is that &lt;code&gt;while (!eof())&lt;/code&gt; won&apos;t &quot;work&quot; on &lt;code&gt;int&lt;/code&gt;s or &lt;code&gt;std::string&lt;/code&gt;s when the input is totally empty, so even knowing there&apos;s no trailing &lt;code&gt;\\n&lt;/code&gt; care is needed.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/410767/tony-delroy&quot; title=&quot;99,376 reputation&quot; class=&quot;comment-user&quot;&gt;Tony Delroy&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment23094105_5605159&quot;&gt;&lt;span title=&quot;2013-04-23 03:34:22Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 23, 2013 at 3:34&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@TonyD Totally agree. The reason I&apos;m saying it is because I think most people when they read this and similar answers will think that if the stream contains &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; (no trailing whitespace or &lt;code&gt;\\n&lt;/code&gt;) and a &lt;code&gt;std::string&lt;/code&gt; is extracted, it will extract the letters from &lt;code&gt;H&lt;/code&gt; to &lt;code&gt;o&lt;/code&gt;, stop extracting, and then &lt;i&gt;not&lt;/i&gt; set the EOF bit. In fact, it would set the EOF bit because it was the EOF that stopped the extraction. Just hoping to clear that up for people.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/150634/joseph-mansfield&quot; title=&quot;105,003 reputation&quot; class=&quot;comment-user&quot;&gt;Joseph Mansfield&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment23100620_5605159&quot;&gt;&lt;span title=&quot;2013-04-23 08:23:10Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 23, 2013 at 8:23&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;&quot;&lt;i&gt;So past the loop there is no (easy) way to distinguish a proper input from an improper one.&lt;/i&gt;&quot; Except that in one case both &lt;code&gt;eofbit&lt;/code&gt; and &lt;code&gt;failbit&lt;/code&gt; are set, in the other only &lt;code&gt;failbit&lt;/code&gt; is set. You only need to test that &lt;i&gt;once&lt;/i&gt; after the loop has terminated, not on every iteration; it will only leave the loop once, so you only need to check &lt;i&gt;why&lt;/i&gt; it left the loop once.  &lt;code&gt;while (in &amp;gt;&amp;gt; data)&lt;/code&gt; works fine for all blank streams.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/981959/jonathan-wakely&quot; title=&quot;160,851 reputation&quot; class=&quot;comment-user&quot;&gt;Jonathan Wakely&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment21189709_13536879&quot;&gt;&lt;span title=&quot;2013-02-25 14:09:27Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Feb 25, 2013 at 14:09&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;What you are saying (and a point made earlier) is that a bad formatted stream can be identified as &lt;code&gt;!eof &amp;amp; fail&lt;/code&gt; past loop. There are cases in which one can not rely on this. See above comment (&lt;a href=&quot;http://goo.gl/9mXYX&quot; rel=&quot;nofollow noreferrer&quot;&gt;goo.gl/9mXYX&lt;/a&gt;). Eitherway, I am not proposing &lt;code&gt;eof&lt;/code&gt;-check as &lt;i&gt;the-always-better&lt;/i&gt; alternative. I am merely saying, it &lt;i&gt;is&lt;/i&gt; a possible and (in some cases more appropriate) way of doing this, rather than &quot;most certainly wrong!&quot; as it tends to be claimed around here in SO.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/108461/sly&quot; title=&quot;1,642 reputation&quot; class=&quot;comment-user&quot;&gt;sly&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment21193527_13536879&quot;&gt;&lt;span title=&quot;2013-02-25 15:58:29Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Feb 25, 2013 at 15:58&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 7 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;&lt;i&gt;&quot;As an example, consider how you&apos;d check for errors where the data is a struct with overloaded operator&amp;gt;&amp;gt; reading multiple fields at once&quot;&lt;/i&gt; - a much simpler case supporting your point is &lt;code&gt;stream &amp;gt;&amp;gt; my_int&lt;/code&gt; where the stream contains e.g. &quot;-&quot;: &lt;code&gt;eofbit&lt;/code&gt; and &lt;code&gt;failbit&lt;/code&gt; are set.  That&apos;s worse than the &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; scenario, where the user-provided overload at least has the option of clearing &lt;code&gt;eofbit&lt;/code&gt; before returning to help support &lt;code&gt;while (s &amp;gt;&amp;gt; x)&lt;/code&gt; usage.  More generally, this answer could use a clean-up - only the final &lt;code&gt;while( !(in&amp;gt;&amp;gt;ws).eof() )&lt;/code&gt; is generally robust, and it&apos;s buried at the end.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/410767/tony-delroy&quot; title=&quot;99,376 reputation&quot; class=&quot;comment-user&quot;&gt;Tony Delroy&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment45712673_13536879&quot;&gt;&lt;span title=&quot;2015-02-25 06:09:52Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Feb 25, 2015 at 6:09&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 2 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;With your &quot;3 examples&quot; &lt;i&gt;only&lt;/i&gt; the first sets eof.  The third does not because the &lt;code&gt;a&lt;/code&gt; fails conversion to int and is not read -- it will be left on the input.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/16406/chris-dodd&quot; title=&quot;112,580 reputation&quot; class=&quot;comment-user&quot;&gt;Chris Dodd&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment127062015_13536879&quot;&gt;&lt;span title=&quot;2022-04-17 20:54:00Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 17 at 20:54&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;so? that&apos;s is kind of the point: early break with a bad stream, or end-loop successfully with eof.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/108461/sly&quot; title=&quot;1,642 reputation&quot; class=&quot;comment-user&quot;&gt;sly&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment127236554_13536879&quot;&gt;&lt;span title=&quot;2022-04-26 01:58:03Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 26 at 1:58&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Apart from the mentioned &quot;undesired result&quot; with doing work on the undefined value of &lt;code&gt;n&lt;/code&gt;, the program might also fall into an &lt;b&gt;infinite loop&lt;/b&gt;, if the failing stream operation doesn&apos;t consume any input.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/4271479/mastov&quot; title=&quot;2,847 reputation&quot; class=&quot;comment-user&quot;&gt;mastov&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment87143702_5605161&quot;&gt;&lt;span title=&quot;2018-04-27 13:33:26Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 27, 2018 at 13:33&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;this is the most accurate answer, although as of c++11, i dont believe the variables are uninitialized anymore(the first bullet pt)&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/7183221/csguy&quot; title=&quot;1,273 reputation&quot; class=&quot;comment-user&quot;&gt;csguy&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment101610687_55981331&quot;&gt;&lt;span title=&quot;2019-08-20 13:52:12Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Aug 20, 2019 at 13:52&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;?syntax error: undefined identifiers &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/7143595/matg&quot; title=&quot;464 reputation&quot; class=&quot;comment-user&quot;&gt;MatG&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment127497273_71187351&quot;&gt;&lt;span title=&quot;2022-05-08 11:20:10Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;May 8 at 11:20&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        "],"id":35,"title":"Why is iostream::eof inside a loop condition (i.e. `while (!stream.eof())`) considered wrong?","content":"\n                \n&lt;p&gt;I just found a comment in &lt;a href=&quot;https://stackoverflow.com/questions/5578631/c-how-do-you-stop-reading-integer-from-text-file-when-encounter-negative-intege/5578649#5578649&quot;&gt;this&lt;/a&gt; answer saying that using &lt;code&gt;iostream::eof&lt;/code&gt; in a loop condition is &quot;almost certainly wrong&quot;. I generally use something like &lt;code&gt;while(cin&amp;gt;&amp;gt;n)&lt;/code&gt; - which I guess implicitly checks for EOF.&lt;/p&gt;\n\n&lt;p&gt;Why is checking for eof explicitly using &lt;code&gt;while (!cin.eof())&lt;/code&gt; wrong?  &lt;/p&gt;\n\n&lt;p&gt;How is it different from using &lt;code&gt;scanf(&quot;...&quot;,...)!=EOF&lt;/code&gt; in C (which I often use with no problems)?&lt;/p&gt;\n    ","slug":"why-is-iostream::eof-inside-a-loop-condition-(i.e.-while-(!stream.eof()))-considered-wrong-1657384355427","postType":"QUESTION","createdAt":"2022-07-09T16:32:35.000Z","updatedAt":"2022-07-09T16:32:35.000Z","tags":[{"id":122,"name":"iostream","slug":"iostream","createdAt":"2022-07-09T16:32:35.000Z","updatedAt":"2022-07-09T16:32:35.000Z","Questions_Tags":{"questionId":35,"tagId":122}}]}]}},"__N_SSG":true}