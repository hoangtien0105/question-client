{"pageProps":{"data":{"count":1,"rows":[{"answer":["\n&lt;p&gt;Note:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;If you&apos;re looking for &lt;strong&gt;prepackaged functionality&lt;/strong&gt; based on the techniques discussed in this answer:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;&lt;code&gt;bash&lt;/code&gt; functions&lt;/strong&gt; that enable &lt;strong&gt;robust escaping&lt;/strong&gt; even in &lt;strong&gt;&lt;em&gt;multi-line&lt;/em&gt; substitutions&lt;/strong&gt; can be found at the &lt;strong&gt;bottom of this post&lt;/strong&gt; (plus a &lt;code&gt;perl&lt;/code&gt; solution that uses &lt;code&gt;perl&lt;/code&gt;&apos;s built-in support for such escaping).&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/a/29626460/1745001&quot;&gt;@EdMorton&apos;s answer&lt;/a&gt; contains a &lt;strong&gt;tool&lt;/strong&gt; (&lt;code&gt;bash&lt;/code&gt; script) that robustly performs &lt;strong&gt;&lt;em&gt;single-line&lt;/em&gt; substitutions&lt;/strong&gt;.\n&lt;ul&gt;\n&lt;li&gt;Ed&apos;s answer now has &lt;strong&gt;an &lt;em&gt;improved&lt;/em&gt; version of the &lt;code&gt;sed&lt;/code&gt; command used below&lt;/strong&gt;, which is needed if you want &lt;strong&gt;to escape string literals for potential use with &lt;em&gt;other&lt;/em&gt; regex-processing tools, such as &lt;code&gt;awk&lt;/code&gt; and &lt;code&gt;perl&lt;/code&gt;.&lt;/strong&gt; In short: &lt;strong&gt;for cross-tool use, &lt;code&gt;\\&lt;/code&gt; must be escaped as &lt;code&gt;\\\\&lt;/code&gt; rather than as &lt;code&gt;[\\]&lt;/code&gt;&lt;/strong&gt;, which means: instead of the&lt;br&gt;\n&lt;code&gt;sed &apos;s/[^^]/[&amp;amp;]/g; s/\\^/\\\\^/g&apos;&lt;/code&gt; command used below, you must use&lt;br&gt;\n&lt;code&gt;sed &apos;s/[^^\\\\]/[&amp;amp;]/g; s/\\^/\\\\^/g; s/\\\\/\\\\\\\\/g&apos;&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;All snippets assume &lt;code&gt;bash&lt;/code&gt; as the shell (POSIX-compliant reformulations are possible):&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;h2&gt;SINGLE-line Solutions&lt;/h2&gt;\n&lt;hr&gt;\n&lt;h3&gt;Escaping a string literal for use as a &lt;em&gt;regex&lt;/em&gt; in &lt;code&gt;sed&lt;/code&gt;:&lt;/h3&gt;\n&lt;p&gt;&lt;sup&gt;To give credit where credit is due: I found the regex used below in &lt;a href=&quot;https://stackoverflow.com/a/28783790/45375&quot;&gt;this answer&lt;/a&gt;.&lt;/sup&gt;&lt;/p&gt;\n&lt;p&gt;Assuming that the search string is a &lt;em&gt;single&lt;/em&gt;-line string:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;search=&lt;span class=&quot;hljs-string&quot;&gt;&apos;abc\\n\\t[a-z]\\+\\([^ ]\\)\\{2,3\\}\\3&apos;&lt;/span&gt;  &lt;span class=&quot;hljs-comment&quot;&gt;# sample input containing metachars.&lt;/span&gt;\n\nsearchEscaped=$(sed &lt;span class=&quot;hljs-string&quot;&gt;&apos;s/[^^]/[&amp;amp;]/g; s/\\^/\\\\^/g&apos;&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$search&lt;/span&gt;&quot;&lt;/span&gt;) &lt;span class=&quot;hljs-comment&quot;&gt;# escape it.&lt;/span&gt;\n\nsed -n &lt;span class=&quot;hljs-string&quot;&gt;&quot;s/&lt;span class=&quot;hljs-variable&quot;&gt;$searchEscaped&lt;/span&gt;/foo/p&quot;&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$search&lt;/span&gt;&quot;&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;# if ok, echoes &apos;foo&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;Every character except &lt;code&gt;^&lt;/code&gt; is placed in its own character set &lt;code&gt;[...]&lt;/code&gt; expression to treat it as a literal.\n&lt;ul&gt;\n&lt;li&gt;Note that &lt;code&gt;^&lt;/code&gt; is the one char. you &lt;em&gt;cannot&lt;/em&gt; represent as &lt;code&gt;[^]&lt;/code&gt;, because it has special meaning in that location (negation).&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;Then, &lt;code&gt;^&lt;/code&gt; chars. are escaped as &lt;code&gt;\\^&lt;/code&gt;.\n&lt;ul&gt;\n&lt;li&gt;Note that you cannot just escape every char by putting a &lt;code&gt;\\&lt;/code&gt; in front of it because that can turn a literal char into a metachar, e.g. &lt;code&gt;\\&amp;lt;&lt;/code&gt; and &lt;code&gt;\\b&lt;/code&gt; are word boundaries in some tools, &lt;code&gt;\\n&lt;/code&gt; is a newline, &lt;code&gt;\\{&lt;/code&gt; is the start of a RE interval like &lt;code&gt;\\{1,3\\}&lt;/code&gt;, etc.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;The approach is robust, but not efficient.&lt;/p&gt;\n&lt;p&gt;The &lt;strong&gt;robustness comes from &lt;em&gt;not&lt;/em&gt; trying to anticipate all special regex characters&lt;/strong&gt; - which will vary across regex dialects - but to &lt;strong&gt;focus on only 2 features &lt;em&gt;shared by all regex dialects&lt;/em&gt;&lt;/strong&gt;:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;the ability to specify literal characters inside a character set.&lt;/li&gt;\n&lt;li&gt;the ability to escape a literal  &lt;code&gt;^&lt;/code&gt; as &lt;code&gt;\\^&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;h3&gt;Escaping a string literal for use as the &lt;em&gt;replacement string&lt;/em&gt; in &lt;code&gt;sed&lt;/code&gt;&apos;s &lt;code&gt;s///&lt;/code&gt; command:&lt;/h3&gt;\n&lt;p&gt;The replacement string in a &lt;code&gt;sed&lt;/code&gt; &lt;code&gt;s///&lt;/code&gt; command is not a regex, but it recognizes &lt;em&gt;placeholders&lt;/em&gt; that refer to either the entire string matched by the regex (&lt;code&gt;&amp;amp;&lt;/code&gt;) or specific capture-group results by index (&lt;code&gt;\\1&lt;/code&gt;, &lt;code&gt;\\2&lt;/code&gt;, ...), so these must be escaped, along with the (customary) regex delimiter, &lt;code&gt;/&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;Assuming that the replacement string is a &lt;em&gt;single&lt;/em&gt;-line string:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;replace=&lt;span class=&quot;hljs-string&quot;&gt;&apos;Laurel &amp;amp; Hardy; PS\\2&apos;&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;# sample input containing metachars.&lt;/span&gt;\n\nreplaceEscaped=$(sed &lt;span class=&quot;hljs-string&quot;&gt;&apos;s/[&amp;amp;/\\]/\\\\&amp;amp;/g&apos;&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$replace&lt;/span&gt;&quot;&lt;/span&gt;) &lt;span class=&quot;hljs-comment&quot;&gt;# escape it&lt;/span&gt;\n\nsed -n &lt;span class=&quot;hljs-string&quot;&gt;&quot;s/\\(.*\\) \\(.*\\)/&lt;span class=&quot;hljs-variable&quot;&gt;$replaceEscaped&lt;/span&gt;/p&quot;&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;foo bar&quot;&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;# if ok, outputs $replace as is&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;hr&gt;\n&lt;hr&gt;\n&lt;h2&gt;MULTI-line Solutions&lt;/h2&gt;\n&lt;hr&gt;\n&lt;h3&gt;Escaping a MULTI-LINE string literal for use as a &lt;em&gt;regex&lt;/em&gt; in &lt;code&gt;sed&lt;/code&gt;:&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: This only makes sense if &lt;em&gt;multiple input lines&lt;/em&gt; (possibly ALL) have been read before attempting to match.&lt;br&gt;\nSince tools such as &lt;code&gt;sed&lt;/code&gt; and &lt;code&gt;awk&lt;/code&gt; operate on a &lt;em&gt;single&lt;/em&gt; line at a time by default, extra steps are needed to make them read more than one line at a time.&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# Define sample multi-line literal.&lt;/span&gt;\nsearch=&lt;span class=&quot;hljs-string&quot;&gt;&apos;/abc\\n\\t[a-z]\\+\\([^ ]\\)\\{2,3\\}\\3\n/def\\n\\t[A-Z]\\+\\([^ ]\\)\\{3,4\\}\\4&apos;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# Escape it.&lt;/span&gt;\nsearchEscaped=$(sed -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;s/[^^]/[&amp;amp;]/g; s/\\^/\\\\^/g; $!a\\&apos;&lt;/span&gt;$&lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&apos;\\\\n&apos;&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$search&lt;/span&gt;&quot;&lt;/span&gt; | &lt;span class=&quot;hljs-built_in&quot;&gt;tr&lt;/span&gt; -d &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;)           &lt;span class=&quot;hljs-comment&quot;&gt;#&apos;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# Use in a Sed command that reads ALL input lines up front.&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;# If ok, echoes &apos;foo&apos;&lt;/span&gt;\nsed -n -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;:a&apos;&lt;/span&gt; -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;$!{N;ba&apos;&lt;/span&gt; -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;}&apos;&lt;/span&gt; -e &lt;span class=&quot;hljs-string&quot;&gt;&quot;s/&lt;span class=&quot;hljs-variable&quot;&gt;$searchEscaped&lt;/span&gt;/foo/p&quot;&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$search&lt;/span&gt;&quot;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;The newlines in multi-line input strings must be translated to &lt;code&gt;&apos;\\n&apos;&lt;/code&gt; &lt;em&gt;strings&lt;/em&gt;, which is how newlines are encoded in a regex.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;$!a\\&apos;$&apos;\\n&apos;&apos;\\\\n&apos;&lt;/code&gt; appends &lt;em&gt;string&lt;/em&gt; &lt;code&gt;&apos;\\n&apos;&lt;/code&gt; to every output line but the last (the last newline is ignored, because it was added by &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;)&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;tr -d &apos;\\n&lt;/code&gt; then removes all &lt;em&gt;actual&lt;/em&gt; newlines from the string (&lt;code&gt;sed&lt;/code&gt; adds one whenever it prints its pattern space), effectively replacing all newlines in the input with &lt;code&gt;&apos;\\n&apos;&lt;/code&gt; strings.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;&lt;code&gt;-e &apos;:a&apos; -e &apos;$!{N;ba&apos; -e &apos;}&apos;&lt;/code&gt; is the POSIX-compliant form of a &lt;code&gt;sed&lt;/code&gt; idiom that reads &lt;em&gt;all&lt;/em&gt; input lines a loop, therefore leaving subsequent commands to operate on all input lines at once.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;If you&apos;re using &lt;em&gt;GNU&lt;/em&gt; &lt;code&gt;sed&lt;/code&gt; (only), you can use its &lt;code&gt;-z&lt;/code&gt; option to simplify reading all input lines at once:&lt;br&gt;\n&lt;code&gt;sed -z &quot;s/$searchEscaped/foo/&quot; &amp;lt;&amp;lt;&amp;lt;&quot;$search&quot;&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;h3&gt;Escaping a MULTI-LINE string literal for use as the &lt;em&gt;replacement string&lt;/em&gt; in &lt;code&gt;sed&lt;/code&gt;&apos;s &lt;code&gt;s///&lt;/code&gt; command:&lt;/h3&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# Define sample multi-line literal.&lt;/span&gt;\nreplace=&lt;span class=&quot;hljs-string&quot;&gt;&apos;Laurel &amp;amp; Hardy; PS\\2\nMasters\\1 &amp;amp; Johnson\\2&apos;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# Escape it for use as a Sed replacement string.&lt;/span&gt;\nIFS= &lt;span class=&quot;hljs-built_in&quot;&gt;read&lt;/span&gt; -d &lt;span class=&quot;hljs-string&quot;&gt;&apos;&apos;&lt;/span&gt; -r &amp;lt; &amp;lt;(sed -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;:a&apos;&lt;/span&gt; -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;$!{N;ba&apos;&lt;/span&gt; -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;}&apos;&lt;/span&gt; -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;s/[&amp;amp;/\\]/\\\\&amp;amp;/g; s/\\n/\\\\&amp;amp;/g&apos;&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$replace&lt;/span&gt;&quot;&lt;/span&gt;)\nreplaceEscaped=&lt;span class=&quot;hljs-variable&quot;&gt;${REPLY%$&apos;\\n&apos;}&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# If ok, outputs $replace as is.&lt;/span&gt;\nsed -n &lt;span class=&quot;hljs-string&quot;&gt;&quot;s/\\(.*\\) \\(.*\\)/&lt;span class=&quot;hljs-variable&quot;&gt;$replaceEscaped&lt;/span&gt;/p&quot;&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;foo bar&quot;&lt;/span&gt; \n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;Newlines in the input string must be retained as actual newlines, but &lt;code&gt;\\&lt;/code&gt;-escaped.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;-e &apos;:a&apos; -e &apos;$!{N;ba&apos; -e &apos;}&apos;&lt;/code&gt; is the POSIX-compliant form of a &lt;code&gt;sed&lt;/code&gt; idiom that reads &lt;em&gt;all&lt;/em&gt; input lines a loop.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;&apos;s/[&amp;amp;/\\]/\\\\&amp;amp;/g&lt;/code&gt; escapes all &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;\\&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt; instances, as in the single-line solution.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;s/\\n/\\\\&amp;amp;/g&apos;&lt;/code&gt; then &lt;code&gt;\\&lt;/code&gt;-prefixes all actual newlines.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;IFS= read -d &apos;&apos; -r&lt;/code&gt; is used to read the &lt;code&gt;sed&lt;/code&gt; command&apos;s output &lt;em&gt;as is&lt;/em&gt; (to avoid the automatic removal of trailing newlines that a command substitution (&lt;code&gt;$(...)&lt;/code&gt;) would perform).&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;${REPLY%$&apos;\\n&apos;}&lt;/code&gt; then removes a &lt;em&gt;single&lt;/em&gt; trailing newline, which the &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; has implicitly appended to the input.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;hr&gt;\n&lt;h2&gt;&lt;em&gt;&lt;code&gt;bash&lt;/code&gt; functions&lt;/em&gt; based on the above (for &lt;code&gt;sed&lt;/code&gt;):&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;quoteRe()&lt;/code&gt; quotes (escapes) for use in a &lt;em&gt;regex&lt;/em&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;quoteSubst()&lt;/code&gt; quotes for use in the &lt;em&gt;substitution string&lt;/em&gt; of a &lt;code&gt;s///&lt;/code&gt; call.&lt;/li&gt;\n&lt;li&gt;both handle &lt;em&gt;multi-line&lt;/em&gt; input correctly\n&lt;ul&gt;\n&lt;li&gt;Note that because &lt;code&gt;sed&lt;/code&gt; reads a &lt;em&gt;single&lt;/em&gt; line at at time by default, use of &lt;code&gt;quoteRe()&lt;/code&gt; with multi-line strings only makes sense in &lt;code&gt;sed&lt;/code&gt; commands that explicitly read multiple (or all) lines at once.&lt;/li&gt;\n&lt;li&gt;Also, using command substitutions (&lt;code&gt;$(...)&lt;/code&gt;) to call the functions won&apos;t work for strings that have &lt;em&gt;trailing&lt;/em&gt; newlines; in that event, use something like &lt;code&gt;IFS= read -d &apos;&apos; -r escapedValue &amp;lt;(quoteSubst &quot;$value&quot;)&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre class=&quot;lang-sh s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# SYNOPSIS&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;#   quoteRe &amp;lt;text&amp;gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;quoteRe&lt;/span&gt;&lt;/span&gt;() { sed -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;s/[^^]/[&amp;amp;]/g; s/\\^/\\\\^/g; $!a\\&apos;&lt;/span&gt;$&lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&apos;\\\\n&apos;&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$1&lt;/span&gt;&quot;&lt;/span&gt; | &lt;span class=&quot;hljs-built_in&quot;&gt;tr&lt;/span&gt; -d &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;; }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-perl&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# SYNOPSIS&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;#  quoteSubst &amp;lt;text&amp;gt;&lt;/span&gt;\nquoteSubst() {\n  IFS= &lt;span class=&quot;hljs-keyword&quot;&gt;read&lt;/span&gt; -d &lt;span class=&quot;hljs-string&quot;&gt;&apos;&apos;&lt;/span&gt; -r &amp;lt; &amp;lt;(sed -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;:a&apos;&lt;/span&gt; -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;$!{N;ba&apos;&lt;/span&gt; -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;}&apos;&lt;/span&gt; -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;s/[&amp;amp;/\\]/\\\\&amp;amp;/g; s/\\n/\\\\&amp;amp;/g&apos;&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;$1&quot;&lt;/span&gt;)\n  &lt;span class=&quot;hljs-keyword&quot;&gt;printf&lt;/span&gt; %s &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-subst&quot;&gt;${REPLY%$&lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;}&lt;/span&gt;&quot;&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;from=$&lt;span class=&quot;hljs-string&quot;&gt;&apos;Cost\\(*):\\n$3.&apos;&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;# sample input containing metachars. &lt;/span&gt;\nto=&lt;span class=&quot;hljs-string&quot;&gt;&apos;You &amp;amp; I&apos;&lt;/span&gt;$&lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&apos;eating A\\1 sauce.&apos;&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;# sample replacement string with metachars.&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# Should print the unmodified value of $to&lt;/span&gt;\nsed -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;:a&apos;&lt;/span&gt; -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;$!{N;ba&apos;&lt;/span&gt; -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;}&apos;&lt;/span&gt; -e &lt;span class=&quot;hljs-string&quot;&gt;&quot;s/&lt;span class=&quot;hljs-subst&quot;&gt;$(quoteRe &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$from&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;/&lt;span class=&quot;hljs-subst&quot;&gt;$(quoteSubst &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$to&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;/&quot;&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$from&lt;/span&gt;&quot;&lt;/span&gt; \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Note the use of &lt;code&gt;-e &apos;:a&apos; -e &apos;$!{N;ba&apos; -e &apos;}&apos;&lt;/code&gt; to read all input at once, so that the multi-line substitution works.&lt;/p&gt;\n&lt;hr&gt;\n&lt;hr&gt;\n&lt;h2&gt;&lt;code&gt;perl&lt;/code&gt; solution:&lt;/h2&gt;\n&lt;p&gt;&lt;strong&gt;Perl has built-in support&lt;/strong&gt; for escaping arbitrary strings for literal use in a regex: the &lt;strong&gt;&lt;a href=&quot;http://perldoc.perl.org/functions/quotemeta.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;quotemeta()&lt;/code&gt; function&lt;/a&gt; or its equivalent &lt;code&gt;\\Q...\\E&lt;/code&gt; quoting&lt;/strong&gt;.&lt;br&gt;\nThe approach is the same for both single- and multi-line strings; for example:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt;=$&lt;span class=&quot;hljs-string&quot;&gt;&apos;Cost\\(*):\\n$3.&apos;&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;# sample input containing metachars.&lt;/span&gt;\nto=&lt;span class=&quot;hljs-string&quot;&gt;&apos;You owe me $1/$&amp;amp; for&apos;&lt;/span&gt;$&lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&apos;eating A\\1 sauce.&apos;&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;# sample replacement string w/ metachars.&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# Should print the unmodified value of $to.&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;# Note that the replacement value needs NO escaping.&lt;/span&gt;\nperl -s -&lt;span class=&quot;hljs-number&quot;&gt;0777&lt;/span&gt; -pe &lt;span class=&quot;hljs-string&quot;&gt;&apos;s/\\Q$from\\E/$to/&apos;&lt;/span&gt; -- -&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-subst&quot;&gt;$from&lt;/span&gt;&quot;&lt;/span&gt; -to=&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-subst&quot;&gt;$to&lt;/span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-subst&quot;&gt;$from&lt;/span&gt;&quot;&lt;/span&gt; \n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;Note the use of &lt;code&gt;-0777&lt;/code&gt; to read all input at once, so that the multi-line substitution works.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;The &lt;code&gt;-s&lt;/code&gt; option allows placing &lt;code&gt;-&amp;lt;var&amp;gt;=&amp;lt;val&amp;gt;&lt;/code&gt;-style Perl variable definitions following &lt;code&gt;--&lt;/code&gt; after the script, before any filename operands.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;Building upon &lt;a href=&quot;https://stackoverflow.com/a/29613573/1745001&quot;&gt;@mklement0&apos;s answer&lt;/a&gt; in this thread, the following tool will replace any single-line string (as opposed to regexp) with any other single-line string using &lt;code&gt;sed&lt;/code&gt; and &lt;code&gt;bash&lt;/code&gt;:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;$ &lt;span class=&quot;hljs-built_in&quot;&gt;cat&lt;/span&gt; sedstr\n&lt;span class=&quot;hljs-comment&quot;&gt;#!/bin/bash&lt;/span&gt;\nold=&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$1&lt;/span&gt;&quot;&lt;/span&gt;\nnew=&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$2&lt;/span&gt;&quot;&lt;/span&gt;\nfile=&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;${3:--}&lt;/span&gt;&quot;&lt;/span&gt;\nescOld=$(sed &lt;span class=&quot;hljs-string&quot;&gt;&apos;s/[^^\\\\]/[&amp;amp;]/g; s/\\^/\\\\^/g; s/\\\\/\\\\\\\\/g&apos;&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$old&lt;/span&gt;&quot;&lt;/span&gt;)\nescNew=$(sed &lt;span class=&quot;hljs-string&quot;&gt;&apos;s/[&amp;amp;/\\]/\\\\&amp;amp;/g&apos;&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$new&lt;/span&gt;&quot;&lt;/span&gt;)\nsed &lt;span class=&quot;hljs-string&quot;&gt;&quot;s/&lt;span class=&quot;hljs-variable&quot;&gt;$escOld&lt;/span&gt;/&lt;span class=&quot;hljs-variable&quot;&gt;$escNew&lt;/span&gt;/g&quot;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$file&lt;/span&gt;&quot;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;To illustrate the need for this tool, consider trying to replace &lt;code&gt;a.*/b{2,}\\nc&lt;/code&gt; with &lt;code&gt;d&amp;amp;e\\1f&lt;/code&gt; by calling &lt;code&gt;sed&lt;/code&gt; directly:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;$ &lt;span class=&quot;hljs-built_in&quot;&gt;cat&lt;/span&gt; file\na.*/b{2,}\\nc\naxx/bb\\nc\n\n$ sed &lt;span class=&quot;hljs-string&quot;&gt;&apos;s/a.*/b{2,}\\nc/d&amp;amp;e\\1f/&apos;&lt;/span&gt; file  \nsed: -e expression &lt;span class=&quot;hljs-comment&quot;&gt;#1, char 16: unknown option to `s&apos;&lt;/span&gt;\n$ sed &lt;span class=&quot;hljs-string&quot;&gt;&apos;s/a.*\\/b{2,}\\nc/d&amp;amp;e\\1f/&apos;&lt;/span&gt; file\nsed: -e expression &lt;span class=&quot;hljs-comment&quot;&gt;#1, char 23: invalid reference \\1 on `s&apos; command&apos;s RHS&lt;/span&gt;\n$ sed &lt;span class=&quot;hljs-string&quot;&gt;&apos;s/a.*\\/b{2,}\\nc/d&amp;amp;e\\\\1f/&apos;&lt;/span&gt; file\na.*/b{2,}\\nc\naxx/bb\\nc\n&lt;span class=&quot;hljs-comment&quot;&gt;# .... and so on, peeling the onion ad nauseum until:&lt;/span&gt;\n$ sed &lt;span class=&quot;hljs-string&quot;&gt;&apos;s/a\\.\\*\\/b{2,}\\\\nc/d\\&amp;amp;e\\\\1f/&apos;&lt;/span&gt; file\nd&amp;amp;e\\1f\naxx/bb\\nc\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;or use the above tool:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;$ sedstr &lt;span class=&quot;hljs-string&quot;&gt;&apos;a.*/b{2,}\\nc&apos;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;d&amp;amp;e\\1f&apos;&lt;/span&gt; file  \nd&amp;amp;e\\1f\naxx/bb\\nc\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The reason this is useful is that it can be easily augmented to use word-delimiters to replace words if necessary, e.g. in GNU &lt;code&gt;sed&lt;/code&gt; syntax:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;sed &lt;span class=&quot;hljs-string&quot;&gt;&quot;s/\\&amp;lt;&lt;span class=&quot;hljs-variable&quot;&gt;$escOld&lt;/span&gt;\\&amp;gt;/&lt;span class=&quot;hljs-variable&quot;&gt;$escNew&lt;/span&gt;/g&quot;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$file&lt;/span&gt;&quot;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;whereas the tools that actually operate on strings (e.g. &lt;code&gt;awk&lt;/code&gt;&apos;s &lt;code&gt;index()&lt;/code&gt;) cannot use word-delimiters.&lt;/p&gt;\n&lt;p&gt;NOTE: the reason to not wrap &lt;code&gt;\\&lt;/code&gt; in a bracket expression is that if you were using a tool that accepts &lt;code&gt;[\\]]&lt;/code&gt; as a literal &lt;code&gt;]&lt;/code&gt; inside a bracket expression (e.g. perl and most awk implementations) to do the actual final substitution (i.e. instead of &lt;code&gt;sed &quot;s/$escOld/$escNew/g&quot;&lt;/code&gt;) then you couldn&apos;t use the approach of:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;sed &lt;span class=&quot;hljs-string&quot;&gt;&apos;s/[^^]/[&amp;amp;]/g; s/\\^/\\\\^/g&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;to escape &lt;code&gt;\\&lt;/code&gt; by enclosing it in &lt;code&gt;[]&lt;/code&gt; because then &lt;code&gt;\\x&lt;/code&gt; would become &lt;code&gt;[\\][x]&lt;/code&gt; which means &lt;code&gt;\\ or ] or [ or x&lt;/code&gt;. Instead you&apos;d need:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;sed &lt;span class=&quot;hljs-string&quot;&gt;&apos;s/[^^\\\\]/[&amp;amp;]/g; s/\\^/\\\\^/g; s/\\\\/\\\\\\\\/g&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;So while &lt;code&gt;[\\]&lt;/code&gt; is probably OK for all current sed implementations, we know that &lt;code&gt;\\\\&lt;/code&gt; will work for all sed, awk, perl, etc. implementations and so use that form of escaping.&lt;/p&gt;\n    ","\n&lt;p&gt;It should be noted that the regular expression used in some answers above among &lt;a href=&quot;https://stackoverflow.com/a/29626460/6646161&quot;&gt;this&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/a/29613573/6646161&quot;&gt;that one&lt;/a&gt;:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&apos;s/[^^\\\\]/[&amp;amp;]/g; s/\\^/\\\\^/g; s/\\\\/\\\\\\\\/g&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;seems to be wrong:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Doing first &lt;code&gt;s/\\^/\\\\^/g&lt;/code&gt; followed by &lt;code&gt;s/\\\\/\\\\\\\\/g&lt;/code&gt; is an error, as any &lt;code&gt;^&lt;/code&gt; escaped first to &lt;code&gt;\\^&lt;/code&gt; will then have its &lt;code&gt;\\&lt;/code&gt; escaped again.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;A better way seems to be: &lt;code&gt;&apos;s/[^\\^]/[&amp;amp;]/g; s/[\\^]/\\\\&amp;amp;/g;&apos;&lt;/code&gt;.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;[^^\\\\]&lt;/code&gt; with sed (BRE/ERE) should be just &lt;code&gt;[^\\^]&lt;/code&gt; (or &lt;code&gt;[^^\\]&lt;/code&gt;). &lt;code&gt;\\&lt;/code&gt; has no special meaning inside a bracket expression and needs not to be quoted.&lt;/li&gt;\n&lt;/ul&gt;\n    "],"comment":["\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Barmar Yes. It is just theoretical.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/171318/hek2mgl&quot; title=&quot;143,764 reputation&quot; class=&quot;comment-user owner&quot;&gt;hek2mgl&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment47372195_29613304&quot;&gt;&lt;span title=&quot;2015-04-13 19:22:22Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 13, 2015 at 19:22&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@hek2mgl What do you want &lt;code&gt;\\n&lt;/code&gt; in the input search string to match? For it to match a literal &lt;code&gt;\\n&lt;/code&gt; in the file it needs to be &lt;code&gt;\\\\n&lt;/code&gt; in the pattern (which is what &lt;code&gt;printf&lt;/code&gt; does).&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/258523/etan-reisner&quot; title=&quot;73,852 reputation&quot; class=&quot;comment-user&quot;&gt;Etan Reisner&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment47373179_29613304&quot;&gt;&lt;span title=&quot;2015-04-13 19:51:48Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 13, 2015 at 19:51&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@EdMorton &lt;code&gt;it should be treated a literal backslash followed by a literal n&lt;/code&gt; - yes, I meant this.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/171318/hek2mgl&quot; title=&quot;143,764 reputation&quot; class=&quot;comment-user owner&quot;&gt;hek2mgl&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment47373522_29613304&quot;&gt;&lt;span title=&quot;2015-04-13 20:02:01Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 13, 2015 at 20:02&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;don&apos;t forget that there are several standard regex used depending the sed version and option.In this case, some escaped character become regex special meaning for other version like the &lt;code&gt;{&lt;/code&gt; or &lt;code&gt;(&lt;/code&gt; between posix and gnu native.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/2885763/neronlevelu&quot; title=&quot;9,602 reputation&quot; class=&quot;comment-user&quot;&gt;NeronLeVelu&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment47384018_29613304&quot;&gt;&lt;span title=&quot;2015-04-14 05:41:37Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 14, 2015 at 5:41&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;For the LHS if you don&apos;t know what data will show up its best to pay attention to the delimiters, the answers I see still use slash but a slash is somewhat common, you can use a non-printable character like &lt;code&gt;SOH \\001&lt;/code&gt; - see my answer to another question that uses this here:   &lt;a href=&quot;http://stackoverflow.com/a/29238669/4401178&quot;&gt;stackoverflow.com/a/29238669/4401178&lt;/a&gt; On the RHS there is no perfect solution that I know of but you can scan the string quickly and find a unique replacement value at runtime, you can see this technique here:  &lt;a href=&quot;https://github.com/AdamDanischewski/r-n-f-bash-rename-script&quot; rel=&quot;nofollow noreferrer&quot;&gt;github.com/AdamDanischewski/r-n-f-bash-rename-script&lt;/a&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;span class=&quot;comment-user&quot;&gt;user4401178&lt;/span&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment47411004_29613304&quot;&gt;&lt;span title=&quot;2015-04-14 18:04:47Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 14, 2015 at 18:04&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 2 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;FWIW, newer &lt;code&gt;sed&lt;/code&gt; allow &lt;code&gt;sed -z&lt;/code&gt; to match NUL separated lines, so the matches can include &lt;code&gt;\\n&lt;/code&gt;.  Example use:  &lt;code&gt;find -print0 | sed -z ... | xargs --null script&lt;/code&gt; etc.  Multiline regex with &lt;code&gt;\\n&lt;/code&gt; come in very handy, as Linux (or Ubuntu for Windows) allows linefeeds in filenames (like: &lt;code&gt;echo help me world &amp;gt; $&apos;\\n\\nminime\\nwas here\\n&apos;&lt;/code&gt;)&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/490291/tino&quot; title=&quot;8,621 reputation&quot; class=&quot;comment-user&quot;&gt;Tino&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment81989854_29613573&quot;&gt;&lt;span title=&quot;2017-11-27 17:49:45Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Nov 27, 2017 at 17:49&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Thanks, @ChristianBongiorno. I don&apos;t quite understand the use case you&apos;re describing, however; are you talking about keyboard macros defined with &lt;code&gt;bind&lt;/code&gt;? How does echoing values come into play? Can you give an example?&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/45375/mklement0&quot; title=&quot;317,460 reputation&quot; class=&quot;comment-user&quot;&gt;mklement0&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment88621312_29613573&quot;&gt;&lt;span title=&quot;2018-06-12 00:40:27Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 12, 2018 at 0:40&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Tino: Thanks, I&apos;ve added a &lt;code&gt;-z&lt;/code&gt;-based variant to the answer, but note that it&apos;s not about older or newer per se, it&apos;s about &lt;i&gt;GNU&lt;/i&gt; &lt;code&gt;sed&lt;/code&gt;, which defines &lt;code&gt;-z&lt;/code&gt; as a nonstandard option, vs. other &lt;code&gt;sed&lt;/code&gt; implementations, such as the &lt;i&gt;BSD&lt;/i&gt; &lt;code&gt;sed&lt;/code&gt; found on macOS, which do not.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/45375/mklement0&quot; title=&quot;317,460 reputation&quot; class=&quot;comment-user&quot;&gt;mklement0&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment88653837_29613573&quot;&gt;&lt;span title=&quot;2018-06-12 19:24:56Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 12, 2018 at 19:24&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@ChristianBongiorno: Thanks for the explanation, but I still don&apos;t get it, unfortunately; I&apos;m curious, however: how about asking a new question focused on this aspect?&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/45375/mklement0&quot; title=&quot;317,460 reputation&quot; class=&quot;comment-user&quot;&gt;mklement0&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment88691124_29613573&quot;&gt;&lt;span title=&quot;2018-06-13 18:20:47Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 13, 2018 at 18:20&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;This is an excellent answer. In my case, I needed to escape the string for input to sed, and need it to work in POSIX sh (not bash), so I ended up with: &lt;code&gt;fixed=`printf &apos;%s\\n&apos; &quot;${val}&quot; |\tsed &apos;s#\\/#\\\\\\/#g&apos; | sed\t&apos;s/\\&amp;amp;/\\\\\\&amp;amp;/g&apos; `&lt;/code&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/3063727/mike&quot; title=&quot;333 reputation&quot; class=&quot;comment-user&quot;&gt;mike&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment100358173_29613573&quot;&gt;&lt;span title=&quot;2019-07-05 16:49:50Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Jul 5, 2019 at 16:49&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 2 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        "],"id":563,"title":"Is it possible to escape regex metacharacters reliably with sed","content":"\n                \n&lt;p&gt;I&apos;m wondering whether it is possible to write a 100% reliable &lt;code&gt;sed&lt;/code&gt; command to escape any regex metacharacters in an input string so that it can be used in a subsequent sed command. Like this:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#!/bin/bash&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;# Trying to replace one regex by another in an input file with sed&lt;/span&gt;\n\nsearch=&lt;span class=&quot;hljs-string&quot;&gt;&quot;/abc\\n\\t[a-z]\\+\\([^ ]\\)\\{2,3\\}\\3&quot;&lt;/span&gt;\nreplace=&lt;span class=&quot;hljs-string&quot;&gt;&quot;/xyz\\n\\t[0-9]\\+\\([^ ]\\)\\{2,3\\}\\3&quot;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# Sanitize input&lt;/span&gt;\nsearch=$(sed &lt;span class=&quot;hljs-string&quot;&gt;&apos;script to escape&apos;&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$search&lt;/span&gt;&quot;&lt;/span&gt;)\nreplace=$(sed &lt;span class=&quot;hljs-string&quot;&gt;&apos;script to escape&apos;&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$replace&lt;/span&gt;&quot;&lt;/span&gt;)\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# Use it in a sed command&lt;/span&gt;\nsed &lt;span class=&quot;hljs-string&quot;&gt;&quot;s/&lt;span class=&quot;hljs-variable&quot;&gt;$search&lt;/span&gt;/&lt;span class=&quot;hljs-variable&quot;&gt;$replace&lt;/span&gt;/&quot;&lt;/span&gt; input\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I know that there are better tools to work with fixed strings instead of patterns, for example &lt;code&gt;awk&lt;/code&gt;, &lt;code&gt;perl&lt;/code&gt; or &lt;code&gt;python&lt;/code&gt;. I would just like to prove whether it is possible or not with &lt;code&gt;sed&lt;/code&gt;. I would say let&apos;s concentrate on basic POSIX regexes to have even more fun! :)&lt;/p&gt;\n\n&lt;p&gt;I have tried a lot of things but anytime I could find an input which broke my attempt. I thought keeping it abstract as &lt;code&gt;script to escape&lt;/code&gt; would not lead anybody into the wrong direction.&lt;/p&gt;\n\n&lt;p&gt;Btw, the discussion came up &lt;a href=&quot;https://stackoverflow.com/questions/29606527/sed-replace-multiple-patterns-but-not-with-the-same-string/29609706?noredirect=1#comment47365660_29609706&quot;&gt;here&lt;/a&gt;. I thought this could be a good place to collect solutions and probably break and/or elaborate them.&lt;/p&gt;\n    ","slug":"is-it-possible-to-escape-regex-metacharacters-reliably-with-sed-1657388428795","postType":"QUESTION","createdAt":"2022-07-09T17:40:28.000Z","updatedAt":"2022-07-09T17:40:28.000Z","tags":[{"id":2721,"name":"sed","slug":"sed","createdAt":"2022-07-09T17:40:28.000Z","updatedAt":"2022-07-09T17:40:28.000Z","Questions_Tags":{"questionId":563,"tagId":2721}}]}]}},"__N_SSG":true}