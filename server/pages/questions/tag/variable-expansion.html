<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2eccd4d47c856f2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2eccd4d47c856f2b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/81-301f760ac8107464.js" defer=""></script><script src="/_next/static/chunks/pages/questions/tag/%5Bslug%5D-6802ea06aeddcbec.js" defer=""></script><script src="/_next/static/B9ZMQqRLGvIP-RcWN9dT2/_buildManifest.js" defer=""></script><script src="/_next/static/B9ZMQqRLGvIP-RcWN9dT2/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5"></style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="https://flowbite.com/docs/images/logo.svg" class="mr-3 h-6 sm:h-9" alt="Flowbite Logo"/><span class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Hunter</span></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/tag/variable-expansion#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="flex items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/how-does-the-windows-command-interpreter-(cmd.exe)-parse-scripts-1657387731560">How does the Windows Command Interpreter (CMD.EXE) parse scripts?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/variable-expansion">variable-expansion</a></div></div><div class="mt-4 mb-6" style="height:100px;overflow:auto"><h4 class="font-semibold">Solution 1:</h4><div class="text-sm bg-green-100 text-neutral-600">
<p>We performed experiments to investigate the grammar of batch scripts. We also investigated differences between batch and command line mode.</p>
<h2>Batch Line Parser:</h2>
<p>Here is a brief overview of phases in the batch file line parser:</p>
<p><strong>Phase 0) Read Line:</strong></p>
<p><strong>Phase 1) Percent Expansion:</strong></p>
<p><strong>Phase 2) Process special characters, tokenize, and build a cached command block:</strong> This is a complex process that is affected by things such as quotes, special characters, token delimiters, and caret escapes.</p>
<p><strong>Phase 3) Echo the parsed command(s)</strong> Only if the command block did not begin with <code>@</code>, and ECHO was ON at the start of the preceding step.</p>
<p><strong>Phase 4) FOR <code>%X</code> variable expansion:</strong> Only if a FOR command is active and the commands after DO are being processed.</p>
<p><strong>Phase 5) Delayed Expansion:</strong> Only if delayed expansion is enabled</p>
<p><strong>Phase 5.3) Pipe processing:</strong> Only if commands are on either side of a pipe</p>
<p><strong>Phase 5.5) Execute Redirection:</strong></p>
<p><strong>Phase 6) CALL processing/Caret doubling:</strong> Only if the command token is CALL</p>
<p><strong>Phase 7) Execute:</strong> The command is executed
<br></p>
<hr>
<p>Here are details for each phase:</p>
<p>Note that the phases described below are only a model of how the batch parser works. The actual cmd.exe internals may not reflect these phases. But this model is effective at predicting behavior of batch scripts.</p>
<p><strong>Phase 0) Read Line:</strong> Read line of input through first <code>&lt;LF&gt;</code>.</p>
<ul>
<li>When reading a line to be parsed as a command, <code>&lt;Ctrl-Z&gt;</code> (0x1A) is read as <code>&lt;LF&gt;</code> (LineFeed 0x0A)</li>
<li>When GOTO or CALL reads lines while scanning for a :label, <code>&lt;Ctrl-Z&gt;</code>, is treated as itself - it is <em><strong>not</strong></em> converted to <code>&lt;LF&gt;</code></li>
</ul>
<p><strong>Phase 1) Percent Expansion:</strong></p>
<ul>
<li>A double <code>%%</code> is replaced by a single <code>%</code></li>
<li>Expansion of arguments (<code>%*</code>, <code>%1</code>, <code>%2</code>, etc.)</li>
<li>Expansion of <code>%var%</code>, if var does not exist replace it with nothing</li>
<li>Line is truncated at first <code>&lt;LF&gt;</code> not within <code>%var%</code> expansion</li>
<li><em>For a complete explanation read the first half of this from dbenham <a href="https://stackoverflow.com/a/7970912/1012053">Same thread: Percent Phase</a></em></li>
</ul>
<p><strong>Phase 2) Process special characters, tokenize, and build a cached command block:</strong> This is a complex process that is affected by things such as quotes, special characters, token delimiters, and caret escapes. What follows is an approximation of this process.</p>
<p>There are concepts that are important throughout this phase.</p>
<ul>
<li>A token is simply a string of characters that is treated as a unit.</li>
<li>Tokens are separated by token delimiters. The standard token delimiters are <code>&lt;space&gt;</code> <code>&lt;tab&gt;</code> <code>;</code> <code>,</code> <code>=</code> <code>&lt;0x0B&gt;</code> <code>&lt;0x0C&gt;</code> and <code>&lt;0xFF&gt;</code><br>
Consecutive token delimiters are treated as one - there are no empty tokens between token delimiters</li>
<li>There are no token delimiters within a quoted string. The entire quoted string is always treated as part of a single token. A single token may consist of a combination of quoted strings and unquoted characters.</li>
</ul>
<p>The following characters may have special meaning in this phase, depending on context: <code>&lt;CR&gt;</code> <code>^</code> <code>(</code> <code>@</code> <code>&amp;</code> <code>|</code> <code>&lt;</code> <code>&gt;</code> <code>&lt;LF&gt;</code> <code>&lt;space&gt;</code> <code>&lt;tab&gt;</code> <code>;</code> <code>,</code> <code>=</code> <code>&lt;0x0B&gt;</code> <code>&lt;0x0C&gt;</code> <code>&lt;0xFF&gt;</code></p>
<p>Look at each character from left to right:</p>
<ul>
<li>If <code>&lt;CR&gt;</code> then remove it, as if it were never there (except for weird <a href="https://www.dostips.com/forum/viewtopic.php?t=9429" rel="noreferrer">redirection behavior</a>)</li>
<li>If a caret (<code>^</code>), the next character is escaped, and the escaping caret is removed. Escaped characters lose all special meaning (except for <code>&lt;LF&gt;</code>).</li>
<li>If a quote (<code>"</code>), toggle the quote flag. If the quote flag is active, then only <code>"</code> and <code>&lt;LF&gt;</code> are special. All other characters lose their special meaning until the next quote toggles the quote flag off. It is not possible to escape the closing quote. All quoted characters are always within the same token.</li>
<li><code>&lt;LF&gt;</code> always turns off the quote flag. Other behaviors vary depending on context, but quotes never alter the behavior of <code>&lt;LF&gt;</code>.
<ul>
<li>Escaped <code>&lt;LF&gt;</code>
<ul>
<li><code>&lt;LF&gt;</code> is stripped</li>
<li>The next character is escaped. If at the end of line buffer, then the next line is read and processed by phases 1 and 1.5 and appended to the current one before escaping the next character. If the next character is <code>&lt;LF&gt;</code>, then it is treated as a literal, meaning this process is not recursive.</li>
</ul>
</li>
<li>Unescaped <code>&lt;LF&gt;</code> not within parentheses
<ul>
<li><code>&lt;LF&gt;</code> is stripped and parsing of the current line is terminated.</li>
<li>Any remaining characters in the line buffer are simply ignored.</li>
</ul>
</li>
<li>Unescaped <code>&lt;LF&gt;</code> within a FOR IN parenthesized block
<ul>
<li><code>&lt;LF&gt;</code> is converted into a <code>&lt;space&gt;</code></li>
<li>If at the end of the line buffer, then the next line is read and appended to the current one.</li>
</ul>
</li>
<li>Unescaped <code>&lt;LF&gt;</code> within a parenthesized command block
<ul>
<li><code>&lt;LF&gt;</code> is converted into <code>&lt;LF&gt;&lt;space&gt;</code>, and the <code>&lt;space&gt;</code> is treated as part of the next line of the command block.</li>
<li>If at the end of line buffer, then the next line is read and appended to the space.</li>
</ul>
</li>
</ul>
</li>
<li>If one of the special characters <code>&amp;</code> <code>|</code> <code>&lt;</code> or <code>&gt;</code>, split the line at this point in order to handle pipes, command concatenation, and redirection.
<ul>
<li>In the case of a pipe (<code>|</code>), each side is a separate command (or command block) that gets special handling in phase 5.3</li>
<li>In the case of <code>&amp;</code>, <code>&amp;&amp;</code>, or <code>||</code> command concatenation, each side of the concatenation is treated as a separate command.</li>
<li>In the case of <code>&lt;</code>, <code>&lt;&lt;</code>, <code>&gt;</code>, or <code>&gt;&gt;</code> redirection, the redirection clause is parsed, temporarily removed, and then appended to the end of the current command. A redirection clause consists of an optional file handle digit, the redirection operator, and the redirection destination token.
<ul>
<li>If the token that precedes the redirection operator is a single unescaped digit, then the digit specifies the file handle to be redirected. If the handle token is not found, then output redirection defaults to 1 (stdout), and input redirection defaults to 0 (stdin).</li>
</ul>
</li>
</ul>
</li>
<li>If the very first token for this command (prior to moving redirection to the end) begins with <code>@</code>, then the <code>@</code> has special meaning. (<code>@</code> is not special in any other context)
<ul>
<li>The special <code>@</code> is removed.</li>
<li>If ECHO is ON, then this command, along with any following concatenated commands on this line, are excluded from the phase 3 echo. If the <code>@</code> is before an opening <code>(</code>, then the entire parenthesized block is excluded from the phase 3 echo.</li>
</ul>
</li>
<li>Process parenthesis (provides for compound statements across multiple lines):
<ul>
<li>If the parser is not looking for a command token, then <code>(</code> is not special.</li>
<li>If the parser is looking for a command token and finds <code>(</code>, then start a new compound statement and increment the parenthesis counter</li>
<li>If the parenthesis counter is &gt; 0 then <code>)</code> terminates the compound statement and decrements the parenthesis counter.</li>
<li>If the line end is reached and the parenthesis counter is &gt; 0 then the next line will be appended to the compound statement (starts again with phase 0)</li>
<li>If the parenthesis counter is 0 and the parser is looking for a command, then <code>)</code> functions similar to a <code>REM</code> statement as long as it is immediately followed by a token delimiter, special character, newline, or end-of-file
<ul>
<li>All special characters lose their meaning except <code>^</code> (line concatenation is possible)</li>
<li>Once the end of the logical line is reached, the entire "command" is discarded.</li>
</ul>
</li>
</ul>
</li>
<li>Each command is parsed into a series of tokens. The first token is always treated as a command token (after special <code>@</code> have been stripped and redirection moved to the end).
<ul>
<li>Leading token delimiters prior to the command token are stripped</li>
<li>When parsing the command token, <code>(</code> functions as a command token delimiter, in addition to the standard token delimiters</li>
<li>The handling of subsequent tokens depends on the command.</li>
</ul>
</li>
<li>Most commands simply concatenate all arguments after the command token into a single argument token. All argument token delimiters are preserved. Argument options are typically not parsed until phase 7.</li>
<li>Three commands get special handling - IF, FOR, and REM
<ul>
<li>IF is split into two or three distinct parts that are processed independently. A syntax error in the IF construction will result in a fatal syntax error.
<ul>
<li>The comparison operation is the actual command that flows all the way through to phase 7
<ul>
<li>All IF options are fully parsed in phase 2.</li>
<li>Consecutive token delimiters collapse into a single space.</li>
<li>Depending on the comparison operator, there will be one or two value tokens that are identified.</li>
</ul>
</li>
<li>The True command block is the set of commands after the condition, and is parsed like any other command block. If ELSE is to be used, then the True block must be parenthesized.</li>
<li>The optional False command block is the set of commands after ELSE. Again, this command block is parsed normally.</li>
<li>The True and False command blocks do not automatically flow into the subsequent phases. Their subsequent processing is controled by phase 7.</li>
</ul>
</li>
<li>FOR is split in two after the DO. A syntax error in the FOR construction will result in a fatal syntax error.
<ul>
<li>The portion through DO is the actual FOR iteration command that flows all the way through phase 7
<ul>
<li>All FOR options are fully parsed in phase 2.</li>
<li>The IN parenthesized clause treats <code>&lt;LF&gt;</code> as <code>&lt;space&gt;</code>. After the IN clause is parsed, all tokens are concatenated together to form a single token.</li>
<li>Consecutive unescaped/unquoted token delimiters collapse into a single space throughout the FOR command through DO.</li>
</ul>
</li>
<li>The portion after DO is a command block that is parsed normally. Subsequent processing of the DO command block is controled by the iteration in phase 7.</li>
</ul>
</li>
<li>REM detected in phase 2 is treated dramatically different than all other commands.
<ul>
<li>Only one argument token is parsed - the parser ignores characters after the first argument token.</li>
<li>The REM command may appear in phase 3 output, but the command is never executed, and the original argument text is echoed - escaping carets are not removed, except...
<ul>
<li>If there is only one argument token that ends with an unescaped <code>^</code> that ends the line, then the argument token is thrown away, and the subsequent line is parsed and appended to the REM. This repeats until there is more than one token, or the last character is not <code>^</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>If the command token begins with <code>:</code>, and this is the first round of phase 2 (not a restart due to CALL in phase 6) then
<ul>
<li>The token is normally treated as an <em>Unexecuted Label</em>.
<ul>
<li>The remainder of the line is parsed, however <code>)</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&amp;</code> and <code>|</code> no longer have special meaning. The entire remainder of the line is considered to be part of the label "command".</li>
<li>The <code>^</code> continues to be special, meaning that line continuation can be used to append the subsequent line to the label.</li>
<li>An <em>Unexecuted Label</em> within a parenthesized block will result in a fatal syntax error unless it is immediately followed by a command or <em>Executed Label</em> on the next line.
<ul>
<li><code>(</code> no longer has special meaning for the first command that follows the <em>Unexecuted Label</em>.</li>
</ul>
</li>
<li>The command is aborted after label parsing is complete. Subsequent phases do not take place for the label</li>
</ul>
</li>
<li>There are three exceptions that can cause a label found in phase 2 to be treated as an <em>Executed Label</em> that continues parsing through phase 7.
<ul>
<li>There is redirection that precedes the label token, and there is a <code>|</code> pipe or <code>&amp;</code>, <code>&amp;&amp;</code>, or <code>||</code> command concatenation on the line.</li>
<li>There is redirection that precedes the label token, and the command is within a parenthesized block.</li>
<li>The label token is the very first command on a line within a parenthesized block, and the line above ended with an <em>Unexecuted Label</em>.</li>
</ul>
</li>
<li>The following occurs when an <em>Executed Label</em> is discovered in phase 2
<ul>
<li>The label, its arguments, and its redirection are all excluded from any echo output in phase 3</li>
<li>Any subsequent concatenated commands on the line are fully parsed and executed.</li>
</ul>
</li>
<li>For more information about <em>Executed Labels</em> vs. <em>Unexecuted Labels</em>, see <a href="https://www.dostips.com/forum/viewtopic.php?f=3&amp;t=3803&amp;p=55405#p55405" rel="noreferrer">https://www.dostips.com/forum/viewtopic.php?f=3&amp;t=3803&amp;p=55405#p55405</a></li>
</ul>
</li>
</ul>
<p><strong>Phase 3) Echo the parsed command(s)</strong> Only if the command block did not begin with <code>@</code>, and ECHO was ON at the start of the preceding step.</p>
<p><strong>Phase 4) FOR <code>%X</code> variable expansion:</strong> Only if a FOR command is active and the commands after DO are being processed.</p>
<ul>
<li>At this point, phase 1 of batch processing will have already converted a FOR variable like <code>%%X</code> into <code>%X</code>. The command line has different percent expansion rules for phase 1. This is the reason that command lines use <code>%X</code> but batch files use <code>%%X</code> for FOR variables.</li>
<li>FOR variable names are case sensitive, but <code>~modifiers</code> are not case sensitive.</li>
<li><code>~modifiers</code> take precedence over variable names. If a character following <code>~</code> is both a modifier and a valid FOR variable name, and there exists a subsequent character that is an active FOR variable name, then the character is interpreted as a modifier.</li>
<li>FOR variable names are global, but only within the context of a DO clause. If a routine is CALLed from within a FOR DO clause, then the FOR variables are not expanded within the CALLed routine. But if the routine has its own FOR command, then <em><strong>all</strong></em> currently defined FOR variables are accessible to the inner DO commands.</li>
<li>FOR variable names can be reused within nested FORs. The inner FOR value takes precedence, but once the INNER FOR closes, then the outer FOR value is restored.</li>
<li>If ECHO was ON at the start of this phase, then phase 3) is repeated to show the parsed DO commands after the FOR variables have been expanded.</li>
</ul>
<p><em><strong>---- From this point onward, each command identified in phase 2 is processed separately.<br>
---- Phases 5 through 7 are completed for one command before moving on to the next.</strong></em></p>
<p><strong>Phase 5) Delayed Expansion:</strong> Only if delayed expansion is on, the command is not in a <a href="https://stackoverflow.com/q/8192318/1012053">parenthesized block on either side of a pipe</a>, and the command is not a <a href="https://www.dostips.com/forum/viewtopic.php?f=3&amp;t=7761" rel="noreferrer">"naked" batch script</a> (script name without parentheses, CALL, command concatenation, or pipe).</p>
<ul>
<li>Each token for a command is parsed for delayed expansion independently.
<ul>
<li>Most commands parse two or more tokens - the command token, the arguments token, and each redirection destination token.</li>
<li>The FOR command parses the IN clause token only.</li>
<li>The IF command parses the comparison values only - either one or two, depending on the comparison operator.</li>
</ul>
</li>
<li>For each parsed token, first check if it contains any <code>!</code>. If not, then the token is not parsed - important for <code>^</code> characters.
If the token does contain <code>!</code>, then scan each character from left to right:
<ul>
<li>If it is a caret (<code>^</code>) the next character has no special meaning, the caret itself is removed</li>
<li>If it is an exclamation mark, search for the next exclamation mark (carets are not observed anymore), expand to the value of the variable.
<ul>
<li>Consecutive opening <code>!</code> are collapsed into a single <code>!</code></li>
<li>Any remaining unpaired <code>!</code> is removed</li>
</ul>
</li>
<li>Expanding vars at this stage is "safe", because special characters are not detected anymore (even <code>&lt;CR&gt;</code> or <code>&lt;LF&gt;</code>)</li>
<li><em>For a more complete explanation, read the 2nd half of this from dbenham
<a href="https://stackoverflow.com/a/7970912/1012053">same thread - Exclamation Point Phase</a></em></li>
</ul>
</li>
</ul>
<p><strong>Phase 5.3) Pipe processing:</strong> Only if commands are on either side of a pipe<br>
Each side of the pipe is processed independently and asynchronously.</p>
<ul>
<li>If command is internal to cmd.exe, or it is a batch file, or if it is a parenthesized command block, then it is executed in a new cmd.exe thread via <code>%comspec% /S /D /c" commandBlock"</code>, so the command block gets a phase restart, but this time in command line mode.
<ul>
<li>If a parenthesized command block, then all <code>&lt;LF&gt;</code> with a command before and after are converted to <code>&lt;space&gt;&amp;</code>. Other <code>&lt;LF&gt;</code> are stripped.</li>
</ul>
</li>
<li>This is the end of processing for the pipe commands.</li>
<li>See <a href="https://stackoverflow.com/q/8192318/1012053">Why does delayed expansion fail when inside a piped block of code?</a> for more about pipe parsing and processing</li>
</ul>
<p><strong>Phase 5.5) Execute Redirection:</strong> Any redirection that was discovered in phase 2 is now executed.</p>
<ul>
<li>The results of phases 4 and 5 can impact the redirection that was discovered in phase 2.</li>
<li>If the redirection fails, then the remainder of the command is aborted. <a href="https://stackoverflow.com/q/10354016/1012053">Note that failed redirection does not set ERRORLEVEL to 1 unless <code>||</code> is used</a>.</li>
</ul>
<p><strong>Phase 6) CALL processing/Caret doubling:</strong> Only if the command token is CALL, or if the text before the first occurring standard token delimiter is CALL. If CALL is parsed from a larger command token, then the unused portion is prepended to the arguments token before proceeding.</p>
<ul>
<li>Scan the arguments token for an unquoted <code>/?</code>. If found anywhere within the tokens, then abort phase 6 and proceed to Phase 7, where the HELP for CALL will be printed.</li>
<li>Remove the first <code>CALL</code>, so multiple CALL's can be stacked</li>
<li>Double all carets</li>
<li>Restart phases 1, 1.5, and 2, but do not continue to phase 3
<ul>
<li>Any doubled carets are reduced back to one caret as long as they are not quoted. But unfortunately, quoted carets remain doubled.</li>
<li>Phase 1 changes a bit
- Expansion errors in step 1.2 or 1.3 abort the CALL, but the error is not fatal - batch processing continues.</li>
<li>Phase 2 tasks are altered a bit
<ul>
<li>Any newly appearing unquoted, unescaped redirection that was not detected in the first round of phase 2 is detected, but it is removed (including the file name) without actually performing the redirection</li>
<li>Any newly appearing unquoted, unescaped caret at the end of the line is removed without performing line continuation</li>
<li>The CALL is aborted without error if any of the following are detected
<ul>
<li>Newly appearing unquoted, unescaped <code>&amp;</code> or <code>|</code></li>
<li>The resultant command token begins with unquoted, unescaped <code>(</code></li>
<li>The very first token after the removed CALL began with <code>@</code></li>
</ul>
</li>
<li>If the resultant command is a seemingly valid IF or FOR, then execution will subsequently fail with an error stating that <code>IF</code> or <code>FOR</code> is not recognized as an internal or external command.</li>
<li>Of course the CALL is not aborted in this 2nd round of phase 2 if the resultant command token is a label beginning with <code>:</code>.</li>
</ul>
</li>
</ul>
</li>
<li>If the resultant command token is CALL, then restart Phase 6 (repeats until no more CALL)</li>
<li>If the resultant command token is a batch script or a :label, then execution of the CALL is fully handled by the remainder of Phase 6.
<ul>
<li>Push the current batch script file position on the call stack so that execution can resume from the correct position when the CALL is completed.</li>
<li>Setup the %0, %1, %2, ...%N and %* argument tokens for the CALL, using all resultant tokens</li>
<li>If the command token is a label that begins with <code>:</code>, then
<ul>
<li>Restart Phase 5. This can impact what :label is CALLed. But since the %0 etc. tokens have already been setup, it will not alter the arguments that are passed to the CALLed routine.</li>
<li>Execute GOTO label to position the file pointer at the beginning of the subroutine (ignore any other tokens that may follow the :label) See Phase 7 for rules on how GOTO works.
<ul>
<li>If the :label token is missing, or the :label is not found, then the call stack is immediately popped to restore the saved file position, and the CALL is aborted.</li>
<li>If the :label happens to contain /?, then GOTO help is printed instead of searching for the :label. The file pointer does not move, such that code after the CALL is executed twice, once in the CALL context, and then again after the CALL return. See <a href="https://stackoverflow.com/q/31987023/1012053">Why CALL prints the GOTO help message in this script?And why command after that are executed twice?</a> for more info.</li>
</ul>
</li>
</ul>
</li>
<li>Else transfer control to the specified batch script.</li>
<li>Execution of the CALLed :label or script continues until either EXIT /B or end-of-file is reached, at which point the CALL stack is popped and execution resumes from the saved file position.<br>
Phase 7 is not executed for CALLed scripts or :labels.</li>
</ul>
</li>
<li>Else the result of phase 6 falls through into phase 7 for execution.</li>
</ul>
<p><strong>Phase 7) Execute:</strong> The command is executed</p>
<ul>
<li><strong>7.1 - Execute internal command</strong> - If the command token is quoted, then skip this step. Otherwise, attempt to parse out an internal command and execute.
<ul>
<li>The following tests are made to determine if an unquoted command token represents an internal command:
<ul>
<li>If the command token exactly matches an internal command, then execute it.</li>
<li>Else break the command token before the first occurrence of <code>+</code> <code>/</code> <code>[</code> <code>]</code> <code>&lt;space&gt;</code> <code>&lt;tab&gt;</code> <code>,</code> <code>;</code> or <code>=</code><br>
If the preceding text is an internal command, then remember that command
<ul>
<li>If in command line mode, or if the command is from a parenthesized block, IF true or false command block, FOR DO command block, or involved with command concatenation, then execute the internal command</li>
<li>Else (must be a stand-alone command in batch mode) scan the current folder and the PATH for a .COM, .EXE, .BAT, or .CMD file whose base name matches the original command token
<ul>
<li>If the first matching file is a .BAT or .CMD, then goto 7.3.exec and execute that script</li>
<li>Else (match not found or first match is .EXE or .COM) execute the remembered internal command</li>
</ul>
</li>
</ul>
</li>
<li>Else break the command token before the first occurrence of <code>.</code> <code>\</code> or <code>:</code><br>
If the preceding text is not an internal command, then goto 7.2<br>
Else the preceding text may be an internal command. Remember this command.</li>
<li>Break the command token before the first occurrence of <code>+</code> <code>/</code> <code>[</code> <code>]</code> <code>&lt;space&gt;</code> <code>&lt;tab&gt;</code> <code>,</code> <code>;</code> or <code>=</code><br>
If the preceding text is a path to an existing file, then goto 7.2<br>
Else execute the remembered internal command.</li>
</ul>
</li>
<li>If an internal command is parsed from a larger command token, then the unused portion of the command token is included in the argument list</li>
<li>Just because a command token is parsed as an internal command does not mean that it will execute successfully. Each internal command has its own rules as to how the arguments and options are parsed, and what syntax is allowed.</li>
<li>All internal commands will print help instead of performing their function if <code>/?</code> is detected. Most recognize <code>/?</code> if it appears anywhere in the arguments. But a few commands like ECHO and SET only print help if the first argument token begins with <code>/?</code>.</li>
<li>SET has some interesting semantics:
<ul>
<li>If a SET command has a quote before the variable name and extensions are enabled<br>
<code>set "name=content" ignored</code> <strong>--&gt;</strong> value=<code>content</code><br>
then the text between the first equal sign and the last quote is used as the content (first equal and last quote excluded). Text after the last quote is ignored. If there is no quote after the equal sign, then the rest of the line is used as content.</li>
<li>If a SET command does not have a quote before the name<br>
<code>set name="content" not ignored</code> <strong>--&gt;</strong> value=<code>"content" not ignored</code><br>
then the entire remainder of the line after the equal is used as content, including any and all quotes that may be present.</li>
</ul>
</li>
<li>An IF comparison is evaluated, and depending on whether the condition is true or false, the appropriate already parsed dependent command block is processed, starting with phase 5.</li>
<li>The IN clause of a FOR command is iterated appropriately.
<ul>
<li>If this is a FOR /F that iterates the output of a command block, then:
<ul>
<li>The IN clause is executed in a new cmd.exe process via CMD /C.</li>
<li>The command block must go through the entire parsing process a second time, but this time in a command line context</li>
<li>ECHO will start out ON, and delayed expansion will usually start out disabled (dependent on the registry setting)</li>
<li>All environment changes made by the IN clause command block will be lost once the child cmd.exe process terminates</li>
</ul>
</li>
<li>For each iteration:
<ul>
<li>The FOR variable values are defined</li>
<li>The already parsed DO command block is then processed, starting with phase 4.</li>
</ul>
</li>
</ul>
</li>
<li>GOTO uses the following logic to locate the :label
<ul>
<li>Parse the label from the first argument token</li>
<li>Scan for the next occurrence of the label
<ul>
<li>Start from the current file position</li>
<li>If end of file is reached, then loop back to the beginning of file and continue to the original starting point.</li>
</ul>
</li>
<li>The scan stops at the first occurrence of the label that it finds, and the file pointer is set to the line immediately following the label. Execution of the script resumes from that point. Note that a successful true GOTO will immediately abort any parsed block of code, including FOR loops.</li>
<li>If the label is not found, or the label token is missing, then the GOTO fails, an error message is printed, and the call stack is popped. This effectively functions as an EXIT /B, except any already parsed commands in the current command block that follow the GOTO are still executed, but in the context of the CALLer (the context that exists after EXIT /B)</li>
<li>See <a href="https://www.dostips.com/forum/viewtopic.php?t=3803" rel="noreferrer">https://www.dostips.com/forum/viewtopic.php?t=3803</a> for a more precise description of label parsing rules, and <a href="https://www.dostips.com/forum/viewtopic.php?t=8988" rel="noreferrer">https://www.dostips.com/forum/viewtopic.php?t=8988</a> for label scanning rules.</li>
</ul>
</li>
<li>RENAME and COPY both accept wildcards for the source and target paths. But Microsoft does a terrible job documenting how the wildcards work, especially for the target path. A useful set of wildcard rules may be found at <a href="https://superuser.com/q/475874/109090">How does the Windows RENAME command interpret wildcards?</a></li>
</ul>
</li>
<li><strong>7.2 - Execute volume change</strong> - Else if the command token does not begin with a quote, is exactly two characters long, and the 2nd character is a colon, then change the volume
<ul>
<li>All argument tokens are ignored</li>
<li>If the volume specified by the first character cannot be found, then abort with an error</li>
<li>A command token of <code>::</code> will always result in an error unless SUBST is used to define a volume for <code>::</code><br>
If SUBST is used to define a volume for <code>::</code>, then the volume will be changed, it will not be treated as a label.</li>
</ul>
</li>
<li><strong>7.3 - Execute external command</strong> - Else try to treat the command as an external command.
<ul>
<li>If in command line mode and the command is not quoted and does not begin with a volume specification, white-space, <code>,</code>, <code>;</code>, <code>=</code> or <code>+</code> then break the command token at the first occurrence of <code>&lt;space&gt;</code> <code>,</code> <code>;</code> or <code>=</code> and prepend the remainder to the argument token(s).</li>
<li>If the 2nd character of the command token is a colon, then verify the volume specified by the 1st character can be found.<br>
If the volume cannot be found, then abort with an error.</li>
<li>If in batch mode and the command token begins with <code>:</code>, then goto 7.4<br>
Note that if the label token begins with <code>::</code>, then this will not be reached because the preceding step will have aborted with an error unless SUBST is used to define a volume for <code>::</code>.</li>
<li>Identify the external command to execute.
<ul>
<li>This is a complex process that may involve the current volume, current directory, PATH variable, PATHEXT variable, and or file associations.</li>
<li>If a valid external command cannot be identified, then abort with an error.</li>
</ul>
</li>
<li>If in command line mode and the command token begins with <code>:</code>, then goto 7.4<br>
Note that this is rarely reached because the preceding step will have aborted with an error unless the command token begins with <code>::</code>, and SUBST is used to define a volume for <code>::</code>, and the entire command token is a valid path to an external command.</li>
<li><strong>7.3.exec</strong> - Execute the external command.</li>
</ul>
</li>
<li><strong>7.4 - Ignore a label</strong> - Ignore the command and all its arguments if the command token begins with <code>:</code>.<br>
Rules in 7.2 and 7.3 may prevent a label from reaching this point.</li>
</ul>
<hr>
<h2>Command Line Parser:</h2>
<p>Works like the BatchLine-Parser, except:</p>
<p><strong>Phase 1) Percent Expansion:</strong></p>
<ul>
<li>No <code>%*</code>, <code>%1</code> etc. argument expansion</li>
<li>If var is undefined, then <code>%var%</code> is left unchanged.</li>
<li>No special handling of <code>%%</code>. If var=content, then <code>%%var%%</code> expands to <code>%content%</code>.</li>
</ul>
<p><strong>Phase 3) Echo the parsed command(s)</strong></p>
<ul>
<li>This is not performed after phase 2. It is only performed after phase 4 for the FOR DO command block.</li>
</ul>
<p><strong>Phase 5) Delayed Expansion:</strong> only if DelayedExpansion is enabled</p>
<ul>
<li>If var is undefined, then <code>!var!</code> is left unchanged.</li>
</ul>
<p><strong>Phase 7) Execute Command</strong></p>
<ul>
<li>Attempts to CALL or GOTO a :label result in an error.</li>
<li>As already documented in phase 7, an executed label may result in an error under different scenarios.
<ul>
<li>Batch executed labels can only cause an error if they begin with <code>::</code></li>
<li>Command line executed labels almost always result in an error</li>
</ul>
</li>
</ul>
<hr>
<h2>Parsing of integer values</h2>
<p>There are many different contexts where cmd.exe parses integer values from strings, and the rules are inconsistent:</p>
<ul>
<li><code>SET /A</code></li>
<li><code>IF</code></li>
<li><code>%var:~n,m%</code> (variable substring expansion)</li>
<li><code>FOR /F "TOKENS=n"</code></li>
<li><code>FOR /F "SKIP=n"</code></li>
<li><code>FOR /L %%A in (n1 n2 n3)</code></li>
<li><code>EXIT [/B] n</code></li>
</ul>
<p>Details for these rules may be found at <a href="https://www.dostips.com/forum/viewtopic.php?t=3758" rel="noreferrer">Rules for how CMD.EXE parses numbers</a></p>
<hr>
<p>For anyone wishing to improve the cmd.exe parsing rules, there is a <a href="https://www.dostips.com/forum/viewtopic.php?f=3&amp;t=8355" rel="noreferrer">discussion topic on the DosTips forum</a> where issues can be reported and suggestions made.</p>
<p>Hope it helps<br>
Jan Erik (jeb) - Original author and discoverer of phases<br>
Dave Benham (dbenham) - Much additional content and editing</p>
    </div></div><div><div class="flex items-center justify-between text-slate-500"><div class="flex space-x-4 md:space-x-8"><div class="flex cursor-pointer items-center transition hover:text-slate-600"><svg xmlns="http://www.w3.org/2000/svg" class="mr-1.5 h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M14 10h4.764a2 2 0 011.789 2.894l-3.5 7A2 2 0 0115.263 21h-4.017c-.163 0-.326-.02-.485-.06L7 20m7-10V5a2 2 0 00-2-2h-.095c-.5 0-.905.405-.905.905 0 .714-.211 1.412-.608 2.006L7 11v9m7-10h-2M7 20H5a2 2 0 01-2-2v-6a2 2 0 012-2h2.5"></path></svg><span>4</span></div></div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"count":1,"rows":[{"answer":["\n\u0026lt;p\u0026gt;We performed experiments to investigate the grammar of batch scripts. We also investigated differences between batch and command line mode.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Batch Line Parser:\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Here is a brief overview of phases in the batch file line parser:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 0) Read Line:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 1) Percent Expansion:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 2) Process special characters, tokenize, and build a cached command block:\u0026lt;/strong\u0026gt; This is a complex process that is affected by things such as quotes, special characters, token delimiters, and caret escapes.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 3) Echo the parsed command(s)\u0026lt;/strong\u0026gt; Only if the command block did not begin with \u0026lt;code\u0026gt;@\u0026lt;/code\u0026gt;, and ECHO was ON at the start of the preceding step.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 4) FOR \u0026lt;code\u0026gt;%X\u0026lt;/code\u0026gt; variable expansion:\u0026lt;/strong\u0026gt; Only if a FOR command is active and the commands after DO are being processed.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 5) Delayed Expansion:\u0026lt;/strong\u0026gt; Only if delayed expansion is enabled\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 5.3) Pipe processing:\u0026lt;/strong\u0026gt; Only if commands are on either side of a pipe\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 5.5) Execute Redirection:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 6) CALL processing/Caret doubling:\u0026lt;/strong\u0026gt; Only if the command token is CALL\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 7) Execute:\u0026lt;/strong\u0026gt; The command is executed\n\u0026lt;br\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;Here are details for each phase:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Note that the phases described below are only a model of how the batch parser works. The actual cmd.exe internals may not reflect these phases. But this model is effective at predicting behavior of batch scripts.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 0) Read Line:\u0026lt;/strong\u0026gt; Read line of input through first \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;When reading a line to be parsed as a command, \u0026lt;code\u0026gt;\u0026amp;lt;Ctrl-Z\u0026amp;gt;\u0026lt;/code\u0026gt; (0x1A) is read as \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; (LineFeed 0x0A)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;When GOTO or CALL reads lines while scanning for a :label, \u0026lt;code\u0026gt;\u0026amp;lt;Ctrl-Z\u0026amp;gt;\u0026lt;/code\u0026gt;, is treated as itself - it is \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;not\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; converted to \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 1) Percent Expansion:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;A double \u0026lt;code\u0026gt;%%\u0026lt;/code\u0026gt; is replaced by a single \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Expansion of arguments (\u0026lt;code\u0026gt;%*\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;%1\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;%2\u0026lt;/code\u0026gt;, etc.)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Expansion of \u0026lt;code\u0026gt;%var%\u0026lt;/code\u0026gt;, if var does not exist replace it with nothing\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Line is truncated at first \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; not within \u0026lt;code\u0026gt;%var%\u0026lt;/code\u0026gt; expansion\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;em\u0026gt;For a complete explanation read the first half of this from dbenham \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/7970912/1012053\u0026quot;\u0026gt;Same thread: Percent Phase\u0026lt;/a\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 2) Process special characters, tokenize, and build a cached command block:\u0026lt;/strong\u0026gt; This is a complex process that is affected by things such as quotes, special characters, token delimiters, and caret escapes. What follows is an approximation of this process.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;There are concepts that are important throughout this phase.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;A token is simply a string of characters that is treated as a unit.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Tokens are separated by token delimiters. The standard token delimiters are \u0026lt;code\u0026gt;\u0026amp;lt;space\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;tab\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;,\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;=\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;0x0B\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;0x0C\u0026amp;gt;\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;\u0026amp;lt;0xFF\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;br\u0026gt;\nConsecutive token delimiters are treated as one - there are no empty tokens between token delimiters\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;There are no token delimiters within a quoted string. The entire quoted string is always treated as part of a single token. A single token may consist of a combination of quoted strings and unquoted characters.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;The following characters may have special meaning in this phase, depending on context: \u0026lt;code\u0026gt;\u0026amp;lt;CR\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;^\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;(\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;@\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;|\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;space\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;tab\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;,\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;=\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;0x0B\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;0x0C\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;0xFF\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Look at each character from left to right:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If \u0026lt;code\u0026gt;\u0026amp;lt;CR\u0026amp;gt;\u0026lt;/code\u0026gt; then remove it, as if it were never there (except for weird \u0026lt;a href=\u0026quot;https://www.dostips.com/forum/viewtopic.php?t=9429\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;redirection behavior\u0026lt;/a\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If a caret (\u0026lt;code\u0026gt;^\u0026lt;/code\u0026gt;), the next character is escaped, and the escaping caret is removed. Escaped characters lose all special meaning (except for \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt;).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If a quote (\u0026lt;code\u0026gt;\u0026quot;\u0026lt;/code\u0026gt;), toggle the quote flag. If the quote flag is active, then only \u0026lt;code\u0026gt;\u0026quot;\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; are special. All other characters lose their special meaning until the next quote toggles the quote flag off. It is not possible to escape the closing quote. All quoted characters are always within the same token.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; always turns off the quote flag. Other behaviors vary depending on context, but quotes never alter the behavior of \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt;.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Escaped \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; is stripped\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The next character is escaped. If at the end of line buffer, then the next line is read and processed by phases 1 and 1.5 and appended to the current one before escaping the next character. If the next character is \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt;, then it is treated as a literal, meaning this process is not recursive.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Unescaped \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; not within parentheses\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; is stripped and parsing of the current line is terminated.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Any remaining characters in the line buffer are simply ignored.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Unescaped \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; within a FOR IN parenthesized block\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; is converted into a \u0026lt;code\u0026gt;\u0026amp;lt;space\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If at the end of the line buffer, then the next line is read and appended to the current one.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Unescaped \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; within a parenthesized command block\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; is converted into \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026amp;lt;space\u0026amp;gt;\u0026lt;/code\u0026gt;, and the \u0026lt;code\u0026gt;\u0026amp;lt;space\u0026amp;gt;\u0026lt;/code\u0026gt; is treated as part of the next line of the command block.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If at the end of line buffer, then the next line is read and appended to the space.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If one of the special characters \u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;|\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt;, split the line at this point in order to handle pipes, command concatenation, and redirection.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;In the case of a pipe (\u0026lt;code\u0026gt;|\u0026lt;/code\u0026gt;), each side is a separate command (or command block) that gets special handling in phase 5.3\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;In the case of \u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026amp;amp;\u0026amp;amp;\u0026lt;/code\u0026gt;, or \u0026lt;code\u0026gt;||\u0026lt;/code\u0026gt; command concatenation, each side of the concatenation is treated as a separate command.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;In the case of \u0026lt;code\u0026gt;\u0026amp;lt;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026amp;lt;\u0026amp;lt;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt;, or \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; redirection, the redirection clause is parsed, temporarily removed, and then appended to the end of the current command. A redirection clause consists of an optional file handle digit, the redirection operator, and the redirection destination token.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If the token that precedes the redirection operator is a single unescaped digit, then the digit specifies the file handle to be redirected. If the handle token is not found, then output redirection defaults to 1 (stdout), and input redirection defaults to 0 (stdin).\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the very first token for this command (prior to moving redirection to the end) begins with \u0026lt;code\u0026gt;@\u0026lt;/code\u0026gt;, then the \u0026lt;code\u0026gt;@\u0026lt;/code\u0026gt; has special meaning. (\u0026lt;code\u0026gt;@\u0026lt;/code\u0026gt; is not special in any other context)\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;The special \u0026lt;code\u0026gt;@\u0026lt;/code\u0026gt; is removed.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If ECHO is ON, then this command, along with any following concatenated commands on this line, are excluded from the phase 3 echo. If the \u0026lt;code\u0026gt;@\u0026lt;/code\u0026gt; is before an opening \u0026lt;code\u0026gt;(\u0026lt;/code\u0026gt;, then the entire parenthesized block is excluded from the phase 3 echo.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Process parenthesis (provides for compound statements across multiple lines):\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If the parser is not looking for a command token, then \u0026lt;code\u0026gt;(\u0026lt;/code\u0026gt; is not special.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the parser is looking for a command token and finds \u0026lt;code\u0026gt;(\u0026lt;/code\u0026gt;, then start a new compound statement and increment the parenthesis counter\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the parenthesis counter is \u0026amp;gt; 0 then \u0026lt;code\u0026gt;)\u0026lt;/code\u0026gt; terminates the compound statement and decrements the parenthesis counter.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the line end is reached and the parenthesis counter is \u0026amp;gt; 0 then the next line will be appended to the compound statement (starts again with phase 0)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the parenthesis counter is 0 and the parser is looking for a command, then \u0026lt;code\u0026gt;)\u0026lt;/code\u0026gt; functions similar to a \u0026lt;code\u0026gt;REM\u0026lt;/code\u0026gt; statement as long as it is immediately followed by a token delimiter, special character, newline, or end-of-file\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;All special characters lose their meaning except \u0026lt;code\u0026gt;^\u0026lt;/code\u0026gt; (line concatenation is possible)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Once the end of the logical line is reached, the entire \u0026quot;command\u0026quot; is discarded.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Each command is parsed into a series of tokens. The first token is always treated as a command token (after special \u0026lt;code\u0026gt;@\u0026lt;/code\u0026gt; have been stripped and redirection moved to the end).\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Leading token delimiters prior to the command token are stripped\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;When parsing the command token, \u0026lt;code\u0026gt;(\u0026lt;/code\u0026gt; functions as a command token delimiter, in addition to the standard token delimiters\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The handling of subsequent tokens depends on the command.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Most commands simply concatenate all arguments after the command token into a single argument token. All argument token delimiters are preserved. Argument options are typically not parsed until phase 7.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Three commands get special handling - IF, FOR, and REM\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;IF is split into two or three distinct parts that are processed independently. A syntax error in the IF construction will result in a fatal syntax error.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;The comparison operation is the actual command that flows all the way through to phase 7\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;All IF options are fully parsed in phase 2.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Consecutive token delimiters collapse into a single space.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Depending on the comparison operator, there will be one or two value tokens that are identified.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The True command block is the set of commands after the condition, and is parsed like any other command block. If ELSE is to be used, then the True block must be parenthesized.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The optional False command block is the set of commands after ELSE. Again, this command block is parsed normally.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The True and False command blocks do not automatically flow into the subsequent phases. Their subsequent processing is controled by phase 7.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;FOR is split in two after the DO. A syntax error in the FOR construction will result in a fatal syntax error.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;The portion through DO is the actual FOR iteration command that flows all the way through phase 7\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;All FOR options are fully parsed in phase 2.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The IN parenthesized clause treats \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; as \u0026lt;code\u0026gt;\u0026amp;lt;space\u0026amp;gt;\u0026lt;/code\u0026gt;. After the IN clause is parsed, all tokens are concatenated together to form a single token.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Consecutive unescaped/unquoted token delimiters collapse into a single space throughout the FOR command through DO.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The portion after DO is a command block that is parsed normally. Subsequent processing of the DO command block is controled by the iteration in phase 7.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;REM detected in phase 2 is treated dramatically different than all other commands.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Only one argument token is parsed - the parser ignores characters after the first argument token.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The REM command may appear in phase 3 output, but the command is never executed, and the original argument text is echoed - escaping carets are not removed, except...\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If there is only one argument token that ends with an unescaped \u0026lt;code\u0026gt;^\u0026lt;/code\u0026gt; that ends the line, then the argument token is thrown away, and the subsequent line is parsed and appended to the REM. This repeats until there is more than one token, or the last character is not \u0026lt;code\u0026gt;^\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the command token begins with \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt;, and this is the first round of phase 2 (not a restart due to CALL in phase 6) then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;The token is normally treated as an \u0026lt;em\u0026gt;Unexecuted Label\u0026lt;/em\u0026gt;.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;The remainder of the line is parsed, however \u0026lt;code\u0026gt;)\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026amp;lt;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;|\u0026lt;/code\u0026gt; no longer have special meaning. The entire remainder of the line is considered to be part of the label \u0026quot;command\u0026quot;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The \u0026lt;code\u0026gt;^\u0026lt;/code\u0026gt; continues to be special, meaning that line continuation can be used to append the subsequent line to the label.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;An \u0026lt;em\u0026gt;Unexecuted Label\u0026lt;/em\u0026gt; within a parenthesized block will result in a fatal syntax error unless it is immediately followed by a command or \u0026lt;em\u0026gt;Executed Label\u0026lt;/em\u0026gt; on the next line.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;(\u0026lt;/code\u0026gt; no longer has special meaning for the first command that follows the \u0026lt;em\u0026gt;Unexecuted Label\u0026lt;/em\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The command is aborted after label parsing is complete. Subsequent phases do not take place for the label\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;There are three exceptions that can cause a label found in phase 2 to be treated as an \u0026lt;em\u0026gt;Executed Label\u0026lt;/em\u0026gt; that continues parsing through phase 7.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;There is redirection that precedes the label token, and there is a \u0026lt;code\u0026gt;|\u0026lt;/code\u0026gt; pipe or \u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026amp;amp;\u0026amp;amp;\u0026lt;/code\u0026gt;, or \u0026lt;code\u0026gt;||\u0026lt;/code\u0026gt; command concatenation on the line.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;There is redirection that precedes the label token, and the command is within a parenthesized block.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The label token is the very first command on a line within a parenthesized block, and the line above ended with an \u0026lt;em\u0026gt;Unexecuted Label\u0026lt;/em\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The following occurs when an \u0026lt;em\u0026gt;Executed Label\u0026lt;/em\u0026gt; is discovered in phase 2\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;The label, its arguments, and its redirection are all excluded from any echo output in phase 3\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Any subsequent concatenated commands on the line are fully parsed and executed.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;For more information about \u0026lt;em\u0026gt;Executed Labels\u0026lt;/em\u0026gt; vs. \u0026lt;em\u0026gt;Unexecuted Labels\u0026lt;/em\u0026gt;, see \u0026lt;a href=\u0026quot;https://www.dostips.com/forum/viewtopic.php?f=3\u0026amp;amp;t=3803\u0026amp;amp;p=55405#p55405\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://www.dostips.com/forum/viewtopic.php?f=3\u0026amp;amp;t=3803\u0026amp;amp;p=55405#p55405\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 3) Echo the parsed command(s)\u0026lt;/strong\u0026gt; Only if the command block did not begin with \u0026lt;code\u0026gt;@\u0026lt;/code\u0026gt;, and ECHO was ON at the start of the preceding step.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 4) FOR \u0026lt;code\u0026gt;%X\u0026lt;/code\u0026gt; variable expansion:\u0026lt;/strong\u0026gt; Only if a FOR command is active and the commands after DO are being processed.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;At this point, phase 1 of batch processing will have already converted a FOR variable like \u0026lt;code\u0026gt;%%X\u0026lt;/code\u0026gt; into \u0026lt;code\u0026gt;%X\u0026lt;/code\u0026gt;. The command line has different percent expansion rules for phase 1. This is the reason that command lines use \u0026lt;code\u0026gt;%X\u0026lt;/code\u0026gt; but batch files use \u0026lt;code\u0026gt;%%X\u0026lt;/code\u0026gt; for FOR variables.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;FOR variable names are case sensitive, but \u0026lt;code\u0026gt;~modifiers\u0026lt;/code\u0026gt; are not case sensitive.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;~modifiers\u0026lt;/code\u0026gt; take precedence over variable names. If a character following \u0026lt;code\u0026gt;~\u0026lt;/code\u0026gt; is both a modifier and a valid FOR variable name, and there exists a subsequent character that is an active FOR variable name, then the character is interpreted as a modifier.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;FOR variable names are global, but only within the context of a DO clause. If a routine is CALLed from within a FOR DO clause, then the FOR variables are not expanded within the CALLed routine. But if the routine has its own FOR command, then \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;all\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; currently defined FOR variables are accessible to the inner DO commands.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;FOR variable names can be reused within nested FORs. The inner FOR value takes precedence, but once the INNER FOR closes, then the outer FOR value is restored.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If ECHO was ON at the start of this phase, then phase 3) is repeated to show the parsed DO commands after the FOR variables have been expanded.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;---- From this point onward, each command identified in phase 2 is processed separately.\u0026lt;br\u0026gt;\n---- Phases 5 through 7 are completed for one command before moving on to the next.\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 5) Delayed Expansion:\u0026lt;/strong\u0026gt; Only if delayed expansion is on, the command is not in a \u0026lt;a href=\u0026quot;https://stackoverflow.com/q/8192318/1012053\u0026quot;\u0026gt;parenthesized block on either side of a pipe\u0026lt;/a\u0026gt;, and the command is not a \u0026lt;a href=\u0026quot;https://www.dostips.com/forum/viewtopic.php?f=3\u0026amp;amp;t=7761\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026quot;naked\u0026quot; batch script\u0026lt;/a\u0026gt; (script name without parentheses, CALL, command concatenation, or pipe).\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Each token for a command is parsed for delayed expansion independently.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Most commands parse two or more tokens - the command token, the arguments token, and each redirection destination token.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The FOR command parses the IN clause token only.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The IF command parses the comparison values only - either one or two, depending on the comparison operator.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;For each parsed token, first check if it contains any \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt;. If not, then the token is not parsed - important for \u0026lt;code\u0026gt;^\u0026lt;/code\u0026gt; characters.\nIf the token does contain \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt;, then scan each character from left to right:\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If it is a caret (\u0026lt;code\u0026gt;^\u0026lt;/code\u0026gt;) the next character has no special meaning, the caret itself is removed\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If it is an exclamation mark, search for the next exclamation mark (carets are not observed anymore), expand to the value of the variable.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Consecutive opening \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt; are collapsed into a single \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Any remaining unpaired \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt; is removed\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Expanding vars at this stage is \u0026quot;safe\u0026quot;, because special characters are not detected anymore (even \u0026lt;code\u0026gt;\u0026amp;lt;CR\u0026amp;gt;\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;em\u0026gt;For a more complete explanation, read the 2nd half of this from dbenham\n\u0026lt;a href=\u0026quot;https://stackoverflow.com/a/7970912/1012053\u0026quot;\u0026gt;same thread - Exclamation Point Phase\u0026lt;/a\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 5.3) Pipe processing:\u0026lt;/strong\u0026gt; Only if commands are on either side of a pipe\u0026lt;br\u0026gt;\nEach side of the pipe is processed independently and asynchronously.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If command is internal to cmd.exe, or it is a batch file, or if it is a parenthesized command block, then it is executed in a new cmd.exe thread via \u0026lt;code\u0026gt;%comspec% /S /D /c\u0026quot; commandBlock\u0026quot;\u0026lt;/code\u0026gt;, so the command block gets a phase restart, but this time in command line mode.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If a parenthesized command block, then all \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; with a command before and after are converted to \u0026lt;code\u0026gt;\u0026amp;lt;space\u0026amp;gt;\u0026amp;amp;\u0026lt;/code\u0026gt;. Other \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; are stripped.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;This is the end of processing for the pipe commands.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;See \u0026lt;a href=\u0026quot;https://stackoverflow.com/q/8192318/1012053\u0026quot;\u0026gt;Why does delayed expansion fail when inside a piped block of code?\u0026lt;/a\u0026gt; for more about pipe parsing and processing\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 5.5) Execute Redirection:\u0026lt;/strong\u0026gt; Any redirection that was discovered in phase 2 is now executed.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;The results of phases 4 and 5 can impact the redirection that was discovered in phase 2.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the redirection fails, then the remainder of the command is aborted. \u0026lt;a href=\u0026quot;https://stackoverflow.com/q/10354016/1012053\u0026quot;\u0026gt;Note that failed redirection does not set ERRORLEVEL to 1 unless \u0026lt;code\u0026gt;||\u0026lt;/code\u0026gt; is used\u0026lt;/a\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 6) CALL processing/Caret doubling:\u0026lt;/strong\u0026gt; Only if the command token is CALL, or if the text before the first occurring standard token delimiter is CALL. If CALL is parsed from a larger command token, then the unused portion is prepended to the arguments token before proceeding.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Scan the arguments token for an unquoted \u0026lt;code\u0026gt;/?\u0026lt;/code\u0026gt;. If found anywhere within the tokens, then abort phase 6 and proceed to Phase 7, where the HELP for CALL will be printed.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Remove the first \u0026lt;code\u0026gt;CALL\u0026lt;/code\u0026gt;, so multiple CALL\u0026apos;s can be stacked\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Double all carets\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Restart phases 1, 1.5, and 2, but do not continue to phase 3\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Any doubled carets are reduced back to one caret as long as they are not quoted. But unfortunately, quoted carets remain doubled.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Phase 1 changes a bit\n- Expansion errors in step 1.2 or 1.3 abort the CALL, but the error is not fatal - batch processing continues.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Phase 2 tasks are altered a bit\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Any newly appearing unquoted, unescaped redirection that was not detected in the first round of phase 2 is detected, but it is removed (including the file name) without actually performing the redirection\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Any newly appearing unquoted, unescaped caret at the end of the line is removed without performing line continuation\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The CALL is aborted without error if any of the following are detected\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Newly appearing unquoted, unescaped \u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;|\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The resultant command token begins with unquoted, unescaped \u0026lt;code\u0026gt;(\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The very first token after the removed CALL began with \u0026lt;code\u0026gt;@\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the resultant command is a seemingly valid IF or FOR, then execution will subsequently fail with an error stating that \u0026lt;code\u0026gt;IF\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;FOR\u0026lt;/code\u0026gt; is not recognized as an internal or external command.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Of course the CALL is not aborted in this 2nd round of phase 2 if the resultant command token is a label beginning with \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the resultant command token is CALL, then restart Phase 6 (repeats until no more CALL)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the resultant command token is a batch script or a :label, then execution of the CALL is fully handled by the remainder of Phase 6.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Push the current batch script file position on the call stack so that execution can resume from the correct position when the CALL is completed.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Setup the %0, %1, %2, ...%N and %* argument tokens for the CALL, using all resultant tokens\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the command token is a label that begins with \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt;, then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Restart Phase 5. This can impact what :label is CALLed. But since the %0 etc. tokens have already been setup, it will not alter the arguments that are passed to the CALLed routine.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Execute GOTO label to position the file pointer at the beginning of the subroutine (ignore any other tokens that may follow the :label) See Phase 7 for rules on how GOTO works.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If the :label token is missing, or the :label is not found, then the call stack is immediately popped to restore the saved file position, and the CALL is aborted.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the :label happens to contain /?, then GOTO help is printed instead of searching for the :label. The file pointer does not move, such that code after the CALL is executed twice, once in the CALL context, and then again after the CALL return. See \u0026lt;a href=\u0026quot;https://stackoverflow.com/q/31987023/1012053\u0026quot;\u0026gt;Why CALL prints the GOTO help message in this script?And why command after that are executed twice?\u0026lt;/a\u0026gt; for more info.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else transfer control to the specified batch script.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Execution of the CALLed :label or script continues until either EXIT /B or end-of-file is reached, at which point the CALL stack is popped and execution resumes from the saved file position.\u0026lt;br\u0026gt;\nPhase 7 is not executed for CALLed scripts or :labels.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else the result of phase 6 falls through into phase 7 for execution.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 7) Execute:\u0026lt;/strong\u0026gt; The command is executed\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;7.1 - Execute internal command\u0026lt;/strong\u0026gt; - If the command token is quoted, then skip this step. Otherwise, attempt to parse out an internal command and execute.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;The following tests are made to determine if an unquoted command token represents an internal command:\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If the command token exactly matches an internal command, then execute it.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else break the command token before the first occurrence of \u0026lt;code\u0026gt;+\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;/\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;[\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;]\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;space\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;tab\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;,\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;;\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;=\u0026lt;/code\u0026gt;\u0026lt;br\u0026gt;\nIf the preceding text is an internal command, then remember that command\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If in command line mode, or if the command is from a parenthesized block, IF true or false command block, FOR DO command block, or involved with command concatenation, then execute the internal command\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else (must be a stand-alone command in batch mode) scan the current folder and the PATH for a .COM, .EXE, .BAT, or .CMD file whose base name matches the original command token\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If the first matching file is a .BAT or .CMD, then goto 7.3.exec and execute that script\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else (match not found or first match is .EXE or .COM) execute the remembered internal command\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else break the command token before the first occurrence of \u0026lt;code\u0026gt;.\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\\\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt;\u0026lt;br\u0026gt;\nIf the preceding text is not an internal command, then goto 7.2\u0026lt;br\u0026gt;\nElse the preceding text may be an internal command. Remember this command.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Break the command token before the first occurrence of \u0026lt;code\u0026gt;+\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;/\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;[\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;]\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;space\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;tab\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;,\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;;\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;=\u0026lt;/code\u0026gt;\u0026lt;br\u0026gt;\nIf the preceding text is a path to an existing file, then goto 7.2\u0026lt;br\u0026gt;\nElse execute the remembered internal command.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If an internal command is parsed from a larger command token, then the unused portion of the command token is included in the argument list\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Just because a command token is parsed as an internal command does not mean that it will execute successfully. Each internal command has its own rules as to how the arguments and options are parsed, and what syntax is allowed.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;All internal commands will print help instead of performing their function if \u0026lt;code\u0026gt;/?\u0026lt;/code\u0026gt; is detected. Most recognize \u0026lt;code\u0026gt;/?\u0026lt;/code\u0026gt; if it appears anywhere in the arguments. But a few commands like ECHO and SET only print help if the first argument token begins with \u0026lt;code\u0026gt;/?\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;SET has some interesting semantics:\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If a SET command has a quote before the variable name and extensions are enabled\u0026lt;br\u0026gt;\n\u0026lt;code\u0026gt;set \u0026quot;name=content\u0026quot; ignored\u0026lt;/code\u0026gt; \u0026lt;strong\u0026gt;--\u0026amp;gt;\u0026lt;/strong\u0026gt; value=\u0026lt;code\u0026gt;content\u0026lt;/code\u0026gt;\u0026lt;br\u0026gt;\nthen the text between the first equal sign and the last quote is used as the content (first equal and last quote excluded). Text after the last quote is ignored. If there is no quote after the equal sign, then the rest of the line is used as content.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If a SET command does not have a quote before the name\u0026lt;br\u0026gt;\n\u0026lt;code\u0026gt;set name=\u0026quot;content\u0026quot; not ignored\u0026lt;/code\u0026gt; \u0026lt;strong\u0026gt;--\u0026amp;gt;\u0026lt;/strong\u0026gt; value=\u0026lt;code\u0026gt;\u0026quot;content\u0026quot; not ignored\u0026lt;/code\u0026gt;\u0026lt;br\u0026gt;\nthen the entire remainder of the line after the equal is used as content, including any and all quotes that may be present.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;An IF comparison is evaluated, and depending on whether the condition is true or false, the appropriate already parsed dependent command block is processed, starting with phase 5.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The IN clause of a FOR command is iterated appropriately.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If this is a FOR /F that iterates the output of a command block, then:\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;The IN clause is executed in a new cmd.exe process via CMD /C.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The command block must go through the entire parsing process a second time, but this time in a command line context\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;ECHO will start out ON, and delayed expansion will usually start out disabled (dependent on the registry setting)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;All environment changes made by the IN clause command block will be lost once the child cmd.exe process terminates\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;For each iteration:\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;The FOR variable values are defined\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The already parsed DO command block is then processed, starting with phase 4.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;GOTO uses the following logic to locate the :label\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Parse the label from the first argument token\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Scan for the next occurrence of the label\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Start from the current file position\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If end of file is reached, then loop back to the beginning of file and continue to the original starting point.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The scan stops at the first occurrence of the label that it finds, and the file pointer is set to the line immediately following the label. Execution of the script resumes from that point. Note that a successful true GOTO will immediately abort any parsed block of code, including FOR loops.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the label is not found, or the label token is missing, then the GOTO fails, an error message is printed, and the call stack is popped. This effectively functions as an EXIT /B, except any already parsed commands in the current command block that follow the GOTO are still executed, but in the context of the CALLer (the context that exists after EXIT /B)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;See \u0026lt;a href=\u0026quot;https://www.dostips.com/forum/viewtopic.php?t=3803\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://www.dostips.com/forum/viewtopic.php?t=3803\u0026lt;/a\u0026gt; for a more precise description of label parsing rules, and \u0026lt;a href=\u0026quot;https://www.dostips.com/forum/viewtopic.php?t=8988\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://www.dostips.com/forum/viewtopic.php?t=8988\u0026lt;/a\u0026gt; for label scanning rules.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;RENAME and COPY both accept wildcards for the source and target paths. But Microsoft does a terrible job documenting how the wildcards work, especially for the target path. A useful set of wildcard rules may be found at \u0026lt;a href=\u0026quot;https://superuser.com/q/475874/109090\u0026quot;\u0026gt;How does the Windows RENAME command interpret wildcards?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;7.2 - Execute volume change\u0026lt;/strong\u0026gt; - Else if the command token does not begin with a quote, is exactly two characters long, and the 2nd character is a colon, then change the volume\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;All argument tokens are ignored\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the volume specified by the first character cannot be found, then abort with an error\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;A command token of \u0026lt;code\u0026gt;::\u0026lt;/code\u0026gt; will always result in an error unless SUBST is used to define a volume for \u0026lt;code\u0026gt;::\u0026lt;/code\u0026gt;\u0026lt;br\u0026gt;\nIf SUBST is used to define a volume for \u0026lt;code\u0026gt;::\u0026lt;/code\u0026gt;, then the volume will be changed, it will not be treated as a label.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;7.3 - Execute external command\u0026lt;/strong\u0026gt; - Else try to treat the command as an external command.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If in command line mode and the command is not quoted and does not begin with a volume specification, white-space, \u0026lt;code\u0026gt;,\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;=\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;+\u0026lt;/code\u0026gt; then break the command token at the first occurrence of \u0026lt;code\u0026gt;\u0026amp;lt;space\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;,\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;;\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;=\u0026lt;/code\u0026gt; and prepend the remainder to the argument token(s).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the 2nd character of the command token is a colon, then verify the volume specified by the 1st character can be found.\u0026lt;br\u0026gt;\nIf the volume cannot be found, then abort with an error.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If in batch mode and the command token begins with \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt;, then goto 7.4\u0026lt;br\u0026gt;\nNote that if the label token begins with \u0026lt;code\u0026gt;::\u0026lt;/code\u0026gt;, then this will not be reached because the preceding step will have aborted with an error unless SUBST is used to define a volume for \u0026lt;code\u0026gt;::\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Identify the external command to execute.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;This is a complex process that may involve the current volume, current directory, PATH variable, PATHEXT variable, and or file associations.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If a valid external command cannot be identified, then abort with an error.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If in command line mode and the command token begins with \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt;, then goto 7.4\u0026lt;br\u0026gt;\nNote that this is rarely reached because the preceding step will have aborted with an error unless the command token begins with \u0026lt;code\u0026gt;::\u0026lt;/code\u0026gt;, and SUBST is used to define a volume for \u0026lt;code\u0026gt;::\u0026lt;/code\u0026gt;, and the entire command token is a valid path to an external command.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;7.3.exec\u0026lt;/strong\u0026gt; - Execute the external command.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;7.4 - Ignore a label\u0026lt;/strong\u0026gt; - Ignore the command and all its arguments if the command token begins with \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt;.\u0026lt;br\u0026gt;\nRules in 7.2 and 7.3 may prevent a label from reaching this point.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;Command Line Parser:\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Works like the BatchLine-Parser, except:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 1) Percent Expansion:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;No \u0026lt;code\u0026gt;%*\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;%1\u0026lt;/code\u0026gt; etc. argument expansion\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If var is undefined, then \u0026lt;code\u0026gt;%var%\u0026lt;/code\u0026gt; is left unchanged.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;No special handling of \u0026lt;code\u0026gt;%%\u0026lt;/code\u0026gt;. If var=content, then \u0026lt;code\u0026gt;%%var%%\u0026lt;/code\u0026gt; expands to \u0026lt;code\u0026gt;%content%\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 3) Echo the parsed command(s)\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;This is not performed after phase 2. It is only performed after phase 4 for the FOR DO command block.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 5) Delayed Expansion:\u0026lt;/strong\u0026gt; only if DelayedExpansion is enabled\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If var is undefined, then \u0026lt;code\u0026gt;!var!\u0026lt;/code\u0026gt; is left unchanged.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 7) Execute Command\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Attempts to CALL or GOTO a :label result in an error.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;As already documented in phase 7, an executed label may result in an error under different scenarios.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Batch executed labels can only cause an error if they begin with \u0026lt;code\u0026gt;::\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Command line executed labels almost always result in an error\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;Parsing of integer values\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;There are many different contexts where cmd.exe parses integer values from strings, and the rules are inconsistent:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;SET /A\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;IF\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;%var:~n,m%\u0026lt;/code\u0026gt; (variable substring expansion)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;FOR /F \u0026quot;TOKENS=n\u0026quot;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;FOR /F \u0026quot;SKIP=n\u0026quot;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;FOR /L %%A in (n1 n2 n3)\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;EXIT [/B] n\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Details for these rules may be found at \u0026lt;a href=\u0026quot;https://www.dostips.com/forum/viewtopic.php?t=3758\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Rules for how CMD.EXE parses numbers\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;For anyone wishing to improve the cmd.exe parsing rules, there is a \u0026lt;a href=\u0026quot;https://www.dostips.com/forum/viewtopic.php?f=3\u0026amp;amp;t=8355\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;discussion topic on the DosTips forum\u0026lt;/a\u0026gt; where issues can be reported and suggestions made.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Hope it helps\u0026lt;br\u0026gt;\nJan Erik (jeb) - Original author and discoverer of phases\u0026lt;br\u0026gt;\nDave Benham (dbenham) - Much additional content and editing\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;When invoking a command from a command window, tokenization of the command line arguments is not done by \u0026lt;code\u0026gt;cmd.exe\u0026lt;/code\u0026gt; (a.k.a. \u0026quot;the shell\u0026quot;).  Most often the tokenization is done by the newly formed processes\u0026apos; C/C++ runtime, but this is not necessarily so -- for example, if the new process was not written in C/C++, or if the new process chooses to ignore \u0026lt;code\u0026gt;argv\u0026lt;/code\u0026gt; and process the raw commandline for itself (e.g. with \u0026lt;a href=\u0026quot;http://msdn.microsoft.com/en-us/library/windows/desktop/ms683156.aspx\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;GetCommandLine()\u0026lt;/a\u0026gt;).  At the OS level, Windows passes command lines untokenized as a single string to new processes.  This is in contrast to most *nix shells, where the shell tokenizes arguments in a consistent, predictable way before passing them to the newly formed process.  All this means that you may experience wildly divergent argument tokenization behavior across different programs on Windows, as individual programs often take argument tokenization into their own hands.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If it sounds like anarchy, it kind of is.  However, since a large number of Windows programs \u0026lt;em\u0026gt;do\u0026lt;/em\u0026gt; utilize the Microsoft C/C++ runtime\u0026apos;s \u0026lt;code\u0026gt;argv\u0026lt;/code\u0026gt;, it may be generally useful to understand \u0026lt;a href=\u0026quot;http://msdn.microsoft.com/en-us/library/a1y7w461.aspx\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;how the MSVCRT tokenizes\u0026lt;/a\u0026gt; arguments.  Here is an excerpt:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Arguments are delimited by white space, which is either a space or a tab.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;A string surrounded by double quotation marks is interpreted as a single argument, regardless of white space contained within. A quoted string can be embedded in an argument. Note that the caret (^) is not recognized as an escape character or delimiter.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;A double quotation mark preceded by a backslash, \\\u0026quot;, is interpreted as a literal double quotation mark (\u0026quot;).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Backslashes are interpreted literally, unless they immediately precede a double quotation mark.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If an even number of backslashes is followed by a double quotation mark, then one backslash () is placed in the argv array for every pair of backslashes (\\), and the double quotation mark (\u0026quot;) is interpreted as a string delimiter.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If an odd number of backslashes is followed by a double quotation mark, then one backslash () is placed in the argv array for every pair of backslashes (\\) and the double quotation mark is interpreted as an escape sequence by the remaining backslash, causing a literal double quotation mark (\u0026quot;) to be placed in argv.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;The Microsoft \u0026quot;batch language\u0026quot; (\u0026lt;code\u0026gt;.bat\u0026lt;/code\u0026gt;) is no exception to this anarchic environment, and it has developed its own unique rules for tokenization and escaping. It also looks like cmd.exe\u0026apos;s command prompt does do some preprocessing of the command line argument (mostly for variable substitution and escaping) before passing the argument off to the newly executing process.  You can read more about the low-level details of the batch language and cmd escaping in the excellent answers by jeb and dbenham on this page.  \u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Let\u0026apos;s build a simple command line utility in C and see what it says about your test cases:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* argv[])\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; argc; i++) {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;argv[%d][%s]\\n\u0026quot;\u0026lt;/span\u0026gt;, i, argv[i]);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;(Notes: argv[0] is always the name of the executable, and is omitted below for brevity.  Tested on Windows XP SP3. Compiled with Visual Studio 2005.)\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;\u0026amp;gt; test.exe \u0026quot;a \u0026quot;\u0026quot;b\u0026quot;\u0026quot; c\u0026quot;\nargv[1][a \u0026quot;b\u0026quot; c]\n\n\u0026amp;gt; test.exe \u0026quot;\u0026quot;\u0026quot;a b c\u0026quot;\u0026quot;\u0026quot;\nargv[1][\u0026quot;a b c\u0026quot;]\n\n\u0026amp;gt; test.exe \u0026quot;a\u0026quot;\u0026quot; b c\nargv[1][a\u0026quot; b c]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And a few of my own tests:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;\u0026amp;gt; test.exe a \u0026quot;b\u0026quot; c\nargv[1][a]\nargv[2][b]\nargv[3][c]\n\n\u0026amp;gt; test.exe a \u0026quot;b c\u0026quot; \u0026quot;d e\nargv[1][a]\nargv[2][b c]\nargv[3][d e]\n\n\u0026amp;gt; test.exe a \\\u0026quot;b\\\u0026quot; c\nargv[1][a]\nargv[2][\u0026quot;b\u0026quot;]\nargv[3][c]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;Percent Expansion Rules\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;Here is an expanded explanation of Phase 1 in \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/4095133/1012053\u0026quot;\u0026gt;jeb\u0026apos;s answer\u0026lt;/a\u0026gt; (valid for both batch mode and command line mode).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 1) Percent Expansion\u0026lt;/strong\u0026gt;\nStarting from left, scan each character for \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt;. If found then\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;1.05 (truncate line at \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt;)\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the character is \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Drop (ignore) the remainder of the line from the \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt; onward\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Goto Phase 2.0\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else the character must be \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt;, so proceed to 1.1\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;1.1 (escape \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt;)\u0026lt;/strong\u0026gt; \u0026lt;em\u0026gt;skipped if command line mode\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If batch mode and followed by another \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt; then\u0026lt;br\u0026gt;\nReplace \u0026lt;code\u0026gt;%%\u0026lt;/code\u0026gt; with single \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt; and continue scan\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;1.2 (expand argument)\u0026lt;/strong\u0026gt; \u0026lt;em\u0026gt;skipped if command line mode\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if batch mode then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If followed by \u0026lt;code\u0026gt;*\u0026lt;/code\u0026gt; and command extensions are enabled then\u0026lt;br\u0026gt;\nReplace \u0026lt;code\u0026gt;%*\u0026lt;/code\u0026gt; with the text of all command line arguments (Replace with nothing if there are no arguments) and continue scan.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if followed by \u0026lt;code\u0026gt;\u0026amp;lt;digit\u0026amp;gt;\u0026lt;/code\u0026gt; then\u0026lt;br\u0026gt;\nReplace \u0026lt;code\u0026gt;%\u0026amp;lt;digit\u0026amp;gt;\u0026lt;/code\u0026gt; with argument value (replace with nothing if undefined) and continue scan.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if followed by \u0026lt;code\u0026gt;~\u0026lt;/code\u0026gt; and command extensions are enabled then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If followed by optional valid list of argument modifiers followed by required \u0026lt;code\u0026gt;\u0026amp;lt;digit\u0026amp;gt;\u0026lt;/code\u0026gt; then\u0026lt;br\u0026gt;\nReplace \u0026lt;code\u0026gt;%~[modifiers]\u0026amp;lt;digit\u0026amp;gt;\u0026lt;/code\u0026gt; with modified argument value (replace with nothing if not defined or if specified $PATH: modifier is not defined) and continue scan.\u0026lt;br\u0026gt;\n\u0026lt;em\u0026gt;Note: modifiers are case insensitive and can appear multiple times in any order, except $PATH: modifier can only appear once and must be the last modifier before the \u0026lt;code\u0026gt;\u0026amp;lt;digit\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else invalid modified argument syntax raises \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;fatal error: All parsed commands are aborted, and batch processing aborts if in batch mode!\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;1.3 (expand variable)\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if command extensions are disabled then\u0026lt;br\u0026gt;\nLook at next string of characters, breaking before \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt; or end of buffer, and call them VAR (may be an empty list)\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If next character is \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt; then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If VAR is defined then\u0026lt;br\u0026gt;\nReplace \u0026lt;code\u0026gt;%VAR%\u0026lt;/code\u0026gt; with value of VAR and continue scan\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if batch mode then\u0026lt;br\u0026gt;\nRemove \u0026lt;code\u0026gt;%VAR%\u0026lt;/code\u0026gt; and continue scan\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else goto 1.4\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else goto 1.4\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if command extensions are enabled then\u0026lt;br\u0026gt;\nLook at next string of characters, breaking before \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt; or end of buffer, and call them VAR (may be an empty list). If VAR breaks before \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt; and the subsequent character is \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt; then include \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt; as the last character in VAR and break before \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt;.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If next character is \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt; then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If VAR is defined then\u0026lt;br\u0026gt;\nReplace \u0026lt;code\u0026gt;%VAR%\u0026lt;/code\u0026gt; with value of VAR and continue scan\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if batch mode then\u0026lt;br\u0026gt;\nRemove \u0026lt;code\u0026gt;%VAR%\u0026lt;/code\u0026gt; and continue scan\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else goto 1.4\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if next character is \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt; then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If VAR is undefined then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If batch mode then\u0026lt;br\u0026gt;\nRemove \u0026lt;code\u0026gt;%VAR:\u0026lt;/code\u0026gt; and continue scan.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else goto 1.4\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if next character is \u0026lt;code\u0026gt;~\u0026lt;/code\u0026gt; then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If next string of characters matches pattern of \u0026lt;code\u0026gt;[integer][,[integer]]%\u0026lt;/code\u0026gt; then\u0026lt;br\u0026gt;\nReplace \u0026lt;code\u0026gt;%VAR:~[integer][,[integer]]%\u0026lt;/code\u0026gt; with substring of value of VAR (possibly resulting in empty string) and continue scan.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else goto 1.4\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if followed by \u0026lt;code\u0026gt;=\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;*=\u0026lt;/code\u0026gt; then\u0026lt;br\u0026gt;\nInvalid variable search and replace syntax raises \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;fatal error: All parsed commands are aborted, and batch processing aborts if in batch mode!\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if next string of characters matches pattern of \u0026lt;code\u0026gt;[*]search=[replace]%\u0026lt;/code\u0026gt;, where search may include any set of characters except \u0026lt;code\u0026gt;=\u0026lt;/code\u0026gt;, and replace may include any set of characters except \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt;, then\u0026lt;br\u0026gt;\nReplace \u0026lt;code\u0026gt;%VAR:[*]search=[replace]%\u0026lt;/code\u0026gt; with value of VAR after performing search and replace (possibly resulting in empty string) and continue scan\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else goto 1.4\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;1.4 (strip %)\u0026lt;/strong\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Else If batch mode then\u0026lt;br\u0026gt;\nRemove \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt; and continue scan starting with the next character after the \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else preserve the leading \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt; and continue scan starting with the next character after the preserved leading \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;The above helps explain why this batch\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;@echo off\nsetlocal enableDelayedExpansion\nset \u0026quot;1var=varA\u0026quot;\nset \u0026quot;~f1var=varB\u0026quot;\ncall :test \u0026quot;arg1\u0026quot;\nexit /b  \n::\n:test \u0026quot;arg1\u0026quot;\necho %%1var%% = %1var%\necho ^^^!1var^^^! = !1var!\necho --------\necho %%~f1var%% = %~f1var%\necho ^^^!~f1var^^^! = !~f1var!\nexit /b\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Gives these results:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;%1var% = \u0026quot;arg1\u0026quot;var\n!1var! = varA\n--------\n%~f1var% = P:\\arg1var\n!~f1var! = varB\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;Note 1\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; - Phase 1 occurs prior to the recognition of REM statements. This is very important because it means even a remark can generate a fatal error if it has invalid argument expansion syntax or invalid variable search and replace syntax!\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;@echo off\nrem %~x This generates a fatal argument expansion error\necho this line is never reached\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;Note 2\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; - Another interesting consequence of the % parsing rules: Variables containing : in the name can be defined, but they cannot be expanded unless command extensions are disabled. There is one exception - a variable name containing a single colon at the end can be expanded while command extensions are enabled. However, you cannot perform substring or search and replace operations on variable names ending with a colon. The batch file below (courtesy of jeb) demonstrates this behavior\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;@echo off\nsetlocal\nset var=content\nset var:=Special\nset var::=double colon\nset var:~0,2=tricky\nset var::~0,2=unfortunate\necho %var%\necho %var:%\necho %var::%\necho %var:~0,2%\necho %var::~0,2%\necho Now with DisableExtensions\nsetlocal DisableExtensions\necho %var%\necho %var:%\necho %var::%\necho %var:~0,2%\necho %var::~0,2%\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;Note 3\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; - An interesting outcome of the order of the parsing rules that jeb lays out in his post: When performing find and replace with delayed expansion, special characters in both the find and replace terms must be escaped or quoted. But the situation is different for percent expansion - the find term must not be escaped (though it can be quoted). The percent replace string may or may not require escape or quote, depending on your intent.\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;@echo off\nsetlocal enableDelayedExpansion\nset \u0026quot;var=this \u0026amp;amp; that\u0026quot;\necho %var:\u0026amp;amp;=and%\necho \u0026quot;%var:\u0026amp;amp;=and%\u0026quot;\necho !var:^\u0026amp;amp;=and!\necho \u0026quot;!var:\u0026amp;amp;=and!\u0026quot;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;#Delayed Expansion Rules\nHere is an expanded, and more accurate explanation of Phase 5 in \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/4095133/1012053\u0026quot;\u0026gt;jeb\u0026apos;s answer\u0026lt;/a\u0026gt; (Valid for both batch mode and command line mode)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Phase 5) Delayed Expansion\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This phase is skipped if any of the following conditions apply:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Delayed expansion is disabled.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The command is within a parenthesized block on either side of a pipe.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The incoming command token is a \u0026quot;naked\u0026quot; batch script, meaning it is not associated with \u0026lt;code\u0026gt;CALL\u0026lt;/code\u0026gt;, parenthesized block, any form of command concatenation (\u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026amp;amp;\u0026amp;amp;\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;||\u0026lt;/code\u0026gt;), or a pipe \u0026lt;code\u0026gt;|\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;The delayed expansion process is applied to tokens independently. A command may have multiple tokens:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;The command token. For most commands the command name itself is a token. But a few commands have specialized regions that are considered a TOKEN for Phase 5.\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;for ... in(TOKEN) do\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;if defined TOKEN\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;if exists TOKEN\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;if errorlevel TOKEN\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;if cmdextversion TOKEN\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;if TOKEN comparison TOKEN\u0026lt;/code\u0026gt;, where comparison is one of \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;equ\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;neq\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;lss\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;leq\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;gtr\u0026lt;/code\u0026gt;, or \u0026lt;code\u0026gt;geq\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The arguments token\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The destination token of redirection (one per redirection)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;No change is made to tokens that do not contain \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For each token that does contain at least one \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt;, scan each character from left to right for \u0026lt;code\u0026gt;^\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt;, and if found, then\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;5.1 (caret escape)\u0026lt;/strong\u0026gt; Needed for \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;^\u0026lt;/code\u0026gt; literals\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If character is a caret \u0026lt;code\u0026gt;^\u0026lt;/code\u0026gt; then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Remove the \u0026lt;code\u0026gt;^\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Scan the next character and preserve it as a literal\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Continue the scan\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;5.2 (expand variable)\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If character is \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt;, then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If command extensions are disabled then\u0026lt;br\u0026gt;\nLook at next string of characters, breaking before \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt;, and call them VAR (may be an empty list)\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If next character is \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt; then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If VAR is defined, then\u0026lt;br\u0026gt;\nReplace \u0026lt;code\u0026gt;!VAR!\u0026lt;/code\u0026gt; with value of VAR and continue scan\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if batch mode then\u0026lt;br\u0026gt;\nRemove \u0026lt;code\u0026gt;!VAR!\u0026lt;/code\u0026gt; and continue scan\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else goto 5.2.1\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else goto 5.2.1\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if command extensions are enabled then\u0026lt;br\u0026gt;\nLook at next string of characters, breaking before \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt;, or \u0026lt;code\u0026gt;\u0026amp;lt;LF\u0026amp;gt;\u0026lt;/code\u0026gt;, and call them VAR (may be an empty list). If VAR breaks before \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt; and the subsequent character is \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt; then include \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt; as the last character in VAR and break before \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If next character is \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt; then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If VAR exists, then\u0026lt;br\u0026gt;\nReplace \u0026lt;code\u0026gt;!VAR!\u0026lt;/code\u0026gt; with value of VAR and continue scan\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if batch mode then\u0026lt;br\u0026gt;\nRemove \u0026lt;code\u0026gt;!VAR!\u0026lt;/code\u0026gt; and continue scan\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else goto 5.2.1\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if next character is \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt; then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If VAR is undefined then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If batch mode then\u0026lt;br\u0026gt;\nRemove \u0026lt;code\u0026gt;!VAR:\u0026lt;/code\u0026gt; and continue scan\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else goto 5.2.1\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if next character is \u0026lt;code\u0026gt;~\u0026lt;/code\u0026gt; then\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If next string of characters matches pattern of \u0026lt;code\u0026gt;[integer][,[integer]]!\u0026lt;/code\u0026gt; then Replace \u0026lt;code\u0026gt;!VAR:~[integer][,[integer]]!\u0026lt;/code\u0026gt; with substring of value of VAR (possibly resulting in empty string) and continue scan.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else goto 5.2.1\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else if next string of characters matches pattern of \u0026lt;code\u0026gt;[*]search=[replace]!\u0026lt;/code\u0026gt;, where search may include any set of characters except \u0026lt;code\u0026gt;=\u0026lt;/code\u0026gt;, and replace may include any set of characters except \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt;, then\u0026lt;br\u0026gt;\nReplace \u0026lt;code\u0026gt;!VAR:[*]search=[replace]!\u0026lt;/code\u0026gt; with value of VAR after performing search and replace (possibly resulting in an empty string) and continue scan\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else goto 5.2.1\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Else goto 5.2.1\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;5.2.1\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If batch mode then remove the leading \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt;\u0026lt;br\u0026gt;\nElse preserve the leading \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Continue the scan starting with the next character after the preserved leading \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As pointed out, commands are passed the entire argument string in Soft land, and it is up to them to parse this into separate arguments for their own use. There is no consistencty in this between different programs, and therefore there is no one set of rules to describe this process. You really need to check each corner case for whatever C library your program uses.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As far as the system \u0026lt;code\u0026gt;.bat\u0026lt;/code\u0026gt; files go, here is that test:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-sh s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;c\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt; args.cmd\n@\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; off\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; cmdcmdline:[%cmdcmdline%]\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; 0:[%0]\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; *:[%*]\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;set\u0026lt;/span\u0026gt; allargs=%*\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; not defined allargs goto :eof\nsetlocal\n@rem Wot about a \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;nice\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; loop?\n@rem Then we are \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; the land of delayedexpansion, !n!, call, etc.\n@rem Plays havoc with args like %t%, a\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;b etc. ugh!\nset n=1\n:loop\n    echo %n%:[%1]\n    set /a n+=1\n    shift\n    set param=%1\n    if defined param goto :loop\nendlocal\n\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now we can run some tests. See if you can figure out just what Soft are trying to do:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;C\u0026amp;gt;args a b c\ncmdcmdline:[cmd.exe ]\n0:[args]\n*:[a b c]\n1:[a]\n2:[b]\n3:[c]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Fine so far. (I\u0026apos;ll leave out the uninteresting \u0026lt;code\u0026gt;%cmdcmdline%\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;%0\u0026lt;/code\u0026gt; from now on.)\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;C\u0026amp;gt;args *.*\n*:[*.*]\n1:[*.*]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;No filename expansion.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;C\u0026amp;gt;args \u0026quot;a b\u0026quot; c\n*:[\u0026quot;a b\u0026quot; c]\n1:[\u0026quot;a b\u0026quot;]\n2:[c]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;No quote stripping, though quotes do prevent argument splitting.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;c\u0026amp;gt;args \u0026quot;\u0026quot;a b\u0026quot; c\n*:[\u0026quot;\u0026quot;a b\u0026quot; c]\n1:[\u0026quot;\u0026quot;a]\n2:[b\u0026quot; c]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Consecutive double quotes causes them to lose any special parsing abilities they may have had. @Beniot\u0026apos;s example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;C\u0026amp;gt;args \u0026quot;a \u0026quot;\u0026quot;\u0026quot; b \u0026quot;\u0026quot; c\u0026quot;\u0026quot;\u0026quot;\n*:[\u0026quot;a \u0026quot;\u0026quot;\u0026quot; b \u0026quot;\u0026quot; c\u0026quot;\u0026quot;\u0026quot;]\n1:[\u0026quot;a \u0026quot;\u0026quot;\u0026quot;]\n2:[b]\n3:[\u0026quot;\u0026quot;]\n4:[c\u0026quot;\u0026quot;\u0026quot;]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Quiz: How do you pass the value of any environment var as a \u0026lt;em\u0026gt;single\u0026lt;/em\u0026gt; argument (i.e., as \u0026lt;code\u0026gt;%1\u0026lt;/code\u0026gt;) to a bat file?\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;c\u0026amp;gt;set t=a \u0026quot;b c\nc\u0026amp;gt;set t\nt=a \u0026quot;b c\nc\u0026amp;gt;args %t%\n1:[a]\n2:[\u0026quot;b c]\nc\u0026amp;gt;args \u0026quot;%t%\u0026quot;\n1:[\u0026quot;a \u0026quot;b]\n2:[c\u0026quot;]\nc\u0026amp;gt;Aaaaaargh!\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Sane parsing seems forever broken.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For your entertainment, try adding miscellaneous \u0026lt;code\u0026gt;^\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\\\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026apos;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt; (\u0026amp;amp;c.) characters to these examples.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You have some great answers above already, but to answer one part of your question:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;set a =b, echo %a %b% c%  bb c%\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;What is happening there is that because you have a space before the =, a variable is created called \u0026lt;code\u0026gt;%a\u0026amp;lt;space\u0026amp;gt;%\u0026lt;/code\u0026gt;\nso when you \u0026lt;code\u0026gt;echo %a %\u0026lt;/code\u0026gt; that is evaluated correctly as \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The remaining part \u0026lt;code\u0026gt;b% c%\u0026lt;/code\u0026gt; is then evaluated as plain text + an undefined variable \u0026lt;code\u0026gt;% c%\u0026lt;/code\u0026gt;, which should be echoed as typed, for me \u0026lt;code\u0026gt;echo %a %b% c%\u0026lt;/code\u0026gt; returns \u0026lt;code\u0026gt;bb% c%\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I suspect that the ability to include spaces in variable names is more of an oversight than a planned \u0026apos;feature\u0026apos;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;\u0026lt;code\u0026gt;FOR\u0026lt;/code\u0026gt;-Loop Meta-Variable Expansion\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;This is an extended explanation of \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;Phase 4)\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; in the \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/4095133\u0026quot;\u0026gt;accepted answer\u0026lt;/a\u0026gt; (applicable for both batch file mode and command line mode). Of course a \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; command must be active. The following describes the processing of the command line portion after the \u0026lt;code\u0026gt;do\u0026lt;/code\u0026gt; clause. Note that in batch file mode, \u0026lt;code\u0026gt;%%\u0026lt;/code\u0026gt; has already been converted to \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt; due to the foregoing immediate \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt;-expansion phase (\u0026lt;em\u0026gt;Phase 1)\u0026lt;/em\u0026gt;).\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;scan for \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt;-sign, beginning from the left up to the end of the line; if one is found, then:\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;if \u0026lt;a href=\u0026quot;https://ss64.com/nt/cmd.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot; title=\u0026quot;CMD.exe\u0026quot;\u0026gt;Command Extensions\u0026lt;/a\u0026gt; are enabled (default), check if next character is \u0026lt;code\u0026gt;~\u0026lt;/code\u0026gt;; if yes, then:\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;take as many as possible of the following characters in the case-insensitive set \u0026lt;code\u0026gt;fdpnxsatz\u0026lt;/code\u0026gt; (even multiple times each) that are preceding a character that defines a \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; variable reference or a \u0026lt;code\u0026gt;$\u0026lt;/code\u0026gt;-sign; if such a \u0026lt;code\u0026gt;$\u0026lt;/code\u0026gt;-sign is encountered, then:\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;scan for a \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt;\u0026lt;sup\u0026gt;1\u0026lt;/sup\u0026gt;; if found, then:\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;if there is a character following the \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt;, use it as a \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; variable reference and expand as expected, unless it is not defined, then do not expand and continue scan at that character position;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;if the \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt; is the last character, \u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;cmd.exe\u0026lt;/code\u0026gt; will crash!\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;else (no \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt; is found) do not expand anything;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;else (if no \u0026lt;code\u0026gt;$\u0026lt;/code\u0026gt;-sign is encountered) expand the \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; variable using all the modifiers, unless it is not defined, then do not expand and continue scan at that character position;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;else (if no \u0026lt;code\u0026gt;~\u0026lt;/code\u0026gt; is found or Command Extensions are disabled) check the next character:\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;if there is no more character available, do not expand anything;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;if the next character is \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt;, do not expand anything and go back to the beginning of the scan at this character position\u0026lt;sup\u0026gt;2\u0026lt;/sup\u0026gt;;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;else use the next character as a \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; variable reference and expand, unless such is not defined, then do not expand;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;go back to the beginning of the scan at the next character position (as long as there still characters available);\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sub\u0026gt;1)  The string between \u0026lt;code\u0026gt;$\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;:\u0026lt;/code\u0026gt; is considered as the name of an environment variable, which may even be empty; since an environment variable cannot have an empty name, the behaviour is just the same as for an undefined environment variable.\u0026lt;/sub\u0026gt;\n\u0026lt;br\u0026gt;\n\u0026lt;sub\u0026gt;2)  This implies that a \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; meta-variable named \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt; cannot be expanded without a \u0026lt;code\u0026gt;~\u0026lt;/code\u0026gt;-modifier.\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sub\u0026gt;Original source: \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/56240800\u0026quot; title=\u0026quot;How to safely echo FOR variable %%~p followed by a string literal\u0026quot;\u0026gt;How to safely echo FOR variable %%~p followed by a string literal\u0026lt;/a\u0026gt;\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;edit: see accepted answer, what follows is wrong and explains only how to pass a command line to TinyPerl.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Regarding quotes, I have the feeling that the behaviour is the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;when a \u0026lt;code\u0026gt;\u0026quot;\u0026lt;/code\u0026gt; is found, string globbing begins\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;when string globbing occurs:\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;every character that is not a \u0026lt;code\u0026gt;\u0026quot;\u0026lt;/code\u0026gt; is globbed\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;when a \u0026lt;code\u0026gt;\u0026quot;\u0026lt;/code\u0026gt; is found:\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;if it is followed by \u0026lt;code\u0026gt;\u0026quot;\u0026quot;\u0026lt;/code\u0026gt; (thus a triple \u0026lt;code\u0026gt;\u0026quot;\u0026lt;/code\u0026gt;) then a double quote is added to the string\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;if it is followed by \u0026lt;code\u0026gt;\u0026quot;\u0026lt;/code\u0026gt; (thus a double \u0026lt;code\u0026gt;\u0026quot;\u0026lt;/code\u0026gt;) then a double quote is added to the string and string globbing ends\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;if the next character is not \u0026lt;code\u0026gt;\u0026quot;\u0026lt;/code\u0026gt;, string globbing ends\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;when line ends, string globbing ends.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;In short:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;\u0026quot;a \u0026quot;\u0026quot;\u0026quot; b \u0026quot;\u0026quot; c\u0026quot;\u0026quot;\u0026quot;\u0026lt;/code\u0026gt; consists of two strings: \u0026lt;code\u0026gt;a \u0026quot; b \u0026quot;\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;c\u0026quot;\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;\u0026quot;a\u0026quot;\u0026quot;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026quot;a\u0026quot;\u0026quot;\u0026quot;\u0026lt;/code\u0026gt; and\u0026lt;code\u0026gt;\u0026quot;a\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026lt;/code\u0026gt; are all the same string if at the end of a line\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Note that Microsoft has published its Terminal\u0026apos;s source code. It may work similar to the command line with respect to syntax parsing. Maybe someone is interested in testing the reverse-engineered parsing rules on accordance with the terminal\u0026apos;s parsing rules.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/Microsoft/Terminal\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Link\u0026lt;/a\u0026gt; to the source code.\u0026lt;/p\u0026gt;\n    "],"id":356,"title":"How does the Windows Command Interpreter (CMD.EXE) parse scripts?","slug":"how-does-the-windows-command-interpreter-(cmd.exe)-parse-scripts-1657387731560","postType":"QUESTION","createdAt":"2022-07-09T17:28:51.000Z","updatedAt":"2022-07-09T17:28:51.000Z","tags":[{"id":1993,"name":"variable-expansion","slug":"variable-expansion","createdAt":"2022-07-09T17:28:51.000Z","updatedAt":"2022-07-09T17:28:51.000Z","Questions_Tags":{"questionId":356,"tagId":1993}}]}]}},"__N_SSG":true},"page":"/questions/tag/[slug]","query":{"slug":"variable-expansion"},"buildId":"B9ZMQqRLGvIP-RcWN9dT2","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>