<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2eccd4d47c856f2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2eccd4d47c856f2b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/81-096e453de8a27667.js" defer=""></script><script src="/_next/static/chunks/pages/questions/tag/%5Bslug%5D-6802ea06aeddcbec.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_buildManifest.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5"></style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="https://flowbite.com/docs/images/logo.svg" class="mr-3 h-6 sm:h-9" alt="Flowbite Logo"/><span class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Hunter</span></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/tag/hammingweight#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="flex items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/how-to-count-the-number-of-set-bits-in-a-32-bit-integer-1657388437370">How to count the number of set bits in a 32-bit integer?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/hammingweight">hammingweight</a></div></div><div class="mt-4 mb-6" style="height:100px;overflow:auto"><h4 class="font-semibold">Solution 1:</h4><div class="text-sm bg-green-100 text-neutral-600">
<p>This is known as the '<a href="https://en.wikipedia.org/wiki/Hamming_weight" rel="noreferrer">Hamming Weight</a>', 'popcount' or 'sideways addition'.</p>
<p>Some CPUs have a single built-in instruction to do it and others have parallel instructions which act on bit vectors.  Instructions like x86's <a href="https://www.felixcloutier.com/x86/popcnt" rel="noreferrer"><code>popcnt</code></a> (on CPUs where it's supported) will almost certainly be fastest for a single integer.  Some other architectures may have a slow instruction implemented with a microcoded loop that tests a bit per cycle (<em>citation needed</em> - hardware popcount is normally fast if it exists at all.).</p>
<p>The 'best' algorithm really depends on which CPU you are on and what your usage pattern is.</p>
<p>Your compiler may know how to do something that's good for the specific CPU you're compiling for, e.g. <a href="https://en.cppreference.com/w/cpp/numeric/popcount" rel="noreferrer">C++20 <code>std::popcount()</code></a>, or C++ <a href="https://en.cppreference.com/w/cpp/utility/bitset/count" rel="noreferrer"><code>std::bitset&lt;32&gt;::count()</code></a>, as a portable way to access builtin / intrinsic functions (see <a href="https://stackoverflow.com/questions/109023/how-to-count-the-number-of-set-bits-in-a-32-bit-integer/109069#109069">another answer</a> on this question).  But your compiler's choice of fallback for target CPUs that don't have hardware popcnt might not be optimal for your use-case.  Or your language (e.g. C) might not expose any portable function that could use a CPU-specific popcount when there is one.</p>
<hr>
<h3>Portable algorithms that don't need (or benefit from) any HW support</h3>
<p>A pre-populated table lookup method can be very fast if your CPU has a large cache and you are doing lots of these operations in a tight loop. However it can suffer because of the expense of a 'cache miss', where the CPU has to fetch some of the table from main memory.  (Look up each byte separately to keep the table small.)  If you want popcount for a contiguous range of numbers, only the low byte is changing for groups of 256 numbers, <a href="https://stackoverflow.com/questions/66520106/count-integers-in-1-n-with-k-zero-bits-below-the-leading-1-popcount-for-a-c/66532113#66532113">making this very good</a>.</p>
<p>If you know that your bytes will be mostly 0's or mostly 1's then there are efficient algorithms for these scenarios, e.g. clearing the lowest set with a bithack in a loop until it becomes zero.</p>
<p>I believe a very good general purpose algorithm is the following, known as 'parallel' or 'variable-precision SWAR algorithm'. I have expressed this in a C-like pseudo language, you may need to adjust it to work for a particular language (e.g. using uint32_t for C++ and &gt;&gt;&gt; in Java):</p>
<p>GCC10 and clang 10.0 can recognize this pattern / idiom and compile it to a hardware popcnt or equivalent instruction when available, giving you the best of both worlds. (<a href="https://godbolt.org/z/qGdh1dvKK" rel="noreferrer">https://godbolt.org/z/qGdh1dvKK</a>)</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">numberOfSetBits</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> i)</span>
{
     <span class="hljs-comment">// Java: use int, and use &gt;&gt;&gt; instead of &gt;&gt;. Or use Integer.bitCount()</span>
     <span class="hljs-comment">// C or C++: use uint32_t</span>
     i = i - ((i &gt;&gt; <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0x55555555</span>);        <span class="hljs-comment">// add pairs of bits</span>
     i = (i &amp; <span class="hljs-number">0x33333333</span>) + ((i &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">0x33333333</span>);  <span class="hljs-comment">// quads</span>
     i = (i + (i &gt;&gt; <span class="hljs-number">4</span>)) &amp; <span class="hljs-number">0x0F0F0F0F</span>;        <span class="hljs-comment">// groups of 8</span>
     <span class="hljs-keyword">return</span> (i * <span class="hljs-number">0x01010101</span>) &gt;&gt; <span class="hljs-number">24</span>;          <span class="hljs-comment">// horizontal sum of bytes</span>
}
</code></pre>
<p>For JavaScript: <a href="https://stackoverflow.com/questions/109023/how-to-count-the-number-of-set-bits-in-a-32-bit-integer/109025#comment103845611_109025">coerce to integer</a> with <code>|0</code> for performance: change the first line to <code>i = (i|0) - ((i &gt;&gt; 1) &amp; 0x55555555);</code></p>
<p>This has the best worst-case behaviour of any of the algorithms discussed, so will efficiently deal with any usage pattern or values you throw at it.  (Its performance is not data-dependent on normal CPUs where all integer operations including multiply are constant-time.  It doesn't get any faster with "simple" inputs, but it's still pretty decent.)</p>
<p>References:</p>
<ul>
<li><a href="https://graphics.stanford.edu/%7Eseander/bithacks.html#CountBitsSetParallel" rel="noreferrer">https://graphics.stanford.edu/~seander/bithacks.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/Hamming_weight" rel="noreferrer">https://en.wikipedia.org/wiki/Hamming_weight</a></li>
<li><a href="http://gurmeet.net/puzzles/fast-bit-counting-routines/" rel="noreferrer">http://gurmeet.net/puzzles/fast-bit-counting-routines/</a></li>
<li><a href="http://aggregate.ee.engr.uky.edu/MAGIC/#Population%20Count%20(Ones%20Count)" rel="noreferrer">http://aggregate.ee.engr.uky.edu/MAGIC/#Population%20Count%20(Ones%20Count)</a></li>
</ul>
<hr>
<h3>How this SWAR bithack works:</h3>
<pre><code>i = i - ((i &gt;&gt; 1) &amp; 0x55555555);
</code></pre>
<p>The first step is an optimized version of masking to isolate the odd / even bits, shifting to line them up, and adding.  This effectively does 16 separate additions in 2-bit accumulators (<a href="https://en.wikipedia.org/wiki/SWAR" rel="noreferrer">SWAR = SIMD Within A Register</a>).  Like <code>(i &amp; 0x55555555) + ((i&gt;&gt;1) &amp; 0x55555555)</code>.</p>
<p>The next step takes the odd/even eight of those 16x 2-bit accumulators and adds again, producing 8x 4-bit sums.  The <code>i - ...</code> optimization isn't possible this time so it does just mask before / after shifting.  Using the same <code>0x33...</code> constant both times instead of <code>0xccc...</code> before shifting is a good thing when compiling for ISAs that need to construct 32-bit constants in registers separately.</p>
<p>The final shift-and-add step of <code>(i + (i &gt;&gt; 4)) &amp; 0x0F0F0F0F</code> widens to 4x 8-bit accumulators.  It masks <em>after</em> adding instead of before, because the maximum value in any 4-bit accumulator is <code>4</code>, if all 4 bits of the corresponding input bits were set.  4+4 = 8 which still fits in 4 bits, so carry between nibble elements is impossible in <code>i + (i &gt;&gt; 4)</code>.</p>
<p>So far this is just fairly normal SIMD using SWAR techniques with a few clever optimizations.  Continuing on with the same pattern for 2 more steps can widen to 2x 16-bit then 1x 32-bit counts.  But there is a more efficient way on machines with fast hardware multiply:</p>
<p>Once we have few enough "elements", <strong>a multiply with a magic constant can sum all the elements into the top element</strong>.  In this case byte elements.  Multiply is done by left-shifting and adding, so <strong>a multiply of <code>x * 0x01010101</code> results in <code>x + (x&lt;&lt;8) + (x&lt;&lt;16) + (x&lt;&lt;24)</code>.</strong>  Our 8-bit elements are wide enough (and holding small enough counts) that this doesn't produce carry <em>into</em> that top 8 bits.</p>
<p><strong>A 64-bit version of this</strong> can do 8x 8-bit elements in a 64-bit integer with a 0x0101010101010101 multiplier, and extract the high byte with <code>&gt;&gt;56</code>.  So it doesn't take any extra steps, just wider constants.  This is what GCC uses for <code>__builtin_popcountll</code> on x86 systems when the hardware <code>popcnt</code> instruction isn't enabled.  If you can use builtins or intrinsics for this, do so to give the compiler a chance to do target-specific optimizations.</p>
<hr>
<h3>With full SIMD for wider vectors (e.g. counting a whole array)</h3>
<p>This bitwise-SWAR algorithm could parallelize to be done in multiple vector elements at once, instead of in a single integer register, for a speedup on CPUs with SIMD but no usable popcount instruction.  (e.g. x86-64 code that has to run on any CPU, not just Nehalem or later.)</p>
<p>However, the best way to use vector instructions for popcount is usually by using a variable-shuffle to do a table-lookup for 4 bits at a time of each byte in parallel.  (The 4 bits index a 16 entry table held in a vector register).</p>
<p>On Intel CPUs, the hardware 64bit popcnt instruction can outperform an <a href="http://wm.ite.pl/articles/sse-popcount.html" rel="noreferrer">SSSE3 <code>PSHUFB</code> bit-parallel implementation</a> by about a factor of 2, but only <a href="http://danluu.com/assembly-intrinsics/" rel="noreferrer">if your compiler gets it just right</a>.  Otherwise SSE can come out significantly ahead.  Newer compiler versions are aware of the <a href="https://stackoverflow.com/a/25089720/224132">popcnt false dependency</a> <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=62011" rel="noreferrer">problem on Intel</a>.</p>
<ul>
<li><a href="https://github.com/WojciechMula/sse-popcount" rel="noreferrer">https://github.com/WojciechMula/sse-popcount</a> state-of-the-art x86 SIMD popcount for SSSE3, AVX2, AVX512BW, AVX512VBMI, or AVX512 VPOPCNT.  Using Harley-Seal across vectors to defer popcount within an element.  (Also ARM NEON)</li>
<li><a href="https://stackoverflow.com/questions/50081465/counting-1-bits-population-count-on-large-data-using-avx-512-or-avx-2">Counting 1 bits (population count) on large data using AVX-512 or AVX-2</a></li>
<li>related: <a href="https://github.com/mklarqvist/positional-popcount" rel="noreferrer">https://github.com/mklarqvist/positional-popcount</a> - separate counts for each bit-position of multiple 8, 16, 32, or 64-bit integers.  (Again, x86 SIMD including AVX-512 which is really good at this, with <code>vpternlogd</code> making Harley-Seal <em>very</em> good.)</li>
</ul>
    </div></div><div><div class="flex items-center justify-between text-slate-500"><div class="flex space-x-4 md:space-x-8"><div class="flex cursor-pointer items-center transition hover:text-slate-600"><svg xmlns="http://www.w3.org/2000/svg" class="mr-1.5 h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M14 10h4.764a2 2 0 011.789 2.894l-3.5 7A2 2 0 0115.263 21h-4.017c-.163 0-.326-.02-.485-.06L7 20m7-10V5a2 2 0 00-2-2h-.095c-.5 0-.905.405-.905.905 0 .714-.211 1.412-.608 2.006L7 11v9m7-10h-2M7 20H5a2 2 0 01-2-2v-6a2 2 0 012-2h2.5"></path></svg><span>4</span></div></div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"count":1,"rows":[{"answer":["\n\u0026lt;p\u0026gt;This is known as the \u0026apos;\u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Hamming_weight\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Hamming Weight\u0026lt;/a\u0026gt;\u0026apos;, \u0026apos;popcount\u0026apos; or \u0026apos;sideways addition\u0026apos;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Some CPUs have a single built-in instruction to do it and others have parallel instructions which act on bit vectors.  Instructions like x86\u0026apos;s \u0026lt;a href=\u0026quot;https://www.felixcloutier.com/x86/popcnt\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;popcnt\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; (on CPUs where it\u0026apos;s supported) will almost certainly be fastest for a single integer.  Some other architectures may have a slow instruction implemented with a microcoded loop that tests a bit per cycle (\u0026lt;em\u0026gt;citation needed\u0026lt;/em\u0026gt; - hardware popcount is normally fast if it exists at all.).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The \u0026apos;best\u0026apos; algorithm really depends on which CPU you are on and what your usage pattern is.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Your compiler may know how to do something that\u0026apos;s good for the specific CPU you\u0026apos;re compiling for, e.g. \u0026lt;a href=\u0026quot;https://en.cppreference.com/w/cpp/numeric/popcount\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;C++20 \u0026lt;code\u0026gt;std::popcount()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;, or C++ \u0026lt;a href=\u0026quot;https://en.cppreference.com/w/cpp/utility/bitset/count\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::bitset\u0026amp;lt;32\u0026amp;gt;::count()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;, as a portable way to access builtin / intrinsic functions (see \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/109023/how-to-count-the-number-of-set-bits-in-a-32-bit-integer/109069#109069\u0026quot;\u0026gt;another answer\u0026lt;/a\u0026gt; on this question).  But your compiler\u0026apos;s choice of fallback for target CPUs that don\u0026apos;t have hardware popcnt might not be optimal for your use-case.  Or your language (e.g. C) might not expose any portable function that could use a CPU-specific popcount when there is one.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;Portable algorithms that don\u0026apos;t need (or benefit from) any HW support\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;A pre-populated table lookup method can be very fast if your CPU has a large cache and you are doing lots of these operations in a tight loop. However it can suffer because of the expense of a \u0026apos;cache miss\u0026apos;, where the CPU has to fetch some of the table from main memory.  (Look up each byte separately to keep the table small.)  If you want popcount for a contiguous range of numbers, only the low byte is changing for groups of 256 numbers, \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/66520106/count-integers-in-1-n-with-k-zero-bits-below-the-leading-1-popcount-for-a-c/66532113#66532113\u0026quot;\u0026gt;making this very good\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If you know that your bytes will be mostly 0\u0026apos;s or mostly 1\u0026apos;s then there are efficient algorithms for these scenarios, e.g. clearing the lowest set with a bithack in a loop until it becomes zero.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I believe a very good general purpose algorithm is the following, known as \u0026apos;parallel\u0026apos; or \u0026apos;variable-precision SWAR algorithm\u0026apos;. I have expressed this in a C-like pseudo language, you may need to adjust it to work for a particular language (e.g. using uint32_t for C++ and \u0026amp;gt;\u0026amp;gt;\u0026amp;gt; in Java):\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;GCC10 and clang 10.0 can recognize this pattern / idiom and compile it to a hardware popcnt or equivalent instruction when available, giving you the best of both worlds. (\u0026lt;a href=\u0026quot;https://godbolt.org/z/qGdh1dvKK\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://godbolt.org/z/qGdh1dvKK\u0026lt;/a\u0026gt;)\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;numberOfSetBits\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;uint32_t\u0026lt;/span\u0026gt; i)\u0026lt;/span\u0026gt;\n{\n     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Java: use int, and use \u0026amp;gt;\u0026amp;gt;\u0026amp;gt; instead of \u0026amp;gt;\u0026amp;gt;. Or use Integer.bitCount()\u0026lt;/span\u0026gt;\n     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// C or C++: use uint32_t\u0026lt;/span\u0026gt;\n     i = i - ((i \u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) \u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x55555555\u0026lt;/span\u0026gt;);        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// add pairs of bits\u0026lt;/span\u0026gt;\n     i = (i \u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x33333333\u0026lt;/span\u0026gt;) + ((i \u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) \u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x33333333\u0026lt;/span\u0026gt;);  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// quads\u0026lt;/span\u0026gt;\n     i = (i + (i \u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;)) \u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x0F0F0F0F\u0026lt;/span\u0026gt;;        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// groups of 8\u0026lt;/span\u0026gt;\n     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (i * \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x01010101\u0026lt;/span\u0026gt;) \u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;24\u0026lt;/span\u0026gt;;          \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// horizontal sum of bytes\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;For JavaScript: \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/109023/how-to-count-the-number-of-set-bits-in-a-32-bit-integer/109025#comment103845611_109025\u0026quot;\u0026gt;coerce to integer\u0026lt;/a\u0026gt; with \u0026lt;code\u0026gt;|0\u0026lt;/code\u0026gt; for performance: change the first line to \u0026lt;code\u0026gt;i = (i|0) - ((i \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 0x55555555);\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This has the best worst-case behaviour of any of the algorithms discussed, so will efficiently deal with any usage pattern or values you throw at it.  (Its performance is not data-dependent on normal CPUs where all integer operations including multiply are constant-time.  It doesn\u0026apos;t get any faster with \u0026quot;simple\u0026quot; inputs, but it\u0026apos;s still pretty decent.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;References:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://graphics.stanford.edu/%7Eseander/bithacks.html#CountBitsSetParallel\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://graphics.stanford.edu/~seander/bithacks.html\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Hamming_weight\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://en.wikipedia.org/wiki/Hamming_weight\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://gurmeet.net/puzzles/fast-bit-counting-routines/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://gurmeet.net/puzzles/fast-bit-counting-routines/\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://aggregate.ee.engr.uky.edu/MAGIC/#Population%20Count%20(Ones%20Count)\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://aggregate.ee.engr.uky.edu/MAGIC/#Population%20Count%20(Ones%20Count)\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;How this SWAR bithack works:\u0026lt;/h3\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;i = i - ((i \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 0x55555555);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The first step is an optimized version of masking to isolate the odd / even bits, shifting to line them up, and adding.  This effectively does 16 separate additions in 2-bit accumulators (\u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/SWAR\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;SWAR = SIMD Within A Register\u0026lt;/a\u0026gt;).  Like \u0026lt;code\u0026gt;(i \u0026amp;amp; 0x55555555) + ((i\u0026amp;gt;\u0026amp;gt;1) \u0026amp;amp; 0x55555555)\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The next step takes the odd/even eight of those 16x 2-bit accumulators and adds again, producing 8x 4-bit sums.  The \u0026lt;code\u0026gt;i - ...\u0026lt;/code\u0026gt; optimization isn\u0026apos;t possible this time so it does just mask before / after shifting.  Using the same \u0026lt;code\u0026gt;0x33...\u0026lt;/code\u0026gt; constant both times instead of \u0026lt;code\u0026gt;0xccc...\u0026lt;/code\u0026gt; before shifting is a good thing when compiling for ISAs that need to construct 32-bit constants in registers separately.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The final shift-and-add step of \u0026lt;code\u0026gt;(i + (i \u0026amp;gt;\u0026amp;gt; 4)) \u0026amp;amp; 0x0F0F0F0F\u0026lt;/code\u0026gt; widens to 4x 8-bit accumulators.  It masks \u0026lt;em\u0026gt;after\u0026lt;/em\u0026gt; adding instead of before, because the maximum value in any 4-bit accumulator is \u0026lt;code\u0026gt;4\u0026lt;/code\u0026gt;, if all 4 bits of the corresponding input bits were set.  4+4 = 8 which still fits in 4 bits, so carry between nibble elements is impossible in \u0026lt;code\u0026gt;i + (i \u0026amp;gt;\u0026amp;gt; 4)\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So far this is just fairly normal SIMD using SWAR techniques with a few clever optimizations.  Continuing on with the same pattern for 2 more steps can widen to 2x 16-bit then 1x 32-bit counts.  But there is a more efficient way on machines with fast hardware multiply:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Once we have few enough \u0026quot;elements\u0026quot;, \u0026lt;strong\u0026gt;a multiply with a magic constant can sum all the elements into the top element\u0026lt;/strong\u0026gt;.  In this case byte elements.  Multiply is done by left-shifting and adding, so \u0026lt;strong\u0026gt;a multiply of \u0026lt;code\u0026gt;x * 0x01010101\u0026lt;/code\u0026gt; results in \u0026lt;code\u0026gt;x + (x\u0026amp;lt;\u0026amp;lt;8) + (x\u0026amp;lt;\u0026amp;lt;16) + (x\u0026amp;lt;\u0026amp;lt;24)\u0026lt;/code\u0026gt;.\u0026lt;/strong\u0026gt;  Our 8-bit elements are wide enough (and holding small enough counts) that this doesn\u0026apos;t produce carry \u0026lt;em\u0026gt;into\u0026lt;/em\u0026gt; that top 8 bits.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;A 64-bit version of this\u0026lt;/strong\u0026gt; can do 8x 8-bit elements in a 64-bit integer with a 0x0101010101010101 multiplier, and extract the high byte with \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;56\u0026lt;/code\u0026gt;.  So it doesn\u0026apos;t take any extra steps, just wider constants.  This is what GCC uses for \u0026lt;code\u0026gt;__builtin_popcountll\u0026lt;/code\u0026gt; on x86 systems when the hardware \u0026lt;code\u0026gt;popcnt\u0026lt;/code\u0026gt; instruction isn\u0026apos;t enabled.  If you can use builtins or intrinsics for this, do so to give the compiler a chance to do target-specific optimizations.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;With full SIMD for wider vectors (e.g. counting a whole array)\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;This bitwise-SWAR algorithm could parallelize to be done in multiple vector elements at once, instead of in a single integer register, for a speedup on CPUs with SIMD but no usable popcount instruction.  (e.g. x86-64 code that has to run on any CPU, not just Nehalem or later.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;However, the best way to use vector instructions for popcount is usually by using a variable-shuffle to do a table-lookup for 4 bits at a time of each byte in parallel.  (The 4 bits index a 16 entry table held in a vector register).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;On Intel CPUs, the hardware 64bit popcnt instruction can outperform an \u0026lt;a href=\u0026quot;http://wm.ite.pl/articles/sse-popcount.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;SSSE3 \u0026lt;code\u0026gt;PSHUFB\u0026lt;/code\u0026gt; bit-parallel implementation\u0026lt;/a\u0026gt; by about a factor of 2, but only \u0026lt;a href=\u0026quot;http://danluu.com/assembly-intrinsics/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;if your compiler gets it just right\u0026lt;/a\u0026gt;.  Otherwise SSE can come out significantly ahead.  Newer compiler versions are aware of the \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/25089720/224132\u0026quot;\u0026gt;popcnt false dependency\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=62011\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;problem on Intel\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/WojciechMula/sse-popcount\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://github.com/WojciechMula/sse-popcount\u0026lt;/a\u0026gt; state-of-the-art x86 SIMD popcount for SSSE3, AVX2, AVX512BW, AVX512VBMI, or AVX512 VPOPCNT.  Using Harley-Seal across vectors to defer popcount within an element.  (Also ARM NEON)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/50081465/counting-1-bits-population-count-on-large-data-using-avx-512-or-avx-2\u0026quot;\u0026gt;Counting 1 bits (population count) on large data using AVX-512 or AVX-2\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;related: \u0026lt;a href=\u0026quot;https://github.com/mklarqvist/positional-popcount\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://github.com/mklarqvist/positional-popcount\u0026lt;/a\u0026gt; - separate counts for each bit-position of multiple 8, 16, 32, or 64-bit integers.  (Again, x86 SIMD including AVX-512 which is really good at this, with \u0026lt;code\u0026gt;vpternlogd\u0026lt;/code\u0026gt; making Harley-Seal \u0026lt;em\u0026gt;very\u0026lt;/em\u0026gt; good.)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Some languages portably expose the operation in a way that \u0026lt;em\u0026gt;can\u0026lt;/em\u0026gt; use efficient hardware support if available, otherwise some library fallback that\u0026apos;s hopefully decent.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For example (from \u0026lt;a href=\u0026quot;https://en.wikichip.org/wiki/population_count#Software_support\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;a table by language\u0026lt;/a\u0026gt;):\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;C++ has \u0026lt;code\u0026gt;std::bitset\u0026amp;lt;\u0026amp;gt;::count()\u0026lt;/code\u0026gt;, or  \u0026lt;a href=\u0026quot;https://en.cppreference.com/w/cpp/numeric/popcount\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;C++20 \u0026lt;code\u0026gt;std::popcount(T x)\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Java has \u0026lt;code\u0026gt;java.lang.Integer.bitCount()\u0026lt;/code\u0026gt; (also for Long or BigInteger)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;C# has \u0026lt;code\u0026gt;System.Numerics.BitOperations.PopCount()\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Python has \u0026lt;code\u0026gt;int.bit_count()\u0026lt;/code\u0026gt; (since 3.10)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Not all compilers / libraries actually manage to use HW support when it\u0026apos;s available, though. (Notably MSVC, even with options that make std::popcount inline as x86 popcnt, its std::bitset::count still always uses a lookup table.  This will hopefully change in future versions.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Also consider the built-in functions of your compiler when the portable language doesn\u0026apos;t have this basic bit operation.  In GNU C for example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c++ s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; __builtin_popcount (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; __builtin_popcountll (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; x);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In the worst case (no single-instruction HW support) the compiler will generate a call to a function (which in current GCC uses a shift/and bit-hack \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/109023/how-to-count-the-number-of-set-bits-in-a-32-bit-integer/109025#109025\u0026quot;\u0026gt;like this answer\u0026lt;/a\u0026gt;, at least for x86). In the best case the compiler will emit a cpu instruction to do the job. (Just like a \u0026lt;code\u0026gt;*\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;/\u0026lt;/code\u0026gt; operator - GCC will use a hardware multiply or divide instruction if available, otherwise will call a libgcc helper function.)  Or even better, if the operand is a compile-time constant after inlining, it can do constant-propagation to get a compile-time-constant popcount result.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The GCC builtins even work across multiple platforms. Popcount has almost become mainstream in the x86 architecture, so it makes sense to start using the builtin now so you can recompile to let it inline a hardware instruction when you compile with \u0026lt;code\u0026gt;-mpopcnt\u0026lt;/code\u0026gt; or something that includes that (e.g. \u0026lt;a href=\u0026quot;https://godbolt.org/z/Ma5e5a\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://godbolt.org/z/Ma5e5a\u0026lt;/a\u0026gt;). Other architectures have had popcount for years, but in the x86 world there are still some ancient Core 2 and similar vintage AMD CPUs in use.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;On x86, you can tell the compiler that it can assume support for \u0026lt;code\u0026gt;popcnt\u0026lt;/code\u0026gt; instruction with \u0026lt;code\u0026gt;-mpopcnt\u0026lt;/code\u0026gt; (also implied by \u0026lt;code\u0026gt;-msse4.2\u0026lt;/code\u0026gt;).  See \u0026lt;a href=\u0026quot;https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;GCC x86 options\u0026lt;/a\u0026gt;.  \u0026lt;code\u0026gt;-march=nehalem -mtune=skylake\u0026lt;/code\u0026gt; (or \u0026lt;code\u0026gt;-march=\u0026lt;/code\u0026gt; whatever CPU you want your code to assume and to tune for) could be a good choice.   Running the resulting binary on an older CPU will result in an illegal-instruction fault.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;To make binaries optimized for the machine you build them on, \u0026lt;strong\u0026gt;use \u0026lt;code\u0026gt;-march=native\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;  (with gcc, clang, or ICC).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/3849337/msvc-equivalent-to-builtin-popcount\u0026quot;\u0026gt;MSVC provides an intrinsic for the x86 \u0026lt;code\u0026gt;popcnt\u0026lt;/code\u0026gt; instruction\u0026lt;/a\u0026gt;, but unlike gcc it\u0026apos;s really an intrinsic for the hardware instruction and requires hardware support.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;Using \u0026lt;code\u0026gt;std::bitset\u0026amp;lt;\u0026amp;gt;::count()\u0026lt;/code\u0026gt; instead of a built-in\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;In theory, any compiler that knows how to popcount efficiently for the target CPU should expose that functionality through ISO C++ \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/utility/bitset/count\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::bitset\u0026amp;lt;\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;.  In practice, you might be better off with the bit-hack AND/shift/ADD in some cases for some target CPUs.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For target architectures where hardware popcount is an optional extension (like x86), not all compilers have a \u0026lt;code\u0026gt;std::bitset\u0026lt;/code\u0026gt; that takes advantage of it when available.  For example, MSVC has no way to enable \u0026lt;code\u0026gt;popcnt\u0026lt;/code\u0026gt; support at compile time, and it\u0026apos;s \u0026lt;code\u0026gt;std::bitset\u0026amp;lt;\u0026amp;gt;::count\u0026lt;/code\u0026gt; always uses \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/12324081/how-does-this-implementation-of-bitsetcount-work\u0026quot;\u0026gt;a table lookup\u0026lt;/a\u0026gt;, even with \u0026lt;code\u0026gt;/Ox /arch:AVX\u0026lt;/code\u0026gt; (which implies SSE4.2, which in turn implies the popcnt feature.)  (Update: see below; that \u0026lt;em\u0026gt;does\u0026lt;/em\u0026gt; get MSVC\u0026apos;s C++20 \u0026lt;code\u0026gt;std::popcount\u0026lt;/code\u0026gt; to use x86 \u0026lt;code\u0026gt;popcnt\u0026lt;/code\u0026gt;, but still not its bitset\u0026amp;lt;\u0026amp;gt;::count.  MSVC could fix that by updating their standard library headers to use std::popcount when available.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;But at least you get something portable that works everywhere, and with gcc/clang with the right target options, you get hardware popcount for architectures that support it.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c++ s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;bitset\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;limits\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;type_traits\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\ntemplate\u0026amp;lt;typename T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//static inline  // static if you want to compile with -mpopcnt in one compilation unit but not others\u0026lt;/span\u0026gt;\ntypename \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::enable_if\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::is_integral\u0026amp;lt;T\u0026amp;gt;::value,  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026amp;gt;::type \n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;popcount\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T x)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::numeric_limits\u0026amp;lt;T\u0026amp;gt;::radix == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;non-binary type\u0026quot;\u0026lt;/span\u0026gt;);\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// sizeof(x)*CHAR_BIT\u0026lt;/span\u0026gt;\n    constexpr \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; bitwidth = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::numeric_limits\u0026amp;lt;T\u0026amp;gt;::digits + \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::numeric_limits\u0026amp;lt;T\u0026amp;gt;::is_signed;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// std::bitset constructor was only unsigned long before C++11.  Beware if porting to C++03\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(bitwidth \u0026amp;lt;= \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::numeric_limits\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt;\u0026amp;gt;::digits, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;arg too wide for std::bitset() constructor\u0026quot;\u0026lt;/span\u0026gt;);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; typename \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::make_unsigned\u0026amp;lt;T\u0026amp;gt;::type UT;        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// probably not needed, bitset width chops after sign-extension\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;bitset\u0026lt;/span\u0026gt;\u0026amp;lt;bitwidth\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bs\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( static_cast\u0026amp;lt;UT\u0026amp;gt;(x) )\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; bs.count();\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;See \u0026lt;a href=\u0026quot;https://gcc.godbolt.org/#z:OYLghAFBqd5TKALEBjA9gEwKYFFMCWALugE4A0BIEAViAIzkDO6ArqatiAOQCkATAGYCAO1QAbVjgDUvQQGEARsSbYic3LwAMAQQHCxkmXPniCAWxUbteoaIlTsshUQCeAB2wB9IqQCGVoKaugD0IdIAqqrSREhOSOieAGas4uKuALTA6FjSTESYICDKRKpERRisIkQQAJTSFu7i2ObY1X5EBOgi0klk0n6kJf6krg3V2MDYpDEe2Ew2YdI6AG7oBJhMeQTAIhnYAB5EbYQiwNu72Jizngu6i%2BEA8j3AqKgDItcSfmfk0tgAR1YBBWfma1Ri6GkXi8imB4k6Ii87kSlWqaTqD2kmHQAHcREwNlwBuJcX5XFtWKotgA2AAsGRK0kS0x%2BmAyhIAXk4IN1pPTGcRpPIAApRWpYgBiZE4W25pHQ%2ByObUJfJI/IZJQAdFidOIWHlxHjptJccQEqwiNIkINMGTSE4Ue40UQ/vNPKgCGD0qbzQMYn5FM0Mkb0ABrVjuaSh9w60JPHoHAAcNL%2BuLI0ViCtYwCQ7ktzJ6OgAsgARaQAIVS4hx8oyST8lh9sR%2B0kE/EFVqdqGquv1ULJ%2BXm/oASrgABrSdwOpIEA5xvS6Y7mJodbAmNyeESNpwAFWs8fyHQI71EZhETmkSyPnVPSWkrjYpp%2BVvVGBXBGavti0gyK9REKiIWTjvu4n7HnyVRCnCVoiOgVrwXEpB3Dom5tDueQFEU6FBt4BBJCY%2BSFCABBMF4ojHMA/jiCY%2B5BEUoKSNgfzSFUhKXNcGhFGhsi6N2bDVBAu7SAcEr3AA7BWNjaAAnDeJ5eH4TCqKQNREUUIisK0pAKWYlilLRXEgP4hAHM4pZyOW/B/AI/BwXsyjbqMNzrvw/ASoIUn3N5MnXgQ3LoEkECiQAVPIAASOgjl4FYAJL7j5GAEscBzTuMVolGamA/pZmHEZp2m6RYgTyHRuBFIQwAqLI/AVnlGladMRX6QsChlUUpFeOxF6YHIXmLr54TqcUKhqNISX5KQrCoCQMyDoWPpsTsPXRt05yKNgfQOsKAhSbV9D0Fq0iVtg9pOPhU5kIi5zqvIu27Vogg2Mdx3yaginKdMNSZRsOUKLlw0FU1716SVS0catZyQ8ARmVSoNluYMN05L6MhbfVI2lGodTjd0k3TbNtkef10laDJaE4PeaHbq0GPmH4YbeODPWGfRIA8REdF1S9PNLNO6CKIGPpwbB2BXFcfwlGUqM/qgCTuFsfhJMcMzdUqxwEl0Iik3JWGY2UJg/dlSAaNIihMBAmHHu9qBKeoCicxowX1MTOsOkQ7A9ObWoupinnSeJFneYuOjM1cMTzEQyKogJUdMAkqkQPHV0DPUvCSdI7ue5dzqxxAfjE7Igc2GH1zHPk0e51UUcURAFGp0XdVZ6QPT8dX%2BeF%2BnQc6GEpcRxXbfVF4pcQH3BeN5najZ4PNQF31Rfd335dRzP9IQEaUMb%2Bc4/p03U8tznvtz55C9YjhzTkfe%2BSJFssSkb0CrmLjH7nsj/o4qwuEZBofdJSs0yqm1vGJekdK7vQ/rhCAECvw7wzs3VuMd27Hzql3UmId659HQEnBOVo/B/C3tDM2adJJu33j0HWh8847x8rtSh7dFCu10C9PqAdu5oKWDCCi9B%2BBJgaFsLKJoWw9D7gQre0k7D3noDVGkAgaTYk2qIK4EAYQAGVYoAC1cCPElF4WKAA5Xc3CkwwjEj3cIsQnBvQ%2BipK018FYxCQPfJIj9n5gVftICA6pug%2BhdA4pwRpcTWjBEkUxvdNYQ2XmA2ORjlHkWqEYhuu9J4ewPjPDu89UHByWLuRxWwbSoDDKaMgYYth8leKgEI3wzggAGMpRqZtRpWnvmCMkFJejiA6NIVo5gyCuBAM9F6SxYrRk2q%2BXJzICyBT8RHFcHTjhm2wLbKk50iBgG4FsEWl1VJC3XD5MI%2BEk7%2BWwIFZ2zhcDbACkFERa1oa1DTns8IL1umoHcK4CAsjzYIxpAcP4XJjlBXNnclhwd9D2CME4EwqBJqiBhkEEu4SVr5LDFE6uMTOHxJ4YkkhPlhpSzUCYIxptzbpP9j5Z5rz3n8BpJ86ReCLn/IgICwuV5wj2hEDCmpGBXkwo%2BMyRQNBFkIXvPZDIvgQRenEC5DxZofww1qrtUxsl4FmyYD7POjC9DF3uEIE4%2BEbDcFqOQcQPAACs3ByAiB4Foc16AeB3XlbVPIbAOAQqEPQc15RuDWrueQMMIBBBJi1FoGk4lxL0BkgGmkSYkxaC0HSI1PA6TmvMCAcSWgtT0BpDSdsWhM3Zv4Lm1MlqvU2p4OapgIAtDkE9d68gcBYAoFAp%2BaYlBqBNuaKQEA7hnT0maMAbNVbZwIgAdQRQVrzXvlaNUZ46Rx3kEIA6GaIJ5hzootgY1JbDVmHNvAQ1iROh4x4BkAA6t6X8jxBC/iIpZXYrB7r7XdcwZ1nAGBbtNea4t1ryC2u4CKY0pARTyA1PyLUggg0ePwMQfo%2BhGDCnQC/E0MHagevHT6uIfgcCdrqAm7gSbyApv4DJLUSZBCCBDTJEjZHxIUYDRaudP7y2Vurahw1fqA1BpDWGiNKZo2xvjRuwQH76NluY5uutiB63IDQPBtxLaqAQHbdMNAHSzhkZ%2BUOlWFbGVzsnW0IgM6%2BklvnQQRdnR/4VqM2ujdtbt0VsgHu9wB6CRHuvYIUst770VgOlego27LLbtQJ538p60jnsvX%2BbsEI/yDDlpZG0TBcTrvEOW59XBGBkmnY52KIg%2Bg8HdW%2B7gZq6NGZ/cmGkGR6TjRU%2BcMDciICQdmjVQQsH5AyebTMfQghkOie9Ya9DmHqCsf9YGmSdIkwmpkuJJMdITUxqozhvDKbSPEfoLm3NMkZLcJNVNmSxWv0MeYExmtBrxPwAgI2trHbW0Kcu0p4AdJRvkA0yO2JXgtCDfIGOozunp0iFnUZhdgrl0Wa/VZudNAgTTEM2B/gGbzXgmALEBg5BpzYBWI8flgrqAwje9QLknJmj0BNcG4Nm2TV0jG4IagVRKaKMKOvSYJx4D0HEoINNu2q3cHy3crdbREcoEYKj9HmOZrY5hO92gABFVgUP2yrZI4RmSNJHoza0MTjbJr6DUEIEwVchmTv48J8T5XNIycU5I9Tz4CierUD7UzyALO2dk3IJz7nPqEdI/oDzo1BAd32e/Y5rWFmT1noyBenzvU3MeYdV5qREWAJWmixwE2bn4uJbSCl9gL6vc4aK5%2B0t3AysVbpNIcp0g6RaiIyX%2BrhBGswb%2BK1hDHWhAmu68d93ibk3%2BpNcRmkE2c1K7I3SAtJq9sF8Y1W9vp2G3Sab9dxTnaTyoBZ09z8mmxe4%2Bw19r9P39N/cM1%2BwHS7zOromNZ81EOZejB4DDuHRq%2Bee5Rw6YXArRevYl4b7AROSem6J%2Bbqno8Vus4NuDOUwnwzO4kBaq2Lu5AXOBq3uHuAuT%2BaOGOr%2B5Q7%2B1ANA0usu/A8u7YG2yuggqu6uMkmu2upEeuZahqn%2B3%2BJuZulOlutOIBdu4BDukBa2MBcBPOvOZwnuCBvudm2G%2B6QeR6IWkqYe4Wrm7mmknm3m8ezoUW9Myelk24Zm2AmeLqr6ueQmJWPARelWS%2B0gLOEGte0GbqDet2zeRBbeLG5A/WSm2GG6i2/q6a7YggSuE23CbO1GY%2B36ImFak%2BthbGYGY2fej0SYrO/AkBYaOGgmvhB2U%2Bkm52s%2BsmFA8mC%2Bym4aXg9Iq%2Bw6yEo6Om8GU6e%2B/2h%2BJmQOJ%2BlmZ%2BqGPufuQhgeh63AIQjwZkIQMWKAOgAAauOBodnuQBlvplljlj%2BvltofEXoSmMXsKAADJGEyTSBQHiTSAji7jHomFQZWEtaWFNbuQoabpDY8JagU7bbiQhruHTaQF94LY6H7b%2BFHa2Ebr8Bd6rZVr55%2BHcB7G9bkD/zIRawgB0hAA%3D\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;asm from gcc, clang, icc, and MSVC\u0026lt;/a\u0026gt; on the Godbolt compiler explorer.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;x86-64 \u0026lt;code\u0026gt;gcc -O3 -std=gnu++11 -mpopcnt\u0026lt;/code\u0026gt; emits this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c++ s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;test_short\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;short\u0026lt;/span\u0026gt; a)\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; popcount(a); }\n    movzx   eax, di      \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# note zero-extension, not sign-extension\u0026lt;/span\u0026gt;\n    popcnt  rax, rax\n    ret\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;test_int\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a)\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; popcount(a); }\n    mov     eax, edi\n    popcnt  rax, rax        \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# unnecessary 64-bit operand size\u0026lt;/span\u0026gt;\n    ret\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;test_u64\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; a)\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; popcount(a); }\n    xor     eax, eax     \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# gcc avoids false dependencies for Intel CPUs\u0026lt;/span\u0026gt;\n    popcnt  rax, rdi\n    ret\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;PowerPC64 \u0026lt;code\u0026gt;gcc -O3 -std=gnu++11\u0026lt;/code\u0026gt; emits (for the \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; arg version):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c++ s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;    rldicl \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;32\u0026lt;/span\u0026gt;     \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# zero-extend from 32 to 64-bit\u0026lt;/span\u0026gt;\n    popcntd \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;         \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# popcount\u0026lt;/span\u0026gt;\n    blr\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This source isn\u0026apos;t x86-specific or GNU-specific at all, but only compiles well with gcc/clang/icc, at least when targeting x86 (including x86-64).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Also note that gcc\u0026apos;s fallback for architectures without single-instruction popcount is a byte-at-a-time table lookup.  This isn\u0026apos;t wonderful \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/15736602/fastest-way-to-count-number-of-1s-in-a-register-arm-assembly\u0026quot;\u0026gt;for ARM, for example\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;\u0026lt;a href=\u0026quot;https://en.cppreference.com/w/cpp/numeric/popcount\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;C++20 has \u0026lt;code\u0026gt;std::popcount(T)\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Current libstdc++ headers unfortunately define it with a special case \u0026lt;code\u0026gt;if(x==0) return 0;\u0026lt;/code\u0026gt; at the start, which clang doesn\u0026apos;t optimize away when compiling for x86:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c++ s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;bit\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; x)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::popcount(x);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;clang 11.0.1 \u0026lt;code\u0026gt;-O3  -std=gnu++20 -march=nehalem\u0026lt;/code\u0026gt;  (\u0026lt;a href=\u0026quot;https://godbolt.org/z/arMe5a\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://godbolt.org/z/arMe5a\u0026lt;/a\u0026gt;)\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c++ s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# clang 11\u0026lt;/span\u0026gt;\n    bar(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;):                                # @bar(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\n        popcnt  eax, edi\n        cmove   eax, edi         \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# redundant: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; popcnt result is 0, return the original 0 instead of the popcnt-generated 0...\u0026lt;/span\u0026gt;\n        ret\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;But GCC compiles nicely:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c++ s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# gcc 10\u0026lt;/span\u0026gt;\n        xor     eax, eax         \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# break false dependency on Intel SnB-family before Ice Lake.\u0026lt;/span\u0026gt;\n        popcnt  eax, edi\n        ret\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Even MSVC does well with it, as long as you use \u0026lt;code\u0026gt;-arch:AVX\u0026lt;/code\u0026gt;  or later (and enable C++20 with \u0026lt;code\u0026gt;-std:c++latest\u0026lt;/code\u0026gt;). \u0026lt;a href=\u0026quot;https://godbolt.org/z/7K4Gef\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://godbolt.org/z/7K4Gef\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c++ s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; PROC                                 ; bar, COMDAT\n        popcnt  eax, ecx\n        ret     \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; ENDP                                 ; bar\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In my opinion, the \u0026quot;best\u0026quot; solution is the one that can be read by another programmer (or the original programmer two years later) without copious comments.  You may well want the fastest or cleverest solution which some have already provided but I prefer readability over cleverness any time.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;unsigned int bitCount (unsigned int value) {\n    unsigned int count = 0;\n    while (value \u0026amp;gt; 0) {           // until all bits are zero\n        if ((value \u0026amp;amp; 1) == 1)     // check lower bit\n            count++;\n        value \u0026amp;gt;\u0026amp;gt;= 1;              // shift bits, removing lower bit\n    }\n    return count;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If you want more speed (and assuming you document it well to help out your successors), you could use a table lookup:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;// Lookup table for fast calculation of bits set in 8-bit unsigned char.\n\nstatic unsigned char oneBitsInUChar[] = {\n//  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F (\u0026amp;lt;- n)\n//  =====================================================\n    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, // 0n\n    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, // 1n\n    : : :\n    4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, // Fn\n};\n\n// Function for fast calculation of bits set in 16-bit unsigned short.\n\nunsigned char oneBitsInUShort (unsigned short x) {\n    return oneBitsInUChar [x \u0026amp;gt;\u0026amp;gt;    8]\n         + oneBitsInUChar [x \u0026amp;amp;  0xff];\n}\n\n// Function for fast calculation of bits set in 32-bit unsigned int.\n\nunsigned char oneBitsInUInt (unsigned int x) {\n    return oneBitsInUShort (x \u0026amp;gt;\u0026amp;gt;     16)\n         + oneBitsInUShort (x \u0026amp;amp;  0xffff);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Although these rely on specific data type sizes so they\u0026apos;re not that portable. But, since many performance optimisations aren\u0026apos;t portable anyway, that may not be an issue. If you want portability, I\u0026apos;d stick to the readable solution.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://books.google.com/books?id=iBNKMspIlqEC\u0026amp;amp;pg=PA66\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;From Hacker\u0026apos;s Delight, p. 66, Figure 5-2\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;int pop(unsigned x)\n{\n    x = x - ((x \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 0x55555555);\n    x = (x \u0026amp;amp; 0x33333333) + ((x \u0026amp;gt;\u0026amp;gt; 2) \u0026amp;amp; 0x33333333);\n    x = (x + (x \u0026amp;gt;\u0026amp;gt; 4)) \u0026amp;amp; 0x0F0F0F0F;\n    x = x + (x \u0026amp;gt;\u0026amp;gt; 8);\n    x = x + (x \u0026amp;gt;\u0026amp;gt; 16);\n    return x \u0026amp;amp; 0x0000003F;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Executes in ~20-ish instructions (arch dependent), no branching.\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;a href=\u0026quot;http://books.google.com/books?id=iBNKMspIlqEC\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Hacker\u0026apos;s Delight\u0026lt;/a\u0026gt; \u0026lt;em\u0026gt;is\u0026lt;/em\u0026gt; delightful! Highly recommended.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I think the fastest waywithout using lookup tables and \u0026lt;em\u0026gt;popcount\u0026lt;/em\u0026gt;is the following. It counts the set bits with just 12 operations.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;int popcount(int v) {\n    v = v - ((v \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 0x55555555);                // put count of each 2 bits into those 2 bits\n    v = (v \u0026amp;amp; 0x33333333) + ((v \u0026amp;gt;\u0026amp;gt; 2) \u0026amp;amp; 0x33333333); // put count of each 4 bits into those 4 bits  \n    return c = ((v + (v \u0026amp;gt;\u0026amp;gt; 4) \u0026amp;amp; 0xF0F0F0F) * 0x1010101) \u0026amp;gt;\u0026amp;gt; 24;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It works because you can count the total number of set bits by dividing in two halves, counting the number of set bits in both halves and then adding them up. Also know as \u0026lt;code\u0026gt;Divide and Conquer\u0026lt;/code\u0026gt; paradigm. Let\u0026apos;s get into detail.. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;v = v - ((v \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 0x55555555); \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The number of bits in two bits can be \u0026lt;code\u0026gt;0b00\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;0b01\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;0b10\u0026lt;/code\u0026gt;. Lets try to work this out on 2 bits.. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt; ---------------------------------------------\n |   v    |   (v \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 0b0101   |  v - x   |\n ---------------------------------------------\n   0b00           0b00               0b00   \n   0b01           0b00               0b01     \n   0b10           0b01               0b01\n   0b11           0b01               0b10\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This is what was required: the last column shows the count of set bits in every two bit pair. If the two bit number is \u0026lt;code\u0026gt;\u0026amp;gt;= 2 (0b10)\u0026lt;/code\u0026gt; then \u0026lt;code\u0026gt;and\u0026lt;/code\u0026gt; produces \u0026lt;code\u0026gt;0b01\u0026lt;/code\u0026gt;, else it produces \u0026lt;code\u0026gt;0b00\u0026lt;/code\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;v = (v \u0026amp;amp; 0x33333333) + ((v \u0026amp;gt;\u0026amp;gt; 2) \u0026amp;amp; 0x33333333); \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This statement should be easy to understand. After the first operation we have the count of set bits in every two bits, now we sum up that count in every 4 bits.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;v \u0026amp;amp; 0b00110011         //masks out even two bits\n(v \u0026amp;gt;\u0026amp;gt; 2) \u0026amp;amp; 0b00110011  // masks out odd two bits\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;We then sum up the above result, giving us the total count of set bits in 4 bits. The last statement is the most tricky.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;c = ((v + (v \u0026amp;gt;\u0026amp;gt; 4) \u0026amp;amp; 0xF0F0F0F) * 0x1010101) \u0026amp;gt;\u0026amp;gt; 24;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Let\u0026apos;s break it down further... \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;v + (v \u0026amp;gt;\u0026amp;gt; 4)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It\u0026apos;s similar to the second statement; we are counting the set bits in groups of 4 instead. We knowbecause of our previous operationsthat every nibble has the count of set bits in it. Let\u0026apos;s look an example. Suppose we have the byte \u0026lt;code\u0026gt;0b01000010\u0026lt;/code\u0026gt;. It means the first nibble has its 4bits set and the second one has its 2bits set. Now we add those nibbles together. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;0b01000010 + 0b01000000\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It gives us the count of set bits in a byte, in the first nibble \u0026lt;code\u0026gt;0b01100010\u0026lt;/code\u0026gt; and therefore we mask the last four bytes of all the bytes in the number (discarding them).\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;0b01100010 \u0026amp;amp; 0xF0 = 0b01100000\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now every byte has the count of set bits in it. We need to add them up all together. The trick is to multiply the result by \u0026lt;code\u0026gt;0b10101010\u0026lt;/code\u0026gt; which has an interesting property. If our number has four bytes, \u0026lt;code\u0026gt;A B C D\u0026lt;/code\u0026gt;, it will result in a new number with these bytes \u0026lt;code\u0026gt;A+B+C+D B+C+D C+D D\u0026lt;/code\u0026gt;. A 4 byte number can have maximum of 32 bits set, which can be represented as \u0026lt;code\u0026gt;0b00100000\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;All we need now is the first byte which has the sum of all set bits in all the bytes, and we get it by  \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt; 24\u0026lt;/code\u0026gt;. This algorithm was designed for \u0026lt;code\u0026gt;32 bit\u0026lt;/code\u0026gt; words but can be easily modified for \u0026lt;code\u0026gt;64 bit\u0026lt;/code\u0026gt; words.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you happen to be using Java, the built-in method \u0026lt;code\u0026gt;Integer.bitCount\u0026lt;/code\u0026gt; will do that.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I got bored, and timed a billion iterations of three approaches. Compiler is gcc -O3. CPU is whatever they put in the 1st gen Macbook Pro.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Fastest is the following, at 3.7 seconds:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;static unsigned char wordbits[65536] = { bitcounts of ints between 0 and 65535 };\nstatic int popcount( unsigned int i )\n{\n    return( wordbits[i\u0026amp;amp;0xFFFF] + wordbits[i\u0026amp;gt;\u0026amp;gt;16] );\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Second place goes to the same code but looking up 4 bytes instead of 2 halfwords. That took around 5.5 seconds.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Third place goes to the bit-twiddling \u0026apos;sideways addition\u0026apos; approach, which took 8.6 seconds.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Fourth place goes to GCC\u0026apos;s __builtin_popcount(), at a shameful 11 seconds.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The counting one-bit-at-a-time approach was waaaay slower, and I got bored of waiting for it to complete.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So if you care about performance above all else then use the first approach. If you care, but not enough to spend 64Kb of RAM on it, use the second approach. Otherwise use the readable (but slow) one-bit-at-a-time approach.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It\u0026apos;s hard to think of a situation where you\u0026apos;d want to use the bit-twiddling approach.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Edit: Similar results \u0026lt;a href=\u0026quot;http://www.dalkescientific.com/writings/diary/archive/2008/07/03/hakmem_and_other_popcounts.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;unsigned int count_bit(unsigned int x)\n{\n  x = (x \u0026amp;amp; 0x55555555) + ((x \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 0x55555555);\n  x = (x \u0026amp;amp; 0x33333333) + ((x \u0026amp;gt;\u0026amp;gt; 2) \u0026amp;amp; 0x33333333);\n  x = (x \u0026amp;amp; 0x0F0F0F0F) + ((x \u0026amp;gt;\u0026amp;gt; 4) \u0026amp;amp; 0x0F0F0F0F);\n  x = (x \u0026amp;amp; 0x00FF00FF) + ((x \u0026amp;gt;\u0026amp;gt; 8) \u0026amp;amp; 0x00FF00FF);\n  x = (x \u0026amp;amp; 0x0000FFFF) + ((x \u0026amp;gt;\u0026amp;gt; 16)\u0026amp;amp; 0x0000FFFF);\n  return x;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Let me explain this algorithm.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This algorithm is based on Divide and Conquer Algorithm. Suppose there is a 8bit integer 213(11010101 in binary), the algorithm works like this(each time merge two neighbor blocks):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;+-------------------------------+\n| 1 | 1 | 0 | 1 | 0 | 1 | 0 | 1 |  \u0026amp;lt;- x\n|  1 0  |  0 1  |  0 1  |  0 1  |  \u0026amp;lt;- first time merge\n|    0 0 1 1    |    0 0 1 0    |  \u0026amp;lt;- second time merge\n|        0 0 0 0 0 1 0 1        |  \u0026amp;lt;- third time ( answer = 00000101 = 5)\n+-------------------------------+\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Why not iteratively divide by 2?\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;count = 0\nwhile n \u0026amp;gt; 0\n  if (n % 2) == 1\n    count += 1\n  n /= 2  \n\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I agree that this isn\u0026apos;t the fastest, but \u0026quot;best\u0026quot; is somewhat ambiguous. I\u0026apos;d argue though that \u0026quot;best\u0026quot; should have an element of clarity\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is one of those questions where it helps to know your micro-architecture.   I just timed two variants under gcc 4.3.3 compiled with -O3 using C++ inlines to eliminate function call overhead, one billion iterations, keeping the running sum of all counts to ensure the compiler doesn\u0026apos;t remove anything important, using rdtsc for timing (clock cycle precise).  \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;inline int pop2(unsigned x, unsigned y)\n{\n    x = x - ((x \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 0x55555555);\n    y = y - ((y \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 0x55555555);\n    x = (x \u0026amp;amp; 0x33333333) + ((x \u0026amp;gt;\u0026amp;gt; 2) \u0026amp;amp; 0x33333333);\n    y = (y \u0026amp;amp; 0x33333333) + ((y \u0026amp;gt;\u0026amp;gt; 2) \u0026amp;amp; 0x33333333);\n    x = (x + (x \u0026amp;gt;\u0026amp;gt; 4)) \u0026amp;amp; 0x0F0F0F0F;\n    y = (y + (y \u0026amp;gt;\u0026amp;gt; 4)) \u0026amp;amp; 0x0F0F0F0F;\n    x = x + (x \u0026amp;gt;\u0026amp;gt; 8);\n    y = y + (y \u0026amp;gt;\u0026amp;gt; 8);\n    x = x + (x \u0026amp;gt;\u0026amp;gt; 16);\n    y = y + (y \u0026amp;gt;\u0026amp;gt; 16);\n    return (x+y) \u0026amp;amp; 0x000000FF;\n}\n\u0026lt;/pre\u0026gt; \n\n\u0026lt;p\u0026gt;The unmodified Hacker\u0026apos;s Delight took 12.2 gigacycles.  My parallel version (counting twice as many bits) runs in 13.0 gigacycles.  10.5s total elapsed for both together on a 2.4GHz Core Duo.  25 gigacycles = just over 10 seconds at this clock frequency, so I\u0026apos;m confident my timings are right.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This has to do with instruction dependency chains, which are very bad for this algorithm.  I could nearly double the speed again by using a pair of 64-bit registers.  In fact, if I was clever and added x+y a little sooner I could shave off some shifts.  The 64-bit version with some small tweaks would come out about even, but count twice as many bits again.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;With 128 bit SIMD registers, yet another factor of two, and the SSE instruction sets often have clever short-cuts, too.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There\u0026apos;s no reason for the code to be especially transparent.  The interface is simple, the algorithm can be referenced on-line in many places, and it\u0026apos;s amenable to comprehensive unit test.  The programmer who stumbles upon it might even learn something.  These bit operations are extremely natural at the machine level.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;OK, I decided to bench the tweaked 64-bit version.  For this one  sizeof(unsigned long) == 8 \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;inline int pop2(unsigned long x, unsigned long y)\n{\n    x = x - ((x \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 0x5555555555555555);\n    y = y - ((y \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 0x5555555555555555);\n    x = (x \u0026amp;amp; 0x3333333333333333) + ((x \u0026amp;gt;\u0026amp;gt; 2) \u0026amp;amp; 0x3333333333333333);\n    y = (y \u0026amp;amp; 0x3333333333333333) + ((y \u0026amp;gt;\u0026amp;gt; 2) \u0026amp;amp; 0x3333333333333333);\n    x = (x + (x \u0026amp;gt;\u0026amp;gt; 4)) \u0026amp;amp; 0x0F0F0F0F0F0F0F0F;\n    y = (y + (y \u0026amp;gt;\u0026amp;gt; 4)) \u0026amp;amp; 0x0F0F0F0F0F0F0F0F;\n    x = x + y; \n    x = x + (x \u0026amp;gt;\u0026amp;gt; 8);\n    x = x + (x \u0026amp;gt;\u0026amp;gt; 16);\n    x = x + (x \u0026amp;gt;\u0026amp;gt; 32); \n    return x \u0026amp;amp; 0xFF;\n}\n\u0026lt;/pre\u0026gt; \n\n\u0026lt;p\u0026gt;That looks about right (I\u0026apos;m not testing carefully, though).   Now the timings come out at 10.70 gigacycles / 14.1 gigacycles.   That later number summed 128 billion bits and corresponds to 5.9s elapsed on this machine.   The non-parallel version speeds up a tiny bit because I\u0026apos;m running in 64-bit mode and it likes 64-bit registers slightly better than 32-bit registers.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Let\u0026apos;s see if there\u0026apos;s a bit more OOO pipelining to be had here.   This was a bit more involved, so I actually tested a bit.  Each term alone sums to 64, all combined sum to 256.  \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;inline int pop4(unsigned long x, unsigned long y, \n                unsigned long u, unsigned long v)\n{\n  enum { m1 = 0x5555555555555555, \n         m2 = 0x3333333333333333, \n         m3 = 0x0F0F0F0F0F0F0F0F, \n         m4 = 0x000000FF000000FF };\n\n    x = x - ((x \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; m1);\n    y = y - ((y \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; m1);\n    u = u - ((u \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; m1);\n    v = v - ((v \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; m1);\n    x = (x \u0026amp;amp; m2) + ((x \u0026amp;gt;\u0026amp;gt; 2) \u0026amp;amp; m2);\n    y = (y \u0026amp;amp; m2) + ((y \u0026amp;gt;\u0026amp;gt; 2) \u0026amp;amp; m2);\n    u = (u \u0026amp;amp; m2) + ((u \u0026amp;gt;\u0026amp;gt; 2) \u0026amp;amp; m2);\n    v = (v \u0026amp;amp; m2) + ((v \u0026amp;gt;\u0026amp;gt; 2) \u0026amp;amp; m2);\n    x = x + y; \n    u = u + v; \n    x = (x \u0026amp;amp; m3) + ((x \u0026amp;gt;\u0026amp;gt; 4) \u0026amp;amp; m3);\n    u = (u \u0026amp;amp; m3) + ((u \u0026amp;gt;\u0026amp;gt; 4) \u0026amp;amp; m3);\n    x = x + u; \n    x = x + (x \u0026amp;gt;\u0026amp;gt; 8);\n    x = x + (x \u0026amp;gt;\u0026amp;gt; 16);\n    x = x \u0026amp;amp; m4; \n    x = x + (x \u0026amp;gt;\u0026amp;gt; 32);\n    return x \u0026amp;amp; 0x000001FF;\n}\n\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I was excited for a moment, but it turns out gcc is playing inline tricks with -O3 even though I\u0026apos;m not using the inline keyword in some tests.  When I let gcc play tricks, a billion calls to pop4() takes 12.56 gigacycles, but I determined it was folding arguments as constant expressions.   A more realistic number appears to be 19.6gc for another 30% speed-up.  My test loop now looks like this, making sure each argument is different enough to stop gcc from playing tricks.   \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;   hitime b4 = rdtsc(); \n   for (unsigned long i = 10L * 1000*1000*1000; i \u0026amp;lt; 11L * 1000*1000*1000; ++i) \n      sum += pop4 (i,  i^1, ~i, i|1); \n   hitime e4 = rdtsc(); \n\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;256 billion bits summed in 8.17s elapsed.  Works out to 1.02s for 32 million bits as benchmarked in the 16-bit table lookup.  Can\u0026apos;t compare directly, because the other bench doesn\u0026apos;t give a clock speed, but looks like I\u0026apos;ve slapped the snot out of the 64KB table edition, which is a tragic use of L1 cache in the first place.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Update: decided to do the obvious and create pop6() by adding four more duplicated lines.  Came out to 22.8gc, 384 billion bits summed in 9.5s elapsed.   So there\u0026apos;s another 20%   Now at 800ms for 32 billion bits.  \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The Hacker\u0026apos;s Delight bit-twiddling becomes so much clearer when you write out the bit patterns.  \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;unsigned int bitCount(unsigned int x)\n{\n  x = ((x \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 0b01010101010101010101010101010101)\n     + (x       \u0026amp;amp; 0b01010101010101010101010101010101);\n  x = ((x \u0026amp;gt;\u0026amp;gt; 2) \u0026amp;amp; 0b00110011001100110011001100110011)\n     + (x       \u0026amp;amp; 0b00110011001100110011001100110011); \n  x = ((x \u0026amp;gt;\u0026amp;gt; 4) \u0026amp;amp; 0b00001111000011110000111100001111)\n     + (x       \u0026amp;amp; 0b00001111000011110000111100001111); \n  x = ((x \u0026amp;gt;\u0026amp;gt; 8) \u0026amp;amp; 0b00000000111111110000000011111111)\n     + (x       \u0026amp;amp; 0b00000000111111110000000011111111); \n  x = ((x \u0026amp;gt;\u0026amp;gt; 16)\u0026amp;amp; 0b00000000000000001111111111111111)\n     + (x       \u0026amp;amp; 0b00000000000000001111111111111111); \n  return x;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The first step adds the even bits to the odd bits, producing a sum of bits in each two.  The other steps add high-order chunks to low-order chunks, doubling the chunk size all the way up, until we have the final count taking up the entire int.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;For a happy medium between a 2\u0026lt;sup\u0026gt;32\u0026lt;/sup\u0026gt; lookup table and iterating through each bit individually:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;int bitcount(unsigned int num){\n    int count = 0;\n    static int nibblebits[] =\n        {0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4};\n    for(; num != 0; num \u0026amp;gt;\u0026amp;gt;= 4)\n        count += nibblebits[num \u0026amp;amp; 0x0f];\n    return count;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;From \u0026lt;a href=\u0026quot;http://ctips.pbwiki.com/CountBits\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://ctips.pbwiki.com/CountBits\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This can be done in \u0026lt;code\u0026gt;O(k)\u0026lt;/code\u0026gt;, where \u0026lt;code\u0026gt;k\u0026lt;/code\u0026gt; is the number of bits set.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;int NumberOfSetBits(int n)\n{\n    int count = 0;\n\n    while (n){\n        ++ count;\n        n = (n - 1) \u0026amp;amp; n;\n    }\n\n    return count;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It\u0026apos;s not the fastest or best solution, but I found the same question in my way, and I started to think and think. finally I realized that it can be done like this if you get the problem from mathematical side, and draw a graph, then you find that it\u0026apos;s a function which has some periodic part, and then you realize the difference between the periods... so here you go:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;unsigned int f(unsigned int x)\n{\n    switch (x) {\n        case 0:\n            return 0;\n        case 1:\n            return 1;\n        case 2:\n            return 1;\n        case 3:\n            return 2;\n        default:\n            return f(x/4) + f(x%4);\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I think the \u0026lt;a href=\u0026quot;https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Brian Kernighan\u0026apos;s\u0026lt;/a\u0026gt; method will be useful too...\nIt goes through as many iterations as there are set bits. So if we have a 32-bit word with only the high bit set, then it will only go once through the loop.  \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;int countSetBits(unsigned int n) { \n    unsigned int n; // count the number of bits set in n\n    unsigned int c; // c accumulates the total bits set in n\n    for (c=0;n\u0026amp;gt;0;n=n\u0026amp;amp;(n-1)) c++; \n    return c; \n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Published in 1988, the C Programming Language 2nd Ed. (by Brian W. Kernighan and Dennis M. Ritchie) mentions this in exercise 2-9. On April 19, 2006 Don Knuth pointed out to me that this method \u0026quot;was first published by Peter Wegner in CACM 3 (1960), 322. (Also discovered independently by Derrick Lehmer and published in 1964 in a book edited by Beckenbach.)\u0026quot;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The function you are looking for is often called the \u0026quot;sideways sum\u0026quot; or \u0026quot;population count\u0026quot; of a binary number.  Knuth discusses it in pre-Fascicle 1A, pp11-12 (although there was a brief reference in Volume 2, 4.6.3-(7).)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;em\u0026gt;locus classicus\u0026lt;/em\u0026gt; is Peter Wegner\u0026apos;s article \u0026quot;A Technique for Counting Ones in a Binary Computer\u0026quot;, from the \u0026lt;a href=\u0026quot;http://cacm.acm.org/magazines/1960/5/14709-a-technique-for-counting-ones-in-a-binary-computer/abstract\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;em\u0026gt;Communications of the ACM\u0026lt;/em\u0026gt;, Volume 3 (1960) Number 5, page 322\u0026lt;/a\u0026gt;.  He gives two different algorithms there, one optimized for numbers expected to be \u0026quot;sparse\u0026quot; (i.e., have a small number of ones) and one for the opposite case.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;get_bits_set\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; v)\u0026lt;/span\u0026gt;\n    {\n      \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; c; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// c accumulates the total bits set in v\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (c = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; v\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; c++)\n        {\n            v \u0026amp;amp;= v - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// clear the least significant bit set\u0026lt;/span\u0026gt;\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; c;\n    }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Few open questions:-\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;If the number is negative then?\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the number is 1024 , then the \u0026quot;iteratively divide by 2\u0026quot; method will iterate 10 times.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;we can modify the algo to support the negative number as follows:-\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;count = 0\nwhile n != 0\nif ((n % 2) == 1 || (n % 2) == -1\n    count += 1\n  n /= 2  \nreturn count\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;now to overcome the second problem we can write the algo like:-\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;int bit_count(int num)\n{\n    int count=0;\n    while(num)\n    {\n        num=(num)\u0026amp;amp;(num-1);\n        count++;\n    }\n    return count;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;for complete reference see :\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://goursaha.freeoda.com/Miscellaneous/IntegerBitCount.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://goursaha.freeoda.com/Miscellaneous/IntegerBitCount.html\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I use the below code which is more intuitive.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;int countSetBits(int n) {\n    return !n ? 0 : 1 + countSetBits(n \u0026amp;amp; (n-1));\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Logic : n \u0026amp;amp; (n-1)  resets the last set bit of n.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;P.S : I know this is not O(1) solution, albeit an interesting solution.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;What do you means with \u0026quot;Best algorithm\u0026quot;? The shorted code or the fasted code? Your code look very elegant and it has a constant execution time. The code is also very short.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But if the speed is the major factor and not the code size then I think the follow can be faster:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;       static final int[] BIT_COUNT = { 0, 1, 1, ... 256 values with a bitsize of a byte ... };\n        static int bitCountOfByte( int value ){\n            return BIT_COUNT[ value \u0026amp;amp; 0xFF ];\n        }\n\n        static int bitCountOfInt( int value ){\n            return bitCountOfByte( value ) \n                 + bitCountOfByte( value \u0026amp;gt;\u0026amp;gt; 8 ) \n                 + bitCountOfByte( value \u0026amp;gt;\u0026amp;gt; 16 ) \n                 + bitCountOfByte( value \u0026amp;gt;\u0026amp;gt; 24 );\n        }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I think that this will not more faster for a 64 bit value but a 32 bit value can be faster.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I wrote a fast bitcount macro for RISC machines in about 1990.  It does not use advanced arithmetic (multiplication, division, %), memory fetches (way too slow), branches (way too slow), but it does assume the CPU has a 32-bit barrel shifter (in other words, \u0026amp;gt;\u0026amp;gt; 1 and \u0026amp;gt;\u0026amp;gt; 32 take the same amount of cycles.)  It assumes that small constants (such as 6, 12, 24) cost nothing to load into the registers, or are stored in temporaries and reused over and over again.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;With these assumptions, it counts 32 bits in about 16 cycles/instructions on most RISC machines.  Note that 15 instructions/cycles is close to a lower bound on the number of cycles or instructions, because it seems to take at least 3 instructions (mask, shift, operator) to cut the number of addends in half, so log_2(32) = 5, 5 x 3 = 15 instructions is a quasi-lowerbound.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;#define BitCount(X,Y)           \\\n                Y = X - ((X \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 033333333333) - ((X \u0026amp;gt;\u0026amp;gt; 2) \u0026amp;amp; 011111111111); \\\n                Y = ((Y + (Y \u0026amp;gt;\u0026amp;gt; 3)) \u0026amp;amp; 030707070707); \\\n                Y =  (Y + (Y \u0026amp;gt;\u0026amp;gt; 6)); \\\n                Y = (Y + (Y \u0026amp;gt;\u0026amp;gt; 12) + (Y \u0026amp;gt;\u0026amp;gt; 24)) \u0026amp;amp; 077;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here is a secret to the first and most complex step:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;input output\nAB    CD             Note\n00    00             = AB\n01    01             = AB\n10    01             = AB - (A \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 0x1\n11    10             = AB - (A \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 0x1\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;so if I take the 1st column (A) above, shift it right 1 bit, and subtract it from AB, I get the output (CD).  The extension to 3 bits is similar; you can check it with an 8-row boolean table like mine above if you wish.\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Don Gillies\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;if you\u0026apos;re using C++ another option is to use template metaprogramming:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;// recursive template to sum bits in an int\ntemplate \u0026amp;lt;int BITS\u0026amp;gt;\nint countBits(int val) {\n        // return the least significant bit plus the result of calling ourselves with\n        // .. the shifted value\n        return (val \u0026amp;amp; 0x1) + countBits\u0026amp;lt;BITS-1\u0026amp;gt;(val \u0026amp;gt;\u0026amp;gt; 1);\n}\n\n// template specialisation to terminate the recursion when there\u0026apos;s only one bit left\ntemplate\u0026amp;lt;\u0026amp;gt;\nint countBits\u0026amp;lt;1\u0026amp;gt;(int val) {\n        return val \u0026amp;amp; 0x1;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;usage would be:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;// to count bits in a byte/char (this returns 8)\ncountBits\u0026amp;lt;8\u0026amp;gt;( 255 )\n\n// another byte (this returns 7)\ncountBits\u0026amp;lt;8\u0026amp;gt;( 254 )\n\n// counting bits in a word/short (this returns 1)\ncountBits\u0026amp;lt;16\u0026amp;gt;( 256 )\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;you could of course further expand this template to use different types (even auto-detecting bit size) but I\u0026apos;ve kept it simple for clarity.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;edit: forgot to mention this is good because it \u0026lt;em\u0026gt;should\u0026lt;/em\u0026gt; work in any C++ compiler and it basically just unrolls your loop for you if a constant value is used for the bit count\u0026lt;/strong\u0026gt; (in other words, I\u0026apos;m pretty sure it\u0026apos;s the fastest general method you\u0026apos;ll find)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;what you can do is \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;while(n){\n    n=n\u0026amp;amp;(n-1);\n    count++;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;the logic behind this is the bits of n-1 is inverted from rightmost set bit of n.\nif n=6 i.e 110\nthen 5 is 101 the bits are inverted from rightmost set bit of n.\nso if we \u0026amp;amp; these two we will make the rightmost bit 0 in every iteration and always go to the next rightmost set bit.Hence, counting the set bit.The worst time complexity will be O(logn) when every bit is set.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I\u0026apos;m particularly fond of this example from the fortune file:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;#define BITCOUNT(x)    (((BX_(x)+(BX_(x)\u0026amp;gt;\u0026amp;gt;4)) \u0026amp;amp; 0x0F0F0F0F) % 255)\n#define BX_(x)         ((x) - (((x)\u0026amp;gt;\u0026amp;gt;1)\u0026amp;amp;0x77777777)\n                             - (((x)\u0026amp;gt;\u0026amp;gt;2)\u0026amp;amp;0x33333333)\n                             - (((x)\u0026amp;gt;\u0026amp;gt;3)\u0026amp;amp;0x11111111))\n\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I like it best because it\u0026apos;s so pretty!\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Java JDK1.5\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Integer.bitCount(n);\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;where n is the number whose 1\u0026apos;s are to be counted.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;check also,\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;Integer.highestOneBit(n);\nInteger.lowestOneBit(n);\nInteger.numberOfLeadingZeros(n);\nInteger.numberOfTrailingZeros(n);\n\n//Beginning with the value 1, rotate left 16 times\n     n = 1;\n         for (int i = 0; i \u0026amp;lt; 16; i++) {\n            n = Integer.rotateLeft(n, 1);\n            System.out.println(n);\n         }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Fast C# solution using pre-calculated table of Byte bit counts with branching on input size.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;public static class BitCount\n{\n    public static uint GetSetBitsCount(uint n)\n    {\n        var counts = BYTE_BIT_COUNTS;\n        return n \u0026amp;lt;= 0xff ? counts[n]\n             : n \u0026amp;lt;= 0xffff ? counts[n \u0026amp;amp; 0xff] + counts[n \u0026amp;gt;\u0026amp;gt; 8]\n             : n \u0026amp;lt;= 0xffffff ? counts[n \u0026amp;amp; 0xff] + counts[(n \u0026amp;gt;\u0026amp;gt; 8) \u0026amp;amp; 0xff] + counts[(n \u0026amp;gt;\u0026amp;gt; 16) \u0026amp;amp; 0xff]\n             : counts[n \u0026amp;amp; 0xff] + counts[(n \u0026amp;gt;\u0026amp;gt; 8) \u0026amp;amp; 0xff] + counts[(n \u0026amp;gt;\u0026amp;gt; 16) \u0026amp;amp; 0xff] + counts[(n \u0026amp;gt;\u0026amp;gt; 24) \u0026amp;amp; 0xff];\n    }\n\n    public static readonly uint[] BYTE_BIT_COUNTS = \n    {\n        0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8\n    };\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I found an implementation of bit counting in an array with using of SIMD instruction (SSSE3 and AVX2). It has in 2-2.5 times better performance than if it will use __popcnt64 intrinsic function.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;SSSE3 version:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;#include \u0026amp;lt;smmintrin.h\u0026amp;gt;\n#include \u0026amp;lt;stdint.h\u0026amp;gt;\n\nconst __m128i Z = _mm_set1_epi8(0x0);\nconst __m128i F = _mm_set1_epi8(0xF);\n//Vector with pre-calculated bit count:\nconst __m128i T = _mm_setr_epi8(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);\n\nuint64_t BitCount(const uint8_t * src, size_t size)\n{\n    __m128i _sum =  _mm128_setzero_si128();\n    for (size_t i = 0; i \u0026amp;lt; size; i += 16)\n    {\n        //load 16-byte vector\n        __m128i _src = _mm_loadu_si128((__m128i*)(src + i));\n        //get low 4 bit for every byte in vector\n        __m128i lo = _mm_and_si128(_src, F);\n        //sum precalculated value from T\n        _sum = _mm_add_epi64(_sum, _mm_sad_epu8(Z, _mm_shuffle_epi8(T, lo)));\n        //get high 4 bit for every byte in vector\n        __m128i hi = _mm_and_si128(_mm_srli_epi16(_src, 4), F);\n        //sum precalculated value from T\n        _sum = _mm_add_epi64(_sum, _mm_sad_epu8(Z, _mm_shuffle_epi8(T, hi)));\n    }\n    uint64_t sum[2];\n    _mm_storeu_si128((__m128i*)sum, _sum);\n    return sum[0] + sum[1];\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;AVX2 version:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;#include \u0026amp;lt;immintrin.h\u0026amp;gt;\n#include \u0026amp;lt;stdint.h\u0026amp;gt;\n\nconst __m256i Z = _mm256_set1_epi8(0x0);\nconst __m256i F = _mm256_set1_epi8(0xF);\n//Vector with pre-calculated bit count:\nconst __m256i T = _mm256_setr_epi8(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, \n                                   0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);\n\nuint64_t BitCount(const uint8_t * src, size_t size)\n{\n    __m256i _sum =  _mm256_setzero_si256();\n    for (size_t i = 0; i \u0026amp;lt; size; i += 32)\n    {\n        //load 32-byte vector\n        __m256i _src = _mm256_loadu_si256((__m256i*)(src + i));\n        //get low 4 bit for every byte in vector\n        __m256i lo = _mm256_and_si256(_src, F);\n        //sum precalculated value from T\n        _sum = _mm256_add_epi64(_sum, _mm256_sad_epu8(Z, _mm256_shuffle_epi8(T, lo)));\n        //get high 4 bit for every byte in vector\n        __m256i hi = _mm256_and_si256(_mm256_srli_epi16(_src, 4), F);\n        //sum precalculated value from T\n        _sum = _mm256_add_epi64(_sum, _mm256_sad_epu8(Z, _mm256_shuffle_epi8(T, hi)));\n    }\n    uint64_t sum[4];\n    _mm256_storeu_si256((__m256i*)sum, _sum);\n    return sum[0] + sum[1] + sum[2] + sum[3];\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I always use this in Competitive Programming and it\u0026apos;s easy to write and efficient:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;#include \u0026amp;lt;bits/stdc++.h\u0026amp;gt;\n\nusing namespace std;\n\nint countOnes(int n) {\n    bitset\u0026amp;lt;32\u0026amp;gt; b(n);\n    return b.count();\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;C++20 \u0026lt;code\u0026gt;std::popcount\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The following proposal has been merged \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0553r4.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0553r4.html\u0026lt;/a\u0026gt; and should add it to a the \u0026lt;code\u0026gt;\u0026amp;lt;bit\u0026amp;gt;\u0026lt;/code\u0026gt; header.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I expect the usage to be like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;#include \u0026amp;lt;bit\u0026amp;gt;\n#include \u0026amp;lt;iostream\u0026amp;gt;\n\nint main() {\n    std::cout \u0026amp;lt;\u0026amp;lt; std::popcount(0x55) \u0026amp;lt;\u0026amp;lt; std::endl;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;ll give it a try when support arrives to GCC, GCC 9.1.0 with \u0026lt;code\u0026gt;g++-9 -std=c++2a\u0026lt;/code\u0026gt; still doesn\u0026apos;t support it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The proposal says:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Header: \u0026lt;code\u0026gt;\u0026amp;lt;bit\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;namespace std {\n\n  // 25.5.6, counting\n  template\u0026amp;lt;class T\u0026amp;gt;\n    constexpr int popcount(T x) noexcept;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;and:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;template\u0026amp;lt;class T\u0026amp;gt;\n  constexpr int popcount(T x) noexcept;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n  \n  \u0026lt;p\u0026gt;Constraints: T is an unsigned integer type (3.9.1 [basic.fundamental]).\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;Returns: The number of 1 bits in the value of x.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;std::rotl\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;std::rotr\u0026lt;/code\u0026gt; were also added to do circular bit rotations: \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/776508/best-practices-for-circular-shift-rotate-operations-in-c/57285854#57285854\u0026quot;\u0026gt;Best practices for circular shift (rotate) operations in C++\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are many algorithm to count the set bits; but i think the best one is the faster one!\nYou can see the detailed on this page:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://graphics.stanford.edu/~seander/bithacks.html\u0026quot;\u0026gt;Bit Twiddling Hacks\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I suggest this one:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Counting bits set in 14, 24, or 32-bit words using 64-bit instructions\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;unsigned int v; // count the number of bits set in v\nunsigned int c; // c accumulates the total bits set in v\n\n// option 1, for at most 14-bit values in v:\nc = (v * 0x200040008001ULL \u0026amp;amp; 0x111111111111111ULL) % 0xf;\n\n// option 2, for at most 24-bit values in v:\nc =  ((v \u0026amp;amp; 0xfff) * 0x1001001001001ULL \u0026amp;amp; 0x84210842108421ULL) % 0x1f;\nc += (((v \u0026amp;amp; 0xfff000) \u0026amp;gt;\u0026amp;gt; 12) * 0x1001001001001ULL \u0026amp;amp; 0x84210842108421ULL) \n     % 0x1f;\n\n// option 3, for at most 32-bit values in v:\nc =  ((v \u0026amp;amp; 0xfff) * 0x1001001001001ULL \u0026amp;amp; 0x84210842108421ULL) % 0x1f;\nc += (((v \u0026amp;amp; 0xfff000) \u0026amp;gt;\u0026amp;gt; 12) * 0x1001001001001ULL \u0026amp;amp; 0x84210842108421ULL) % \n     0x1f;\nc += ((v \u0026amp;gt;\u0026amp;gt; 24) * 0x1001001001001ULL \u0026amp;amp; 0x84210842108421ULL) % 0x1f;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This method requires a 64-bit CPU with fast modulus division to be efficient. The first option takes only 3 operations; the second option takes 10; and the third option takes 15. \u0026lt;/p\u0026gt;\n    "],"comment":["\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;This is the Hamming weight BTW.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/4615/purfideas\u0026quot; title=\u0026quot;3,230 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Purfideas\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment20763_109023\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2008-09-20 19:17:27Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 20, 2008 at 19:17\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;What\u0026apos;s a real-world application for this? (This isn\u0026apos;t to be taken as a criticism--I\u0026apos;m just curious.)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/364123/jonmorgan\u0026quot; title=\u0026quot;2,540 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;jonmorgan\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment4813304_109023\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-12-10 20:59:22Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 10, 2010 at 20:59\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Calculation of parity bit (look it up), which was used as simple error detection in communication.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/395718/dialecticus\u0026quot; title=\u0026quot;15,946 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Dialecticus\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment4814840_109023\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-12-11 00:28:09Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 11, 2010 at 0:28\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Dialecticus, calculating a parity bit is \u0026lt;a href=\u0026quot;http://www-graphics.stanford.edu/~seander/bithacks.html#ParityParallel\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;cheaper\u0026lt;/a\u0026gt; than calculating the Hamming weight\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/12048/finnw\u0026quot; title=\u0026quot;46,800 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;finnw\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment6898564_109023\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-05-12 12:14:31Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 12, 2011 at 12:14\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@spookyjon Let\u0026apos;s say you have a graph represented as an adjacency matrix, which is essentially a bit set. If you want to calculate the number of edges of a vertex, it boils down to calculating the Hamming weight of one row in the bit set.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/417501/fuz\u0026quot; title=\u0026quot;83,697 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;fuz\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment9384559_109023\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-10-10 16:02:42Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 10, 2011 at 16:02\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;ha! love the NumberOfSetBits() function, but good luck getting that through a code review. :-)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/44330/jason-s\u0026quot; title=\u0026quot;179,271 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Jason S\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment1663942_109025\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-11-22 06:51:19Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 22, 2009 at 6:51\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Maybe it should use \u0026lt;code\u0026gt;unsigned int\u0026lt;/code\u0026gt;, to easily show that it is free of any sign bit complications. Also would \u0026lt;code\u0026gt;uint32_t\u0026lt;/code\u0026gt; be safer, as in, you get what you expect on all platforms?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/60075/craig-mcqueen\u0026quot; title=\u0026quot;39,856 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Craig McQueen\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment1808591_109025\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-12-15 02:18:41Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 15, 2009 at 2:18\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@nonnb: Actually, as written, the code is buggy and needs maintenance. \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; is implementation-defined for negative values. The argument needs to be changed (or cast) to \u0026lt;code\u0026gt;unsigned\u0026lt;/code\u0026gt;, and since the code is 32-bit-specific, it should probably be using \u0026lt;code\u0026gt;uint32_t\u0026lt;/code\u0026gt;.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/379897/r-github-stop-helping-ice\u0026quot; title=\u0026quot;202,279 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;R.. GitHub STOP HELPING ICE\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment6937839_109025\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-05-14 21:55:39Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 14, 2011 at 21:55\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;It\u0026apos;s not really magic.  It\u0026apos;s adding sets of bits but doing so with some clever optimizations.  The wikipedia link given in the answer does a good job of explaining what\u0026apos;s going on but I\u0026apos;ll go line by line.  1) Count up the number of bits in every pair of bits, putting that count in that pair of bits (you\u0026apos;ll have 00, 01, or 10); the \u0026quot;clever\u0026quot; bit here is the subtract that avoids one mask. 2) Add pairs of those sums of bitpairs into their corresponding nibbles; nothing clever here but each nibble will now have a value 0-4.  (cont\u0026apos;d)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/65845/dash-tom-bang\u0026quot; title=\u0026quot;16,875 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;dash-tom-bang\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment18837480_109025\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-12-05 00:42:48Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 5, 2012 at 0:42\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Another note, this extends to 64 and 128 bit registers by simply extending the constants appropriately.  Interestingly (to me), those constants are also ~0 / 3, 5, 17, and 255; the former three being 2^n+1.  This all makes more sense the more you stare at it and think about it in the shower.  :)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/65845/dash-tom-bang\u0026quot; title=\u0026quot;16,875 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;dash-tom-bang\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment18837547_109025\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-12-05 00:48:15Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 5, 2012 at 0:48\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I agree that this is good practice in general, but on XCode/OSX/Intel I found it to generate slower code than most of the suggestions posted here. See my answer for details.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;span class=\u0026quot;comment-user\u0026quot;\u0026gt;Mike F\u0026lt;/span\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment32418_109069\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2008-09-25 03:29:58Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 25, 2008 at 3:29\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;The Intel i5/i7 has the SSE4 instruction POPCNT which does it, using general purpose registers.  GCC on my system does not emit that instruction using this intrinsic, i guess because of no -march=nehalem option yet.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/115567/matja\u0026quot; title=\u0026quot;3,844 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;matja\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment1676321_109069\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-11-24 10:31:53Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 24, 2009 at 10:31\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@matja, my GCC 4.4.1 emits the popcnt instruction if I compile with -msse4.2\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/15955/nils-pipenbrinck\u0026quot; title=\u0026quot;80,817 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Nils Pipenbrinck\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment1677151_109069\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-11-24 13:29:35Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 24, 2009 at 13:29\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;use c++\u0026apos;s \u0026lt;code\u0026gt;std::bitset::count\u0026lt;/code\u0026gt;.  after inlining this compiles to a single \u0026lt;code\u0026gt;__builtin_popcount\u0026lt;/code\u0026gt; call.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/28817/deft-code\u0026quot; title=\u0026quot;54,666 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;deft_code\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment3829869_109069\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-09-04 18:18:38Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 4, 2010 at 18:18\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@nlucaroni Well, yes. Times are changing. I\u0026apos;ve wrote this answer in 2008. Nowadays we have native popcount and the intrinsic will compile down to a single assembler statement if the platform allows that.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/15955/nils-pipenbrinck\u0026quot; title=\u0026quot;80,817 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Nils Pipenbrinck\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment26046752_109069\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-07-24 19:45:44Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 24, 2013 at 19:45\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Instead of dividing by 2 and commenting it as \u0026quot;shift bits...\u0026quot;, you should just use the shift operator (\u0026amp;gt;\u0026amp;gt;) and leave out the comment.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/19719/indiv\u0026quot; title=\u0026quot;16,678 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;indiv\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment32441_109915\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2008-09-25 03:42:31Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 25, 2008 at 3:42\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;wouldn\u0026apos;t it make more sense to replace \u0026lt;code\u0026gt;if ((value \u0026amp;amp; 1) == 1) { count++; }\u0026lt;/code\u0026gt; with \u0026lt;code\u0026gt;count += value \u0026amp;amp; 1\u0026lt;/code\u0026gt;?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/216292/ponkadoodle\u0026quot; title=\u0026quot;5,663 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Ponkadoodle\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment2733732_109915\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-04-25 19:04:49Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 25, 2010 at 19:04\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;No, the best solution isn\u0026apos;t the one most readable in this case. Here the best algorithm is the fastest one.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/385378/nikic\u0026quot; title=\u0026quot;99,016 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;NikiC\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment3998272_109915\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-09-23 07:55:16Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 23, 2010 at 7:55\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;That\u0026apos;s entirely your opinion, @nikic, although you\u0026apos;re free to downvote me, obviously. There was no mention in the question as to how to quantify \u0026quot;best\u0026quot;, the words \u0026quot;performance\u0026quot; or \u0026quot;fast\u0026quot; can be seen nowhere. That\u0026apos;s why I opted for readable.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/14860/paxdiablo\u0026quot; title=\u0026quot;818,480 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;paxdiablo\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment3998738_109915\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-09-23 08:57:06Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 23, 2010 at 8:57\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I am reading this answer 3 years later, and I find it as the best answer because it is readable and has more comments. period.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2065936/waka-waka-waka\u0026quot; title=\u0026quot;975 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;waka-waka-waka\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment29218747_109915\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-10-30 04:09:21Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 30, 2013 at 4:09\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;The Java method \u0026lt;code\u0026gt;Integer.bitCount(int)\u0026lt;/code\u0026gt; uses this same exact implementation.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1192716/marco-bolis\u0026quot; title=\u0026quot;1,161 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Marco Bolis\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment43977423_109117\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-01-05 16:33:22Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 5, 2015 at 16:33\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Having a little trouble following this - how would it change if we only cared about 16-bit values, instead of 32-bit?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/191354/jeremy-blum\u0026quot; title=\u0026quot;488 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Jeremy Blum\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment45671936_109117\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-02-24 07:23:40Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 24, 2015 at 7:23\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Maybe hackers delight is delightful, but I would give a good kicking to anybody calling this \u0026lt;code\u0026gt;pop\u0026lt;/code\u0026gt; instead of \u0026lt;code\u0026gt;population_count\u0026lt;/code\u0026gt; (or \u0026lt;code\u0026gt;pop_cnt\u0026lt;/code\u0026gt; if you must have an abreviation). @MarcoBolis I presume that will be true of all versions of Java, but officially that would be implementation dependent :)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/589259/maarten-bodewes\u0026quot; title=\u0026quot;85,583 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Maarten Bodewes\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment46486386_109117\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-03-18 18:51:08Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 18, 2015 at 18:51\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;And, this requires no multiplications, like the code in the accepted answer.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1715099/alex\u0026quot; title=\u0026quot;906 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Alex\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment76918467_109117\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-07-07 13:23:55Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 7, 2017 at 13:23\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Note that in generalizing to 64-bit there is a problem. The result cannot be 64, because of the mask.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1374975/albert-van-der-horst\u0026quot; title=\u0026quot;760 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Albert van der Horst\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment96757715_109117\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-03-05 10:56:58Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 5, 2019 at 10:56\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;What is the \u0026lt;code\u0026gt;c = \u0026lt;/code\u0026gt; about?  Looks like is should be eliminated.  Further, suggest an extra paren set A\u0026quot;(((v + (v \u0026amp;gt;\u0026amp;gt; 4)) \u0026amp;amp; 0xF0F0F0F) * 0x1010101) \u0026amp;gt;\u0026amp;gt; 24\u0026quot; to avoid some classic warnings.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2410359/chux-reinstate-monica\u0026quot; title=\u0026quot;128,313 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;chux - Reinstate Monica\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment28729888_15979139\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-10-15 15:40:06Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 15, 2013 at 15:40\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;An important feature is that this 32-bit routine works for both \u0026lt;code\u0026gt;popcount(int v)\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;popcount(unsigned v)\u0026lt;/code\u0026gt;.  For portability, consider \u0026lt;code\u0026gt;popcount(uint32_t v)\u0026lt;/code\u0026gt;, etc.  Really like the *0x1010101 part.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2410359/chux-reinstate-monica\u0026quot; title=\u0026quot;128,313 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;chux - Reinstate Monica\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment28730227_15979139\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-10-15 15:49:05Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 15, 2013 at 15:49\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;sauce ? (book, link, invetors\u0026apos;s names etc) would be VERY welcomed. Because then we can paste that in our codebases with a comment to where it comes from.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/893406/v-oddou\u0026quot; title=\u0026quot;6,218 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;v.oddou\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment46902616_15979139\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-03-31 01:34:39Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 31, 2015 at 1:34\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I think for better clarity the last line should be written as: \u0026lt;code\u0026gt;return (((i + (i \u0026amp;gt;\u0026amp;gt; 4)) \u0026amp;amp; 0x0F0F0F0F) * 0x01010101) \u0026amp;gt;\u0026amp;gt; 24;\u0026lt;/code\u0026gt; so we don\u0026apos;t need to count letters to see what you are actually doing (since you discarded the first \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt;, I accidentally thought you used the wrong (flipped) bit pattern as mask - that is until I noted there are only 7 letters and not 8).\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2586599/emem\u0026quot; title=\u0026quot;5,306 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;emem\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment58192628_15979139\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-02-06 09:02:10Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 6, 2016 at 9:02\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;That \u0026lt;b\u0026gt;multiplication\u0026lt;/b\u0026gt; by 0x01010101 might be slow, depending on processor. For example, in my old PowerBook G4, 1 multiplication was about as slow as 4 additions (not as bad as division, where 1 division was about as slow as 23 additions).\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3614563/george-koehler\u0026quot; title=\u0026quot;1,450 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;George Koehler\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment83114958_15979139\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-01-03 03:05:29Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 3, 2018 at 3:05\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;When sun provided different APIs, it must be using some logic on background, right?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1773303/vallabh-patade\u0026quot; title=\u0026quot;4,790 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Vallabh Patade\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment22760373_109054\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-04-12 10:19:08Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 12, 2013 at 10:19\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;As a side note, Java\u0026apos;s implementation uses the \u0026lt;b\u0026gt;same\u0026lt;/b\u0026gt; algorithm pointed out by \u0026lt;a href=\u0026quot;http://stackoverflow.com/questions/109023/how-to-count-the-number-of-set-bits-in-a-32-bit-integer#109117\u0026quot;\u0026gt;Kevin Little\u0026lt;/a\u0026gt;.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1192716/marco-bolis\u0026quot; title=\u0026quot;1,161 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Marco Bolis\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment43977604_109054\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-01-05 16:37:39Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 5, 2015 at 16:37\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Implementation aside, this is probably the clearest message of intent for developers maintaining your code after you (or when you come back to it 6 months later)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/639441/divillysausages\u0026quot; title=\u0026quot;7,697 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;divillysausages\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment74600099_109054\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-05-04 10:08:42Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 4, 2017 at 10:08\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Mike, The table based approach is unbeatable if the table is in the cache. This happens in micro-benchmarks (e.g. do millions of tests in a tight loop). However, a cache miss takes around 200 cycles, and even the most naive popcount will be faster here.  It always depends on the application.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/15955/nils-pipenbrinck\u0026quot; title=\u0026quot;80,817 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Nils Pipenbrinck\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment32510_131212\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2008-09-25 04:42:23Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 25, 2008 at 4:42\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;If you\u0026apos;re not calling this routine a few million times in a tight loop then you have no reason to care about it\u0026apos;s performance at all, and might as well use the naive-but-readable approach since the performance loss will be negligible. And FWIW, the 8bit LUT gets cache-hot within 10-20 calls.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;span class=\u0026quot;comment-user\u0026quot;\u0026gt;Mike F\u0026lt;/span\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment33113_131212\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2008-09-25 11:02:03Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 25, 2008 at 11:02\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I don\u0026apos;t think it\u0026apos;s all that hard to imagine a situation where this is a leaf call made from the method -actually doing the heavy lifting- in your app.  Depending on what else is going on (and threading) the smaller version could win.  Lots of algorithms have been written that beat their peers due to better locality of reference.  Why not this too?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/328304/jason\u0026quot; title=\u0026quot;2,746 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Jason\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment2814509_131212\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-05-06 08:50:25Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 6, 2010 at 8:50\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Try this with clang, it\u0026apos;s \u0026lt;i\u0026gt;significantly\u0026lt;/i\u0026gt; smarter at implementing builtins.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/149482/matt-joiner\u0026quot; title=\u0026quot;107,240 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Matt Joiner\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment4105747_131212\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-10-05 05:23:06Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 5, 2010 at 5:23\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;GCC won\u0026apos;t emit popcont instruction unless called with -msse4.2, case which is faster than \u0026apos;sideways addition\u0026apos;.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/578749/lvella\u0026quot; title=\u0026quot;11,709 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;lvella\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment14985699_131212\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-07-07 06:02:18Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 7, 2012 at 6:02\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;This algorithm is the version Matt Howells posted, before being optimized to the fact that it became unreadable.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1017417/lefteris-e\u0026quot; title=\u0026quot;2,716 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Lefteris E\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment24710261_11816547\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-06-13 10:06:28Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 13, 2013 at 10:06\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@LefterisE: Except using shift/add all the way to the end, instead of using a multiply to sum 8-bit chunks into the top 8 bits, replacing the last 2 \u0026lt;code\u0026gt;x=...\u0026lt;/code\u0026gt; lines here.  My edits demangled it some (keeping the optimized logic, improving readability and adding comments), and I added a section that explains the SWAR bithacks involved.  This answer is still useful, though, at least for the diagram.  Or for a hypothetical 32-bit machine with a slow multiply instruction.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/224132/peter-cordes\u0026quot; title=\u0026quot;289,881 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Peter Cordes\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment128357990_11816547\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2022-06-18 02:49:56Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 18 at 2:49\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;That\u0026apos;ll work and is easy to understand, but there are faster methods.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/16881/matt-howells\u0026quot; title=\u0026quot;39,052 reputation\u0026quot; class=\u0026quot;comment-user owner\u0026quot;\u0026gt;Matt Howells\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment20788_109045\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2008-09-20 19:40:13Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 20, 2008 at 19:40\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Unless you do this a \u0026lt;i\u0026gt;LOT\u0026lt;/i\u0026gt;, the performance impact would be negligible. So all things being equal, I agree with daniel that \u0026apos;best\u0026apos; implies \u0026quot;doesn\u0026apos;t read like gibberish\u0026quot;.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;span class=\u0026quot;comment-user\u0026quot;\u0026gt;Mike F\u0026lt;/span\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment20932_109045\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2008-09-20 21:50:32Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 20, 2008 at 21:50\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I deliberately didn\u0026apos;t define \u0026apos;best\u0026apos;, to get a variety of methods. Lets face it if we have got down to the level of this sort of bit-twiddling we are probably looking for something uber-fast that looks like a chimp has typed it.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/16881/matt-howells\u0026quot; title=\u0026quot;39,052 reputation\u0026quot; class=\u0026quot;comment-user owner\u0026quot;\u0026gt;Matt Howells\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment21907_109045\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2008-09-21 17:47:38Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 21, 2008 at 17:47\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Bad code. A compiler might make good one out of it, but in my tests GCC did not. Replace (n%2) with (n\u0026amp;amp;1); AND being much faster than MODULO. Replace (n/=2) with (n\u0026amp;gt;\u0026amp;gt;=1); bitshifting much faster than division.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/15809/mecki\u0026quot; title=\u0026quot;115,401 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Mecki\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment33061_109045\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2008-09-25 10:35:31Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 25, 2008 at 10:35\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Mecki: In my tests, gcc (4.0, -O3)  \u0026lt;i\u0026gt;did\u0026lt;/i\u0026gt; do the obvious optimisations.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;span class=\u0026quot;comment-user\u0026quot;\u0026gt;Mike F\u0026lt;/span\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment33503_109045\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2008-09-25 13:32:50Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 25, 2008 at 13:32\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;The best non-assembler form like this I\u0026apos;ve seen unrolled 24 32bit words at a time. \u0026lt;a href=\u0026quot;http://dalkescientific.com/writings/diary/popcnt.c\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;dalkescientific.com/writings/diary/popcnt.c\u0026lt;/a\u0026gt;,  \u0026lt;a href=\u0026quot;http://stackoverflow.com/questions/3693981/bit-popcount-for-large-buffer-assembly-preferred\u0026quot; title=\u0026quot;bit popcount for large buffer assembly preferred\u0026quot;\u0026gt;stackoverflow.com/questions/3693981/\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;http://www.dalkescientific.com/writings/diary/archive/2008/07/05/bitslice_and_popcount.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;dalkescientific.com/writings/diary/archive/2008/07/05/\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/149482/matt-joiner\u0026quot; title=\u0026quot;107,240 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Matt Joiner\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment4105757_1511920\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-10-05 05:25:53Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 5, 2010 at 5:25\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;This solution seem to have minor problem, related to operator precedence. For each term it should say: x = (((x \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 0b01010101010101010101010101010101)        + (x       \u0026amp;amp; 0b01010101010101010101010101010101)); (i.e. extra parens added).\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/139282/nopik\u0026quot; title=\u0026quot;522 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Nopik\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment39694605_20697993\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-08-22 07:38:28Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 22, 2014 at 7:38\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;In case you\u0026apos;re confused, the error in the original article that @Nopik pointed out has since been fixed (by someone else), and without newly introducing \u0026lt;i\u0026gt;extraneous\u0026lt;/i\u0026gt; parentheses as the comment suggests.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/147511/glenn-slayden\u0026quot; title=\u0026quot;16,127 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Glenn Slayden\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment125074753_20697993\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2022-01-18 03:33:58Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 18 at 3:33\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Not portable.  What if the CPU has 9 bit bytes?  Yes, there are real CPU\u0026apos;s like that out there...\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/71074/robert-s-barnes\u0026quot; title=\u0026quot;38,519 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Robert S. Barnes\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment6200382_113098\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-03-29 08:06:42Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 29, 2011 at 8:06\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Robert S. Barnes, this function will still work.  It makes no assumption about native word size, and no reference to \u0026quot;bytes\u0026quot; at all.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/12048/finnw\u0026quot; title=\u0026quot;46,800 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;finnw\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment6827906_113098\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-05-08 11:26:16Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 8, 2011 at 11:26\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Is the complexity of this code \u0026lt;code\u0026gt;O(floor(log2(num))/4)\u0026lt;/code\u0026gt;, assuming \u0026lt;code\u0026gt;num\u0026lt;/code\u0026gt; can be as arbitrarily large as possible? Because the \u0026lt;code\u0026gt;while\u0026lt;/code\u0026gt; loop runs as long as there\u0026apos;s a nibble to process? There are \u0026lt;code\u0026gt;floor(log2(num))\u0026lt;/code\u0026gt; bits and \u0026lt;code\u0026gt;floor(log2(num)) / 4\u0026lt;/code\u0026gt; nibbles. Is the reasoning correct?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/7261925/robur-131\u0026quot; title=\u0026quot;374 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Robur_131\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment110273890_113098\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2020-06-12 19:28:18Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 12, 2020 at 19:28\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Robur_131 I don\u0026apos;t see anything wrong with your reasoning, except that big-O doesn\u0026apos;t care about constant factors so you could simplify to just O(log n).  The nice thing about this algorithm is it doesn\u0026apos;t always take worst case, if the upper bits are zero it exits early.  In fact for an input of zero the loop doesn\u0026apos;t run at all.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/5987/mark-ransom\u0026quot; title=\u0026quot;287,628 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Mark Ransom\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment119411867_113098\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2021-05-16 15:55:10Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 16, 2021 at 15:55\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@MarkRansom: So unless you\u0026apos;re optimizing for inputs of zero, you should probably change it to a \u0026lt;code\u0026gt;do{}while\u0026lt;/code\u0026gt; loop that doesn\u0026apos;t compare/branch until after checking the low 4 bits.  Or unroll to check 2x 4 bits on the first iteration.  That means the branch-prediction pattern is the same for all inputs from 0..255, and making the branching more predictable is often a Good Thing, when the work saved is much cheaper than a branch mispredict.  (Of course that depends on the CPU, and you wouldn\u0026apos;t typically use this on a high-end CPU where branch misses are most expensive.)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/224132/peter-cordes\u0026quot; title=\u0026quot;289,881 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Peter Cordes\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment128358010_113098\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2022-06-18 02:55:11Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 18 at 2:55\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;This is essentially \u0026lt;b\u0026gt;Brian Kernighan\u0026apos;s\u0026lt;/b\u0026gt; (remember him?) algorithm, with the minor change that he used the more succinct \u0026lt;code\u0026gt;n \u0026amp;amp;= (n-1)\u0026lt;/code\u0026gt; form.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/10871073/adrian-mole\u0026quot; title=\u0026quot;43,506 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Adrian Mole\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment101707330_21114060\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-08-23 13:05:48Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 23, 2019 at 13:05\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;oh i like that. how bout the python version: \u0026lt;code\u0026gt;def f(i, d={0:lambda:0, 1:lambda:1, 2:lambda:1, 3:lambda:2}): return d.get(i, lambda: f(i//4) + f(i%4))()\u0026lt;/code\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/804147/underrun\u0026quot; title=\u0026quot;6,473 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;underrun\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment20475748_12974349\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-02-01 19:04:05Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 1, 2013 at 19:04\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;this is good for \u0026quot;sparse\u0026quot; numbers with a low number of bits, as it is \u0026lt;code\u0026gt;O(ONE-BITS)\u0026lt;/code\u0026gt;. It is indeed O(1) since there are at most 32 one-bits.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1941755/ealfonso\u0026quot; title=\u0026quot;5,981 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;ealfonso\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment83489678_10459753\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-01-14 19:55:48Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 14, 2018 at 19:55\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;My code has 10 operation. Your code has 12 operation. Your link work with smaller arrays (5). I use 256 elements. With the caching can be a problem. But if you use it very frequently then this is not a problem.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/12631/horcrux7\u0026quot; title=\u0026quot;22,913 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Horcrux7\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment20883_109093\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2008-09-20 21:12:35Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 20, 2008 at 21:12\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;This approach is measurably quite a bit faster than the bit-twiddling approach, as it turns out. As for using more memory, it compiles to less code and that gain is repeated every time you inline the function. So it could easily turn out to be a net win.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;span class=\u0026quot;comment-user\u0026quot;\u0026gt;Mike F\u0026lt;/span\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment32442_109093\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2008-09-25 03:43:04Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 25, 2008 at 3:43\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Unfortunately, the bit counting isn\u0026apos;t done in parallel, so it\u0026apos;s probably slower. Might make a nice \u0026lt;code\u0026gt;constexpr\u0026lt;/code\u0026gt; though.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/688624/imallett\u0026quot; title=\u0026quot;13,966 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;imallett\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment50421598_10004919\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-07-03 15:14:29Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 3, 2015 at 15:14\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Agreed - it was a fun exercise in C++ template recursion, but definitely a pretty naïve solution.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/679950/pentaphobe\u0026quot; title=\u0026quot;336 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;pentaphobe\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment53391231_10004919\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-09-25 06:46:45Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 25, 2015 at 6:46\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;How does it perform compared to the other suggestions?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/764223/asdf\u0026quot; title=\u0026quot;229 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;asdf\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment7717587_118631\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-07-01 16:08:26Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 1, 2011 at 16:08\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Not really an algorithm, this is just a library call. Useful for Java, not so much for everybody else.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/10947/benzado\u0026quot; title=\u0026quot;78,878 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;benzado\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment4830142_4413115\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-12-13 05:14:41Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 13, 2010 at 5:14\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@benzado is right but +1 anyway, because some Java developers might not be aware of the method\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/12048/finnw\u0026quot; title=\u0026quot;46,800 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;finnw\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment6827911_4413115\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-05-08 11:27:53Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 8, 2011 at 11:27\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@finnw, i am one of those developers. :)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/668963/neevek\u0026quot; title=\u0026quot;11,380 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;neevek\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment29647682_4413115\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-11-12 08:37:34Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 12, 2013 at 8:37\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Ironically, that table could have been created by any of the algorithms posted in this thread!   Nevertheless, using tables like this means constant-time performance.   Going one step further and creating a 64K translation table would therefore halve the AND, SHIFT and ADD operations necessary.    An interesting subject for bit manipulators!\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/924272/user924272\u0026quot; title=\u0026quot;734 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;user924272\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment57170358_21455308\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-01-10 23:23:18Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 10, 2016 at 23:23\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Bigger tables can be slower (and not constant-time) due to cache issues. You can \u0026apos;look up\u0026apos; 3 bits at a time with \u0026lt;code\u0026gt;(0xe994 \u0026amp;gt;\u0026amp;gt;(k*2))\u0026amp;amp;3\u0026lt;/code\u0026gt;,without memory access...\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/450000/greggo\u0026quot; title=\u0026quot;2,771 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;greggo\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment73238217_21455308\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-03-28 18:42:29Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 28, 2017 at 18:42\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        "],"id":566,"title":"How to count the number of set bits in a 32-bit integer?","content":"\n                \n\u0026lt;p\u0026gt;8 bits representing the number 7 look like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;00000111\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Three bits are set.   \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;What are algorithms to determine the number of set bits in a 32-bit integer?\u0026lt;/p\u0026gt;\n    ","slug":"how-to-count-the-number-of-set-bits-in-a-32-bit-integer-1657388437370","postType":"QUESTION","createdAt":"2022-07-09T17:40:37.000Z","updatedAt":"2022-07-09T17:40:37.000Z","tags":[{"id":2732,"name":"hammingweight","slug":"hammingweight","createdAt":"2022-07-09T17:40:37.000Z","updatedAt":"2022-07-09T17:40:37.000Z","Questions_Tags":{"questionId":566,"tagId":2732}}]}]}},"__N_SSG":true},"page":"/questions/tag/[slug]","query":{"slug":"hammingweight"},"buildId":"4Y8KGE-c2lolBeBmcum_I","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>