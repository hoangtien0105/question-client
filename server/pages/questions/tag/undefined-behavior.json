{"pageProps":{"data":{"count":1,"rows":[{"answer":["\n&lt;p&gt;&lt;em&gt;&lt;strong&gt;Undefined behavior&lt;/strong&gt;&lt;/em&gt; is one of those aspects of the C and C++ language that can be surprising to programmers coming from other languages (other languages try to hide it better). Basically,  it is possible to write C++ programs that do not behave in a predictable way, even though many C++ compilers will not report any errors in the program!&lt;/p&gt;\n&lt;p&gt;Let&apos;s look at a classic example:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;* p = &lt;span class=&quot;hljs-string&quot;&gt;&quot;hello!\\n&quot;&lt;/span&gt;;   &lt;span class=&quot;hljs-comment&quot;&gt;// yes I know, deprecated conversion&lt;/span&gt;\n    p[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;hljs-string&quot;&gt;&apos;y&apos;&lt;/span&gt;;\n    p[&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;] = &lt;span class=&quot;hljs-string&quot;&gt;&apos;w&apos;&lt;/span&gt;;\n    std::cout &amp;lt;&amp;lt; p;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The variable &lt;code&gt;p&lt;/code&gt; points to the string literal &lt;code&gt;&quot;hello!\\n&quot;&lt;/code&gt;, and the two assignments below try to modify that string literal. What does this program do? According to section 2.14.5 paragraph 11 of the C++ standard, it invokes &lt;em&gt;undefined behavior&lt;/em&gt;:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;The effect of attempting to modify a string literal is undefined.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;I can hear people screaming &quot;But wait, I can compile this no problem and get the output &lt;code&gt;yellow&lt;/code&gt;&quot; or &quot;What do you mean undefined, string literals are stored in read-only memory, so the first assignment attempt results in a core dump&quot;. This is exactly the problem with undefined behavior. Basically, the standard allows anything to happen once you invoke undefined behavior (even nasal demons). If there is a &quot;correct&quot; behavior according to your mental model of the language, that model is simply wrong; The C++ standard has the only vote, period.&lt;/p&gt;\n&lt;p&gt;Other examples of undefined behavior include accessing an array beyond its bounds, &lt;a href=&quot;https://stackoverflow.com/q/2894891&quot;&gt;dereferencing the null pointer&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/q/6441218&quot;&gt;accessing objects after their lifetime ended&lt;/a&gt; or writing &lt;a href=&quot;https://stackoverflow.com/q/949433&quot;&gt;allegedly clever expressions&lt;/a&gt; like &lt;code&gt;i++ + ++i&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;Section 1.9 of the C++ standard also mentions undefined behavior&apos;s two less dangerous brothers, &lt;strong&gt;unspecified behavior&lt;/strong&gt; and &lt;strong&gt;implementation-defined behavior&lt;/strong&gt;:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;The semantic descriptions in this International Standard define a parameterized nondeterministic abstract machine.&lt;/p&gt;\n&lt;p&gt;Certain aspects and operations of the abstract machine are described in this International Standard as &lt;strong&gt;implementation-defined&lt;/strong&gt; (for example, &lt;code&gt;sizeof(int)&lt;/code&gt;). These constitute the parameters of the abstract machine. Each implementation shall include documentation describing its characteristics and behavior in these respects.&lt;/p&gt;\n&lt;p&gt;Certain other aspects and operations of the abstract machine are described in this International Standard as &lt;strong&gt;unspecified&lt;/strong&gt; (for example, order of evaluation of arguments to a function). Where possible, this International Standard defines a set of allowable behaviors. These define the nondeterministic aspects of the abstract machine.&lt;/p&gt;\n&lt;p&gt;Certain other operations are described in this International Standard as &lt;strong&gt;undefined&lt;/strong&gt; (for example, the  effect of dereferencing the null pointer). [ &lt;em&gt;Note&lt;/em&gt;: &lt;strong&gt;this International Standard imposes no requirements on the behavior of programs that contain undefined behavior.&lt;/strong&gt; &lt;em&gt;end note&lt;/em&gt; ]&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Specifically, section 1.3.24 states:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Permissible undefined behavior ranges from &lt;strong&gt;ignoring the situation completely with unpredictable results&lt;/strong&gt;, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;What can you do to avoid running into undefined behavior? Basically, you have to read &lt;a href=&quot;https://stackoverflow.com/questions/388242/&quot;&gt;good C++ books&lt;/a&gt; by authors who know what they&apos;re talking about. Avoid internet tutorials. Avoid bullschildt.&lt;/p&gt;\n    ","\n&lt;p&gt;Well, this is basically a straight copy-paste from the standard&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;strong&gt;3.4.1&lt;/strong&gt; 1 &lt;strong&gt;implementation-defined behavior&lt;/strong&gt; unspecified behavior where\neach implementation documents how the\nchoice is made&lt;/p&gt;\n&lt;p&gt;2 EXAMPLE An example of\nimplementation-defined behavior is the\npropagation of the high-order bit when\na signed integer is shifted right.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;3.4.3&lt;/strong&gt; 1 &lt;strong&gt;undefined behavior&lt;/strong&gt; behavior, upon use of a nonportable or erroneous\nprogram construct or of erroneous\ndata, for which this International\nStandard imposes no requirements&lt;/p&gt;\n&lt;p&gt;2\nNOTE Possible undefined behavior\nranges from ignoring the situation\ncompletely with unpredictable results,\nto behaving during translation or\nprogram execution in a documented\nmanner characteristic of the\nenvironment (with or without the\nissuance of a diagnostic message), to\nterminating a translation or execution\n(with the issuance of a diagnostic\nmessage).&lt;/p&gt;\n&lt;p&gt;3 EXAMPLE An example of\nundefined behavior is the behavior on\ninteger overflow.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;3.4.4&lt;/strong&gt; 1 &lt;strong&gt;unspecified behavior&lt;/strong&gt; use of an unspecified value, or other behavior\nwhere this International Standard\nprovides two or more possibilities and\nimposes no further requirements on\nwhich is chosen in any instance&lt;/p&gt;\n&lt;p&gt;2\nEXAMPLE An example of unspecified\nbehavior is the order in which the\narguments to a function are evaluated.&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;Maybe easy wording could be easier for understanding than the rigorous definition of the standards.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;implementation-defined behavior&lt;/strong&gt;&lt;br&gt;\nThe language says that we have data-types. The compiler vendors specify what sizes shall they use, and provide a documentation of what they did.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;undefined behavior&lt;/strong&gt;&lt;br&gt;\nYou are doing something wrong. For example, you have a very large value in an &lt;code&gt;int&lt;/code&gt; that doesn&apos;t fit in &lt;code&gt;char&lt;/code&gt;. How do you put that value in &lt;code&gt;char&lt;/code&gt;? actually there is no way! Anything could happen, but the most sensible thing would be to take the first byte of that int and put it in &lt;code&gt;char&lt;/code&gt;. It is just wrong to do that to assign the first byte, but thats what happens under the hood.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;unspecified behavior&lt;/strong&gt;&lt;br&gt;\nWhich function of these two is executed first?&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;fun&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; n, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; m)&lt;/span&gt;&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;fun1&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;fun1&quot;&lt;/span&gt;;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n}\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;fun2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;fun2&quot;&lt;/span&gt;;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;\n}\n...\n&lt;span class=&quot;hljs-built_in&quot;&gt;fun&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;fun1&lt;/span&gt;(), &lt;span class=&quot;hljs-built_in&quot;&gt;fun2&lt;/span&gt;()); &lt;span class=&quot;hljs-comment&quot;&gt;// which one is executed first?&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The language doesn&apos;t specify the evaluation, left to right or right to left! So an unspecified behavior may or mayn&apos;t result in an undefined behavior, but certainly your program should not produce an unspecified behavior.&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;@eSKay I think your question is worth editing the answer to clarify more :)&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;for &lt;code&gt;fun(fun1(), fun2());&lt;/code&gt; isn&apos;t the behaviour &quot;implementation defined&quot;? The compiler has to choose one or the other course, after all?&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;The difference between implementation-defined and unspecified, is that the compiler is supposed to pick a behavior in the first case but it doesn&apos;t have to in the second case. For example, an implementation must have one and only one definition of &lt;code&gt;sizeof(int)&lt;/code&gt;. So, it can&apos;t say that &lt;code&gt;sizeof(int)&lt;/code&gt; is 4 for some portion of the program and 8 for others. Unlike unspecified behavior, where the compiler can say OK I am gonna evaluate these arguments left-to-right and the next function&apos;s arguments are evaluated right-to-left. It can happen in the same program, that&apos;s why it is called &lt;em&gt;&lt;strong&gt;unspecified&lt;/strong&gt;&lt;/em&gt;. In fact, C++ could have been made easier if some of the unspecified behaviors were specified. Take a look here at &lt;a href=&quot;//www.stroustrup.com/bs_faq2.html#undefined&quot; rel=&quot;nofollow noreferrer&quot;&gt;Dr. Stroustrup&apos;s answer for that&lt;/a&gt;:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;It is claimed that the difference between what can be produced giving the compiler this freedom and requiring &quot;ordinary left-to-right evaluation&quot; can be significant. I&apos;m unconvinced, but with innumerable compilers &quot;out there&quot; taking advantage of the freedom and some people passionately defending that freedom, a change would be difficult and could take decades to penetrate to the distant corners of the C and C++ worlds. I am disappointed that not all compilers warn against code such as &lt;code&gt;++i+i++&lt;/code&gt;. Similarly, the order of evaluation of arguments is unspecified.&lt;/p&gt;\n&lt;p&gt;IMO far too many &quot;things&quot; are left undefined, unspecified, that&apos;s easy to say and even to give examples of, but hard to fix. It should also be noted that it is not all that difficult to avoid most of the problems and produce portable code.&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;From the official C Rationale Document&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;The terms &lt;em&gt;unspecified&lt;/em&gt; behavior, &lt;em&gt;undefined&lt;/em&gt; behavior, and &lt;em&gt;implementation-defined&lt;/em&gt; behavior are used to categorize the result of writing programs whose properties the Standard does not, or cannot, completely describe.  The goal of adopting this categorization is to allow a certain variety among implementations which permits quality of implementation to be an active force in the marketplace as well as to allow certain popular extensions, without removing the cachet of conformance to the Standard.  Appendix F to the Standard catalogs those behaviors which fall into one of these three categories. &lt;/p&gt;\n  \n  &lt;p&gt;&lt;em&gt;Unspecified behavior&lt;/em&gt; gives the implementor some latitude in translating programs.  This latitude does not extend as far as failing to translate the program. &lt;/p&gt;\n  \n  &lt;p&gt;&lt;em&gt;Undefined behavior&lt;/em&gt; gives the implementor license not to catch certain program errors that are difficult to diagnose.  It also identifies areas of possible conforming language extension: the implementor may augment the language by providing a definition of the officially undefined behavior. &lt;/p&gt;\n  \n  &lt;p&gt;&lt;em&gt;Implementation-defined&lt;/em&gt; behavior gives an implementor the freedom to choose the appropriate approach, but requires that this choice be explained to the user.  Behaviors designated as implementation-defined are generally those in which a user could make meaningful coding decisions based on the implementation definition.  Implementors should bear in mind this criterion when deciding how extensive an implementation definition ought to be.  As with unspecified behavior, simply failing to translate the source containing the implementation-defined behavior is not an adequate response. &lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;&lt;a href=&quot;http://www.devx.com/tips/Tip/12684&quot; rel=&quot;noreferrer&quot;&gt;Undefined Behavior vs. Unspecified Behavior&lt;/a&gt; has a short description of it.&lt;/p&gt;\n\n&lt;p&gt;Their final summary:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;To sum up, unspecified behavior is usually something you shouldn&apos;t\n  worry about, unless your software is required to be portable.\n  Conversely, undefined behavior is always undesirable and should never\n  occur.&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;Implementation defined- &lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Implementors wish,should be well documented,standard gives choices but sure to compile&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Unspecified -&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Same as implementation-defined but not documented&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Undefined-&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Anything might happen,take care of it.&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;Historically, both Implementation-Defined Behavior and Undefined Behavior represented situations in which the authors of the Standard expected that people writing quality implementations would use judgment to decide what behavioral guarantees, if any, would be useful for programs in the intended application field running on the intended targets.  The needs of high-end number-crunching code are quite different from those of low-level systems code, and both UB and IDB give compiler writers flexibility to meet those different needs.  Neither category mandates that implementations behave in a way that&apos;s useful for any particular purpose, or even for any purpose whatsoever.  Quality implementations that claim to be suitable for a particular purpose, however, should behave in a manner befitting such purpose &lt;em&gt;whether the Standard requires it or not&lt;/em&gt;.&lt;/p&gt;\n\n&lt;p&gt;The only difference between Implementation-Defined Behavior and Undefined Behavior is that the former requires that implementations define and document a consistent behavior &lt;em&gt;even in cases where nothing the implementation could possibly do would be useful&lt;/em&gt;.  The dividing line between them is not whether it would generally be useful for implementations to define behaviors (compiler writers should define useful behaviors when practical whether the Standard requires them to or not) but &lt;em&gt;whether there might be implementations where defining a behavior would be simultaneously costly and useless&lt;/em&gt;.  A judgment that such implementations might exist does not in any way, shape, or form, imply any judgment about the usefulness of supporting a defined behavior on other platforms.&lt;/p&gt;\n\n&lt;p&gt;Unfortunately, since the mid 1990s compiler writers have started to interpret the lack of behavioral mandates as an judgment that behavioral guarantees aren&apos;t worth the cost even in application fields where they&apos;re vital, and even on systems where they cost practically nothing.  Instead of treating UB as an invitation to exercise reasonable judgment, compiler writers have started treating it as an excuse &lt;em&gt;not&lt;/em&gt; to do so.&lt;/p&gt;\n\n&lt;p&gt;For example, given the following code:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;scaled_velocity&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; v, &lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; pow)&lt;/span&gt;\n&lt;/span&gt;{\n  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (v &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;250&lt;/span&gt;)\n    v = &lt;span class=&quot;hljs-number&quot;&gt;250&lt;/span&gt;;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (v &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;-250&lt;/span&gt;)\n    v = &lt;span class=&quot;hljs-number&quot;&gt;-250&lt;/span&gt;;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; v &amp;lt;&amp;lt; pow;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;a two&apos;s-complement implementation would not have to expend any effort\nwhatsoever to treat the expression &lt;code&gt;v &amp;lt;&amp;lt; pow&lt;/code&gt; as a two&apos;s-complement shift\nwithout regard for whether &lt;code&gt;v&lt;/code&gt; was positive or negative.&lt;/p&gt;\n\n&lt;p&gt;The preferred philosophy among some of today&apos;s compiler writers, however, would suggest that because &lt;code&gt;v&lt;/code&gt; can only be negative if the program is going to engage in Undefined Behavior, there&apos;s no reason to have the program clip the negative range of &lt;code&gt;v&lt;/code&gt;.  Even though left-shifting of negative values used to be supported on every single compiler of significance, and a large amount of existing code relies upon that behavior, modern philosophy would interpret the fact that the Standard says that left-shifting negative values is UB as implying that compiler writers should feel free to ignore that.&lt;/p&gt;\n    ","\n&lt;p&gt;C++ standard n3337  &lt;strong&gt;§&lt;/strong&gt; 1.3.10\n&lt;strong&gt;implementation-defined behavior&lt;/strong&gt;&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;behavior, for a well-formed program construct and correct data, that\n  depends on the implementation and that each implementation documents&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Sometimes C++ Standard doesn&apos;t impose particular behavior on some constructs but says instead that a particular, well defined behavior has to be chosen and &lt;strong&gt;described&lt;/strong&gt; by particular implementation (version of library). So user can still know exactly how will program behave even though Standard doesn&apos;t describe this. &lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;C++ standard n3337  &lt;strong&gt;§&lt;/strong&gt; 1.3.24\n&lt;strong&gt;undefined behavior&lt;/strong&gt;&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;behavior for which this International Standard imposes no requirements\n  [ Note: Undefined behavior may be expected when this International\n  Standard omits any explicit definition of behavior or when a program\n  uses an erroneous construct or erroneous data. Permissible undefined\n  behavior ranges from ignoring the situation completely with\n  unpredictable results, to behaving during translation or program\n  execution in a documented manner characteristic of the environment\n  (with or without the issuance of a diagnostic message), to terminating\n  a translation or execution (with the issuance of a diagnostic\n  message). Many erroneous program constructs do not engender undefined\n  behavior; they are required to be diagnosed.  end note ]&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;When the program encounters construct that is not defined according to C++ Standard it is allowed to do whatever it wants to do ( maybe send an email to me or maybe send an email to you or maybe ignore the code completely). &lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;C++ standard n3337  &lt;strong&gt;§&lt;/strong&gt; 1.3.25\n&lt;strong&gt;unspecified behavior&lt;/strong&gt;&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;behavior, for a well-formed program construct and correct data, that\n  depends on the implementation [ Note: The implementation is not\n  required to document which behavior occurs. The range of possible\n  behaviors is usually delineated by this International Standard.  end\n  note ]&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;C++ Standard doesn&apos;t impose particular behavior on some constructs but says instead that a particular, well defined behavior has to be chosen ( &lt;strong&gt;bot not necessary described&lt;/strong&gt;) by particular implementation (version of library). So in the case when no description has been provided it can be difficult to the user to know exactly how will program behave.&lt;/p&gt;\n    ","\n&lt;p&gt;Undefined behavior is &lt;em&gt;ugly&lt;/em&gt; -- as in, &quot;The good, the bad, and the ugly&quot;.&lt;/p&gt;\n&lt;p&gt;Good: a program that compiles and works, for the right reasons.&lt;/p&gt;\n&lt;p&gt;Bad: a program that has an error, of a kind that the compiler can detect and complain about.&lt;/p&gt;\n&lt;p&gt;Ugly: a program that has an error, that the compiler &lt;em&gt;cannot&lt;/em&gt; detect and warn about, meaning that the program compiles, and may seem to work correctly some of the time, but also fails bizarrely some of the time.  That&apos;s what undefined behavior is.&lt;/p&gt;\n&lt;p&gt;Some program languages and other formal systems try hard to limit the &quot;gulf of undefinedness&quot; -- that is, they try to arrange things so that most or all programs are either &quot;good&quot; or &quot;bad&quot;, and that very few are &quot;ugly&quot;.  It&apos;s a characteristic feature of C, however, that its &quot;gulf of undefinedness&quot; is quite wide.&lt;/p&gt;\n    "],"comment":["\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;I was pretty sure that we&apos;ve dne this befor, but I can&apos;t find it. See also: &lt;a href=&quot;http://stackoverflow.com/questions/2301372/undefined-unspecified-implementation-defined-behaviour-warnings&quot; title=&quot;undefined unspecified implementation defined behaviour warnings&quot;&gt;stackoverflow.com/questions/2301372/&lt;/a&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/2509/dmckee-ex-moderator-kitten&quot; title=&quot;95,126 reputation&quot; class=&quot;comment-user&quot;&gt;dmckee --- ex-moderator kitten&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment2377798_2397984&quot;&gt;&lt;span title=&quot;2010-03-07 22:02:22Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Mar 7, 2010 at 22:02&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;From the comp.lang.c FAQ: &lt;a href=&quot;http://c-faq.com/ansi/undef.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;People seem to make a point of distinguishing between implementation-defined, unspecified, and undefined behavior. What do these mean?&lt;/a&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/179715/jamesdlin&quot; title=&quot;66,868 reputation&quot; class=&quot;comment-user&quot;&gt;jamesdlin&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment53278585_2397984&quot;&gt;&lt;span title=&quot;2010-03-08 02:37:23Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Mar 8, 2010 at 2:37&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;&lt;a href=&quot;http://theunixshell.blogspot.com/2013/07/what-is-undefined-behavior.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;theunixshell.blogspot.com/2013/07/&lt;/a&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/134713/vijay&quot; title=&quot;62,861 reputation&quot; class=&quot;comment-user&quot;&gt;Vijay&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment25552287_2397984&quot;&gt;&lt;span title=&quot;2013-07-10 06:36:07Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jul 10, 2013 at 6:36&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Here is &lt;a href=&quot;http://www.drdobbs.com/go-parallel/article/print?articleId=232901670&amp;amp;siteSectionName=&quot; rel=&quot;nofollow noreferrer&quot;&gt;an interesting discussion&lt;/a&gt; (the section &quot;Annex L and Undefined Behavior&quot;).&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/371739/owen&quot; title=&quot;37,938 reputation&quot; class=&quot;comment-user&quot;&gt;Owen&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment25915125_2397984&quot;&gt;&lt;span title=&quot;2013-07-21 04:37:08Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jul 21, 2013 at 4:37&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;It&apos;s a weird fact that resulted from the merge that this answer only covers C++ but this question&apos;s tags includes C. C has a different notion of &quot;undefined behavior&quot;: It will still require the implementation to give diagnostic messages even if behavior is also stated to be undefined for certain rule violations (constraint violations).&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/34509/johannes-schaub-litb&quot; title=&quot;482,727 reputation&quot; class=&quot;comment-user&quot;&gt;Johannes Schaub - litb&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment4580274_4105123&quot;&gt;&lt;span title=&quot;2010-11-20 04:45:58Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Nov 20, 2010 at 4:45&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Benoit It is undefined behavior because the standard says it&apos;s undefined behavior, period. On some systems, indeed string literals are stored in the read-only text segment, and the program will crash if you try to modify a string literal. On other systems, the string literal will indeed appear change. The standard does not mandate what has to happen. That&apos;s what undefined behavior means.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/252000/fredoverflow&quot; title=&quot;247,769 reputation&quot; class=&quot;comment-user&quot;&gt;fredoverflow&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment20000567_4105123&quot;&gt;&lt;span title=&quot;2013-01-17 13:37:52Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jan 17, 2013 at 13:37&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@FredOverflow, Why does a good compiler allow us to compile code that gives undefined behavior? Exactly what &lt;i&gt;good&lt;/i&gt; can compiling this kind of code give? Why didn&apos;t all good compilers give us a huge red warning sign when we are trying to compile code that gives undefined behavior?&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/632951/pacerier&quot; title=&quot;81,802 reputation&quot; class=&quot;comment-user&quot;&gt;Pacerier&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment28147580_4105123&quot;&gt;&lt;span title=&quot;2013-09-27 08:53:08Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Sep 27, 2013 at 8:53&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 2 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Pacerier There are certain things that are not checkable at compile time. For example it is not always possible to guarantee that a null pointer is never dereferenced, but this is undefined.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/880984/tim-seguine&quot; title=&quot;2,818 reputation&quot; class=&quot;comment-user&quot;&gt;Tim Seguine&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment30560921_4105123&quot;&gt;&lt;span title=&quot;2013-12-08 14:16:05Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Dec 8, 2013 at 14:16&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Celeritas, undefined behavior &lt;i&gt;can&lt;/i&gt; be non-deterministic.  For example, it is impossible to know ahead of time what the contents of uninitialized memory will be, eg. &lt;code&gt;int f(){int a; return a;}&lt;/code&gt;: the value of &lt;code&gt;a&lt;/code&gt; may change between function calls.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/3063736/mark&quot; title=&quot;2,745 reputation&quot; class=&quot;comment-user&quot;&gt;Mark&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment53996145_4105123&quot;&gt;&lt;span title=&quot;2015-10-12 20:56:21Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Oct 12, 2015 at 20:56&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;What&apos;s the difference between implementation-defined and unspecified behaviour?&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/182153/zolomon&quot; title=&quot;8,911 reputation&quot; class=&quot;comment-user owner&quot;&gt;Zolomon&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment2377634_2397995&quot;&gt;&lt;span title=&quot;2010-03-07 21:23:43Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Mar 7, 2010 at 21:23&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Zolomon: Just like it says: basucally the same thing, except that in case of implementation-defined the implementation is requred to document (to guarantee) what exactly is going to happen, while in case of unspecified the implementation is not required to document or guarantee anything.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/187690/ant-stop-the-ukronazis&quot; title=&quot;302,970 reputation&quot; class=&quot;comment-user&quot;&gt;AnT - Stop the UkroNazis&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment2377648_2397995&quot;&gt;&lt;span title=&quot;2010-03-07 21:27:58Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Mar 7, 2010 at 21:27&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 2 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Zolomon: It&apos;s reflected in the difference between 3.4.1 and 2.4.4.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/140719/sbi&quot; title=&quot;213,029 reputation&quot; class=&quot;comment-user&quot;&gt;sbi&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment2377649_2397995&quot;&gt;&lt;span title=&quot;2010-03-07 21:28:00Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Mar 7, 2010 at 21:28&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Celeritas: Hyper-modern compilers can do better than that.  Given &lt;code&gt;int foo(int x) { if (x &amp;gt;= 0) launch_missiles(); return x &amp;lt;&amp;lt; 1; }&lt;/code&gt; a compiler can determine that since all means of invoking the function that don&apos;t launch the missiles invoke Undefined Behavior, it can make the call to &lt;code&gt;launch_missiles()&lt;/code&gt; unconditional.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment48233702_2397995&quot;&gt;&lt;span title=&quot;2015-05-05 17:24:38Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;May 5, 2015 at 17:24&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@northerner As the quote states, unspecified behavior is usually restricted to a limited set of possible behaviors. In some cases you might even come to conclusion that all of these possibilities are acceptable in the given context, in which cases unspecified behavior is not a problem at all. Undefined behavior is completely unrestricted (e.b. &quot;the program may decide to format your hard drive&quot;). Undefined behavior is always a problem.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/187690/ant-stop-the-ukronazis&quot; title=&quot;302,970 reputation&quot; class=&quot;comment-user&quot;&gt;AnT - Stop the UkroNazis&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment72939735_2397995&quot;&gt;&lt;span title=&quot;2017-03-21 07:41:11Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 21, 2017 at 7:41&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;for &lt;code&gt;fun(fun1(), fun2());&lt;/code&gt; isn&apos;t the behaviour &lt;code&gt;&quot;implementation defined&quot;&lt;/code&gt;? The compiler has to choose one or the other course, after all?&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/113124/lazer&quot; title=&quot;86,109 reputation&quot; class=&quot;comment-user&quot;&gt;Lazer&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment2379121_2398030&quot;&gt;&lt;span title=&quot;2010-03-08 05:14:36Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Mar 8, 2010 at 5:14&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@AraK: thanks for the explaining. I understand it now.  Btw, &lt;code&gt;&quot;I am gonna evaluate these arguments left-to-right and the next function&apos;s arguments are evaluated right-to-left&quot;&lt;/code&gt; I understand this &lt;code&gt;can&lt;/code&gt; happen. Does it really, with compilers that we use these days?&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/113124/lazer&quot; title=&quot;86,109 reputation&quot; class=&quot;comment-user&quot;&gt;Lazer&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment2380245_2398030&quot;&gt;&lt;span title=&quot;2010-03-08 10:23:40Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Mar 8, 2010 at 10:23&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@eSKay You have to ask a guru about this who got his hands dirty with many compilers :) AFAIK VC evaluates arguments right-to-left always.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/127893/khaled-alshaya&quot; title=&quot;91,624 reputation&quot; class=&quot;comment-user&quot;&gt;Khaled Alshaya&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment2380270_2398030&quot;&gt;&lt;span title=&quot;2010-03-08 10:28:52Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Mar 8, 2010 at 10:28&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Lazer: It can definitely happen.  Simple scenario: foo(bar, boz()) and foo(boz(), bar), where bar is an int and boz() is a function returning int.  Assume a CPU where parameters are expected to be passed in registers R0-R1.  Function results are returned in R0; functions may trash R1.  Evaluating &quot;bar&quot; before &quot;boz()&quot; would require saving a copy of bar somewhere else before calling boz() and then loading that saved copy.  Evaluating &quot;bar&quot; after &quot;boz()&quot; will avoid a memory store and re-fetch, and is an optimization many compilers would do regardless of their order in the argument list.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment6085845_2398030&quot;&gt;&lt;span title=&quot;2011-03-21 20:12:13Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Mar 21, 2011 at 20:12&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 2 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;I don&apos;t know about C++ but the C standard says that a conversion of an int to a char is either implementation defined or even well defined (depending on the actual values and signedness of types). See C99 §6.3.1.3 (unchanged in C11).&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/104790/nikolai-ruhe&quot; title=&quot;80,654 reputation&quot; class=&quot;comment-user&quot;&gt;Nikolai Ruhe&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment19891045_2398030&quot;&gt;&lt;span title=&quot;2013-01-14 10:18:24Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jan 14, 2013 at 10:18&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Hyper-modern compiler writers also regard &quot;undefined behavior&quot; as giving compiler writers license to assume that programs will never receive inputs that would cause Undefined Behavior, and to arbitrarily change all aspects of how the programs behave when they receive such inputs.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment62399199_14487077&quot;&gt;&lt;span title=&quot;2016-05-25 22:30:45Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;May 25, 2016 at 22:30&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Another point I just noticed: C89 did not use the term &quot;extension&quot; to describe features that were guaranteed on some implementations but not others.  The authors of C89 recognized that the majority of then-current implementations would treat signed arithmetic and unsigned arithmetic identically except when the results were used in certain ways, and such treatment applied even in case of signed overflow; they did not list that as a common extention in Annex J2, however, which suggests to me they viewed it as a natural state of affairs, rather than an extension.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment65435870_14487077&quot;&gt;&lt;span title=&quot;2016-08-19 15:49:55Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Aug 19, 2016 at 15:49&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;There are two kinds of compilers: those which, unless explicitly documented otherwise, interpret most of the Standard&apos;s forms of Undefined Behavior as falling back upon characteristic behaviors documented by the underlying environment, and those which by default only usefully expose behaviors which the Standard characterizes as Implementation-Defined.  When using compilers of the first type, many things of the first type can be done efficiently and safely using UB. Compilers for the second type will only be suitable for such tasks if they provide options to guarantee behavior in such cases.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment76836228_2398003&quot;&gt;&lt;span title=&quot;2017-07-05 15:23:09Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jul 5, 2017 at 15:23&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;I think it&apos;s important to note that the practical meaning of &quot;undefined&quot; has changed over the last few years.  It used to be that given &lt;code&gt;uint32_t s;&lt;/code&gt;, evaluating &lt;code&gt;1u&amp;lt;&amp;lt;s&lt;/code&gt; when &lt;code&gt;s&lt;/code&gt; is 33 could be expected to maybe yield 0 or maybe yield 2, but not do anything else wacky.  Newer compilers, however, evaluating &lt;code&gt;1u&amp;lt;&amp;lt;s&lt;/code&gt; may cause a compiler to determine that because &lt;code&gt;s&lt;/code&gt; must have been less than 32 beforehand, any code before or after that expression which would only be relevant if &lt;code&gt;s&lt;/code&gt; had been 32 or greater may be omitted.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment47502991_29093246&quot;&gt;&lt;span title=&quot;2015-04-16 18:25:12Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 16, 2015 at 18:25&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;But handling undefined behavior in a nice way doesn&apos;t come for free.  The whole reason that modern compilers exhibit such bizarre behavior in some cases of UB is that they are relentlessly optimizing, and to do the best job at that, they have to be able to assume that UB never occurs.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/43839/tom-swirly&quot; title=&quot;2,680 reputation&quot; class=&quot;comment-user&quot;&gt;Tom Swirly&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment62387995_29664862&quot;&gt;&lt;span title=&quot;2016-05-25 16:24:38Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;May 25, 2016 at 16:24&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;But the fact that &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; is UB on negative numbers is a nasty little trap and I&apos;m glad to be reminded of that!&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/43839/tom-swirly&quot; title=&quot;2,680 reputation&quot; class=&quot;comment-user&quot;&gt;Tom Swirly&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment62388079_29664862&quot;&gt;&lt;span title=&quot;2016-05-25 16:27:17Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;May 25, 2016 at 16:27&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@TomSwirly: Unfortunately, compiler writers don&apos;t care that offering loose behavioral guarantees beyond those mandated by the Standard can often allow a massive speed boost compared with requiring that code avoid at all costs anything not defined by the Standard.  If a programmer doesn&apos;t care whether &lt;code&gt;i+j&amp;gt;k&lt;/code&gt; yields 1 or 0 in cases where the addition overflows, &lt;i&gt;provided it has no other side effects&lt;/i&gt;, a compiler may be able to make some massive optimizations that would not be possible if the programmer wrote the code as &lt;code&gt;(int)((unsigned)i+j) &amp;gt; k&lt;/code&gt;.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment62390792_29664862&quot;&gt;&lt;span title=&quot;2016-05-25 17:48:55Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;May 25, 2016 at 17:48&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@TomSwirly: To them, if compiler X can take a strictly-conforming program to do some task T and yield an executable that is 5% more efficient than compiler Y would yield with that same program, that means X is better, even if Y could generate code that did the same task three times as efficiently given a program that exploits behaviors that Y guarantees but X does not.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment62391254_29664862&quot;&gt;&lt;span title=&quot;2016-05-25 18:01:21Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;May 25, 2016 at 18:01&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@PSkocik: Consider as a simple scenario a situation where a &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;, and &lt;code&gt;k&lt;/code&gt; are arguments to a function a compiler is expanding in line for a function call &lt;code&gt;foo(x, y, x)&lt;/code&gt;.   In that scenario, a compiler could replace &lt;code&gt;i+j &amp;gt; k&lt;/code&gt; with &lt;code&gt;x+y &amp;gt; x&lt;/code&gt;, which it could in turn replaced with &lt;code&gt;y &amp;gt; 0&lt;/code&gt;, skipping the addition entirely, eliminating any dependency on the value of &lt;code&gt;x&lt;/code&gt;, and possibly allowing a compiler to eliminate the comparison and any dependency upon the exact value of &lt;code&gt;y&lt;/code&gt; if it can determine that &lt;code&gt;y&lt;/code&gt; will always be positive.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment125015516_29664862&quot;&gt;&lt;span title=&quot;2022-01-14 21:23:22Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Jan 14 at 21:23&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Constructs which the Standard characterizes as Undefined Behavior are &quot;non-portable &lt;i&gt;or&lt;/i&gt; erroneous&quot;, but the Standard makes no attempt to distinguish those which are erroneous from those which are non-portable &lt;i&gt;but correct&lt;/i&gt; when processed by the implementations for which they were written or others that are compatible with them.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment120207808_68006253&quot;&gt;&lt;span title=&quot;2021-06-16 22:42:05Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 16, 2021 at 22:42&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        "],"id":80,"title":"Undefined, unspecified and implementation-defined behavior","content":"\n                \n&lt;p&gt;What is &lt;em&gt;undefined behavior&lt;/em&gt; (UB) in C and C++?  What about &lt;em&gt;unspecified behavior&lt;/em&gt; and &lt;em&gt;implementation-defined&lt;/em&gt; behavior?  What is the difference between them?&lt;/p&gt;\n    ","slug":"undefined-unspecified-and-implementation-defined-behavior-1657384516085","postType":"QUESTION","createdAt":"2022-07-09T16:35:16.000Z","updatedAt":"2022-07-09T16:35:16.000Z","tags":[{"id":294,"name":"undefined-behavior","slug":"undefined-behavior","createdAt":"2022-07-09T16:35:16.000Z","updatedAt":"2022-07-09T16:35:16.000Z","Questions_Tags":{"questionId":80,"tagId":294}}]}]}},"__N_SSG":true}