{"pageProps":{"data":{"count":1,"rows":[{"answer":["\n&lt;p&gt;Put yourself in the compiler&apos;s position: when you forward declare a type, all the compiler knows is that this type exists; it knows nothing about its size, members, or methods. This is why it&apos;s called an &lt;em&gt;incomplete type&lt;/em&gt;. Therefore, you cannot use the type to declare a member, or a base class, since the compiler would need to know the layout of the type.&lt;/p&gt;\n\n&lt;p&gt;Assuming the following forward declaration.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;X&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here&apos;s what you can and cannot do.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;What you can do with an incomplete type:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;Declare a member to be a pointer or a reference to the incomplete type:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Foo&lt;/span&gt; {\n    X *p;\n    X &amp;amp;r;\n};\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;em&gt;Declare&lt;/em&gt; functions or methods which accept/return incomplete types:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(X)&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=&quot;hljs-function&quot;&gt;X    &lt;span class=&quot;hljs-title&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;em&gt;Define&lt;/em&gt; functions or methods which accept/return pointers/references to the incomplete type (but without using its members):&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f3&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(X*, X&amp;amp;)&lt;/span&gt; &lt;/span&gt;{}\n&lt;span class=&quot;hljs-function&quot;&gt;X&amp;amp;   &lt;span class=&quot;hljs-title&quot;&gt;f4&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;       &lt;/span&gt;{}\n&lt;span class=&quot;hljs-function&quot;&gt;X*   &lt;span class=&quot;hljs-title&quot;&gt;f5&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;       &lt;/span&gt;{}\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&lt;strong&gt;What you cannot do with an incomplete type:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;Use it as a base class&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Foo&lt;/span&gt; : X {} &lt;span class=&quot;hljs-comment&quot;&gt;// compiler error!&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Use it to declare a member:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Foo&lt;/span&gt; {\n    X m; &lt;span class=&quot;hljs-comment&quot;&gt;// compiler error!&lt;/span&gt;\n};\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;em&gt;Define&lt;/em&gt; functions or methods using this type&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(X x)&lt;/span&gt; &lt;/span&gt;{} &lt;span class=&quot;hljs-comment&quot;&gt;// compiler error!&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;X    &lt;span class=&quot;hljs-title&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;    &lt;/span&gt;{} &lt;span class=&quot;hljs-comment&quot;&gt;// compiler error!&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Use its methods or fields, in fact trying to dereference a variable with incomplete type&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Foo&lt;/span&gt; {\n    X *m;            \n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;            \n    &lt;/span&gt;{\n        m-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;someMethod&lt;/span&gt;();      &lt;span class=&quot;hljs-comment&quot;&gt;// compiler error!&lt;/span&gt;\n        &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = m-&amp;gt;someField; &lt;span class=&quot;hljs-comment&quot;&gt;// compiler error!&lt;/span&gt;\n    }\n};\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;When it comes to templates, there is no absolute rule: whether you can use an incomplete type as a template parameter is dependent on the way the type is used in the template.&lt;/p&gt;\n\n&lt;p&gt;For instance, &lt;code&gt;std::vector&amp;lt;T&amp;gt;&lt;/code&gt; requires its parameter to be a complete type, while &lt;code&gt;boost::container::vector&amp;lt;T&amp;gt;&lt;/code&gt; does not. Sometimes, a complete type is required only if you use certain member functions; &lt;a href=&quot;https://stackoverflow.com/questions/6012157/is-stdunique-ptrt-required-to-know-the-full-definition-of-t&quot;&gt;this is the case for &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, for example.&lt;/p&gt;\n\n&lt;p&gt;A well-documented template should indicate in its documentation all the requirements of its parameters, including whether they need to be complete types or not.&lt;/p&gt;\n    ","\n&lt;p&gt;The main rule is that you can only forward-declare classes whose memory layout (and thus member functions and data members) do not need to be known in the file you forward-declare it.&lt;/p&gt;\n\n&lt;p&gt;This would rule out base classes and anything but classes used via references and pointers.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201633620&quot; rel=&quot;noreferrer&quot;&gt;Lakos&lt;/a&gt; distinguishes between class usage&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;em&gt;in-name-only&lt;/em&gt; (for which a forward declaration is sufficient) and&lt;/li&gt;\n&lt;li&gt;&lt;em&gt;in-size&lt;/em&gt; (for which the class definition is needed).&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;I&apos;ve never seen it pronounced more succinctly :)&lt;/p&gt;\n    ","\n&lt;p&gt;As well as pointers and references to incomplete types, you can also declare function prototypes that specify parameters and/or return values that are incomplete types.  However, you cannot &lt;em&gt;define&lt;/em&gt; a function having a parameter or return type that is incomplete, unless it is a pointer or reference.&lt;/p&gt;\n\n&lt;p&gt;Examples:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;X&lt;/span&gt;;              &lt;span class=&quot;hljs-comment&quot;&gt;// Forward declaration of X&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(X* px)&lt;/span&gt; &lt;/span&gt;{}      &lt;span class=&quot;hljs-comment&quot;&gt;// Legal: can always use a pointer&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(X&amp;amp;  x)&lt;/span&gt; &lt;/span&gt;{}      &lt;span class=&quot;hljs-comment&quot;&gt;// Legal: can always use a reference&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;X &lt;span class=&quot;hljs-title&quot;&gt;f3&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;             &lt;span class=&quot;hljs-comment&quot;&gt;// Legal: return value in function prototype&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f4&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(X)&lt;/span&gt;&lt;/span&gt;;            &lt;span class=&quot;hljs-comment&quot;&gt;// Legal: parameter in function prototype&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f5&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(X)&lt;/span&gt; &lt;/span&gt;{}          &lt;span class=&quot;hljs-comment&quot;&gt;// ILLEGAL: *definitions* require complete types&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;None of the answers so far describe when one can use a forward declaration of a class template. So, here it goes.&lt;/p&gt;\n\n&lt;p&gt;A class template can be forwarded declared as:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;X&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Following the structure of the &lt;a href=&quot;https://stackoverflow.com/a/553869/434551&quot;&gt;accepted answer&lt;/a&gt;,&lt;/p&gt;\n\n&lt;p&gt;Here&apos;s what you can and cannot do.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;What you can do with an incomplete type:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;Declare a member to be a pointer or a reference to the incomplete type in another class template:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Foo&lt;/span&gt; {\n    X&amp;lt;T&amp;gt;* ptr;\n    X&amp;lt;T&amp;gt;&amp;amp; ref;\n};\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Declare a member to be a pointer or a reference to one of its incomplete instantiations:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Foo&lt;/span&gt; {\n    X&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;* ptr;\n    X&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; ref;\n};\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Declare function templates or member function templates which accept/return incomplete types:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n   &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;      &lt;span class=&quot;hljs-title&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(X&amp;lt;T&amp;gt;)&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n   &lt;span class=&quot;hljs-function&quot;&gt;X&amp;lt;T&amp;gt;    &lt;span class=&quot;hljs-title&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Declare functions or member functions which accept/return one of its incomplete instantiations:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;      &lt;span class=&quot;hljs-title&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(X&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=&quot;hljs-function&quot;&gt;X&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;    &lt;span class=&quot;hljs-title&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Define function templates or member function templates which accept/return pointers/references to the incomplete type (but without using its members):&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n   &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;      &lt;span class=&quot;hljs-title&quot;&gt;f3&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(X&amp;lt;T&amp;gt;*, X&amp;lt;T&amp;gt;&amp;amp;)&lt;/span&gt; &lt;/span&gt;{}\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n   &lt;span class=&quot;hljs-function&quot;&gt;X&amp;lt;T&amp;gt;&amp;amp;   &lt;span class=&quot;hljs-title&quot;&gt;f4&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(X&amp;lt;T&amp;gt;&amp;amp; in)&lt;/span&gt; &lt;/span&gt;{ &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; in; }\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n   &lt;span class=&quot;hljs-function&quot;&gt;X&amp;lt;T&amp;gt;*   &lt;span class=&quot;hljs-title&quot;&gt;f5&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(X&amp;lt;T&amp;gt;* in)&lt;/span&gt; &lt;/span&gt;{ &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; in; }\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Define functions or methods which accept/return pointers/references to one of its incomplete instantiations  (but without using its members):&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;      &lt;span class=&quot;hljs-title&quot;&gt;f3&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(X&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;*, X&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp;)&lt;/span&gt; &lt;/span&gt;{}\n&lt;span class=&quot;hljs-function&quot;&gt;X&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp;   &lt;span class=&quot;hljs-title&quot;&gt;f4&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(X&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; in)&lt;/span&gt; &lt;/span&gt;{ &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; in; }\n&lt;span class=&quot;hljs-function&quot;&gt;X&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;*   &lt;span class=&quot;hljs-title&quot;&gt;f5&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(X&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;* in)&lt;/span&gt; &lt;/span&gt;{ &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; in; }\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Use it as a base class of another template class&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Foo&lt;/span&gt; : X&amp;lt;T&amp;gt; {} &lt;span class=&quot;hljs-comment&quot;&gt;// OK as long as X is defined before&lt;/span&gt;\n                    &lt;span class=&quot;hljs-comment&quot;&gt;// Foo is instantiated.&lt;/span&gt;\n\nFoo&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt; a1; &lt;span class=&quot;hljs-comment&quot;&gt;// Compiler error.&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;X&lt;/span&gt; {};\nFoo&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt; a2; &lt;span class=&quot;hljs-comment&quot;&gt;// OK since X is now defined.&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Use it to declare a member of another class template:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Foo&lt;/span&gt; {\n    X&amp;lt;T&amp;gt; m; &lt;span class=&quot;hljs-comment&quot;&gt;// OK as long as X is defined before&lt;/span&gt;\n            &lt;span class=&quot;hljs-comment&quot;&gt;// Foo is instantiated. &lt;/span&gt;\n};\n\nFoo&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt; a1; &lt;span class=&quot;hljs-comment&quot;&gt;// Compiler error.&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;X&lt;/span&gt; {};\nFoo&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt; a2; &lt;span class=&quot;hljs-comment&quot;&gt;// OK since X is now defined.&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;em&gt;Define&lt;/em&gt; function templates or methods using this type&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;    &lt;span class=&quot;hljs-title&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(X&amp;lt;T&amp;gt; x)&lt;/span&gt; &lt;/span&gt;{}    &lt;span class=&quot;hljs-comment&quot;&gt;// OK if X is defined before calling f1&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n  &lt;span class=&quot;hljs-function&quot;&gt;X&amp;lt;T&amp;gt;    &lt;span class=&quot;hljs-title&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;X&lt;/span&gt;&amp;lt;T&amp;gt;(); }  &lt;span class=&quot;hljs-comment&quot;&gt;// OK if X is defined before calling f2&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;test1&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n   &lt;span class=&quot;hljs-built_in&quot;&gt;f1&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;X&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;());  &lt;span class=&quot;hljs-comment&quot;&gt;// Compiler error&lt;/span&gt;\n   &lt;span class=&quot;hljs-built_in&quot;&gt;f2&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;();     &lt;span class=&quot;hljs-comment&quot;&gt;// Compiler error&lt;/span&gt;\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;X&lt;/span&gt; {};\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;test2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n   &lt;span class=&quot;hljs-built_in&quot;&gt;f1&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;X&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;());  &lt;span class=&quot;hljs-comment&quot;&gt;// OK since X is defined now&lt;/span&gt;\n   &lt;span class=&quot;hljs-built_in&quot;&gt;f2&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;();     &lt;span class=&quot;hljs-comment&quot;&gt;// OK since X is defined now&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&lt;strong&gt;What you cannot do with an incomplete type:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;Use one of its instantiations as a base class&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Foo&lt;/span&gt; : X&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt; {} &lt;span class=&quot;hljs-comment&quot;&gt;// compiler error!&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Use one of its instantiations to declare a member:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Foo&lt;/span&gt; {\n    X&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt; m; &lt;span class=&quot;hljs-comment&quot;&gt;// compiler error!&lt;/span&gt;\n};\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;em&gt;Define&lt;/em&gt; functions or methods using one of its instantiations&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;      &lt;span class=&quot;hljs-title&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(X&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt; x)&lt;/span&gt; &lt;/span&gt;{}            &lt;span class=&quot;hljs-comment&quot;&gt;// compiler error!&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;X&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;    &lt;span class=&quot;hljs-title&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;X&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;(); }   &lt;span class=&quot;hljs-comment&quot;&gt;// compiler error!&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Use the methods or fields of one of its instantiations, in fact trying to dereference a variable with incomplete type&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Foo&lt;/span&gt; {\n    X&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;* m;            \n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;            \n    &lt;/span&gt;{\n        m-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;someMethod&lt;/span&gt;();      &lt;span class=&quot;hljs-comment&quot;&gt;// compiler error!&lt;/span&gt;\n        &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = m-&amp;gt;someField; &lt;span class=&quot;hljs-comment&quot;&gt;// compiler error!&lt;/span&gt;\n    }\n};\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Create explicit instantiations of the class template&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;X&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;;\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;In file in which you use only Pointer or Reference to a class.And no member/member function should be invoked thought those Pointer/ reference.&lt;/p&gt;\n\n&lt;p&gt;with &lt;code&gt;class Foo;&lt;/code&gt;//forward declaration&lt;/p&gt;\n\n&lt;p&gt;We can declare data members of type Foo* or Foo&amp;amp;.&lt;/p&gt;\n\n&lt;p&gt;We can declare (but not define) functions with arguments, and/or return values, of type Foo.&lt;/p&gt;\n\n&lt;p&gt;We can declare static data members of type Foo. This is because static data members are defined outside the class definition.&lt;/p&gt;\n    ","\n&lt;p&gt;I&apos;m writing this as a separate answer rather than just a comment because I disagree with Luc Touraille&apos;s answer, not on the grounds of legality but for robust software and the danger of misinterpretation.&lt;/p&gt;\n\n&lt;p&gt;Specifically, I have an issue with the implied contract of what you expect users of your interface to have to know.&lt;/p&gt;\n\n&lt;p&gt;If you are returning or accepting reference types, then you are just saying they can pass through a pointer or reference which they may in turn have known only through a forward declaration.&lt;/p&gt;\n\n&lt;p&gt;When you are returning an incomplete type &lt;code&gt;X    f2();&lt;/code&gt; then you are saying your caller &lt;strong&gt;must&lt;/strong&gt; have the full type specification of X. They need it in order to create the LHS or temporary object at the call site.&lt;/p&gt;\n\n&lt;p&gt;Similarly, if you accept an incomplete type, the caller has to have constructed the object which is the parameter. Even if that object was returned as another incomplete type from a function, the call site needs the full declaration. i.e.:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;X&lt;/span&gt;;  &lt;span class=&quot;hljs-comment&quot;&gt;// forward for two legal declarations &lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;X &lt;span class=&quot;hljs-title&quot;&gt;returnsX&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;XAcceptor&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(X)&lt;/span&gt;&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;XAcepptor&lt;/span&gt;( &lt;span class=&quot;hljs-built_in&quot;&gt;returnsX&lt;/span&gt;() );  &lt;span class=&quot;hljs-comment&quot;&gt;// X declaration needs to be known here&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I think there&apos;s an important principle that a header should supply enough information to use it without a dependency requiring other headers. That means header should be able to be included in a  compilation unit without causing a compiler error when you use any functions it declares.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Except&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;If this external dependency is &lt;strong&gt;desired&lt;/strong&gt; behaviour. Instead of using conditional compilation you could have a &lt;em&gt;well-documented&lt;/em&gt; requirement for them to supply their own header declaring X. This is an alternative to using #ifdefs and can be a useful way to introduce mocks or other variants.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;The important distinction being some template techniques where you are explicitly NOT expected to instantiate them, mentioned just so someone doesn&apos;t get snarky with me.&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n    ","\n&lt;p&gt;The general rule I follow is not to include any header file unless I have to.  So unless I am storing the object of a class as a member variable of my class I won&apos;t include it, I&apos;ll just use the forward declaration.&lt;/p&gt;\n    ","\n&lt;p&gt;As long as you don&apos;t need the definition (think pointers and references) you can get away with forward declarations. This is why mostly you&apos;d see them in headers while implementation files typically will pull the header for the appropriate definition(s).&lt;/p&gt;\n    ","\n&lt;p&gt;You will usually want to use forward declaration in a classes header file when you want to use the other type (class) as a member of the class. You can not use the forward-declared classes &lt;em&gt;methods&lt;/em&gt; in the header file because C++ does not know the definition of that class at that point yet. That&apos;s logic you have to move into the .cpp-files, but if you are using template-functions you should reduce them to only the part that uses the template and move that function into the header. &lt;/p&gt;\n    ","\n&lt;p&gt;Take it that forward declaration will get your code to compile (obj is created). Linking however (exe creation) will not be successfull unless the definitions are found. &lt;/p&gt;\n    ","\n&lt;p&gt;I just want to add one important thing you can do with a forwarded class not mentioned in the answer of Luc Touraille.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;What you can do with an incomplete type:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;Define&lt;/em&gt; functions or methods which accept/return \npointers/references to the incomplete type and forward that pointers/references \nto another function.     &lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;  &lt;span class=&quot;hljs-title&quot;&gt;f6&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(X*)&lt;/span&gt;       &lt;/span&gt;{}\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;  &lt;span class=&quot;hljs-title&quot;&gt;f7&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(X&amp;amp;)&lt;/span&gt;       &lt;/span&gt;{}\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;  &lt;span class=&quot;hljs-title&quot;&gt;f8&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(X* x_ptr, X&amp;amp; x_ref)&lt;/span&gt; &lt;/span&gt;{ &lt;span class=&quot;hljs-built_in&quot;&gt;f6&lt;/span&gt;(x_ptr); &lt;span class=&quot;hljs-built_in&quot;&gt;f7&lt;/span&gt;(x_ref); }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;A module can pass through an object of a forward declared class to another module.&lt;/p&gt;\n    ","\n&lt;p&gt;As, Luc Touraille has already explained it very well where to use and not use forward declaration of the class.&lt;/p&gt;\n\n&lt;p&gt;I will just add to that why we need to use it.&lt;/p&gt;\n\n&lt;p&gt;We should be using Forward declaration wherever possible to avoid the unwanted dependency injection.&lt;/p&gt;\n\n&lt;p&gt;As &lt;code&gt;#include&lt;/code&gt; header files are added on multiple files therefore, if we add a header into another header file it will add unwanted dependency injection in various parts of source code which can be avoided by adding &lt;code&gt;#include&lt;/code&gt; header into &lt;code&gt;.cpp&lt;/code&gt; files wherever possible rather than adding to another header file and use class forward declaration wherever possible in header &lt;code&gt;.h&lt;/code&gt; files.&lt;/p&gt;\n    "],"id":516,"title":"When can I use a forward declaration?","slug":"when-can-i-use-a-forward-declaration-1657388251827","postType":"QUESTION","createdAt":"2022-07-09T17:37:31.000Z","updatedAt":"2022-07-09T17:37:31.000Z","tags":[{"id":2555,"name":"forward-declaration","slug":"forward-declaration","createdAt":"2022-07-09T17:37:31.000Z","updatedAt":"2022-07-09T17:37:31.000Z","Questions_Tags":{"questionId":516,"tagId":2555}}]}]}},"__N_SSG":true}