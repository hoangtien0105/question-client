<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2eccd4d47c856f2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2eccd4d47c856f2b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/81-096e453de8a27667.js" defer=""></script><script src="/_next/static/chunks/pages/questions/tag/%5Bslug%5D-6802ea06aeddcbec.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_buildManifest.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5"></style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="https://flowbite.com/docs/images/logo.svg" class="mr-3 h-6 sm:h-9" alt="Flowbite Logo"/><span class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Hunter</span></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/tag/iostream#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="flex items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/why-is-iostream::eof-inside-a-loop-condition-(i.e.-while-(!stream.eof()))-considered-wrong-1657384355427">Why is iostream::eof inside a loop condition (i.e. `while (!stream.eof())`) considered wrong?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/iostream">iostream</a></div></div><div class="mt-4 mb-6" style="height:100px;overflow:auto"><h4 class="font-semibold">Solution 1:</h4><div class="text-sm bg-green-100 text-neutral-600">
<p>Because <code>iostream::eof</code> will only return <code>true</code> <em>after</em> reading the end of the stream. It does <em>not</em> indicate, that the next read will be the end of the stream.</p>

<p>Consider this (and assume then next read will be at the end of the stream):</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span>(!inStream.<span class="hljs-built_in">eof</span>()){
  <span class="hljs-type">int</span> data;
  <span class="hljs-comment">// yay, not end of stream yet, now read ...</span>
  inStream &gt;&gt; data;
  <span class="hljs-comment">// oh crap, now we read the end and *only* now the eof bit will be set (as well as the fail bit)</span>
  <span class="hljs-comment">// do stuff with (now uninitialized) data</span>
}
</code></pre>

<p>Against this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> data;
<span class="hljs-keyword">while</span>(inStream &gt;&gt; data){
  <span class="hljs-comment">// when we land here, we can be sure that the read was successful.</span>
  <span class="hljs-comment">// if it wasn't, the returned stream from operator&gt;&gt; would be converted to false</span>
  <span class="hljs-comment">// and the loop wouldn't even be entered</span>
  <span class="hljs-comment">// do stuff with correctly initialized data (hopefully)</span>
}
</code></pre>

<p>And on your second question: Because</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"..."</span>,...)!=EOF)
</code></pre>

<p>is the same as</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">if</span>(!(inStream &gt;&gt; data).<span class="hljs-built_in">eof</span>())
</code></pre>

<p>and <strong>not</strong> the same as</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">if</span>(!inStream.<span class="hljs-built_in">eof</span>())
    inFile &gt;&gt; data
</code></pre>
    </div></div><div><div class="flex items-center justify-between text-slate-500"><div class="flex space-x-4 md:space-x-8"><div class="flex cursor-pointer items-center transition hover:text-slate-600"><svg xmlns="http://www.w3.org/2000/svg" class="mr-1.5 h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M14 10h4.764a2 2 0 011.789 2.894l-3.5 7A2 2 0 0115.263 21h-4.017c-.163 0-.326-.02-.485-.06L7 20m7-10V5a2 2 0 00-2-2h-.095c-.5 0-.905.405-.905.905 0 .714-.211 1.412-.608 2.006L7 11v9m7-10h-2M7 20H5a2 2 0 01-2-2v-6a2 2 0 012-2h2.5"></path></svg><span>4</span></div></div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"count":1,"rows":[{"answer":["\n\u0026lt;p\u0026gt;Because \u0026lt;code\u0026gt;iostream::eof\u0026lt;/code\u0026gt; will only return \u0026lt;code\u0026gt;true\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;after\u0026lt;/em\u0026gt; reading the end of the stream. It does \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; indicate, that the next read will be the end of the stream.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Consider this (and assume then next read will be at the end of the stream):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(!inStream.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;()){\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// yay, not end of stream yet, now read ...\u0026lt;/span\u0026gt;\n  inStream \u0026amp;gt;\u0026amp;gt; data;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// oh crap, now we read the end and *only* now the eof bit will be set (as well as the fail bit)\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// do stuff with (now uninitialized) data\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Against this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(inStream \u0026amp;gt;\u0026amp;gt; data){\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// when we land here, we can be sure that the read was successful.\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// if it wasn\u0026apos;t, the returned stream from operator\u0026amp;gt;\u0026amp;gt; would be converted to false\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// and the loop wouldn\u0026apos;t even be entered\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// do stuff with correctly initialized data (hopefully)\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And on your second question: Because\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;scanf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;...\u0026quot;\u0026lt;/span\u0026gt;,...)!=EOF)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;is the same as\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(!(inStream \u0026amp;gt;\u0026amp;gt; data).\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;())\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and \u0026lt;strong\u0026gt;not\u0026lt;/strong\u0026gt; the same as\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(!inStream.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;())\n    inFile \u0026amp;gt;\u0026amp;gt; data\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Bottom-line top:\u0026lt;/strong\u0026gt;  With proper handling of white-space, the following is how \u0026lt;code\u0026gt;eof\u0026lt;/code\u0026gt; can be used (and even, be more reliable than \u0026lt;code\u0026gt;fail()\u0026lt;/code\u0026gt; for error checking):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( !(in\u0026amp;gt;\u0026amp;gt;std::ws).\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;() ) {  \n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n   in \u0026amp;gt;\u0026amp;gt; data;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ( in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;() ) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* handle with break or throw */\u0026lt;/span\u0026gt;; \n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// now use data\u0026lt;/span\u0026gt;\n}    \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;(\u0026lt;em\u0026gt;Thanks Tony D for the suggestion to highlight the answer. See his comment below for an example to why this is more robust.\u0026lt;/em\u0026gt;)\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;The main argument against using \u0026lt;code\u0026gt;eof()\u0026lt;/code\u0026gt; seems to be missing an important subtlety about the role of white space. My proposition is that, checking \u0026lt;code\u0026gt;eof()\u0026lt;/code\u0026gt; explicitly is not only not \u0026quot;\u0026lt;em\u0026gt;always wrong\u0026lt;/em\u0026gt;\u0026quot; -- which seems to be an overriding opinion in this and similar SO threads --, but with proper handling of white-space, it provides for a cleaner and more reliable error handling, and is the \u0026lt;em\u0026gt;always correct\u0026lt;/em\u0026gt; solution (although, not necessarily the tersest).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To summarize what is being suggested as the \u0026quot;proper\u0026quot; termination and read order is the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(in \u0026amp;gt;\u0026amp;gt; data) {  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; }\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// which is equivalent to \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( !(in \u0026amp;gt;\u0026amp;gt; data).\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;() )  {  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The failure due to read attempt beyond eof is taken as the termination condition.  This means is that there is no easy way to distinguish between a successful stream and one that really fails for reasons other than eof. Take the following streams: \u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;1 2 3 4 5\u0026amp;lt;eof\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;1 2 a 3 4 5\u0026amp;lt;eof\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;a\u0026amp;lt;eof\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;while(in\u0026amp;gt;\u0026amp;gt;data)\u0026lt;/code\u0026gt; terminates with a set \u0026lt;code\u0026gt;failbit\u0026lt;/code\u0026gt; for \u0026lt;em\u0026gt;all\u0026lt;/em\u0026gt; three input. In the first and third, \u0026lt;code\u0026gt;eofbit\u0026lt;/code\u0026gt; is also set. So past the loop one needs very ugly extra logic to distinguish a proper input (1st) from improper ones (2nd and 3rd).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Whereas, take the following: \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( !in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;() ) \n{  \n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n   in \u0026amp;gt;\u0026amp;gt; data;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ( in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;() ) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* handle with break or throw */\u0026lt;/span\u0026gt;; \n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// now use data\u0026lt;/span\u0026gt;\n}    \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here, \u0026lt;code\u0026gt;in.fail()\u0026lt;/code\u0026gt; verifies that as long as there is something to read, it is the correct one. It\u0026apos;s purpose is not a mere while-loop terminator. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So far so good, but what happens if there is trailing space in the stream -- what sounds like the major concern against \u0026lt;code\u0026gt;eof()\u0026lt;/code\u0026gt; as terminator?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;We don\u0026apos;t need to surrender our error handling; just eat up the white-space:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( !in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;() ) \n{  \n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n   in \u0026amp;gt;\u0026amp;gt; data \u0026amp;gt;\u0026amp;gt; ws; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// eat whitespace with std::ws\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ( in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;() ) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* handle with break or throw */\u0026lt;/span\u0026gt;; \n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// now use data\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;std::ws\u0026lt;/code\u0026gt; skips any potential (zero or more) trailing space in the stream while setting the \u0026lt;code\u0026gt;eofbit\u0026lt;/code\u0026gt;, and \u0026lt;strong\u0026gt;not the \u0026lt;code\u0026gt;failbit\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;.  So, \u0026lt;code\u0026gt;in.fail()\u0026lt;/code\u0026gt; works as expected, as long as there is at least one data to read. If all-blank streams are also acceptable, then the correct form is:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( !(in\u0026amp;gt;\u0026amp;gt;ws).\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;() ) \n{  \n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n   in \u0026amp;gt;\u0026amp;gt; data; \n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ( in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;() ) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* handle with break or throw */\u0026lt;/span\u0026gt;; \n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* this will never fire if the eof is reached cleanly */\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// now use data\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Summary:\u0026lt;/strong\u0026gt; A properly constructed \u0026lt;code\u0026gt;while(!eof)\u0026lt;/code\u0026gt; is not only possible and not wrong, but allows data to be localized within scope, and provides a cleaner separation of error checking from business as usual.  That being said, \u0026lt;code\u0026gt;while(!fail)\u0026lt;/code\u0026gt; is inarguably a more common and terse idiom, and may be preferred in simple (single data per read type of) scenarios. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Because if programmers don\u0026apos;t write \u0026lt;code\u0026gt;while(stream \u0026amp;gt;\u0026amp;gt; n)\u0026lt;/code\u0026gt;, they possibly write this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(!stream.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;())\n{\n    stream \u0026amp;gt;\u0026amp;gt; n;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//some work on n;\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here the problem is, you cannot do \u0026lt;code\u0026gt;some work on n\u0026lt;/code\u0026gt; without first checking if the stream read was successful, because if it was unsuccessful, your \u0026lt;code\u0026gt;some work on n\u0026lt;/code\u0026gt; would produce undesired result.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The whole point is that, \u0026lt;code\u0026gt;eofbit\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;badbit\u0026lt;/code\u0026gt;, or \u0026lt;code\u0026gt;failbit\u0026lt;/code\u0026gt; are set \u0026lt;strong\u0026gt;after an attempt is made to read from the stream.\u0026lt;/strong\u0026gt; So if \u0026lt;code\u0026gt;stream \u0026amp;gt;\u0026amp;gt; n\u0026lt;/code\u0026gt; fails, then \u0026lt;code\u0026gt;eofbit\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;badbit\u0026lt;/code\u0026gt;, or \u0026lt;code\u0026gt;failbit\u0026lt;/code\u0026gt; is set immediately, so its more idiomatic if you write \u0026lt;code\u0026gt;while (stream \u0026amp;gt;\u0026amp;gt; n)\u0026lt;/code\u0026gt;, because the returned object \u0026lt;code\u0026gt;stream\u0026lt;/code\u0026gt; converts to \u0026lt;code\u0026gt;false\u0026lt;/code\u0026gt; if there was some failure in reading from the stream and consequently the loop stops. And it converts to \u0026lt;code\u0026gt;true\u0026lt;/code\u0026gt; if the read was successful and the loop continues.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The other answers have explained why the logic is wrong in \u0026lt;code\u0026gt;while (!stream.eof())\u0026lt;/code\u0026gt; and how to fix it. I want to focus on something different:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;why is checking for eof explicitly using \u0026lt;code\u0026gt;iostream::eof\u0026lt;/code\u0026gt; wrong?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;In general terms, checking for \u0026lt;code\u0026gt;eof\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;only\u0026lt;/em\u0026gt; is wrong because stream extraction (\u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt;) can fail without hitting the end of the file. If you have e.g. \u0026lt;code\u0026gt;int n; cin \u0026amp;gt;\u0026amp;gt; n;\u0026lt;/code\u0026gt; and the stream contains \u0026lt;code\u0026gt;hello\u0026lt;/code\u0026gt;, then \u0026lt;code\u0026gt;h\u0026lt;/code\u0026gt; is not a valid digit, so extraction will fail without reaching the end of the input.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This issue, combined with the general logic error of checking the stream state \u0026lt;em\u0026gt;before\u0026lt;/em\u0026gt; attempting to read from it, which means for N input items the loop will run N+1 times, leads to the following symptoms:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If the stream is empty, the loop will run once. \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; will fail (there is no input to be read) and all variables that were supposed to be set (by \u0026lt;code\u0026gt;stream \u0026amp;gt;\u0026amp;gt; x\u0026lt;/code\u0026gt;) are actually uninitialized. This leads to garbage data being processed, which can manifest as nonsensical results (often huge numbers).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;(If your standard library conforms to C++11, things are a bit different now: A failed \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; now sets numeric variables to \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt; instead of leaving them uninitialized (except for \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt;s).)\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If the stream is not empty, the loop will run again after the last valid input. Since in the last iteration all \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; operations fail, variables are likely to keep their value from the previous iteration. This can manifest as \u0026quot;the last line is printed twice\u0026quot; or \u0026quot;the last input record is processed twice\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;(This should manifest a bit differently since C++11 (see above): Now you get a \u0026quot;phantom record\u0026quot; of zeroes instead of a repeated last line.)\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If the stream contains malformed data but you only check for \u0026lt;code\u0026gt;.eof\u0026lt;/code\u0026gt;, you end up with an infinite loop. \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; will fail to extract any data from the stream, so the loop spins in place without ever reaching the end.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;To recap: The solution is to test the success of the \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; operation itself, not to use a separate \u0026lt;code\u0026gt;.eof()\u0026lt;/code\u0026gt; method: \u0026lt;code\u0026gt;while (stream \u0026amp;gt;\u0026amp;gt; n \u0026amp;gt;\u0026amp;gt; m) { ... }\u0026lt;/code\u0026gt;, just as in C you test the success of the \u0026lt;code\u0026gt;scanf\u0026lt;/code\u0026gt; call itself: \u0026lt;code\u0026gt;while (scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;amp;n, \u0026amp;amp;m) == 2) { ... }\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The important thing to remember is that, \u0026lt;code\u0026gt;inFile.eof()\u0026lt;/code\u0026gt; doesnt become \u0026lt;code\u0026gt;True\u0026lt;/code\u0026gt; until \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;after\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; an attempted read fails, because youve reached the end of the file. So, in this example, youll get an error.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (!inFile.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;()){\n    inFile \u0026amp;gt;\u0026amp;gt; x;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;process\u0026lt;/span\u0026gt;(x);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The way to make this loop correct, is to combine reading and checking into a single operation, like so\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (inFile \u0026amp;gt;\u0026amp;gt; x)\u0026amp;nbsp;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;process\u0026lt;/span\u0026gt;(x);\u0026amp;nbsp;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;By convention, \u0026lt;code\u0026gt;operator\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; returns the stream we read from, and a Boolean test on a stream returns \u0026lt;code\u0026gt;False\u0026lt;/code\u0026gt; when the stream fails (such as reaching end of file).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;So this gives us the correct sequence :\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;read\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;test whether the read succeeds\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;if and only if the test succeeds, process what weve read\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;If you happen to encounter some \u0026lt;em\u0026gt;other\u0026lt;/em\u0026gt; problem that prevents you from reading from the file correctly, you will not be able to reach \u0026lt;code\u0026gt;eof()\u0026lt;/code\u0026gt; as such. For example, lets look at something like this\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x;\u0026amp;nbsp;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (!inFile.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;()) {\u0026amp;nbsp;\n    inFile \u0026amp;gt;\u0026amp;gt; x;\u0026amp;nbsp;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;process\u0026lt;/span\u0026gt;(x);\n}\u0026amp;nbsp;\n    \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Let us trace through the working of the above code, with an example\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Assume the contents of the file are \u0026lt;code\u0026gt;\u0026apos;1\u0026apos;, \u0026apos;2\u0026apos;, \u0026apos;3\u0026apos;, \u0026apos;a\u0026apos;, \u0026apos;b\u0026apos;\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The loop will read the 1, 2, and 3 correctly.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Then itll get to \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;When it tries to extract \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; as an int, itll fail.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The stream is now in a failed state, until or unless we \u0026lt;code\u0026gt;clear\u0026lt;/code\u0026gt; the stream, all attempts at reading from it will fail.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;But, when we test for eof(), itll return \u0026lt;code\u0026gt;False\u0026lt;/code\u0026gt;, because were not at the end of the file, because theres still \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; waiting to be read.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The loop will keep trying to read from the file, and fail every time, so it \u0026lt;strong\u0026gt;never\u0026lt;/strong\u0026gt; reaches the end of the file.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;So, the loop above will run forever.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;But, if we use a loop like this, we will get the required output.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (inFile \u0026amp;gt;\u0026amp;gt; x)\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;process\u0026lt;/span\u0026gt;(x);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In this case, the stream will convert to \u0026lt;code\u0026gt;False\u0026lt;/code\u0026gt; not only in case of end of file, but also in case of a failed conversion, such as the \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; that we cant read as an integer.\u0026lt;/p\u0026gt;\n    "],"comment":["\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026lt;code\u0026gt;scanf(...) != EOF\u0026lt;/code\u0026gt; won\u0026apos;t work in C either, because \u0026lt;code\u0026gt;scanf\u0026lt;/code\u0026gt; returns the number of fields successfully parsed and assigned.  The correct condition is \u0026lt;code\u0026gt;scanf(...) \u0026amp;lt; n\u0026lt;/code\u0026gt; where \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt; is the number of fields in the format string.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/103167/ben-voigt\u0026quot; title=\u0026quot;270,533 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Ben Voigt\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment12832536_5605125\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-04-05 16:50:42Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 5, 2012 at 16:50\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Ben Voigt, it will return a negative number (which EOF usually is defined as such) in case EOF is reached\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/281306/sebastian\u0026quot; title=\u0026quot;5,863 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Sebastian\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment18536882_5605125\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-11-23 23:44:41Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 23, 2012 at 23:44\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@SebastianGodelet: Actually, it will return \u0026lt;code\u0026gt;EOF\u0026lt;/code\u0026gt; if end of file is encountered before the first field conversion (successful or not).  If end-of-file is reached between fields, it will return the number of fields succcessfully converted and stored.  Which makes comparison to \u0026lt;code\u0026gt;EOF\u0026lt;/code\u0026gt; wrong.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/103167/ben-voigt\u0026quot; title=\u0026quot;270,533 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Ben Voigt\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment18545887_5605125\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-11-24 15:06:27Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 24, 2012 at 15:06\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@SebastianGodelet: No, not really.  He errs when he says that \u0026quot;past the loop there is no (easy) way to distinguish a proper input from an improper one\u0026quot;.  In fact it\u0026apos;s as easy as checking \u0026lt;code\u0026gt;.eof()\u0026lt;/code\u0026gt; after the loop exits.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/103167/ben-voigt\u0026quot; title=\u0026quot;270,533 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Ben Voigt\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment18547414_5605125\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-11-24 16:52:48Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 24, 2012 at 16:52\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Ben Yes, for this case (reading a simple int). But one can easily come up with a scenario where \u0026lt;code\u0026gt;while(fail)\u0026lt;/code\u0026gt; loop terminates with both an actual failure and an eof. Think about if you require 3 ints per iteration (say you are reading an x-y-z point or something), but there is, erroneously, only two ints in the stream.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/108461/sly\u0026quot; title=\u0026quot;1,642 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;sly\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment18550194_5605125\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-11-24 19:47:17Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 24, 2012 at 19:47\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Worth mentioning is that if (!(inStream \u0026amp;gt;\u0026amp;gt; data).eof()) doesn\u0026apos;t do anything useful either. Fallacy 1: It\u0026apos;ll not enter the condition if there was no whitespace after the last piece of data (last datum will not be processed). Fallacy 2: It will enter the condition even if reading data failed, as long as EOF was not reached (infinite loop, processing the same old data over and over again).\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/238233/tronic\u0026quot; title=\u0026quot;10,042 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Tronic\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment20081828_5605159\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-01-20 16:20:10Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 20, 2013 at 16:20\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I think it\u0026apos;s worth pointing out that this answer is slightly misleading. When extracting \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;s or \u0026lt;code\u0026gt;std::string\u0026lt;/code\u0026gt;s or similar, the EOF bit \u0026lt;i\u0026gt;is\u0026lt;/i\u0026gt; set when you extract the one right before the end and the extraction hits the end. You do not need to read again. The reason it doesn\u0026apos;t get set when reading from files is because there\u0026apos;s an extra \u0026lt;code\u0026gt;\\n\u0026lt;/code\u0026gt; at the end. I\u0026apos;ve covered this in \u0026lt;a href=\u0026quot;http://stackoverflow.com/a/14615673/150634\u0026quot;\u0026gt;another answer\u0026lt;/a\u0026gt;. Reading \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt;s is a different matter because it only extracts one at a time and doesn\u0026apos;t continue to hit the end.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/150634/joseph-mansfield\u0026quot; title=\u0026quot;105,003 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Joseph Mansfield\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment22561833_5605159\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-04-06 16:59:44Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 6, 2013 at 16:59\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;The main problem is that \u0026lt;b\u0026gt;just because we haven\u0026apos;t reached the EOF, doesn\u0026apos;t mean the next read will succeed\u0026lt;/b\u0026gt;.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/150634/joseph-mansfield\u0026quot; title=\u0026quot;105,003 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Joseph Mansfield\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment22561896_5605159\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-04-06 17:03:49Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 6, 2013 at 17:03\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@sftrabbit: all true but not very useful... even if there\u0026apos;s no trailing \u0026apos;\\n\u0026apos; it\u0026apos;s reasonable to want other trailing whitespace to be handled consistently with other whitespace throughout the file (i.e. skipped).  Further, a subtle consequence of \u0026quot;when you extract the one right before\u0026quot; is that \u0026lt;code\u0026gt;while (!eof())\u0026lt;/code\u0026gt; won\u0026apos;t \u0026quot;work\u0026quot; on \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;s or \u0026lt;code\u0026gt;std::string\u0026lt;/code\u0026gt;s when the input is totally empty, so even knowing there\u0026apos;s no trailing \u0026lt;code\u0026gt;\\n\u0026lt;/code\u0026gt; care is needed.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/410767/tony-delroy\u0026quot; title=\u0026quot;99,376 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Tony Delroy\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment23094105_5605159\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-04-23 03:34:22Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 23, 2013 at 3:34\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@TonyD Totally agree. The reason I\u0026apos;m saying it is because I think most people when they read this and similar answers will think that if the stream contains \u0026lt;code\u0026gt;\u0026quot;Hello\u0026quot;\u0026lt;/code\u0026gt; (no trailing whitespace or \u0026lt;code\u0026gt;\\n\u0026lt;/code\u0026gt;) and a \u0026lt;code\u0026gt;std::string\u0026lt;/code\u0026gt; is extracted, it will extract the letters from \u0026lt;code\u0026gt;H\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;o\u0026lt;/code\u0026gt;, stop extracting, and then \u0026lt;i\u0026gt;not\u0026lt;/i\u0026gt; set the EOF bit. In fact, it would set the EOF bit because it was the EOF that stopped the extraction. Just hoping to clear that up for people.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/150634/joseph-mansfield\u0026quot; title=\u0026quot;105,003 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Joseph Mansfield\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment23100620_5605159\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-04-23 08:23:10Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 23, 2013 at 8:23\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026quot;\u0026lt;i\u0026gt;So past the loop there is no (easy) way to distinguish a proper input from an improper one.\u0026lt;/i\u0026gt;\u0026quot; Except that in one case both \u0026lt;code\u0026gt;eofbit\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;failbit\u0026lt;/code\u0026gt; are set, in the other only \u0026lt;code\u0026gt;failbit\u0026lt;/code\u0026gt; is set. You only need to test that \u0026lt;i\u0026gt;once\u0026lt;/i\u0026gt; after the loop has terminated, not on every iteration; it will only leave the loop once, so you only need to check \u0026lt;i\u0026gt;why\u0026lt;/i\u0026gt; it left the loop once.  \u0026lt;code\u0026gt;while (in \u0026amp;gt;\u0026amp;gt; data)\u0026lt;/code\u0026gt; works fine for all blank streams.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/981959/jonathan-wakely\u0026quot; title=\u0026quot;160,851 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Jonathan Wakely\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment21189709_13536879\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-02-25 14:09:27Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 25, 2013 at 14:09\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;What you are saying (and a point made earlier) is that a bad formatted stream can be identified as \u0026lt;code\u0026gt;!eof \u0026amp;amp; fail\u0026lt;/code\u0026gt; past loop. There are cases in which one can not rely on this. See above comment (\u0026lt;a href=\u0026quot;http://goo.gl/9mXYX\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;goo.gl/9mXYX\u0026lt;/a\u0026gt;). Eitherway, I am not proposing \u0026lt;code\u0026gt;eof\u0026lt;/code\u0026gt;-check as \u0026lt;i\u0026gt;the-always-better\u0026lt;/i\u0026gt; alternative. I am merely saying, it \u0026lt;i\u0026gt;is\u0026lt;/i\u0026gt; a possible and (in some cases more appropriate) way of doing this, rather than \u0026quot;most certainly wrong!\u0026quot; as it tends to be claimed around here in SO.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/108461/sly\u0026quot; title=\u0026quot;1,642 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;sly\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment21193527_13536879\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-02-25 15:58:29Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 25, 2013 at 15:58\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 7 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026lt;i\u0026gt;\u0026quot;As an example, consider how you\u0026apos;d check for errors where the data is a struct with overloaded operator\u0026amp;gt;\u0026amp;gt; reading multiple fields at once\u0026quot;\u0026lt;/i\u0026gt; - a much simpler case supporting your point is \u0026lt;code\u0026gt;stream \u0026amp;gt;\u0026amp;gt; my_int\u0026lt;/code\u0026gt; where the stream contains e.g. \u0026quot;-\u0026quot;: \u0026lt;code\u0026gt;eofbit\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;failbit\u0026lt;/code\u0026gt; are set.  That\u0026apos;s worse than the \u0026lt;code\u0026gt;operator\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; scenario, where the user-provided overload at least has the option of clearing \u0026lt;code\u0026gt;eofbit\u0026lt;/code\u0026gt; before returning to help support \u0026lt;code\u0026gt;while (s \u0026amp;gt;\u0026amp;gt; x)\u0026lt;/code\u0026gt; usage.  More generally, this answer could use a clean-up - only the final \u0026lt;code\u0026gt;while( !(in\u0026amp;gt;\u0026amp;gt;ws).eof() )\u0026lt;/code\u0026gt; is generally robust, and it\u0026apos;s buried at the end.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/410767/tony-delroy\u0026quot; title=\u0026quot;99,376 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Tony Delroy\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment45712673_13536879\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-02-25 06:09:52Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 25, 2015 at 6:09\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;With your \u0026quot;3 examples\u0026quot; \u0026lt;i\u0026gt;only\u0026lt;/i\u0026gt; the first sets eof.  The third does not because the \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; fails conversion to int and is not read -- it will be left on the input.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/16406/chris-dodd\u0026quot; title=\u0026quot;112,580 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Chris Dodd\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment127062015_13536879\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2022-04-17 20:54:00Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 17 at 20:54\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;so? that\u0026apos;s is kind of the point: early break with a bad stream, or end-loop successfully with eof.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/108461/sly\u0026quot; title=\u0026quot;1,642 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;sly\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment127236554_13536879\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2022-04-26 01:58:03Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 26 at 1:58\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Apart from the mentioned \u0026quot;undesired result\u0026quot; with doing work on the undefined value of \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt;, the program might also fall into an \u0026lt;b\u0026gt;infinite loop\u0026lt;/b\u0026gt;, if the failing stream operation doesn\u0026apos;t consume any input.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/4271479/mastov\u0026quot; title=\u0026quot;2,847 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;mastov\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment87143702_5605161\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-04-27 13:33:26Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 27, 2018 at 13:33\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;this is the most accurate answer, although as of c++11, i dont believe the variables are uninitialized anymore(the first bullet pt)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/7183221/csguy\u0026quot; title=\u0026quot;1,273 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;csguy\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment101610687_55981331\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-08-20 13:52:12Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 20, 2019 at 13:52\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;?syntax error: undefined identifiers \u0026lt;code\u0026gt;True\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;False\u0026lt;/code\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/7143595/matg\u0026quot; title=\u0026quot;464 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;MatG\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment127497273_71187351\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2022-05-08 11:20:10Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 8 at 11:20\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        "],"id":35,"title":"Why is iostream::eof inside a loop condition (i.e. `while (!stream.eof())`) considered wrong?","content":"\n                \n\u0026lt;p\u0026gt;I just found a comment in \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/5578631/c-how-do-you-stop-reading-integer-from-text-file-when-encounter-negative-intege/5578649#5578649\u0026quot;\u0026gt;this\u0026lt;/a\u0026gt; answer saying that using \u0026lt;code\u0026gt;iostream::eof\u0026lt;/code\u0026gt; in a loop condition is \u0026quot;almost certainly wrong\u0026quot;. I generally use something like \u0026lt;code\u0026gt;while(cin\u0026amp;gt;\u0026amp;gt;n)\u0026lt;/code\u0026gt; - which I guess implicitly checks for EOF.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Why is checking for eof explicitly using \u0026lt;code\u0026gt;while (!cin.eof())\u0026lt;/code\u0026gt; wrong?  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;How is it different from using \u0026lt;code\u0026gt;scanf(\u0026quot;...\u0026quot;,...)!=EOF\u0026lt;/code\u0026gt; in C (which I often use with no problems)?\u0026lt;/p\u0026gt;\n    ","slug":"why-is-iostream::eof-inside-a-loop-condition-(i.e.-while-(!stream.eof()))-considered-wrong-1657384355427","postType":"QUESTION","createdAt":"2022-07-09T16:32:35.000Z","updatedAt":"2022-07-09T16:32:35.000Z","tags":[{"id":122,"name":"iostream","slug":"iostream","createdAt":"2022-07-09T16:32:35.000Z","updatedAt":"2022-07-09T16:32:35.000Z","Questions_Tags":{"questionId":35,"tagId":122}}]}]}},"__N_SSG":true},"page":"/questions/tag/[slug]","query":{"slug":"iostream"},"buildId":"4Y8KGE-c2lolBeBmcum_I","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>