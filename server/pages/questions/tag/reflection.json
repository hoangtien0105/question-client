{"pageProps":{"data":{"count":1,"rows":[{"id":213,"title":"How do I use reflection to call a generic method?","slug":"how-do-i-use-reflection-to-call-a-generic-method-1657387256751","postType":"QUESTION","createdAt":"2022-07-09T17:20:56.000Z","updatedAt":"2022-07-09T17:20:56.000Z","tags":[{"id":1484,"name":"reflection","slug":"reflection","createdAt":"2022-07-09T17:20:56.000Z","updatedAt":"2022-07-09T17:20:56.000Z","Questions_Tags":{"questionId":213,"tagId":1484}}]}]},"slug":"reflection","page":1,"answers":{"213":["\n&lt;p&gt;You need to use reflection to get the method to start with, then &quot;construct&quot; it by supplying type arguments with &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.reflection.methodinfo.makegenericmethod.aspx&quot; rel=&quot;noreferrer&quot;&gt;MakeGenericMethod&lt;/a&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;MethodInfo method = &lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt;(Sample).GetMethod(&lt;span class=&quot;hljs-keyword&quot;&gt;nameof&lt;/span&gt;(Sample.GenericMethod));\nMethodInfo generic = method.MakeGenericMethod(myType);\ngeneric.Invoke(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;For a static method, pass &lt;code&gt;null&lt;/code&gt; as the first argument to &lt;code&gt;Invoke&lt;/code&gt;. That&apos;s nothing to do with generic methods - it&apos;s just normal reflection.&lt;/p&gt;\n\n&lt;p&gt;As noted, a lot of this is simpler as of C# 4 using &lt;code&gt;dynamic&lt;/code&gt; - if you can use type inference, of course. It doesn&apos;t help in cases where type inference isn&apos;t available, such as the exact example in the question.&lt;/p&gt;\n    ","\n&lt;p&gt;Just an addition to the original answer. While this will work:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;MethodInfo method = &lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt;(Sample).GetMethod(&lt;span class=&quot;hljs-string&quot;&gt;&quot;GenericMethod&quot;&lt;/span&gt;);\nMethodInfo generic = method.MakeGenericMethod(myType);\ngeneric.Invoke(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It is also a little dangerous in that you lose compile-time check for &lt;code&gt;GenericMethod&lt;/code&gt;. If you later do a refactoring and rename &lt;code&gt;GenericMethod&lt;/code&gt;, this code won&apos;t notice and will fail at run time. Also, if there is any post-processing of the assembly (for example obfuscating or removing unused methods/classes) this code might break too.&lt;/p&gt;\n\n&lt;p&gt;So, if you know the method you are linking to at compile time, and this isn&apos;t called millions of times so overhead doesn&apos;t matter, I would change this code to be:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;Action&amp;lt;&amp;gt; GenMethod = GenericMethod&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;&amp;gt;;  &lt;span class=&quot;hljs-comment&quot;&gt;//change int by any base type &lt;/span&gt;\n                                          &lt;span class=&quot;hljs-comment&quot;&gt;//accepted by GenericMethod&lt;/span&gt;\nMethodInfo method = &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.GetType().GetMethod(GenMethod.Method.Name);\nMethodInfo generic = method.MakeGenericMethod(myType);\ngeneric.Invoke(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;While not very pretty, you have a compile time reference to &lt;code&gt;GenericMethod&lt;/code&gt; here, and if you refactor, delete or do anything with &lt;code&gt;GenericMethod&lt;/code&gt;, this code will keep working, or at least break at compile time (if for example you remove &lt;code&gt;GenericMethod&lt;/code&gt;). &lt;/p&gt;\n\n&lt;p&gt;Other way to do the same would be to create a new wrapper class, and create it through &lt;code&gt;Activator&lt;/code&gt;. I don&apos;t know if there is a better way.&lt;/p&gt;\n    ","\n&lt;p&gt;Calling a generic method with a type parameter known only at runtime can be greatly simplified by using a &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dd264741.aspx&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;dynamic&lt;/code&gt;&lt;/a&gt; type instead of the reflection API.&lt;/p&gt;\n&lt;p&gt;To use this technique the type must be known from the actual object (not just an instance of the &lt;code&gt;Type&lt;/code&gt; class). Otherwise, you have to create an object of that type or use the standard reflection API &lt;a href=&quot;https://stackoverflow.com/a/232621/350384&quot;&gt;solution&lt;/a&gt;. You can create an object by using the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/wccyzw83%28v=vs.110%29.aspx&quot; rel=&quot;noreferrer&quot;&gt;Activator.CreateInstance&lt;/a&gt; method.&lt;/p&gt;\n&lt;p&gt;If you want to call a generic method, that in &quot;normal&quot; usage would have had its type inferred, then it simply comes to casting the object of unknown type to &lt;code&gt;dynamic&lt;/code&gt;. Here&apos;s an example:&lt;/p&gt;\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Alpha&lt;/span&gt; { }\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Beta&lt;/span&gt; { }\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Service&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Process&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span class=&quot;hljs-params&quot;&gt;T item&lt;/span&gt;)&lt;/span&gt;\n    {\n        Console.WriteLine(&lt;span class=&quot;hljs-string&quot;&gt;&quot;item.GetType(): &quot;&lt;/span&gt; + item.GetType()\n                          + &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\ttypeof(T): &quot;&lt;/span&gt; + &lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt;(T));\n    }\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Program&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Main&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;[] args&lt;/span&gt;)&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Alpha();\n        &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; b = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Beta();\n\n        &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; service = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Service();\n        service.Process(a); &lt;span class=&quot;hljs-comment&quot;&gt;// Same as &quot;service.Process&amp;lt;Alpha&amp;gt;(a)&quot;&lt;/span&gt;\n        service.Process(b); &lt;span class=&quot;hljs-comment&quot;&gt;// Same as &quot;service.Process&amp;lt;Beta&amp;gt;(b)&quot;&lt;/span&gt;\n\n        &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; objects = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt;[] { a, b };\n        &lt;span class=&quot;hljs-keyword&quot;&gt;foreach&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; o &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; objects)\n        {\n            service.Process(o); &lt;span class=&quot;hljs-comment&quot;&gt;// Same as &quot;service.Process&amp;lt;object&amp;gt;(o)&quot;&lt;/span&gt;\n        }\n        &lt;span class=&quot;hljs-keyword&quot;&gt;foreach&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; o &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; objects)\n        {\n            &lt;span class=&quot;hljs-built_in&quot;&gt;dynamic&lt;/span&gt; dynObj = o;\n            service.Process(dynObj); &lt;span class=&quot;hljs-comment&quot;&gt;// Or write &quot;service.Process((dynamic)o)&quot;&lt;/span&gt;\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;And here&apos;s the output of this program:&lt;/p&gt;\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;item.GetType(): &lt;span class=&quot;hljs-function&quot;&gt;Alpha    &lt;span class=&quot;hljs-title&quot;&gt;typeof&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;T&lt;/span&gt;): Alpha\nitem.&lt;span class=&quot;hljs-title&quot;&gt;GetType&lt;/span&gt;(): Beta     &lt;span class=&quot;hljs-title&quot;&gt;typeof&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;T&lt;/span&gt;): Beta\nitem.&lt;span class=&quot;hljs-title&quot;&gt;GetType&lt;/span&gt;(): Alpha    &lt;span class=&quot;hljs-title&quot;&gt;typeof&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;T&lt;/span&gt;): System.Object\nitem.&lt;span class=&quot;hljs-title&quot;&gt;GetType&lt;/span&gt;(): Beta     &lt;span class=&quot;hljs-title&quot;&gt;typeof&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;T&lt;/span&gt;): System.Object\nitem.&lt;span class=&quot;hljs-title&quot;&gt;GetType&lt;/span&gt;(): Alpha    &lt;span class=&quot;hljs-title&quot;&gt;typeof&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;T&lt;/span&gt;): Alpha\nitem.&lt;span class=&quot;hljs-title&quot;&gt;GetType&lt;/span&gt;(): Beta     &lt;span class=&quot;hljs-title&quot;&gt;typeof&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;T&lt;/span&gt;): Beta\n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;Process&lt;/code&gt; is a generic instance method that writes the real type of the passed argument (by using the &lt;code&gt;GetType()&lt;/code&gt; method) and the type of the generic parameter (by using &lt;code&gt;typeof&lt;/code&gt; operator).&lt;/p&gt;\n&lt;p&gt;By casting the object argument to &lt;code&gt;dynamic&lt;/code&gt; type we deferred providing the type parameter until runtime. When the &lt;code&gt;Process&lt;/code&gt; method is called with the &lt;code&gt;dynamic&lt;/code&gt; argument then the compiler doesn&apos;t care about the type of this argument. The compiler generates code that at runtime checks the real types of passed arguments (by using reflection) and choose the best method to call. Here there is only this one generic method, so it&apos;s invoked with a proper type parameter.&lt;/p&gt;\n&lt;p&gt;In this example, the output is the same as if you wrote:&lt;/p&gt;\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;foreach&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; o &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; objects)\n{\n    MethodInfo method = &lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt;(Service).GetMethod(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Process&quot;&lt;/span&gt;);\n    MethodInfo generic = method.MakeGenericMethod(o.GetType());\n    generic.Invoke(service, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt;[] { o });\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The version with a dynamic type is definitely shorter and easier to write. You also shouldn&apos;t worry about performance of calling this function multiple times. The next call with arguments of the same type should be faster thanks to the &lt;a href=&quot;https://web.archive.org/web/20140422080408/http://blogs.msdn.com/b/samng/archive/2008/10/29/dynamic-in-c.aspx&quot; rel=&quot;noreferrer&quot;&gt;caching&lt;/a&gt; mechanism in DLR. Of course, you can write code that cache invoked delegates, but by using the &lt;code&gt;dynamic&lt;/code&gt; type you get this behaviour for free.&lt;/p&gt;\n&lt;p&gt;If the generic method you want to call don&apos;t have an argument of a parametrized type (so its type parameter can&apos;t be inferred) then you can wrap the invocation of the generic method in a helper method like in the following example:&lt;/p&gt;\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Program&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Main&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;[] args&lt;/span&gt;)&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt; obj = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Alpha();\n\n        Helper((&lt;span class=&quot;hljs-built_in&quot;&gt;dynamic&lt;/span&gt;)obj);\n    }\n\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Helper&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span class=&quot;hljs-params&quot;&gt;T obj&lt;/span&gt;)&lt;/span&gt;\n    {\n        GenericMethod&amp;lt;T&amp;gt;();\n    }\n\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;GenericMethod&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt;()&lt;/span&gt;\n    {\n        Console.WriteLine(&lt;span class=&quot;hljs-string&quot;&gt;&quot;GenericMethod&amp;lt;&quot;&lt;/span&gt; + &lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt;(T) + &lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;gt;&quot;&lt;/span&gt;);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1&gt;Increased type safety&lt;/h1&gt;\n&lt;p&gt;What is really great about using &lt;code&gt;dynamic&lt;/code&gt; object as a replacement for using reflection API is that you only lose compile time checking of this particular type that you don&apos;t know until runtime. Other arguments and the name of the method are staticly analysed by the compiler as usual. If you remove or add more arguments, change their types or rename method name then you&apos;ll get a compile-time error. This won&apos;t happen if you provide the method name as a string in &lt;code&gt;Type.GetMethod&lt;/code&gt; and arguments as the objects array in &lt;code&gt;MethodInfo.Invoke&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;Below is a simple example that illustrates how some errors can be caught at compile time (commented code) and other at runtime. It also shows how the DLR tries to resolve which method to call.&lt;/p&gt;\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;IItem&lt;/span&gt; { }\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;FooItem&lt;/span&gt; : &lt;span class=&quot;hljs-title&quot;&gt;IItem&lt;/span&gt; { }\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;BarItem&lt;/span&gt; : &lt;span class=&quot;hljs-title&quot;&gt;IItem&lt;/span&gt; { }\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Alpha&lt;/span&gt; { }\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Program&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Main&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;[] args&lt;/span&gt;)&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; objects = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt;[] { &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; FooItem(), &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; BarItem(), &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Alpha() };\n        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; objects.Length; i++)\n        {\n            ProcessItem((&lt;span class=&quot;hljs-built_in&quot;&gt;dynamic&lt;/span&gt;)objects[i], &lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt; + i, i);\n\n            &lt;span class=&quot;hljs-comment&quot;&gt;//ProcesItm((dynamic)objects[i], &quot;test&quot; + i, i);&lt;/span&gt;\n            &lt;span class=&quot;hljs-comment&quot;&gt;//compiler error: The name &apos;ProcesItm&apos; does not&lt;/span&gt;\n            &lt;span class=&quot;hljs-comment&quot;&gt;//exist in the current context&lt;/span&gt;\n\n            &lt;span class=&quot;hljs-comment&quot;&gt;//ProcessItem((dynamic)objects[i], &quot;test&quot; + i);&lt;/span&gt;\n            &lt;span class=&quot;hljs-comment&quot;&gt;//error: No overload for method &apos;ProcessItem&apos; takes 2 arguments&lt;/span&gt;\n        }\n    }\n\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ProcessItem&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span class=&quot;hljs-params&quot;&gt;T item, &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; text, &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; number&lt;/span&gt;)\n        &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; T : IItem&lt;/span&gt;\n    {\n        Console.WriteLine(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Generic ProcessItem&amp;lt;{0}&amp;gt;, text {1}, number:{2}&quot;&lt;/span&gt;,\n                          &lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt;(T), text, number);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;OK&quot;&lt;/span&gt;;\n    }\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ProcessItem&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;BarItem item, &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; text, &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; number&lt;/span&gt;)&lt;/span&gt;\n    {\n        Console.WriteLine(&lt;span class=&quot;hljs-string&quot;&gt;&quot;ProcessItem with Bar, &quot;&lt;/span&gt; + text + &lt;span class=&quot;hljs-string&quot;&gt;&quot;, &quot;&lt;/span&gt; + number);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Here we again execute some method by casting the argument to the &lt;code&gt;dynamic&lt;/code&gt; type. Only verification of first argument&apos;s type is postponed to runtime. You will get a compiler error if the name of the method you&apos;re calling doesn&apos;t exist or if other arguments are invalid (wrong number of arguments or wrong types).&lt;/p&gt;\n&lt;p&gt;When you pass the &lt;code&gt;dynamic&lt;/code&gt; argument to a method then this call is &lt;a href=&quot;https://ericlippert.com/2012/02/06/what-is-late-binding/&quot; rel=&quot;noreferrer&quot;&gt;lately bound&lt;/a&gt;. Method overload resolution happens at runtime and tries to choose the best overload. So if you invoke the &lt;code&gt;ProcessItem&lt;/code&gt; method with an object of &lt;code&gt;BarItem&lt;/code&gt; type then you&apos;ll actually call the non-generic method, because it is a better match for this type. However, you&apos;ll get a runtime error when you pass an argument of the &lt;code&gt;Alpha&lt;/code&gt; type because there&apos;s no method that can handle this object (a generic method has the constraint &lt;code&gt;where T : IItem&lt;/code&gt; and &lt;code&gt;Alpha&lt;/code&gt; class doesn&apos;t implement this interface). But that&apos;s the whole point. The compiler doesn&apos;t have information that this call is valid. You as a programmer know this, and you should make sure that this code runs without errors.&lt;/p&gt;\n&lt;h2&gt;Return type gotcha&lt;/h2&gt;\n&lt;p&gt;When you&apos;re calling a non-void method with a parameter of dynamic type, its return type will probably &lt;a href=&quot;https://ericlippert.com/2012/10/22/a-method-group-of-one/&quot; rel=&quot;noreferrer&quot;&gt;be &lt;code&gt;dynamic&lt;/code&gt; too&lt;/a&gt;. So if you&apos;d change previous example to this code:&lt;/p&gt;\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; result = ProcessItem((&lt;span class=&quot;hljs-built_in&quot;&gt;dynamic&lt;/span&gt;)testObjects[i], &lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt; + i, i);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;then the type of the result object would be &lt;code&gt;dynamic&lt;/code&gt;. This is because the compiler don&apos;t always know which method will be called. If you know the return type of the function call then you should &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dd264736.aspx&quot; rel=&quot;noreferrer&quot;&gt;implicitly convert&lt;/a&gt; it to the required type so the rest of the code is statically typed:&lt;/p&gt;\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; result = ProcessItem((&lt;span class=&quot;hljs-built_in&quot;&gt;dynamic&lt;/span&gt;)testObjects[i], &lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt; + i, i);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;You&apos;ll get a runtime error if the type doesn&apos;t match.&lt;/p&gt;\n&lt;p&gt;Actually, if you try to get the result value in the previous example then you&apos;ll get a runtime error in the second loop iteration. This is because you tried to save the return value of a void function.&lt;/p&gt;\n    ","\n&lt;p&gt;Adding on to &lt;a href=&quot;https://stackoverflow.com/questions/232535/how-do-i-use-reflection-to-call-a-generic-method/5134251#5134251&quot;&gt;Adrian Gallero&apos;s answer&lt;/a&gt;:&lt;/p&gt;\n&lt;p&gt;Calling a generic method from type info involves three steps.&lt;/p&gt;\n&lt;p&gt;##TLDR: Calling a known generic method with a type object can be accomplished by:##&lt;/p&gt;\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;((Action)GenericMethod&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt;&amp;gt;)\n    .Method\n    .GetGenericMethodDefinition()\n    .MakeGenericMethod(&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;))\n    .Invoke(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;where &lt;code&gt;GenericMethod&amp;lt;object&amp;gt;&lt;/code&gt; is the method name to call and any type that satisfies the generic constraints.&lt;/p&gt;\n&lt;p&gt;(Action) matches the signature of the method to be called i.e. (&lt;code&gt;Func&amp;lt;string,string,int&amp;gt;&lt;/code&gt; or &lt;code&gt;Action&amp;lt;bool&amp;gt;&lt;/code&gt;)&lt;/p&gt;\n&lt;p&gt;##Step 1 is getting the MethodInfo for the generic method definition##&lt;/p&gt;\n&lt;p&gt;###Method 1: Use GetMethod() or GetMethods() with appropriate types or binding flags.###&lt;/p&gt;\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;MethodInfo method = &lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt;(Sample).GetMethod(&lt;span class=&quot;hljs-string&quot;&gt;&quot;GenericMethod&quot;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;###Method 2: Create a delegate, get the MethodInfo object and then call GetGenericMethodDefinition&lt;/p&gt;\n&lt;p&gt;From inside the class that contains the methods:&lt;/p&gt;\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;MethodInfo method = ((Action)GenericMethod&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt;&amp;gt;)\n    .Method\n    .GetGenericMethodDefinition();\n\nMethodInfo method = ((Action)StaticMethod&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt;&amp;gt;)\n    .Method\n    .GetGenericMethodDefinition();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;From outside of the class that contains the methods:&lt;/p&gt;\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;MethodInfo method = ((Action)(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Sample())\n    .GenericMethod&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt;&amp;gt;)\n    .Method\n    .GetGenericMethodDefinition();\n\nMethodInfo method = ((Action)Sample.StaticMethod&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt;&amp;gt;)\n    .Method\n    .GetGenericMethodDefinition();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In C#, the name of a method, i.e. &quot;ToString&quot; or &quot;GenericMethod&quot; actually refers to a group of methods that may contain one or more methods.  Until you provide the types of the method parameters, it is not known which\nmethod you are referring to.&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;((Action)GenericMethod&amp;lt;object&amp;gt;)&lt;/code&gt; refers to the delegate for a specific method.  &lt;code&gt;((Func&amp;lt;string, int&amp;gt;)GenericMethod&amp;lt;object&amp;gt;)&lt;/code&gt;\nrefers to a different overload of GenericMethod&lt;/p&gt;\n&lt;p&gt;###Method 3: Create a lambda expression containing a method call expression, get the MethodInfo object and then GetGenericMethodDefinition&lt;/p&gt;\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;MethodInfo method = ((MethodCallExpression)((Expression&amp;lt;Action&amp;lt;Sample&amp;gt;&amp;gt;)(\n    (Sample v) =&amp;gt; v.GenericMethod&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt;&amp;gt;()\n    )).Body).Method.GetGenericMethodDefinition();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This breaks down to&lt;/p&gt;\n&lt;p&gt;Create a lambda expression where the body is a call to your desired method.&lt;/p&gt;\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;Expression&amp;lt;Action&amp;lt;Sample&amp;gt;&amp;gt; expr = (Sample v) =&amp;gt; v.GenericMethod&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt;&amp;gt;();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Extract the body and cast to MethodCallExpression&lt;/p&gt;\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;MethodCallExpression methodCallExpr = (MethodCallExpression)expr.Body;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Get the generic method definition from the method&lt;/p&gt;\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;MethodInfo methodA = methodCallExpr.Method.GetGenericMethodDefinition();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;##Step 2 is calling MakeGenericMethod to create a generic method with the appropriate type(s).##&lt;/p&gt;\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;MethodInfo generic = method.MakeGenericMethod(myType);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;##Step 3 is invoking the method with the appropriate arguments.##&lt;/p&gt;\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;generic.Invoke(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;With C# 4.0, reflection isn&apos;t necessary as the DLR can call it using runtime types. Since using the DLR library is kind of a pain dynamically (instead of the C# compiler generating code for you), the open source framework &lt;a href=&quot;https://github.com/ekonbenefits/dynamitey&quot; rel=&quot;noreferrer&quot;&gt;Dynamitey&lt;/a&gt; (.net standard 1.5) gives you easy cached run-time access to the same calls the compiler would generate for you.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; name = InvokeMemberName.Create;\nDynamic.InvokeMemberAction(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;, name(&lt;span class=&quot;hljs-string&quot;&gt;&quot;GenericMethod&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt;[]{myType}));\n\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; staticContext = InvokeContext.CreateStatic;\nDynamic.InvokeMemberAction(staticContext(&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt;(Sample)), name(&lt;span class=&quot;hljs-string&quot;&gt;&quot;StaticMethod&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt;[]{myType}));\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Nobody provided the &quot;&lt;em&gt;classic Reflection&lt;/em&gt;&quot; solution, so here is a complete code example:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; System;\n&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; System.Collections;\n&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; System.Collections.Generic;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;DictionaryRuntime&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;DynamicDictionaryFactory&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; Factory to create dynamically a generic Dictionary.&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;\n        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; IDictionary &lt;span class=&quot;hljs-title&quot;&gt;CreateDynamicGenericInstance&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;Type keyType, Type valueType&lt;/span&gt;)&lt;/span&gt;\n        {\n            &lt;span class=&quot;hljs-comment&quot;&gt;//Creating the Dictionary.&lt;/span&gt;\n            Type typeDict = &lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt;(Dictionary&amp;lt;,&amp;gt;);\n\n            &lt;span class=&quot;hljs-comment&quot;&gt;//Creating KeyValue Type for Dictionary.&lt;/span&gt;\n            Type[] typeArgs = { keyType, valueType };\n\n            &lt;span class=&quot;hljs-comment&quot;&gt;//Passing the Type and create Dictionary Type.&lt;/span&gt;\n            Type genericType = typeDict.MakeGenericType(typeArgs);\n\n            &lt;span class=&quot;hljs-comment&quot;&gt;//Creating Instance for Dictionary&amp;lt;K,T&amp;gt;.&lt;/span&gt;\n            IDictionary d = Activator.CreateInstance(genericType) &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; IDictionary;\n\n            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; d;\n\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The above &lt;code&gt;DynamicDictionaryFactory&lt;/code&gt; class has a method &lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;CreateDynamicGenericInstance(Type keyType, Type valueType)&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;and it creates and returns an IDictionary instance, the types of whose keys and values are exactly the specified on the call &lt;code&gt;keyType&lt;/code&gt; and &lt;code&gt;valueType&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Here is a complete example&lt;/strong&gt; how to call this method to instantiate and use a &lt;code&gt;Dictionary&amp;lt;String, int&amp;gt;&lt;/code&gt; :&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; System;\n&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; System.Collections.Generic;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;DynamicDictionary&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Test&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Main&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;[] args&lt;/span&gt;)&lt;/span&gt;\n        {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; factory = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; DictionaryRuntime.DynamicDictionaryFactory();\n            &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; dict = factory.CreateDynamicGenericInstance(&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt;(String), &lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;));\n\n            &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; typedDict = dict &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; Dictionary&amp;lt;String, &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;&amp;gt;;\n\n            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (typedDict != &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;)\n            {\n                Console.WriteLine(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Dictionary&amp;lt;String, int&amp;gt;&quot;&lt;/span&gt;);\n\n                typedDict.Add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;One&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);\n                typedDict.Add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Two&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;);\n                typedDict.Add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Three&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;);\n\n                &lt;span class=&quot;hljs-keyword&quot;&gt;foreach&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; kvp &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; typedDict)\n                {\n                    Console.WriteLine(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\\&quot;&quot;&lt;/span&gt; + kvp.Key + &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\&quot;: &quot;&lt;/span&gt; + kvp.Value);\n                }\n            }\n            &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;\n                Console.WriteLine(&lt;span class=&quot;hljs-string&quot;&gt;&quot;null&quot;&lt;/span&gt;);\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;When the above console application is executed, we get the correct, expected result:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;Dictionary&amp;lt;String, &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;&amp;gt;\n&lt;span class=&quot;hljs-string&quot;&gt;&quot;One&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;span class=&quot;hljs-string&quot;&gt;&quot;Two&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;\n&lt;span class=&quot;hljs-string&quot;&gt;&quot;Three&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;This is my 2 cents based on &lt;a href=&quot;https://stackoverflow.com/questions/232535/how-do-i-use-reflection-to-call-a-generic-method/27870198#27870198&quot;&gt;Grax&apos;s answer&lt;/a&gt;, but with two parameters required for a generic method.&lt;/p&gt;\n\n&lt;p&gt;Assume your method is defined as follows in an Helpers class:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Helpers&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; U &lt;span class=&quot;hljs-title&quot;&gt;ConvertCsvDataToCollection&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;U&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; csvData&lt;/span&gt;)\n    &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; U : ObservableCollection&amp;lt;T&amp;gt;&lt;/span&gt;\n    {\n      &lt;span class=&quot;hljs-comment&quot;&gt;//transform code here&lt;/span&gt;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In my case, U type is always an observable collection storing object of type T.&lt;/p&gt;\n\n&lt;p&gt;As I have my types predefined, I first create the &quot;dummy&quot; objects that represent the observable collection (U) and the object stored in it (T) and that will be used below to get their type when calling the Make&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt; myCollection = Activator.CreateInstance(collectionType);\n&lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt; myoObject = Activator.CreateInstance(objectType);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Then call the GetMethod to find your Generic function:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;MethodInfo method = &lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt;(Helpers).\nGetMethod(&lt;span class=&quot;hljs-string&quot;&gt;&quot;ConvertCsvDataToCollection&quot;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So far, the above call is pretty much identical as to what was explained above but with a small difference when you need have to pass multiple parameters to it.&lt;/p&gt;\n\n&lt;p&gt;You need to pass an Type[] array to the MakeGenericMethod function that contains the &quot;dummy&quot; objects&apos; types that were create above:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;MethodInfo generic = method.MakeGenericMethod(\n&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Type[] {\n   myCollection.GetType(),\n   myObject.GetType()\n});\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Once that&apos;s done, you need to call the Invoke method as mentioned above.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;generic.Invoke(&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt;[] { csvData });\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And you&apos;re done. Works a charm!&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;UPDATE:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;As @Bevan highlighted, I do not need to create an array when calling the MakeGenericMethod function as it takes in params and I do not need to create an object in order to get the types as I can just pass the types directly to this function. In my case, since I have the types predefined in another class, I simply changed my code to:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt; myCollection = &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;;\n\nMethodInfo method = &lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt;(Helpers).\nGetMethod(&lt;span class=&quot;hljs-string&quot;&gt;&quot;ConvertCsvDataToCollection&quot;&lt;/span&gt;);\n\nMethodInfo generic = method.MakeGenericMethod(\n   myClassInfo.CollectionType,\n   myClassInfo.ObjectType\n);\n\nmyCollection = generic.Invoke(&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt;[] { csvData });\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;myClassInfo contains 2 properties of type &lt;code&gt;Type&lt;/code&gt; which I set at run time based on an enum value passed to the constructor and will provide me with the relevant types which I then use in the MakeGenericMethod.&lt;/p&gt;\n\n&lt;p&gt;Thanks again for highlighting this @Bevan.&lt;/p&gt;\n    ","\n&lt;p&gt;Inspired by &lt;a href=&quot;https://stackoverflow.com/a/3958029/1016343&quot;&gt;Enigmativity&apos;s answer&lt;/a&gt; - let&apos;s assume you have two (or more) classes, like&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Bar&lt;/span&gt; { }\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Square&lt;/span&gt; { }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and you want to call the method &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; with &lt;code&gt;Bar&lt;/code&gt; and &lt;code&gt;Square&lt;/code&gt;, which is declared as&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;myClass&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Foo&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span class=&quot;hljs-params&quot;&gt;T item&lt;/span&gt;)&lt;/span&gt;\n    {\n        Console.WriteLine(&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt;(T).Name);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Then you can implement an &lt;strong&gt;Extension method&lt;/strong&gt; like:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Extension&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;InvokeFoo&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt; T t&lt;/span&gt;)&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; fooMethod = &lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt;(myClass).GetMethod(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Foo&quot;&lt;/span&gt;);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; tType = &lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt;(T);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; fooTMethod = fooMethod.MakeGenericMethod(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt;[] { tType });\n        fooTMethod.Invoke(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; myClass(), &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt;[] { t });\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;With this, you can simply invoke &lt;code&gt;Foo&lt;/code&gt; like:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; objSquare = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Square();\nobjSquare.InvokeFoo();\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; objBar = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Bar();\nobjBar.InvokeFoo();\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;which works for every class. In this case, it will output:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Square &lt;br&gt;\n  Bar&lt;/p&gt;\n&lt;/blockquote&gt;\n    "]},"randomTags":[{"name":"singleton","slug":"singleton"},{"name":"python-datamodel","slug":"python-datamodel"},{"name":"automatic-semicolon-insertion","slug":"automatic-semicolon-insertion"},{"name":"default-parameters","slug":"default-parameters"},{"name":"gethashcode","slug":"gethashcode"},{"name":"universal-image-loader","slug":"universal-image-loader"},{"name":"dimension","slug":"dimension"},{"name":"expected-condition","slug":"expected-condition"},{"name":"git-revert","slug":"git-revert"},{"name":"mariadb","slug":"mariadb"},{"name":"default-constructor","slug":"default-constructor"},{"name":"split","slug":"split"},{"name":"equals","slug":"equals"},{"name":"copy-elision","slug":"copy-elision"},{"name":"java.util.scanner","slug":"java.util.scanner"},{"name":"c89","slug":"c89"},{"name":"utf-8","slug":"utf-8"},{"name":"sizeof","slug":"sizeof"},{"name":"opengl","slug":"opengl"},{"name":"local-variables","slug":"local-variables"}]},"__N_SSG":true}