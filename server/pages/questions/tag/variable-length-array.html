<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2eccd4d47c856f2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2eccd4d47c856f2b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/81-301f760ac8107464.js" defer=""></script><script src="/_next/static/chunks/pages/questions/tag/%5Bslug%5D-6802ea06aeddcbec.js" defer=""></script><script src="/_next/static/B9ZMQqRLGvIP-RcWN9dT2/_buildManifest.js" defer=""></script><script src="/_next/static/B9ZMQqRLGvIP-RcWN9dT2/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5"></style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="https://flowbite.com/docs/images/logo.svg" class="mr-3 h-6 sm:h-9" alt="Flowbite Logo"/><span class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Hunter</span></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/tag/variable-length-array#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="flex items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/why-aren&#x27;t-variable-length-arrays-part-of-the-c++-standard-1657384712975">Why aren&#x27;t variable-length arrays part of the C++ standard?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/variable-length-array">variable-length-array</a></div></div><div class="mt-4 mb-6" style="height:100px;overflow:auto"><h4 class="font-semibold">Solution 1:</h4><div class="text-sm bg-green-100 text-neutral-600">
<p>(Background: I have some experience implementing C and C++ compilers.)</p>

<p>Variable-length arrays in C99 were basically a misstep. In order to support VLAs, C99 had to make the following concessions to common sense:</p>

<ul>
<li><p><code>sizeof x</code> is no longer always a compile-time constant; the compiler must sometimes generate code to evaluate a <code>sizeof</code>-expression at runtime.</p></li>
<li><p>Allowing two-dimensional VLAs (<code>int A[x][y]</code>) required a new syntax for declaring functions that take 2D VLAs as parameters: <code>void foo(int n, int A[][*])</code>.</p></li>
<li><p>Less importantly in the C++ world, but extremely important for C's target audience of embedded-systems programmers, declaring a VLA means chomping an <em>arbitrarily large</em> chunk of your stack. This is a <em>guaranteed</em> stack-overflow and crash. (Anytime you declare <code>int A[n]</code>, you're implicitly asserting that you have 2GB of stack to spare. After all, if you know "<code>n</code> is definitely less than 1000 here", then you would just declare <code>int A[1000]</code>. Substituting the 32-bit integer <code>n</code> for <code>1000</code> is an admission that you have no idea what the behavior of your program ought to be.)</p></li>
</ul>

<p>Okay, so let's move to talking about C++ now. In C++, we have the same strong distinction between "type system" and "value system" that C89 does but we've really started to rely on it in ways that C has not. For example:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span> { ... };
<span class="hljs-type">int</span> A[n];
S&lt;<span class="hljs-keyword">decltype</span>(A)&gt; s;  <span class="hljs-comment">// equivalently, S&lt;int[n]&gt; s;</span>
</code></pre>

<p>If <code>n</code> weren't a compile-time constant (i.e., if <code>A</code> were of variably modified type), then what on earth would be the type of <code>S</code>? Would <code>S</code>'s type <em>also</em> be determined only at runtime?</p>

<p>What about this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">bool</span> <span class="hljs-title">myfunc</span><span class="hljs-params">(T&amp; t1, T&amp; t2)</span> </span>{ ... };
<span class="hljs-type">int</span> A1[n1], A2[n2];
<span class="hljs-built_in">myfunc</span>(A1, A2);
</code></pre>

<p>The compiler must generate code for some instantiation of <code>myfunc</code>. What should that code look like? How can we statically generate that code, if we don't know the type of <code>A1</code> at compile time?</p>

<p>Worse, what if it turns out at runtime that <code>n1 != n2</code>, so that <code>!std::is_same&lt;decltype(A1), decltype(A2)&gt;()</code>? In that case, the call to <code>myfunc</code> <strong>shouldn't even compile</strong>, because template type deduction should fail! How could we possibly emulate that behavior at runtime?</p>

<p>Basically, C++ is moving in the direction of pushing more and more decisions into <em>compile-time</em>: template code generation, <code>constexpr</code> function evaluation, and so on. Meanwhile, C99 was busy pushing traditionally <em>compile-time</em> decisions (e.g. <code>sizeof</code>) into the <em>runtime</em>. With this in mind, does it really even make sense to expend any effort <em>trying</em> to integrate C99-style VLAs into C++?</p>

<p>As every other answerer has already pointed out, C++ provides lots of heap-allocation mechanisms (<code>std::unique_ptr&lt;int[]&gt; A = new int[n];</code> or <code>std::vector&lt;int&gt; A(n);</code> being the obvious ones) when you really want to convey the idea "I have no idea how much RAM I might need." And C++ provides a nifty exception-handling model for dealing with the inevitable situation that the amount of RAM you need is greater than the amount of RAM you have. But hopefully <em>this</em> answer gives you a good idea of why C99-style VLAs were <strong>not</strong> a good fit for C++  and not really even a good fit for C99. ;)</p>

<hr>

<p>For more on the topic, see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf" rel="noreferrer">N3810 "Alternatives for Array Extensions"</a>, Bjarne Stroustrup's October 2013 paper on VLAs. Bjarne's POV is very different from mine; N3810 focuses more on finding a good C++ish <em>syntax</em> for the things, and on discouraging the use of raw arrays in C++, whereas I focused more on the implications for metaprogramming and the typesystem. I don't know if he considers the metaprogramming/typesystem implications solved, solvable, or merely uninteresting.</p>

<hr>

<p>A good blog post that hits many of these same points is <a href="https://nullprogram.com/blog/2019/10/27/" rel="noreferrer">"Legitimate Use of Variable Length Arrays"</a> (Chris Wellons, 2019-10-27).</p>
    </div></div><div><div class="flex items-center justify-between text-slate-500"><div class="flex space-x-4 md:space-x-8"><div class="flex cursor-pointer items-center transition hover:text-slate-600"><svg xmlns="http://www.w3.org/2000/svg" class="mr-1.5 h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M14 10h4.764a2 2 0 011.789 2.894l-3.5 7A2 2 0 0115.263 21h-4.017c-.163 0-.326-.02-.485-.06L7 20m7-10V5a2 2 0 00-2-2h-.095c-.5 0-.905.405-.905.905 0 .714-.211 1.412-.608 2.006L7 11v9m7-10h-2M7 20H5a2 2 0 01-2-2v-6a2 2 0 012-2h2.5"></path></svg><span>4</span></div></div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"count":1,"rows":[{"answer":["\n\u0026lt;p\u0026gt;(Background: I have some experience implementing C and C++ compilers.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Variable-length arrays in C99 were basically a misstep. In order to support VLAs, C99 had to make the following concessions to common sense:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;sizeof x\u0026lt;/code\u0026gt; is no longer always a compile-time constant; the compiler must sometimes generate code to evaluate a \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt;-expression at runtime.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Allowing two-dimensional VLAs (\u0026lt;code\u0026gt;int A[x][y]\u0026lt;/code\u0026gt;) required a new syntax for declaring functions that take 2D VLAs as parameters: \u0026lt;code\u0026gt;void foo(int n, int A[][*])\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Less importantly in the C++ world, but extremely important for C\u0026apos;s target audience of embedded-systems programmers, declaring a VLA means chomping an \u0026lt;em\u0026gt;arbitrarily large\u0026lt;/em\u0026gt; chunk of your stack. This is a \u0026lt;em\u0026gt;guaranteed\u0026lt;/em\u0026gt; stack-overflow and crash. (Anytime you declare \u0026lt;code\u0026gt;int A[n]\u0026lt;/code\u0026gt;, you\u0026apos;re implicitly asserting that you have 2GB of stack to spare. After all, if you know \u0026quot;\u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt; is definitely less than 1000 here\u0026quot;, then you would just declare \u0026lt;code\u0026gt;int A[1000]\u0026lt;/code\u0026gt;. Substituting the 32-bit integer \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt; for \u0026lt;code\u0026gt;1000\u0026lt;/code\u0026gt; is an admission that you have no idea what the behavior of your program ought to be.)\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Okay, so let\u0026apos;s move to talking about C++ now. In C++, we have the same strong distinction between \u0026quot;type system\u0026quot; and \u0026quot;value system\u0026quot; that C89 does but we\u0026apos;ve really started to rely on it in ways that C has not. For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;S\u0026lt;/span\u0026gt; { ... };\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; A[n];\nS\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(A)\u0026amp;gt; s;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// equivalently, S\u0026amp;lt;int[n]\u0026amp;gt; s;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt; weren\u0026apos;t a compile-time constant (i.e., if \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; were of variably modified type), then what on earth would be the type of \u0026lt;code\u0026gt;S\u0026lt;/code\u0026gt;? Would \u0026lt;code\u0026gt;S\u0026lt;/code\u0026gt;\u0026apos;s type \u0026lt;em\u0026gt;also\u0026lt;/em\u0026gt; be determined only at runtime?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;What about this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;myfunc\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T\u0026amp;amp; t1, T\u0026amp;amp; t2)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ ... };\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; A1[n1], A2[n2];\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;myfunc\u0026lt;/span\u0026gt;(A1, A2);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The compiler must generate code for some instantiation of \u0026lt;code\u0026gt;myfunc\u0026lt;/code\u0026gt;. What should that code look like? How can we statically generate that code, if we don\u0026apos;t know the type of \u0026lt;code\u0026gt;A1\u0026lt;/code\u0026gt; at compile time?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Worse, what if it turns out at runtime that \u0026lt;code\u0026gt;n1 != n2\u0026lt;/code\u0026gt;, so that \u0026lt;code\u0026gt;!std::is_same\u0026amp;lt;decltype(A1), decltype(A2)\u0026amp;gt;()\u0026lt;/code\u0026gt;? In that case, the call to \u0026lt;code\u0026gt;myfunc\u0026lt;/code\u0026gt; \u0026lt;strong\u0026gt;shouldn\u0026apos;t even compile\u0026lt;/strong\u0026gt;, because template type deduction should fail! How could we possibly emulate that behavior at runtime?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Basically, C++ is moving in the direction of pushing more and more decisions into \u0026lt;em\u0026gt;compile-time\u0026lt;/em\u0026gt;: template code generation, \u0026lt;code\u0026gt;constexpr\u0026lt;/code\u0026gt; function evaluation, and so on. Meanwhile, C99 was busy pushing traditionally \u0026lt;em\u0026gt;compile-time\u0026lt;/em\u0026gt; decisions (e.g. \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt;) into the \u0026lt;em\u0026gt;runtime\u0026lt;/em\u0026gt;. With this in mind, does it really even make sense to expend any effort \u0026lt;em\u0026gt;trying\u0026lt;/em\u0026gt; to integrate C99-style VLAs into C++?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As every other answerer has already pointed out, C++ provides lots of heap-allocation mechanisms (\u0026lt;code\u0026gt;std::unique_ptr\u0026amp;lt;int[]\u0026amp;gt; A = new int[n];\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;std::vector\u0026amp;lt;int\u0026amp;gt; A(n);\u0026lt;/code\u0026gt; being the obvious ones) when you really want to convey the idea \u0026quot;I have no idea how much RAM I might need.\u0026quot; And C++ provides a nifty exception-handling model for dealing with the inevitable situation that the amount of RAM you need is greater than the amount of RAM you have. But hopefully \u0026lt;em\u0026gt;this\u0026lt;/em\u0026gt; answer gives you a good idea of why C99-style VLAs were \u0026lt;strong\u0026gt;not\u0026lt;/strong\u0026gt; a good fit for C++  and not really even a good fit for C99. ;)\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;For more on the topic, see \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;N3810 \u0026quot;Alternatives for Array Extensions\u0026quot;\u0026lt;/a\u0026gt;, Bjarne Stroustrup\u0026apos;s October 2013 paper on VLAs. Bjarne\u0026apos;s POV is very different from mine; N3810 focuses more on finding a good C++ish \u0026lt;em\u0026gt;syntax\u0026lt;/em\u0026gt; for the things, and on discouraging the use of raw arrays in C++, whereas I focused more on the implications for metaprogramming and the typesystem. I don\u0026apos;t know if he considers the metaprogramming/typesystem implications solved, solvable, or merely uninteresting.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;A good blog post that hits many of these same points is \u0026lt;a href=\u0026quot;https://nullprogram.com/blog/2019/10/27/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026quot;Legitimate Use of Variable Length Arrays\u0026quot;\u0026lt;/a\u0026gt; (Chris Wellons, 2019-10-27).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There recently was a discussion about this kicked off in usenet: \u0026lt;a href=\u0026quot;http://groups.google.com/group/comp.std.c++/browse_thread/thread/2bfe25800d4961e8/9545494bbb336dfa\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Why no VLAs in C++0x\u0026lt;/a\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I agree with those people that seem to agree that having to create a potential large array on the stack, which usually has only little space available, isn\u0026apos;t good. The argument is, if you know the size beforehand, you can use a static array. And if you don\u0026apos;t know the size beforehand, you will write unsafe code. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;C99 VLAs could provide a small benefit of being able to create small arrays without wasting space or calling constructors for unused elements, but they will introduce rather large changes to the type system (you need to be able to specify types depending on runtime values - this does not yet exist in current C++, except for \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; operator type-specifiers, but they are treated specially, so that the runtime-ness doesn\u0026apos;t escape the scope of the \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; operator).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can use \u0026lt;code\u0026gt;std::vector\u0026lt;/code\u0026gt;, but it is not quite the same, as it uses dynamic memory, and making it use one\u0026apos;s own stack-allocator isn\u0026apos;t exactly easy (alignment is an issue, too). It also doesn\u0026apos;t solve the same problem, because a vector is a resizable container, whereas VLAs are fixed-size. The \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2648.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;C++ Dynamic Array\u0026lt;/a\u0026gt; proposal is intended to introduce a library based solution, as alternative to a language based VLA. However, it\u0026apos;s not going to be part of C++0x, as far as I know.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You could always use alloca() to allocate memory on the stack at runtime, if you wished:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *values = (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *)\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;alloca\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;) * n);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Being allocated on the stack implies that it will automatically be freed when the stack unwinds.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Quick note: As mentioned in the Mac OS X man page for alloca(3), \u0026quot;The alloca() function is machine and compiler dependent; its use is dis-couraged.\u0026quot;  Just so you know.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In my own work, I\u0026apos;ve realized that every time I\u0026apos;ve wanted something like variable-length automatic arrays or alloca(), I didn\u0026apos;t really care that the memory was physically located on the cpu stack, just that it came from some stack allocator that didn\u0026apos;t incur slow trips to the general heap.  So I have a per-thread object that owns some memory from which it can push/pop variable sized buffers.  On some platforms I allow this to grow via mmu.  Other platforms have a fixed size (usually accompanied by a fixed size cpu stack as well because no mmu).  One platform I work with (a handheld game console) has precious little cpu stack anyway because it resides in scarce, fast memory.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;m not saying that pushing variable-sized buffers onto the cpu stack is never needed.  Honestly I was surprised back when I discovered this wasn\u0026apos;t standard, as it certainly seems like the concept fits into the language well enough.  For me though, the requirements \u0026quot;variable size\u0026quot; and \u0026quot;must be physically located on the cpu stack\u0026quot; have never come up together.  It\u0026apos;s been about speed, so I made my own sort of \u0026quot;parallel stack for data buffers\u0026quot;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are situations where allocating heap memory is very expensive compared to the operations performed. An example is matrix math. If you work with smallish matrices say 5 to 10 elements  and do a lot of arithmetics the malloc overhead will be really significant. At the same time making the size a compile time constant does seem very wasteful and inflexible.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I think that C++ is so unsafe in itself that the argument to \u0026quot;try to not add more unsafe features\u0026quot; is not very strong. On the other hand, as C++ is arguably the most runtime efficient programming language features which makes it more so are always useful: People who write performance critical programs will to a large extent use C++, and they need as much performance as possible. Moving stuff from heap to stack is one such possibility. Reducing the number of heap blocks is another. Allowing VLAs as object members would one way to achieve this. I\u0026apos;m working on such a suggestion. It is a bit complicated to implement, admittedly, but it seems quite doable.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Seems it will be available in C++14:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/C++14#Runtime-sized_one_dimensional_arrays\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://en.wikipedia.org/wiki/C%2B%2B14#Runtime-sized_one_dimensional_arrays\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Update: It did not make it into C++14.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This was considered for inclusion in C++/1x, \u0026lt;a href=\u0026quot;http://www.stroustrup.com/C++11FAQ.html#C99\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;but was dropped\u0026lt;/a\u0026gt; (this is a correction to what I said earlier).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It would be less useful in C++ anyway since we already have \u0026lt;code\u0026gt;std::vector\u0026lt;/code\u0026gt; to fill this role.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Arrays like this are part of C99, but not part of standard C++. as others have said, a vector is always a much better solution, which is probably why variable sized arrays are not in the C++ standatrd (or in the proposed C++0x standard).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;BTW, for questions on  \u0026quot;why\u0026quot; the C++ standard is the way it is, the moderated Usenet newsgroup \u0026lt;a href=\u0026quot;http://groups.google.com/group/comp.std.c++/topics?lnk=rgh\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;comp.std.c++\u0026lt;/a\u0026gt; is the place to go to.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Use std::vector for this. For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;std::vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; values;\nvalues.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;resize\u0026lt;/span\u0026gt;(n);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The memory will be allocated on the heap, but this holds only a small performance drawback. Furthermore, it is wise not to allocate large datablocks on the stack, as it is rather limited in size.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;C99 allows VLA. And it puts some restrictions on how to declare VLA. For details, refer to 6.7.5.2 of the standard. C++ disallows VLA. But g++ allows it.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;VLAs are a part of a larger family of Variably Modified types.\nThis family of types is very special because they have \u0026lt;em\u0026gt;runtime\u0026lt;/em\u0026gt; components.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The code:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; A[n];\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Is seen by compiler as:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; T[n];\nT A;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Note that the runtime size of array is not bound to the variable \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; but to the \u0026lt;strong\u0026gt;type\u0026lt;/strong\u0026gt; of the variable.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Nothing prevents one from making new variables of this type:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;T B,C,D;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;or the pointers or arrays\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;T *p, Z[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;];\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Moreover, pointers allow one to create VLAs with dynamic storage.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;T *p = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(T));\n...\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;free\u0026lt;/span\u0026gt;(p);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;What dispels a \u0026lt;strong\u0026gt;popular myth\u0026lt;/strong\u0026gt; that VLAs can only be allocated on stack.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Back to the question.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This runtime component does not work well with type deduction which is one of the bases with C++ typing system. It would not possible to use templates, deduction and  overloading.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;C++ typing system is static, all types must be fully defined or deduced during \u0026lt;em\u0026gt;compilation\u0026lt;/em\u0026gt;.\nVM types are completed only during program \u0026lt;em\u0026gt;execution\u0026lt;/em\u0026gt;.\nAdditional complexity introducing VM types to already hellishly complex C++ was simply considered unjustified. Mainly because their main practical application\nare automatic VLAs (\u0026lt;code\u0026gt;int A[n];\u0026lt;/code\u0026gt;) which have an alternative in form of \u0026lt;code\u0026gt;std::vector\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;It a bit sad because VM types provides very elegant and efficient solutions to programs handling multidimensional arrays.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In C one can simply write:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; A[n][n][n])\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; n; ++i)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; j = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; j \u0026amp;lt; n; ++j)\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; k = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; k \u0026amp;lt; n; ++k)\n        A[i][j][k] = i * j * k;\n}\n\n...\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; A[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;][\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;][\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;], B[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;][\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;][\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;];\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, A);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, B);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now try to provide as efficient and elegant solution in C++.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you know the value at compile time you can do the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; X\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; values[X];\n\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Edit: You can create an a vector that uses a stack allocator (alloca), since the allocator is a template parameter.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I have a solution that actually worked for me.  I did not want to allocate memory because of fragmentation on a routine that needed to run many times.  The answer is extremely dangerous, so use it at your own risk, but it takes advantage of assembly to reserve space on the stack.  My example below uses a character array (obviously other sized variable would require more memory).\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;varTest\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; iSz)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *varArray;\n    __asm {\n        sub esp, iSz       \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Create space on the stack for the variable array here\u0026lt;/span\u0026gt;\n        mov varArray, esp  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// save the end of it to our pointer\u0026lt;/span\u0026gt;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Use the array called varArray here...  \u0026lt;/span\u0026gt;\n\n    __asm {\n        add esp, iSz       \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Variable array is no longer accessible after this point\u0026lt;/span\u0026gt;\n    } \n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The dangers here are many but I\u0026apos;ll explain a few:\n1. Changing the variable size half way through would kill the stack position\n2. Overstepping the array bounds would destroy other variables and possible code\n3. This does not work in a 64 bit build... need different assembly for that one (but a macro might solve that problem).\n4. Compiler specific (may have trouble moving between compilers).  I haven\u0026apos;t tried so I really don\u0026apos;t know.\u0026lt;/p\u0026gt;\n    "],"id":130,"title":"Why aren't variable-length arrays part of the C++ standard?","slug":"why-aren't-variable-length-arrays-part-of-the-c++-standard-1657384712975","postType":"QUESTION","createdAt":"2022-07-09T16:38:32.000Z","updatedAt":"2022-07-09T16:38:32.000Z","tags":[{"id":475,"name":"variable-length-array","slug":"variable-length-array","createdAt":"2022-07-09T16:38:33.000Z","updatedAt":"2022-07-09T16:38:33.000Z","Questions_Tags":{"questionId":130,"tagId":475}}]}]}},"__N_SSG":true},"page":"/questions/tag/[slug]","query":{"slug":"variable-length-array"},"buildId":"B9ZMQqRLGvIP-RcWN9dT2","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>