<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2eccd4d47c856f2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2eccd4d47c856f2b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/81-096e453de8a27667.js" defer=""></script><script src="/_next/static/chunks/pages/questions/tag/%5Bslug%5D-6802ea06aeddcbec.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_buildManifest.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5"></style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="https://flowbite.com/docs/images/logo.svg" class="mr-3 h-6 sm:h-9" alt="Flowbite Logo"/><span class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Hunter</span></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/tag/variable-length-array#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="flex items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/why-aren&#x27;t-variable-length-arrays-part-of-the-c++-standard-1657384712975">Why aren&#x27;t variable-length arrays part of the C++ standard?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/variable-length-array">variable-length-array</a></div></div><div class="mt-4 mb-6" style="height:100px;overflow:auto"><h4 class="font-semibold">Solution 1:</h4><div class="text-sm bg-green-100 text-neutral-600">
<p>(Background: I have some experience implementing C and C++ compilers.)</p>

<p>Variable-length arrays in C99 were basically a misstep. In order to support VLAs, C99 had to make the following concessions to common sense:</p>

<ul>
<li><p><code>sizeof x</code> is no longer always a compile-time constant; the compiler must sometimes generate code to evaluate a <code>sizeof</code>-expression at runtime.</p></li>
<li><p>Allowing two-dimensional VLAs (<code>int A[x][y]</code>) required a new syntax for declaring functions that take 2D VLAs as parameters: <code>void foo(int n, int A[][*])</code>.</p></li>
<li><p>Less importantly in the C++ world, but extremely important for C's target audience of embedded-systems programmers, declaring a VLA means chomping an <em>arbitrarily large</em> chunk of your stack. This is a <em>guaranteed</em> stack-overflow and crash. (Anytime you declare <code>int A[n]</code>, you're implicitly asserting that you have 2GB of stack to spare. After all, if you know "<code>n</code> is definitely less than 1000 here", then you would just declare <code>int A[1000]</code>. Substituting the 32-bit integer <code>n</code> for <code>1000</code> is an admission that you have no idea what the behavior of your program ought to be.)</p></li>
</ul>

<p>Okay, so let's move to talking about C++ now. In C++, we have the same strong distinction between "type system" and "value system" that C89 does but we've really started to rely on it in ways that C has not. For example:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span> { ... };
<span class="hljs-type">int</span> A[n];
S&lt;<span class="hljs-keyword">decltype</span>(A)&gt; s;  <span class="hljs-comment">// equivalently, S&lt;int[n]&gt; s;</span>
</code></pre>

<p>If <code>n</code> weren't a compile-time constant (i.e., if <code>A</code> were of variably modified type), then what on earth would be the type of <code>S</code>? Would <code>S</code>'s type <em>also</em> be determined only at runtime?</p>

<p>What about this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">bool</span> <span class="hljs-title">myfunc</span><span class="hljs-params">(T&amp; t1, T&amp; t2)</span> </span>{ ... };
<span class="hljs-type">int</span> A1[n1], A2[n2];
<span class="hljs-built_in">myfunc</span>(A1, A2);
</code></pre>

<p>The compiler must generate code for some instantiation of <code>myfunc</code>. What should that code look like? How can we statically generate that code, if we don't know the type of <code>A1</code> at compile time?</p>

<p>Worse, what if it turns out at runtime that <code>n1 != n2</code>, so that <code>!std::is_same&lt;decltype(A1), decltype(A2)&gt;()</code>? In that case, the call to <code>myfunc</code> <strong>shouldn't even compile</strong>, because template type deduction should fail! How could we possibly emulate that behavior at runtime?</p>

<p>Basically, C++ is moving in the direction of pushing more and more decisions into <em>compile-time</em>: template code generation, <code>constexpr</code> function evaluation, and so on. Meanwhile, C99 was busy pushing traditionally <em>compile-time</em> decisions (e.g. <code>sizeof</code>) into the <em>runtime</em>. With this in mind, does it really even make sense to expend any effort <em>trying</em> to integrate C99-style VLAs into C++?</p>

<p>As every other answerer has already pointed out, C++ provides lots of heap-allocation mechanisms (<code>std::unique_ptr&lt;int[]&gt; A = new int[n];</code> or <code>std::vector&lt;int&gt; A(n);</code> being the obvious ones) when you really want to convey the idea "I have no idea how much RAM I might need." And C++ provides a nifty exception-handling model for dealing with the inevitable situation that the amount of RAM you need is greater than the amount of RAM you have. But hopefully <em>this</em> answer gives you a good idea of why C99-style VLAs were <strong>not</strong> a good fit for C++  and not really even a good fit for C99. ;)</p>

<hr>

<p>For more on the topic, see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf" rel="noreferrer">N3810 "Alternatives for Array Extensions"</a>, Bjarne Stroustrup's October 2013 paper on VLAs. Bjarne's POV is very different from mine; N3810 focuses more on finding a good C++ish <em>syntax</em> for the things, and on discouraging the use of raw arrays in C++, whereas I focused more on the implications for metaprogramming and the typesystem. I don't know if he considers the metaprogramming/typesystem implications solved, solvable, or merely uninteresting.</p>

<hr>

<p>A good blog post that hits many of these same points is <a href="https://nullprogram.com/blog/2019/10/27/" rel="noreferrer">"Legitimate Use of Variable Length Arrays"</a> (Chris Wellons, 2019-10-27).</p>
    </div></div><div><div class="flex items-center justify-between text-slate-500"><div class="flex space-x-4 md:space-x-8"><div class="flex cursor-pointer items-center transition hover:text-slate-600"><svg xmlns="http://www.w3.org/2000/svg" class="mr-1.5 h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M14 10h4.764a2 2 0 011.789 2.894l-3.5 7A2 2 0 0115.263 21h-4.017c-.163 0-.326-.02-.485-.06L7 20m7-10V5a2 2 0 00-2-2h-.095c-.5 0-.905.405-.905.905 0 .714-.211 1.412-.608 2.006L7 11v9m7-10h-2M7 20H5a2 2 0 01-2-2v-6a2 2 0 012-2h2.5"></path></svg><span>4</span></div></div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"count":1,"rows":[{"answer":["\n\u0026lt;p\u0026gt;(Background: I have some experience implementing C and C++ compilers.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Variable-length arrays in C99 were basically a misstep. In order to support VLAs, C99 had to make the following concessions to common sense:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;sizeof x\u0026lt;/code\u0026gt; is no longer always a compile-time constant; the compiler must sometimes generate code to evaluate a \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt;-expression at runtime.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Allowing two-dimensional VLAs (\u0026lt;code\u0026gt;int A[x][y]\u0026lt;/code\u0026gt;) required a new syntax for declaring functions that take 2D VLAs as parameters: \u0026lt;code\u0026gt;void foo(int n, int A[][*])\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Less importantly in the C++ world, but extremely important for C\u0026apos;s target audience of embedded-systems programmers, declaring a VLA means chomping an \u0026lt;em\u0026gt;arbitrarily large\u0026lt;/em\u0026gt; chunk of your stack. This is a \u0026lt;em\u0026gt;guaranteed\u0026lt;/em\u0026gt; stack-overflow and crash. (Anytime you declare \u0026lt;code\u0026gt;int A[n]\u0026lt;/code\u0026gt;, you\u0026apos;re implicitly asserting that you have 2GB of stack to spare. After all, if you know \u0026quot;\u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt; is definitely less than 1000 here\u0026quot;, then you would just declare \u0026lt;code\u0026gt;int A[1000]\u0026lt;/code\u0026gt;. Substituting the 32-bit integer \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt; for \u0026lt;code\u0026gt;1000\u0026lt;/code\u0026gt; is an admission that you have no idea what the behavior of your program ought to be.)\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Okay, so let\u0026apos;s move to talking about C++ now. In C++, we have the same strong distinction between \u0026quot;type system\u0026quot; and \u0026quot;value system\u0026quot; that C89 does but we\u0026apos;ve really started to rely on it in ways that C has not. For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;S\u0026lt;/span\u0026gt; { ... };\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; A[n];\nS\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(A)\u0026amp;gt; s;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// equivalently, S\u0026amp;lt;int[n]\u0026amp;gt; s;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt; weren\u0026apos;t a compile-time constant (i.e., if \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; were of variably modified type), then what on earth would be the type of \u0026lt;code\u0026gt;S\u0026lt;/code\u0026gt;? Would \u0026lt;code\u0026gt;S\u0026lt;/code\u0026gt;\u0026apos;s type \u0026lt;em\u0026gt;also\u0026lt;/em\u0026gt; be determined only at runtime?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;What about this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;myfunc\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T\u0026amp;amp; t1, T\u0026amp;amp; t2)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ ... };\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; A1[n1], A2[n2];\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;myfunc\u0026lt;/span\u0026gt;(A1, A2);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The compiler must generate code for some instantiation of \u0026lt;code\u0026gt;myfunc\u0026lt;/code\u0026gt;. What should that code look like? How can we statically generate that code, if we don\u0026apos;t know the type of \u0026lt;code\u0026gt;A1\u0026lt;/code\u0026gt; at compile time?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Worse, what if it turns out at runtime that \u0026lt;code\u0026gt;n1 != n2\u0026lt;/code\u0026gt;, so that \u0026lt;code\u0026gt;!std::is_same\u0026amp;lt;decltype(A1), decltype(A2)\u0026amp;gt;()\u0026lt;/code\u0026gt;? In that case, the call to \u0026lt;code\u0026gt;myfunc\u0026lt;/code\u0026gt; \u0026lt;strong\u0026gt;shouldn\u0026apos;t even compile\u0026lt;/strong\u0026gt;, because template type deduction should fail! How could we possibly emulate that behavior at runtime?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Basically, C++ is moving in the direction of pushing more and more decisions into \u0026lt;em\u0026gt;compile-time\u0026lt;/em\u0026gt;: template code generation, \u0026lt;code\u0026gt;constexpr\u0026lt;/code\u0026gt; function evaluation, and so on. Meanwhile, C99 was busy pushing traditionally \u0026lt;em\u0026gt;compile-time\u0026lt;/em\u0026gt; decisions (e.g. \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt;) into the \u0026lt;em\u0026gt;runtime\u0026lt;/em\u0026gt;. With this in mind, does it really even make sense to expend any effort \u0026lt;em\u0026gt;trying\u0026lt;/em\u0026gt; to integrate C99-style VLAs into C++?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As every other answerer has already pointed out, C++ provides lots of heap-allocation mechanisms (\u0026lt;code\u0026gt;std::unique_ptr\u0026amp;lt;int[]\u0026amp;gt; A = new int[n];\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;std::vector\u0026amp;lt;int\u0026amp;gt; A(n);\u0026lt;/code\u0026gt; being the obvious ones) when you really want to convey the idea \u0026quot;I have no idea how much RAM I might need.\u0026quot; And C++ provides a nifty exception-handling model for dealing with the inevitable situation that the amount of RAM you need is greater than the amount of RAM you have. But hopefully \u0026lt;em\u0026gt;this\u0026lt;/em\u0026gt; answer gives you a good idea of why C99-style VLAs were \u0026lt;strong\u0026gt;not\u0026lt;/strong\u0026gt; a good fit for C++  and not really even a good fit for C99. ;)\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;For more on the topic, see \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;N3810 \u0026quot;Alternatives for Array Extensions\u0026quot;\u0026lt;/a\u0026gt;, Bjarne Stroustrup\u0026apos;s October 2013 paper on VLAs. Bjarne\u0026apos;s POV is very different from mine; N3810 focuses more on finding a good C++ish \u0026lt;em\u0026gt;syntax\u0026lt;/em\u0026gt; for the things, and on discouraging the use of raw arrays in C++, whereas I focused more on the implications for metaprogramming and the typesystem. I don\u0026apos;t know if he considers the metaprogramming/typesystem implications solved, solvable, or merely uninteresting.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;A good blog post that hits many of these same points is \u0026lt;a href=\u0026quot;https://nullprogram.com/blog/2019/10/27/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026quot;Legitimate Use of Variable Length Arrays\u0026quot;\u0026lt;/a\u0026gt; (Chris Wellons, 2019-10-27).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There recently was a discussion about this kicked off in usenet: \u0026lt;a href=\u0026quot;http://groups.google.com/group/comp.std.c++/browse_thread/thread/2bfe25800d4961e8/9545494bbb336dfa\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Why no VLAs in C++0x\u0026lt;/a\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I agree with those people that seem to agree that having to create a potential large array on the stack, which usually has only little space available, isn\u0026apos;t good. The argument is, if you know the size beforehand, you can use a static array. And if you don\u0026apos;t know the size beforehand, you will write unsafe code. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;C99 VLAs could provide a small benefit of being able to create small arrays without wasting space or calling constructors for unused elements, but they will introduce rather large changes to the type system (you need to be able to specify types depending on runtime values - this does not yet exist in current C++, except for \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; operator type-specifiers, but they are treated specially, so that the runtime-ness doesn\u0026apos;t escape the scope of the \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; operator).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can use \u0026lt;code\u0026gt;std::vector\u0026lt;/code\u0026gt;, but it is not quite the same, as it uses dynamic memory, and making it use one\u0026apos;s own stack-allocator isn\u0026apos;t exactly easy (alignment is an issue, too). It also doesn\u0026apos;t solve the same problem, because a vector is a resizable container, whereas VLAs are fixed-size. The \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2648.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;C++ Dynamic Array\u0026lt;/a\u0026gt; proposal is intended to introduce a library based solution, as alternative to a language based VLA. However, it\u0026apos;s not going to be part of C++0x, as far as I know.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You could always use alloca() to allocate memory on the stack at runtime, if you wished:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *values = (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *)\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;alloca\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;) * n);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Being allocated on the stack implies that it will automatically be freed when the stack unwinds.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Quick note: As mentioned in the Mac OS X man page for alloca(3), \u0026quot;The alloca() function is machine and compiler dependent; its use is dis-couraged.\u0026quot;  Just so you know.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In my own work, I\u0026apos;ve realized that every time I\u0026apos;ve wanted something like variable-length automatic arrays or alloca(), I didn\u0026apos;t really care that the memory was physically located on the cpu stack, just that it came from some stack allocator that didn\u0026apos;t incur slow trips to the general heap.  So I have a per-thread object that owns some memory from which it can push/pop variable sized buffers.  On some platforms I allow this to grow via mmu.  Other platforms have a fixed size (usually accompanied by a fixed size cpu stack as well because no mmu).  One platform I work with (a handheld game console) has precious little cpu stack anyway because it resides in scarce, fast memory.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;m not saying that pushing variable-sized buffers onto the cpu stack is never needed.  Honestly I was surprised back when I discovered this wasn\u0026apos;t standard, as it certainly seems like the concept fits into the language well enough.  For me though, the requirements \u0026quot;variable size\u0026quot; and \u0026quot;must be physically located on the cpu stack\u0026quot; have never come up together.  It\u0026apos;s been about speed, so I made my own sort of \u0026quot;parallel stack for data buffers\u0026quot;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are situations where allocating heap memory is very expensive compared to the operations performed. An example is matrix math. If you work with smallish matrices say 5 to 10 elements  and do a lot of arithmetics the malloc overhead will be really significant. At the same time making the size a compile time constant does seem very wasteful and inflexible.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I think that C++ is so unsafe in itself that the argument to \u0026quot;try to not add more unsafe features\u0026quot; is not very strong. On the other hand, as C++ is arguably the most runtime efficient programming language features which makes it more so are always useful: People who write performance critical programs will to a large extent use C++, and they need as much performance as possible. Moving stuff from heap to stack is one such possibility. Reducing the number of heap blocks is another. Allowing VLAs as object members would one way to achieve this. I\u0026apos;m working on such a suggestion. It is a bit complicated to implement, admittedly, but it seems quite doable.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Seems it will be available in C++14:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/C++14#Runtime-sized_one_dimensional_arrays\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://en.wikipedia.org/wiki/C%2B%2B14#Runtime-sized_one_dimensional_arrays\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Update: It did not make it into C++14.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This was considered for inclusion in C++/1x, \u0026lt;a href=\u0026quot;http://www.stroustrup.com/C++11FAQ.html#C99\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;but was dropped\u0026lt;/a\u0026gt; (this is a correction to what I said earlier).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It would be less useful in C++ anyway since we already have \u0026lt;code\u0026gt;std::vector\u0026lt;/code\u0026gt; to fill this role.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Arrays like this are part of C99, but not part of standard C++. as others have said, a vector is always a much better solution, which is probably why variable sized arrays are not in the C++ standatrd (or in the proposed C++0x standard).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;BTW, for questions on  \u0026quot;why\u0026quot; the C++ standard is the way it is, the moderated Usenet newsgroup \u0026lt;a href=\u0026quot;http://groups.google.com/group/comp.std.c++/topics?lnk=rgh\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;comp.std.c++\u0026lt;/a\u0026gt; is the place to go to.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Use std::vector for this. For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;std::vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; values;\nvalues.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;resize\u0026lt;/span\u0026gt;(n);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The memory will be allocated on the heap, but this holds only a small performance drawback. Furthermore, it is wise not to allocate large datablocks on the stack, as it is rather limited in size.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;C99 allows VLA. And it puts some restrictions on how to declare VLA. For details, refer to 6.7.5.2 of the standard. C++ disallows VLA. But g++ allows it.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;VLAs are a part of a larger family of Variably Modified types.\nThis family of types is very special because they have \u0026lt;em\u0026gt;runtime\u0026lt;/em\u0026gt; components.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The code:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; A[n];\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Is seen by compiler as:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; T[n];\nT A;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Note that the runtime size of array is not bound to the variable \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; but to the \u0026lt;strong\u0026gt;type\u0026lt;/strong\u0026gt; of the variable.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Nothing prevents one from making new variables of this type:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;T B,C,D;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;or the pointers or arrays\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;T *p, Z[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;];\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Moreover, pointers allow one to create VLAs with dynamic storage.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;T *p = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(T));\n...\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;free\u0026lt;/span\u0026gt;(p);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;What dispels a \u0026lt;strong\u0026gt;popular myth\u0026lt;/strong\u0026gt; that VLAs can only be allocated on stack.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Back to the question.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This runtime component does not work well with type deduction which is one of the bases with C++ typing system. It would not possible to use templates, deduction and  overloading.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;C++ typing system is static, all types must be fully defined or deduced during \u0026lt;em\u0026gt;compilation\u0026lt;/em\u0026gt;.\nVM types are completed only during program \u0026lt;em\u0026gt;execution\u0026lt;/em\u0026gt;.\nAdditional complexity introducing VM types to already hellishly complex C++ was simply considered unjustified. Mainly because their main practical application\nare automatic VLAs (\u0026lt;code\u0026gt;int A[n];\u0026lt;/code\u0026gt;) which have an alternative in form of \u0026lt;code\u0026gt;std::vector\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;It a bit sad because VM types provides very elegant and efficient solutions to programs handling multidimensional arrays.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In C one can simply write:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; A[n][n][n])\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; n; ++i)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; j = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; j \u0026amp;lt; n; ++j)\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; k = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; k \u0026amp;lt; n; ++k)\n        A[i][j][k] = i * j * k;\n}\n\n...\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; A[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;][\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;][\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;], B[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;][\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;][\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;];\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, A);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, B);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now try to provide as efficient and elegant solution in C++.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you know the value at compile time you can do the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; X\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; values[X];\n\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Edit: You can create an a vector that uses a stack allocator (alloca), since the allocator is a template parameter.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I have a solution that actually worked for me.  I did not want to allocate memory because of fragmentation on a routine that needed to run many times.  The answer is extremely dangerous, so use it at your own risk, but it takes advantage of assembly to reserve space on the stack.  My example below uses a character array (obviously other sized variable would require more memory).\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;varTest\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; iSz)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *varArray;\n    __asm {\n        sub esp, iSz       \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Create space on the stack for the variable array here\u0026lt;/span\u0026gt;\n        mov varArray, esp  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// save the end of it to our pointer\u0026lt;/span\u0026gt;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Use the array called varArray here...  \u0026lt;/span\u0026gt;\n\n    __asm {\n        add esp, iSz       \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Variable array is no longer accessible after this point\u0026lt;/span\u0026gt;\n    } \n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The dangers here are many but I\u0026apos;ll explain a few:\n1. Changing the variable size half way through would kill the stack position\n2. Overstepping the array bounds would destroy other variables and possible code\n3. This does not work in a 64 bit build... need different assembly for that one (but a macro might solve that problem).\n4. Compiler specific (may have trouble moving between compilers).  I haven\u0026apos;t tried so I really don\u0026apos;t know.\u0026lt;/p\u0026gt;\n    "],"comment":["\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Just out of curiosity, why does it need to be allocated on the stack? Are you that affraid of heap allocation performance issues?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/74612/dimitri-c\u0026quot; title=\u0026quot;21,240 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Dimitri C.\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment1787685_1887097\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-12-11 10:32:07Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 11, 2009 at 10:32\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Dimitri Not really, but there\u0026apos;s no denying that stack allocation will be faster than heap allocation. And in some cases this may matter.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/125672/andreas-brinck\u0026quot; title=\u0026quot;49,524 reputation\u0026quot; class=\u0026quot;comment-user owner\u0026quot;\u0026gt;Andreas Brinck\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment1787713_1887097\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-12-11 10:37:03Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 11, 2009 at 10:37\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;The main advantage of variable length arrays that all data is close together so when you iterate through this array you read and write bytes next to each other. Your data is fetched into the cache and cpu can work on it without fetching and sending the bytes to/from the memory.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/58805/calmarius\u0026quot; title=\u0026quot;17,549 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Calmarius\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment4295973_1887097\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-10-24 16:04:44Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 24, 2010 at 16:04\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Variable length arrays are also may be used to replace preprocessor constants with static const variables. Also in C you don\u0026apos;t have another options for VLA, and it is sometimes needed to write portable C/C++ code (compatible with both compilers).\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/685653/yury\u0026quot; title=\u0026quot;2,792 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Yury\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment19300414_1887097\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-12-21 06:45:05Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 21, 2012 at 6:45\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;as an aside, it appears clang++ allows VLAs.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3426763/user3426763\u0026quot; title=\u0026quot;1 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;user3426763\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment34132475_1887097\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-03-16 20:42:23Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 16, 2014 at 20:42\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I agree VLAs were just wrong.  The much more widely implemented, and far more useful, \u0026lt;code\u0026gt;alloca()\u0026lt;/code\u0026gt; should have been standardized in C99 instead.  VLAs are what happens when a standards committee jumps out ahead of implementations, instead of the other way around.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/939557/madscientist\u0026quot; title=\u0026quot;82,898 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;MadScientist\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment34467712_21519062\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-03-25 11:21:02Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 25, 2014 at 11:21\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;The variably-modified type system is a great addition IMO, and none of your bullet points violate common sense.  (1) the C standard does not distinguish between \u0026quot;compile-time\u0026quot; and \u0026quot;run-time\u0026quot; so this is a non-issue; (2) The \u0026lt;code\u0026gt;*\u0026lt;/code\u0026gt; is optional, you can (and should) write \u0026lt;code\u0026gt;int A[][n]\u0026lt;/code\u0026gt;; (3) You can use the type system without actually declaring any VLAs. For example a function can accept array of variably modified type, and it can be called with non-VLA 2-D arrays of differing dimensions.   However you make valid points in the latter part of your post.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1505939/m-m\u0026quot; title=\u0026quot;135,063 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;M.M\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment46415072_21519062\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-03-17 04:52:00Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 17, 2015 at 4:52\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026quot;declaring a VLA means chomping an arbitrarily large chunk of your stack. This is a guaranteed stack-overflow and crash. (Anytime you declare int A[n], you\u0026apos;re implicitly asserting that you have 2GB of stack to spare\u0026quot; is empirically false.  I just ran a VLA program with a stack far less than 2GB without any stack overflow.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2189128/jeff-hammond\u0026quot; title=\u0026quot;4,975 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Jeff Hammond\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment62599689_21519062\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-05-31 20:54:45Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 31, 2016 at 20:54\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026apos;\u0026lt;i\u0026gt;After all, if you know \u0026quot;n is definitely less than 1000 here\u0026quot;, then you would just declare int A[1000].\u0026lt;/i\u0026gt;\u0026apos; is just nonsense. If, say, the VLA length is \u0026lt;code\u0026gt;10\u0026lt;/code\u0026gt; on 99.99% of function invocations and only hits its upper bound of \u0026lt;code\u0026gt;1000\u0026lt;/code\u0026gt; on 0.01% of invocations, you\u0026apos;ve just basically wasted 1000 bytes that will never be freed as long as the frame remains on the stack -- which could be almost all the time if the function is high up your control flow hierarchy. You may think 1000 bytes is not much, but then factor in all your cache misses every time  your CPU has to move in and out of that function!\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/765294/will\u0026quot; title=\u0026quot;1,967 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Will\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment98190075_21519062\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-04-19 06:01:14Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 19, 2019 at 6:01\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;As for embedded, I work almost exclusively with embedded systems and I use pointers to VLA all the time. Allocating VLA objects is however banned by my coding standard. But I don\u0026apos;t recall ever seeing a stack overflow caused by VLA in any embedded system. The \u0026quot;anti-VLA movement\u0026quot; rather seems to be coming from the PC people with Microsoft in front. Because if VLA are allowed, MS would have to update their so called \u0026quot;2019\u0026quot; compiler from 1989 to fall in line with the 1999 version of the language.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/584518/lundin\u0026quot; title=\u0026quot;175,730 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Lundin\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment117924203_21519062\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2021-03-19 14:25:21Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 19, 2021 at 14:25\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;+1 and accepted. One comment though, I think the safety argument is a little bit weak since there are so many other ways to cause stack overflows. The safety argument could be used to support the position that you should never use recursion and that you should allocate \u0026lt;i\u0026gt;all\u0026lt;/i\u0026gt; objects from the heap.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/125672/andreas-brinck\u0026quot; title=\u0026quot;49,524 reputation\u0026quot; class=\u0026quot;comment-user owner\u0026quot;\u0026gt;Andreas Brinck\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment1787758_1887178\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-12-11 10:46:31Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 11, 2009 at 10:46\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;So you\u0026apos;re saying that because there are other ways to cause stack overflows, we might as well encourage more of them?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/33213/jalf\u0026quot; title=\u0026quot;236,976 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;jalf\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment1787812_1887178\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-12-11 10:57:52Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 11, 2009 at 10:57\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Andreas, agreed about the weakness. But for recursion, it takes a huge number of calls until stack is eaten up, and if that can be the case, people would use iteration. As some people on the usenet thread say, though, this is not an argument against VLAs in all cases, since sometimes you definitely may know an upper bound. But in those cases, from what i see a static array can equally be sufficient, since it would not waste much space anyway (if it \u0026lt;i\u0026gt;would\u0026lt;/i\u0026gt;, then you would actually have to ask whether the stack area is large enough again).\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/34509/johannes-schaub-litb\u0026quot; title=\u0026quot;482,727 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Johannes Schaub - litb\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment1787828_1887178\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-12-11 11:00:14Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 11, 2009 at 11:00\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Also look at Matt Austern\u0026apos;s answer in that thread: The language specification of VLAs would probably considerably more complex for C++, because of the stricter type matches in C++ (example: C allows assigning a \u0026lt;code\u0026gt;T(*)[]\u0026lt;/code\u0026gt; to a \u0026lt;code\u0026gt;T(*)[N]\u0026lt;/code\u0026gt; - in C++ this is not allowed, since C++ does not know about \u0026quot;type compatibility\u0026quot; - it requires exact matches), type parameters, exceptions, con- and destructors and stuffs. I\u0026apos;m not sure whether the benefits of VLAs would really pay off all that work. But then, i have never used VLAs in real life, so i probably don\u0026apos;t know good use cases for them.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/34509/johannes-schaub-litb\u0026quot; title=\u0026quot;482,727 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Johannes Schaub - litb\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment1787848_1887178\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-12-11 11:03:43Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 11, 2009 at 11:03\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@AHelps: Perhaps what would be best for that would be a type that behaves somewhat like \u0026lt;code\u0026gt;vector\u0026lt;/code\u0026gt; but requires a fixed LIFO usage pattern and maintains one or more per-thread statically-allocated buffers which are generally sized according to the largest total allocation the thread has ever used, but which could be explicitly trimmed.  A normal \u0026quot;allocation\u0026quot; would in the common case require nothing more than a pointer copy, pointer-from-pointer subtraction, integer comparison, and pointer addition; de-allocation would simply require a pointer copy.  Not much slower than a VLA.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/363751/supercat\u0026quot; title=\u0026quot;73,697 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;supercat\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment49316886_1887178\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-06-03 16:15:39Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 3, 2015 at 16:15\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Also, the scope for alloca() is the entire function, not just the block of code containing the variable. So using it inside of a loop it will continuously increase the stack. A VLA does not have this problem.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/492336/sashoalm\u0026quot; title=\u0026quot;69,607 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;sashoalm\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment63718888_1887192\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-07-01 11:49:17Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 1, 2016 at 11:49\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;However, VLAs having the scope of the enclosing block means they are significantly less useful than alloca() with the scope of the entire function.  Consider: \u0026lt;code\u0026gt;if (!p) { p = alloca(strlen(foo)+1); strcpy(p, foo); }\u0026lt;/code\u0026gt;  This cannot be done with VLAs, precisely because of their block scope.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/939557/madscientist\u0026quot; title=\u0026quot;82,898 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;MadScientist\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment70438209_1887192\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-01-12 16:35:05Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 12, 2017 at 16:35\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;That does not answer OP\u0026apos;s \u0026lt;i\u0026gt;why\u0026lt;/i\u0026gt; question. Moreover, this is a \u0026lt;code\u0026gt;C\u0026lt;/code\u0026gt;-like solution, and not really \u0026lt;code\u0026gt;C++\u0026lt;/code\u0026gt;-ish.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2311167/adrian-w\u0026quot; title=\u0026quot;4,078 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Adrian W\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment89046720_1887192\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-06-25 15:37:30Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 25, 2018 at 15:37\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;not equivalent. alloca has dirty syntax.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/208397/codinglab\u0026quot; title=\u0026quot;1,433 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;CodingLab\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment124618208_1887192\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2021-12-27 15:50:37Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 27, 2021 at 15:50\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;This has the downside of having to manage that stack manually, but it\u0026apos;s generally a very good approach.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/8063904/smiley1000\u0026quot; title=\u0026quot;55 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Smiley1000\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment121372840_15553765\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2021-08-06 08:55:12Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 6, 2021 at 8:55\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I\u0026apos;ve thought about this too... are you saying that you effectively have a \u0026lt;code\u0026gt;thread_local std::pmr::unsynchronized_pool_resource;\u0026lt;/code\u0026gt; that you can get at from anywhere when you want thread-local scratch space?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/874660/ben\u0026quot; title=\u0026quot;7,913 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Ben\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment125451822_15553765\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2022-02-03 00:56:24Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 3 at 0:56\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;interesting. Herb Sutter discusses it here under \u0026lt;b\u0026gt;Dynamic Arrays\u0026lt;/b\u0026gt;: \u0026lt;a href=\u0026quot;http://isocpp.org/blog/2013/04/trip-report-iso-c-spring-2013-meeting\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;isocpp.org/blog/2013/04/trip-report-iso-c-spring-2013-meeting\u0026lt;/a\u0026gt; (this is the reference for the wikipedia information)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/238902/default\u0026quot; title=\u0026quot;11,015 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;default\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment26685660_18206942\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-08-13 11:12:34Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 13, 2013 at 11:12\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026quot;Run-time sized arrays and dynarray have been moved to the Array Extensions technical specification\u0026quot; wrote 78.86.152.103 on Wikipedia on 18 January 2014: \u0026lt;a href=\u0026quot;https://en.wikipedia.org/w/index.php?title=C%2B%2B14\u0026amp;amp;diff=591269892\u0026amp;amp;oldid=589637208\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;en.wikipedia.org/w/\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/39992/strager\u0026quot; title=\u0026quot;86,906 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;strager\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment33305082_18206942\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-02-24 03:26:19Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 24, 2014 at 3:26\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Wikipedia isn\u0026apos;t a normative reference :)  This proposal did not make it into C++14.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1505939/m-m\u0026quot; title=\u0026quot;135,063 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;M.M\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment42042498_18206942\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-11-04 02:37:29Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 4, 2014 at 2:37\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@ViktorSehr: What\u0026apos;s the status of this w.r.t. C++17?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1593077/einpoklum\u0026quot; title=\u0026quot;103,988 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;einpoklum\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment61839178_18206942\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-05-10 23:37:00Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 10, 2016 at 23:37\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@einpoklum No idea, use boost::container::static_vector\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/100724/viktor-sehr\u0026quot; title=\u0026quot;12,560 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Viktor Sehr\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment72253812_18206942\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-03-02 15:44:11Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 2, 2017 at 15:44\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;No, we don\u0026apos;t, std::vector doesn\u0026apos;t allocate data on the stack. :)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/399317/kos\u0026quot; title=\u0026quot;68,155 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Kos\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment8376145_1887171\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-08-10 16:34:30Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 10, 2011 at 16:34\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@M.M: Fair enough, but in practice we still can\u0026apos;t use \u0026lt;code\u0026gt;std::vector\u0026lt;/code\u0026gt; instead of, say, \u0026lt;code\u0026gt;alloca()\u0026lt;/code\u0026gt;.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1593077/einpoklum\u0026quot; title=\u0026quot;103,988 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;einpoklum\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment61839162_1887171\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-05-10 23:36:09Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 10, 2016 at 23:36\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@einpoklum in terms of getting correct output for your program , you can. Performance is a quality-of-implementation issue\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1505939/m-m\u0026quot; title=\u0026quot;135,063 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;M.M\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment61839405_1887171\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-05-10 23:50:09Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 10, 2016 at 23:50\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@M.M quality-of-implementation is not portable. and if you don\u0026apos;t need performance, you don\u0026apos;t use c++ in the first place\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2088034/pal\u0026quot; title=\u0026quot;620 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;pal\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment101340991_1887171\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-08-09 13:49:30Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 9, 2019 at 13:49\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;How do you handle multidimensions with vectors without tedious multiplications. C++ only gives excuses to exclude useful tools while they lie about \u0026quot;we need to allow people to write things we don\u0026apos;t imagine\u0026quot;. If this was useless why all these languages support it: \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Variable-length_array\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;en.wikipedia.org/wiki/Variable-length_array\u0026lt;/a\u0026gt;   even C# added it and yes it is called stackalloc....\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2187015/abdurrahim\u0026quot; title=\u0026quot;1,959 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Abdurrahim\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment122699507_1887171\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2021-10-02 20:30:23Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 2, 2021 at 20:30\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;-1 Vector is not always better.  Often, yes.  Always, no.  If you only need a small array, are on a platform where heap space is slow, and your library\u0026apos;s implementation of vector uses heap space, then this feature might very well be better if it existed.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1035398/patrick-m\u0026quot; title=\u0026quot;1,006 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Patrick M\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment25586894_1887165\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-07-11 01:14:42Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 11, 2013 at 1:14\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;A major application for variable length arrays is evaluation of arbitrary degree polynomials. In that case, your \u0026quot;small performance drawback\u0026quot; means \u0026quot;the code runs five times slower in typical cases.\u0026quot; That\u0026apos;s not small.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/78006/ahelps\u0026quot; title=\u0026quot;1,772 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;AHelps\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment47286043_1887145\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-04-10 18:26:44Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 10, 2015 at 18:26\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Why don\u0026apos;t you simply use \u0026lt;code\u0026gt;std::vector\u0026amp;lt;int\u0026amp;gt; values(n);\u0026lt;/code\u0026gt;?  By using \u0026lt;code\u0026gt;resize\u0026lt;/code\u0026gt; after construction you are prohibiting non-moveable types.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/9716597/l-f\u0026quot; title=\u0026quot;18,153 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;L. F.\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment102884626_1887145\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-10-06 13:57:40Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 6, 2019 at 13:57\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;not equivalent. dirty syntax.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/208397/codinglab\u0026quot; title=\u0026quot;1,433 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;CodingLab\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment124618264_1887145\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2021-12-27 15:53:26Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 27, 2021 at 15:53\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Can you provide a link to the standard paragraph that you are pointing ?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/4558911/vincent\u0026quot; title=\u0026quot;3,616 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Vincent\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment75412823_11734003\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-05-26 11:10:53Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 26, 2017 at 11:10\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;If you know the value at compile time, you don\u0026apos;t need a template at all. Just use X directly in your non-template function.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/33732/rob-kennedy\u0026quot; title=\u0026quot;159,435 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Rob Kennedy\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment1789536_1887172\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-12-11 15:43:26Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 11, 2009 at 15:43\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Sometimes the caller knows at compile-time and the callee does not, that\u0026apos;s what templates are good for. Of course, in the general case, no one knows X until run-time.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/22820/qwertie\u0026quot; title=\u0026quot;15,216 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Qwertie\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment15308764_1887172\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-07-20 00:50:45Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 20, 2012 at 0:50\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 4 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;You can\u0026apos;t use alloca in a STL allocator - allocated memory from alloca will be freed when the stack frame is destroyed - that\u0026apos;s when the method who should allocate memory returns.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/209610/oliver\u0026quot; title=\u0026quot;775 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Oliver\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment17497481_1887172\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-10-16 12:58:47Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 16, 2012 at 12:58\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;... and if you want to roll this yourself, maybe use a RAII class?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1593077/einpoklum\u0026quot; title=\u0026quot;103,988 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;einpoklum\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment61839226_21132597\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-05-10 23:39:45Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 10, 2016 at 23:39\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;You could simply use boost::container::static_vector thou.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/100724/viktor-sehr\u0026quot; title=\u0026quot;12,560 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Viktor Sehr\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment61849092_21132597\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-05-11 07:51:58Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 11, 2016 at 7:51\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;This doesn\u0026apos;t have equivalents for other compilers which have more raw assembly than MSVC. VC will likely understand that \u0026lt;code\u0026gt;esp\u0026lt;/code\u0026gt; changed and will adjust its accesses to stack, but in e.g. GCC you\u0026apos;ll just break it completely  at least if you use optimizations and \u0026lt;code\u0026gt;-fomit-frame-pointer\u0026lt;/code\u0026gt; in particular.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/673852/ruslan\u0026quot; title=\u0026quot;16,742 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Ruslan\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment63384889_21132597\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-06-22 13:29:59Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 22, 2016 at 13:29\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        "],"id":130,"title":"Why aren't variable-length arrays part of the C++ standard?","content":"\n                \n\u0026lt;p\u0026gt;I haven\u0026apos;t used C very much in the last few years. When I read \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/1886504/coding-problem-using-a-2-d-array-of-structs-inside-another-struct-in-c\u0026quot;\u0026gt;this question\u0026lt;/a\u0026gt; today I came across some C syntax which I wasn\u0026apos;t familiar with.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Apparently in \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/C99\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;C99\u0026lt;/a\u0026gt; the following syntax is valid:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; values[n]; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Declare a variable length array\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This seems like a pretty useful feature. Was there ever a discussion about adding it to the C++ standard, and if so, why it was omitted?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Some potential reasons:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Hairy for compiler vendors to implement\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Incompatible with some other part of the standard\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Functionality can be emulated with other C++ constructs\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;The C++ standard states that array size must be a constant expression (8.3.4.1).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Yes, of course I realize that in the toy example one could use \u0026lt;code\u0026gt;std::vector\u0026amp;lt;int\u0026amp;gt; values(m);\u0026lt;/code\u0026gt;, but this allocates memory from the heap and not the stack. And if I want a multidimensional array like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; y, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; z)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; values[x][y][z]; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Declare a variable length array\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;the \u0026lt;code\u0026gt;vector\u0026lt;/code\u0026gt; version becomes pretty clumsy:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; y, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; z)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    vector\u0026amp;lt; vector\u0026amp;lt; vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026amp;gt; \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;values\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* Really painful expression here. */\u0026lt;/span\u0026gt;);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The slices, rows and columns will also potentially be spread all over memory.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Looking at the discussion at \u0026lt;code\u0026gt;comp.std.c++\u0026lt;/code\u0026gt; it\u0026apos;s clear that this question is pretty controversial with some very heavyweight names on both sides of the argument. It\u0026apos;s certainly not obvious that a \u0026lt;code\u0026gt;std::vector\u0026lt;/code\u0026gt; is always a better solution.\u0026lt;/p\u0026gt;\n    ","slug":"why-aren't-variable-length-arrays-part-of-the-c++-standard-1657384712975","postType":"QUESTION","createdAt":"2022-07-09T16:38:32.000Z","updatedAt":"2022-07-09T16:38:32.000Z","tags":[{"id":475,"name":"variable-length-array","slug":"variable-length-array","createdAt":"2022-07-09T16:38:33.000Z","updatedAt":"2022-07-09T16:38:33.000Z","Questions_Tags":{"questionId":130,"tagId":475}}]}]}},"__N_SSG":true},"page":"/questions/tag/[slug]","query":{"slug":"variable-length-array"},"buildId":"4Y8KGE-c2lolBeBmcum_I","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>