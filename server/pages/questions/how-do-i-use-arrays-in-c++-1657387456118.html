<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>How do I use arrays in C++? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="C++ inherited arrays from C where they are used virtually everywhere. C++ provides abstractions that are easier to use and less error-prone (std::vector&lt;T&gt; since C++98 and std::array&lt;T, n&gt; since C++11), so the need for arrays does not arise quite as often as it does in C. However, when you read legacy code or interact with a library written in C, you should have a firm grasp on how arrays work.
This FAQ is split into five parts:

arrays on the type level and accessing elements
array creation and initialization
assignment and parameter passing
multidimensional arrays and arrays of pointers
common pitfalls when using arrays

If you feel something important is missing in this FAQ, write an answer and link it here as an additional part.
In the following text, &quot;array&quot; means &quot;C array&quot;, not the class template std::array. Basic knowledge of the C declarator syntax is assumed. Note that the manual usage of new and delete as demonstrated below is extremely dangerous in the face of exceptions, but that is the topic of another FAQ.

(Note: This is meant to be an entry to Stack Overflow&#x27;s C++ FAQ. If you want to critique the idea of providing an FAQ in this form, then the posting on meta that started all this would be the place to do that. Answers to that question are monitored in the C++ chatroom, where the FAQ idea started out in the first place, so your answer is very likely to get read by those who came up with the idea.)
    "/><meta property="og:title" content="How do I use arrays in C++? | Solutions Checker"/><meta property="og:description" content="C++ inherited arrays from C where they are used virtually everywhere. C++ provides abstractions that are easier to use and less error-prone (std::vector&lt;T&gt; since C++98 and std::array&lt;T, n&gt; since C++11), so the need for arrays does not arise quite as often as it does in C. However, when you read legacy code or interact with a library written in C, you should have a firm grasp on how arrays work.
This FAQ is split into five parts:

arrays on the type level and accessing elements
array creation and initialization
assignment and parameter passing
multidimensional arrays and arrays of pointers
common pitfalls when using arrays

If you feel something important is missing in this FAQ, write an answer and link it here as an additional part.
In the following text, &quot;array&quot; means &quot;C array&quot;, not the class template std::array. Basic knowledge of the C declarator syntax is assumed. Note that the manual usage of new and delete as demonstrated below is extremely dangerous in the face of exceptions, but that is the topic of another FAQ.

(Note: This is meant to be an entry to Stack Overflow&#x27;s C++ FAQ. If you want to critique the idea of providing an FAQ in this form, then the posting on meta that started all this would be the place to do that. Answers to that question are monitored in the C++ chatroom, where the FAQ idea started out in the first place, so your answer is very likely to get read by those who came up with the idea.)
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"How do I use arrays in C++?","text":"C++ inherited arrays from C where they are used virtually everywhere. C++ provides abstractions that are easier to use and less error-prone (std::vector&lt;T&gt; since C++98 and std::array&lt;T, n&gt; since C++11), so the need for arrays does not arise quite as often as it does in C. However, when you read legacy code or interact with a library written in C, you should have a firm grasp on how arrays work.\nThis FAQ is split into five parts:\n\narrays on the type level and accessing elements\narray creation and initialization\nassignment and parameter passing\nmultidimensional arrays and arrays of pointers\ncommon pitfalls when using arrays\n\nIf you feel something important is missing in this FAQ, write an answer and link it here as an additional part.\nIn the following text, &quot;array&quot; means &quot;C array&quot;, not the class template std::array. Basic knowledge of the C declarator syntax is assumed. Note that the manual usage of new and delete as demonstrated below is extremely dangerous in the face of exceptions, but that is the topic of another FAQ.\n\n(Note: This is meant to be an entry to Stack Overflow&apos;s C++ FAQ. If you want to critique the idea of providing an FAQ in this form, then the posting on meta that started all this would be the place to do that. Answers to that question are monitored in the C++ chatroom, where the FAQ idea started out in the first place, so your answer is very likely to get read by those who came up with the idea.)\n    ","answerCount":5,"upVoteCount":500,"suggestedAnswer":[{"text":"Arrays on the type level\n\nAn array type is denoted as T[n] where T is the element type and n is a positive size, the number of elements in the array. The array type is a product type of the element type and the size. If one or both of those ingredients differ, you get a distinct type:\n\n#include &lt;type_traits&gt;\n\nstatic_assert(!std::is_same&lt;int[8], float[8]&gt;::value, &quot;distinct element type&quot;);\nstatic_assert(!std::is_same&lt;int[8],   int[9]&gt;::value, &quot;distinct size&quot;);\n\n\nNote that the size is part of the type, that is, array types of different size are incompatible types that have absolutely nothing to do with each other. sizeof(T[n]) is equivalent to n * sizeof(T).\n\nArray-to-pointer decay\n\nThe only &quot;connection&quot; between T[n] and T[m] is that both types can implicitly be converted to T*, and the result of this conversion is a pointer to the first element of the array. That is, anywhere a T* is required, you can provide a T[n], and the compiler will silently provide that pointer:\n\n                  +---+---+---+---+---+---+---+---+\nthe_actual_array: |   |   |   |   |   |   |   |   |   int[8]\n                  +---+---+---+---+---+---+---+---+\n                    ^\n                    |\n                    |\n                    |\n                    |  pointer_to_the_first_element   int*\n\n\nThis conversion is known as &quot;array-to-pointer decay&quot;, and it is a major source of confusion. The size of the array is lost in this process, since it is no longer part of the type (T*). Pro: Forgetting the size of an array on the type level allows a pointer to point to the first element of an array of any size. Con: Given a pointer to the first (or any other) element of an array, there is no way to detect how large that array is or where exactly the pointer points to relative to the bounds of the array. Pointers are extremely stupid.\n\nArrays are not pointers\n\nThe compiler will silently generate a pointer to the first element of an array whenever it is deemed useful, that is, whenever an operation would fail on an array but succeed on a pointer. This conversion from array to pointer is trivial, since the resulting pointer value is simply the address of the array. Note that the pointer is not stored as part of the array itself (or anywhere else in memory). An array is not a pointer.\n\nstatic_assert(!std::is_same&lt;int[8], int*&gt;::value, &quot;an array is not a pointer&quot;);\n\n\nOne important context in which an array does not decay into a pointer to its first element is when the &amp; operator is applied to it. In that case, the &amp; operator yields a pointer to the entire array, not just a pointer to its first element. Although in that case the values (the addresses) are the same, a pointer to the first element of an array and a pointer to the entire array are completely distinct types:\n\nstatic_assert(!std::is_same&lt;int*, int(*)[8]&gt;::value, &quot;distinct element type&quot;);\n\n\nThe following ASCII art explains this distinction:\n\n      +-----------------------------------+\n      | +---+---+---+---+---+---+---+---+ |\n+---&gt; | |   |   |   |   |   |   |   |   | | int[8]\n|     | +---+---+---+---+---+---+---+---+ |\n|     +---^-------------------------------+\n|         |\n|         |\n|         |\n|         |  pointer_to_the_first_element   int*\n|\n|  pointer_to_the_entire_array              int(*)[8]\n\n\nNote how the pointer to the first element only points to a single integer (depicted as a small box), whereas the pointer to the entire array points to an array of 8 integers (depicted as a large box).\n\nThe same situation arises in classes and is maybe more obvious. A pointer to an object and a pointer to its first data member have the same value (the same address), yet they are completely distinct types.\n\nIf you are unfamiliar with the C declarator syntax, the parenthesis in the type int(*)[8] are essential:\n\n\nint(*)[8] is a pointer to an array of 8 integers.\nint*[8] is an array of 8 pointers, each element of type int*.\n\n\nAccessing elements\n\nC++ provides two syntactic variations to access individual elements of an array.\nNeither of them is superior to the other, and you should familiarize yourself with both.\n\nPointer arithmetic\n\nGiven a pointer p to the first element of an array, the expression p+i yields a pointer to the i-th element of the array. By dereferencing that pointer afterwards, one can access individual elements:\n\nstd::cout &lt;&lt; *(x+3) &lt;&lt; &quot;, &quot; &lt;&lt; *(x+7) &lt;&lt; std::endl;\n\n\nIf x denotes an array, then array-to-pointer decay will kick in, because adding an array and an integer is meaningless (there is no plus operation on arrays), but adding a pointer and an integer makes sense:\n\n   +---+---+---+---+---+---+---+---+\nx: |   |   |   |   |   |   |   |   |   int[8]\n   +---+---+---+---+---+---+---+---+\n     ^           ^               ^\n     |           |               |\n     |           |               |\n     |           |               |\nx+0  |      x+3  |          x+7  |     int*\n\n\n(Note that the implicitly generated pointer has no name, so I wrote x+0 in order to identify it.)\n\nIf, on the other hand, x denotes a pointer to the first (or any other) element of an array, then array-to-pointer decay is not necessary, because the pointer on which i is going to be added already exists:\n\n   +---+---+---+---+---+---+---+---+\n   |   |   |   |   |   |   |   |   |   int[8]\n   +---+---+---+---+---+---+---+---+\n     ^           ^               ^\n     |           |               |\n     |           |               |\n   +-|-+         |               |\nx: | | |    x+3  |          x+7  |     int*\n   +---+\n\n\nNote that in the depicted case, x is a pointer variable (discernible by the small box next to x), but it could just as well be the result of a function returning a pointer (or any other expression of type T*).\n\nIndexing operator\n\nSince the syntax *(x+i) is a bit clumsy, C++ provides the alternative syntax x[i]:\n\nstd::cout &lt;&lt; x[3] &lt;&lt; &quot;, &quot; &lt;&lt; x[7] &lt;&lt; std::endl;\n\n\nDue to the fact that addition is commutative, the following code does exactly the same:\n\nstd::cout &lt;&lt; 3[x] &lt;&lt; &quot;, &quot; &lt;&lt; 7[x] &lt;&lt; std::endl;\n\n\nThe definition of the indexing operator leads to the following interesting equivalence:\n\n&amp;x[i]  ==  &amp;*(x+i)  ==  x+i\n\n\nHowever, &amp;x[0] is generally not equivalent to x. The former is a pointer, the latter an array. Only when the context triggers array-to-pointer decay can x and &amp;x[0] be used interchangeably. For example:\n\nT* p = &amp;array[0];  // rewritten as &amp;*(array+0), decay happens due to the addition\nT* q = array;      // decay happens due to the assignment\n\n\nOn the first line, the compiler detects an assignment from a pointer to a pointer, which trivially succeeds. On the second line, it detects an assignment from an array to a pointer. Since this is meaningless (but pointer to pointer assignment makes sense), array-to-pointer decay kicks in as usual.\n\nRanges\n\nAn array of type T[n] has n elements, indexed from 0 to n-1; there is no element n. And yet, to support half-open ranges (where the beginning is inclusive and the end is exclusive), C++ allows the computation of a pointer to the (non-existent) n-th element, but it is illegal to dereference that pointer:\n\n   +---+---+---+---+---+---+---+---+....\nx: |   |   |   |   |   |   |   |   |   .   int[8]\n   +---+---+---+---+---+---+---+---+....\n     ^                               ^\n     |                               |\n     |                               |\n     |                               |\nx+0  |                          x+8  |     int*\n\n\nFor example, if you want to sort an array, both of the following would work equally well:\n\nstd::sort(x + 0, x + n);\nstd::sort(&amp;x[0], &amp;x[0] + n);\n\n\nNote that it is illegal to provide &amp;x[n] as the second argument since this is equivalent to &amp;*(x+n), and the sub-expression *(x+n) technically invokes undefined behavior in C++ (but not in C99).\n\nAlso note that you could simply provide x as the first argument. That is a little too terse for my taste, and it also makes template argument deduction a bit harder for the compiler, because in that case the first argument is an array but the second argument is a pointer. (Again, array-to-pointer decay kicks in.)\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"Programmers often confuse multidimensional arrays with arrays of pointers.\n\nMultidimensional arrays\n\nMost programmers are familiar with named multidimensional arrays, but many are unaware of the fact that multidimensional array can also be created anonymously. Multidimensional arrays are often referred to as &quot;arrays of arrays&quot; or &quot;true multidimensional arrays&quot;.\n\nNamed multidimensional arrays\n\nWhen using named multidimensional arrays, all dimensions must be known at compile time:\n\nint H = read_int();\nint W = read_int();\n\nint connect_four[6][7];   // okay\n\nint connect_four[H][7];   // ISO C++ forbids variable length array\nint connect_four[6][W];   // ISO C++ forbids variable length array\nint connect_four[H][W];   // ISO C++ forbids variable length array\n\n\nThis is how a named multidimensional array looks like in memory:\n\n              +---+---+---+---+---+---+---+\nconnect_four: |   |   |   |   |   |   |   |\n              +---+---+---+---+---+---+---+\n              |   |   |   |   |   |   |   |\n              +---+---+---+---+---+---+---+\n              |   |   |   |   |   |   |   |\n              +---+---+---+---+---+---+---+\n              |   |   |   |   |   |   |   |\n              +---+---+---+---+---+---+---+\n              |   |   |   |   |   |   |   |\n              +---+---+---+---+---+---+---+\n              |   |   |   |   |   |   |   |\n              +---+---+---+---+---+---+---+\n\n\nNote that 2D grids such as the above are merely helpful visualizations. From the point of view of C++, memory is a &quot;flat&quot; sequence of bytes. The elements of a multidimensional array are stored in row-major order. That is, connect_four[0][6] and connect_four[1][0] are neighbors in memory. In fact, connect_four[0][7] and connect_four[1][0] denote the same element! This means that you can take multi-dimensional arrays and treat them as large, one-dimensional arrays:\n\nint* p = &amp;connect_four[0][0];\nint* q = p + 42;\nsome_int_sequence_algorithm(p, q);\n\n\nAnonymous multidimensional arrays\n\nWith anonymous multidimensional arrays, all dimensions except the first must be known at compile time:\n\nint (*p)[7] = new int[6][7];   // okay\nint (*p)[7] = new int[H][7];   // okay\n\nint (*p)[W] = new int[6][W];   // ISO C++ forbids variable length array\nint (*p)[W] = new int[H][W];   // ISO C++ forbids variable length array\n\n\nThis is how an anonymous multidimensional array looks like in memory:\n\n              +---+---+---+---+---+---+---+\n        +---&gt; |   |   |   |   |   |   |   |\n        |     +---+---+---+---+---+---+---+\n        |     |   |   |   |   |   |   |   |\n        |     +---+---+---+---+---+---+---+\n        |     |   |   |   |   |   |   |   |\n        |     +---+---+---+---+---+---+---+\n        |     |   |   |   |   |   |   |   |\n        |     +---+---+---+---+---+---+---+\n        |     |   |   |   |   |   |   |   |\n        |     +---+---+---+---+---+---+---+\n        |     |   |   |   |   |   |   |   |\n        |     +---+---+---+---+---+---+---+\n        |\n      +-|-+\n   p: | | |\n      +---+\n\n\nNote that the array itself is still allocated as a single block in memory.\n\nArrays of pointers\n\nYou can overcome the restriction of fixed width by introducing another level of indirection.\n\nNamed arrays of pointers\n\nHere is a named array of five pointers which are initialized with anonymous arrays of different lengths:\n\nint* triangle[5];\nfor (int i = 0; i &lt; 5; ++i)\n{\n    triangle[i] = new int[5 - i];\n}\n\n// ...\n\nfor (int i = 0; i &lt; 5; ++i)\n{\n    delete[] triangle[i];\n}\n\n\nAnd here is how it looks like in memory:\n\n          +---+---+---+---+---+\n          |   |   |   |   |   |\n          +---+---+---+---+---+\n            ^\n            | +---+---+---+---+\n            | |   |   |   |   |\n            | +---+---+---+---+\n            |   ^\n            |   | +---+---+---+\n            |   | |   |   |   |\n            |   | +---+---+---+\n            |   |   ^\n            |   |   | +---+---+\n            |   |   | |   |   |\n            |   |   | +---+---+\n            |   |   |   ^\n            |   |   |   | +---+\n            |   |   |   | |   |\n            |   |   |   | +---+\n            |   |   |   |   ^\n            |   |   |   |   |\n            |   |   |   |   |\n          +-|-+-|-+-|-+-|-+-|-+\ntriangle: | | | | | | | | | | |\n          +---+---+---+---+---+\n\n\nSince each line is allocated individually now, viewing 2D arrays as 1D arrays does not work anymore.\n\nAnonymous arrays of pointers\n\nHere is an anonymous array of 5 (or any other number of) pointers which are initialized with anonymous arrays of different lengths:\n\nint n = calculate_five();   // or any other number\nint** p = new int*[n];\nfor (int i = 0; i &lt; n; ++i)\n{\n    p[i] = new int[n - i];\n}\n\n// ...\n\nfor (int i = 0; i &lt; n; ++i)\n{\n    delete[] p[i];\n}\ndelete[] p;   // note the extra delete[] !\n\n\nAnd here is how it looks like in memory:\n\n          +---+---+---+---+---+\n          |   |   |   |   |   |\n          +---+---+---+---+---+\n            ^\n            | +---+---+---+---+\n            | |   |   |   |   |\n            | +---+---+---+---+\n            |   ^\n            |   | +---+---+---+\n            |   | |   |   |   |\n            |   | +---+---+---+\n            |   |   ^\n            |   |   | +---+---+\n            |   |   | |   |   |\n            |   |   | +---+---+\n            |   |   |   ^\n            |   |   |   | +---+\n            |   |   |   | |   |\n            |   |   |   | +---+\n            |   |   |   |   ^\n            |   |   |   |   |\n            |   |   |   |   |\n          +-|-+-|-+-|-+-|-+-|-+\n          | | | | | | | | | | |\n          +---+---+---+---+---+\n            ^\n            |\n            |\n          +-|-+\n       p: | | |\n          +---+\n\n\nConversions\n\nArray-to-pointer decay naturally extends to arrays of arrays and arrays of pointers:\n\nint array_of_arrays[6][7];\nint (*pointer_to_array)[7] = array_of_arrays;\n\nint* array_of_pointers[6];\nint** pointer_to_pointer = array_of_pointers;\n\n\nHowever, there is no implicit conversion from T[h][w] to T**. If such an implicit conversion did exist, the result would be a pointer to the first element of an array of h pointers to T (each pointing to the first element of a line in the original 2D array), but that pointer array does not exist anywhere in memory yet. If you want such a conversion, you must create and fill the required pointer array manually:\n\nint connect_four[6][7];\n\nint** p = new int*[6];\nfor (int i = 0; i &lt; 6; ++i)\n{\n    p[i] = connect_four[i];\n}\n\n// ...\n\ndelete[] p;\n\n\nNote that this generates a view of the original multidimensional array. If you need a copy instead, you must create extra arrays and copy the data yourself:\n\nint connect_four[6][7];\n\nint** p = new int*[6];\nfor (int i = 0; i &lt; 6; ++i)\n{\n    p[i] = new int[7];\n    std::copy(connect_four[i], connect_four[i + 1], p[i]);\n}\n\n// ...\n\nfor (int i = 0; i &lt; 6; ++i)\n{\n    delete[] p[i];\n}\ndelete[] p;\n\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"Assignment\n\nFor no particular reason, arrays cannot be assigned to one another. Use std::copy instead:\n\n#include &lt;algorithm&gt;\n\n// ...\n\nint a[8] = {2, 3, 5, 7, 11, 13, 17, 19};\nint b[8];\nstd::copy(a + 0, a + 8, b);\n\n\nThis is more flexible than what true array assignment could provide because it is possible to copy slices of larger arrays into smaller arrays.\nstd::copy is usually specialized for primitive types to give maximum performance. It is unlikely that std::memcpy performs better. If in doubt, measure.\n\nAlthough you cannot assign arrays directly, you can assign structs and classes which contain array members. That is because array members are copied memberwise by the assignment operator which is provided as a default by the compiler. If you define the assignment operator manually for your own struct or class types, you must fall back to manual copying for the array members.\n\nParameter passing\n\nArrays cannot be passed by value. You can either pass them by pointer or by reference.\n\nPass by pointer\n\nSince arrays themselves cannot be passed by value, usually a pointer to their first element is passed by value instead. This is often called &quot;pass by pointer&quot;. Since the size of the array is not retrievable via that pointer, you have to pass a second parameter indicating the size of the array (the classic C solution) or a second pointer pointing after the last element of the array (the C++ iterator solution):\n\n#include &lt;numeric&gt;\n#include &lt;cstddef&gt;\n\nint sum(const int* p, std::size_t n)\n{\n    return std::accumulate(p, p + n, 0);\n}\n\nint sum(const int* p, const int* q)\n{\n    return std::accumulate(p, q, 0);\n}\n\n\nAs a syntactic alternative, you can also declare parameters as T p[], and it means the exact same thing as T* p in the context of parameter lists only:\n\nint sum(const int p[], std::size_t n)\n{\n    return std::accumulate(p, p + n, 0);\n}\n\n\nYou can think of the compiler as rewriting T p[] to T *p in the context of parameter lists only. This special rule is partly responsible for the whole confusion about arrays and pointers. In every other context, declaring something as an array or as a pointer makes a huge difference.\n\nUnfortunately, you can also provide a size in an array parameter which is silently ignored by the compiler. That is, the following three signatures are exactly equivalent, as indicated by the compiler errors:\n\nint sum(const int* p, std::size_t n)\n\n// error: redefinition of &apos;int sum(const int*, size_t)&apos;\nint sum(const int p[], std::size_t n)\n\n// error: redefinition of &apos;int sum(const int*, size_t)&apos;\nint sum(const int p[8], std::size_t n)   // the 8 has no meaning here\n\n\nPass by reference\n\nArrays can also be passed by reference:\n\nint sum(const int (&amp;a)[8])\n{\n    return std::accumulate(a + 0, a + 8, 0);\n}\n\n\nIn this case, the array size is significant. Since writing a function that only accepts arrays of exactly 8 elements is of little use, programmers usually write such functions as templates:\n\ntemplate &lt;std::size_t n&gt;\nint sum(const int (&amp;a)[n])\n{\n    return std::accumulate(a + 0, a + n, 0);\n}\n\n\nNote that you can only call such a function template with an actual array of integers, not with a pointer to an integer. The size of the array is automatically inferred, and for every size n, a different function is instantiated from the template. You can also write quite useful function templates that abstract from both the element type and from the size.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"5. Common pitfalls when using arrays.\n\n5.1 Pitfall: Trusting type-unsafe linking.\n\nOK, youve been told, or have found out yourself, that globals (namespace\nscope variables that can be accessed outside the translation unit) are\nEvil. But did you know how truly Evil they are? Consider the\nprogram below, consisting of two files [main.cpp] and [numbers.cpp]:\n\n// [main.cpp]\n#include &lt;iostream&gt;\n\nextern int* numbers;\n\nint main()\n{\n    using namespace std;\n    for( int i = 0;  i &lt; 42;  ++i )\n    {\n        cout &lt;&lt; (i &gt; 0? &quot;, &quot; : &quot;&quot;) &lt;&lt; numbers[i];\n    }\n    cout &lt;&lt; endl;\n}\n\n\n\n\n// [numbers.cpp]\nint numbers[42] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n\n\nIn Windows 7 this compiles and links fine with both MinGW g++ 4.4.1 and\nVisual C++ 10.0.\n\nSince the types don&apos;t match, the program crashes when you run it.\n\n\n\nIn-the-formal explanation: the program has Undefined Behavior (UB), and instead\nof crashing it can therefore just hang, or perhaps do nothing, or it\ncan send threating e-mails to the presidents of the USA, Russia, India,\nChina and Switzerland, and make Nasal Daemons fly out of your nose.\n\nIn-practice explanation: in main.cpp the array is treated as a pointer, placed\nat the same address as the array. For 32-bit executable this means that the first\nint value in the array, is treated as a pointer. I.e., in main.cpp the\nnumbers variable contains, or appears to contain, (int*)1. This causes the\nprogram to access memory down at very bottom of the address space, which is\nconventionally reserved and trap-causing. Result: you get a crash.\n\nThe compilers are fully within their rights to not diagnose this error,\nbecause C++11 §3.5/10 says, about the requirement of compatible types\nfor the declarations,\n\n\n  [N3290 §3.5/10]\n  A violation of this rule on type identity does not require a diagnostic.\n\n\nThe same paragraph details the variation that is allowed:\n\n\n   declarations for an array object can specify array types that\n  differ by the presence or absence of a major array bound (8.3.4).\n\n\nThis allowed variation does not include declaring a name as an array in one\ntranslation unit, and as a pointer in another translation unit.    \n\n5.2 Pitfall: Doing premature optimization (memset &amp; friends).\n\nNot written yet\n\n5.3 Pitfall: Using the C idiom to get number of elements.\n\nWith deep C experience its natural to write \n\n#define N_ITEMS( array )   (sizeof( array )/sizeof( array[0] ))\n\n\nSince an array decays to pointer to first element where needed, the\nexpression sizeof(a)/sizeof(a[0]) can also be written as\nsizeof(a)/sizeof(*a). It means the same, and no matter how its\nwritten it is the C idiom for finding the number elements of array.\n\nMain pitfall: the C idiom is not typesafe. For example, the code\n\n\n#include &lt;stdio.h&gt;\n\n#define N_ITEMS( array ) (sizeof( array )/sizeof( *array ))\n\nvoid display( int const a[7] )\n{\n    int const   n = N_ITEMS( a );          // Oops.\n    printf( &quot;%d elements.\\n&quot;, n );\n}\n\nint main()\n{\n    int const   moohaha[]   = {1, 2, 3, 4, 5, 6, 7};\n\n    printf( &quot;%d elements, calling display...\\n&quot;, N_ITEMS( moohaha ) );\n    display( moohaha );\n}\n\n\npasses a pointer to N_ITEMS, and therefore most likely produces a wrong\nresult. Compiled as a 32-bit executable in Windows 7 it produces \n\n\n  7 elements, calling display...\n  1 elements.\n\n\n\nThe compiler rewrites int const a[7] to just int const a[].\nThe compiler rewrites int const a[] to int const* a.\nN_ITEMS is therefore invoked with a pointer.\nFor a 32-bit executable sizeof(array) (size of a pointer) is then 4.\nsizeof(*array) is equivalent to sizeof(int), which for a 32-bit executable is also 4.\n\n\nIn order to detect this error at run time you can do \n\n#include &lt;assert.h&gt;\n#include &lt;typeinfo&gt;\n\n#define N_ITEMS( array )       (                               \\\n    assert((                                                    \\\n        &quot;N_ITEMS requires an actual array as argument&quot;,        \\\n        typeid( array ) != typeid( &amp;*array )                    \\\n        )),                                                     \\\n    sizeof( array )/sizeof( *array )                            \\\n    )\n\n\n\n  7 elements, calling display...\n  Assertion failed: ( &quot;N_ITEMS requires an actual array as argument&quot;, typeid( a ) != typeid( &amp;*a ) ), file runtime_detect\n  ion.cpp, line 16  \n  \n  This application has requested the Runtime to terminate it in an unusual way.\n  Please contact the application&apos;s support team for more information.  \n\n\nThe runtime error detection is better than no detection, but it wastes a little\nprocessor time, and perhaps much more programmer time. Better with detection at\ncompile time! And if you&apos;re happy to not support arrays of local types with C++98,\nthen you can do that:\n\n#include &lt;stddef.h&gt;\n\ntypedef ptrdiff_t   Size;\n\ntemplate&lt; class Type, Size n &gt;\nSize n_items( Type (&amp;)[n] ) { return n; }\n\n#define N_ITEMS( array )       n_items( array )\n\n\nCompiling this definition substituted into the first complete program, with g++,\nI got \n\n\n  M:\\count&gt; g++ compile_time_detection.cpp\n  compile_time_detection.cpp: In function &apos;void display(const int*)&apos;:\n  compile_time_detection.cpp:14: error: no matching function for call to &apos;n_items(const int*&amp;)&apos;  \n  \n  M:\\count&gt; _  \n\n\nHow it works: the array is passed by reference to n_items, and so it does\nnot decay to pointer to first element, and the function can just return the\nnumber of elements specified by the type.\n\nWith C++11 you can use this also for arrays of local type, and it&apos;s the type safe\nC++ idiom for finding the number of elements of an array.\n\n5.4 C++11 &amp; C++14 pitfall: Using a constexpr array size function.\n\nWith C++11 and later it&apos;s natural, but as you&apos;ll see dangerous!, to\nreplace the C++03 function\n\ntypedef ptrdiff_t   Size;\n\ntemplate&lt; class Type, Size n &gt;\nSize n_items( Type (&amp;)[n] ) { return n; }\n\n\nwith\n\nusing Size = ptrdiff_t;\n\ntemplate&lt; class Type, Size n &gt;\nconstexpr auto n_items( Type (&amp;)[n] ) -&gt; Size { return n; }\n\n\nwhere the significant change is the use of constexpr, which allows\nthis function to produce a compile time constant.\n\nFor example, in contrast to the C++03 function, such a compile time constant\ncan be used to declare an array of the same size as another:\n\n// Example 1\nvoid foo()\n{\n    int const x[] = {3, 1, 4, 1, 5, 9, 2, 6, 5, 4};\n    constexpr Size n = n_items( x );\n    int y[n] = {};\n    // Using y here.\n}\n\n\nBut consider this code using the constexpr version:\n\n// Example 2\ntemplate&lt; class Collection &gt;\nvoid foo( Collection const&amp; c )\n{\n    constexpr int n = n_items( c );     // Not in C++14!\n    // Use c here\n}\n\nauto main() -&gt; int\n{\n    int x[42];\n    foo( x );\n}\n\n\nThe pitfall: as of July 2015 the above compiles with MinGW-64 5.1.0 with\n-pedantic-errors, and,\ntesting with the online compilers at gcc.godbolt.org/, also with clang 3.0\nand clang 3.2, but not with clang 3.3, 3.4.1, 3.5.0, 3.5.1, 3.6 (rc1) or\n3.7 (experimental). And important for the Windows platform, it does not compile\nwith Visual C++ 2015. The reason is a C++11/C++14 statement about use of\nreferences in constexpr expressions:\n\nC++11 C++14 $5.19/2 nineth dash\n\n\n  A conditional-expression e is a core constant expression unless the evaluation\n  of e, following the rules of the abstract machine (1.9), would evaluate one of the\n  following expressions:\n            \n  \n  \n  an id-expression that refers to a variable or data member of reference type\n  unless the reference has a preceding initialization and either  \n  \n  \n  it is initialized with a constant expression or  \n  it is a non-static data member of an object whose lifetime began within\n  the evaluation of e;\n  \n  \n\n\nOne can always write the more verbose\n\n// Example 3  --  limited\n\nusing Size = ptrdiff_t;\n\ntemplate&lt; class Collection &gt;\nvoid foo( Collection const&amp; c )\n{\n    constexpr Size n = std::extent&lt; decltype( c ) &gt;::value;\n    // Use c here\n}\n\n\n but this fails when Collection is not a raw array.\n\nTo deal with collections that can be non-arrays one needs the overloadability of an\nn_items function, but also, for compile time use one needs a compile time\nrepresentation of the array size. And the classic C++03 solution, which works fine\nalso in C++11 and C++14, is to let the function report its result not as a value\nbut via its function result type. For example like this:\n\n// Example 4 - OK (not ideal, but portable and safe)\n\n#include &lt;array&gt;\n#include &lt;stddef.h&gt;\n\nusing Size = ptrdiff_t;\n\ntemplate&lt; Size n &gt;\nstruct Size_carrier\n{\n    char sizer[n];\n};\n\ntemplate&lt; class Type, Size n &gt;\nauto static_n_items( Type (&amp;)[n] )\n    -&gt; Size_carrier&lt;n&gt;;\n// No implementation, is used only at compile time.\n\ntemplate&lt; class Type, size_t n &gt;        // size_t for g++\nauto static_n_items( std::array&lt;Type, n&gt; const&amp; )\n    -&gt; Size_carrier&lt;n&gt;;\n// No implementation, is used only at compile time.\n\n#define STATIC_N_ITEMS( c ) \\\n    static_cast&lt;Size&gt;( sizeof( static_n_items( c ).sizer ) )\n\ntemplate&lt; class Collection &gt;\nvoid foo( Collection const&amp; c )\n{\n    constexpr Size n = STATIC_N_ITEMS( c );\n    // Use c here\n    (void) c;\n}\n\nauto main() -&gt; int\n{\n    int x[42];\n    std::array&lt;int, 43&gt; y;\n    foo( x );\n    foo( y );\n}\n\n\nAbout the choice of return type for static_n_items: this code doesn&apos;t use std::integral_constant\nbecause with std::integral_constant the result is represented\ndirectly as a constexpr value, reintroducing the original problem. Instead\nof a Size_carrier class one can let the function directly return a\nreference to an array. However, not everybody is familiar with that syntax.\n\nAbout the naming: part of this solution to the constexpr-invalid-due-to-reference\nproblem is to make the choice of compile time constant explicit.\n\nHopefully the oops-there-was-a-reference-involved-in-your-constexpr issue will be fixed with\nC++17, but until then a macro like the STATIC_N_ITEMS above yields portability,\ne.g. to the clang and Visual C++ compilers, retaining type safety.\n\nRelated: macros do not respect scopes, so to avoid name collisions it can be a\ngood idea to use a name prefix, e.g. MYLIB_STATIC_N_ITEMS.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"Array creation and initialization\n\nAs with any other kind of C++ object, arrays can be stored either directly in named variables (then the size must be a compile-time constant; C++ does not support VLAs), or they can be stored anonymously on the heap and accessed indirectly via pointers (only then can the size be computed at runtime).\n\nAutomatic arrays\n\nAutomatic arrays (arrays living &quot;on the stack&quot;) are created each time the flow of control passes through the definition of a non-static local array variable:\n\nvoid foo()\n{\n    int automatic_array[8];\n}\n\n\nInitialization is performed in ascending order. Note that the initial values depend on the element type T:\n\n\nIf T is a POD (like int in the above example), no initialization takes place.\nOtherwise, the default-constructor of T initializes all the elements.\nIf T provides no accessible default-constructor, the program does not compile.\n\n\nAlternatively, the initial values can be explicitly specified in the array initializer, a comma-separated list surrounded by curly brackets:\n\n    int primes[8] = {2, 3, 5, 7, 11, 13, 17, 19};\n\n\nSince in this case the number of elements in the array initializer is equal to the size of the array, specifying the size manually is redundant. It can automatically be deduced by the compiler:\n\n    int primes[] = {2, 3, 5, 7, 11, 13, 17, 19};   // size 8 is deduced\n\n\nIt is also possible to specify the size and provide a shorter array initializer:\n\n    int fibonacci[50] = {0, 1, 1};   // 47 trailing zeros are deduced\n\n\nIn that case, the remaining elements are zero-initialized. Note that C++ allows an empty array initializer (all elements are zero-initialized), whereas C89 does not (at least one value is required). Also note that array initializers can only be used to initialize arrays; they cannot later be used in assignments.\n\nStatic arrays\n\nStatic arrays (arrays living &quot;in the data segment&quot;) are local array variables defined with the static keyword and array variables at namespace scope (&quot;global variables&quot;):\n\nint global_static_array[8];\n\nvoid foo()\n{\n    static int local_static_array[8];\n}\n\n\n(Note that variables at namespace scope are implicitly static. Adding the static keyword to their definition has a completely different, deprecated meaning.)\n\nHere is how static arrays behave differently from automatic arrays:\n\n\nStatic arrays without an array initializer are zero-initialized prior to any further potential initialization.\nStatic POD arrays are initialized exactly once, and the initial values are typically baked into the executable, in which case there is no initialization cost at runtime. This is not always the most space-efficient solution, however, and it is not required by the standard.\nStatic non-POD arrays are initialized the first time the flow of control passes through their definition. In the case of local static arrays, that may never happen if the function is never called.\n\n\n(None of the above is specific to arrays. These rules apply equally well to other kinds of static objects.)\n\nArray data members\n\nArray data members are created when their owning object is created. Unfortunately, C++03 provides no means to initialize arrays in the member initializer list, so initialization must be faked with assignments:\n\nclass Foo\n{\n    int primes[8];\n\npublic:\n\n    Foo()\n    {\n        primes[0] = 2;\n        primes[1] = 3;\n        primes[2] = 5;\n        // ...\n    }\n};\n\n\nAlternatively, you can define an automatic array in the constructor body and copy the elements over:\n\nclass Foo\n{\n    int primes[8];\n\npublic:\n\n    Foo()\n    {\n        int local_array[] = {2, 3, 5, 7, 11, 13, 17, 19};\n        std::copy(local_array + 0, local_array + 8, primes + 0);\n    }\n};\n\n\nIn C++0x, arrays can be initialized in the member initializer list thanks to uniform initialization:\n\nclass Foo\n{\n    int primes[8];\n\npublic:\n\n    Foo() : primes { 2, 3, 5, 7, 11, 13, 17, 19 }\n    {\n    }\n};\n\n\nThis is the only solution that works with element types that have no default constructor.\n\nDynamic arrays\n\nDynamic arrays have no names, hence the only means of accessing them is via pointers. Because they have no names, I will refer to them as &quot;anonymous arrays&quot; from now on.\n\nIn C, anonymous arrays are created via malloc and friends. In C++, anonymous arrays are created using the new T[size] syntax which returns a pointer to the first element of an anonymous array:\n\nstd::size_t size = compute_size_at_runtime();\nint* p = new int[size];\n\n\nThe following ASCII art depicts the memory layout if the size is computed as 8 at runtime:\n\n             +---+---+---+---+---+---+---+---+\n(anonymous)  |   |   |   |   |   |   |   |   |\n             +---+---+---+---+---+---+---+---+\n               ^\n               |\n               |\n             +-|-+\n          p: | | |                               int*\n             +---+\n\n\nObviously, anonymous arrays require more memory than named arrays due to the extra pointer that must be stored separately. (There is also some additional overhead on the free store.)\n\nNote that there is no array-to-pointer decay going on here. Although evaluating new int[size] does in fact create an array of integers, the result of the expression new int[size] is already a pointer to a single integer (the first element), not an array of integers or a pointer to an array of integers of unknown size. That would be impossible, because the static type system requires array sizes to be compile-time constants. (Hence, I did not annotate the anonymous array with static type information in the picture.)\n\nConcerning default values for elements, anonymous arrays behave similar to automatic arrays.\nNormally, anonymous POD arrays are not initialized, but there is a special syntax that triggers value-initialization:\n\nint* p = new int[some_computed_size]();\n\n\n(Note the trailing pair of parenthesis right before the semicolon.) Again, C++0x simplifies the rules and allows specifying initial values for anonymous arrays thanks to uniform initialization:\n\nint* p = new int[8] { 2, 3, 5, 7, 11, 13, 17, 19 };\n\n\nIf you are done using an anonymous array, you have to release it back to the system:\n\ndelete[] p;\n\n\nYou must release each anonymous array exactly once and then never touch it again afterwards. Not releasing it at all results in a memory leak (or more generally, depending on the element type, a resource leak), and trying to release it multiple times results in undefined behavior. Using the non-array form delete (or free) instead of delete[] to release the array is also undefined behavior.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-12e9794e898cd5f3.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-928c5d1eb8fb0bba.js" defer=""></script><script src="/_next/static/BnkbnjkWYxefPXjTJLVVv/_buildManifest.js" defer=""></script><script src="/_next/static/BnkbnjkWYxefPXjTJLVVv/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/how-do-i-use-arrays-in-c%2B%2B-1657387456118#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/how-do-i-use-arrays-in-c++-1657387456118"><h1>How do I use arrays in C++?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"></div></div><div class="question-content mt-5">
                
<p>C++ inherited arrays from C where they are used virtually everywhere. C++ provides abstractions that are easier to use and less error-prone (<code>std::vector&lt;T&gt;</code> since C++98 and <a href="http://en.cppreference.com/w/cpp/container/array" rel="noreferrer"><code>std::array&lt;T, n&gt;</code></a> since <a href="https://en.wikipedia.org/wiki/C++11" rel="noreferrer">C++11</a>), so the need for arrays does not arise quite as often as it does in C. However, when you read legacy code or interact with a library written in C, you should have a firm grasp on how arrays work.</p>
<p>This FAQ is split into five parts:</p>
<ol>
<li><a href="https://stackoverflow.com/questions/4810668/">arrays on the type level and accessing elements</a></li>
<li><a href="https://stackoverflow.com/questions/4984228/">array creation and initialization</a></li>
<li><a href="https://stackoverflow.com/questions/4810672/">assignment and parameter passing</a></li>
<li><a href="https://stackoverflow.com/questions/4810676/">multidimensional arrays and arrays of pointers</a></li>
<li><a href="https://stackoverflow.com/questions/4810664/how-do-i-use-arrays-in-c/7439261#7439261">common pitfalls when using arrays</a></li>
</ol>
<p>If you feel something important is missing in this FAQ, write an answer and link it here as an additional part.</p>
<p>In the following text, "array" means "C array", not the class template <code>std::array</code>. Basic knowledge of the C declarator syntax is assumed. Note that the manual usage of <code>new</code> and <code>delete</code> as demonstrated below is extremely dangerous in the face of exceptions, but that is the topic of <a href="https://stackoverflow.com/questions/712639/">another FAQ</a>.</p>
<hr>
<p><em>(Note: This is meant to be an entry to <a href="https://stackoverflow.com/questions/tagged/c++-faq">Stack Overflow's C++ FAQ</a>. If you want to critique the idea of providing an FAQ in this form, then <a href="https://meta.stackexchange.com/questions/68647/setting-up-a-faq-for-the-c-tag">the posting on meta that started all this</a> would be the place to do that. Answers to that question are monitored in the <a href="https://chat.stackoverflow.com/rooms/10/c-lounge">C++ chatroom</a>, where the FAQ idea started out in the first place, so your answer is very likely to get read by those who came up with the idea.)</em></p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>Arrays on the type level</h1>

<p>An array type is denoted as <code>T[n]</code> where <code>T</code> is the <em>element type</em> and <code>n</code> is a positive <em>size</em>, the number of elements in the array. The array type is a product type of the element type and the size. If one or both of those ingredients differ, you get a distinct type:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span>

<span class="hljs-built_in">static_assert</span>(!std::is_same&lt;<span class="hljs-type">int</span>[<span class="hljs-number">8</span>], <span class="hljs-type">float</span>[<span class="hljs-number">8</span>]&gt;::value, <span class="hljs-string">"distinct element type"</span>);
<span class="hljs-built_in">static_assert</span>(!std::is_same&lt;<span class="hljs-type">int</span>[<span class="hljs-number">8</span>],   <span class="hljs-type">int</span>[<span class="hljs-number">9</span>]&gt;::value, <span class="hljs-string">"distinct size"</span>);
</code></pre>

<p>Note that the size is part of the type, that is, array types of different size are incompatible types that have absolutely nothing to do with each other. <code>sizeof(T[n])</code> is equivalent to <code>n * sizeof(T)</code>.</p>

<h2>Array-to-pointer decay</h2>

<p>The only "connection" between <code>T[n]</code> and <code>T[m]</code> is that both types can implicitly be <em>converted</em> to <code>T*</code>, and the result of this conversion is a pointer to the first element of the array. That is, anywhere a <code>T*</code> is required, you can provide a <code>T[n]</code>, and the compiler will silently provide that pointer:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">                  +---+---+---+---+---+---+---+---+
the_actual_array: |   |   |   |   |   |   |   |   |   <span class="hljs-type">int</span>[<span class="hljs-number">8</span>]
                  +---+---+---+---+---+---+---+---+
                    ^
                    |
                    |
                    |
                    |  pointer_to_the_first_element   <span class="hljs-type">int</span>*
</code></pre>

<p>This conversion is known as "array-to-pointer decay", and it is a major source of confusion. The size of the array is lost in this process, since it is no longer part of the type (<code>T*</code>). Pro: Forgetting the size of an array on the type level allows a pointer to point to the first element of an array of <em>any</em> size. Con: Given a pointer to the first (or any other) element of an array, there is no way to detect how large that array is or where exactly the pointer points to relative to the bounds of the array. <a href="https://stackoverflow.com/questions/4261074/">Pointers are extremely stupid</a>.</p>

<h2>Arrays are not pointers</h2>

<p>The compiler will silently generate a pointer to the first element of an array whenever it is deemed useful, that is, whenever an operation would fail on an array but succeed on a pointer. This conversion from array to pointer is trivial, since the resulting pointer <em>value</em> is simply the address of the array. Note that the pointer is <em>not</em> stored as part of the array itself (or anywhere else in memory). <strong>An array is not a pointer.</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-built_in">static_assert</span>(!std::is_same&lt;<span class="hljs-type">int</span>[<span class="hljs-number">8</span>], <span class="hljs-type">int</span>*&gt;::value, <span class="hljs-string">"an array is not a pointer"</span>);
</code></pre>

<p>One important context in which an array does <em>not</em> decay into a pointer to its first element is when the <code>&amp;</code> operator is applied to it. In that case, the <code>&amp;</code> operator yields a pointer to the <em>entire</em> array, not just a pointer to its first element. Although in that case the <em>values</em> (the addresses) are the same, a pointer to the first element of an array and a pointer to the entire array are completely distinct types:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-built_in">static_assert</span>(!std::is_same&lt;<span class="hljs-type">int</span>*, <span class="hljs-built_in">int</span>(*)[<span class="hljs-number">8</span>]&gt;::value, <span class="hljs-string">"distinct element type"</span>);
</code></pre>

<p>The following ASCII art explains this distinction:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">      +-----------------------------------+
      | +---+---+---+---+---+---+---+---+ |
+---&gt; | |   |   |   |   |   |   |   |   | | <span class="hljs-type">int</span>[<span class="hljs-number">8</span>]
|     | +---+---+---+---+---+---+---+---+ |
|     +---^-------------------------------+
|         |
|         |
|         |
|         |  pointer_to_the_first_element   <span class="hljs-type">int</span>*
|
|  <span class="hljs-function">pointer_to_the_entire_array              <span class="hljs-title">int</span><span class="hljs-params">(*)</span>[8]
</span></code></pre>

<p>Note how the pointer to the first element only points to a single integer (depicted as a small box), whereas the pointer to the entire array points to an array of 8 integers (depicted as a large box).</p>

<p>The same situation arises in classes and is maybe more obvious. A pointer to an object and a pointer to its first data member have the same <em>value</em> (the same address), yet they are completely distinct types.</p>

<p>If you are unfamiliar with the C declarator syntax, the parenthesis in the type <code>int(*)[8]</code> are essential:</p>

<ul>
<li><code>int(*)[8]</code> is a pointer to an array of 8 integers.</li>
<li><code>int*[8]</code> is an array of 8 pointers, each element of type <code>int*</code>.</li>
</ul>

<h1>Accessing elements</h1>

<p>C++ provides two syntactic variations to access individual elements of an array.
Neither of them is superior to the other, and you should familiarize yourself with both.</p>

<h2>Pointer arithmetic</h2>

<p>Given a pointer <code>p</code> to the first element of an array, the expression <code>p+i</code> yields a pointer to the i-th element of the array. By dereferencing that pointer afterwards, one can access individual elements:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">std::cout &lt;&lt; *(x+<span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-string">", "</span> &lt;&lt; *(x+<span class="hljs-number">7</span>) &lt;&lt; std::endl;
</code></pre>

<p>If <code>x</code> denotes an <em>array</em>, then array-to-pointer decay will kick in, because adding an array and an integer is meaningless (there is no plus operation on arrays), but adding a pointer and an integer makes sense:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">   +---+---+---+---+---+---+---+---+
x: |   |   |   |   |   |   |   |   |   <span class="hljs-type">int</span>[<span class="hljs-number">8</span>]
   +---+---+---+---+---+---+---+---+
     ^           ^               ^
     |           |               |
     |           |               |
     |           |               |
x+<span class="hljs-number">0</span>  |      x+<span class="hljs-number">3</span>  |          x+<span class="hljs-number">7</span>  |     <span class="hljs-type">int</span>*
</code></pre>

<p>(Note that the implicitly generated pointer has no name, so I wrote <code>x+0</code> in order to identify it.)</p>

<p>If, on the other hand, <code>x</code> denotes a <em>pointer</em> to the first (or any other) element of an array, then array-to-pointer decay is not necessary, because the pointer on which <code>i</code> is going to be added already exists:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">   +---+---+---+---+---+---+---+---+
   |   |   |   |   |   |   |   |   |   <span class="hljs-type">int</span>[<span class="hljs-number">8</span>]
   +---+---+---+---+---+---+---+---+
     ^           ^               ^
     |           |               |
     |           |               |
   +-|-+         |               |
x: | | |    x+<span class="hljs-number">3</span>  |          x+<span class="hljs-number">7</span>  |     <span class="hljs-type">int</span>*
   +---+
</code></pre>

<p>Note that in the depicted case, <code>x</code> is a pointer <em>variable</em> (discernible by the small box next to <code>x</code>), but it could just as well be the result of a function returning a pointer (or any other expression of type <code>T*</code>).</p>

<h2>Indexing operator</h2>

<p>Since the syntax <code>*(x+i)</code> is a bit clumsy, C++ provides the alternative syntax <code>x[i]</code>:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">std::cout &lt;&lt; x[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-string">", "</span> &lt;&lt; x[<span class="hljs-number">7</span>] &lt;&lt; std::endl;
</code></pre>

<p>Due to the fact that addition is commutative, the following code does exactly the same:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">std::cout &lt;&lt; <span class="hljs-number">3</span>[x] &lt;&lt; <span class="hljs-string">", "</span> &lt;&lt; <span class="hljs-number">7</span>[x] &lt;&lt; std::endl;
</code></pre>

<p>The definition of the indexing operator leads to the following interesting equivalence:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">&amp;x[i]  ==  &amp;*(x+i)  ==  x+i
</code></pre>

<p>However, <code>&amp;x[0]</code> is generally <em>not</em> equivalent to <code>x</code>. The former is a pointer, the latter an array. Only when the context triggers array-to-pointer decay can <code>x</code> and <code>&amp;x[0]</code> be used interchangeably. For example:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">T* p = &amp;array[<span class="hljs-number">0</span>];  <span class="hljs-comment">// rewritten as &amp;*(array+0), decay happens due to the addition</span>
T* q = array;      <span class="hljs-comment">// decay happens due to the assignment</span>
</code></pre>

<p>On the first line, the compiler detects an assignment from a pointer to a pointer, which trivially succeeds. On the second line, it detects an assignment from an <em>array</em> to a pointer. Since this is meaningless (but <em>pointer</em> to pointer assignment makes sense), array-to-pointer decay kicks in as usual.</p>

<h2>Ranges</h2>

<p>An array of type <code>T[n]</code> has <code>n</code> elements, indexed from <code>0</code> to <code>n-1</code>; there is no element <code>n</code>. And yet, to support half-open ranges (where the beginning is <em>inclusive</em> and the end is <em>exclusive</em>), C++ allows the computation of a pointer to the (non-existent) n-th element, but it is illegal to dereference that pointer:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">   +---+---+---+---+---+---+---+---+....
x: |   |   |   |   |   |   |   |   |   .   <span class="hljs-type">int</span>[<span class="hljs-number">8</span>]
   +---+---+---+---+---+---+---+---+....
     ^                               ^
     |                               |
     |                               |
     |                               |
x+<span class="hljs-number">0</span>  |                          x+<span class="hljs-number">8</span>  |     <span class="hljs-type">int</span>*
</code></pre>

<p>For example, if you want to sort an array, both of the following would work equally well:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">std::<span class="hljs-built_in">sort</span>(x + <span class="hljs-number">0</span>, x + n);
std::<span class="hljs-built_in">sort</span>(&amp;x[<span class="hljs-number">0</span>], &amp;x[<span class="hljs-number">0</span>] + n);
</code></pre>

<p>Note that it is illegal to provide <code>&amp;x[n]</code> as the second argument since this is equivalent to <code>&amp;*(x+n)</code>, and the sub-expression <code>*(x+n)</code> technically invokes <a href="https://stackoverflow.com/questions/3144904/">undefined behavior</a> in C++ (but not in C99).</p>

<p>Also note that you could simply provide <code>x</code> as the first argument. That is a little too terse for my taste, and it also makes template argument deduction a bit harder for the compiler, because in that case the first argument is an array but the second argument is a pointer. (Again, array-to-pointer decay kicks in.)</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Programmers often confuse multidimensional arrays with arrays of pointers.</p>

<h1>Multidimensional arrays</h1>

<p>Most programmers are familiar with named multidimensional arrays, but many are unaware of the fact that multidimensional array can also be created anonymously. Multidimensional arrays are often referred to as "arrays of arrays" or "<em>true</em> multidimensional arrays".</p>

<h2>Named multidimensional arrays</h2>

<p>When using named multidimensional arrays, <em>all</em> dimensions must be known at compile time:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> H = <span class="hljs-built_in">read_int</span>();
<span class="hljs-type">int</span> W = <span class="hljs-built_in">read_int</span>();

<span class="hljs-type">int</span> connect_four[<span class="hljs-number">6</span>][<span class="hljs-number">7</span>];   <span class="hljs-comment">// okay</span>

<span class="hljs-type">int</span> connect_four[H][<span class="hljs-number">7</span>];   <span class="hljs-comment">// ISO C++ forbids variable length array</span>
<span class="hljs-type">int</span> connect_four[<span class="hljs-number">6</span>][W];   <span class="hljs-comment">// ISO C++ forbids variable length array</span>
<span class="hljs-type">int</span> connect_four[H][W];   <span class="hljs-comment">// ISO C++ forbids variable length array</span>
</code></pre>

<p>This is how a named multidimensional array looks like in memory:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">              +---+---+---+---+---+---+---+
connect_four: |   |   |   |   |   |   |   |
              +---+---+---+---+---+---+---+
              |   |   |   |   |   |   |   |
              +---+---+---+---+---+---+---+
              |   |   |   |   |   |   |   |
              +---+---+---+---+---+---+---+
              |   |   |   |   |   |   |   |
              +---+---+---+---+---+---+---+
              |   |   |   |   |   |   |   |
              +---+---+---+---+---+---+---+
              |   |   |   |   |   |   |   |
              +---+---+---+---+---+---+---+
</code></pre>

<p>Note that 2D grids such as the above are merely helpful visualizations. From the point of view of C++, memory is a "flat" sequence of bytes. The elements of a multidimensional array are stored in row-major order. That is, <code>connect_four[0][6]</code> and <code>connect_four[1][0]</code> are neighbors in memory. In fact, <code>connect_four[0][7]</code> and <code>connect_four[1][0]</code> denote the same element! This means that you can take multi-dimensional arrays and treat them as large, one-dimensional arrays:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span>* p = &amp;connect_four[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];
<span class="hljs-type">int</span>* q = p + <span class="hljs-number">42</span>;
<span class="hljs-built_in">some_int_sequence_algorithm</span>(p, q);
</code></pre>

<h2>Anonymous multidimensional arrays</h2>

<p>With anonymous multidimensional arrays, all dimensions <em>except the first</em> must be known at compile time:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-built_in">int</span> (*p)[<span class="hljs-number">7</span>] = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">6</span>][<span class="hljs-number">7</span>];   <span class="hljs-comment">// okay</span>
<span class="hljs-built_in">int</span> (*p)[<span class="hljs-number">7</span>] = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[H][<span class="hljs-number">7</span>];   <span class="hljs-comment">// okay</span>

<span class="hljs-built_in">int</span> (*p)[W] = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">6</span>][W];   <span class="hljs-comment">// ISO C++ forbids variable length array</span>
<span class="hljs-built_in">int</span> (*p)[W] = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[H][W];   <span class="hljs-comment">// ISO C++ forbids variable length array</span>
</code></pre>

<p>This is how an anonymous multidimensional array looks like in memory:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">              +---+---+---+---+---+---+---+
        +---&gt; |   |   |   |   |   |   |   |
        |     +---+---+---+---+---+---+---+
        |     |   |   |   |   |   |   |   |
        |     +---+---+---+---+---+---+---+
        |     |   |   |   |   |   |   |   |
        |     +---+---+---+---+---+---+---+
        |     |   |   |   |   |   |   |   |
        |     +---+---+---+---+---+---+---+
        |     |   |   |   |   |   |   |   |
        |     +---+---+---+---+---+---+---+
        |     |   |   |   |   |   |   |   |
        |     +---+---+---+---+---+---+---+
        |
      +-|-+
   p: | | |
      +---+
</code></pre>

<p>Note that the array itself is still allocated as a single block in memory.</p>

<h1>Arrays of pointers</h1>

<p>You can overcome the restriction of fixed width by introducing another level of indirection.</p>

<h2>Named arrays of pointers</h2>

<p>Here is a named array of five pointers which are initialized with anonymous arrays of different lengths:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span>* triangle[<span class="hljs-number">5</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i)
{
    triangle[i] = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span> - i];
}

<span class="hljs-comment">// ...</span>

<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i)
{
    <span class="hljs-keyword">delete</span>[] triangle[i];
}
</code></pre>

<p>And here is how it looks like in memory:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">          +---+---+---+---+---+
          |   |   |   |   |   |
          +---+---+---+---+---+
            ^
            | +---+---+---+---+
            | |   |   |   |   |
            | +---+---+---+---+
            |   ^
            |   | +---+---+---+
            |   | |   |   |   |
            |   | +---+---+---+
            |   |   ^
            |   |   | +---+---+
            |   |   | |   |   |
            |   |   | +---+---+
            |   |   |   ^
            |   |   |   | +---+
            |   |   |   | |   |
            |   |   |   | +---+
            |   |   |   |   ^
            |   |   |   |   |
            |   |   |   |   |
          +-|-+-|-+-|-+-|-+-|-+
triangle: | | | | | | | | | | |
          +---+---+---+---+---+
</code></pre>

<p>Since each line is allocated individually now, viewing 2D arrays as 1D arrays does not work anymore.</p>

<h2>Anonymous arrays of pointers</h2>

<p>Here is an anonymous array of 5 (or any other number of) pointers which are initialized with anonymous arrays of different lengths:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> n = <span class="hljs-built_in">calculate_five</span>();   <span class="hljs-comment">// or any other number</span>
<span class="hljs-type">int</span>** p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>*[n];
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)
{
    p[i] = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n - i];
}

<span class="hljs-comment">// ...</span>

<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)
{
    <span class="hljs-keyword">delete</span>[] p[i];
}
<span class="hljs-keyword">delete</span>[] p;   <span class="hljs-comment">// note the extra delete[] !</span>
</code></pre>

<p>And here is how it looks like in memory:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">          +---+---+---+---+---+
          |   |   |   |   |   |
          +---+---+---+---+---+
            ^
            | +---+---+---+---+
            | |   |   |   |   |
            | +---+---+---+---+
            |   ^
            |   | +---+---+---+
            |   | |   |   |   |
            |   | +---+---+---+
            |   |   ^
            |   |   | +---+---+
            |   |   | |   |   |
            |   |   | +---+---+
            |   |   |   ^
            |   |   |   | +---+
            |   |   |   | |   |
            |   |   |   | +---+
            |   |   |   |   ^
            |   |   |   |   |
            |   |   |   |   |
          +-|-+-|-+-|-+-|-+-|-+
          | | | | | | | | | | |
          +---+---+---+---+---+
            ^
            |
            |
          +-|-+
       p: | | |
          +---+
</code></pre>

<h1>Conversions</h1>

<p>Array-to-pointer decay naturally extends to arrays of arrays and arrays of pointers:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> array_of_arrays[<span class="hljs-number">6</span>][<span class="hljs-number">7</span>];
<span class="hljs-built_in">int</span> (*pointer_to_array)[<span class="hljs-number">7</span>] = array_of_arrays;

<span class="hljs-type">int</span>* array_of_pointers[<span class="hljs-number">6</span>];
<span class="hljs-type">int</span>** pointer_to_pointer = array_of_pointers;
</code></pre>

<p>However, there is no implicit conversion from <code>T[h][w]</code> to <code>T**</code>. If such an implicit conversion did exist, the result would be a pointer to the first element of an array of <code>h</code> pointers to <code>T</code> (each pointing to the first element of a line in the original 2D array), but that pointer array does not exist anywhere in memory yet. If you want such a conversion, you must create and fill the required pointer array manually:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> connect_four[<span class="hljs-number">6</span>][<span class="hljs-number">7</span>];

<span class="hljs-type">int</span>** p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>*[<span class="hljs-number">6</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; ++i)
{
    p[i] = connect_four[i];
}

<span class="hljs-comment">// ...</span>

<span class="hljs-keyword">delete</span>[] p;
</code></pre>

<p>Note that this generates a view of the original multidimensional array. If you need a copy instead, you must create extra arrays and copy the data yourself:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> connect_four[<span class="hljs-number">6</span>][<span class="hljs-number">7</span>];

<span class="hljs-type">int</span>** p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>*[<span class="hljs-number">6</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; ++i)
{
    p[i] = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">7</span>];
    std::<span class="hljs-built_in">copy</span>(connect_four[i], connect_four[i + <span class="hljs-number">1</span>], p[i]);
}

<span class="hljs-comment">// ...</span>

<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; ++i)
{
    <span class="hljs-keyword">delete</span>[] p[i];
}
<span class="hljs-keyword">delete</span>[] p;
</code></pre>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>Assignment</h1>

<p>For no particular reason, arrays cannot be assigned to one another. Use <code>std::copy</code> instead:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>

<span class="hljs-comment">// ...</span>

<span class="hljs-type">int</span> a[<span class="hljs-number">8</span>] = {<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>};
<span class="hljs-type">int</span> b[<span class="hljs-number">8</span>];
std::<span class="hljs-built_in">copy</span>(a + <span class="hljs-number">0</span>, a + <span class="hljs-number">8</span>, b);
</code></pre>

<p>This is more flexible than what true array assignment could provide because it is possible to copy slices of larger arrays into smaller arrays.
<code>std::copy</code> is usually specialized for primitive types to give maximum performance. It is unlikely that <code>std::memcpy</code> performs better. If in doubt, measure.</p>

<p>Although you cannot assign arrays directly, you <em>can</em> assign structs and classes which <em>contain</em> array members. That is because <a href="https://stackoverflow.com/questions/4164279/">array members are copied memberwise</a> by the assignment operator which is provided as a default by the compiler. If you define the assignment operator manually for your own struct or class types, you must fall back to manual copying for the array members.</p>

<h1>Parameter passing</h1>

<p>Arrays cannot be passed by value. You can either pass them by pointer or by reference.</p>

<h2>Pass by pointer</h2>

<p>Since arrays themselves cannot be passed by value, usually a pointer to their first element is passed by value instead. This is often called "pass by pointer". Since the size of the array is not retrievable via that pointer, you have to pass a second parameter indicating the size of the array (the classic C solution) or a second pointer pointing after the last element of the array (the C++ iterator solution):</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* p, std::<span class="hljs-type">size_t</span> n)</span>
</span>{
    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">accumulate</span>(p, p + n, <span class="hljs-number">0</span>);
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* p, <span class="hljs-type">const</span> <span class="hljs-type">int</span>* q)</span>
</span>{
    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">accumulate</span>(p, q, <span class="hljs-number">0</span>);
}
</code></pre>

<p>As a syntactic alternative, you can also declare parameters as <code>T p[]</code>, and it means the exact same thing as <code>T* p</code> <strong>in the context of parameter lists only</strong>:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> p[], std::<span class="hljs-type">size_t</span> n)</span>
</span>{
    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">accumulate</span>(p, p + n, <span class="hljs-number">0</span>);
}
</code></pre>

<p>You can think of the compiler as rewriting <code>T p[]</code> to <code>T *p</code> <strong>in the context of parameter lists only</strong>. This special rule is partly responsible for the whole confusion about arrays and pointers. In every other context, declaring something as an array or as a pointer makes a <em>huge</em> difference.</p>

<p>Unfortunately, you can also provide a size in an array parameter which is silently ignored by the compiler. That is, the following three signatures are exactly equivalent, as indicated by the compiler errors:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* p, std::<span class="hljs-type">size_t</span> n)</span>

<span class="hljs-comment">// error: redefinition of 'int sum(const int*, size_t)'</span>
<span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> p[], std::<span class="hljs-type">size_t</span> n)</span>

<span class="hljs-comment">// error: redefinition of 'int sum(const int*, size_t)'</span>
<span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> p[<span class="hljs-number">8</span>], std::<span class="hljs-type">size_t</span> n)</span>   <span class="hljs-comment">// the 8 has no meaning here</span>
</span></code></pre>

<h2>Pass by reference</h2>

<p>Arrays can also be passed by reference:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> (&amp;a)[<span class="hljs-number">8</span>])</span>
</span>{
    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">accumulate</span>(a + <span class="hljs-number">0</span>, a + <span class="hljs-number">8</span>, <span class="hljs-number">0</span>);
}
</code></pre>

<p>In this case, the array size is significant. Since writing a function that only accepts arrays of exactly 8 elements is of little use, programmers usually write such functions as templates:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;std::<span class="hljs-type">size_t</span> n&gt;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> (&amp;a)[n])</span>
</span>{
    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">accumulate</span>(a + <span class="hljs-number">0</span>, a + n, <span class="hljs-number">0</span>);
}
</code></pre>

<p>Note that you can only call such a function template with an actual array of integers, not with a pointer to an integer. The size of the array is automatically inferred, and for every size <code>n</code>, a different function is instantiated from the template. You can also write <a href="https://stackoverflow.com/questions/4759078/">quite useful</a> function templates that abstract from both the element type and from the size.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>5. Common pitfalls when using arrays.</h1>

<h2>5.1 Pitfall: Trusting type-unsafe linking.</h2>

<p>OK, youve been told, or have found out yourself, that globals (namespace
scope variables that can be accessed outside the translation unit) are
Evil. But did you know how truly Evil they are? Consider the
program below, consisting of two files [main.cpp] and [numbers.cpp]:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// [main.cpp]</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">extern</span> <span class="hljs-type">int</span>* numbers;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;  i &lt; <span class="hljs-number">42</span>;  ++i )
    {
        cout &lt;&lt; (i &gt; <span class="hljs-number">0</span>? <span class="hljs-string">", "</span> : <span class="hljs-string">""</span>) &lt;&lt; numbers[i];
    }
    cout &lt;&lt; endl;
}
</code></pre>

<p></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// [numbers.cpp]</span>
<span class="hljs-type">int</span> numbers[<span class="hljs-number">42</span>] = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>};
</code></pre>

<p>In Windows 7 this compiles and links fine with both MinGW g++ 4.4.1 and
Visual C++ 10.0.</p>

<p>Since the types don't match, the program crashes when you run it.</p>

<p><img src="https://i.stack.imgur.com/v7KJF.png" alt="The Windows 7 crash dialog"></p>

<p>In-the-formal explanation: the program has Undefined Behavior (UB), and instead
of crashing it can therefore just hang, or perhaps do nothing, or it
can send threating e-mails to the presidents of the USA, Russia, India,
China and Switzerland, and make Nasal Daemons fly out of your nose.</p>

<p>In-practice explanation: in <code>main.cpp</code> the array is treated as a pointer, placed
at the same address as the array. For 32-bit executable this means that the first
<code>int</code> value in the array, is treated as a pointer. I.e., in <code>main.cpp</code> the
<code>numbers</code> variable contains, or appears to contain, <code>(int*)1</code>. This causes the
program to access memory down at very bottom of the address space, which is
conventionally reserved and trap-causing. Result: you get a crash.</p>

<p>The compilers are fully within their rights to not diagnose this error,
because C++11 §3.5/10 says, about the requirement of compatible types
for the declarations,</p>

<blockquote>
  <p><strong>[N3290 §3.5/10]</strong><br>
  A violation of this rule on type identity does not require a diagnostic.</p>
</blockquote>

<p>The same paragraph details the variation that is allowed:</p>

<blockquote>
  <p> declarations for an array object can specify array types that
  differ by the presence or absence of a major array bound (8.3.4).</p>
</blockquote>

<p>This allowed variation does not include declaring a name as an array in one
translation unit, and as a pointer in another translation unit.    </p>

<h2>5.2 Pitfall: Doing premature optimization (<code>memset</code> &amp; friends).</h2>

<p><em>Not written yet</em></p>

<h2>5.3 Pitfall: Using the C idiom to get number of elements.</h2>

<p>With deep C experience its natural to write </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> N_ITEMS( array )   (sizeof( array )/sizeof( array[0] ))</span>
</code></pre>

<p>Since an <code>array</code> decays to pointer to first element where needed, the
expression <code>sizeof(a)/sizeof(a[0])</code> can also be written as
<code>sizeof(a)/sizeof(*a)</code>. It means the same, and no matter how its
written it is the <strong>C idiom</strong> for finding the number elements of array.</p>

<p>Main pitfall: the C idiom is not typesafe. For example, the code
</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> N_ITEMS( array ) (sizeof( array )/sizeof( *array ))</span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">( <span class="hljs-type">int</span> <span class="hljs-type">const</span> a[<span class="hljs-number">7</span>] )</span>
</span>{
    <span class="hljs-type">int</span> <span class="hljs-type">const</span>   n = <span class="hljs-built_in">N_ITEMS</span>( a );          <span class="hljs-comment">// Oops.</span>
    <span class="hljs-built_in">printf</span>( <span class="hljs-string">"%d elements.\n"</span>, n );
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">int</span> <span class="hljs-type">const</span>   moohaha[]   = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>};

    <span class="hljs-built_in">printf</span>( <span class="hljs-string">"%d elements, calling display...\n"</span>, <span class="hljs-built_in">N_ITEMS</span>( moohaha ) );
    <span class="hljs-built_in">display</span>( moohaha );
}
</code></pre>

<p>passes a pointer to <code>N_ITEMS</code>, and therefore most likely produces a wrong
result. Compiled as a 32-bit executable in Windows 7 it produces </p>

<blockquote>
  <p>7 elements, calling display...<br>
  1 elements.</p>
</blockquote>

<ol>
<li>The compiler rewrites <code>int const a[7]</code> to just <code>int const a[]</code>.</li>
<li>The compiler rewrites <code>int const a[]</code> to <code>int const* a</code>.</li>
<li><code>N_ITEMS</code> is therefore invoked with a pointer.</li>
<li>For a 32-bit executable <code>sizeof(array)</code> (size of a pointer) is then 4.</li>
<li><code>sizeof(*array)</code> is equivalent to <code>sizeof(int)</code>, which for a 32-bit executable is also 4.</li>
</ol>

<p>In order to detect this error at run time you can do </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> N_ITEMS( array )       (                               \
    assert((                                                    \
        <span class="hljs-string">"N_ITEMS requires an actual array as argument"</span>,        \
        typeid( array ) != typeid( &amp;*array )                    \
        )),                                                     \
    sizeof( array )/sizeof( *array )                            \
    )</span>
</code></pre>

<blockquote>
  <p>7 elements, calling display...<br>
  Assertion failed: ( "N_ITEMS requires an actual array as argument", typeid( a ) != typeid( &amp;*a ) ), file runtime_detect
  ion.cpp, line 16  </p>
  
  <p>This application has requested the Runtime to terminate it in an unusual way.<br>
  Please contact the application's support team for more information.  </p>
</blockquote>

<p>The runtime error detection is better than no detection, but it wastes a little
processor time, and perhaps much more programmer time. Better with detection at
compile time! And if you're happy to not support arrays of local types with C++98,
then you can do that:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stddef.h&gt;</span></span>

<span class="hljs-keyword">typedef</span> <span class="hljs-type">ptrdiff_t</span>   Size;

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> Type, Size n &gt;
Size <span class="hljs-title">n_items</span><span class="hljs-params">( Type (&amp;)[n] )</span> </span>{ <span class="hljs-keyword">return</span> n; }

<span class="hljs-meta">#<span class="hljs-keyword">define</span> N_ITEMS( array )       n_items( array )</span>
</code></pre>

<p>Compiling this definition substituted into the first complete program, with g++,
I got </p>

<blockquote>
  <p>M:\count&gt; g++ compile_time_detection.cpp<br>
  compile_time_detection.cpp: In function 'void display(const int*)':<br>
  compile_time_detection.cpp:14: error: no matching function for call to 'n_items(const int*&amp;)'  </p>
  
  <p>M:\count&gt; _  </p>
</blockquote>

<p>How it works: the array is passed <em>by reference</em> to <code>n_items</code>, and so it does
not decay to pointer to first element, and the function can just return the
number of elements specified by the type.</p>

<p>With C++11 you can use this also for arrays of local type, and it's the type safe
<strong>C++ idiom</strong> for finding the number of elements of an array.</p>

<h2>5.4 C++11 &amp; C++14 pitfall: Using a <code>constexpr</code> array size function.</h2>

<p>With C++11 and later it's natural, but as you'll see dangerous!, to
replace the C++03 function</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">ptrdiff_t</span>   Size;

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> Type, Size n &gt;
Size <span class="hljs-title">n_items</span><span class="hljs-params">( Type (&amp;)[n] )</span> </span>{ <span class="hljs-keyword">return</span> n; }
</code></pre>

<p>with</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">using</span> Size = <span class="hljs-type">ptrdiff_t</span>;

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> Type, Size n &gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">n_items</span><span class="hljs-params">( Type (&amp;)[n] )</span> -&gt; Size </span>{ <span class="hljs-keyword">return</span> n; }
</code></pre>

<p>where the significant change is the use of <code>constexpr</code>, which allows
this function to produce a <strong>compile time constant</strong>.</p>

<p>For example, in contrast to the C++03 function, such a compile time constant
can be used to declare an array of the same size as another:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// Example 1</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">int</span> <span class="hljs-type">const</span> x[] = {<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>};
    <span class="hljs-keyword">constexpr</span> Size n = <span class="hljs-built_in">n_items</span>( x );
    <span class="hljs-type">int</span> y[n] = {};
    <span class="hljs-comment">// Using y here.</span>
}
</code></pre>

<p>But consider this code using the <code>constexpr</code> version:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// Example 2</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> Collection &gt;
<span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">( Collection <span class="hljs-type">const</span>&amp; c )</span>
</span>{
    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> n = <span class="hljs-built_in">n_items</span>( c );     <span class="hljs-comment">// Not in C++14!</span>
    <span class="hljs-comment">// Use c here</span>
}

<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">int</span>
</span>{
    <span class="hljs-type">int</span> x[<span class="hljs-number">42</span>];
    <span class="hljs-built_in">foo</span>( x );
}
</code></pre>

<p>The pitfall: as of July 2015 the above compiles with MinGW-64 5.1.0 with
<code>-pedantic-errors</code>, and,
testing with the online compilers at <a href="http://gcc.godbolt.org/" rel="noreferrer">gcc.godbolt.org/</a>, also with clang 3.0
and clang 3.2, but not with clang 3.3, 3.4.1, 3.5.0, 3.5.1, 3.6 (rc1) or
3.7 (experimental). And important for the Windows platform, it does not compile
with Visual C++ 2015. The reason is a C++11/C++14 statement about use of
references in <code>constexpr</code> expressions:</p>

C++11 C++14 $5.19/2 nine<sup><i>th</i></sup> dash

<blockquote>
  <p>A <em>conditional-expression</em> <code>e</code> is a <em>core constant expression</em> unless the evaluation
  of <code>e</code>, following the rules of the abstract machine (1.9), would evaluate one of the
  following expressions:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </p>
  
  <ul>
  <li>an <em>id-expression</em> that refers to a variable or data member of reference type
  unless the reference has a preceding initialization and either  
  
  <ul>
  <li>it is initialized with a constant expression or  </li>
  <li>it is a non-static data member of an object whose lifetime began within
  the evaluation of e;</li>
  </ul></li>
  </ul>
</blockquote>

<p>One can always write the more verbose</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// Example 3  --  limited</span>

<span class="hljs-keyword">using</span> Size = <span class="hljs-type">ptrdiff_t</span>;

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> Collection &gt;
<span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">( Collection <span class="hljs-type">const</span>&amp; c )</span>
</span>{
    <span class="hljs-keyword">constexpr</span> Size n = std::extent&lt; <span class="hljs-keyword">decltype</span>( c ) &gt;::value;
    <span class="hljs-comment">// Use c here</span>
}
</code></pre>

<p> but this fails when <code>Collection</code> is not a raw array.</p>

<p>To deal with collections that can be non-arrays one needs the overloadability of an
<code>n_items</code> function, but also, for compile time use one needs a compile time
representation of the array size. And the classic C++03 solution, which works fine
also in C++11 and C++14, is to let the function report its result not as a value
but via its function result <em>type</em>. For example like this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// Example 4 - OK (not ideal, but portable and safe)</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stddef.h&gt;</span></span>

<span class="hljs-keyword">using</span> Size = <span class="hljs-type">ptrdiff_t</span>;

<span class="hljs-keyword">template</span>&lt; Size n &gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Size_carrier</span>
{
    <span class="hljs-type">char</span> sizer[n];
};

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> Type, Size n &gt;
<span class="hljs-keyword">auto</span> <span class="hljs-title">static_n_items</span><span class="hljs-params">( Type (&amp;)[n] )</span>
    -&gt; Size_carrier&lt;n&gt;</span>;
<span class="hljs-comment">// No implementation, is used only at compile time.</span>

<span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>, <span class="hljs-type">size_t</span> n &gt;        <span class="hljs-comment">// size_t for g++</span>
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">static_n_items</span><span class="hljs-params">( std::array&lt;Type, n&gt; <span class="hljs-type">const</span>&amp; )</span>
    -&gt; Size_carrier&lt;n&gt;</span>;
<span class="hljs-comment">// No implementation, is used only at compile time.</span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> STATIC_N_ITEMS( c ) \
    static_cast<span class="hljs-string">&lt;Size&gt;</span>( sizeof( static_n_items( c ).sizer ) )</span>

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> Collection &gt;
<span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">( Collection <span class="hljs-type">const</span>&amp; c )</span>
</span>{
    <span class="hljs-keyword">constexpr</span> Size n = <span class="hljs-built_in">STATIC_N_ITEMS</span>( c );
    <span class="hljs-comment">// Use c here</span>
    (<span class="hljs-type">void</span>) c;
}

<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">int</span>
</span>{
    <span class="hljs-type">int</span> x[<span class="hljs-number">42</span>];
    std::array&lt;<span class="hljs-type">int</span>, 43&gt; y;
    <span class="hljs-built_in">foo</span>( x );
    <span class="hljs-built_in">foo</span>( y );
}
</code></pre>

<p>About the choice of return type for <code>static_n_items</code>: this code doesn't use <code>std::integral_constant</code>
because with <code>std::integral_constant</code> the result is represented
directly as a <code>constexpr</code> value, reintroducing the original problem. Instead
of a <code>Size_carrier</code> class one can let the function directly return a
reference to an array. However, not everybody is familiar with that syntax.</p>

<p>About the naming: part of this solution to the <code>constexpr</code>-invalid-due-to-reference
problem is to make the choice of compile time constant explicit.</p>

<p>Hopefully the oops-there-was-a-reference-involved-in-your-<code>constexpr</code> issue will be fixed with
C++17, but until then a macro like the <code>STATIC_N_ITEMS</code> above yields portability,
e.g. to the clang and Visual C++ compilers, retaining type safety.</p>

<p>Related: macros do not respect scopes, so to avoid name collisions it can be a
good idea to use a name prefix, e.g. <code>MYLIB_STATIC_N_ITEMS</code>.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>Array creation and initialization</h1>

<p>As with any other kind of C++ object, arrays can be stored either directly in named variables (then the size must be a compile-time constant; <a href="https://stackoverflow.com/questions/1887097/">C++ does not support VLAs</a>), or they can be stored anonymously on the heap and accessed indirectly via pointers (only then can the size be computed at runtime).</p>

<h2>Automatic arrays</h2>

<p>Automatic arrays (arrays living "on the stack") are created each time the flow of control passes through the definition of a non-static local array variable:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">int</span> automatic_array[<span class="hljs-number">8</span>];
}
</code></pre>

<p>Initialization is performed in ascending order. Note that the initial values depend on the element type <code>T</code>:</p>

<ul>
<li>If <code>T</code> is a <a href="https://stackoverflow.com/questions/146589/">POD</a> (like <code>int</code> in the above example), no initialization takes place.</li>
<li>Otherwise, the default-constructor of <code>T</code> initializes all the elements.</li>
<li>If <code>T</code> provides no accessible default-constructor, the program does not compile.</li>
</ul>

<p>Alternatively, the initial values can be explicitly specified in the <em>array initializer</em>, a comma-separated list surrounded by curly brackets:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">    <span class="hljs-type">int</span> primes[<span class="hljs-number">8</span>] = {<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>};
</code></pre>

<p>Since in this case the number of elements in the array initializer is equal to the size of the array, specifying the size manually is redundant. It can automatically be deduced by the compiler:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">    <span class="hljs-type">int</span> primes[] = {<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>};   <span class="hljs-comment">// size 8 is deduced</span>
</code></pre>

<p>It is also possible to specify the size and provide a shorter array initializer:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">    <span class="hljs-type">int</span> fibonacci[<span class="hljs-number">50</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>};   <span class="hljs-comment">// 47 trailing zeros are deduced</span>
</code></pre>

<p>In that case, the remaining elements are <a href="https://stackoverflow.com/questions/1613383/">zero-initialized</a>. Note that C++ allows an empty array initializer (all elements are zero-initialized), whereas C89 does not (at least one value is required). Also note that array initializers can only be used to <em>initialize</em> arrays; they cannot later be used in assignments.</p>

<h2>Static arrays</h2>

<p>Static arrays (arrays living "in the data segment") are local array variables defined with the <code>static</code> keyword and array variables at namespace scope ("global variables"):</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> global_static_array[<span class="hljs-number">8</span>];

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">static</span> <span class="hljs-type">int</span> local_static_array[<span class="hljs-number">8</span>];
}
</code></pre>

<p>(Note that variables at namespace scope are implicitly static. Adding the <code>static</code> keyword to their definition has a <a href="https://stackoverflow.com/questions/3891325/">completely different, deprecated meaning</a>.)</p>

<p>Here is how static arrays behave differently from automatic arrays:</p>

<ul>
<li>Static arrays without an array initializer are zero-initialized prior to any further potential initialization.</li>
<li>Static POD arrays are initialized <em>exactly once</em>, and the initial values are <em>typically</em> baked into the executable, in which case there is no initialization cost at runtime. This is not always the most space-efficient solution, however, and it is not required by the standard.</li>
<li>Static non-POD arrays are initialized the <em>first time</em> the flow of control passes through their definition. In the case of local static arrays, that may never happen if the function is never called.</li>
</ul>

<p>(None of the above is specific to arrays. These rules apply equally well to other kinds of static objects.)</p>

<h2>Array data members</h2>

<p>Array data members are created when their owning object is created. Unfortunately, C++03 provides no means to initialize arrays in the <a href="https://stackoverflow.com/questions/1711990/">member initializer list</a>, so initialization must be faked with assignments:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>
{
    <span class="hljs-type">int</span> primes[<span class="hljs-number">8</span>];

<span class="hljs-keyword">public</span>:

    <span class="hljs-built_in">Foo</span>()
    {
        primes[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>;
        primes[<span class="hljs-number">1</span>] = <span class="hljs-number">3</span>;
        primes[<span class="hljs-number">2</span>] = <span class="hljs-number">5</span>;
        <span class="hljs-comment">// ...</span>
    }
};
</code></pre>

<p>Alternatively, you can define an automatic array in the constructor body and copy the elements over:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>
{
    <span class="hljs-type">int</span> primes[<span class="hljs-number">8</span>];

<span class="hljs-keyword">public</span>:

    <span class="hljs-built_in">Foo</span>()
    {
        <span class="hljs-type">int</span> local_array[] = {<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>};
        std::<span class="hljs-built_in">copy</span>(local_array + <span class="hljs-number">0</span>, local_array + <span class="hljs-number">8</span>, primes + <span class="hljs-number">0</span>);
    }
};
</code></pre>

<p>In C++0x, arrays <em>can</em> be initialized in the member initializer list thanks to <a href="http://www.youtube.com/watch?v=uEqknlxXJfg" rel="noreferrer">uniform initialization</a>:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>
{
    <span class="hljs-type">int</span> primes[<span class="hljs-number">8</span>];

<span class="hljs-keyword">public</span>:

    <span class="hljs-built_in">Foo</span>() : primes { <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span> }
    {
    }
};
</code></pre>

<p>This is the only solution that works with element types that have no default constructor.</p>

<h2>Dynamic arrays</h2>

<p>Dynamic arrays have no names, hence the only means of accessing them is via pointers. Because they have no names, I will refer to them as "anonymous arrays" from now on.</p>

<p>In C, anonymous arrays are created via <code>malloc</code> and friends. In C++, anonymous arrays are created using the <code>new T[size]</code> syntax which returns a pointer to the first element of an anonymous array:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">std::<span class="hljs-type">size_t</span> size = <span class="hljs-built_in">compute_size_at_runtime</span>();
<span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size];
</code></pre>

<p>The following ASCII art depicts the memory layout if the size is computed as 8 at runtime:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">             +---+---+---+---+---+---+---+---+
(anonymous)  |   |   |   |   |   |   |   |   |
             +---+---+---+---+---+---+---+---+
               ^
               |
               |
             +-|-+
          p: | | |                               <span class="hljs-type">int</span>*
             +---+
</code></pre>

<p>Obviously, anonymous arrays require more memory than named arrays due to the extra pointer that must be stored separately. (There is also some additional overhead on the free store.)</p>

<p>Note that there is <em>no</em> array-to-pointer decay going on here. Although evaluating <code>new int[size]</code> does in fact create an <em>array</em> of integers, the result of the expression <code>new int[size]</code> is <em>already</em> a pointer to a single integer (the first element), <em>not</em> an array of integers or a pointer to an array of integers of unknown size. That would be impossible, because the static type system requires array sizes to be compile-time constants. (Hence, I did not annotate the anonymous array with static type information in the picture.)</p>

<p>Concerning default values for elements, anonymous arrays behave similar to automatic arrays.
Normally, anonymous POD arrays are not initialized, but there is a <a href="https://stackoverflow.com/questions/620137/">special syntax</a> that triggers value-initialization:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[some_computed_size]();
</code></pre>

<p>(Note the trailing pair of parenthesis right before the semicolon.) Again, C++0x simplifies the rules and allows specifying initial values for anonymous arrays thanks to uniform initialization:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">8</span>] { <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span> };
</code></pre>

<p>If you are done using an anonymous array, you have to release it back to the system:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">delete</span>[] p;
</code></pre>

<p>You must release each anonymous array exactly once and then never touch it again afterwards. Not releasing it at all results in a memory leak (or more generally, depending on the element type, a resource leak), and trying to release it multiple times results in undefined behavior. Using the non-array form <code>delete</code> (or <code>free</code>) instead of <code>delete[]</code> to release the array is also <a href="https://stackoverflow.com/questions/1612031/">undefined behavior</a>.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/how-do-you-parse-and-process-htmlxml-in-php-1657384351267">How do you parse and process HTML/XML in PHP?</a><a href="/questions/how-to-format-numbers-as-currency-strings-1657388399166">How to format numbers as currency strings</a><a href="/questions/how-can-i-upload-files-to-a-server-using-jspservlet-1657384847658">How can I upload files to a server using JSP/Servlet?</a><a href="/questions/sql-select-only-rows-with-max-value-on-a-column-duplicate-1657384614292">SQL select only rows with max value on a column [duplicate]</a><a href="/questions/what-does-**-(double-starasterisk)-and-*-(starasterisk)-do-for-parameters-1657384800967">What does ** (double star/asterisk) and * (star/asterisk) do for parameters?</a><a href="/questions/what-is-this-weird-colon-member-(%22-:-%22)-syntax-in-the-constructor-1657387264047">What is this weird colon-member (&quot; : &quot;) syntax in the constructor?</a><a href="/questions/how-to-avoid-using-select-in-excel-vba-1657384286300">How to avoid using Select in Excel VBA</a><a href="/questions/how-to-use-sharedpreferences-in-android-to-store-fetch-and-edit-values-closed-1657387683057">How to use SharedPreferences in Android to store, fetch and edit values [closed]</a><a href="/questions/when-to-use-virtual-destructors-1657388152135">When to use virtual destructors?</a><a href="/questions/what-is-the-scope-of-variables-in-javascript-1657384464291">What is the scope of variables in JavaScript?</a><a href="/questions/maintain-the-aspect-ratio-of-a-div-with-css-1657387513615">Maintain the aspect ratio of a div with CSS</a><a href="/questions/how-can-i-vertically-align-elements-in-a-div-1657385504431">How can I vertically align elements in a div?</a><a href="/questions/why-does-std::getline()-skip-input-after-a-formatted-extraction-1657384756118">Why does std::getline() skip input after a formatted extraction?</a><a href="/questions/how-do-i-redirect-to-another-webpage-1657384869767">How do I redirect to another webpage?</a><a href="/questions/int-division:-why-is-the-result-of-13-0-1657387547814">Int division: Why is the result of 1/3 == 0?</a><a href="/questions/can-i-mix-mysql-apis-in-php-1657384597444">Can I mix MySQL APIs in PHP?</a><a href="/questions/%22cross-origin-requests-are-only-supported-for-http.%22-error-when-loading-a-local-file-1657387942403">&quot;Cross origin requests are only supported for HTTP.&quot; error when loading a local file</a><a href="/questions/why-is-my-variable-unaltered-after-i-modify-it-inside-of-a-function-asynchronous-code-reference-1657384288966">Why is my variable unaltered after I modify it inside of a function? - Asynchronous code reference</a><a href="/questions/difference-between-sh-and-bash-1657388197713">Difference between sh and Bash</a><a href="/questions/using-i-and-j-as-variables-in-matlab-1657388506358">Using i and j as variables in MATLAB</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;h1\u0026gt;Arrays on the type level\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;An array type is denoted as \u0026lt;code\u0026gt;T[n]\u0026lt;/code\u0026gt; where \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; is the \u0026lt;em\u0026gt;element type\u0026lt;/em\u0026gt; and \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt; is a positive \u0026lt;em\u0026gt;size\u0026lt;/em\u0026gt;, the number of elements in the array. The array type is a product type of the element type and the size. If one or both of those ingredients differ, you get a distinct type:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;type_traits\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(!std::is_same\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;], \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;]\u0026amp;gt;::value, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;distinct element type\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(!std::is_same\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;],   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt;]\u0026amp;gt;::value, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;distinct size\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that the size is part of the type, that is, array types of different size are incompatible types that have absolutely nothing to do with each other. \u0026lt;code\u0026gt;sizeof(T[n])\u0026lt;/code\u0026gt; is equivalent to \u0026lt;code\u0026gt;n * sizeof(T)\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Array-to-pointer decay\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The only \u0026quot;connection\u0026quot; between \u0026lt;code\u0026gt;T[n]\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;T[m]\u0026lt;/code\u0026gt; is that both types can implicitly be \u0026lt;em\u0026gt;converted\u0026lt;/em\u0026gt; to \u0026lt;code\u0026gt;T*\u0026lt;/code\u0026gt;, and the result of this conversion is a pointer to the first element of the array. That is, anywhere a \u0026lt;code\u0026gt;T*\u0026lt;/code\u0026gt; is required, you can provide a \u0026lt;code\u0026gt;T[n]\u0026lt;/code\u0026gt;, and the compiler will silently provide that pointer:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;                  +---+---+---+---+---+---+---+---+\nthe_actual_array: |   |   |   |   |   |   |   |   |   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;]\n                  +---+---+---+---+---+---+---+---+\n                    ^\n                    |\n                    |\n                    |\n                    |  pointer_to_the_first_element   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;*\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This conversion is known as \u0026quot;array-to-pointer decay\u0026quot;, and it is a major source of confusion. The size of the array is lost in this process, since it is no longer part of the type (\u0026lt;code\u0026gt;T*\u0026lt;/code\u0026gt;). Pro: Forgetting the size of an array on the type level allows a pointer to point to the first element of an array of \u0026lt;em\u0026gt;any\u0026lt;/em\u0026gt; size. Con: Given a pointer to the first (or any other) element of an array, there is no way to detect how large that array is or where exactly the pointer points to relative to the bounds of the array. \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/4261074/\u0026quot;\u0026gt;Pointers are extremely stupid\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Arrays are not pointers\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The compiler will silently generate a pointer to the first element of an array whenever it is deemed useful, that is, whenever an operation would fail on an array but succeed on a pointer. This conversion from array to pointer is trivial, since the resulting pointer \u0026lt;em\u0026gt;value\u0026lt;/em\u0026gt; is simply the address of the array. Note that the pointer is \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; stored as part of the array itself (or anywhere else in memory). \u0026lt;strong\u0026gt;An array is not a pointer.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(!std::is_same\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;], \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;*\u0026amp;gt;::value, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;an array is not a pointer\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;One important context in which an array does \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; decay into a pointer to its first element is when the \u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt; operator is applied to it. In that case, the \u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt; operator yields a pointer to the \u0026lt;em\u0026gt;entire\u0026lt;/em\u0026gt; array, not just a pointer to its first element. Although in that case the \u0026lt;em\u0026gt;values\u0026lt;/em\u0026gt; (the addresses) are the same, a pointer to the first element of an array and a pointer to the entire array are completely distinct types:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(!std::is_same\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;*, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;(*)[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;]\u0026amp;gt;::value, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;distinct element type\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The following ASCII art explains this distinction:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;      +-----------------------------------+\n      | +---+---+---+---+---+---+---+---+ |\n+---\u0026amp;gt; | |   |   |   |   |   |   |   |   | | \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;]\n|     | +---+---+---+---+---+---+---+---+ |\n|     +---^-------------------------------+\n|         |\n|         |\n|         |\n|         |  pointer_to_the_first_element   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;*\n|\n|  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;pointer_to_the_entire_array              \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(*)\u0026lt;/span\u0026gt;[8]\n\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note how the pointer to the first element only points to a single integer (depicted as a small box), whereas the pointer to the entire array points to an array of 8 integers (depicted as a large box).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The same situation arises in classes and is maybe more obvious. A pointer to an object and a pointer to its first data member have the same \u0026lt;em\u0026gt;value\u0026lt;/em\u0026gt; (the same address), yet they are completely distinct types.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you are unfamiliar with the C declarator syntax, the parenthesis in the type \u0026lt;code\u0026gt;int(*)[8]\u0026lt;/code\u0026gt; are essential:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;int(*)[8]\u0026lt;/code\u0026gt; is a pointer to an array of 8 integers.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;int*[8]\u0026lt;/code\u0026gt; is an array of 8 pointers, each element of type \u0026lt;code\u0026gt;int*\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;h1\u0026gt;Accessing elements\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;C++ provides two syntactic variations to access individual elements of an array.\nNeither of them is superior to the other, and you should familiarize yourself with both.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Pointer arithmetic\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Given a pointer \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt; to the first element of an array, the expression \u0026lt;code\u0026gt;p+i\u0026lt;/code\u0026gt; yields a pointer to the i-th element of the array. By dereferencing that pointer afterwards, one can access individual elements:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;std::cout \u0026amp;lt;\u0026amp;lt; *(x+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;) \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;, \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; *(x+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;) \u0026amp;lt;\u0026amp;lt; std::endl;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; denotes an \u0026lt;em\u0026gt;array\u0026lt;/em\u0026gt;, then array-to-pointer decay will kick in, because adding an array and an integer is meaningless (there is no plus operation on arrays), but adding a pointer and an integer makes sense:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;   +---+---+---+---+---+---+---+---+\nx: |   |   |   |   |   |   |   |   |   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;]\n   +---+---+---+---+---+---+---+---+\n     ^           ^               ^\n     |           |               |\n     |           |               |\n     |           |               |\nx+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;  |      x+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;  |          x+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;  |     \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;*\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;(Note that the implicitly generated pointer has no name, so I wrote \u0026lt;code\u0026gt;x+0\u0026lt;/code\u0026gt; in order to identify it.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If, on the other hand, \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; denotes a \u0026lt;em\u0026gt;pointer\u0026lt;/em\u0026gt; to the first (or any other) element of an array, then array-to-pointer decay is not necessary, because the pointer on which \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; is going to be added already exists:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;   +---+---+---+---+---+---+---+---+\n   |   |   |   |   |   |   |   |   |   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;]\n   +---+---+---+---+---+---+---+---+\n     ^           ^               ^\n     |           |               |\n     |           |               |\n   +-|-+         |               |\nx: | | |    x+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;  |          x+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;  |     \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;*\n   +---+\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that in the depicted case, \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; is a pointer \u0026lt;em\u0026gt;variable\u0026lt;/em\u0026gt; (discernible by the small box next to \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;), but it could just as well be the result of a function returning a pointer (or any other expression of type \u0026lt;code\u0026gt;T*\u0026lt;/code\u0026gt;).\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Indexing operator\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Since the syntax \u0026lt;code\u0026gt;*(x+i)\u0026lt;/code\u0026gt; is a bit clumsy, C++ provides the alternative syntax \u0026lt;code\u0026gt;x[i]\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;std::cout \u0026amp;lt;\u0026amp;lt; x[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;, \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; x[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;] \u0026amp;lt;\u0026amp;lt; std::endl;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Due to the fact that addition is commutative, the following code does exactly the same:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;[x] \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;, \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;[x] \u0026amp;lt;\u0026amp;lt; std::endl;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The definition of the indexing operator leads to the following interesting equivalence:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026amp;amp;x[i]  ==  \u0026amp;amp;*(x+i)  ==  x+i\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;However, \u0026lt;code\u0026gt;\u0026amp;amp;x[0]\u0026lt;/code\u0026gt; is generally \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; equivalent to \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;. The former is a pointer, the latter an array. Only when the context triggers array-to-pointer decay can \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;\u0026amp;amp;x[0]\u0026lt;/code\u0026gt; be used interchangeably. For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;T* p = \u0026amp;amp;array[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;];  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// rewritten as \u0026amp;amp;*(array+0), decay happens due to the addition\u0026lt;/span\u0026gt;\nT* q = array;      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// decay happens due to the assignment\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;On the first line, the compiler detects an assignment from a pointer to a pointer, which trivially succeeds. On the second line, it detects an assignment from an \u0026lt;em\u0026gt;array\u0026lt;/em\u0026gt; to a pointer. Since this is meaningless (but \u0026lt;em\u0026gt;pointer\u0026lt;/em\u0026gt; to pointer assignment makes sense), array-to-pointer decay kicks in as usual.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Ranges\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;An array of type \u0026lt;code\u0026gt;T[n]\u0026lt;/code\u0026gt; has \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt; elements, indexed from \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;n-1\u0026lt;/code\u0026gt;; there is no element \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt;. And yet, to support half-open ranges (where the beginning is \u0026lt;em\u0026gt;inclusive\u0026lt;/em\u0026gt; and the end is \u0026lt;em\u0026gt;exclusive\u0026lt;/em\u0026gt;), C++ allows the computation of a pointer to the (non-existent) n-th element, but it is illegal to dereference that pointer:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;   +---+---+---+---+---+---+---+---+....\nx: |   |   |   |   |   |   |   |   |   .   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;]\n   +---+---+---+---+---+---+---+---+....\n     ^                               ^\n     |                               |\n     |                               |\n     |                               |\nx+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;  |                          x+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;  |     \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;*\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;For example, if you want to sort an array, both of the following would work equally well:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sort\u0026lt;/span\u0026gt;(x + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, x + n);\nstd::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sort\u0026lt;/span\u0026gt;(\u0026amp;amp;x[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;], \u0026amp;amp;x[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] + n);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that it is illegal to provide \u0026lt;code\u0026gt;\u0026amp;amp;x[n]\u0026lt;/code\u0026gt; as the second argument since this is equivalent to \u0026lt;code\u0026gt;\u0026amp;amp;*(x+n)\u0026lt;/code\u0026gt;, and the sub-expression \u0026lt;code\u0026gt;*(x+n)\u0026lt;/code\u0026gt; technically invokes \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/3144904/\u0026quot;\u0026gt;undefined behavior\u0026lt;/a\u0026gt; in C++ (but not in C99).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Also note that you could simply provide \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; as the first argument. That is a little too terse for my taste, and it also makes template argument deduction a bit harder for the compiler, because in that case the first argument is an array but the second argument is a pointer. (Again, array-to-pointer decay kicks in.)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Programmers often confuse multidimensional arrays with arrays of pointers.\u0026lt;/p\u0026gt;\n\n\u0026lt;h1\u0026gt;Multidimensional arrays\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;Most programmers are familiar with named multidimensional arrays, but many are unaware of the fact that multidimensional array can also be created anonymously. Multidimensional arrays are often referred to as \u0026quot;arrays of arrays\u0026quot; or \u0026quot;\u0026lt;em\u0026gt;true\u0026lt;/em\u0026gt; multidimensional arrays\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Named multidimensional arrays\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;When using named multidimensional arrays, \u0026lt;em\u0026gt;all\u0026lt;/em\u0026gt; dimensions must be known at compile time:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; H = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read_int\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; W = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read_int\u0026lt;/span\u0026gt;();\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; connect_four[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;][\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;];   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// okay\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; connect_four[H][\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;];   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ISO C++ forbids variable length array\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; connect_four[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;][W];   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ISO C++ forbids variable length array\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; connect_four[H][W];   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ISO C++ forbids variable length array\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This is how a named multidimensional array looks like in memory:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;              +---+---+---+---+---+---+---+\nconnect_four: |   |   |   |   |   |   |   |\n              +---+---+---+---+---+---+---+\n              |   |   |   |   |   |   |   |\n              +---+---+---+---+---+---+---+\n              |   |   |   |   |   |   |   |\n              +---+---+---+---+---+---+---+\n              |   |   |   |   |   |   |   |\n              +---+---+---+---+---+---+---+\n              |   |   |   |   |   |   |   |\n              +---+---+---+---+---+---+---+\n              |   |   |   |   |   |   |   |\n              +---+---+---+---+---+---+---+\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that 2D grids such as the above are merely helpful visualizations. From the point of view of C++, memory is a \u0026quot;flat\u0026quot; sequence of bytes. The elements of a multidimensional array are stored in row-major order. That is, \u0026lt;code\u0026gt;connect_four[0][6]\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;connect_four[1][0]\u0026lt;/code\u0026gt; are neighbors in memory. In fact, \u0026lt;code\u0026gt;connect_four[0][7]\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;connect_four[1][0]\u0026lt;/code\u0026gt; denote the same element! This means that you can take multi-dimensional arrays and treat them as large, one-dimensional arrays:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;* p = \u0026amp;amp;connect_four[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;][\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;];\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;* q = p + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;some_int_sequence_algorithm\u0026lt;/span\u0026gt;(p, q);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h2\u0026gt;Anonymous multidimensional arrays\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;With anonymous multidimensional arrays, all dimensions \u0026lt;em\u0026gt;except the first\u0026lt;/em\u0026gt; must be known at compile time:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*p)[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;][\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;];   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// okay\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*p)[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[H][\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;];   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// okay\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*p)[W] = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;][W];   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ISO C++ forbids variable length array\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*p)[W] = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[H][W];   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ISO C++ forbids variable length array\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This is how an anonymous multidimensional array looks like in memory:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;              +---+---+---+---+---+---+---+\n        +---\u0026amp;gt; |   |   |   |   |   |   |   |\n        |     +---+---+---+---+---+---+---+\n        |     |   |   |   |   |   |   |   |\n        |     +---+---+---+---+---+---+---+\n        |     |   |   |   |   |   |   |   |\n        |     +---+---+---+---+---+---+---+\n        |     |   |   |   |   |   |   |   |\n        |     +---+---+---+---+---+---+---+\n        |     |   |   |   |   |   |   |   |\n        |     +---+---+---+---+---+---+---+\n        |     |   |   |   |   |   |   |   |\n        |     +---+---+---+---+---+---+---+\n        |\n      +-|-+\n   p: | | |\n      +---+\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that the array itself is still allocated as a single block in memory.\u0026lt;/p\u0026gt;\n\n\u0026lt;h1\u0026gt;Arrays of pointers\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;You can overcome the restriction of fixed width by introducing another level of indirection.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Named arrays of pointers\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Here is a named array of five pointers which are initialized with anonymous arrays of different lengths:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;* triangle[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;];\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;; ++i)\n{\n    triangle[i] = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt; - i];\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;; ++i)\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;[] triangle[i];\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And here is how it looks like in memory:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;          +---+---+---+---+---+\n          |   |   |   |   |   |\n          +---+---+---+---+---+\n            ^\n            | +---+---+---+---+\n            | |   |   |   |   |\n            | +---+---+---+---+\n            |   ^\n            |   | +---+---+---+\n            |   | |   |   |   |\n            |   | +---+---+---+\n            |   |   ^\n            |   |   | +---+---+\n            |   |   | |   |   |\n            |   |   | +---+---+\n            |   |   |   ^\n            |   |   |   | +---+\n            |   |   |   | |   |\n            |   |   |   | +---+\n            |   |   |   |   ^\n            |   |   |   |   |\n            |   |   |   |   |\n          +-|-+-|-+-|-+-|-+-|-+\ntriangle: | | | | | | | | | | |\n          +---+---+---+---+---+\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Since each line is allocated individually now, viewing 2D arrays as 1D arrays does not work anymore.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Anonymous arrays of pointers\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Here is an anonymous array of 5 (or any other number of) pointers which are initialized with anonymous arrays of different lengths:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;calculate_five\u0026lt;/span\u0026gt;();   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// or any other number\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;** p = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;*[n];\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; n; ++i)\n{\n    p[i] = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[n - i];\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; n; ++i)\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;[] p[i];\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;[] p;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// note the extra delete[] !\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And here is how it looks like in memory:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;          +---+---+---+---+---+\n          |   |   |   |   |   |\n          +---+---+---+---+---+\n            ^\n            | +---+---+---+---+\n            | |   |   |   |   |\n            | +---+---+---+---+\n            |   ^\n            |   | +---+---+---+\n            |   | |   |   |   |\n            |   | +---+---+---+\n            |   |   ^\n            |   |   | +---+---+\n            |   |   | |   |   |\n            |   |   | +---+---+\n            |   |   |   ^\n            |   |   |   | +---+\n            |   |   |   | |   |\n            |   |   |   | +---+\n            |   |   |   |   ^\n            |   |   |   |   |\n            |   |   |   |   |\n          +-|-+-|-+-|-+-|-+-|-+\n          | | | | | | | | | | |\n          +---+---+---+---+---+\n            ^\n            |\n            |\n          +-|-+\n       p: | | |\n          +---+\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h1\u0026gt;Conversions\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;Array-to-pointer decay naturally extends to arrays of arrays and arrays of pointers:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; array_of_arrays[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;][\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;];\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*pointer_to_array)[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;] = array_of_arrays;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;* array_of_pointers[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;];\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;** pointer_to_pointer = array_of_pointers;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;However, there is no implicit conversion from \u0026lt;code\u0026gt;T[h][w]\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;T**\u0026lt;/code\u0026gt;. If such an implicit conversion did exist, the result would be a pointer to the first element of an array of \u0026lt;code\u0026gt;h\u0026lt;/code\u0026gt; pointers to \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; (each pointing to the first element of a line in the original 2D array), but that pointer array does not exist anywhere in memory yet. If you want such a conversion, you must create and fill the required pointer array manually:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; connect_four[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;][\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;];\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;** p = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;*[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;];\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;; ++i)\n{\n    p[i] = connect_four[i];\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;[] p;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that this generates a view of the original multidimensional array. If you need a copy instead, you must create extra arrays and copy the data yourself:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; connect_four[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;][\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;];\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;** p = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;*[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;];\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;; ++i)\n{\n    p[i] = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;];\n    std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;copy\u0026lt;/span\u0026gt;(connect_four[i], connect_four[i + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;], p[i]);\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;; ++i)\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;[] p[i];\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;[] p;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;Assignment\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;For no particular reason, arrays cannot be assigned to one another. Use \u0026lt;code\u0026gt;std::copy\u0026lt;/code\u0026gt; instead:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;algorithm\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;] = {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;13\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;17\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;19\u0026lt;/span\u0026gt;};\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; b[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;];\nstd::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;copy\u0026lt;/span\u0026gt;(a + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, a + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;, b);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This is more flexible than what true array assignment could provide because it is possible to copy slices of larger arrays into smaller arrays.\n\u0026lt;code\u0026gt;std::copy\u0026lt;/code\u0026gt; is usually specialized for primitive types to give maximum performance. It is unlikely that \u0026lt;code\u0026gt;std::memcpy\u0026lt;/code\u0026gt; performs better. If in doubt, measure.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Although you cannot assign arrays directly, you \u0026lt;em\u0026gt;can\u0026lt;/em\u0026gt; assign structs and classes which \u0026lt;em\u0026gt;contain\u0026lt;/em\u0026gt; array members. That is because \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/4164279/\u0026quot;\u0026gt;array members are copied memberwise\u0026lt;/a\u0026gt; by the assignment operator which is provided as a default by the compiler. If you define the assignment operator manually for your own struct or class types, you must fall back to manual copying for the array members.\u0026lt;/p\u0026gt;\n\n\u0026lt;h1\u0026gt;Parameter passing\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;Arrays cannot be passed by value. You can either pass them by pointer or by reference.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Pass by pointer\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Since arrays themselves cannot be passed by value, usually a pointer to their first element is passed by value instead. This is often called \u0026quot;pass by pointer\u0026quot;. Since the size of the array is not retrievable via that pointer, you have to pass a second parameter indicating the size of the array (the classic C solution) or a second pointer pointing after the last element of the array (the C++ iterator solution):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;numeric\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;cstddef\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;sum\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;* p, std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; n)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;accumulate\u0026lt;/span\u0026gt;(p, p + n, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;sum\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;* p, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;* q)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;accumulate\u0026lt;/span\u0026gt;(p, q, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;As a syntactic alternative, you can also declare parameters as \u0026lt;code\u0026gt;T p[]\u0026lt;/code\u0026gt;, and it means the exact same thing as \u0026lt;code\u0026gt;T* p\u0026lt;/code\u0026gt; \u0026lt;strong\u0026gt;in the context of parameter lists only\u0026lt;/strong\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;sum\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; p[], std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; n)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;accumulate\u0026lt;/span\u0026gt;(p, p + n, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You can think of the compiler as rewriting \u0026lt;code\u0026gt;T p[]\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;T *p\u0026lt;/code\u0026gt; \u0026lt;strong\u0026gt;in the context of parameter lists only\u0026lt;/strong\u0026gt;. This special rule is partly responsible for the whole confusion about arrays and pointers. In every other context, declaring something as an array or as a pointer makes a \u0026lt;em\u0026gt;huge\u0026lt;/em\u0026gt; difference.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Unfortunately, you can also provide a size in an array parameter which is silently ignored by the compiler. That is, the following three signatures are exactly equivalent, as indicated by the compiler errors:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;sum\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;* p, std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; n)\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// error: redefinition of \u0026apos;int sum(const int*, size_t)\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;sum\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; p[], std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; n)\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// error: redefinition of \u0026apos;int sum(const int*, size_t)\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;sum\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;], std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; n)\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// the 8 has no meaning here\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h2\u0026gt;Pass by reference\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Arrays can also be passed by reference:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;sum\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (\u0026amp;amp;a)[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;])\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;accumulate\u0026lt;/span\u0026gt;(a + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, a + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In this case, the array size is significant. Since writing a function that only accepts arrays of exactly 8 elements is of little use, programmers usually write such functions as templates:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; n\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;sum\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (\u0026amp;amp;a)[n])\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;accumulate\u0026lt;/span\u0026gt;(a + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, a + n, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that you can only call such a function template with an actual array of integers, not with a pointer to an integer. The size of the array is automatically inferred, and for every size \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt;, a different function is instantiated from the template. You can also write \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/4759078/\u0026quot;\u0026gt;quite useful\u0026lt;/a\u0026gt; function templates that abstract from both the element type and from the size.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;5. Common pitfalls when using arrays.\u0026lt;/h1\u0026gt;\n\n\u0026lt;h2\u0026gt;5.1 Pitfall: Trusting type-unsafe linking.\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;OK, youve been told, or have found out yourself, that globals (namespace\nscope variables that can be accessed outside the translation unit) are\nEvil. But did you know how truly Evil they are? Consider the\nprogram below, consisting of two files [main.cpp] and [numbers.cpp]:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// [main.cpp]\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extern\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;* numbers;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;  i \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt;;  ++i )\n    {\n        cout \u0026amp;lt;\u0026amp;lt; (i \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;? \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;, \u0026quot;\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;) \u0026amp;lt;\u0026amp;lt; numbers[i];\n    }\n    cout \u0026amp;lt;\u0026amp;lt; endl;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// [numbers.cpp]\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; numbers[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt;] = {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt;};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In Windows 7 this compiles and links fine with both MinGW g++ 4.4.1 and\nVisual C++ 10.0.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Since the types don\u0026apos;t match, the program crashes when you run it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/v7KJF.png\u0026quot; alt=\u0026quot;The Windows 7 crash dialog\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In-the-formal explanation: the program has Undefined Behavior (UB), and instead\nof crashing it can therefore just hang, or perhaps do nothing, or it\ncan send threating e-mails to the presidents of the USA, Russia, India,\nChina and Switzerland, and make Nasal Daemons fly out of your nose.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In-practice explanation: in \u0026lt;code\u0026gt;main.cpp\u0026lt;/code\u0026gt; the array is treated as a pointer, placed\nat the same address as the array. For 32-bit executable this means that the first\n\u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; value in the array, is treated as a pointer. I.e., in \u0026lt;code\u0026gt;main.cpp\u0026lt;/code\u0026gt; the\n\u0026lt;code\u0026gt;numbers\u0026lt;/code\u0026gt; variable contains, or appears to contain, \u0026lt;code\u0026gt;(int*)1\u0026lt;/code\u0026gt;. This causes the\nprogram to access memory down at very bottom of the address space, which is\nconventionally reserved and trap-causing. Result: you get a crash.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The compilers are fully within their rights to not diagnose this error,\nbecause C++11 §3.5/10 says, about the requirement of compatible types\nfor the declarations,\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;[N3290 §3.5/10]\u0026lt;/strong\u0026gt;\u0026lt;br\u0026gt;\n  A violation of this rule on type identity does not require a diagnostic.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;The same paragraph details the variation that is allowed:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt; declarations for an array object can specify array types that\n  differ by the presence or absence of a major array bound (8.3.4).\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;This allowed variation does not include declaring a name as an array in one\ntranslation unit, and as a pointer in another translation unit.    \u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;5.2 Pitfall: Doing premature optimization (\u0026lt;code\u0026gt;memset\u0026lt;/code\u0026gt; \u0026amp;amp; friends).\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Not written yet\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;5.3 Pitfall: Using the C idiom to get number of elements.\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;With deep C experience its natural to write \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; N_ITEMS( array )   (sizeof( array )/sizeof( array[0] ))\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Since an \u0026lt;code\u0026gt;array\u0026lt;/code\u0026gt; decays to pointer to first element where needed, the\nexpression \u0026lt;code\u0026gt;sizeof(a)/sizeof(a[0])\u0026lt;/code\u0026gt; can also be written as\n\u0026lt;code\u0026gt;sizeof(a)/sizeof(*a)\u0026lt;/code\u0026gt;. It means the same, and no matter how its\nwritten it is the \u0026lt;strong\u0026gt;C idiom\u0026lt;/strong\u0026gt; for finding the number elements of array.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Main pitfall: the C idiom is not typesafe. For example, the code\n\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; N_ITEMS( array ) (sizeof( array )/sizeof( *array ))\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;display\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;] )\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;   n = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;N_ITEMS\u0026lt;/span\u0026gt;( a );          \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Oops.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d elements.\\n\u0026quot;\u0026lt;/span\u0026gt;, n );\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;   moohaha[]   = {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;};\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d elements, calling display...\\n\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;N_ITEMS\u0026lt;/span\u0026gt;( moohaha ) );\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;display\u0026lt;/span\u0026gt;( moohaha );\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;passes a pointer to \u0026lt;code\u0026gt;N_ITEMS\u0026lt;/code\u0026gt;, and therefore most likely produces a wrong\nresult. Compiled as a 32-bit executable in Windows 7 it produces \u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;7 elements, calling display...\u0026lt;br\u0026gt;\n  1 elements.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;The compiler rewrites \u0026lt;code\u0026gt;int const a[7]\u0026lt;/code\u0026gt; to just \u0026lt;code\u0026gt;int const a[]\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The compiler rewrites \u0026lt;code\u0026gt;int const a[]\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;int const* a\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;N_ITEMS\u0026lt;/code\u0026gt; is therefore invoked with a pointer.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;For a 32-bit executable \u0026lt;code\u0026gt;sizeof(array)\u0026lt;/code\u0026gt; (size of a pointer) is then 4.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;sizeof(*array)\u0026lt;/code\u0026gt; is equivalent to \u0026lt;code\u0026gt;sizeof(int)\u0026lt;/code\u0026gt;, which for a 32-bit executable is also 4.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;In order to detect this error at run time you can do \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;assert.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typeinfo\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; N_ITEMS( array )       (                               \\\n    assert((                                                    \\\n        \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;N_ITEMS requires an actual array as argument\u0026quot;\u0026lt;/span\u0026gt;,        \\\n        typeid( array ) != typeid( \u0026amp;amp;*array )                    \\\n        )),                                                     \\\n    sizeof( array )/sizeof( *array )                            \\\n    )\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;7 elements, calling display...\u0026lt;br\u0026gt;\n  Assertion failed: ( \u0026quot;N_ITEMS requires an actual array as argument\u0026quot;, typeid( a ) != typeid( \u0026amp;amp;*a ) ), file runtime_detect\n  ion.cpp, line 16  \u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;This application has requested the Runtime to terminate it in an unusual way.\u0026lt;br\u0026gt;\n  Please contact the application\u0026apos;s support team for more information.  \u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;The runtime error detection is better than no detection, but it wastes a little\nprocessor time, and perhaps much more programmer time. Better with detection at\ncompile time! And if you\u0026apos;re happy to not support arrays of local types with C++98,\nthen you can do that:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stddef.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;ptrdiff_t\u0026lt;/span\u0026gt;   Size;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; Type, Size n \u0026amp;gt;\nSize \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;n_items\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( Type (\u0026amp;amp;)[n] )\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; n; }\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; N_ITEMS( array )       n_items( array )\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Compiling this definition substituted into the first complete program, with g++,\nI got \u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;M:\\count\u0026amp;gt; g++ compile_time_detection.cpp\u0026lt;br\u0026gt;\n  compile_time_detection.cpp: In function \u0026apos;void display(const int*)\u0026apos;:\u0026lt;br\u0026gt;\n  compile_time_detection.cpp:14: error: no matching function for call to \u0026apos;n_items(const int*\u0026amp;amp;)\u0026apos;  \u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;M:\\count\u0026amp;gt; _  \u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;How it works: the array is passed \u0026lt;em\u0026gt;by reference\u0026lt;/em\u0026gt; to \u0026lt;code\u0026gt;n_items\u0026lt;/code\u0026gt;, and so it does\nnot decay to pointer to first element, and the function can just return the\nnumber of elements specified by the type.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;With C++11 you can use this also for arrays of local type, and it\u0026apos;s the type safe\n\u0026lt;strong\u0026gt;C++ idiom\u0026lt;/strong\u0026gt; for finding the number of elements of an array.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;5.4 C++11 \u0026amp;amp; C++14 pitfall: Using a \u0026lt;code\u0026gt;constexpr\u0026lt;/code\u0026gt; array size function.\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;With C++11 and later it\u0026apos;s natural, but as you\u0026apos;ll see dangerous!, to\nreplace the C++03 function\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;ptrdiff_t\u0026lt;/span\u0026gt;   Size;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; Type, Size n \u0026amp;gt;\nSize \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;n_items\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( Type (\u0026amp;amp;)[n] )\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; n; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;with\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; Size = \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;ptrdiff_t\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; Type, Size n \u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;n_items\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( Type (\u0026amp;amp;)[n] )\u0026lt;/span\u0026gt; -\u0026amp;gt; Size \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; n; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;where the significant change is the use of \u0026lt;code\u0026gt;constexpr\u0026lt;/code\u0026gt;, which allows\nthis function to produce a \u0026lt;strong\u0026gt;compile time constant\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example, in contrast to the C++03 function, such a compile time constant\ncan be used to declare an array of the same size as another:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Example 1\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; x[] = {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;};\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; Size n = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;n_items\u0026lt;/span\u0026gt;( x );\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; y[n] = {};\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Using y here.\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;But consider this code using the \u0026lt;code\u0026gt;constexpr\u0026lt;/code\u0026gt; version:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Example 2\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; Collection \u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( Collection \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp; c )\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;n_items\u0026lt;/span\u0026gt;( c );     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Not in C++14!\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Use c here\u0026lt;/span\u0026gt;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt;];\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;( x );\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The pitfall: as of July 2015 the above compiles with MinGW-64 5.1.0 with\n\u0026lt;code\u0026gt;-pedantic-errors\u0026lt;/code\u0026gt;, and,\ntesting with the online compilers at \u0026lt;a href=\u0026quot;http://gcc.godbolt.org/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;gcc.godbolt.org/\u0026lt;/a\u0026gt;, also with clang 3.0\nand clang 3.2, but not with clang 3.3, 3.4.1, 3.5.0, 3.5.1, 3.6 (rc1) or\n3.7 (experimental). And important for the Windows platform, it does not compile\nwith Visual C++ 2015. The reason is a C++11/C++14 statement about use of\nreferences in \u0026lt;code\u0026gt;constexpr\u0026lt;/code\u0026gt; expressions:\u0026lt;/p\u0026gt;\n\nC++11 C++14 $5.19/2 nine\u0026lt;sup\u0026gt;\u0026lt;i\u0026gt;th\u0026lt;/i\u0026gt;\u0026lt;/sup\u0026gt; dash\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;A \u0026lt;em\u0026gt;conditional-expression\u0026lt;/em\u0026gt; \u0026lt;code\u0026gt;e\u0026lt;/code\u0026gt; is a \u0026lt;em\u0026gt;core constant expression\u0026lt;/em\u0026gt; unless the evaluation\n  of \u0026lt;code\u0026gt;e\u0026lt;/code\u0026gt;, following the rules of the abstract machine (1.9), would evaluate one of the\n  following expressions:\u0026lt;br\u0026gt;\n  \u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;  \u0026lt;/p\u0026gt;\n  \n  \u0026lt;ul\u0026gt;\n  \u0026lt;li\u0026gt;an \u0026lt;em\u0026gt;id-expression\u0026lt;/em\u0026gt; that refers to a variable or data member of reference type\n  unless the reference has a preceding initialization and either  \n  \n  \u0026lt;ul\u0026gt;\n  \u0026lt;li\u0026gt;it is initialized with a constant expression or  \u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;it is a non-static data member of an object whose lifetime began within\n  the evaluation of e;\u0026lt;/li\u0026gt;\n  \u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n  \u0026lt;/ul\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;One can always write the more verbose\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Example 3  --  limited\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; Size = \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;ptrdiff_t\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; Collection \u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( Collection \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp; c )\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; Size n = std::extent\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;( c ) \u0026amp;gt;::value;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Use c here\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt; but this fails when \u0026lt;code\u0026gt;Collection\u0026lt;/code\u0026gt; is not a raw array.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To deal with collections that can be non-arrays one needs the overloadability of an\n\u0026lt;code\u0026gt;n_items\u0026lt;/code\u0026gt; function, but also, for compile time use one needs a compile time\nrepresentation of the array size. And the classic C++03 solution, which works fine\nalso in C++11 and C++14, is to let the function report its result not as a value\nbut via its function result \u0026lt;em\u0026gt;type\u0026lt;/em\u0026gt;. For example like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Example 4 - OK (not ideal, but portable and safe)\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;array\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stddef.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; Size = \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;ptrdiff_t\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt; Size n \u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Size_carrier\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; sizer[n];\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; Type, Size n \u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;static_n_items\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( Type (\u0026amp;amp;)[n] )\u0026lt;/span\u0026gt;\n    -\u0026amp;gt; Size_carrier\u0026amp;lt;n\u0026amp;gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// No implementation, is used only at compile time.\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Type\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; n \u0026amp;gt;        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// size_t for g++\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;static_n_items\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( std::array\u0026amp;lt;Type, n\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp; )\u0026lt;/span\u0026gt;\n    -\u0026amp;gt; Size_carrier\u0026amp;lt;n\u0026amp;gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// No implementation, is used only at compile time.\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; STATIC_N_ITEMS( c ) \\\n    static_cast\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;Size\u0026amp;gt;\u0026lt;/span\u0026gt;( sizeof( static_n_items( c ).sizer ) )\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; Collection \u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( Collection \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp; c )\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; Size n = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;STATIC_N_ITEMS\u0026lt;/span\u0026gt;( c );\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Use c here\u0026lt;/span\u0026gt;\n    (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;) c;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt;];\n    std::array\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;, 43\u0026amp;gt; y;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;( x );\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;( y );\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;About the choice of return type for \u0026lt;code\u0026gt;static_n_items\u0026lt;/code\u0026gt;: this code doesn\u0026apos;t use \u0026lt;code\u0026gt;std::integral_constant\u0026lt;/code\u0026gt;\nbecause with \u0026lt;code\u0026gt;std::integral_constant\u0026lt;/code\u0026gt; the result is represented\ndirectly as a \u0026lt;code\u0026gt;constexpr\u0026lt;/code\u0026gt; value, reintroducing the original problem. Instead\nof a \u0026lt;code\u0026gt;Size_carrier\u0026lt;/code\u0026gt; class one can let the function directly return a\nreference to an array. However, not everybody is familiar with that syntax.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;About the naming: part of this solution to the \u0026lt;code\u0026gt;constexpr\u0026lt;/code\u0026gt;-invalid-due-to-reference\nproblem is to make the choice of compile time constant explicit.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Hopefully the oops-there-was-a-reference-involved-in-your-\u0026lt;code\u0026gt;constexpr\u0026lt;/code\u0026gt; issue will be fixed with\nC++17, but until then a macro like the \u0026lt;code\u0026gt;STATIC_N_ITEMS\u0026lt;/code\u0026gt; above yields portability,\ne.g. to the clang and Visual C++ compilers, retaining type safety.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Related: macros do not respect scopes, so to avoid name collisions it can be a\ngood idea to use a name prefix, e.g. \u0026lt;code\u0026gt;MYLIB_STATIC_N_ITEMS\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;Array creation and initialization\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;As with any other kind of C++ object, arrays can be stored either directly in named variables (then the size must be a compile-time constant; \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/1887097/\u0026quot;\u0026gt;C++ does not support VLAs\u0026lt;/a\u0026gt;), or they can be stored anonymously on the heap and accessed indirectly via pointers (only then can the size be computed at runtime).\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Automatic arrays\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Automatic arrays (arrays living \u0026quot;on the stack\u0026quot;) are created each time the flow of control passes through the definition of a non-static local array variable:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; automatic_array[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;];\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Initialization is performed in ascending order. Note that the initial values depend on the element type \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; is a \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/146589/\u0026quot;\u0026gt;POD\u0026lt;/a\u0026gt; (like \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; in the above example), no initialization takes place.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Otherwise, the default-constructor of \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; initializes all the elements.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; provides no accessible default-constructor, the program does not compile.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Alternatively, the initial values can be explicitly specified in the \u0026lt;em\u0026gt;array initializer\u0026lt;/em\u0026gt;, a comma-separated list surrounded by curly brackets:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; primes[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;] = {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;13\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;17\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;19\u0026lt;/span\u0026gt;};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Since in this case the number of elements in the array initializer is equal to the size of the array, specifying the size manually is redundant. It can automatically be deduced by the compiler:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; primes[] = {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;13\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;17\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;19\u0026lt;/span\u0026gt;};   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// size 8 is deduced\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It is also possible to specify the size and provide a shorter array initializer:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; fibonacci[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;50\u0026lt;/span\u0026gt;] = {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;};   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 47 trailing zeros are deduced\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In that case, the remaining elements are \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/1613383/\u0026quot;\u0026gt;zero-initialized\u0026lt;/a\u0026gt;. Note that C++ allows an empty array initializer (all elements are zero-initialized), whereas C89 does not (at least one value is required). Also note that array initializers can only be used to \u0026lt;em\u0026gt;initialize\u0026lt;/em\u0026gt; arrays; they cannot later be used in assignments.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Static arrays\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Static arrays (arrays living \u0026quot;in the data segment\u0026quot;) are local array variables defined with the \u0026lt;code\u0026gt;static\u0026lt;/code\u0026gt; keyword and array variables at namespace scope (\u0026quot;global variables\u0026quot;):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; global_static_array[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;];\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; local_static_array[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;];\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;(Note that variables at namespace scope are implicitly static. Adding the \u0026lt;code\u0026gt;static\u0026lt;/code\u0026gt; keyword to their definition has a \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/3891325/\u0026quot;\u0026gt;completely different, deprecated meaning\u0026lt;/a\u0026gt;.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here is how static arrays behave differently from automatic arrays:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Static arrays without an array initializer are zero-initialized prior to any further potential initialization.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Static POD arrays are initialized \u0026lt;em\u0026gt;exactly once\u0026lt;/em\u0026gt;, and the initial values are \u0026lt;em\u0026gt;typically\u0026lt;/em\u0026gt; baked into the executable, in which case there is no initialization cost at runtime. This is not always the most space-efficient solution, however, and it is not required by the standard.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Static non-POD arrays are initialized the \u0026lt;em\u0026gt;first time\u0026lt;/em\u0026gt; the flow of control passes through their definition. In the case of local static arrays, that may never happen if the function is never called.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;(None of the above is specific to arrays. These rules apply equally well to other kinds of static objects.)\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Array data members\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Array data members are created when their owning object is created. Unfortunately, C++03 provides no means to initialize arrays in the \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/1711990/\u0026quot;\u0026gt;member initializer list\u0026lt;/a\u0026gt;, so initialization must be faked with assignments:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; primes[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;];\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt;()\n    {\n        primes[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n        primes[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;;\n        primes[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...\u0026lt;/span\u0026gt;\n    }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Alternatively, you can define an automatic array in the constructor body and copy the elements over:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; primes[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;];\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt;()\n    {\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; local_array[] = {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;13\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;17\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;19\u0026lt;/span\u0026gt;};\n        std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;copy\u0026lt;/span\u0026gt;(local_array + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, local_array + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;, primes + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n    }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In C++0x, arrays \u0026lt;em\u0026gt;can\u0026lt;/em\u0026gt; be initialized in the member initializer list thanks to \u0026lt;a href=\u0026quot;http://www.youtube.com/watch?v=uEqknlxXJfg\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;uniform initialization\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; primes[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;];\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt;() : primes { \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;13\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;17\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;19\u0026lt;/span\u0026gt; }\n    {\n    }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This is the only solution that works with element types that have no default constructor.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Dynamic arrays\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Dynamic arrays have no names, hence the only means of accessing them is via pointers. Because they have no names, I will refer to them as \u0026quot;anonymous arrays\u0026quot; from now on.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In C, anonymous arrays are created via \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; and friends. In C++, anonymous arrays are created using the \u0026lt;code\u0026gt;new T[size]\u0026lt;/code\u0026gt; syntax which returns a pointer to the first element of an anonymous array:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; size = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;compute_size_at_runtime\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;* p = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[size];\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The following ASCII art depicts the memory layout if the size is computed as 8 at runtime:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;             +---+---+---+---+---+---+---+---+\n(anonymous)  |   |   |   |   |   |   |   |   |\n             +---+---+---+---+---+---+---+---+\n               ^\n               |\n               |\n             +-|-+\n          p: | | |                               \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;*\n             +---+\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Obviously, anonymous arrays require more memory than named arrays due to the extra pointer that must be stored separately. (There is also some additional overhead on the free store.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note that there is \u0026lt;em\u0026gt;no\u0026lt;/em\u0026gt; array-to-pointer decay going on here. Although evaluating \u0026lt;code\u0026gt;new int[size]\u0026lt;/code\u0026gt; does in fact create an \u0026lt;em\u0026gt;array\u0026lt;/em\u0026gt; of integers, the result of the expression \u0026lt;code\u0026gt;new int[size]\u0026lt;/code\u0026gt; is \u0026lt;em\u0026gt;already\u0026lt;/em\u0026gt; a pointer to a single integer (the first element), \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; an array of integers or a pointer to an array of integers of unknown size. That would be impossible, because the static type system requires array sizes to be compile-time constants. (Hence, I did not annotate the anonymous array with static type information in the picture.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Concerning default values for elements, anonymous arrays behave similar to automatic arrays.\nNormally, anonymous POD arrays are not initialized, but there is a \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/620137/\u0026quot;\u0026gt;special syntax\u0026lt;/a\u0026gt; that triggers value-initialization:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;* p = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[some_computed_size]();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;(Note the trailing pair of parenthesis right before the semicolon.) Again, C++0x simplifies the rules and allows specifying initial values for anonymous arrays thanks to uniform initialization:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;* p = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;] { \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;13\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;17\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;19\u0026lt;/span\u0026gt; };\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If you are done using an anonymous array, you have to release it back to the system:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;[] p;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You must release each anonymous array exactly once and then never touch it again afterwards. Not releasing it at all results in a memory leak (or more generally, depending on the element type, a resource leak), and trying to release it multiple times results in undefined behavior. Using the non-array form \u0026lt;code\u0026gt;delete\u0026lt;/code\u0026gt; (or \u0026lt;code\u0026gt;free\u0026lt;/code\u0026gt;) instead of \u0026lt;code\u0026gt;delete[]\u0026lt;/code\u0026gt; to release the array is also \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/1612031/\u0026quot;\u0026gt;undefined behavior\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    "],"id":264,"title":"How do I use arrays in C++?","content":"\n                \n\u0026lt;p\u0026gt;C++ inherited arrays from C where they are used virtually everywhere. C++ provides abstractions that are easier to use and less error-prone (\u0026lt;code\u0026gt;std::vector\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; since C++98 and \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/container/array\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::array\u0026amp;lt;T, n\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; since \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/C++11\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;C++11\u0026lt;/a\u0026gt;), so the need for arrays does not arise quite as often as it does in C. However, when you read legacy code or interact with a library written in C, you should have a firm grasp on how arrays work.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This FAQ is split into five parts:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/4810668/\u0026quot;\u0026gt;arrays on the type level and accessing elements\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/4984228/\u0026quot;\u0026gt;array creation and initialization\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/4810672/\u0026quot;\u0026gt;assignment and parameter passing\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/4810676/\u0026quot;\u0026gt;multidimensional arrays and arrays of pointers\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/4810664/how-do-i-use-arrays-in-c/7439261#7439261\u0026quot;\u0026gt;common pitfalls when using arrays\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;If you feel something important is missing in this FAQ, write an answer and link it here as an additional part.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In the following text, \u0026quot;array\u0026quot; means \u0026quot;C array\u0026quot;, not the class template \u0026lt;code\u0026gt;std::array\u0026lt;/code\u0026gt;. Basic knowledge of the C declarator syntax is assumed. Note that the manual usage of \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;delete\u0026lt;/code\u0026gt; as demonstrated below is extremely dangerous in the face of exceptions, but that is the topic of \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/712639/\u0026quot;\u0026gt;another FAQ\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;(Note: This is meant to be an entry to \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/tagged/c++-faq\u0026quot;\u0026gt;Stack Overflow\u0026apos;s C++ FAQ\u0026lt;/a\u0026gt;. If you want to critique the idea of providing an FAQ in this form, then \u0026lt;a href=\u0026quot;https://meta.stackexchange.com/questions/68647/setting-up-a-faq-for-the-c-tag\u0026quot;\u0026gt;the posting on meta that started all this\u0026lt;/a\u0026gt; would be the place to do that. Answers to that question are monitored in the \u0026lt;a href=\u0026quot;https://chat.stackoverflow.com/rooms/10/c-lounge\u0026quot;\u0026gt;C++ chatroom\u0026lt;/a\u0026gt;, where the FAQ idea started out in the first place, so your answer is very likely to get read by those who came up with the idea.)\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n    ","slug":"how-do-i-use-arrays-in-c++-1657387456118","postType":"QUESTION","createdAt":"2022-07-09T17:24:16.000Z","updatedAt":"2022-07-09T17:24:16.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"How do you parse and process HTML/XML in PHP?","slug":"how-do-you-parse-and-process-htmlxml-in-php-1657384351267"},{"title":"How to format numbers as currency strings","slug":"how-to-format-numbers-as-currency-strings-1657388399166"},{"title":"How can I upload files to a server using JSP/Servlet?","slug":"how-can-i-upload-files-to-a-server-using-jspservlet-1657384847658"},{"title":"SQL select only rows with max value on a column [duplicate]","slug":"sql-select-only-rows-with-max-value-on-a-column-duplicate-1657384614292"},{"title":"What does ** (double star/asterisk) and * (star/asterisk) do for parameters?","slug":"what-does-**-(double-starasterisk)-and-*-(starasterisk)-do-for-parameters-1657384800967"},{"title":"What is this weird colon-member (\" : \") syntax in the constructor?","slug":"what-is-this-weird-colon-member-(\"-:-\")-syntax-in-the-constructor-1657387264047"},{"title":"How to avoid using Select in Excel VBA","slug":"how-to-avoid-using-select-in-excel-vba-1657384286300"},{"title":"How to use SharedPreferences in Android to store, fetch and edit values [closed]","slug":"how-to-use-sharedpreferences-in-android-to-store-fetch-and-edit-values-closed-1657387683057"},{"title":"When to use virtual destructors?","slug":"when-to-use-virtual-destructors-1657388152135"},{"title":"What is the scope of variables in JavaScript?","slug":"what-is-the-scope-of-variables-in-javascript-1657384464291"},{"title":"Maintain the aspect ratio of a div with CSS","slug":"maintain-the-aspect-ratio-of-a-div-with-css-1657387513615"},{"title":"How can I vertically align elements in a div?","slug":"how-can-i-vertically-align-elements-in-a-div-1657385504431"},{"title":"Why does std::getline() skip input after a formatted extraction?","slug":"why-does-std::getline()-skip-input-after-a-formatted-extraction-1657384756118"},{"title":"How do I redirect to another webpage?","slug":"how-do-i-redirect-to-another-webpage-1657384869767"},{"title":"Int division: Why is the result of 1/3 == 0?","slug":"int-division:-why-is-the-result-of-13-0-1657387547814"},{"title":"Can I mix MySQL APIs in PHP?","slug":"can-i-mix-mysql-apis-in-php-1657384597444"},{"title":"\"Cross origin requests are only supported for HTTP.\" error when loading a local file","slug":"\"cross-origin-requests-are-only-supported-for-http.\"-error-when-loading-a-local-file-1657387942403"},{"title":"Why is my variable unaltered after I modify it inside of a function? - Asynchronous code reference","slug":"why-is-my-variable-unaltered-after-i-modify-it-inside-of-a-function-asynchronous-code-reference-1657384288966"},{"title":"Difference between sh and Bash","slug":"difference-between-sh-and-bash-1657388197713"},{"title":"Using i and j as variables in MATLAB","slug":"using-i-and-j-as-variables-in-matlab-1657388506358"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"how-do-i-use-arrays-in-c++-1657387456118"},"buildId":"BnkbnjkWYxefPXjTJLVVv","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>