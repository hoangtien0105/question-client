<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>What do lambda function closures capture? [duplicate] | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="
            
        
            
                
                    
                        This question already has answers here:
                        
                    
                
            
                    
                        Creating functions in a loop
                            
                                (5 answers)
                            
                    
                Closed 6 days ago.
        


    

Recently I started playing around with Python and I came around something peculiar in the way closures work. Consider the following code:
adders=[None, None, None, None]

for i in [0,1,2,3]:
   adders[i]=lambda a: i+a

print adders[1](3)

It builds a simple array of functions that take a single input and return that input added by a number. The functions are constructed in for loop where the iterator i runs from 0 to 3. For each of these numbers a lambda function is created which captures i and adds it to the function&#x27;s input. The last line calls the second lambda function with 3 as a parameter. To my surprise the output was 6.
I expected a 4. My reasoning was: in Python everything is an object and thus every variable is essential a pointer to it. When creating the lambda closures for i, I expected it to store a pointer to the integer object currently pointed to by i. That means that when i assigned a new integer object it shouldn&#x27;t effect the previously created closures. Sadly, inspecting the adders array within a debugger shows that it does. All lambda functions refer to the last value of i, 3, which results in adders[1](3) returning 6.
Which make me wonder about the following:

What do the closures capture exactly?
What is the most elegant way to convince the lambda functions to capture the current value of i in a way that will not be affected when i changes its value?

    "/><meta property="og:title" content="What do lambda function closures capture? [duplicate] | Solutions Checker"/><meta property="og:description" content="
            
        
            
                
                    
                        This question already has answers here:
                        
                    
                
            
                    
                        Creating functions in a loop
                            
                                (5 answers)
                            
                    
                Closed 6 days ago.
        


    

Recently I started playing around with Python and I came around something peculiar in the way closures work. Consider the following code:
adders=[None, None, None, None]

for i in [0,1,2,3]:
   adders[i]=lambda a: i+a

print adders[1](3)

It builds a simple array of functions that take a single input and return that input added by a number. The functions are constructed in for loop where the iterator i runs from 0 to 3. For each of these numbers a lambda function is created which captures i and adds it to the function&#x27;s input. The last line calls the second lambda function with 3 as a parameter. To my surprise the output was 6.
I expected a 4. My reasoning was: in Python everything is an object and thus every variable is essential a pointer to it. When creating the lambda closures for i, I expected it to store a pointer to the integer object currently pointed to by i. That means that when i assigned a new integer object it shouldn&#x27;t effect the previously created closures. Sadly, inspecting the adders array within a debugger shows that it does. All lambda functions refer to the last value of i, 3, which results in adders[1](3) returning 6.
Which make me wonder about the following:

What do the closures capture exactly?
What is the most elegant way to convince the lambda functions to capture the current value of i in a way that will not be affected when i changes its value?

    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"What do lambda function closures capture? [duplicate]","text":"\n            \n        \n            \n                \n                    \n                        This question already has answers here:\n                        \n                    \n                \n            \n                    \n                        Creating functions in a loop\n                            \n                                (5 answers)\n                            \n                    \n                Closed 6 days ago.\n        \n\n\n    \n\nRecently I started playing around with Python and I came around something peculiar in the way closures work. Consider the following code:\nadders=[None, None, None, None]\n\nfor i in [0,1,2,3]:\n   adders[i]=lambda a: i+a\n\nprint adders[1](3)\n\nIt builds a simple array of functions that take a single input and return that input added by a number. The functions are constructed in for loop where the iterator i runs from 0 to 3. For each of these numbers a lambda function is created which captures i and adds it to the function&apos;s input. The last line calls the second lambda function with 3 as a parameter. To my surprise the output was 6.\nI expected a 4. My reasoning was: in Python everything is an object and thus every variable is essential a pointer to it. When creating the lambda closures for i, I expected it to store a pointer to the integer object currently pointed to by i. That means that when i assigned a new integer object it shouldn&apos;t effect the previously created closures. Sadly, inspecting the adders array within a debugger shows that it does. All lambda functions refer to the last value of i, 3, which results in adders[1](3) returning 6.\nWhich make me wonder about the following:\n\nWhat do the closures capture exactly?\nWhat is the most elegant way to convince the lambda functions to capture the current value of i in a way that will not be affected when i changes its value?\n\n    ","answerCount":7,"upVoteCount":500,"suggestedAnswer":[{"text":"you may force the capture of a variable using an argument with a default value:\n\n&gt;&gt;&gt; for i in [0,1,2,3]:\n...    adders[i]=lambda a,i=i: i+a  # note the dummy parameter with a default value\n...\n&gt;&gt;&gt; print( adders[1](3) )\n4\n\n\nthe idea is to declare a parameter (cleverly named i) and give it a default value of the variable you want to capture (the value of  i)\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"Your second question has been answered, but as for your first:\n\nwhat does the closure capture exactly?\n\nScoping in Python is dynamic and lexical. A closure will always remember the name and scope of the variable, not the object it&apos;s pointing to. Since all the functions in your example are created in the same scope and use the same variable name, they always refer to the same variable.\nRegarding your other question of how to overcome this, there are two ways that come to mind:\n\nThe most concise, but not strictly equivalent way is the one recommended by Adrien Plisson. Create a lambda with an extra argument, and set the extra argument&apos;s default value to the object you want preserved.\n\nA little more verbose but less hacky would be to create a new scope each time you create the lambda:\n &gt;&gt;&gt; adders = [0,1,2,3]\n &gt;&gt;&gt; for i in [0,1,2,3]:\n ...     adders[i] = (lambda b: lambda a: b + a)(i)\n ...     \n &gt;&gt;&gt; adders[1](3)\n 4\n &gt;&gt;&gt; adders[2](3)\n 5\n\n\n\nThe scope here is created using a new function (a lambda, for brevity), which binds its argument, and passing the value you want to bind as the argument. In real code, though, you most likely will have an ordinary function instead of the lambda to create the new scope:\ndef createAdder(x):\n    return lambda y: y + x\nadders = [createAdder(i) for i in range(4)]\n\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"For completeness another answer to your second question: You could use partial in the functools module.\nWith importing add from operator as Chris Lutz proposed the example becomes:\nfrom functools import partial\nfrom operator import add   # add(a, b) -- Same as a + b.\n\nadders = [0,1,2,3]\nfor i in [0,1,2,3]:\n    # store callable object with first argument given as (current) i\n    adders[i] = partial(add, i) \n\nprint adders[1](3)\n\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"Consider the following code:\n\nx = &quot;foo&quot;\n\ndef print_x():\n    print x\n\nx = &quot;bar&quot;\n\nprint_x() # Outputs &quot;bar&quot;\n\n\nI think most people won&apos;t find this confusing at all. It is the expected behaviour.\n\nSo, why do people think it would be different when it is done in a loop? I know I did that mistake myself, but I don&apos;t know why. It is the loop? Or perhaps the lambda?\n\nAfter all, the loop is just a shorter version of:\n\nadders= [0,1,2,3]\ni = 0\nadders[i] = lambda a: i+a\ni = 1\nadders[i] = lambda a: i+a\ni = 2\nadders[i] = lambda a: i+a\ni = 3\nadders[i] = lambda a: i+a\n\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"Here&apos;s a new example that highlights the data structure and contents of a closure, to help clarify when the enclosing context is &quot;saved.&quot;\n\ndef make_funcs():\n    i = 42\n    my_str = &quot;hi&quot;\n\n    f_one = lambda: i\n\n    i += 1\n    f_two = lambda: i+1\n\n    f_three = lambda: my_str\n    return f_one, f_two, f_three\n\nf_1, f_2, f_3 = make_funcs()\n\n\nWhat is in a closure?\n\n&gt;&gt;&gt; print f_1.func_closure, f_1.func_closure[0].cell_contents\n(&lt;cell at 0x106a99a28: int object at 0x7fbb20c11170&gt;,) 43 \n\n\nNotably, my_str is not in f1&apos;s closure.\n\nWhat&apos;s in f2&apos;s closure?\n\n&gt;&gt;&gt; print f_2.func_closure, f_2.func_closure[0].cell_contents\n(&lt;cell at 0x106a99a28: int object at 0x7fbb20c11170&gt;,) 43\n\n\nNotice (from the memory addresses) that both closures contain the same objects. So, you can start to think of the lambda function as having a reference to the scope. However, my_str is not in the closure for f_1 or f_2, and i is not in the closure for f_3 (not shown), which suggests the closure objects themselves are distinct objects.\n\nAre the closure objects themselves the same object?\n\n&gt;&gt;&gt; print f_1.func_closure is f_2.func_closure\nFalse\n\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"In answer to your second question, the most elegant way to do this would be to use a function that takes two parameters instead of an array:\n\nadd = lambda a, b: a + b\nadd(1, 3)\n\n\nHowever, using lambda here is a bit silly. Python gives us the operator module, which provides a functional interface to the basic operators. The lambda above has unnecessary overhead just to call the addition operator:\n\nfrom operator import add\nadd(1, 3)\n\n\nI understand that you&apos;re playing around, trying to explore the language, but I can&apos;t imagine a situation I would use an array of functions where Python&apos;s scoping weirdness would get in the way.\n\nIf you wanted, you could write a small class that uses your array-indexing syntax:\n\nclass Adders(object):\n    def __getitem__(self, item):\n        return lambda a: a + item\n\nadders = Adders()\nadders[1](3)\n\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"One way to sort out the scope of i is to generate the lambda in another scope (a closure function), handing over the necessary parameters for it to make the lambda:\ndef get_funky(i):\n    return lambda a: i+a\n\nadders=[None, None, None, None]\n\nfor i in [0,1,2,3]:\n   adders[i]=get_funky(i)\n\nprint(*(ar(5) for ar in adders))\n\ngiving 5 6 7 8 of course.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-12e9794e898cd5f3.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-928c5d1eb8fb0bba.js" defer=""></script><script src="/_next/static/BnkbnjkWYxefPXjTJLVVv/_buildManifest.js" defer=""></script><script src="/_next/static/BnkbnjkWYxefPXjTJLVVv/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/what-do-lambda-function-closures-capture-duplicate-1657388161827#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-do-lambda-function-closures-capture-duplicate-1657388161827"><h1>What do lambda function closures capture? [duplicate]</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"></div></div><div class="question-content mt-5">
                    <div>
            <aside class="s-notice s-notice__info post-notice js-post-notice mb16" role="status">
        <div class="d-flex fd-column fw-nowrap">
            <div class="d-flex fw-nowrap">
                <div class="flex--item wmn0 fl1 lh-lg">
                    <div class="flex--item fl1 lh-lg">
                        <b>This question already has answers here</b>:
                        
                    </div>
                </div>
            </div>
                    <div class="flex--item mb0 mt4">
                        <a href="/questions/3431676/creating-functions-in-a-loop" dir="ltr">Creating functions in a loop</a>
                            <span class="question-originals-answer-count">
                                (5 answers)
                            </span>
                    </div>
                <div class="flex--item mb0 mt8">Closed <span title="2022-07-03 04:31:24Z" class="relativetime">6 days ago</span>.</div>
        </div>
</aside>

    </div>

<p>Recently I started playing around with Python and I came around something peculiar in the way closures work. Consider the following code:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">adders=[<span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>]

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]:
   adders[i]=<span class="hljs-keyword">lambda</span> a: i+a

<span class="hljs-built_in">print</span> adders[<span class="hljs-number">1</span>](<span class="hljs-number">3</span>)
</code></pre>
<p>It builds a simple array of functions that take a single input and return that input added by a number. The functions are constructed in <code>for</code> loop where the iterator <code>i</code> runs from <code>0</code> to <code>3</code>. For each of these numbers a <code>lambda</code> function is created which captures <code>i</code> and adds it to the function's input. The last line calls the second <code>lambda</code> function with <code>3</code> as a parameter. To my surprise the output was <code>6</code>.</p>
<p>I expected a <code>4</code>. My reasoning was: in Python everything is an object and thus every variable is essential a pointer to it. When creating the <code>lambda</code> closures for <code>i</code>, I expected it to store a pointer to the integer object currently pointed to by <code>i</code>. That means that when <code>i</code> assigned a new integer object it shouldn't effect the previously created closures. Sadly, inspecting the <code>adders</code> array within a debugger shows that it does. All <code>lambda</code> functions refer to the last value of <code>i</code>, <code>3</code>, which results in <code>adders[1](3)</code> returning <code>6</code>.</p>
<p>Which make me wonder about the following:</p>
<ul>
<li>What do the closures capture exactly?</li>
<li>What is the most elegant way to convince the <code>lambda</code> functions to capture the current value of <code>i</code> in a way that will not be affected when <code>i</code> changes its value?</li>
</ul>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>you may force the capture of a variable using an argument with a default value:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]:
<span class="hljs-meta">... </span>   adders[i]=<span class="hljs-keyword">lambda</span> a,i=i: i+a  <span class="hljs-comment"># note the dummy parameter with a default value</span>
...
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>( adders[<span class="hljs-number">1</span>](<span class="hljs-number">3</span>) )
<span class="hljs-number">4</span>
</code></pre>

<p>the idea is to declare a parameter (cleverly named <code>i</code>) and give it a default value of the variable you want to capture (the value of  <code>i</code>)</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Your second question has been answered, but as for your first:</p>
<blockquote>
<p>what does the closure capture exactly?</p>
</blockquote>
<p>Scoping in Python is <strike>dynamic and</strike> lexical. A closure will always remember the name and scope of the variable, not the object it's pointing to. Since all the functions in your example are created in the same scope and use the same variable name, they always refer to the same variable.</p>
<p>Regarding your other question of how to overcome this, there are two ways that come to mind:</p>
<ol>
<li><p>The most concise, but not strictly equivalent way is the <a href="https://stackoverflow.com/a/2295372/181765">one recommended by Adrien Plisson</a>. Create a lambda with an extra argument, and set the extra argument's default value to the object you want preserved.</p>
</li>
<li><p>A little more verbose but less hacky would be to create a new scope each time you create the lambda:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"> &gt;&gt;&gt; adders = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
 &gt;&gt;&gt; <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]:
 ...     adders[i] = (<span class="hljs-keyword">lambda</span> b: <span class="hljs-keyword">lambda</span> a: b + a)(i)
 ...     
 &gt;&gt;&gt; adders[<span class="hljs-number">1</span>](<span class="hljs-number">3</span>)
 <span class="hljs-number">4</span>
 &gt;&gt;&gt; adders[<span class="hljs-number">2</span>](<span class="hljs-number">3</span>)
 <span class="hljs-number">5</span>
</code></pre>
</li>
</ol>
<p>The scope here is created using a new function (a lambda, for brevity), which binds its argument, and passing the value you want to bind as the argument. In real code, though, you most likely will have an ordinary function instead of the lambda to create the new scope:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">createAdder</span>(<span class="hljs-params">x</span>):
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">lambda</span> y: y + x
adders = [createAdder(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)]
</code></pre>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>For completeness another answer to your second question: You could use <a href="http://docs.python.org/library/functools.html#functools.partial" rel="nofollow noreferrer">partial</a> in the <a href="http://docs.python.org/library/functools.html" rel="nofollow noreferrer">functools</a> module.</p>
<p>With importing add from operator as Chris Lutz proposed the example becomes:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> partial
<span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> add   <span class="hljs-comment"># add(a, b) -- Same as a + b.</span>

adders = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]:
    <span class="hljs-comment"># store callable object with first argument given as (current) i</span>
    adders[i] = partial(add, i) 

<span class="hljs-built_in">print</span> adders[<span class="hljs-number">1</span>](<span class="hljs-number">3</span>)
</code></pre>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Consider the following code:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">x = <span class="hljs-string">"foo"</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">print_x</span>():
    <span class="hljs-built_in">print</span> x

x = <span class="hljs-string">"bar"</span>

print_x() <span class="hljs-comment"># Outputs "bar"</span>
</code></pre>

<p>I think most people won't find this confusing at all. It is the expected behaviour.</p>

<p>So, why do people think it would be different when it is done in a loop? I know I did that mistake myself, but I don't know why. It is the loop? Or perhaps the lambda?</p>

<p>After all, the loop is just a shorter version of:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">adders= [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
i = <span class="hljs-number">0</span>
adders[i] = <span class="hljs-keyword">lambda</span> a: i+a
i = <span class="hljs-number">1</span>
adders[i] = <span class="hljs-keyword">lambda</span> a: i+a
i = <span class="hljs-number">2</span>
adders[i] = <span class="hljs-keyword">lambda</span> a: i+a
i = <span class="hljs-number">3</span>
adders[i] = <span class="hljs-keyword">lambda</span> a: i+a
</code></pre>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here's a new example that highlights the data structure and contents of a closure, to help clarify when the enclosing context is "saved."</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_funcs</span>():
    i = <span class="hljs-number">42</span>
    my_str = <span class="hljs-string">"hi"</span>

    f_one = <span class="hljs-keyword">lambda</span>: i

    i += <span class="hljs-number">1</span>
    f_two = <span class="hljs-keyword">lambda</span>: i+<span class="hljs-number">1</span>

    f_three = <span class="hljs-keyword">lambda</span>: my_str
    <span class="hljs-keyword">return</span> f_one, f_two, f_three

f_1, f_2, f_3 = make_funcs()
</code></pre>

<p>What is in a closure?</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span> f_1.func_closure, f_1.func_closure[<span class="hljs-number">0</span>].cell_contents
(&lt;cell at <span class="hljs-number">0x106a99a28</span>: <span class="hljs-built_in">int</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0x7fbb20c11170</span>&gt;,) <span class="hljs-number">43</span> 
</code></pre>

<p>Notably, my_str is not in f1's closure.</p>

<p>What's in f2's closure?</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span> f_2.func_closure, f_2.func_closure[<span class="hljs-number">0</span>].cell_contents
(&lt;cell at <span class="hljs-number">0x106a99a28</span>: <span class="hljs-built_in">int</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0x7fbb20c11170</span>&gt;,) <span class="hljs-number">43</span>
</code></pre>

<p>Notice (from the memory addresses) that both closures contain the same objects. So, you can <em>start</em> to think of the lambda function as having a reference to the scope. However, my_str is not in the closure for f_1 or f_2, and i is not in the closure for f_3 (not shown), which suggests the closure objects themselves are distinct objects.</p>

<p>Are the closure objects themselves the same object?</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span> f_1.func_closure <span class="hljs-keyword">is</span> f_2.func_closure
<span class="hljs-literal">False</span>
</code></pre>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In answer to your second question, the most elegant way to do this would be to use a function that takes two parameters instead of an array:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">add = <span class="hljs-keyword">lambda</span> a, b: a + b
add(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)
</code></pre>

<p>However, using lambda here is a bit silly. Python gives us the <code>operator</code> module, which provides a functional interface to the basic operators. The lambda above has unnecessary overhead just to call the addition operator:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> add
add(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)
</code></pre>

<p>I understand that you're playing around, trying to explore the language, but I can't imagine a situation I would use an array of functions where Python's scoping weirdness would get in the way.</p>

<p>If you wanted, you could write a small class that uses your array-indexing syntax:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Adders</span>(<span class="hljs-title class_ inherited__">object</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, item</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">lambda</span> a: a + item

adders = Adders()
adders[<span class="hljs-number">1</span>](<span class="hljs-number">3</span>)
</code></pre>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>One way to sort out the scope of <code>i</code> is to generate the lambda in another scope (a closure function), handing over the necessary parameters for it to make the lambda:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_funky</span>(<span class="hljs-params">i</span>):
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">lambda</span> a: i+a

adders=[<span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>]

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]:
   adders[i]=get_funky(i)

<span class="hljs-built_in">print</span>(*(ar(<span class="hljs-number">5</span>) <span class="hljs-keyword">for</span> ar <span class="hljs-keyword">in</span> adders))
</code></pre>
<p>giving <code>5 6 7 8</code> of course.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/transpose-reshape-dataframe-without-%22timevar%22-from-long-to-wide-format-1657388213347">Transpose / reshape dataframe without &quot;timevar&quot; from long to wide format</a><a href="/questions/sort-a-maplesskey-valuegreater-by-values-1657387443904">Sort a Map&lt;Key, Value&gt; by values</a><a href="/questions/how-to-sum-a-variable-by-group-1657384838148">How to sum a variable by group</a><a href="/questions/how-to-remove-the-space-between-inlineinline-block-elements-1657384532273">How to remove the space between inline/inline-block elements?</a><a href="/questions/what-is-the-scope-of-variables-in-javascript-1657384464291">What is the scope of variables in JavaScript?</a><a href="/questions/is-it-possible-for-flex-items-to-align-tightly-to-the-items-above-them-1657388511179">Is it possible for flex items to align tightly to the items above them?</a><a href="/questions/how-to-create-a-mysql-hierarchical-recursive-query-1657387662163">How to create a MySQL hierarchical recursive query?</a><a href="/questions/does-javascript-guarantee-object-property-order-1657384822587">Does JavaScript guarantee object property order?</a><a href="/questions/string.equals-versus-duplicate-1657387599972">String.equals versus == [duplicate]</a><a href="/questions/web-scraping-javascript-page-with-python-1657388240875">Web-scraping JavaScript page with Python</a><a href="/questions/sorting-object-property-by-values-1657388367300">Sorting object property by values</a><a href="/questions/how-to-test-multiple-variables-for-equality-against-a-single-value-1657384358504">How to test multiple variables for equality against a single value?</a><a href="/questions/when-should-i-use-a-return-statement-in-es6-arrow-functions-1657388472113">When should I use a return statement in ES6 arrow functions</a><a href="/questions/how-to-check-if-element-is-visible-after-scrolling-1657387987960">How to check if element is visible after scrolling?</a><a href="/questions/most-efficient-method-to-groupby-on-an-array-of-objects-1657387580538">Most efficient method to groupby on an array of objects</a><a href="/questions/ways-to-deal-with-document-under-iframe-1657388403345">Ways to deal with #document under iframe</a><a href="/questions/how-can-i-vertically-align-elements-in-a-div-1657385504431">How can I vertically align elements in a div?</a><a href="/questions/how-do-i-write-a-correct-micro-benchmark-in-java-1657384488725">How do I write a correct micro-benchmark in Java?</a><a href="/questions/dollar(document).ready-equivalent-without-jquery-1657388504115">$(document).ready equivalent without jQuery</a><a href="/questions/sort-(order)-data-frame-rows-by-multiple-columns-1657388355671">Sort (order) data frame rows by multiple columns</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;you may force the capture of a variable using an argument with a default value:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; i \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;]:\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;   adders[i]=\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt; a,i=i: i+a  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# note the dummy parameter with a default value\u0026lt;/span\u0026gt;\n...\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;( adders[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;](\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;) )\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;the idea is to declare a parameter (cleverly named \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt;) and give it a default value of the variable you want to capture (the value of  \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt;)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Your second question has been answered, but as for your first:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;what does the closure capture exactly?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Scoping in Python is \u0026lt;strike\u0026gt;dynamic and\u0026lt;/strike\u0026gt; lexical. A closure will always remember the name and scope of the variable, not the object it\u0026apos;s pointing to. Since all the functions in your example are created in the same scope and use the same variable name, they always refer to the same variable.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Regarding your other question of how to overcome this, there are two ways that come to mind:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;The most concise, but not strictly equivalent way is the \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/2295372/181765\u0026quot;\u0026gt;one recommended by Adrien Plisson\u0026lt;/a\u0026gt;. Create a lambda with an extra argument, and set the extra argument\u0026apos;s default value to the object you want preserved.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;A little more verbose but less hacky would be to create a new scope each time you create the lambda:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt; \u0026amp;gt;\u0026amp;gt;\u0026amp;gt; adders = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;]\n \u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; i \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;]:\n ...     adders[i] = (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt; b: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt; a: b + a)(i)\n ...     \n \u0026amp;gt;\u0026amp;gt;\u0026amp;gt; adders[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;](\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;)\n \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;\n \u0026amp;gt;\u0026amp;gt;\u0026amp;gt; adders[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;](\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;)\n \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;The scope here is created using a new function (a lambda, for brevity), which binds its argument, and passing the value you want to bind as the argument. In real code, though, you most likely will have an ordinary function instead of the lambda to create the new scope:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;createAdder\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt; y: y + x\nadders = [createAdder(i) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; i \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;range\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;)]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;For completeness another answer to your second question: You could use \u0026lt;a href=\u0026quot;http://docs.python.org/library/functools.html#functools.partial\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;partial\u0026lt;/a\u0026gt; in the \u0026lt;a href=\u0026quot;http://docs.python.org/library/functools.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;functools\u0026lt;/a\u0026gt; module.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;With importing add from operator as Chris Lutz proposed the example becomes:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; functools \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; partial\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; operator \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; add   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# add(a, b) -- Same as a + b.\u0026lt;/span\u0026gt;\n\nadders = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; i \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;]:\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# store callable object with first argument given as (current) i\u0026lt;/span\u0026gt;\n    adders[i] = partial(add, i) \n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; adders[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;](\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Consider the following code:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;x = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;foo\u0026quot;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;print_x\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; x\n\nx = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;bar\u0026quot;\u0026lt;/span\u0026gt;\n\nprint_x() \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Outputs \u0026quot;bar\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I think most people won\u0026apos;t find this confusing at all. It is the expected behaviour.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So, why do people think it would be different when it is done in a loop? I know I did that mistake myself, but I don\u0026apos;t know why. It is the loop? Or perhaps the lambda?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;After all, the loop is just a shorter version of:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;adders= [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;]\ni = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\nadders[i] = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt; a: i+a\ni = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\nadders[i] = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt; a: i+a\ni = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;\nadders[i] = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt; a: i+a\ni = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\nadders[i] = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt; a: i+a\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here\u0026apos;s a new example that highlights the data structure and contents of a closure, to help clarify when the enclosing context is \u0026quot;saved.\u0026quot;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;make_funcs\u0026lt;/span\u0026gt;():\n    i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt;\n    my_str = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hi\u0026quot;\u0026lt;/span\u0026gt;\n\n    f_one = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt;: i\n\n    i += \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n    f_two = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt;: i+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\n    f_three = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt;: my_str\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; f_one, f_two, f_three\n\nf_1, f_2, f_3 = make_funcs()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;What is in a closure?\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; f_1.func_closure, f_1.func_closure[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;].cell_contents\n(\u0026amp;lt;cell at \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x106a99a28\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt; at \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x7fbb20c11170\u0026lt;/span\u0026gt;\u0026amp;gt;,) \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;43\u0026lt;/span\u0026gt; \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Notably, my_str is not in f1\u0026apos;s closure.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;What\u0026apos;s in f2\u0026apos;s closure?\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; f_2.func_closure, f_2.func_closure[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;].cell_contents\n(\u0026amp;lt;cell at \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x106a99a28\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt; at \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x7fbb20c11170\u0026lt;/span\u0026gt;\u0026amp;gt;,) \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;43\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Notice (from the memory addresses) that both closures contain the same objects. So, you can \u0026lt;em\u0026gt;start\u0026lt;/em\u0026gt; to think of the lambda function as having a reference to the scope. However, my_str is not in the closure for f_1 or f_2, and i is not in the closure for f_3 (not shown), which suggests the closure objects themselves are distinct objects.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Are the closure objects themselves the same object?\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; f_1.func_closure \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; f_2.func_closure\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In answer to your second question, the most elegant way to do this would be to use a function that takes two parameters instead of an array:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;add = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt; a, b: a + b\nadd(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;However, using lambda here is a bit silly. Python gives us the \u0026lt;code\u0026gt;operator\u0026lt;/code\u0026gt; module, which provides a functional interface to the basic operators. The lambda above has unnecessary overhead just to call the addition operator:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; operator \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; add\nadd(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I understand that you\u0026apos;re playing around, trying to explore the language, but I can\u0026apos;t imagine a situation I would use an array of functions where Python\u0026apos;s scoping weirdness would get in the way.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you wanted, you could write a small class that uses your array-indexing syntax:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Adders\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_ inherited__\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__getitem__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, item\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt; a: a + item\n\nadders = Adders()\nadders[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;](\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;One way to sort out the scope of \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; is to generate the lambda in another scope (a closure function), handing over the necessary parameters for it to make the lambda:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;get_funky\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;i\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt; a: i+a\n\nadders=[\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;]\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; i \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;]:\n   adders[i]=get_funky(i)\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(*(ar(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; ar \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; adders))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;giving \u0026lt;code\u0026gt;5 6 7 8\u0026lt;/code\u0026gt; of course.\u0026lt;/p\u0026gt;\n    "],"id":489,"title":"What do lambda function closures capture? [duplicate]","content":"\n                    \u0026lt;div\u0026gt;\n            \u0026lt;aside class=\u0026quot;s-notice s-notice__info post-notice js-post-notice mb16\u0026quot; role=\u0026quot;status\u0026quot;\u0026gt;\n        \u0026lt;div class=\u0026quot;d-flex fd-column fw-nowrap\u0026quot;\u0026gt;\n            \u0026lt;div class=\u0026quot;d-flex fw-nowrap\u0026quot;\u0026gt;\n                \u0026lt;div class=\u0026quot;flex--item wmn0 fl1 lh-lg\u0026quot;\u0026gt;\n                    \u0026lt;div class=\u0026quot;flex--item fl1 lh-lg\u0026quot;\u0026gt;\n                        \u0026lt;b\u0026gt;This question already has answers here\u0026lt;/b\u0026gt;:\n                        \n                    \u0026lt;/div\u0026gt;\n                \u0026lt;/div\u0026gt;\n            \u0026lt;/div\u0026gt;\n                    \u0026lt;div class=\u0026quot;flex--item mb0 mt4\u0026quot;\u0026gt;\n                        \u0026lt;a href=\u0026quot;/questions/3431676/creating-functions-in-a-loop\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;Creating functions in a loop\u0026lt;/a\u0026gt;\n                            \u0026lt;span class=\u0026quot;question-originals-answer-count\u0026quot;\u0026gt;\n                                (5 answers)\n                            \u0026lt;/span\u0026gt;\n                    \u0026lt;/div\u0026gt;\n                \u0026lt;div class=\u0026quot;flex--item mb0 mt8\u0026quot;\u0026gt;Closed \u0026lt;span title=\u0026quot;2022-07-03 04:31:24Z\u0026quot; class=\u0026quot;relativetime\u0026quot;\u0026gt;6 days ago\u0026lt;/span\u0026gt;.\u0026lt;/div\u0026gt;\n        \u0026lt;/div\u0026gt;\n\u0026lt;/aside\u0026gt;\n\n    \u0026lt;/div\u0026gt;\n\n\u0026lt;p\u0026gt;Recently I started playing around with Python and I came around something peculiar in the way closures work. Consider the following code:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;adders=[\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;]\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; i \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;]:\n   adders[i]=\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt; a: i+a\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; adders[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;](\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;It builds a simple array of functions that take a single input and return that input added by a number. The functions are constructed in \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; loop where the iterator \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; runs from \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;3\u0026lt;/code\u0026gt;. For each of these numbers a \u0026lt;code\u0026gt;lambda\u0026lt;/code\u0026gt; function is created which captures \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; and adds it to the function\u0026apos;s input. The last line calls the second \u0026lt;code\u0026gt;lambda\u0026lt;/code\u0026gt; function with \u0026lt;code\u0026gt;3\u0026lt;/code\u0026gt; as a parameter. To my surprise the output was \u0026lt;code\u0026gt;6\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I expected a \u0026lt;code\u0026gt;4\u0026lt;/code\u0026gt;. My reasoning was: in Python everything is an object and thus every variable is essential a pointer to it. When creating the \u0026lt;code\u0026gt;lambda\u0026lt;/code\u0026gt; closures for \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt;, I expected it to store a pointer to the integer object currently pointed to by \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt;. That means that when \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; assigned a new integer object it shouldn\u0026apos;t effect the previously created closures. Sadly, inspecting the \u0026lt;code\u0026gt;adders\u0026lt;/code\u0026gt; array within a debugger shows that it does. All \u0026lt;code\u0026gt;lambda\u0026lt;/code\u0026gt; functions refer to the last value of \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;3\u0026lt;/code\u0026gt;, which results in \u0026lt;code\u0026gt;adders[1](3)\u0026lt;/code\u0026gt; returning \u0026lt;code\u0026gt;6\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Which make me wonder about the following:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;What do the closures capture exactly?\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;What is the most elegant way to convince the \u0026lt;code\u0026gt;lambda\u0026lt;/code\u0026gt; functions to capture the current value of \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; in a way that will not be affected when \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; changes its value?\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","slug":"what-do-lambda-function-closures-capture-duplicate-1657388161827","postType":"QUESTION","createdAt":"2022-07-09T17:36:01.000Z","updatedAt":"2022-07-09T17:36:01.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"Transpose / reshape dataframe without \"timevar\" from long to wide format","slug":"transpose-reshape-dataframe-without-\"timevar\"-from-long-to-wide-format-1657388213347"},{"title":"Sort a Map\u003cKey, Value\u003e by values","slug":"sort-a-maplesskey-valuegreater-by-values-1657387443904"},{"title":"How to sum a variable by group","slug":"how-to-sum-a-variable-by-group-1657384838148"},{"title":"How to remove the space between inline/inline-block elements?","slug":"how-to-remove-the-space-between-inlineinline-block-elements-1657384532273"},{"title":"What is the scope of variables in JavaScript?","slug":"what-is-the-scope-of-variables-in-javascript-1657384464291"},{"title":"Is it possible for flex items to align tightly to the items above them?","slug":"is-it-possible-for-flex-items-to-align-tightly-to-the-items-above-them-1657388511179"},{"title":"How to create a MySQL hierarchical recursive query?","slug":"how-to-create-a-mysql-hierarchical-recursive-query-1657387662163"},{"title":"Does JavaScript guarantee object property order?","slug":"does-javascript-guarantee-object-property-order-1657384822587"},{"title":"String.equals versus == [duplicate]","slug":"string.equals-versus-duplicate-1657387599972"},{"title":"Web-scraping JavaScript page with Python","slug":"web-scraping-javascript-page-with-python-1657388240875"},{"title":"Sorting object property by values","slug":"sorting-object-property-by-values-1657388367300"},{"title":"How to test multiple variables for equality against a single value?","slug":"how-to-test-multiple-variables-for-equality-against-a-single-value-1657384358504"},{"title":"When should I use a return statement in ES6 arrow functions","slug":"when-should-i-use-a-return-statement-in-es6-arrow-functions-1657388472113"},{"title":"How to check if element is visible after scrolling?","slug":"how-to-check-if-element-is-visible-after-scrolling-1657387987960"},{"title":"Most efficient method to groupby on an array of objects","slug":"most-efficient-method-to-groupby-on-an-array-of-objects-1657387580538"},{"title":"Ways to deal with #document under iframe","slug":"ways-to-deal-with-document-under-iframe-1657388403345"},{"title":"How can I vertically align elements in a div?","slug":"how-can-i-vertically-align-elements-in-a-div-1657385504431"},{"title":"How do I write a correct micro-benchmark in Java?","slug":"how-do-i-write-a-correct-micro-benchmark-in-java-1657384488725"},{"title":"$(document).ready equivalent without jQuery","slug":"dollar(document).ready-equivalent-without-jquery-1657388504115"},{"title":"Sort (order) data frame rows by multiple columns","slug":"sort-(order)-data-frame-rows-by-multiple-columns-1657388355671"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"what-do-lambda-function-closures-capture-duplicate-1657388161827"},"buildId":"BnkbnjkWYxefPXjTJLVVv","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>