{"pageProps":{"data":{"answer":["\n&lt;p&gt;If your goal is to use a profiler, use one of the suggested ones.&lt;/p&gt;\n\n&lt;p&gt;However, if you&apos;re in a hurry and you can manually interrupt your program under the debugger while it&apos;s being subjectively slow, there&apos;s a simple way to find performance problems.&lt;/p&gt;\n\n&lt;p&gt;Just halt it several times, and each time look at the call stack. If there is some code that is wasting some percentage of the time, 20% or 50% or whatever, that is the probability that you will catch it in the act on each sample. So, that is roughly the percentage of samples on which you will see it. There is no educated guesswork required. If you do have a guess as to what the problem is, this will prove or disprove it.&lt;/p&gt;\n\n&lt;p&gt;You may have multiple performance problems of different sizes. If you clean out any one of them, the remaining ones will take a larger percentage, and be easier to spot, on subsequent passes. This &lt;em&gt;magnification effect&lt;/em&gt;, when compounded over multiple problems, can lead to truly massive speedup factors.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Caveat&lt;/strong&gt;: Programmers tend to be skeptical of this technique unless they&apos;ve used it themselves. They will say that profilers give you this information, but that is only true if they sample the entire call stack, and then let you examine a random set of samples. (The summaries are where the insight is lost.) Call graphs don&apos;t give you the same information, because &lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;They don&apos;t summarize at the instruction level, and&lt;/li&gt;\n&lt;li&gt;They give confusing summaries in the presence of recursion.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;They will also say it only works on toy programs, when actually it works on any program, and it seems to work better on bigger programs, because they tend to have more problems to find. They will say it sometimes finds things that aren&apos;t problems, but that is only true if you see something &lt;em&gt;once&lt;/em&gt;. If you see a problem on more than one sample, it is real.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt; This can also be done on multi-thread programs if there is a way to collect call-stack samples of the thread pool at a point in time, as there is in Java.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;P.P.S&lt;/strong&gt; As a rough generality, the more layers of abstraction you have in your software, the more likely you are to find that that is the cause of performance problems (and the opportunity to get speedup).&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Added&lt;/strong&gt;: It might not be obvious, but the stack sampling technique works equally well in the presence of recursion. The reason is that the time that would be saved by removal of an instruction is approximated by the fraction of samples containing it, regardless of the number of times it may occur within a sample.&lt;/p&gt;\n\n&lt;p&gt;Another objection I often hear is: &quot;&lt;em&gt;It will stop someplace random, and it will miss the real problem&lt;/em&gt;&quot;.\nThis comes from having a prior concept of what the real problem is.\nA key property of performance problems is that they defy expectations.\nSampling tells you something is a problem, and your first reaction is disbelief.\nThat is natural, but you can be sure if it finds a problem it is real, and vice-versa.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Added&lt;/strong&gt;: Let me make a Bayesian explanation of how it works.  Suppose there is some instruction &lt;code&gt;I&lt;/code&gt; (call or otherwise) which is on the call stack some fraction &lt;code&gt;f&lt;/code&gt; of the time (and thus costs that much). For simplicity, suppose we don&apos;t know what &lt;code&gt;f&lt;/code&gt; is, but assume it is either 0.1, 0.2, 0.3, ... 0.9, 1.0, and the prior probability of each of these possibilities is 0.1, so all of these costs are equally likely a-priori.&lt;/p&gt;\n\n&lt;p&gt;Then suppose we take just 2 stack samples, and we see instruction &lt;code&gt;I&lt;/code&gt; on both samples, designated observation &lt;code&gt;o=2/2&lt;/code&gt;. This gives us new estimates of the frequency &lt;code&gt;f&lt;/code&gt; of &lt;code&gt;I&lt;/code&gt;, according to this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;Prior                                    \n&lt;span class=&quot;hljs-title&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(f=x)&lt;/span&gt; x  &lt;span class=&quot;hljs-title&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(o=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;|f=x)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(o=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;&amp;amp;&amp;amp;f=x)&lt;/span&gt;  &lt;span class=&quot;hljs-title&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(o=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;&amp;amp;&amp;amp;f &amp;gt;= x)&lt;/span&gt;  &lt;span class=&quot;hljs-title&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(f &amp;gt;= x | o=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;\n\n0.1    1     1             0.1          0.1            0.25974026\n0.1    0.9   0.81          0.081        0.181          0.47012987\n0.1    0.8   0.64          0.064        0.245          0.636363636\n0.1    0.7   0.49          0.049        0.294          0.763636364\n0.1    0.6   0.36          0.036        0.33           0.857142857\n0.1    0.5   0.25          0.025        0.355          0.922077922\n0.1    0.4   0.16          0.016        0.371          0.963636364\n0.1    0.3   0.09          0.009        0.38           0.987012987\n0.1    0.2   0.04          0.004        0.384          0.997402597\n0.1    0.1   0.01          0.001        0.385          1\n\n                  &lt;span class=&quot;hljs-title&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(o=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt; 0.385                \n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The last column says that, for example, the probability that &lt;code&gt;f&lt;/code&gt; &amp;gt;= 0.5 is 92%, up from the prior assumption of 60%.&lt;/p&gt;\n\n&lt;p&gt;Suppose the prior assumptions are different. Suppose we assume &lt;code&gt;P(f=0.1)&lt;/code&gt; is .991 (nearly certain), and all the other possibilities are almost impossible (0.001). In other words, our prior certainty is that &lt;code&gt;I&lt;/code&gt; is cheap. Then we get:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;Prior                                    \n&lt;span class=&quot;hljs-title&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(f=x)&lt;/span&gt; x  &lt;span class=&quot;hljs-title&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(o=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;|f=x)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(o=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;&amp;amp;&amp;amp; f=x)&lt;/span&gt;  &lt;span class=&quot;hljs-title&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(o=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;&amp;amp;&amp;amp;f &amp;gt;= x)&lt;/span&gt;  &lt;span class=&quot;hljs-title&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(f &amp;gt;= x | o=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;\n\n0.001  1    1              0.001        0.001          0.072727273\n0.001  0.9  0.81           0.00081      0.00181        0.131636364\n0.001  0.8  0.64           0.00064      0.00245        0.178181818\n0.001  0.7  0.49           0.00049      0.00294        0.213818182\n0.001  0.6  0.36           0.00036      0.0033         0.24\n0.001  0.5  0.25           0.00025      0.00355        0.258181818\n0.001  0.4  0.16           0.00016      0.00371        0.269818182\n0.001  0.3  0.09           0.00009      0.0038         0.276363636\n0.001  0.2  0.04           0.00004      0.00384        0.279272727\n0.991  0.1  0.01           0.00991      0.01375        1\n\n                  &lt;span class=&quot;hljs-title&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(o=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt; 0.01375                \n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Now it says &lt;code&gt;P(f &amp;gt;= 0.5)&lt;/code&gt; is 26%, up from the prior assumption of 0.6%. So Bayes allows us to update our estimate of the probable cost of &lt;code&gt;I&lt;/code&gt;. If the amount of data is small, it doesn&apos;t tell us accurately what the cost is, only that it is big enough to be worth fixing.&lt;/p&gt;\n\n&lt;p&gt;Yet another way to look at it is called the &lt;a href=&quot;http://en.wikipedia.org/wiki/Rule_of_succession&quot; rel=&quot;noreferrer&quot;&gt;Rule Of Succession&lt;/a&gt;.\nIf you flip a coin 2 times, and it comes up heads both times, what does that tell you about the probable weighting of the coin?\nThe respected way to answer is to say that it&apos;s a Beta distribution, with average value &lt;code&gt;(number of hits + 1) / (number of tries + 2) = (2+1)/(2+2) = 75%&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;(The key is that we see &lt;code&gt;I&lt;/code&gt; more than once. If we only see it once, that doesn&apos;t tell us much except that &lt;code&gt;f&lt;/code&gt; &amp;gt; 0.)&lt;/p&gt;\n\n&lt;p&gt;So, even a very small number of samples can tell us a lot about the cost of instructions that it sees. (And it will see them with a frequency, on average, proportional to their cost. If &lt;code&gt;n&lt;/code&gt; samples are taken, and &lt;code&gt;f&lt;/code&gt; is the cost, then &lt;code&gt;I&lt;/code&gt; will appear on &lt;code&gt;nf+/-sqrt(nf(1-f))&lt;/code&gt; samples. Example, &lt;code&gt;n=10&lt;/code&gt;, &lt;code&gt;f=0.3&lt;/code&gt;, that is &lt;code&gt;3+/-1.4&lt;/code&gt; samples.)&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;Added&lt;/strong&gt;: To give an intuitive feel for the difference between measuring and random stack sampling:&lt;br&gt;\nThere are profilers now that sample the stack, even on wall-clock time, but &lt;em&gt;what comes out&lt;/em&gt; is measurements (or hot path, or hot spot, from which a &quot;bottleneck&quot; can easily hide). What they don&apos;t show you (and they easily could) is the actual samples themselves. And if your goal is to &lt;em&gt;find&lt;/em&gt; the bottleneck, the number of them you need to see is, &lt;em&gt;on average&lt;/em&gt;, 2 divided by the fraction of time it takes.\nSo if it takes 30% of time, 2/.3 = 6.7 samples, on average, will show it, and the chance that 20 samples will show it is 99.2%.&lt;/p&gt;\n\n&lt;p&gt;Here is an off-the-cuff illustration of the difference between examining measurements and examining stack samples.\nThe bottleneck could be one big blob like this, or numerous small ones, it makes no difference.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/FpWuS.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/FpWuS.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Measurement is horizontal; it tells you what fraction of time specific routines take.\nSampling is vertical.\nIf there is any way to avoid what the whole program is doing at that moment, &lt;em&gt;and if you see it on a second sample&lt;/em&gt;, you&apos;ve found the bottleneck.\nThat&apos;s what makes the difference - seeing the whole reason for the time being spent, not just how much.&lt;/p&gt;\n    ","\n&lt;p&gt;Use &lt;a href=&quot;http://en.wikipedia.org/wiki/Valgrind&quot; rel=&quot;nofollow noreferrer&quot;&gt;Valgrind&lt;/a&gt; with the following options:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;valgrind --tool=callgrind ./(Your binary)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This generates a file called &lt;code&gt;callgrind.out.x&lt;/code&gt;. Use the &lt;code&gt;kcachegrind&lt;/code&gt; tool to read this file. It will give you a graphical analysis of things with results like which lines cost how much.&lt;/p&gt;\n    ","\n&lt;p&gt;I assume you&apos;re using GCC. The standard solution would be to profile with &lt;a href=&quot;http://www.math.utah.edu/docs/info/gprof_toc.html&quot; rel=&quot;noreferrer&quot;&gt;gprof&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;Be sure to add &lt;code&gt;-pg&lt;/code&gt; to compilation before profiling:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;cc -o myprog myprog.c utils.c -g -pg\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I haven&apos;t tried it yet but I&apos;ve heard good things about &lt;a href=&quot;https://github.com/gperftools/gperftools&quot; rel=&quot;noreferrer&quot;&gt;google-perftools&lt;/a&gt;. It is definitely worth a try.&lt;/p&gt;\n\n&lt;p&gt;Related question &lt;a href=&quot;https://stackoverflow.com/questions/56672/how-do-you-profile-your-code&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;A few other buzzwords if &lt;code&gt;gprof&lt;/code&gt; does not do the job for you: &lt;a href=&quot;http://en.wikipedia.org/wiki/Valgrind&quot; rel=&quot;noreferrer&quot;&gt;Valgrind&lt;/a&gt;, Intel &lt;a href=&quot;http://en.wikipedia.org/wiki/VTune&quot; rel=&quot;noreferrer&quot;&gt;VTune&lt;/a&gt;, Sun &lt;a href=&quot;http://en.wikipedia.org/wiki/DTrace&quot; rel=&quot;noreferrer&quot;&gt;DTrace&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;Newer kernels (e.g. the latest Ubuntu kernels) come with the new &apos;perf&apos; tools (&lt;code&gt;apt-get install linux-tools&lt;/code&gt;) AKA &lt;a href=&quot;https://en.wikipedia.org/wiki/Perf_(Linux)&quot; rel=&quot;noreferrer&quot;&gt;perf_events&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;These come with classic sampling profilers (&lt;a href=&quot;http://manpages.ubuntu.com/manpages/trusty/man1/perf.1.html&quot; rel=&quot;noreferrer&quot;&gt;man-page&lt;/a&gt;) as well as the awesome &lt;a href=&quot;http://web.archive.org/web/20090922171904/http://blog.fenrus.org/?p=5&quot; rel=&quot;noreferrer&quot;&gt;timechart&lt;/a&gt;!&lt;/p&gt;\n\n&lt;p&gt;The important thing is that these tools can be &lt;strong&gt;system profiling&lt;/strong&gt; and not just process profiling - they can show the interaction between threads, processes and the kernel and let you understand the scheduling and I/O dependencies between processes.&lt;/p&gt;\n\n&lt;p&gt;&lt;img src=&quot;https://i.stack.imgur.com/FMYp4.png&quot; alt=&quot;Alt text&quot;&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;The answer to run &lt;code&gt;valgrind --tool=callgrind&lt;/code&gt; is not quite complete without some options. We usually do not want to profile 10 minutes of slow startup time under Valgrind and want to profile our program when it is doing some task.&lt;/p&gt;\n\n&lt;p&gt;So this is what I recommend. Run program first:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;valgrind --tool=callgrind --dump-instr=yes -v --instr-atstart=no ./binary &amp;gt; tmp\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Now when it works and we want to start profiling we should run in another window:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;callgrind_control -i on\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This turns profiling on. To turn it off and stop whole task we might use:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;callgrind_control -k\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Now we have some files named callgrind.out.* in current directory. To see profiling results use:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;kcachegrind callgrind.out.*\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I recommend in next window to click on &quot;Self&quot; column header, otherwise it shows that &quot;main()&quot; is most time consuming task. &quot;Self&quot; shows how much each function itself took time, not together with dependents. &lt;/p&gt;\n    ","\n&lt;p&gt;I would use Valgrind and Callgrind as a base for my profiling tool suite. What is important to know is that Valgrind is basically a Virtual Machine:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;(wikipedia) Valgrind is in essence a virtual\n  machine using just-in-time (JIT)\n  compilation techniques, including\n  dynamic recompilation. Nothing from\n  the original program ever gets run\n  directly on the host processor.\n  Instead, Valgrind first translates the\n  program into a temporary, simpler form\n  called Intermediate Representation\n  (IR), which is a processor-neutral,\n  SSA-based form. After the conversion,\n  a tool (see below) is free to do\n  whatever transformations it would like\n  on the IR, before Valgrind translates\n  the IR back into machine code and lets\n  the host processor run it. &lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Callgrind is a profiler build upon that. Main benefit is that you don&apos;t have to run your aplication for hours to get reliable result. Even one second run is sufficient to get rock-solid, reliable results, because Callgrind is a &lt;strong&gt;non-probing&lt;/strong&gt; profiler. &lt;/p&gt;\n\n&lt;p&gt;Another tool build upon Valgrind is Massif. I use it to profile heap memory usage. It works great. What it does is that it gives you snapshots of memory usage -- detailed information WHAT holds WHAT percentage of memory, and WHO had put it there. Such information is available at different points of time of application run.&lt;/p&gt;\n    ","\n&lt;p&gt;This is a response to &lt;a href=&quot;https://stackoverflow.com/a/375930/321731&quot;&gt;Nazgob&apos;s Gprof answer&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;I&apos;ve been using Gprof the last couple of days and have already found three significant limitations, one of which I&apos;ve not seen documented anywhere else (yet):&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;It doesn&apos;t work properly on multi-threaded code, unless you use a &lt;a href=&quot;http://sam.zoy.org/writings/programming/gprof.html&quot; rel=&quot;noreferrer&quot;&gt;workaround&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;The call graph gets confused by function pointers. Example: I have a function called &lt;code&gt;multithread()&lt;/code&gt; which enables me to multi-thread a specified function over a specified array (both passed as arguments). Gprof however, views all calls to &lt;code&gt;multithread()&lt;/code&gt; as equivalent for the purposes of computing time spent in children. Since some functions I pass to &lt;code&gt;multithread()&lt;/code&gt; take much longer than others my call graphs are mostly useless. (To those wondering if threading is the issue here: no, &lt;code&gt;multithread()&lt;/code&gt; can optionally, and did in this case, run everything sequentially on the calling thread only).&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;It says &lt;a href=&quot;http://www.cs.utah.edu/dept/old/texinfo/as/gprof.html&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt; that &quot;... the number-of-calls figures are derived by counting, not sampling. They are completely accurate...&quot;. Yet I find my call graph giving me 5345859132+784984078 as call stats to my most-called function, where the first number is supposed to be direct calls, and the second recursive calls (which are all from itself). Since this implied I had a bug, I put in long (64-bit) counters into the code and did the same run again. My counts: 5345859132 direct, and 78094395406 self-recursive calls.  There are a lot of digits there, so I&apos;ll point out the recursive calls I measure are 78bn, versus 784m from Gprof: a factor of 100 different. Both runs were single threaded and unoptimised code, one compiled &lt;code&gt;-g&lt;/code&gt; and the other &lt;code&gt;-pg&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;This was GNU &lt;a href=&quot;https://en.wikipedia.org/wiki/Gprof&quot; rel=&quot;noreferrer&quot;&gt;Gprof&lt;/a&gt; (GNU Binutils for Debian) 2.18.0.20080103 running under 64-bit Debian Lenny, if that helps anyone.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Survey of C++ profiling techniques: gprof vs valgrind vs perf vs gperftools&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;In this answer, I will use several different tools to a analyze a few very simple test programs, in order to concretely compare how those tools work.&lt;/p&gt;\n&lt;p&gt;The following test program is very simple and does the following:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;&lt;code&gt;main&lt;/code&gt; calls &lt;code&gt;fast&lt;/code&gt; and &lt;code&gt;maybe_slow&lt;/code&gt; 3 times, one of the &lt;code&gt;maybe_slow&lt;/code&gt; calls being slow&lt;/p&gt;\n&lt;p&gt;The slow call of &lt;code&gt;maybe_slow&lt;/code&gt; is 10x longer, and dominates runtime if we consider calls to the child function &lt;code&gt;common&lt;/code&gt;. Ideally, the profiling tool will be able to point us to the specific slow call.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;both &lt;code&gt;fast&lt;/code&gt; and &lt;code&gt;maybe_slow&lt;/code&gt; call &lt;code&gt;common&lt;/code&gt;, which accounts for the bulk of the program execution&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;The program interface is:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;./main.out [n [seed]]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;and the program does &lt;code&gt;O(n^2)&lt;/code&gt; loops in total. &lt;code&gt;seed&lt;/code&gt; is just to get different output without affecting runtime.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;main.c&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;inttypes.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-type&quot;&gt;uint64_t&lt;/span&gt; __attribute__ ((noinline)) &lt;span class=&quot;hljs-built_in&quot;&gt;common&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;uint64_t&lt;/span&gt; n, &lt;span class=&quot;hljs-type&quot;&gt;uint64_t&lt;/span&gt; seed) {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;uint64_t&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; n; ++i) {\n        seed = (seed * seed) - (&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; * seed) + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; seed;\n}\n\n&lt;span class=&quot;hljs-type&quot;&gt;uint64_t&lt;/span&gt; __attribute__ ((noinline)) &lt;span class=&quot;hljs-built_in&quot;&gt;fast&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;uint64_t&lt;/span&gt; n, &lt;span class=&quot;hljs-type&quot;&gt;uint64_t&lt;/span&gt; seed) {\n    &lt;span class=&quot;hljs-type&quot;&gt;uint64_t&lt;/span&gt; max = (n / &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;) + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;uint64_t&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; max; ++i) {\n        seed = &lt;span class=&quot;hljs-built_in&quot;&gt;common&lt;/span&gt;(n, (seed * seed) - (&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; * seed) + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; seed;\n}\n\n&lt;span class=&quot;hljs-type&quot;&gt;uint64_t&lt;/span&gt; __attribute__ ((noinline)) &lt;span class=&quot;hljs-built_in&quot;&gt;maybe_slow&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;uint64_t&lt;/span&gt; n, &lt;span class=&quot;hljs-type&quot;&gt;uint64_t&lt;/span&gt; seed, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; is_slow) {\n    &lt;span class=&quot;hljs-type&quot;&gt;uint64_t&lt;/span&gt; max = n;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (is_slow) {\n        max *= &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;uint64_t&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; max; ++i) {\n        seed = &lt;span class=&quot;hljs-built_in&quot;&gt;common&lt;/span&gt;(n, (seed * seed) - (&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; * seed) + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; seed;\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; **argv)&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;uint64_t&lt;/span&gt; n, seed;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (argc &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) {\n        n = &lt;span class=&quot;hljs-built_in&quot;&gt;strtoll&lt;/span&gt;(argv[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;], &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);\n    } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {\n        n = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (argc &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) {\n        seed = &lt;span class=&quot;hljs-built_in&quot;&gt;strtoll&lt;/span&gt;(argv[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;], &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);\n    } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {\n        seed = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n    }\n    seed += &lt;span class=&quot;hljs-built_in&quot;&gt;maybe_slow&lt;/span&gt;(n, seed, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);\n    seed += &lt;span class=&quot;hljs-built_in&quot;&gt;fast&lt;/span&gt;(n, seed);\n    seed += &lt;span class=&quot;hljs-built_in&quot;&gt;maybe_slow&lt;/span&gt;(n, seed, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);\n    seed += &lt;span class=&quot;hljs-built_in&quot;&gt;fast&lt;/span&gt;(n, seed);\n    seed += &lt;span class=&quot;hljs-built_in&quot;&gt;maybe_slow&lt;/span&gt;(n, seed, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);\n    seed += &lt;span class=&quot;hljs-built_in&quot;&gt;fast&lt;/span&gt;(n, seed);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%&quot;&lt;/span&gt; PRIX64 &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n&quot;&lt;/span&gt;, seed);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; EXIT_SUCCESS;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;gprof&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;gprof requires recompiling the software with instrumentation, and it also uses a sampling approach together with that instrumentation. It therefore strikes a balance between accuracy (sampling is not always fully accurate and can skip functions) and execution slowdown (instrumentation and sampling are relatively fast techniques that don&apos;t slow down execution very much).&lt;/p&gt;\n&lt;p&gt;gprof is built-into GCC/binutils, so all we have to do is to compile with the &lt;code&gt;-pg&lt;/code&gt; option to enable gprof. We then run the program normally with a size CLI parameter that produces a run of reasonable duration of a few seconds (&lt;code&gt;10000&lt;/code&gt;):&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;gcc -pg -ggdb3 -O3 -std=c99 -Wall -Wextra -pedantic -o main.out main.c\ntime ./main.out &lt;span class=&quot;hljs-number&quot;&gt;10000&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;For educational reasons, we will also do a run without optimizations enabled. Note that this is useless in practice, as you normally only care about optimizing the performance of the optimized program:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;gcc -pg -ggdb3 -O0 -std=c99 -Wall -Wextra -pedantic -o main.out main.c\n./main.out &lt;span class=&quot;hljs-number&quot;&gt;10000&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;First, &lt;code&gt;time&lt;/code&gt; tells us that the execution time with and without &lt;code&gt;-pg&lt;/code&gt; were the same, which is great: no slowdown! I have however seen accounts of 2x - 3x slowdowns on complex software, e.g. as &lt;a href=&quot;https://gem5.atlassian.net/browse/GEM5-337&quot; rel=&quot;nofollow noreferrer&quot;&gt;shown in this ticket&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;Because we compiled with &lt;code&gt;-pg&lt;/code&gt;, running the program produces a file &lt;code&gt;gmon.out&lt;/code&gt; file containing the profiling data.&lt;/p&gt;\n&lt;p&gt;We can observe that file graphically with &lt;code&gt;gprof2dot&lt;/code&gt; as asked at: &lt;a href=&quot;https://stackoverflow.com/questions/2439060/is-it-possible-to-get-a-graphical-representation-of-gprof-results&quot;&gt;Is it possible to get a graphical representation of gprof results?&lt;/a&gt;&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;sudo apt install graphviz\npython3 -m pip install --user gprof2dot\ngprof main.out &amp;gt; main.gprof\ngprof2dot &amp;lt; main.gprof | dot -Tsvg -o output.svg\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Here, the &lt;code&gt;gprof&lt;/code&gt; tool reads the &lt;code&gt;gmon.out&lt;/code&gt; trace information, and generates a human readable report in &lt;code&gt;main.gprof&lt;/code&gt;, which &lt;code&gt;gprof2dot&lt;/code&gt; then reads to generate a graph.&lt;/p&gt;\n&lt;p&gt;The source for gprof2dot is at: &lt;a href=&quot;https://github.com/jrfonseca/gprof2dot&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://github.com/jrfonseca/gprof2dot&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;We observe the following for the &lt;code&gt;-O0&lt;/code&gt; run:&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/mM8NQ.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/mM8NQ.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;and for the &lt;code&gt;-O3&lt;/code&gt; run:&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/31VNy.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/31VNy.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;The &lt;code&gt;-O0&lt;/code&gt; output is pretty much self-explanatory. For example, it shows that the 3 &lt;code&gt;maybe_slow&lt;/code&gt; calls and their child calls take up 97.56% of the total runtime, although execution of &lt;code&gt;maybe_slow&lt;/code&gt; itself without children accounts for 0.00% of the total execution time, i.e. almost all the time spent in that function was spent on child calls.&lt;/p&gt;\n&lt;p&gt;TODO: why is &lt;code&gt;main&lt;/code&gt; missing from the &lt;code&gt;-O3&lt;/code&gt; output, even though I can see it on a &lt;code&gt;bt&lt;/code&gt; in GDB? &lt;a href=&quot;https://stackoverflow.com/questions/39041871/missing-function-from-gprof-output&quot;&gt;Missing function from GProf output&lt;/a&gt; I think it is because gprof is also sampling based in addition to its compiled instrumentation, and the &lt;code&gt;-O3&lt;/code&gt; &lt;code&gt;main&lt;/code&gt; is just too fast and got no samples.&lt;/p&gt;\n&lt;p&gt;I choose SVG output instead of PNG because the SVG is searchable with &lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;F&lt;/kbd&gt; and the file size can be about 10x smaller. Also, the width and height of the generated image can be humoungous with tens of thousands of pixels for complex software, and GNOME &lt;code&gt;eog&lt;/code&gt; 3.28.1 bugs out in that case for PNGs, while SVGs get opened by my browser automatically. gimp 2.8 worked well though, see also:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;https://askubuntu.com/questions/1112641/how-to-view-extremely-large-images&quot;&gt;https://askubuntu.com/questions/1112641/how-to-view-extremely-large-images&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://unix.stackexchange.com/questions/77968/viewing-large-image-on-linux&quot;&gt;https://unix.stackexchange.com/questions/77968/viewing-large-image-on-linux&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://superuser.com/questions/356038/viewer-for-huge-images-under-linux-100-mp-color-images&quot;&gt;https://superuser.com/questions/356038/viewer-for-huge-images-under-linux-100-mp-color-images&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;but even then, you will be dragging the image around a lot to find what you want, see e.g. this image from a &quot;real&quot; software example taken from &lt;a href=&quot;https://gem5.atlassian.net/browse/GEM5-337&quot; rel=&quot;nofollow noreferrer&quot;&gt;this ticket&lt;/a&gt;:&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/Nvg9G.jpg&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/Nvg9G.jpg&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Can you find the most critical call stack easily with all those tiny unsorted spaghetti lines going over one another? There might be better &lt;code&gt;dot&lt;/code&gt; options I&apos;m sure, but I don&apos;t want to go there now. What we really need is a proper dedicated viewer for it, but I haven&apos;t found one yet:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/7274095/view-gprof-output-in-kcachegrind&quot;&gt;View gprof output in kcachegrind&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1576666/which-is-the-best-replacement-for-kprof&quot;&gt;Which is the best replacement for KProf?&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;You can however use the color map to mitigate those problems a bit. For example, on the previous huge image, I finally managed to find the critical path on the left when I made the brilliant deduction that green comes after red, followed finally by darker and darker blue.&lt;/p&gt;\n&lt;p&gt;Alternatively, we can also observe the text output of the &lt;code&gt;gprof&lt;/code&gt; built-in binutils tool which we previously saved at:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;cat main.gprof\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;By default, this produces an extremely verbose output that explains what the output data means. Since I can&apos;t explain better than that, I&apos;ll let you read it yourself.&lt;/p&gt;\n&lt;p&gt;Once you have understood the data output format, you can reduce verbosity to show just the data without the tutorial with the &lt;code&gt;-b&lt;/code&gt; option:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;gprof -b main.out\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In our example, outputs were for &lt;code&gt;-O0&lt;/code&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;Flat profile:\n\nEach sample counts as &lt;span class=&quot;hljs-number&quot;&gt;0.01&lt;/span&gt; seconds.\n  %   cumulative   self              self     total           \n time   seconds   seconds    calls   s/call   s/call  name    \n&lt;span class=&quot;hljs-number&quot;&gt;100.35&lt;/span&gt;      &lt;span class=&quot;hljs-number&quot;&gt;3.67&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;3.67&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;123003&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;  common\n  &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;      &lt;span class=&quot;hljs-number&quot;&gt;3.67&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;        &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;0.03&lt;/span&gt;  fast\n  &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;      &lt;span class=&quot;hljs-number&quot;&gt;3.67&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;        &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;1.19&lt;/span&gt;  maybe_slow\n\n            Call graph\n\n\ngranularity: each sample hit covers &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;byte&lt;/span&gt;(s) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0.27&lt;/span&gt;% of &lt;span class=&quot;hljs-number&quot;&gt;3.67&lt;/span&gt; seconds\n\nindex % time    self  children    called     name\n                &lt;span class=&quot;hljs-number&quot;&gt;0.09&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;3003&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;123003&lt;/span&gt;      fast [&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;]\n                &lt;span class=&quot;hljs-number&quot;&gt;3.58&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;120000&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;123003&lt;/span&gt;      maybe_slow [&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]\n[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]    &lt;span class=&quot;hljs-number&quot;&gt;100.0&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;3.67&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;123003&lt;/span&gt;         common [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]\n-----------------------------------------------\n                                                 &amp;lt;spontaneous&amp;gt;\n[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]    &lt;span class=&quot;hljs-number&quot;&gt;100.0&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;3.67&lt;/span&gt;                 main [&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]\n                &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;3.58&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;           maybe_slow [&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]\n                &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.09&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;           fast [&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;]\n-----------------------------------------------\n                &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;3.58&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;           main [&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]\n[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]     &lt;span class=&quot;hljs-number&quot;&gt;97.6&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;3.58&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;         maybe_slow [&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]\n                &lt;span class=&quot;hljs-number&quot;&gt;3.58&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;120000&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;123003&lt;/span&gt;      common [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]\n-----------------------------------------------\n                &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.09&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;           main [&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]\n[&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;]      &lt;span class=&quot;hljs-number&quot;&gt;2.4&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.09&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;         fast [&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;]\n                &lt;span class=&quot;hljs-number&quot;&gt;0.09&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;3003&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;123003&lt;/span&gt;      common [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]\n-----------------------------------------------\n\nIndex by function name\n\n   [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] common                  [&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;] fast                    [&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;] maybe_slow\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;and for &lt;code&gt;-O3&lt;/code&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;Flat profile:\n\nEach sample counts as &lt;span class=&quot;hljs-number&quot;&gt;0.01&lt;/span&gt; seconds.\n  %   cumulative   self              self     total           \n time   seconds   seconds    calls  us/call  us/call  name    \n&lt;span class=&quot;hljs-number&quot;&gt;100.52&lt;/span&gt;      &lt;span class=&quot;hljs-number&quot;&gt;1.84&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;1.84&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;123003&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;14.96&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;14.96&lt;/span&gt;  common\n\n            Call graph\n\n\ngranularity: each sample hit covers &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;byte&lt;/span&gt;(s) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0.54&lt;/span&gt;% of &lt;span class=&quot;hljs-number&quot;&gt;1.84&lt;/span&gt; seconds\n\nindex % time    self  children    called     name\n                &lt;span class=&quot;hljs-number&quot;&gt;0.04&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;3003&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;123003&lt;/span&gt;      fast [&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]\n                &lt;span class=&quot;hljs-number&quot;&gt;1.79&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;120000&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;123003&lt;/span&gt;      maybe_slow [&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]\n[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]    &lt;span class=&quot;hljs-number&quot;&gt;100.0&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;1.84&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;123003&lt;/span&gt;         common [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]\n-----------------------------------------------\n                                                 &amp;lt;spontaneous&amp;gt;\n[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]     &lt;span class=&quot;hljs-number&quot;&gt;97.6&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;1.79&lt;/span&gt;                 maybe_slow [&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]\n                &lt;span class=&quot;hljs-number&quot;&gt;1.79&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;120000&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;123003&lt;/span&gt;      common [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]\n-----------------------------------------------\n                                                 &amp;lt;spontaneous&amp;gt;\n[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]      &lt;span class=&quot;hljs-number&quot;&gt;2.4&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.04&lt;/span&gt;                 fast [&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]\n                &lt;span class=&quot;hljs-number&quot;&gt;0.04&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;3003&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;123003&lt;/span&gt;      common [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]\n-----------------------------------------------\n\nIndex by function name\n\n   [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] common\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;As a very quick summary for each section e.g.:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;                &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;3.58&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;           main [&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]\n[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]     &lt;span class=&quot;hljs-number&quot;&gt;97.6&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;3.58&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;         maybe_slow [&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]\n                &lt;span class=&quot;hljs-number&quot;&gt;3.58&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;120000&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;123003&lt;/span&gt;      common [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;centers around the function that is left indented (&lt;code&gt;maybe_flow&lt;/code&gt;). &lt;code&gt;[3]&lt;/code&gt; is the ID of that function. Above the function, are its callers, and below it the callees.&lt;/p&gt;\n&lt;p&gt;For &lt;code&gt;-O3&lt;/code&gt;, see here like in the graphical output that &lt;code&gt;maybe_slow&lt;/code&gt; and &lt;code&gt;fast&lt;/code&gt; don&apos;t have a known parent, which is what the documentation says that &lt;code&gt;&amp;lt;spontaneous&amp;gt;&lt;/code&gt; means.&lt;/p&gt;\n&lt;p&gt;I&apos;m not sure if there is a nice way to do line-by-line profiling with gprof: &lt;a href=&quot;https://stackoverflow.com/questions/9608949/gprof-time-spent-in-particular-lines-of-code&quot;&gt;`gprof` time spent in particular lines of code&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;valgrind callgrind&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;valgrind runs the program through the valgrind virtual machine. This makes the profiling very accurate, but it also produces a very large slowdown of the program. I have also mentioned kcachegrind previously at: &lt;a href=&quot;https://stackoverflow.com/questions/517589/tools-to-get-a-pictorial-function-call-graph-of-code/31190167#31190167&quot;&gt;Tools to get a pictorial function call graph of code&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;callgrind is the valgrind&apos;s tool to profile code and kcachegrind is a KDE program that can visualize cachegrind output.&lt;/p&gt;\n&lt;p&gt;First we have to remove the &lt;code&gt;-pg&lt;/code&gt; flag to go back to normal compilation, otherwise the run actually fails with &lt;a href=&quot;https://stackoverflow.com/questions/2146082/valgrind-profiling-timer-expired&quot;&gt;&lt;code&gt;Profiling timer expired&lt;/code&gt;&lt;/a&gt;, and yes, this is so common that I did and there was a Stack Overflow question for it.&lt;/p&gt;\n&lt;p&gt;So we compile and run as:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;sudo apt install kcachegrind valgrind\ngcc -ggdb3 -O3 -std=c99 -Wall -Wextra -pedantic -o main.out main.c\ntime valgrind --tool=callgrind valgrind --dump-instr=yes \\\n  --collect-jumps=yes ./main.out &lt;span class=&quot;hljs-number&quot;&gt;10000&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;I enable &lt;code&gt;--dump-instr=yes --collect-jumps=yes&lt;/code&gt; because this also dumps information that enables us to view a per assembly line breakdown of performance, at a relatively small added overhead cost.&lt;/p&gt;\n&lt;p&gt;Off the bat, &lt;code&gt;time&lt;/code&gt; tells us that the program took 29.5 seconds to execute, so we had a slowdown of about 15x on this example. Clearly, this slowdown is going to be a serious limitation for larger workloads. On the &quot;real world software example&quot; &lt;a href=&quot;https://gem5.atlassian.net/browse/GEM5-337&quot; rel=&quot;nofollow noreferrer&quot;&gt;mentioned here&lt;/a&gt;, I observed a slowdown of 80x.&lt;/p&gt;\n&lt;p&gt;The run generates a profile data file named &lt;code&gt;callgrind.out.&amp;lt;pid&amp;gt;&lt;/code&gt; e.g. &lt;code&gt;callgrind.out.8554&lt;/code&gt; in my case. We view that file with:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;kcachegrind callgrind.out&lt;span class=&quot;hljs-number&quot;&gt;.8554&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;which shows a GUI that contains data similar to the textual gprof output:&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/v1kfK.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/v1kfK.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Also, if we go on the bottom right &quot;Call Graph&quot; tab, we see a call graph which we can export by right clicking it to obtain the following image with unreasonable amounts of white border :-)&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/ZTdAJ.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/ZTdAJ.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;I think &lt;code&gt;fast&lt;/code&gt; is not showing on that graph because kcachegrind must have simplified the visualization because that call takes up too little time, this will likely be the behavior you want on a real program. The right click menu has some settings to control when to cull such nodes, but I couldn&apos;t get it to show such a short call after a quick attempt. If I click on &lt;code&gt;fast&lt;/code&gt; on the left window, it does show a call graph with &lt;code&gt;fast&lt;/code&gt;, so that stack was actually captured. No one had yet found a way to show the complete graph call graph: &lt;a href=&quot;https://stackoverflow.com/questions/33769323/make-callgrind-show-all-function-calls-in-the-kcachegrind-callgraph&quot;&gt;Make callgrind show all function calls in the kcachegrind callgraph&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;TODO on complex C++ software, I see some entries of type &lt;code&gt;&amp;lt;cycle N&amp;gt;&lt;/code&gt;, e.g. &lt;code&gt;&amp;lt;cycle 11&amp;gt;&lt;/code&gt; where I&apos;d expect function names, what does that mean? I noticed there is a &quot;Cycle Detection&quot; button to toggle that on and off, but what does it mean?&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;&lt;code&gt;perf&lt;/code&gt; from &lt;code&gt;linux-tools&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;perf&lt;/code&gt; seems to use exclusively Linux kernel sampling mechanisms. This makes it very simple to setup, but also not fully accurate.&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;sudo apt install linux-tools\ntime perf record -g ./main.out &lt;span class=&quot;hljs-number&quot;&gt;10000&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This added 0.2s to execution, so we are fine time-wise, but I still don&apos;t see much of interest, after expanding the &lt;code&gt;common&lt;/code&gt; node with the keyboard right arrow:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;Samples: &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;K of event &lt;span class=&quot;hljs-string&quot;&gt;&apos;cycles:uppp&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-function&quot;&gt;Event &lt;span class=&quot;hljs-title&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(approx.)&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;6228527608&lt;/span&gt;     \n  Children      Self  Command   Shared Object     Symbol                  \n-   &lt;span class=&quot;hljs-number&quot;&gt;99.98&lt;/span&gt;%    &lt;span class=&quot;hljs-number&quot;&gt;99.88&lt;/span&gt;%  main.out  main.out          [.] common              \n     common                                                               \n     &lt;span class=&quot;hljs-number&quot;&gt;0.11&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.11&lt;/span&gt;%  main.out  [kernel]          [k] &lt;span class=&quot;hljs-number&quot;&gt;0xffffffff8a6009e7&lt;/span&gt;  \n     &lt;span class=&quot;hljs-number&quot;&gt;0.01&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.01&lt;/span&gt;%  main.out  [kernel]          [k] &lt;span class=&quot;hljs-number&quot;&gt;0xffffffff8a600158&lt;/span&gt;  \n     &lt;span class=&quot;hljs-number&quot;&gt;0.01&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  [unknown]         [k] &lt;span class=&quot;hljs-number&quot;&gt;0x0000000000000040&lt;/span&gt;  \n     &lt;span class=&quot;hljs-number&quot;&gt;0.01&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  ld&lt;span class=&quot;hljs-number&quot;&gt;-2.27&lt;/span&gt;.so        [.] _dl_sysdep_start    \n     &lt;span class=&quot;hljs-number&quot;&gt;0.01&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  ld&lt;span class=&quot;hljs-number&quot;&gt;-2.27&lt;/span&gt;.so        [.] dl_main             \n     &lt;span class=&quot;hljs-number&quot;&gt;0.01&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  ld&lt;span class=&quot;hljs-number&quot;&gt;-2.27&lt;/span&gt;.so        [.] mprotect            \n     &lt;span class=&quot;hljs-number&quot;&gt;0.01&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  ld&lt;span class=&quot;hljs-number&quot;&gt;-2.27&lt;/span&gt;.so        [.] _dl_map_object      \n     &lt;span class=&quot;hljs-number&quot;&gt;0.01&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  ld&lt;span class=&quot;hljs-number&quot;&gt;-2.27&lt;/span&gt;.so        [.] _xstat              \n     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  ld&lt;span class=&quot;hljs-number&quot;&gt;-2.27&lt;/span&gt;.so        [.] __GI___tunables_init\n     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  [unknown]         [.] &lt;span class=&quot;hljs-number&quot;&gt;0x2f3d4f4944555453&lt;/span&gt;  \n     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  [unknown]         [.] &lt;span class=&quot;hljs-number&quot;&gt;0x00007fff3cfc57ac&lt;/span&gt;  \n     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  ld&lt;span class=&quot;hljs-number&quot;&gt;-2.27&lt;/span&gt;.so        [.] _start              \n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;So then I try to benchmark the &lt;code&gt;-O0&lt;/code&gt; program to see if that shows anything, and only now, at last, do I see a call graph:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;Samples: &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;K of event &lt;span class=&quot;hljs-string&quot;&gt;&apos;cycles:uppp&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-function&quot;&gt;Event &lt;span class=&quot;hljs-title&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(approx.)&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;12438962281&lt;/span&gt;   \n  Children      Self  Command   Shared Object     Symbol                  \n+   &lt;span class=&quot;hljs-number&quot;&gt;99.99&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  [unknown]         [.] &lt;span class=&quot;hljs-number&quot;&gt;0x04be258d4c544155&lt;/span&gt;  \n+   &lt;span class=&quot;hljs-number&quot;&gt;99.99&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  libc&lt;span class=&quot;hljs-number&quot;&gt;-2.27&lt;/span&gt;.so      [.] __libc_start_main   \n-   &lt;span class=&quot;hljs-number&quot;&gt;99.99&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  main.out          [.] main                \n   - main                                                                 \n      - &lt;span class=&quot;hljs-number&quot;&gt;97.54&lt;/span&gt;% maybe_slow                                                 \n           common                                                         \n      - &lt;span class=&quot;hljs-number&quot;&gt;2.45&lt;/span&gt;% fast                                                        \n           common                                                         \n+   &lt;span class=&quot;hljs-number&quot;&gt;99.96&lt;/span&gt;%    &lt;span class=&quot;hljs-number&quot;&gt;99.85&lt;/span&gt;%  main.out  main.out          [.] common              \n+   &lt;span class=&quot;hljs-number&quot;&gt;97.54&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.03&lt;/span&gt;%  main.out  main.out          [.] maybe_slow          \n+    &lt;span class=&quot;hljs-number&quot;&gt;2.45&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  main.out          [.] fast                \n     &lt;span class=&quot;hljs-number&quot;&gt;0.11&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.11&lt;/span&gt;%  main.out  [kernel]          [k] &lt;span class=&quot;hljs-number&quot;&gt;0xffffffff8a6009e7&lt;/span&gt;  \n     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  [unknown]         [k] &lt;span class=&quot;hljs-number&quot;&gt;0x0000000000000040&lt;/span&gt;  \n     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  ld&lt;span class=&quot;hljs-number&quot;&gt;-2.27&lt;/span&gt;.so        [.] _dl_sysdep_start    \n     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  ld&lt;span class=&quot;hljs-number&quot;&gt;-2.27&lt;/span&gt;.so        [.] dl_main             \n     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  ld&lt;span class=&quot;hljs-number&quot;&gt;-2.27&lt;/span&gt;.so        [.] _dl_lookup_symbol_x \n     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  [kernel]          [k] &lt;span class=&quot;hljs-number&quot;&gt;0xffffffff8a600158&lt;/span&gt;  \n     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  ld&lt;span class=&quot;hljs-number&quot;&gt;-2.27&lt;/span&gt;.so        [.] mmap64              \n     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  ld&lt;span class=&quot;hljs-number&quot;&gt;-2.27&lt;/span&gt;.so        [.] _dl_map_object      \n     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  ld&lt;span class=&quot;hljs-number&quot;&gt;-2.27&lt;/span&gt;.so        [.] __GI___tunables_init\n     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  [unknown]         [.] &lt;span class=&quot;hljs-number&quot;&gt;0x552e53555f6e653d&lt;/span&gt;  \n     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  [unknown]         [.] &lt;span class=&quot;hljs-number&quot;&gt;0x00007ffe1cf20fdb&lt;/span&gt;  \n     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%     &lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;%  main.out  ld&lt;span class=&quot;hljs-number&quot;&gt;-2.27&lt;/span&gt;.so        [.] _start              \n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;TODO: what happened on the &lt;code&gt;-O3&lt;/code&gt; execution? Is it simply that &lt;code&gt;maybe_slow&lt;/code&gt; and &lt;code&gt;fast&lt;/code&gt; were too fast and did not get any samples? Does it work well with &lt;code&gt;-O3&lt;/code&gt; on larger programs that take longer to execute? Did I miss some CLI option? I found out about &lt;code&gt;-F&lt;/code&gt; to control the sample frequency in Hertz, but I turned it up to the max allowed by default of &lt;code&gt;-F 39500&lt;/code&gt; (could be increased with &lt;code&gt;sudo&lt;/code&gt;) and I still don&apos;t see clear calls.&lt;/p&gt;\n&lt;p&gt;One cool thing about &lt;code&gt;perf&lt;/code&gt; is the FlameGraph tool from Brendan Gregg which displays the call stack timings in a very neat way that allows you to quickly see the big calls. The tool is available at: &lt;a href=&quot;https://github.com/brendangregg/FlameGraph&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://github.com/brendangregg/FlameGraph&lt;/a&gt; and is also mentioned on his perf tutorial at: &lt;a href=&quot;http://www.brendangregg.com/perf.html#FlameGraphs&quot; rel=&quot;nofollow noreferrer&quot;&gt;http://www.brendangregg.com/perf.html#FlameGraphs&lt;/a&gt; When I ran &lt;code&gt;perf&lt;/code&gt; without &lt;code&gt;sudo&lt;/code&gt; I got &lt;a href=&quot;https://github.com/brendangregg/FlameGraph/issues/132&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;ERROR: No stack counts found&lt;/code&gt;&lt;/a&gt; so for now I&apos;ll be doing it with &lt;code&gt;sudo&lt;/code&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;git clone https:&lt;span class=&quot;hljs-comment&quot;&gt;//github.com/brendangregg/FlameGraph&lt;/span&gt;\nsudo perf record -F &lt;span class=&quot;hljs-number&quot;&gt;99&lt;/span&gt; -g -o perf_with_stack.data ./main.out &lt;span class=&quot;hljs-number&quot;&gt;10000&lt;/span&gt;\nsudo perf script -i perf_with_stack.data | FlameGraph/stackcollapse-perf.pl | FlameGraph/flamegraph.pl &amp;gt; flamegraph.svg\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;but in such a simple program the output is not very easy to understand, since we can&apos;t easily see neither &lt;code&gt;maybe_slow&lt;/code&gt; nor &lt;code&gt;fast&lt;/code&gt; on that graph:&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/QFKSS.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/QFKSS.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;On the a more complex example it becomes clear what the graph means:&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/4Ufpd.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/4Ufpd.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;TODO there are a log of &lt;code&gt;[unknown]&lt;/code&gt; functions in that example, why is that?&lt;/p&gt;\n&lt;p&gt;Another perf GUI interfaces which might be worth it include:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;Eclipse Trace Compass plugin: &lt;a href=&quot;https://www.eclipse.org/tracecompass/&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://www.eclipse.org/tracecompass/&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;But this has the downside that you have to first convert the data to the Common Trace Format, which can be done with &lt;code&gt;perf data --to-ctf&lt;/code&gt;, but it needs to be enabled at build time/have &lt;code&gt;perf&lt;/code&gt; new enough, either of which is not the case for the perf in Ubuntu 18.04&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/KDAB/hotspot&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://github.com/KDAB/hotspot&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;The downside of this is that there seems to be no Ubuntu package, and building it requires Qt 5.10 while Ubuntu 18.04 is at Qt 5.9.&lt;/p&gt;\n&lt;p&gt;But &lt;a href=&quot;https://stackoverflow.com/users/758288/david-faure&quot;&gt;David Faure&lt;/a&gt; mentions in the comments that there is no an AppImage package which might be a convenient way to use it.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;gperftools&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;Previously called &quot;Google Performance Tools&quot;, source: &lt;a href=&quot;https://github.com/gperftools/gperftools&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://github.com/gperftools/gperftools&lt;/a&gt; Sample based.&lt;/p&gt;\n&lt;p&gt;First install gperftools with:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;sudo apt install google-perftools\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Then, we can enable the gperftools CPU profiler in two ways: at runtime, or at build time.&lt;/p&gt;\n&lt;p&gt;At runtime, we have to pass set the &lt;code&gt;LD_PRELOAD&lt;/code&gt; to point to &lt;code&gt;libprofiler.so&lt;/code&gt;, which you can find with &lt;code&gt;locate libprofiler.so&lt;/code&gt;, e.g. on my system:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;gcc -ggdb3 -O3 -std=c99 -Wall -Wextra -pedantic -o main.out main.c\nLD_PRELOAD=/usr/lib/x86_64-linux-gnu/libprofiler.so \\\n  CPUPROFILE=prof.out ./main.out &lt;span class=&quot;hljs-number&quot;&gt;10000&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Alternatively, we can build the library in at link time, dispensing passing &lt;code&gt;LD_PRELOAD&lt;/code&gt; at runtime:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;gcc -Wl,--no-as-needed,-lprofiler,--as-needed -ggdb3 -O3 -std=c99 -Wall -Wextra -pedantic -o main.out main.c\nCPUPROFILE=prof.out ./main.out &lt;span class=&quot;hljs-number&quot;&gt;10000&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;See also: &lt;a href=&quot;https://stackoverflow.com/questions/46949407/gperftools-profile-file-not-dumped&quot;&gt;gperftools - profile file not dumped&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;The nicest way to view this data I&apos;ve found so far is to make pprof output the same format that kcachegrind takes as input (yes, the Valgrind-project-viewer-tool) and use kcachegrind to view that:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;google-pprof --callgrind main.out prof.out  &amp;gt; callgrind.out\nkcachegrind callgrind.out\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;After running with either of those methods, we get a &lt;code&gt;prof.out&lt;/code&gt; profile data file as output. We can view that file graphically as an SVG with:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;google-pprof --web main.out prof.out\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/SiISF.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/SiISF.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;which gives as a familiar call graph like other tools, but with the clunky unit of number of samples rather than seconds.&lt;/p&gt;\n&lt;p&gt;Alternatively, we can also get some textual data with:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;google-pprof --text main.out prof.out\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;which gives:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;Using local file main.out.\nUsing local file prof.out.\nTotal: &lt;span class=&quot;hljs-number&quot;&gt;187&lt;/span&gt; samples\n     &lt;span class=&quot;hljs-number&quot;&gt;187&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;100.0&lt;/span&gt;% &lt;span class=&quot;hljs-number&quot;&gt;100.0&lt;/span&gt;%      &lt;span class=&quot;hljs-number&quot;&gt;187&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;100.0&lt;/span&gt;% common\n       &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;0.0&lt;/span&gt;% &lt;span class=&quot;hljs-number&quot;&gt;100.0&lt;/span&gt;%      &lt;span class=&quot;hljs-number&quot;&gt;187&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;100.0&lt;/span&gt;% __libc_start_main\n       &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;0.0&lt;/span&gt;% &lt;span class=&quot;hljs-number&quot;&gt;100.0&lt;/span&gt;%      &lt;span class=&quot;hljs-number&quot;&gt;187&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;100.0&lt;/span&gt;% _start\n       &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;0.0&lt;/span&gt;% &lt;span class=&quot;hljs-number&quot;&gt;100.0&lt;/span&gt;%        &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;2.1&lt;/span&gt;% fast\n       &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;0.0&lt;/span&gt;% &lt;span class=&quot;hljs-number&quot;&gt;100.0&lt;/span&gt;%      &lt;span class=&quot;hljs-number&quot;&gt;187&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;100.0&lt;/span&gt;% main\n       &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;0.0&lt;/span&gt;% &lt;span class=&quot;hljs-number&quot;&gt;100.0&lt;/span&gt;%      &lt;span class=&quot;hljs-number&quot;&gt;183&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;97.9&lt;/span&gt;% maybe_slow\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;See also: &lt;a href=&quot;https://stackoverflow.com/questions/10874308/how-to-use-google-perf-tools&quot;&gt;How to use google perf tools&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Instrument your code with raw &lt;code&gt;perf_event_open&lt;/code&gt; syscalls&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;I think this is the same underlying subsystem that &lt;code&gt;perf&lt;/code&gt; uses, but you could of course attain even greater control by explicitly instrumenting your program at compile time with events of interest.&lt;/p&gt;\n&lt;p&gt;This is likely too hardcore for most people, but it&apos;s kind of fun. Minimal runnable example at: &lt;a href=&quot;https://stackoverflow.com/questions/13313510/quick-way-to-count-number-of-instructions-executed-in-a-c-program/64863392#64863392&quot;&gt;Quick way to count number of instructions executed in a C program&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Intel VTune&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/VTune&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://en.wikipedia.org/wiki/VTune&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;This seems to be closed source and x86-only, but it is likely to be amazing from what I&apos;ve heard. I&apos;m not sure how free it is to use, but it seems to be free to download. TODO evaluate.&lt;/p&gt;\n&lt;p&gt;Tested in Ubuntu 18.04, gprof2dot 2019.11.30, valgrind 3.13.0, perf 4.15.18, Linux kernel 4.15.0, FLameGraph 1a0dc6985aad06e76857cf2a354bd5ba0c9ce96b, gperftools 2.5-2.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Use Valgrind, callgrind and kcachegrind:&lt;/strong&gt; &lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;valgrind --tool=callgrind ./(Your binary)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;generates callgrind.out.x. Read it using kcachegrind.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Use gprof (add -pg):&lt;/strong&gt; &lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;cc -o myprog myprog.c utils.c -g -pg \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;(not so good for multi-threads, function pointers)&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Use google-perftools:&lt;/strong&gt; &lt;/p&gt;\n\n&lt;p&gt;Uses time sampling, I/O and CPU bottlenecks are revealed.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Intel VTune is the best (free for educational purposes).&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Others:&lt;/strong&gt; AMD Codeanalyst (since replaced with AMD CodeXL), OProfile, &apos;perf&apos; tools (apt-get install linux-tools)&lt;/p&gt;\n    ","\n&lt;p&gt;For single-threaded programs you can use &lt;strong&gt;igprof&lt;/strong&gt;, The Ignominous Profiler: &lt;a href=&quot;https://igprof.org/&quot; rel=&quot;noreferrer&quot;&gt;https://igprof.org/&lt;/a&gt; .&lt;/p&gt;\n\n&lt;p&gt;It is a sampling profiler, along the lines of the... long... answer by Mike Dunlavey, which will gift wrap the results in a browsable call stack tree, annotated with the time or memory spent in each function, either cumulative or per-function.&lt;/p&gt;\n    ","\n&lt;p&gt;Also worth mentioning are&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;HPCToolkit (&lt;a href=&quot;http://hpctoolkit.org/&quot; rel=&quot;noreferrer&quot;&gt;http://hpctoolkit.org/&lt;/a&gt;) - Open-source, works for parallel programs and has a GUI with which to look at the results multiple ways&lt;/li&gt;\n&lt;li&gt;Intel VTune (&lt;a href=&quot;https://software.intel.com/en-us/vtune&quot; rel=&quot;noreferrer&quot;&gt;https://software.intel.com/en-us/vtune&lt;/a&gt;) - If you have intel compilers this is very good &lt;/li&gt;\n&lt;li&gt;TAU (&lt;a href=&quot;http://www.cs.uoregon.edu/research/tau/home.php&quot; rel=&quot;noreferrer&quot;&gt;http://www.cs.uoregon.edu/research/tau/home.php&lt;/a&gt;) &lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;I have used HPCToolkit and VTune and they are very effective at finding the long pole in the tent and do not need your code to be recompiled (except that you have to use -g -O or RelWithDebInfo type build in CMake to get meaningful output). I have heard TAU is similar in capabilities.&lt;/p&gt;\n    ","\n&lt;p&gt;Actually a bit surprised not many mentioned about &lt;a href=&quot;https://github.com/google/benchmark&quot; rel=&quot;nofollow noreferrer&quot;&gt;google/benchmark&lt;/a&gt; , while it is a bit cumbersome to pin the specific area of code, specially if the code base is a little big one, however I found this really helpful when used in combination with &lt;code&gt;callgrind&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;IMHO identifying the piece that is causing bottleneck is the key here. I&apos;d however try and answer the following questions first and choose tool based on that&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;is my algorithm correct ?&lt;/li&gt;\n&lt;li&gt;are there locks that are proving to be bottle necks ?&lt;/li&gt;\n&lt;li&gt;is there a specific section of code that&apos;s proving to be a culprit ?&lt;/li&gt;\n&lt;li&gt;how about IO, handled and optimized ?&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;&lt;code&gt;valgrind&lt;/code&gt; with the combination of &lt;code&gt;callgrind&lt;/code&gt; and &lt;code&gt;kcachegrind&lt;/code&gt; should provide a decent estimation on the points above, and once it&apos;s established that there are issues with some section of code, I&apos;d suggest to do a micro bench mark - &lt;code&gt;google benchmark&lt;/code&gt; is a good place to start.&lt;/p&gt;\n    ","\n&lt;p&gt;These are the two methods I use for speeding up my code:&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;em&gt;For CPU bound applications:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;Use a profiler in DEBUG mode to identify questionable parts of your code&lt;/li&gt;\n&lt;li&gt;Then switch to RELEASE mode and comment out the questionable sections of your code (stub it with nothing) until you see changes in performance.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;em&gt;For I/O bound applications:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;Use a profiler in RELEASE mode to identify questionable parts of your code.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;N.B.&lt;/p&gt;\n\n&lt;p&gt;If you don&apos;t have a profiler, use the poor man&apos;s profiler. Hit pause while debugging your application. Most developer suites will break into assembly with commented line numbers. You&apos;re statistically likely to land in a region that is eating most of your CPU cycles.&lt;/p&gt;\n\n&lt;p&gt;For CPU, the reason for profiling in &lt;strong&gt;DEBUG&lt;/strong&gt; mode is because if your tried profiling in &lt;strong&gt;RELEASE&lt;/strong&gt; mode, the compiler is going to reduce math, vectorize loops, and inline functions which tends to glob your code into an un-mappable mess when it&apos;s assembled. &lt;strong&gt;An un-mappable mess means your profiler will not be able to clearly identify what is taking so long because the assembly may not correspond to the source code under optimization&lt;/strong&gt;. If you need the performance (e.g. timing sensitive) of &lt;strong&gt;RELEASE&lt;/strong&gt; mode, disable debugger features as needed to keep a usable performance.&lt;/p&gt;\n\n&lt;p&gt;For I/O-bound, the profiler can still identify I/O operations in &lt;strong&gt;RELEASE&lt;/strong&gt; mode because I/O operations are either externally linked to a shared library (most of the time) or in the worst case, will result in a sys-call interrupt vector (which is also easily identifiable by the profiler).&lt;/p&gt;\n    ","\n&lt;p&gt;You can use the iprof library:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://gitlab.com/Neurochrom/iprof&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://gitlab.com/Neurochrom/iprof&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://github.com/Neurochrom/iprof&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://github.com/Neurochrom/iprof&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;It&apos;s cross-platform and allows you not to measure performance of your application also in real-time. You can even couple it with a live graph.\nFull disclaimer: I am the author.&lt;/p&gt;\n    ","\n&lt;p&gt;You can use a logging framework like &lt;a href=&quot;https://github.com/emilk/loguru&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;loguru&lt;/code&gt;&lt;/a&gt; since it includes timestamps and total uptime which can be used nicely for profiling:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/eHqdn.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/eHqdn.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;At work we have a really nice tool that helps us monitoring what we want in terms of scheduling. This has been useful numerous times.&lt;/p&gt;\n\n&lt;p&gt;It&apos;s in C++ and must be customized to your needs. Unfortunately I can&apos;t share code, just concepts.\nYou use a &quot;large&quot; &lt;code&gt;volatile&lt;/code&gt; buffer containing timestamps and event ID that you can dump post mortem or after stopping the logging system (and dump this into a file for example).&lt;/p&gt;\n\n&lt;p&gt;You retrieve the so-called large buffer with all the data and a small interface parses it and shows events with name (up/down + value) like an oscilloscope does with colors (configured in &lt;code&gt;.hpp&lt;/code&gt; file).&lt;/p&gt;\n\n&lt;p&gt;You customize the amount of events generated to focus solely on what you desire. It helped us a lot for scheduling issues while consuming the amount of CPU we wanted based on the amount of logged events per second. &lt;/p&gt;\n\n&lt;p&gt;You need 3 files : &lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;toolname.hpp &lt;span class=&quot;hljs-comment&quot;&gt;// interface&lt;/span&gt;\ntoolname.cpp &lt;span class=&quot;hljs-comment&quot;&gt;// code&lt;/span&gt;\ntool_events_id.hpp &lt;span class=&quot;hljs-comment&quot;&gt;// Events ID&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The concept is to define events in &lt;code&gt;tool_events_id.hpp&lt;/code&gt; like that :&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// EVENT_NAME                         ID      BEGIN_END BG_COLOR NAME&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; SOCK_PDU_RECV_D               0x0301  &lt;span class=&quot;hljs-comment&quot;&gt;//@D00301 BGEEAAAA # TX_PDU_Recv&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; SOCK_PDU_RECV_F               0x0302  &lt;span class=&quot;hljs-comment&quot;&gt;//@F00301 BGEEAAAA # TX_PDU_Recv&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You also define a few functions in &lt;code&gt;toolname.hpp&lt;/code&gt; :&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; LOG_LEVEL_ERROR 0&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; LOG_LEVEL_WARN 1&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;probe&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(id,payload)&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=&quot;hljs-comment&quot;&gt;// etc&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Wherever in you code you can use :&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;toolname&amp;lt;LOG_LEVEL&amp;gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;log&lt;/span&gt;(EVENT_NAME,VALUE);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The &lt;code&gt;probe&lt;/code&gt; function uses a few assembly lines to retrieve the clock timestamp ASAP and then sets an entry in the buffer. We also have an atomic increment to safely find an index where to store the log event.\nOf course buffer is circular.&lt;/p&gt;\n\n&lt;p&gt;Hope the idea is not obfuscated by the lack of sample code.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;use a debugging software&lt;/strong&gt; \nhow to identify where the code is running slowly ?&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;just think you have a obstacle while you are in motion then it will decrease your speed&lt;/strong&gt;  &lt;/p&gt;\n\n&lt;p&gt;like that unwanted reallocation&apos;s looping,buffer overflows,searching,memory leakages etc operations consumes more execution power it will effect adversely over performance of the code,\nBe sure to add -pg to compilation before profiling:&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;g++ your_prg.cpp -pg&lt;/code&gt; or &lt;code&gt;cc my_program.cpp -g -pg&lt;/code&gt; as per your compiler&lt;/p&gt;\n\n&lt;p&gt;haven&apos;t tried it yet but I&apos;ve heard good things about google-perftools. It is definitely worth a try.&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;valgrind --tool=callgrind ./(Your binary)&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;It will generate a file called gmon.out or callgrind.out.x. You can then use kcachegrind or debugger tool to read this file. It will give you a graphical analysis of things with results like which lines cost how much. &lt;/p&gt;\n\n&lt;p&gt;i think so&lt;/p&gt;\n    ","\n&lt;p&gt;As no one mentioned Arm MAP, I&apos;d add it as personally I have successfully used Map to profile a C++ scientific program. &lt;/p&gt;\n\n&lt;p&gt;Arm MAP is the profiler for parallel, multithreaded or single threaded C, C++, Fortran and F90 codes.  It provides in-depth analysis and bottleneck pinpointing to the source line.  Unlike most profilers, it&apos;s designed to be able to profile pthreads, OpenMP or MPI for parallel and threaded code.&lt;/p&gt;\n\n&lt;p&gt;MAP is commercial software. &lt;/p&gt;\n    ","\n&lt;p&gt;Use &lt;code&gt;-pg&lt;/code&gt; flag when compiling and linking the code and run the executable file. While this program is executed, profiling data is collected in the file a.out.&lt;br&gt;\nThere is two different type of profiling&lt;br&gt;&lt;/p&gt;\n\n&lt;p&gt;1- Flat profiling: &lt;br&gt;\n by running the command &lt;code&gt;gprog --flat-profile a.out&lt;/code&gt; you got the following data&lt;br&gt;\n - what percentage of the overall time was spent for the function,&lt;br&gt;\n - how many seconds were spent in a functionincluding and excluding calls to sub-functions,&lt;br&gt;\n - the number of calls,&lt;br&gt;\n - the average time per call.&lt;br&gt;&lt;/p&gt;\n\n&lt;p&gt;2- graph profiling&lt;br&gt;\nus the command &lt;code&gt;gprof --graph a.out&lt;/code&gt; to get the following data for each function which includes&lt;br&gt;\n - In each section, one function is marked with an index number.&lt;br&gt;\n - Above function , there is a list of functions that call the function .&lt;br&gt;\n - Below function , there is a list of functions that are called by the function .&lt;br&gt;&lt;/p&gt;\n\n&lt;p&gt;To get more info you can look in &lt;a href=&quot;https://sourceware.org/binutils/docs-2.32/gprof/&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://sourceware.org/binutils/docs-2.32/gprof/&lt;/a&gt;&lt;br&gt;&lt;/p&gt;\n    "],"comment":["\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;If you will provide more data about your development stack you might get better answers. There are profilers from Intel and Sun but you have to use their compilers. Is that an option?&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/3579/nazgob&quot; title=&quot;8,392 reputation&quot; class=&quot;comment-user&quot;&gt;Nazgob&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment203921_375913&quot;&gt;&lt;span title=&quot;2008-12-17 20:38:17Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Dec 17, 2008 at 20:38&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;It is already answered on the following link:    &lt;a href=&quot;http://stackoverflow.com/questions/2497211/how-to-profile-multi-threaded-c-application-on-linux&quot; title=&quot;how to profile multi threaded c application on linux&quot;&gt;stackoverflow.com/questions/2497211/&lt;/a&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1322523/kapil-gupta&quot; title=&quot;49 reputation&quot; class=&quot;comment-user&quot;&gt;Kapil Gupta&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment13890879_375913&quot;&gt;&lt;span title=&quot;2012-05-22 10:12:22Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;May 22, 2012 at 10:12&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Most of the answers are &lt;code&gt;code&lt;/code&gt; profilers.  However, priority inversion, cache aliasing, resource contention, etc. can all be factors in optimizing and performance.  I think that people read information into &lt;i&gt;my slow code&lt;/i&gt;. FAQs are referencing this thread.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1880339/artless-noise&quot; title=&quot;19,842 reputation&quot; class=&quot;comment-user&quot;&gt;artless noise&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment21883921_375913&quot;&gt;&lt;span title=&quot;2013-03-17 18:44:47Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 17, 2013 at 18:44&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 2 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;&lt;a href=&quot;https://youtu.be/nXaxk27zwlk&quot; rel=&quot;nofollow noreferrer&quot;&gt;CppCon 2015: Chandler Carruth &quot;Tuning C++: Benchmarks, and CPUs, and Compilers! Oh My!&quot;&lt;/a&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/865719/maddouri&quot; title=&quot;3,579 reputation&quot; class=&quot;comment-user&quot;&gt;maddouri&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment53959345_375913&quot;&gt;&lt;span title=&quot;2015-10-11 22:06:49Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Oct 11, 2015 at 22:06&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;I used to use pstack randomly, most of the time will print out the most typical stack where the program is most of the time, hence pointing to the bottleneck.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/2639772/jose-manuel-gomez-alvarez&quot; title=&quot;1,739 reputation&quot; class=&quot;comment-user&quot;&gt;Jose Manuel Gomez Alvarez&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment69522044_375913&quot;&gt;&lt;span title=&quot;2016-12-15 09:26:00Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Dec 15, 2016 at 9:26&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;This is basically a poor man&apos;s sampling profiler, which is great, but you run the risk of a too-small sample size which will possibly give you entirely spurious results.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/53543/crashworks&quot; title=&quot;39,490 reputation&quot; class=&quot;comment-user&quot;&gt;Crashworks&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment707742_378024&quot;&gt;&lt;span title=&quot;2009-05-22 21:56:36Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;May 22, 2009 at 21:56&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Crash: I won&apos;t debate the &quot;poor man&quot; part :-) It&apos;s true that statistical measurement precision requires many samples, but there are two conflicting goals - measurement and problem location. I&apos;m focussing on the latter, for which you need precision of location, not precision of measure. So for example, there can be, mid-stack, a single function call A(); that accounts for 50% of time, but it can be in another large function B, along with many other calls to A() that are not costly. Precise summaries of function times can be a clue, but every other stack sample will pinpoint the problem.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/23771/mike-dunlavey&quot; title=&quot;39,406 reputation&quot; class=&quot;comment-user&quot;&gt;Mike Dunlavey&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment708270_378024&quot;&gt;&lt;span title=&quot;2009-05-23 01:14:27Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;May 23, 2009 at 1:14&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;... the world seems to think that a call-graph, annotated with call counts and/or average timing, is good enough. It is not. And the sad part is, for those that sample the call stack, the most useful information is right in front of them, but they throw it away, in the interests of &quot;statistics&quot;.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/23771/mike-dunlavey&quot; title=&quot;39,406 reputation&quot; class=&quot;comment-user&quot;&gt;Mike Dunlavey&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment712158_378024&quot;&gt;&lt;span title=&quot;2009-05-24 18:08:35Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;May 24, 2009 at 18:08&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;I don&apos;t mean to disagree with your technique. Clearly I rely quite heavily on stack-walking sampling profilers. I&apos;m just pointing out that there are some tools that do it in an automated way now, which is important when you&apos;re past the point of getting a function from 25% to 15% and need to knock it down from 1.2% to 0.6%.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/53543/crashworks&quot; title=&quot;39,490 reputation&quot; class=&quot;comment-user&quot;&gt;Crashworks&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment745868_378024&quot;&gt;&lt;span title=&quot;2009-06-02 03:27:19Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Jun 2, 2009 at 3:27&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;-1: Neat idea, but if you&apos;re getting paid to work in even a moderately performance oriented environment this is a waste of everyone&apos;s time. Use a real profiler so we don&apos;t have to come along behind you and fix the actual problems.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/138304/sam-harwell&quot; title=&quot;95,215 reputation&quot; class=&quot;comment-user&quot;&gt;Sam Harwell&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment2608945_378024&quot;&gt;&lt;span title=&quot;2010-04-08 13:26:32Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Apr 8, 2010 at 13:26&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;valgrind is great, but be warned that it will make your program darn slow&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/10335/neves&quot; title=&quot;26,845 reputation&quot; class=&quot;comment-user&quot;&gt;neves&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment11294119_771005&quot;&gt;&lt;span title=&quot;2012-01-25 20:07:02Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jan 25, 2012 at 20:07&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Check out also &lt;a href=&quot;http://code.google.com/p/jrfonseca/wiki/Gprof2Dot&quot; rel=&quot;nofollow noreferrer&quot;&gt;Gprof2Dot&lt;/a&gt; for an amazing alternative way to visualize the output. &lt;code&gt;./gprof2dot.py -f callgrind callgrind.out.x | dot -Tsvg -o output.svg&lt;/code&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/543411/sebastian&quot; title=&quot;1,358 reputation&quot; class=&quot;comment-user&quot;&gt;Sebastian&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment24024925_771005&quot;&gt;&lt;span title=&quot;2013-05-22 13:42:48Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;May 22, 2013 at 13:42&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@neves Yes Valgrind is just not very helpful in terms of speed for profiling &quot;gstreamer&quot; and &quot;opencv&quot; applications real-time.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/264683/enthusiasticgeek&quot; title=&quot;2,572 reputation&quot; class=&quot;comment-user&quot;&gt;enthusiasticgeek&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment24039170_771005&quot;&gt;&lt;span title=&quot;2013-05-22 20:20:04Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;May 22, 2013 at 20:20&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Sebastian: &lt;code&gt;gprof2dot&lt;/code&gt; is now here: &lt;a href=&quot;https://github.com/jrfonseca/gprof2dot&quot; rel=&quot;nofollow noreferrer&quot;&gt;github.com/jrfonseca/gprof2dot&lt;/a&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/4323/john-zwinck&quot; title=&quot;224,331 reputation&quot; class=&quot;comment-user&quot;&gt;John Zwinck&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment74344146_771005&quot;&gt;&lt;span title=&quot;2017-04-27 03:19:13Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 27, 2017 at 3:19&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;One thing to bear in mind is to compile WITH debug symbols included but WITH optimisation, to get something explorable yet with the speed characteristics similar to the actual &quot;release&quot; build.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/3378985/biosthezerg&quot; title=&quot;356 reputation&quot; class=&quot;comment-user&quot;&gt;BIOStheZerg&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment103524926_771005&quot;&gt;&lt;span title=&quot;2019-10-29 12:01:47Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Oct 29, 2019 at 12:01&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;I agree that gprof is the current standard.  Just a note, though, Valgrind is used to profile memory leaks and other memory-related aspects of your programs, not for speed optimization.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1288/bill-the-lizard&quot; title=&quot;387,743 reputation&quot; class=&quot;comment-user&quot;&gt;Bill the Lizard&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment205825_375930&quot;&gt;&lt;span title=&quot;2008-12-18 15:02:11Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Dec 18, 2008 at 15:02&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Bill, In vaglrind suite you can find callgrind and massif. Both are pretty useful to profile apps&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/10170/salvatore-dario-minonne&quot; title=&quot;619 reputation&quot; class=&quot;comment-user&quot;&gt;Salvatore Dario Minonne&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment205836_375930&quot;&gt;&lt;span title=&quot;2008-12-18 15:05:55Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Dec 18, 2008 at 15:05&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Bill-the-Lizard: Some comments on &lt;b&gt;gprof&lt;/b&gt; : &lt;a href=&quot;http://stackoverflow.com/questions/1777556/alternatives-to-gprof/1779343#1779343&quot; title=&quot;alternatives to gprof&quot;&gt;stackoverflow.com/questions/1777556/alternatives-to-gprof/&lt;/a&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/23771/mike-dunlavey&quot; title=&quot;39,406 reputation&quot; class=&quot;comment-user&quot;&gt;Mike Dunlavey&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment2356123_375930&quot;&gt;&lt;span title=&quot;2010-03-04 13:23:53Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Mar 4, 2010 at 13:23&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;gprof -pg is only an approximation of callstack profiling.  It inserts mcount calls to track which functions are calling which other functions.  It uses standard time based sampling for, uh, time.  It then apportions times sampled in a function foo() back to the callers of foo(), in proprtion to the numberr of calls. So it doesn&apos;t distinguish between calls of different costs.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1051115/krazy-glew&quot; title=&quot;6,858 reputation&quot; class=&quot;comment-user&quot;&gt;Krazy Glew&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment13350872_375930&quot;&gt;&lt;span title=&quot;2012-04-28 05:45:56Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 28, 2012 at 5:45&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;With clang/clang++, one might consider using &lt;a href=&quot;https://github.com/gperftools/gperftools&quot; rel=&quot;nofollow noreferrer&quot;&gt;gperftools&lt;/a&gt;&apos;s CPU profiler. Caveat: Have not done so myself.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1593077/einpoklum&quot; title=&quot;103,988 reputation&quot; class=&quot;comment-user&quot;&gt;einpoklum&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment103106207_375930&quot;&gt;&lt;span title=&quot;2019-10-14 14:27:03Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Oct 14, 2019 at 14:27&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Great tool! Is there anyway for me to get a typical &quot;butterfly&quot; view that starts from &quot;main-&amp;gt;func1-&amp;gt;fun2&quot; style? I can&apos;t seem to figure that out... &lt;code&gt;perf report&lt;/code&gt; seems to give me the function names with the call parents... (so it&apos;s sort of an inverted butterfly view)&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/111021/kizzx2&quot; title=&quot;18,267 reputation&quot; class=&quot;comment-user&quot;&gt;kizzx2&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment4075107_3502048&quot;&gt;&lt;span title=&quot;2010-10-01 06:17:51Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Oct 1, 2010 at 6:17&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Will, can perf show timechart of thread activity; with CPU number information added? I want to see when and which thread was running on every CPU.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/196561/osgx&quot; title=&quot;86,289 reputation&quot; class=&quot;comment-user&quot;&gt;osgx&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment10365394_3502048&quot;&gt;&lt;span title=&quot;2011-12-06 04:24:17Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Dec 6, 2011 at 4:24&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@kizzx2 - you can use &lt;code&gt;gprof2dot&lt;/code&gt; and &lt;code&gt;perf script&lt;/code&gt;. Very nice tool!&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/311567/dashesy&quot; title=&quot;2,475 reputation&quot; class=&quot;comment-user&quot;&gt;dashesy&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment13720045_3502048&quot;&gt;&lt;span title=&quot;2012-05-14 23:55:46Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;May 14, 2012 at 23:55&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Even newer kernels like 4.13 have eBPF for profiling.  See &lt;a href=&quot;http://www.brendangregg.com/blog/2015-05-15/ebpf-one-small-step.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;brendangregg.com/blog/2015-05-15/ebpf-one-small-step.html&lt;/a&gt; and &lt;a href=&quot;http://www.brendangregg.com/ebpf.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;brendangregg.com/ebpf.html&lt;/a&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/425208/andrew-stern&quot; title=&quot;678 reputation&quot; class=&quot;comment-user&quot;&gt;Andrew Stern&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment80411979_3502048&quot;&gt;&lt;span title=&quot;2017-10-13 15:00:16Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Oct 13, 2017 at 15:00&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;This should be the accepted answer. Using a debugger introduces too much noise in the samples. Performance counters for linux works for multiple threads, multiple processes, user and kernel space, which is great. You can also retrieve many useful information such as branch and cache misses. In the same website @AndrewStern mentioned, there is a flamegraph which is very useful for this kind of analysis: &lt;a href=&quot;https://github.com/brendangregg/FlameGraph&quot; rel=&quot;nofollow noreferrer&quot;&gt;flame graphs&lt;/a&gt;. It generates SVG files that can be opened with a web browser for interactive graphs!&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/5809597/jorge-bellon&quot; title=&quot;2,751 reputation&quot; class=&quot;comment-user&quot;&gt;Jorge Bellon&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment94478548_3502048&quot;&gt;&lt;span title=&quot;2018-12-17 12:25:46Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Dec 17, 2018 at 12:25&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 3 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Now on some reason callgrind.out.* files were always empty. Executing callgrind_control -d was useful to force dump of data to disk.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/977749/t%c3%b5nu-samuel&quot; title=&quot;2,738 reputation&quot; class=&quot;comment-user&quot;&gt;Tnu Samuel&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment38966203_10945113&quot;&gt;&lt;span title=&quot;2014-07-31 04:25:47Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jul 31, 2014 at 4:25&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Can&apos;t. My usual contexts are something like whole MySQL or PHP or some similar big thing. Often even do not know what I want to separate at first.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/977749/t%c3%b5nu-samuel&quot; title=&quot;2,738 reputation&quot; class=&quot;comment-user&quot;&gt;Tnu Samuel&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment55463576_10945113&quot;&gt;&lt;span title=&quot;2015-11-21 22:50:29Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Nov 21, 2015 at 22:50&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Or in my case my program actually loads a bunch of data into an LRU cache, and I want not to profile that. So I force-load a subset of the  cache at startup, and profile the code using only that data (letting the OS+CPU manage the memory use within my cache). It works, but loading that cache is slow and CPU intensive across code that I&apos;m trying to profile in a different context, so callgrind produces badly polluted results.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/3040096/code-abominator&quot; title=&quot;1,461 reputation&quot; class=&quot;comment-user&quot;&gt;Code Abominator&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment59750683_10945113&quot;&gt;&lt;span title=&quot;2016-03-17 03:49:42Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 17, 2016 at 3:49&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;there is also &lt;code&gt;CALLGRIND_TOGGLE_COLLECT&lt;/code&gt; to enable/disable collection programmatically; see &lt;a href=&quot;https://stackoverflow.com/a/13700817/288875&quot;&gt;stackoverflow.com/a/13700817/288875&lt;/a&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/288875/andre-holzner&quot; title=&quot;17,795 reputation&quot; class=&quot;comment-user&quot;&gt;Andre Holzner&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment78847562_10945113&quot;&gt;&lt;span title=&quot;2017-08-29 16:59:43Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Aug 29, 2017 at 16:59&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@TnuSamuel, for me also callgrind.out.* was empty. In my case, the program was getting crahsed while profiling. Once the reason for crash was resolved, I am able to see contents in callgrind.out.* file.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/7621143/explorer&quot; title=&quot;904 reputation&quot; class=&quot;comment-user&quot;&gt;explorer&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment109983450_10945113&quot;&gt;&lt;span title=&quot;2020-06-04 04:29:04Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 4, 2020 at 4:29&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Yes, it does sampling, but not for number-of-calls figures. Interestingly, following your link ultimately led me to an updated version of the manual page I linked to in my post, new URL: &lt;a href=&quot;http://sourceware.org/binutils/docs/gprof/Sampling-Error.html#Sampling-Error&quot; rel=&quot;nofollow noreferrer&quot;&gt;sourceware.org/binutils/docs/gprof/&lt;/a&gt;  This repeats the quote in part (iii) of my answer, but also says &quot;In multi-threaded applications, or single threaded applications that link with multi-threaded libraries, the counts are only deterministic if the counting function is thread-safe. (Note: beware that the mcount counting function in glibc is not thread-safe).&quot;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/823636/rob-before-edits&quot; title=&quot;1,113 reputation&quot; class=&quot;comment-user&quot;&gt;Rob_before_edits&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment14619502_6540100&quot;&gt;&lt;span title=&quot;2012-06-22 04:30:03Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 22, 2012 at 4:30&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;It is not clear to me if this explains my result in (iii).  My code was linked -lpthread -lm and declared both a &quot;pthread_t *thr&quot; and a &quot;pthread_mutex_t nextLock = PTHREAD_MUTEX_INITIALIZER&quot; static variable even when it was running single threaded.  I would ordinarily presume that &quot;link with multi-threaded libraries&quot; means actually using those libraries, and to a greater extent than this, but I could be wrong!&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/823636/rob-before-edits&quot; title=&quot;1,113 reputation&quot; class=&quot;comment-user&quot;&gt;Rob_before_edits&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment14620618_6540100&quot;&gt;&lt;span title=&quot;2012-06-22 06:05:28Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 22, 2012 at 6:05&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;By default perf record uses the frame pointer register. Modern compilers don&apos;t record the frame address and instead use the register as a general purpose. The alternative is to compile with &lt;code&gt;-fno-omit-frame-pointer&lt;/code&gt; flag or use a different alternative: record with &lt;code&gt;--call-graph &quot;dwarf&quot;&lt;/code&gt; or &lt;code&gt;--call-graph &quot;lbr&quot;&lt;/code&gt; depending on your scenario.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/5809597/jorge-bellon&quot; title=&quot;2,751 reputation&quot; class=&quot;comment-user&quot;&gt;Jorge Bellon&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment107804198_60265409&quot;&gt;&lt;span title=&quot;2020-03-30 15:27:05Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 30, 2020 at 15:27&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;KDAB&apos;s hotspot ships with an AppImage these days, making it really easy to use.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/758288/david-faure&quot; title=&quot;1,610 reputation&quot; class=&quot;comment-user&quot;&gt;David Faure&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment128569180_60265409&quot;&gt;&lt;span title=&quot;2022-06-28 16:23:00Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 28 at 16:23&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;It looks interesting, but fails to compile with GCC 9.2. (Debian/Sid) I made an issue on github.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/841108/basile-starynkevitch&quot; title=&quot;1 reputation&quot; class=&quot;comment-user&quot;&gt;Basile Starynkevitch&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment105552151_49335925&quot;&gt;&lt;span title=&quot;2020-01-11 21:47:51Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Jan 11, 2020 at 21:47&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;I found that my google benchmark numbers looked more accurate than gprof when i measured sections of code. As you said its really good for micro benchmarking. but If you want  a more holistic picture you need a different approach.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/4781799/rahul-ravindran&quot; title=&quot;432 reputation&quot; class=&quot;comment-user&quot;&gt;Rahul Ravindran&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment110487365_58681290&quot;&gt;&lt;span title=&quot;2020-06-19 16:22:13Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 19, 2020 at 16:22&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;+1 The poor man&apos;s method works just as well for I/O bound as for CPU bound, and I recommend doing all performance tuning in DEBUG mode. When you&apos;re finished tuning, then turn on RELEASE. It will make an improvement if the program is CPU-bound in your code. &lt;a href=&quot;https://www.youtube.com/watch?v=xPg3sRpdW1U&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;i&gt;Here&apos;s a crude but short video of the process.&lt;/i&gt;&lt;/a&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/23771/mike-dunlavey&quot; title=&quot;39,406 reputation&quot; class=&quot;comment-user&quot;&gt;Mike Dunlavey&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment37854424_20272646&quot;&gt;&lt;span title=&quot;2014-06-27 20:55:26Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 27, 2014 at 20:55&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;I wouldn&apos;t use DEBUG builds for performance profiling. Often have I seen that performance critical parts in DEBUG mode are completely optimized away in release mode. Another problem is the use of asserts in debug code which add noise to the performance.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1079347/gast128&quot; title=&quot;1,113 reputation&quot; class=&quot;comment-user&quot;&gt;gast128&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment38630467_20272646&quot;&gt;&lt;span title=&quot;2014-07-21 18:55:57Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jul 21, 2014 at 18:55&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Did you read my post at all?  &quot;If you need the performance (e.g. timing sensitive) of RELEASE mode, disable debugger features as needed to keep a usable performance&quot;, &quot;Then switch to RELEASE mode and comment the questionable sections of your code (Stub it with nothing) until you see changes in performance.&quot;?  I said check for possible problem areas in debug mode and verify those problems in release mode to avoid the pitfall you mentioned.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/2446285/seo&quot; title=&quot;1,911 reputation&quot; class=&quot;comment-user&quot;&gt;seo&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment38667126_20272646&quot;&gt;&lt;span title=&quot;2014-07-22 15:54:03Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jul 22, 2014 at 15:54&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;I actually would suggest adding some optimization flag, e.g. compile with &lt;code&gt;g++ -O -pg -Wall your_prg.cpp &lt;/code&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/841108/basile-starynkevitch&quot; title=&quot;1 reputation&quot; class=&quot;comment-user&quot;&gt;Basile Starynkevitch&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment112840534_61294963&quot;&gt;&lt;span title=&quot;2020-09-09 13:07:37Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Sep 9, 2020 at 13:07&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        "],"id":144,"title":"How do I profile C++ code running on Linux?","content":"\n                \n&lt;p&gt;How do I find areas of my code that run slowly in a C++ application running on Linux?&lt;/p&gt;\n    ","slug":"how-do-i-profile-c++-code-running-on-linux-1657384754272","postType":"QUESTION","createdAt":"2022-07-09T16:39:14.000Z","updatedAt":"2022-07-09T16:39:14.000Z","tags":[{"id":524,"name":"profiling","slug":"profiling","createdAt":"2022-07-09T16:39:14.000Z","updatedAt":"2022-07-09T16:39:14.000Z","Questions_Tags":{"questionId":144,"tagId":524}}]}},"__N_SSG":true}