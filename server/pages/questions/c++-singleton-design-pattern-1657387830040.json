{"pageProps":{"data":{"answer":["\n&lt;p&gt;In 2008 I provided a C++98 implementation of the Singleton design pattern that is lazy-evaluated, guaranteed-destruction, not-technically-thread-safe:&lt;br&gt;\n&lt;a href=&quot;https://stackoverflow.com/a/271104/364696&quot;&gt;Can any one provide me a sample of Singleton in c++?&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Here is an updated C++11 implementation of the Singleton design pattern that is lazy-evaluated, correctly-destroyed, and &lt;a href=&quot;https://stackoverflow.com/a/449823/52074&quot;&gt;thread-safe&lt;/a&gt;.&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;S&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; S&amp;amp; &lt;span class=&quot;hljs-title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n        &lt;/span&gt;{\n            &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; S    instance; &lt;span class=&quot;hljs-comment&quot;&gt;// Guaranteed to be destroyed.&lt;/span&gt;\n                                  &lt;span class=&quot;hljs-comment&quot;&gt;// Instantiated on first use.&lt;/span&gt;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; instance;\n        }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;:\n        &lt;span class=&quot;hljs-built_in&quot;&gt;S&lt;/span&gt;() {}                    &lt;span class=&quot;hljs-comment&quot;&gt;// Constructor? (the {} brackets) are needed here.&lt;/span&gt;\n\n        &lt;span class=&quot;hljs-comment&quot;&gt;// C++ 03&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;// ========&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;// Don&apos;t forget to declare these two. You want to make sure they&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;// are inaccessible(especially from outside), otherwise, you may accidentally get copies of&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;// your singleton appearing.&lt;/span&gt;\n        &lt;span class=&quot;hljs-built_in&quot;&gt;S&lt;/span&gt;(S &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;&amp;amp;);              &lt;span class=&quot;hljs-comment&quot;&gt;// Don&apos;t Implement&lt;/span&gt;\n        &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;=(S &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;&amp;amp;); &lt;span class=&quot;hljs-comment&quot;&gt;// Don&apos;t implement&lt;/span&gt;\n\n        &lt;span class=&quot;hljs-comment&quot;&gt;// C++ 11&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;// =======&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;// We can use the better technique of deleting the methods&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;// we don&apos;t want.&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n        &lt;span class=&quot;hljs-built_in&quot;&gt;S&lt;/span&gt;(S &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;&amp;amp;)               = &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt;;\n        &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;=(S &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;&amp;amp;)  = &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt;;\n\n        &lt;span class=&quot;hljs-comment&quot;&gt;// Note: Scott Meyers mentions in his Effective Modern&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;//       C++ book, that deleted functions should generally&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;//       be public as it results in better error messages&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;//       due to the compilers behavior to check accessibility&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;//       before deleted status&lt;/span&gt;\n};\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;See this article about when to use a singleton: (not often)&lt;br&gt;\n&lt;a href=&quot;https://stackoverflow.com/questions/86582/singleton-how-should-it-be-used&quot;&gt;Singleton: How should it be used&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;See this two article about initialization order and how to cope:&lt;br&gt;\n&lt;a href=&quot;https://stackoverflow.com/questions/211237/c-static-variables-initialisation-order/211307#211307&quot;&gt;Static variables initialisation order&lt;/a&gt;&lt;br&gt;\n&lt;a href=&quot;https://stackoverflow.com/questions/335369/finding-c-static-initialization-order-problems/335746#335746&quot;&gt;Finding C++ static initialization order problems&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;See this article describing lifetimes:&lt;br&gt;\n&lt;a href=&quot;https://stackoverflow.com/questions/246564/what-is-the-lifetime-of-a-static-variable-in-a-c-function&quot;&gt;What is the lifetime of a static variable in a C++ function?&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;See this article that discusses some threading implications to singletons:&lt;br&gt;\n&lt;a href=&quot;https://stackoverflow.com/questions/449436/singleton-instance-declared-as-static-variable-of-getinstance-method/449823#449823&quot;&gt;Singleton instance declared as static variable of GetInstance method, is it thread-safe?&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;See this article that explains why double checked locking will not work on C++:&lt;br&gt;\n&lt;a href=&quot;https://stackoverflow.com/questions/367633/what-are-all-the-common-undefined-behaviour-that-c-programmer-should-know-about/367690#367690&quot;&gt;What are all the common undefined behaviours that a C++ programmer should know about?&lt;/a&gt;&lt;br&gt;\n&lt;a href=&quot;http://www.drdobbs.com/cpp/c-and-the-perils-of-double-checked-locki/184405726&quot; rel=&quot;noreferrer&quot;&gt;Dr Dobbs: C++ and The Perils of Double-Checked Locking: Part I&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;You could avoid memory allocation. There are many variants, all having problems in case of multithreading environment.&lt;/p&gt;\n\n&lt;p&gt;I prefer this kind of implementation (actually, it is not correctly said I prefer, because I avoid singletons as much as possible):&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Singleton&lt;/span&gt;\n{\n&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;:\n   &lt;span class=&quot;hljs-built_in&quot;&gt;Singleton&lt;/span&gt;();\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n   &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; Singleton&amp;amp; &lt;span class=&quot;hljs-title&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n   &lt;/span&gt;{\n      &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; Singleton INSTANCE;\n      &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; INSTANCE;\n   }\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It has no dynamic memory allocation.&lt;/p&gt;\n    ","\n&lt;p&gt;Being a Singleton, you usually do not want it to be destructed.&lt;/p&gt;\n\n&lt;p&gt;It will get torn down and deallocated when the program terminates, which is the normal, desired behavior for a singleton.  If you want to be able to explicitly clean it, it&apos;s fairly easy to add a static method to the class that allows you to restore it to a clean state, and have it reallocate next time it&apos;s used, but that&apos;s outside of the scope of a &quot;classic&quot; singleton.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/a/1008289/3807729&quot;&gt;@Loki Astari&apos;s answer&lt;/a&gt; is excellent. &lt;/p&gt;\n\n&lt;p&gt;However there are times with multiple static objects where you need to be able to guarantee that the &lt;em&gt;singleton&lt;/em&gt; will not be destroyed until all your static objects that use the &lt;em&gt;singleton&lt;/em&gt; no longer need it.&lt;/p&gt;\n\n&lt;p&gt;In this case &lt;code&gt;std::shared_ptr&lt;/code&gt; can be used to keep the &lt;em&gt;singleton&lt;/em&gt; alive for all users even when the static destructors are being called at the end of the program:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Singleton&lt;/span&gt;\n{\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n    &lt;span class=&quot;hljs-built_in&quot;&gt;Singleton&lt;/span&gt;(Singleton &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;&amp;amp;) = &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt;;\n    Singleton&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;=(Singleton &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;&amp;amp;) = &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; std::shared_ptr&amp;lt;Singleton&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n    &lt;/span&gt;{\n        &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; std::shared_ptr&amp;lt;Singleton&amp;gt; s{&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Singleton};\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; s;\n    }\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;:\n    &lt;span class=&quot;hljs-built_in&quot;&gt;Singleton&lt;/span&gt;() {}\n};\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Another non-allocating alternative: create a singleton, say of class &lt;code&gt;C&lt;/code&gt;, as you need it:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;singleton&lt;/span&gt;&amp;lt;C&amp;gt;()\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;using&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;X&lt;/span&gt;&amp;gt;\n&lt;span class=&quot;hljs-function&quot;&gt;X&amp;amp; &lt;span class=&quot;hljs-title&quot;&gt;singleton&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; X x;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; x;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Neither this nor Cătălin&apos;s answer is automatically thread-safe in current C++, but will be in C++0x.&lt;/p&gt;\n    ","\n&lt;p&gt;I did not find a CRTP implementation among the answers, so here it is:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; HeirT&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Singleton&lt;/span&gt;\n{\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n    &lt;span class=&quot;hljs-built_in&quot;&gt;Singleton&lt;/span&gt;() = &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-built_in&quot;&gt;Singleton&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; Singleton &amp;amp;) = &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt;;\n\n    Singleton &amp;amp;&lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;=(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; Singleton &amp;amp;) = &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; HeirT &amp;amp;&lt;span class=&quot;hljs-title&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n    &lt;/span&gt;{\n        &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; HeirT instance;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; instance;\n    }\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;To use just inherit your class from this, like: &lt;code&gt;class Test : public Singleton&amp;lt;Test&amp;gt;&lt;/code&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;We went over this topic recently in my EECS class. If you want to look at the lecture notes in detail, visit &lt;a href=&quot;http://umich.edu/%7Eeecs381/lecture/IdiomsDesPattsCreational.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;http://umich.edu/~eecs381/lecture/IdiomsDesPattsCreational.pdf&lt;/a&gt;. These notes (and quotations I give in this answer) were created by my Professor, David Kieras.&lt;/p&gt;\n&lt;p&gt;There are two ways that I know to create a Singleton class correctly.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;First Way:&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;Implement it similar to the way you have it in your example. As for destruction, &quot;Singletons usually endure for the length of the program run; most OSs will recover memory and most other resources when a program terminates, so there is an argument for not worrying about this.&quot;&lt;/p&gt;\n&lt;p&gt;However, it is good practice to clean up at program termination. Therefore, you can do this with an auxiliary static SingletonDestructor class and declare that as a friend in your Singleton.&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Singleton&lt;/span&gt; {\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; Singleton* &lt;span class=&quot;hljs-title&quot;&gt;get_instance&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;\n  \n  &lt;span class=&quot;hljs-comment&quot;&gt;// disable copy/move -- this is a Singleton&lt;/span&gt;\n  &lt;span class=&quot;hljs-built_in&quot;&gt;Singleton&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; Singleton&amp;amp;) = &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt;;\n  &lt;span class=&quot;hljs-built_in&quot;&gt;Singleton&lt;/span&gt;(Singleton&amp;amp;&amp;amp;) = &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt;;\n  Singleton&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;=(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; Singleton&amp;amp;) = &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt;;\n  Singleton&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;=(Singleton&amp;amp;&amp;amp;) = &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt;;\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Singleton_destroyer&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;:\n  &lt;span class=&quot;hljs-built_in&quot;&gt;Singleton&lt;/span&gt;();  &lt;span class=&quot;hljs-comment&quot;&gt;// no one else can create one&lt;/span&gt;\n  ~&lt;span class=&quot;hljs-built_in&quot;&gt;Singleton&lt;/span&gt;(); &lt;span class=&quot;hljs-comment&quot;&gt;// prevent accidental deletion&lt;/span&gt;\n\n  &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; Singleton* ptr;\n};\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// auxiliary static object for destroying the memory of Singleton&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Singleton_destroyer&lt;/span&gt; {\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n  ~Singleton_destroyer { &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt; Singleton::ptr; }\n};\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// somewhere in code (Singleton.cpp is probably the best place) &lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// create a global static Singleton_destroyer object&lt;/span&gt;\nSingleton_destoyer the_destroyer;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The Singleton_destroyer will be created on program startup, and &quot;when program terminates, all global/static objects are destroyed by the runtime library shutdown code (inserted by the linker), so the_destroyer will be destroyed; its destructor will delete the Singleton, running its destructor.&quot;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Second Way&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;This is called the Meyers Singleton, created by C++ wizard Scott Meyers. Simply define get_instance() differently. Now you can also get rid of the pointer member variable.&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// public member function&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; Singleton&amp;amp; &lt;span class=&quot;hljs-title&quot;&gt;Singleton::get_instance&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n  &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; Singleton s;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; s;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This is neat because the value returned is by reference and you can use &lt;code&gt;.&lt;/code&gt; syntax instead of &lt;code&gt;-&amp;gt;&lt;/code&gt; to access member variables.&lt;/p&gt;\n&lt;p&gt;&quot;Compiler automatically builds code that creates &apos;s&apos; first time through the\ndeclaration, not thereafter, and then deletes the static object at program\ntermination.&quot;&lt;/p&gt;\n&lt;p&gt;Note also that with the Meyers Singleton you &quot;can get into very difficult situation if objects rely on each other at the time of\ntermination - when does the Singleton disappear relative to other objects? But for simple applications, this works fine.&quot;&lt;/p&gt;\n    ","\n&lt;p&gt;Here is an easy implementation.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;Windows.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; std;\n\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;SingletonClass&lt;/span&gt; {\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; SingletonClass* &lt;span class=&quot;hljs-title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (!m_instanceSingleton) ?\n        m_instanceSingleton = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; SingletonClass : \n        m_instanceSingleton;\n    }\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;:\n    &lt;span class=&quot;hljs-comment&quot;&gt;// private constructor and destructor&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;SingletonClass&lt;/span&gt;() { cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;SingletonClass instance created!\\n&quot;&lt;/span&gt;; }\n    ~&lt;span class=&quot;hljs-built_in&quot;&gt;SingletonClass&lt;/span&gt;() {}\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// private copy constructor and assignment operator&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;SingletonClass&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; SingletonClass&amp;amp;);\n    SingletonClass&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;=(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; SingletonClass&amp;amp;);\n\n    &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; SingletonClass *m_instanceSingleton;\n};\n\nSingletonClass* SingletonClass::m_instanceSingleton = &lt;span class=&quot;hljs-literal&quot;&gt;nullptr&lt;/span&gt;;\n\n\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; * argv[])&lt;/span&gt; &lt;/span&gt;{\n\n    SingletonClass *singleton;\n    singleton = singleton-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;getInstance&lt;/span&gt;();\n    cout &amp;lt;&amp;lt; singleton &amp;lt;&amp;lt; endl;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Another object gets the reference of the first object!&lt;/span&gt;\n    SingletonClass *anotherSingleton;\n    anotherSingleton = anotherSingleton-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;getInstance&lt;/span&gt;();\n    cout &amp;lt;&amp;lt; anotherSingleton &amp;lt;&amp;lt; endl;\n\n    &lt;span class=&quot;hljs-built_in&quot;&gt;Sleep&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;5000&lt;/span&gt;);\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Only one object created and this object reference is returned each and every time afterwords.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;SingletonClass instance created!\n&lt;span class=&quot;hljs-number&quot;&gt;00915&lt;/span&gt;CB8\n&lt;span class=&quot;hljs-number&quot;&gt;00915&lt;/span&gt;CB8\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here 00915CB8 is the memory location of singleton Object, same for the duration of the program but (normally!) different each time the program is run.&lt;/p&gt;\n\n&lt;p&gt;N.B. This is not a thread safe one.You have to ensure thread safety.&lt;/p&gt;\n    ","\n&lt;p&gt;The solution in the accepted answer has a significant drawback - the destructor for the singleton is called after the control leaves the &lt;code&gt;main()&lt;/code&gt; function. There may be problems really, when some dependent objects are allocated inside &lt;code&gt;main&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;I met this problem, when trying to introduce a Singleton in the Qt application. I decided, that all my setup dialogs must be Singletons, and adopted the pattern above. Unfortunately, Qt&apos;s main class &lt;code&gt;QApplication&lt;/code&gt; was allocated on stack in the &lt;code&gt;main&lt;/code&gt; function, and Qt forbids creating/destroying dialogs when no application object is available.&lt;/p&gt;\n\n&lt;p&gt;That is why I prefer heap-allocated singletons. I provide an explicit &lt;code&gt;init()&lt;/code&gt; and &lt;code&gt;term()&lt;/code&gt; methods for all the singletons and call them inside &lt;code&gt;main&lt;/code&gt;. Thus I have a full control over the order of singletons creation/destruction, and also I guarantee that singletons will be created, no matter whether someone called &lt;code&gt;getInstance()&lt;/code&gt; or not.&lt;/p&gt;\n    ","\n&lt;p&gt;Has anyone mentioned &lt;code&gt;std::call_once&lt;/code&gt; and &lt;code&gt;std::once_flag&lt;/code&gt;?\nMost other approaches - including double checked locking - are broken.&lt;/p&gt;\n\n&lt;p&gt;One major problem in singleton pattern implementation is safe initialization. The only safe way is to guard the initialization sequence with synchronizing barriers. But those barriers themselves need to be safely initiated. &lt;code&gt;std::once_flag&lt;/code&gt; is the mechanism to get guaranteed safe initialization.&lt;/p&gt;\n    ","\n&lt;p&gt;If you want to allocate the object in heap, why don&apos;t use a unique pointer. Memory will also be deallocated since we are using a unique pointer.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;S&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; S&amp;amp; &lt;span class=&quot;hljs-title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n        &lt;/span&gt;{\n            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;( m_s.&lt;span class=&quot;hljs-built_in&quot;&gt;get&lt;/span&gt;() == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; )\n            {\n              m_s.&lt;span class=&quot;hljs-built_in&quot;&gt;reset&lt;/span&gt;( &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;S&lt;/span&gt;() );\n            }\n            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; *m_s;\n        }\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;:\n        &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; std::unique_ptr&amp;lt;S&amp;gt; m_s;\n\n        &lt;span class=&quot;hljs-built_in&quot;&gt;S&lt;/span&gt;();\n        &lt;span class=&quot;hljs-built_in&quot;&gt;S&lt;/span&gt;(S &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;&amp;amp;);            &lt;span class=&quot;hljs-comment&quot;&gt;// Don&apos;t Implement&lt;/span&gt;\n        &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;=(S &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;&amp;amp;); &lt;span class=&quot;hljs-comment&quot;&gt;// Don&apos;t implement&lt;/span&gt;\n};\n\n&lt;span class=&quot;hljs-function&quot;&gt;std::unique_ptr&amp;lt;S&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;S::m_s&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;C++11 Thread safe implementation:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt; &lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n &lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;thread&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n\n &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Singleton&lt;/span&gt;\n {\n     &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;:\n         &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; Singleton * _instance;\n         &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; std::mutex mutex_;\n\n     &lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt;:\n         &lt;span class=&quot;hljs-built_in&quot;&gt;Singleton&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; std::string value): &lt;span class=&quot;hljs-built_in&quot;&gt;value_&lt;/span&gt;(value)\n         {\n         }\n         ~&lt;span class=&quot;hljs-built_in&quot;&gt;Singleton&lt;/span&gt;() {}\n         std::string value_;\n\n     &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n         &lt;span class=&quot;hljs-comment&quot;&gt;/**\n          * Singletons should not be cloneable.\n          */&lt;/span&gt;\n         &lt;span class=&quot;hljs-built_in&quot;&gt;Singleton&lt;/span&gt;(Singleton &amp;amp;other) = &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt;;\n         &lt;span class=&quot;hljs-comment&quot;&gt;/**\n          * Singletons should not be assignable.\n          */&lt;/span&gt;\n         &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;=(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; Singleton &amp;amp;) = &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt;;\n\n         &lt;span class=&quot;hljs-comment&quot;&gt;//static Singleton *GetInstance(const std::string&amp;amp; value);&lt;/span&gt;\n         &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; Singleton *&lt;span class=&quot;hljs-title&quot;&gt;GetInstance&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; std::string&amp;amp; value)&lt;/span&gt;\n         &lt;/span&gt;{\n             &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (_instance == &lt;span class=&quot;hljs-literal&quot;&gt;nullptr&lt;/span&gt;)\n             {\n                 &lt;span class=&quot;hljs-function&quot;&gt;std::lock_guard&amp;lt;std::mutex&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(mutex_)&lt;/span&gt;&lt;/span&gt;;\n                 &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (_instance == &lt;span class=&quot;hljs-literal&quot;&gt;nullptr&lt;/span&gt;)\n                 {\n                     _instance = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Singleton&lt;/span&gt;(value);\n                 }\n             }\n             &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; _instance;\n         }\n\n         &lt;span class=&quot;hljs-function&quot;&gt;std::string &lt;span class=&quot;hljs-title&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;&lt;/span&gt;{\n             &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; value_;\n         }\n };\n\n &lt;span class=&quot;hljs-comment&quot;&gt;/**\n  * Static methods should be defined outside the class.\n  */&lt;/span&gt;\n Singleton* Singleton::_instance = &lt;span class=&quot;hljs-literal&quot;&gt;nullptr&lt;/span&gt;;\n std::mutex Singleton::mutex_;\n\n\n &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ThreadFoo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{\n     std::this_thread::&lt;span class=&quot;hljs-built_in&quot;&gt;sleep_for&lt;/span&gt;(std::chrono::&lt;span class=&quot;hljs-built_in&quot;&gt;milliseconds&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;));\n     Singleton* singleton = Singleton::&lt;span class=&quot;hljs-built_in&quot;&gt;GetInstance&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;FOO&quot;&lt;/span&gt;);\n     std::cout &amp;lt;&amp;lt; singleton-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;value&lt;/span&gt;() &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n&quot;&lt;/span&gt;;\n }\n\n &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ThreadBar&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{\n     std::this_thread::&lt;span class=&quot;hljs-built_in&quot;&gt;sleep_for&lt;/span&gt;(std::chrono::&lt;span class=&quot;hljs-built_in&quot;&gt;milliseconds&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;));\n     Singleton* singleton = Singleton::&lt;span class=&quot;hljs-built_in&quot;&gt;GetInstance&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;BAR&quot;&lt;/span&gt;);\n     std::cout &amp;lt;&amp;lt; singleton-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;value&lt;/span&gt;() &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n&quot;&lt;/span&gt;;\n }\n\n &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n &lt;/span&gt;{\n     std::cout &amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;If you see the same value, then singleton was reused (yay!\\n&quot;&lt;/span&gt; &amp;lt;&amp;lt;\n                 &lt;span class=&quot;hljs-string&quot;&gt;&quot;If you see different values, then 2 singletons were created (booo!!)\\n\\n&quot;&lt;/span&gt; &amp;lt;&amp;lt;\n                 &lt;span class=&quot;hljs-string&quot;&gt;&quot;RESULT:\\n&quot;&lt;/span&gt;;\n     &lt;span class=&quot;hljs-function&quot;&gt;std::thread &lt;span class=&quot;hljs-title&quot;&gt;t1&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(ThreadFoo)&lt;/span&gt;&lt;/span&gt;;\n     &lt;span class=&quot;hljs-function&quot;&gt;std::thread &lt;span class=&quot;hljs-title&quot;&gt;t2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(ThreadBar)&lt;/span&gt;&lt;/span&gt;;\n     t1.&lt;span class=&quot;hljs-built_in&quot;&gt;join&lt;/span&gt;();\n     t2.&lt;span class=&quot;hljs-built_in&quot;&gt;join&lt;/span&gt;();\n     std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Complete!&quot;&lt;/span&gt; &amp;lt;&amp;lt; std::endl;\n\n     &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n }\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;It is indeed probably allocated from the heap, but without the sources there is no way of knowing.&lt;/p&gt;\n\n&lt;p&gt;The typical implementation (taken from some code I have in emacs already) would be:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;Singleton * &lt;span class=&quot;hljs-title&quot;&gt;Singleton::getInstance&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!instance) {\n        instance = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Singleton&lt;/span&gt;();\n    };\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; instance;\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;...and rely on the program going out of scope to clean up afterwards.&lt;/p&gt;\n\n&lt;p&gt;If you work on a platform where cleanup must be done manually, I&apos;d probably add a manual cleanup routine.&lt;/p&gt;\n\n&lt;p&gt;Another issue with doing it this way is that it isn&apos;t thread-safe. In a multithreaded environment, two threads could get through the &quot;if&quot; before either has a chance to allocate the new instance (so both would). This still isn&apos;t too big of a deal if you are relying on program termination to clean up anyway.&lt;/p&gt;\n    ","\n&lt;p&gt;In addition to the other discussion here, it may be worth noting that you can have global-ness, without limiting usage to one instance. For example, consider the case of reference counting something...&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Store&lt;/span&gt;{\n   std::array&amp;lt;Something, 1024&amp;gt; data;\n   &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; idx)&lt;/span&gt;&lt;/span&gt;{ &lt;span class=&quot;hljs-comment&quot;&gt;/* ... */&lt;/span&gt; }\n   &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;incr_ref&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; idx)&lt;/span&gt;&lt;/span&gt;{ &lt;span class=&quot;hljs-comment&quot;&gt;/* ... */&lt;/span&gt;}\n   &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;decr_ref&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; idx)&lt;/span&gt;&lt;/span&gt;{ &lt;span class=&quot;hljs-comment&quot;&gt;/* ... */&lt;/span&gt;}\n};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;Store* store_p&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ItemRef&lt;/span&gt;{\n   &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; idx;\n   &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{ &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; store_p-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;get&lt;/span&gt;(idx); };\n   &lt;span class=&quot;hljs-built_in&quot;&gt;ItemRef&lt;/span&gt;() { store_p-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;incr_ref&lt;/span&gt;(idx); };\n   ~&lt;span class=&quot;hljs-built_in&quot;&gt;ItemRef&lt;/span&gt;() { store_p-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;decr_ref&lt;/span&gt;(idx); };\n};\n\nStore store1_g;\nStore store2_g; &lt;span class=&quot;hljs-comment&quot;&gt;// we don&apos;t restrict the number of global Store instances&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Now somewhere inside a function (such as &lt;code&gt;main&lt;/code&gt;) you can do:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; ref1_a = &lt;span class=&quot;hljs-built_in&quot;&gt;ItemRef&lt;/span&gt;&amp;lt;&amp;amp;store1_g&amp;gt;(&lt;span class=&quot;hljs-number&quot;&gt;101&lt;/span&gt;);\n&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; ref2_a = &lt;span class=&quot;hljs-built_in&quot;&gt;ItemRef&lt;/span&gt;&amp;lt;&amp;amp;store2_g&amp;gt;(&lt;span class=&quot;hljs-number&quot;&gt;201&lt;/span&gt;); \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The refs don&apos;t need to store a pointer back to their respective &lt;code&gt;Store&lt;/code&gt; because that information is supplied at compile-time. You also don&apos;t have to worry about the &lt;code&gt;Store&lt;/code&gt;&apos;s lifetime because the compiler requires that it is global.  If there is indeed only one instance of &lt;code&gt;Store&lt;/code&gt; then there&apos;s no overhead in this approach; with more than one instance it&apos;s up to the compiler to be clever about code generation. If necessary, the &lt;code&gt;ItemRef&lt;/code&gt; class can even be made a &lt;code&gt;friend&lt;/code&gt; of &lt;code&gt;Store&lt;/code&gt; (you can have templated friends!).&lt;/p&gt;\n\n&lt;p&gt;If &lt;code&gt;Store&lt;/code&gt; itself is a templated class then things get messier, but it is still possible to use this method, perhaps by implementing a helper class with the following signature:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; Store_t, Store_t* store_p&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;StoreWrapper&lt;/span&gt;{ &lt;span class=&quot;hljs-comment&quot;&gt;/* stuff to access store_p, e.g. methods returning \n                       instances of ItemRef&amp;lt;Store_t, store_p&amp;gt;. */&lt;/span&gt; };\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The user can now create a &lt;code&gt;StoreWrapper&lt;/code&gt; type (and global instance) for each global &lt;code&gt;Store&lt;/code&gt; instance, and always access the stores via their wrapper instance (thus forgetting about the gory details of the template parameters needed for using &lt;code&gt;Store&lt;/code&gt;).&lt;/p&gt;\n    ","\n&lt;p&gt;Here is a &lt;a href=&quot;https://github.com/canonical/multipass/blob/7d3de5fb1a4402b4438dae4806677fdd6c776450/include/multipass/singleton.h&quot; rel=&quot;nofollow noreferrer&quot;&gt;mockable singleton&lt;/a&gt; using &lt;a href=&quot;https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern&quot; rel=&quot;nofollow noreferrer&quot;&gt;CRTP&lt;/a&gt;. It relies on &lt;a href=&quot;https://github.com/canonical/multipass/blob/7d3de5fb1a4402b4438dae4806677fdd6c776450/include/multipass/private_pass_provider.h&quot; rel=&quot;nofollow noreferrer&quot;&gt;a little helper&lt;/a&gt; to enforce a single object at any one time (at most). To enforce a single object over program execution, remove the reset (which we find useful for tests).&lt;/p&gt;\n&lt;p&gt;A &lt;code&gt;ConcreteSinleton&lt;/code&gt; can be implemented like this:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ConcreteSingleton&lt;/span&gt; : &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Singleton&amp;lt;ConcreteSingleton&amp;gt;\n{\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n  &lt;span class=&quot;hljs-built_in&quot;&gt;ConcreteSingleton&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; Singleton&amp;lt;ConcreteSingleton&amp;gt;::PrivatePass&amp;amp;)\n      : Singleton&amp;lt;StandardPaths&amp;gt;::Singleton{pass}\n  {}\n  \n  &lt;span class=&quot;hljs-comment&quot;&gt;// ... concrete interface&lt;/span&gt;\n  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;/span&gt;{&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;42&lt;/span&gt;;}\n\n};\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;And then used with&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;ConcreteSingleton::&lt;span class=&quot;hljs-built_in&quot;&gt;instance&lt;/span&gt;().&lt;span class=&quot;hljs-built_in&quot;&gt;f&lt;/span&gt;();\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;This is about object life-time management. Suppose you have more than singletons in your software. And they depend on Logger singleton. During application destruction, suppose another singleton object uses Logger to log its destruction steps. You have to guarantee that Logger should be cleaned up last. Therefore, please also check out this paper:\n&lt;a href=&quot;http://www.cs.wustl.edu/~schmidt/PDF/ObjMan.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;http://www.cs.wustl.edu/~schmidt/PDF/ObjMan.pdf&lt;/a&gt; &lt;/p&gt;\n    ","\n&lt;p&gt;My implementation is similar to Galik&apos;s. The difference is my implementation allows the shared pointers to clean up allocated memory, as opposed to holding onto the memory until the application is exited and the static pointers are cleaned up.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;pragma&lt;/span&gt; once&lt;/span&gt;\n\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;memory&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Singleton&lt;/span&gt;\n{\n&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;:\n  &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; std::weak_ptr&amp;lt;T&amp;gt; _singleton;\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; std::shared_ptr&amp;lt;T&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;singleton&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n  &lt;/span&gt;{\n    std::shared_ptr&amp;lt;T&amp;gt; singleton = _singleton.&lt;span class=&quot;hljs-built_in&quot;&gt;lock&lt;/span&gt;();\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!singleton) \n    {\n      singleton.&lt;span class=&quot;hljs-built_in&quot;&gt;reset&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;T&lt;/span&gt;());\n      _singleton = singleton;\n    }\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; singleton;\n  }\n};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\nstd::weak_ptr&amp;lt;T&amp;gt; Singleton&amp;lt;T&amp;gt;::_singleton;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Your code is correct, except that &lt;em&gt;you didn&apos;t declare the instance pointer outside the class&lt;/em&gt;. The inside class declarations of static variables are not considered declarations in C++, however this is allowed in other languages like &lt;strong&gt;C#&lt;/strong&gt; or &lt;strong&gt;Java&lt;/strong&gt; etc.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Singleton&lt;/span&gt;\n{\n   &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n       &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; Singleton* &lt;span class=&quot;hljs-title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;( )&lt;/span&gt;&lt;/span&gt;;\n   &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;:\n       &lt;span class=&quot;hljs-built_in&quot;&gt;Singleton&lt;/span&gt;( );\n       &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; Singleton* instance;\n};\nSingleton* Singleton::instance; &lt;span class=&quot;hljs-comment&quot;&gt;//we need to declare outside because static variables are global&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You must know that Singleton instance &lt;em&gt;doesn&apos;t need to be manually deleted by us&lt;/em&gt;. We need a single object of it throughout the whole program, so &lt;em&gt;at the end of program execution, it will be automatically deallocated.&lt;/em&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Here is my view on how to do proper singletons (and other non-trivial static objects): &lt;a href=&quot;https://github.com/alex4747-pub/proper_singleton&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://github.com/alex4747-pub/proper_singleton&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Summary:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Use static initialization list to instantiate singletons at the right time: after entering main and before enabling multi-threading&lt;/li&gt;\n&lt;li&gt;Add minor improvements to make it unit-test friendly.&lt;/li&gt;\n&lt;/ol&gt;\n    ","\n&lt;p&gt;I would like to show here another example of a singleton in C++. It makes sense to use template programming. Besides, it makes sense to derive your singleton class from a not copyable and not movabe classes. Here how it looks like in the code:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;DoNotCopy&lt;/span&gt;\n{\n&lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt;:\n    &lt;span class=&quot;hljs-built_in&quot;&gt;DoNotCopy&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;) = &lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt;;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;DoNotCopy&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; DoNotCopy&amp;amp;) = &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt;;\n    DoNotCopy&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;=(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; DoNotCopy&amp;amp;) = &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt;;\n};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;DoNotMove&lt;/span&gt;\n{\n&lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt;:\n    &lt;span class=&quot;hljs-built_in&quot;&gt;DoNotMove&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;) = &lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt;;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;DoNotMove&lt;/span&gt;(DoNotMove&amp;amp;&amp;amp;) = &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt;;\n    DoNotMove&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;=(DoNotMove&amp;amp;&amp;amp;) = &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt;;\n};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;DoNotCopyMove&lt;/span&gt; : &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; DoNotCopy,\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; DoNotMove\n{\n&lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt;:\n    &lt;span class=&quot;hljs-built_in&quot;&gt;DoNotCopyMove&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;) = &lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt;;\n};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;T&lt;/span&gt;&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Singleton&lt;/span&gt; : &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; DoNotCopyMove\n{\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; T&amp;amp; &lt;span class=&quot;hljs-title&quot;&gt;Instance&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;\n    &lt;/span&gt;{\n        &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; T instance;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; instance;\n    }\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt;:\n    &lt;span class=&quot;hljs-built_in&quot;&gt;Singleton&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;) = &lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt;;\n};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Logger&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt;: &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Singleton&amp;lt;Logger&amp;gt;\n{\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; std::string&amp;amp; str)&lt;/span&gt; &lt;/span&gt;{ std::cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; std::endl; }\n};\n\n\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    Logger::&lt;span class=&quot;hljs-built_in&quot;&gt;Instance&lt;/span&gt;().&lt;span class=&quot;hljs-built_in&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;xx&quot;&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The splitting into NotCopyable and NotMovable clases allows you to define your singleton more specific (sometimes you want to move your single instance).&lt;/p&gt;\n    ","\n&lt;p&gt;It restrict instantiation of a class to one object. This is useful when exactly one object is needed to coordinate actions across the system&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Singleton&lt;/span&gt; {\n&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;:\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; data;\n    &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; Singleton* instance;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;Singleton&lt;/span&gt;();\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; Singleton* &lt;span class=&quot;hljs-title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;\n};\nSingleton* Singleton::instance = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\nSingleton::&lt;span class=&quot;hljs-built_in&quot;&gt;Singleton&lt;/span&gt;()\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;-&amp;gt;data = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n    cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;constructor called..&quot;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n}\n\n \n\n&lt;span class=&quot;hljs-function&quot;&gt;Singleton* &lt;span class=&quot;hljs-title&quot;&gt;Singleton::getInstance&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!instance) {\n        instance = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Singleton&lt;/span&gt;();\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; instance;\n    }\n}\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n    Singleton *s = s-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;getInstance&lt;/span&gt;();\n    Singleton *s1 =s1-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;getInstance&lt;/span&gt;();\n    }\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;The paper that was linked to above describes the shortcoming of double checked locking is that the compiler may allocate the memory for the object and set a pointer to the address of the allocated memory, before the object&apos;s constructor has been called. It is quite easy in c++ however to use allocaters to allocate the memory manually, and then use a construct call to initialize the memory. Using this appraoch, the double-checked locking works just fine.&lt;/p&gt;\n    ","\n&lt;p&gt;Simple singleton class, This must be your header class file&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;ifndef&lt;/span&gt; SC_SINGLETON_CLASS_H&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; SC_SINGLETON_CLASS_H&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;SingletonClass&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; SingletonClass* &lt;span class=&quot;hljs-title&quot;&gt;Instance&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n        &lt;/span&gt;{\n           &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; SingletonClass* instance = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;SingletonClass&lt;/span&gt;();\n           &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; instance;\n        }\n\n        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Relocate&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; X, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; Y, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; Z)&lt;/span&gt;&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;:\n        &lt;span class=&quot;hljs-built_in&quot;&gt;SingletonClass&lt;/span&gt;();\n        ~&lt;span class=&quot;hljs-built_in&quot;&gt;SingletonClass&lt;/span&gt;();\n};\n\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; sSingletonClass SingletonClass::Instance()&lt;/span&gt;\n\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Access your singleton like this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;sSingletonClass-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;Relocate&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; INS(c) private:void operator=(c const&amp;amp;){};public:static c&amp;amp; I(){static c _instance;return _instance;}&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;   &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;CCtrl&lt;/span&gt;\n    {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;:\n        &lt;span class=&quot;hljs-built_in&quot;&gt;CCtrl&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;virtual&lt;/span&gt; ~&lt;span class=&quot;hljs-built_in&quot;&gt;CCtrl&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;);\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n        &lt;span class=&quot;hljs-built_in&quot;&gt;INS&lt;/span&gt;(CCtrl);\n&lt;/code&gt;&lt;/pre&gt;\n    "],"id":388,"title":"C++ Singleton design pattern","content":"\n                \n&lt;p&gt;Recently I&apos;ve bumped into a realization/implementation of the Singleton design pattern for C++. It has looked like this (I have adopted it from the real-life example):&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// a lot of methods are omitted here&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Singleton&lt;/span&gt;\n{\n   &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n       &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; Singleton* &lt;span class=&quot;hljs-title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;( )&lt;/span&gt;&lt;/span&gt;;\n       ~&lt;span class=&quot;hljs-built_in&quot;&gt;Singleton&lt;/span&gt;( );\n   &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;:\n       &lt;span class=&quot;hljs-built_in&quot;&gt;Singleton&lt;/span&gt;( );\n       &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; Singleton* instance;\n};\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;From this declaration, I can deduce that the instance field is initiated on the heap. That means there is a memory allocation. What is completely unclear for me is when exactly the memory is going to be deallocated? Or is there a bug and memory leak? It seems like there is a problem with the implementation.&lt;/p&gt;\n&lt;p&gt;My main question is, how do I implement it in the right way?&lt;/p&gt;\n    ","slug":"c++-singleton-design-pattern-1657387830040","postType":"QUESTION","createdAt":"2022-07-09T17:30:30.000Z","updatedAt":"2022-07-09T17:30:30.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"How to center an element horizontally and vertically","slug":"how-to-center-an-element-horizontally-and-vertically-1657388132330"},{"title":"What should main() return in C and C++?","slug":"what-should-main()-return-in-c-and-c++-1657384745630"},{"title":"How to avoid using Select in Excel VBA","slug":"how-to-avoid-using-select-in-excel-vba-1657384286300"},{"title":"How do you access the matched groups in a JavaScript regular expression?","slug":"how-do-you-access-the-matched-groups-in-a-javascript-regular-expression-1657388233817"},{"title":"Why is processing a sorted array faster than processing an unsorted array?","slug":"why-is-processing-a-sorted-array-faster-than-processing-an-unsorted-array-1657385497444"},{"title":"How do you use bcrypt for hashing passwords in PHP? [duplicate]","slug":"how-do-you-use-bcrypt-for-hashing-passwords-in-php-duplicate-1657387318517"},{"title":"Why does Spring MVC respond with a 404 and report \"No mapping found for HTTP request with URI [...] in DispatcherServlet\"?","slug":"why-does-spring-mvc-respond-with-a-404-and-report-\"no-mapping-found-for-http-request-with-uri-...-in-dispatcherservlet\"-1657387995250"},{"title":"Why Use Integer Instead of Long?","slug":"why-use-integer-instead-of-long-1657388012352"},{"title":"What does \"list comprehension\" and similar mean? How does it work and how can I use it?","slug":"what-does-\"list-comprehension\"-and-similar-mean-how-does-it-work-and-how-can-i-use-it-1657387996940"},{"title":"Captured variable in a loop in C#","slug":"captured-variable-in-a-loop-in-c-1657387696779"},{"title":"What causes a java.lang.ArrayIndexOutOfBoundsException and how do I prevent it?","slug":"what-causes-a-java.lang.arrayindexoutofboundsexception-and-how-do-i-prevent-it-1657384370848"},{"title":"List of lists changes reflected across sublists unexpectedly","slug":"list-of-lists-changes-reflected-across-sublists-unexpectedly-1657384393720"},{"title":"How to randomize (shuffle) a JavaScript array?","slug":"how-to-randomize-(shuffle)-a-javascript-array-1657384790171"},{"title":"Query based on multiple where clauses in Firebase","slug":"query-based-on-multiple-where-clauses-in-firebase-1657387494547"},{"title":"When should I use a return statement in ES6 arrow functions","slug":"when-should-i-use-a-return-statement-in-es6-arrow-functions-1657388472113"},{"title":"\"Cross origin requests are only supported for HTTP.\" error when loading a local file","slug":"\"cross-origin-requests-are-only-supported-for-http.\"-error-when-loading-a-local-file-1657387942403"},{"title":"Which equals operator (== vs ===) should be used in JavaScript comparisons?","slug":"which-equals-operator-(-vs-)-should-be-used-in-javascript-comparisons-1657384663105"},{"title":"Serialize and Deserialize Json and Json Array in Unity","slug":"serialize-and-deserialize-json-and-json-array-in-unity-1657388273270"},{"title":"JavaScript property access: dot notation vs. brackets?","slug":"javascript-property-access:-dot-notation-vs.-brackets-1657384717494"},{"title":"Where and why do I have to put the \"template\" and \"typename\" keywords?","slug":"where-and-why-do-i-have-to-put-the-\"template\"-and-\"typename\"-keywords-1657384467606"}]},"__N_SSG":true}