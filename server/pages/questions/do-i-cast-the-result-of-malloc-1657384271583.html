<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2eccd4d47c856f2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2eccd4d47c856f2b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/471-84c36aa98dd4107c.js" defer=""></script><script src="/_next/static/chunks/81-096e453de8a27667.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-e3d1b60e109d3ba1.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_buildManifest.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.hFcsiD code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-6e32c308-0"]{content:"hFcsiD,"}/*!sc*/
.ljvTUN .comment-item .comment-body .d-inline-flex.ai-center{text-align:right;}/*!sc*/
.ljvTUN .comment-item .comment-body .comment-date{float:right;}/*!sc*/
data-styled.g6[id="sc-6e32c308-1"]{content:"ljvTUN,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="https://flowbite.com/docs/images/logo.svg" class="mr-3 h-6 sm:h-9" alt="Flowbite Logo"/><span class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Hunter</span></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/do-i-cast-the-result-of-malloc-1657384271583#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-6e32c308-0 hFcsiD flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/do-i-cast-the-result-of-malloc-1657384271583">Do I cast the result of malloc?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/casting">casting</a></div></div><div class="question-content mt-5">
                
<p>In <a href="http://stackoverflow.com/questions/571945/getting-a-stack-overflow-exception-when-declaring-a-large-array">this question</a>, someone suggested in a <a href="http://stackoverflow.com/questions/571945/getting-a-stack-overflow-exception-when-declaring-a-large-array#comment388297_571961">comment</a> that I should <em><strong>not</strong></em> cast the result of <code>malloc</code>. i.e., I should do this:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> *sieve = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(*sieve) * length);
</code></pre>
<p>rather than:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> *sieve = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(*sieve) * length);
</code></pre>
<p>Why would this be the case?</p>
    </div></div></div><div class="sc-6e32c308-1 ljvTUN flex text-xs pl-10 flex-col comment items-center justify-center"><h4 class="text-left mt-10 text-lg font-semibold">Comments</h4><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy"><a href="http://stackoverflow.com/q/7545365/168175">stackoverflow.com/q/7545365/168175</a></span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/168175/flexo" title="85,154 reputation" class="comment-user">Flexo</a>
<span class="mod-flair " title="Moderator"></span>                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment11088903_605845"><span title="2012-01-15 20:06:32Z, License: CC BY-SA 3.0" class="relativetime-clean">Jan 15, 2012 at 20:06</span></a></span>
            </div>
        </div><span class="divide-x-8 "></span><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy">Casts are evil.  I see so many cast in code just as a result of bad coding practice. Whenever you need to insert one the first thing you should ask yourselves is " what is wrong here" . Is everything declared as it should  be ? If it is no cast would be needed so something is declared wrong. If you really do need to do some low level stuff on individual bytes in an int or so consider a union to access them. That'll declare them just fine. As a rule of thumb do not insert them unless the compiler complains. Then avoid them. This example will not complain. void pointer will promote to any type.</span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/5717390/hans-lepoeter" title="139 reputation" class="comment-user">Hans Lepoeter</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment117225829_605845"><span title="2021-02-21 21:52:05Z, License: CC BY-SA 4.0" class="relativetime-clean">Feb 21, 2021 at 21:52</span></a></span>
                        <span title="this comment was edited 1 time">
                            <svg aria-hidden="true" class="va-text-bottom o50 svg-icon iconPencilSm" width="14" height="14" viewBox="0 0 14 14"><path d="m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z"></path></svg>
                        </span>
            </div>
        </div><span class="divide-x-8 "></span><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy">@HansLepoeter in C++ , those are necessary for malloc, giving some basis to my notion that there's something wrong with it</span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/13651625/an-ant" title="172 reputation" class="comment-user">An Ant</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment117385253_605845"><span title="2021-02-27 11:51:14Z, License: CC BY-SA 4.0" class="relativetime-clean">Feb 27, 2021 at 11:51</span></a></span>
            </div>
        </div><span class="divide-x-8 "></span><button class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">See more</button></div><div class="sc-6e32c308-2 bFXWFO"><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h3>TL;DR</h3>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> *sieve = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * length);
</code></pre>
<p>has two problems. The cast and that you're using the type instead of variable as argument for sizeof. Instead, do like this:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> *sieve = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span> *sieve * length);
</code></pre>
<h3>Long version</h3>
<p><strong>No</strong>; you <em>don't</em> cast the result, since:</p>
<ul>
<li>It is unnecessary, as <code>void *</code> is automatically and safely promoted to any other pointer type in this case.</li>
<li>It adds clutter to the code, casts are not very easy to read (especially if the pointer type is long).</li>
<li>It makes you repeat yourself, which is generally bad.</li>
<li>It can hide an error if you forgot to include <code>&lt;stdlib.h&gt;</code>. This can cause crashes (or, worse, <em>not</em> cause a crash until way later in some totally different part of the code). Consider what happens if pointers and integers are differently sized; then you're hiding a warning by casting and might lose bits of your returned address. Note: as of C99 implicit functions are gone from C, and this point is no longer relevant since there's no automatic assumption that undeclared functions return <code>int</code>.</li>
</ul>
<p>As a clarification, note that I said "you don't cast", not "you don't <em>need</em> to cast". In my opinion, it's a failure to include the cast, even if you got it right. There are simply no benefits to doing it, but a bunch of potential risks, and including the cast indicates that you don't know about the risks.</p>
<p>Also note, as commentators point out, that the above talks about straight C, not C++. I very firmly believe in C and C++ as separate languages.</p>
<p>To add further, your code needlessly repeats the type information (<code>int</code>) which can cause errors. It's better to de-reference the pointer being used to store the return value, to "lock" the two together:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> *sieve = <span class="hljs-built_in">malloc</span>(length * <span class="hljs-keyword">sizeof</span> *sieve);
</code></pre>
<p>This also moves the <code>length</code> to the front for increased visibility, and drops the redundant parentheses with <code>sizeof</code>; they <em>are only needed</em> when the argument is a type name. Many people seem to not know (or ignore) this, which makes their code more verbose. Remember: <code>sizeof</code> is not a function! :)</p>
<hr>
<p>While moving <code>length</code> to the front <em>may</em> increase visibility in some rare cases, one should also pay attention that in the general case, it should be better to write the expression as:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> *sieve = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span> *sieve * length);
</code></pre>
<p>Since keeping the <code>sizeof</code> first, in this case, ensures multiplication is done with at least <code>size_t</code> math.</p>
<p>Compare: <code>malloc(sizeof *sieve * length * width)</code> vs. <code>malloc(length * width * sizeof *sieve)</code> the second may overflow the <code>length * width</code> when <code>width</code> and <code>length</code> are smaller types than <code>size_t</code>.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In C, you don't need to cast the return value of <code>malloc</code>. The pointer to void returned by <code>malloc</code> is automagically converted to the correct type. However, if you want your code to compile with a C++ compiler, a cast is needed. A preferred alternative among the community is to use the following:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> *sieve = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span> *sieve * length);
</code></pre>

<p>which additionally frees you from having to worry about changing the right-hand side of the expression if ever you change the type of <code>sieve</code>.</p>

<p>Casts are bad, as people have pointed out. Especially pointer casts. </p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You <strong>do</strong> cast, because:</p>

<ul>
<li>It makes your code <strong>more portable</strong> between C and C++, and as SO experience shows, a great many programmers claim they are writing in C when they are really writing in C++ (or C plus local compiler extensions).</li>
<li>Failing to do so <strong>can hide an error</strong>: note all the SO examples of confusing when to write <code>type *</code> versus <code>type **</code>.</li>
<li>The idea that it keeps you from noticing you failed to <code>#include</code> an appropriate header file misses <strong>the forest for the trees</strong>. It's the same as saying "don't worry about the fact you failed to ask the compiler to complain about not seeing prototypes -- that pesky stdlib.h is the REAL important thing to remember!"</li>
<li>It forces an <strong>extra cognitive cross-check</strong>. It puts the (alleged) desired type right next to the arithmetic you're doing for the raw size of that variable. I bet you could do an SO study that shows that <code>malloc()</code> bugs are caught much faster when there's a cast. As with assertions, annotations that reveal intent decrease bugs. </li>
<li>Repeating yourself in a way that the machine can check is often a <strong>great</strong> idea. In fact, that's what an assertion is, and this use of cast is an assertion. Assertions are still the most general technique we have for getting code correct, since Turing came up with the idea so many years ago.</li>
</ul>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As others stated, it is not needed for C, but necessary for C++. If you think you are going to compile your C code with a C++ compiler, for whatever reasons, you can use a macro instead, like:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span>
<span class="hljs-meta"># <span class="hljs-keyword">define</span> NEW(type, count) ((type *)calloc(count, sizeof(type)))</span>
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
<span class="hljs-meta"># <span class="hljs-keyword">define</span> NEW(type, count) (calloc(count, sizeof(type)))</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>

<p>That way you can still write it in a very compact way:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> *sieve = NEW(<span class="hljs-type">int</span>, <span class="hljs-number">1</span>);
</code></pre>

<p>and it will compile for C and C++.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>From the <a href="https://en.wikipedia.org/wiki/C_dynamic_memory_allocation#Advantages_to_casting" rel="noreferrer">Wikipedia</a>:</p>

<blockquote>
  <p><strong>Advantages to casting</strong></p>
  
  <ul>
  <li><p>Including the cast may allow a C program or function to compile as C++.</p></li>
  <li><p>The cast allows for pre-1989 versions of malloc that originally returned a char *.</p></li>
  <li><p>Casting can help the developer identify inconsistencies in type sizing should the destination pointer type change, particularly if the pointer is declared far from the malloc() call (although modern compilers and static analyzers can warn on such behaviour without requiring the cast).</p></li>
  </ul>
  
  <p><strong>Disadvantages to casting</strong></p>
  
  <ul>
  <li><p>Under the ANSI C standard, the cast is redundant.</p></li>
  <li><p>Adding the cast may mask failure to include the header <em>stdlib.h</em>, in
  which the prototype for malloc is found. In the absence of a
  prototype for malloc, the standard requires that the C compiler
  assume malloc returns an int. If there is no cast, a warning is
  issued when this integer is assigned to the pointer; however, with
  the cast, this warning is not produced, hiding a bug. On certain
  architectures and data models (such as LP64 on 64-bit systems, where
  long and pointers are 64-bit and int is 32-bit), this error can
  actually result in undefined behaviour, as the implicitly declared
  malloc returns a 32-bit value whereas the actually defined function
  returns a 64-bit value. Depending on calling conventions and memory
  layout, this may result in stack smashing. This issue is less likely
  to go unnoticed in modern compilers, as they uniformly produce
  warnings that an undeclared function has been used, so a warning will
  still appear. For example, GCC's default behaviour is to show a
  warning that reads "incompatible implicit declaration of built-in
  function" regardless of whether the cast is present or not.</p></li>
  <li><p>If the type of the pointer is changed at its declaration, one may
  also, need to change all lines where malloc is called and cast.</p></li>
  </ul>
</blockquote>

<p>Although <strong>malloc without casting is preferred method and most experienced programmers choose it</strong>, you should use whichever you like having aware of the issues.</p>

<p>i.e: If you need to compile C program as C++ (Although it is a separate language) you must cast the result of use <code>malloc</code>. </p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In C you can implicitly convert a <code>void</code> pointer to any other kind of pointer, so a cast is not necessary. Using one may suggest to the casual observer that there is some reason why one is needed, which may be misleading.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You don't cast the result of <code>malloc</code>, because doing so adds pointless clutter to your code.</p>
<p>The most common reason why people cast the result of <code>malloc</code> is because they are unsure about how the C language works. That's a warning sign: if you don't know how a particular language mechanism works, then <em>don't</em> take a guess. Look it up or ask on Stack Overflow.</p>
<p>Some comments:</p>
<ul>
<li><p>A void pointer can be converted to/from any other pointer type without an explicit cast (C11 6.3.2.3 and 6.5.16.1).</p>
</li>
<li><p>C++ will however not allow an implicit cast between <code>void*</code> and another pointer type. So in C++, the cast would have been correct. But if you program in C++, you should use <code>new</code> and not <code>malloc()</code>. And you should never compile C code using a C++ compiler.</p>
<p>If you need to support both C and C++ with the same source code, use compiler switches to mark the differences. Do not attempt to sate both language standards with the same code, because they are not compatible.</p>
</li>
<li><p>If a C compiler cannot find a function because you forgot to include the header, you will get a compiler/linker error about that. So if you forgot to include <code>&lt;stdlib.h&gt;</code> that's no biggie, you won't be able to build your program.</p>
</li>
<li><p>On ancient compilers that follow a version of the standard which is more than 25 years old, forgetting to include <code>&lt;stdlib.h&gt;</code> would result in dangerous behavior. Because in that ancient standard, functions without a visible prototype implicitly converted the return type to <code>int</code>. Casting the result from <code>malloc</code> explicitly would then hide away this bug.</p>
<p>But that is really a non-issue. You aren't using a 25 years old computer, so why would you use a 25 years old compiler?</p>
</li>
</ul>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In C you get an implicit conversion from <code>void *</code> to any other (data) pointer.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Casting the value returned by <code>malloc()</code> is not necessary now, but I'd like to add one point that seems no one has pointed out:</p>

<p>In the ancient days, that is, before <strong>ANSI C</strong> provides the <code>void *</code> as the generic type of pointers, <code>char *</code> is the type for such usage. In that case, the cast can shut down the compiler warnings.</p>

<p>Reference: <a href="http://c-faq.com/malloc/cast.html" rel="noreferrer">C FAQ</a></p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Just adding my experience, studying computer engineering I see that the two or three professors that I have seen writing in C always cast malloc, however the one I asked (with an immense CV and understanding of C) told me that it is absolutely unnecessary but only used to be absolutely specific, and to get the students into the mentality of being absolutely specific. Essentially casting will not change anything in how it works, it does exactly what it says, allocates memory, and casting does not effect it, you get the same memory, and even if you cast it to something else by mistake (and somehow evade compiler errors) C will access it the same way.</p>

<p><strong>Edit:</strong> Casting has a certain point. When you use array notation, the code generated has to know how many memory places it has to advance to reach the beginning of the next element, this is achieved through casting. This way you know that for a double you go 8 bytes ahead while for an int you go 4, and so on. Thus it has no effect if you use pointer notation, in array notation it becomes necessary.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It is not mandatory to cast the results of <code>malloc</code>, since it returns <code>void*</code> , and a <code>void*</code> can be pointed to any datatype. </p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This is what <a href="http://www.gnu.org/software/libc/manual/html_node/Basic-Allocation.html" rel="noreferrer">The GNU C Library Reference</a> manual says: </p>

<blockquote>
  <p>You can store the result of <code>malloc</code> into any pointer variable without a
  cast, because ISO C automatically converts the type <code>void *</code> to another
  type of pointer when necessary. But the cast is necessary in contexts
  other than assignment operators or if you might want your code to run
  in traditional C.</p>
</blockquote>

<p>And indeed the <a href="http://www.compsci.hunter.cuny.edu/~sweiss/resources/c11standard.pdf" rel="noreferrer">ISO C11 standard</a> (p347) says so: </p>

<blockquote>
  <p>The pointer returned if the allocation succeeds is suitably aligned so
  that it may be assigned to a pointer to any type of object with a
  fundamental alignment requirement and then used to access such an
  object or an array of such objects in the space allocated (until the
  space is explicitly deallocated)</p>
</blockquote>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A void pointer is a generic object pointer and C supports implicit conversion from a void pointer type to other types, so there is no need of explicitly typecasting it.</p>

<p>However, if you want the same code work perfectly compatible on a C++ platform, which does not support implicit conversion, you need to do the typecasting, so it all depends on usability.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The returned type is void*, which can be cast to the desired type of data pointer in order to be dereferenceable.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It depends on the programming language and compiler. If you use <code>malloc</code> in C, there is no need to type cast it, as it will automatically type cast. However, if you are using C++, then you should type cast because <code>malloc</code> will return a <code>void*</code> type.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In the C language, a void pointer can be assigned to any pointer, which is why you should not use a type cast. If you want "type safe" allocation, I can recommend the following macro functions, which I always use in my C projects:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> NEW_ARRAY(ptr, n) (ptr) = malloc((n) * sizeof *(ptr))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> NEW(ptr) NEW_ARRAY((ptr), 1)</span>
</code></pre>

<p>With these in place you can simply say</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">NEW_ARRAY(sieve, length);
</code></pre>

<p>For non-dynamic arrays, the third must-have function macro is</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEN(arr) (sizeof (arr) / sizeof (arr)[0])</span>
</code></pre>

<p>which makes array loops safer and more convenient:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> i, a[<span class="hljs-number">100</span>];

<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; LEN(a); i++) {
   ...
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>People used to GCC and Clang are spoiled.  It's not all that good out there.</p>

<p>I have been pretty horrified over the years by the staggeringly aged compilers I've been required to use.  Often companies and managers adopt an ultra-conservative approach to changing compilers and will not even <em>test</em> if a new compiler ( with better standards compliance and code optimization ) will work in their system.  The practical reality for working developers is that when you're coding you need to cover your bases and, unfortunately, casting mallocs is a good habit if you cannot control what compiler may be applied to your code.</p>

<p>I would also suggest that many organizations apply a coding standard of their own and that <em>that</em> should be the method people follow if it is defined.  In the absence of explicit guidance I tend to go for most likely to compile everywhere, rather than slavish adherence to a standard.</p>

<p>The argument that it's not necessary under current standards is quite valid.  But that argument omits the practicalities of the real world.  We do not code in a world ruled exclusively by the standard of the day, but by the practicalities of what I like to call "local management's reality field".  And that's bent and twisted more than space time ever was. :-)</p>

<p>YMMV.</p>

<p>I tend to think of casting malloc as a defensive operation.  Not pretty, not perfect, but generally safe.  ( Honestly, if you've not included stdlib.h then you've <em>way</em> more problems than casting malloc ! ).</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 18</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1><strong>This question is subject of opinion-based abuse.</strong></h1>
<p>Sometimes I notice comments like that:</p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc">Don't cast the result of malloc</a></p>
</blockquote>
<p>or</p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc">Why you don't cast the result of malloc</a></p>
</blockquote>
<p>on questions where OP uses casting. The comments itself contain a hyperlink to this question.</p>
<p>That is in <em>any</em> possible manner inappropriate and incorrect as well. There is no right and no wrong when it is truly a matter of one's own coding-style.</p>
<hr>
<h3>Why is this happening?</h3>
<p>It's based upon two reasons:</p>
<ol>
<li><p>This question is indeed opinion-based. Technically, the question should have been closed as opinion-based years ago. A "<em>Do I</em>" or "<em>Don't I</em>" or equivalent "<em>Should I</em>" or "<em>Shouldn't I</em>" question, you just can't answer focused without an attitude of one's own opinion. One of the reason to close a question is because it "might lead to opinion-based answers" as it is well shown here.</p>
</li>
<li><p>Many answers (including the most apparent and accepted <a href="https://stackoverflow.com/a/605858/12139179">answer</a> of <a href="https://stackoverflow.com/users/28169/unwind">@unwind</a>) are either completely or almost entirely opinion-based (f.e. a mysterious "clutter" that would be added to your code if you do casting or repeating yourself would be bad) and show a clear and focused tendency to omit the cast. They argue about the redundancy of the cast on one side but also and even worse argue to solve a bug caused by a bug/failure of programming itself - to not <code>#include &lt;stdlib.h&gt;</code> if one want to use <code>malloc()</code>.</p>
</li>
</ol>
<hr>
<p>I want to bring a true view of some points discussed, with less of my personal opinion. A few points need to be noted especially:</p>
<ol>
<li><p>Such a very susceptible question to fall into one's own opinion needs an answer with neutral pros and cons. Not only cons or pros.</p>
<p>A good overview of pros and cons is listed in this answer:</p>
<p><a href="https://stackoverflow.com/a/33047365/12139179">https://stackoverflow.com/a/33047365/12139179</a></p>
<p>(I personally consider this because of that reason the best answer, so far.)</p>
</li>
</ol>
<hr>
<ol start="2">
<li><p>One reason which is encountered at most to reason the omission of the cast is that the cast might hide a bug.</p>
<p>If someone uses an implicit declared <code>malloc()</code> that returns <code>int</code> (implicit functions are gone from the standard since C99) and <code>sizeof(int) != sizeof(int*)</code>, as shown in this question</p>
<p><a href="http://stackoverflow.com/q/7545365/168175">Why does this code segfault on 64-bit architecture but work fine on 32-bit?</a></p>
<p>the cast would hide a bug.</p>
<p>While this is true, it only shows half of the story as the omission of the cast would only be a forward-bringing solution to an even bigger bug - not including <code>stdlib.h</code> when using <code>malloc()</code>.</p>
<p>This will never be a serious issue, If you,</p>
<ol>
<li><p>Use a compiler compliant to C99 or above (which is recommended and should be mandatory), and</p>
</li>
<li><p>Aren't so absent to forgot to include <code>stdlib.h</code>, when you want to use <code>malloc()</code> in your code, which is a huge bug itself.</p>
</li>
</ol>
</li>
</ol>
<hr>
<ol start="3">
<li><p>Some people argue about C++ compliance of C code, as the cast is obliged in C++.</p>
<p>First of all to say in general: Compiling C code with a C++ compiler is not a good practice.</p>
<p>C and C++ are in fact two completely different languages with different semantics.</p>
<p>But If you really want/need to make C code compliant to C++ and vice versa use compiler switches instead of any cast.</p>
<p>Since the cast is with tendency declared as redundant or even harmful, I want to take a focus on these questions, which give good reasons why casting can be useful or even necessary:</p>
<ul>
<li><p><a href="https://stackoverflow.com/a/34094068/12139179">https://stackoverflow.com/a/34094068/12139179</a></p>
</li>
<li><p><a href="https://stackoverflow.com/a/36297486/12139179">https://stackoverflow.com/a/36297486/12139179</a></p>
</li>
<li><p><a href="https://stackoverflow.com/a/33044300/12139179">https://stackoverflow.com/a/33044300/12139179</a></p>
</li>
</ul>
</li>
</ol>
<hr>
<ol start="4">
<li>The cast can be non-beneficial when your code, respectively the type of the assigned pointer (and with that the type of the cast), changes, although this is in most cases unlikely. Then you would need to maintain/change all casts too and if you have a few thousand calls to memory-management functions in your code, this can really summarizing up and decrease the maintenance efficiency.</li>
</ol>
<hr>
<h3>Summary:</h3>
<p>Fact is, that the cast is redundant per the C standard (already since ANSI-C (C89/C90)) if the assigned pointer point to an object of fundamental alignment requirement (which includes the most of all objects).</p>
<p>You don't need to do the cast as the pointer is automatically aligned in this case:</p>
<blockquote>
<p>"The order and contiguity of storage allocated by successive calls to the aligned_alloc, calloc, malloc, and realloc functions is unspecified. <strong>The pointer returned if the allocation succeeds is suitably aligned so that it may be assigned to a pointer to any type of object with a fundamental alignment requirement</strong> and then used to access such an object or an array of such objects in the space allocated (until the space is explicitly deallocated)."</p>
<p>Source: C18, §7.22.3/1</p>
</blockquote>
<hr>
<blockquote>
<p>"A <em>fundamental alignment</em> is a valid alignment less than or equal to <code>_Alignof (max_align_t)</code>. Fundamental alignments shall be supported by the implementation for objects of all storage durations. The alignment requirements of the following types shall be fundamental alignments:</p>
<p>  all atomic, qualified, or unqualified basic types;</p>
<p>  all atomic, qualified, or unqualified enumerated types;</p>
<p>  all atomic, qualified, or unqualified pointer types;</p>
<p>  all array types whose element type has a fundamental alignment requirement;57)</p>
<p>  all types specified in Clause 7 as complete object types;</p>
<p>  all structure or union types all of whose elements have types with fundamental alignment requirements and none of whose elements have an alignment specifier specifying an alignment that is not a fundamental alignment.</p>
<ol start="57">
<li>As specified in 6.2.1, the later declaration might hide the prior declaration."</li>
</ol>
<p>Source: C18, §6.2.8/2</p>
</blockquote>
<p>However, if you allocate memory for an implementation-defined object of extended alignment requirement, the cast would be needed.</p>
<blockquote>
<p>An <em>extended alignment</em> is represented by an alignment greater than <code>_Alignof (max_align_t)</code>. It is implementation-defined whether any extended alignments are supported and the storage durations for which they are supported. A type having an extended alignment requirement is an over-aligned type.58)</p>
<p>Source. C18, §6.2.8/3</p>
</blockquote>
<p>Everything else is a matter of the specific use case and one's own opinion.</p>
<p>Please be careful how you educate yourself.</p>
<p>I recommend you to read <em>all</em> of the answers made so far carefully first (as well as their comments which may point at a failure) and then build your own opinion if you or if you not cast the result of <code>malloc()</code> at a specific case.</p>
<p>Please note:</p>
<p><strong>There is no right and wrong answer to that question. It is a matter of style and you yourself decide which way you choose (if you aren't forced to by education or job of course). Please be aware of that and don't let trick you</strong>.</p>
<hr>
<p>Last note: I voted to lately close this question as opinion-based, which is indeed needed since years. If you got the close/reopen privilege I would like to invite you to do so, too.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 19</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2>No, you don't cast the result of <code>malloc()</code>.</h2>

<p>In general, you <strong>don't cast to or from <code>void *</code></strong>.</p>

<p>A typical reason given for not doing so is that failure to <code>#include &lt;stdlib.h&gt;</code> could go unnoticed. This isn't an issue anymore for a long time now as C99 made <em>implicit function declarations</em> illegal, so if your compiler conforms to at least C99, you will get a diagnostic message.</p>

<p>But there's a <strong>much stronger reason</strong> not to introduce unnecessary pointer casts:</p>

<p>In C, a <strong>pointer cast is almost always an error</strong>. This is because of the following rule (<strong>§6.5 p7</strong> in N1570, the latest draft for C11):</p>

<blockquote>
  <p>An object shall have its stored value accessed only by an lvalue expression that has one of
  the following types:<br>
   a type compatible with the effective type of the object,<br>
   a qualified version of a type compatible with the effective type of the object,<br>
   a type that is the signed or unsigned type corresponding to the effective type of the
  object,<br>
   a type that is the signed or unsigned type corresponding to a qualified version of the
  effective type of the object,<br>
   an aggregate or union type that includes one of the aforementioned types among its
  members (including, recursively, a member of a subaggregate or contained union), or<br>
   a character type.</p>
</blockquote>

<p>This is also known as the <em>strict aliasing rule</em>. So the following code is <em>undefined behavior</em>:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">long</span> x = <span class="hljs-number">5</span>;
<span class="hljs-type">double</span> *p = (<span class="hljs-type">double</span> *)&amp;x;
<span class="hljs-type">double</span> y = *p;
</code></pre>

<p>And, sometimes surprisingly, the following is as well:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">foo</span> {</span> <span class="hljs-type">int</span> x; };
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bar</span> {</span> <span class="hljs-type">int</span> x; <span class="hljs-type">int</span> y; };
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bar</span> <span class="hljs-title">b</span> =</span> { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>};
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">foo</span> *<span class="hljs-title">p</span> =</span> (<span class="hljs-keyword">struct</span> foo *)&amp;b;
<span class="hljs-type">int</span> z = p-&gt;x;
</code></pre>

<p>Sometimes, you <strong>do</strong> need to cast pointers, but given the <em>strict aliasing rule</em>, you have to be very careful with it. So, any occurrence of a pointer cast in your code is a place you <strong>have to double-check for its validity</strong>. Therefore, you never write an unnecessary pointer cast.</p>

<h3>tl;dr</h3>

<p>In a nutshell: Because in C, <strong>any</strong> occurrence of a <em>pointer cast</em> should raise a red flag for code requiring special attention, you should never write <em>unnecessary</em> pointer casts.</p>

<hr>

<p>Side notes:</p>

<ul>
<li><p>There are cases where you actually <em>need</em> a cast to <code>void *</code>, e.g. if you want to print a pointer:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%p\n"</span>, (<span class="hljs-type">void</span> *)&amp;x);
</code></pre>

<p>The cast is necessary here, because <code>printf()</code> is a variadic function, so implicit conversions don't work.</p></li>
<li><p>In C++, the situation is different. Casting pointer types is somewhat common (and correct) when dealing with objects of derived classes. Therefore, it makes sense that in C++, the conversion to and from <code>void *</code> is <strong>not</strong> implicit. C++ has a whole set of different flavors of casting.</p></li>
</ul>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 20</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I put in the cast simply to show disapproval of the ugly hole in the type system, which allows code such as the following snippet to compile without diagnostics, even though no casts are used to bring about the bad conversion:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">double</span> d;
<span class="hljs-type">void</span> *p = &amp;d;
<span class="hljs-type">int</span> *q = p;
</code></pre>

<p>I wish that didn't exist (and it doesn't in C++) and so I cast. It represents my taste, and my programming politics. I'm not only casting a pointer, but effectively, casting a ballot, and <a href="http://dilbert.com/strip/1994-02-03">casting out demons of stupidity</a>. If I can't <em>actually</em> <a href="http://dilbert.com/strip/1994-02-02">cast out stupidity</a>, then at least let me express the wish to do so with a gesture of protest.</p>

<p>In fact, a good practice is to wrap <code>malloc</code> (and friends) with functions that return <code>unsigned char *</code>, and basically never to use <code>void *</code> in your code.  If you need a generic pointer-to-any-object, use a <code>char *</code> or <code>unsigned char *</code>, and have casts in both directions. The one relaxation that can be indulged, perhaps, is using functions like <code>memset</code> and <code>memcpy</code> without casts.</p>

<p>On the topic of casting and C++ compatibility, if you write your code so that it compiles as both C and C++ (in which case you <em>have to</em> cast the return value of <code>malloc</code> when assigning it to something other than <code>void *</code>), you can do a very helpful thing for yourself: you can use macros for casting which translate to C++ style casts when compiling as C++, but reduce to a C cast when compiling as C:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-comment">/* In a header somewhere */</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> strip_qual(TYPE, EXPR) (const_cast<span class="hljs-string">&lt;TYPE&gt;</span>(EXPR))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> convert(TYPE, EXPR) (static_cast<span class="hljs-string">&lt;TYPE&gt;</span>(EXPR))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> coerce(TYPE, EXPR) (reinterpret_cast<span class="hljs-string">&lt;TYPE&gt;</span>(EXPR))</span>
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> strip_qual(TYPE, EXPR) ((TYPE) (EXPR))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> convert(TYPE, EXPR) ((TYPE) (EXPR))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> coerce(TYPE, EXPR) ((TYPE) (EXPR))</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>

<p>If you adhere to these macros, then a simple <code>grep</code> search of your code base for these identifiers will show you where all your casts are, so you can review whether any of them are incorrect.</p>

<p>Then, going forward, if you regularly compile the code with C++, it will enforce the use of an appropriate cast. For instance, if you use <code>strip_qual</code> just to remove a <code>const</code> or <code>volatile</code>, but the program changes in such a way that a type conversion is now involved, you will get a diagnostic, and you will have to use a combination of casts to get the desired conversion.</p>

<p>To help you adhere to these macros, the the GNU C++ (not C!) compiler has a beautiful feature: an optional diagnostic which is produced for all occurrences of C style casts.</p>

<pre>     -Wold-style-cast (C++ and Objective-C++ only)
         Warn if an old-style (C-style) cast to a non-void type is used
         within a C++ program.  The new-style casts (dynamic_cast,
         static_cast, reinterpret_cast, and const_cast) are less vulnerable
         to unintended effects and much easier to search for.
</pre>

<p>If your C code compiles as C++, you can use this <code>-Wold-style-cast</code> option to find out all occurrences of the <code>(type)</code> casting syntax that may creep into the code, and follow up on these diagnostics by replacing it with an appropriate choice from among the above macros (or a combination, if necessary).</p>

<p>This treatment of conversions is the single largest standalone technical justification for working in a "Clean C": the combined C and C++ dialect, which in turn technically justifies casting the return value of <code>malloc</code>.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 21</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The best thing to do when programming in C whenever it is possible:</p>

<ol>
<li>Make your program compile through a C compiler with all warnings turned on <code>-Wall</code> and fix all errors and warnings</li>
<li>Make sure there are no variables declared as <code>auto</code></li>
<li>Then compile it using a C++ compiler with <code>-Wall</code> and <code>-std=c++11</code>. Fix all errors and warnings.</li>
<li>Now compile using the C compiler again. Your program should now compile without any warning and contain fewer bugs.</li>
</ol>

<p>This procedure lets you take advantage of C++ strict type checking, thus reducing the number of bugs. In particular, this procedure forces you to include <code>stdlib.h</code>or you will get</p>

<blockquote>
  <p><code>malloc</code> was not declared within this scope</p>
</blockquote>

<p>and also forces you to cast the result of <code>malloc</code> or you will get</p>

<blockquote>
  <p>invalid conversion from <code>void*</code> to <code>T*</code></p>
</blockquote>

<p>or what ever your target type is.</p>

<p>The only benefits from writing in C instead of C++ I can find are</p>

<ol>
<li>C has a well specified ABI</li>
<li>C++ may generate more code [exceptions, RTTI, templates, <em>runtime</em> polymorphism]</li>
</ol>

<p>Notice that the second cons should in the ideal case disappear when using the subset common to C together with the <em>static</em> polymorphic feature.</p>

<p>For those that finds C++ strict rules inconvenient, we can use the C++11 feature with inferred  type</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-keyword">auto</span> memblock=static_cast&lt;T*&gt;(<span class="hljs-built_in">malloc</span>(n*<span class="hljs-keyword">sizeof</span>(T))); <span class="hljs-comment">//Mult may overflow...</span>
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 22</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I prefer to do the cast, but not manually. My favorite is using <code>g_new</code> and <code>g_new0</code> macros from glib. If glib is not used, I would add similar macros. Those macros reduce code duplication without compromising type safety. If you get the type wrong, you would get an implicit cast between non-void pointers, which would cause a warning (error in C++). If you forget to include the header that defines <code>g_new</code> and <code>g_new0</code>, you would get an error. <code>g_new</code> and <code>g_new0</code> both take the same arguments, unlike <code>malloc</code> that takes fewer arguments than <code>calloc</code>. Just add <code>0</code> to get zero-initialized memory. The code can be compiled with a C++ compiler without changes.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 23</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Casting is only for C++ not C.In case you are using a C++ compiler you better change it to C compiler.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 24</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>The casting of malloc is unnecessary in C but mandatory in C++.</strong></p>

<p>Casting is unnecessary in C because of:</p>

<ul>
<li><code>void *</code> is automatically and safely promoted to any other pointer type in the case of C.</li>
<li>It can hide an error if you forgot to include <code>&lt;stdlib.h&gt;</code>. This can cause crashes.</li>
<li>If pointers and integers are differently sized, then you're hiding a warning by casting and might lose bits of your returned address.</li>
<li>If the type of the pointer is changed at its declaration, one may also need to change all lines where <code>malloc</code> is called and cast.</li>
</ul>

<p>On the other hand, casting may increase the portability of your program. i.e, it allows a C program or function to compile as C++.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 25</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The concept behind void pointer is that it can be casted to any data type that is why malloc returns void. Also you must be aware of automatic typecasting. So it is not mandatory to cast the pointer though you must do it. It helps in keeping the code clean and helps debugging</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 26</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A void pointer is a generic pointer and C supports implicit conversion from a void pointer type to other types, so there is no need of explicitly typecasting it.</p>

<p>However, if you want the same code work perfectly compatible on a C++ platform, which does not support implicit conversion, you need to do the typecasting, so it all depends on usability.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 27</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<ol>
<li><p>As other stated, it is not needed for C, but for C++.</p></li>
<li><p>Including the cast may allow a C program or function to compile as C++.</p></li>
<li><p>In C it is unnecessary, as void * is automatically and safely promoted to any other pointer type.</p></li>
<li><p>But if you cast then, it can hide an error if you forgot to include
<strong>stdlib.h</strong>. This can cause crashes (or, worse, not cause a crash
until way later in some totally different part of the code).</p>

<p>Because <strong>stdlib.h</strong> contains the prototype for malloc is found. In the
absence of a prototype for malloc, the standard requires that the C
compiler assumes malloc returns an int. If there is no cast, a
warning is issued when this integer is assigned to the pointer;
however, with the cast, this warning is not produced, hiding a bug.</p></li>
</ol>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 28</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The main issue with <code>malloc</code> is to get the <em>right size</em>.</p>
<p>The memory returned form <code>malloc()</code> is <em>untyped</em>, and it will not magically gain an <em>effective type</em> due to a simple cast.</p>
<p>I guess that both approaches are fine and the choice should depend on programmer intention.</p>
<ol>
<li>If allocating memory for a <strong>type</strong>, then use a cast.</li>
</ol>
<p><code>ptr = (T*)malloc(sizeof(T));</code></p>
<ol start="2">
<li>If allocating memory for a given pointer, then don't use a cast.</li>
</ol>
<p><code>ptr = malloc(sizeof *ptr);</code></p>
<h3>Ad 1</h3>
<p>The first method assures the correct size by allocating memory for a given type, and then casting it to assure that it is assigned to the right pointer. If incorrect type of <code>ptr</code> is used then the compiler will issue a warning/error. If the type of <code>ptr</code> is changed, then the compiler will point the places where the code needs refactoring.</p>
<p>Moreover, the first method can be combined into a macro similar to <code>new</code> operator in C++.</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NEW(T) ((T*)malloc(sizeof(T)))</span>
...
ptr = NEW(T);
</code></pre>
<p>Moreover this method works if <code>ptr</code> is <code>void*</code>.</p>
<h2>Ad 2</h2>
<p>The second methods does not care about the types, it assures the correct size by taking it from the pointer's type. The main advantage of this method is the automatic adjustment of storage size whenever the type of <code>ptr</code> is changed.
It can save some time (or errors) when refactoring.</p>
<p>The disadvantage is that the method does not work if <code>ptr</code> is <code>void*</code> but it may be perceived as a good thing. And that it does not work with C++ so it should not be used in inlined functions in headers that are going to be used by C++ programs.</p>
<p>Personally, I prefer the second option.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 29</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>For me, the take home and conclusion here is that casting <code>malloc</code> in C is totally NOT necessary but if you however cast, it wont affect <code>malloc</code> as <code>malloc</code> will still allocate to you your requested blessed memory space.
Another take home is the reason or one of the reasons people do casting and this is to enable them compile same program either in C or C++.</p>

<p>There may be other reasons but other reasons, almost certainly, would land you in serious trouble sooner or later.</p>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;h3\u0026gt;TL;DR\u0026lt;/h3\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *sieve = (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *) \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;) * length);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;has two problems. The cast and that you\u0026apos;re using the type instead of variable as argument for sizeof. Instead, do like this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *sieve = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; *sieve * length);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h3\u0026gt;Long version\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;No\u0026lt;/strong\u0026gt;; you \u0026lt;em\u0026gt;don\u0026apos;t\u0026lt;/em\u0026gt; cast the result, since:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;It is unnecessary, as \u0026lt;code\u0026gt;void *\u0026lt;/code\u0026gt; is automatically and safely promoted to any other pointer type in this case.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It adds clutter to the code, casts are not very easy to read (especially if the pointer type is long).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It makes you repeat yourself, which is generally bad.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It can hide an error if you forgot to include \u0026lt;code\u0026gt;\u0026amp;lt;stdlib.h\u0026amp;gt;\u0026lt;/code\u0026gt;. This can cause crashes (or, worse, \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; cause a crash until way later in some totally different part of the code). Consider what happens if pointers and integers are differently sized; then you\u0026apos;re hiding a warning by casting and might lose bits of your returned address. Note: as of C99 implicit functions are gone from C, and this point is no longer relevant since there\u0026apos;s no automatic assumption that undeclared functions return \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;As a clarification, note that I said \u0026quot;you don\u0026apos;t cast\u0026quot;, not \u0026quot;you don\u0026apos;t \u0026lt;em\u0026gt;need\u0026lt;/em\u0026gt; to cast\u0026quot;. In my opinion, it\u0026apos;s a failure to include the cast, even if you got it right. There are simply no benefits to doing it, but a bunch of potential risks, and including the cast indicates that you don\u0026apos;t know about the risks.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Also note, as commentators point out, that the above talks about straight C, not C++. I very firmly believe in C and C++ as separate languages.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;To add further, your code needlessly repeats the type information (\u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;) which can cause errors. It\u0026apos;s better to de-reference the pointer being used to store the return value, to \u0026quot;lock\u0026quot; the two together:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *sieve = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(length * \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; *sieve);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This also moves the \u0026lt;code\u0026gt;length\u0026lt;/code\u0026gt; to the front for increased visibility, and drops the redundant parentheses with \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt;; they \u0026lt;em\u0026gt;are only needed\u0026lt;/em\u0026gt; when the argument is a type name. Many people seem to not know (or ignore) this, which makes their code more verbose. Remember: \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt; is not a function! :)\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;While moving \u0026lt;code\u0026gt;length\u0026lt;/code\u0026gt; to the front \u0026lt;em\u0026gt;may\u0026lt;/em\u0026gt; increase visibility in some rare cases, one should also pay attention that in the general case, it should be better to write the expression as:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *sieve = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; *sieve * length);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Since keeping the \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt; first, in this case, ensures multiplication is done with at least \u0026lt;code\u0026gt;size_t\u0026lt;/code\u0026gt; math.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Compare: \u0026lt;code\u0026gt;malloc(sizeof *sieve * length * width)\u0026lt;/code\u0026gt; vs. \u0026lt;code\u0026gt;malloc(length * width * sizeof *sieve)\u0026lt;/code\u0026gt; the second may overflow the \u0026lt;code\u0026gt;length * width\u0026lt;/code\u0026gt; when \u0026lt;code\u0026gt;width\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;length\u0026lt;/code\u0026gt; are smaller types than \u0026lt;code\u0026gt;size_t\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In C, you don\u0026apos;t need to cast the return value of \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt;. The pointer to void returned by \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; is automagically converted to the correct type. However, if you want your code to compile with a C++ compiler, a cast is needed. A preferred alternative among the community is to use the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *sieve = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; *sieve * length);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;which additionally frees you from having to worry about changing the right-hand side of the expression if ever you change the type of \u0026lt;code\u0026gt;sieve\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Casts are bad, as people have pointed out. Especially pointer casts. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You \u0026lt;strong\u0026gt;do\u0026lt;/strong\u0026gt; cast, because:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;It makes your code \u0026lt;strong\u0026gt;more portable\u0026lt;/strong\u0026gt; between C and C++, and as SO experience shows, a great many programmers claim they are writing in C when they are really writing in C++ (or C plus local compiler extensions).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Failing to do so \u0026lt;strong\u0026gt;can hide an error\u0026lt;/strong\u0026gt;: note all the SO examples of confusing when to write \u0026lt;code\u0026gt;type *\u0026lt;/code\u0026gt; versus \u0026lt;code\u0026gt;type **\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The idea that it keeps you from noticing you failed to \u0026lt;code\u0026gt;#include\u0026lt;/code\u0026gt; an appropriate header file misses \u0026lt;strong\u0026gt;the forest for the trees\u0026lt;/strong\u0026gt;. It\u0026apos;s the same as saying \u0026quot;don\u0026apos;t worry about the fact you failed to ask the compiler to complain about not seeing prototypes -- that pesky stdlib.h is the REAL important thing to remember!\u0026quot;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It forces an \u0026lt;strong\u0026gt;extra cognitive cross-check\u0026lt;/strong\u0026gt;. It puts the (alleged) desired type right next to the arithmetic you\u0026apos;re doing for the raw size of that variable. I bet you could do an SO study that shows that \u0026lt;code\u0026gt;malloc()\u0026lt;/code\u0026gt; bugs are caught much faster when there\u0026apos;s a cast. As with assertions, annotations that reveal intent decrease bugs. \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Repeating yourself in a way that the machine can check is often a \u0026lt;strong\u0026gt;great\u0026lt;/strong\u0026gt; idea. In fact, that\u0026apos;s what an assertion is, and this use of cast is an assertion. Assertions are still the most general technique we have for getting code correct, since Turing came up with the idea so many years ago.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As others stated, it is not needed for C, but necessary for C++. If you think you are going to compile your C code with a C++ compiler, for whatever reasons, you can use a macro instead, like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ifdef\u0026lt;/span\u0026gt; __cplusplus\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; NEW(type, count) ((type *)calloc(count, sizeof(type)))\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; NEW(type, count) (calloc(count, sizeof(type)))\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;endif\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;That way you can still write it in a very compact way:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *sieve = NEW(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and it will compile for C and C++.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;From the \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/C_dynamic_memory_allocation#Advantages_to_casting\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Wikipedia\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Advantages to casting\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n  \n  \u0026lt;ul\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Including the cast may allow a C program or function to compile as C++.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;p\u0026gt;The cast allows for pre-1989 versions of malloc that originally returned a char *.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Casting can help the developer identify inconsistencies in type sizing should the destination pointer type change, particularly if the pointer is declared far from the malloc() call (although modern compilers and static analyzers can warn on such behaviour without requiring the cast).\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n  \u0026lt;/ul\u0026gt;\n  \n  \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Disadvantages to casting\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n  \n  \u0026lt;ul\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Under the ANSI C standard, the cast is redundant.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Adding the cast may mask failure to include the header \u0026lt;em\u0026gt;stdlib.h\u0026lt;/em\u0026gt;, in\n  which the prototype for malloc is found. In the absence of a\n  prototype for malloc, the standard requires that the C compiler\n  assume malloc returns an int. If there is no cast, a warning is\n  issued when this integer is assigned to the pointer; however, with\n  the cast, this warning is not produced, hiding a bug. On certain\n  architectures and data models (such as LP64 on 64-bit systems, where\n  long and pointers are 64-bit and int is 32-bit), this error can\n  actually result in undefined behaviour, as the implicitly declared\n  malloc returns a 32-bit value whereas the actually defined function\n  returns a 64-bit value. Depending on calling conventions and memory\n  layout, this may result in stack smashing. This issue is less likely\n  to go unnoticed in modern compilers, as they uniformly produce\n  warnings that an undeclared function has been used, so a warning will\n  still appear. For example, GCC\u0026apos;s default behaviour is to show a\n  warning that reads \u0026quot;incompatible implicit declaration of built-in\n  function\u0026quot; regardless of whether the cast is present or not.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If the type of the pointer is changed at its declaration, one may\n  also, need to change all lines where malloc is called and cast.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n  \u0026lt;/ul\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Although \u0026lt;strong\u0026gt;malloc without casting is preferred method and most experienced programmers choose it\u0026lt;/strong\u0026gt;, you should use whichever you like having aware of the issues.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;i.e: If you need to compile C program as C++ (Although it is a separate language) you must cast the result of use \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt;. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In C you can implicitly convert a \u0026lt;code\u0026gt;void\u0026lt;/code\u0026gt; pointer to any other kind of pointer, so a cast is not necessary. Using one may suggest to the casual observer that there is some reason why one is needed, which may be misleading.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You don\u0026apos;t cast the result of \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt;, because doing so adds pointless clutter to your code.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The most common reason why people cast the result of \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; is because they are unsure about how the C language works. That\u0026apos;s a warning sign: if you don\u0026apos;t know how a particular language mechanism works, then \u0026lt;em\u0026gt;don\u0026apos;t\u0026lt;/em\u0026gt; take a guess. Look it up or ask on Stack Overflow.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Some comments:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;A void pointer can be converted to/from any other pointer type without an explicit cast (C11 6.3.2.3 and 6.5.16.1).\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;C++ will however not allow an implicit cast between \u0026lt;code\u0026gt;void*\u0026lt;/code\u0026gt; and another pointer type. So in C++, the cast would have been correct. But if you program in C++, you should use \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; and not \u0026lt;code\u0026gt;malloc()\u0026lt;/code\u0026gt;. And you should never compile C code using a C++ compiler.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If you need to support both C and C++ with the same source code, use compiler switches to mark the differences. Do not attempt to sate both language standards with the same code, because they are not compatible.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If a C compiler cannot find a function because you forgot to include the header, you will get a compiler/linker error about that. So if you forgot to include \u0026lt;code\u0026gt;\u0026amp;lt;stdlib.h\u0026amp;gt;\u0026lt;/code\u0026gt; that\u0026apos;s no biggie, you won\u0026apos;t be able to build your program.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;On ancient compilers that follow a version of the standard which is more than 25 years old, forgetting to include \u0026lt;code\u0026gt;\u0026amp;lt;stdlib.h\u0026amp;gt;\u0026lt;/code\u0026gt; would result in dangerous behavior. Because in that ancient standard, functions without a visible prototype implicitly converted the return type to \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;. Casting the result from \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; explicitly would then hide away this bug.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;But that is really a non-issue. You aren\u0026apos;t using a 25 years old computer, so why would you use a 25 years old compiler?\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In C you get an implicit conversion from \u0026lt;code\u0026gt;void *\u0026lt;/code\u0026gt; to any other (data) pointer.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Casting the value returned by \u0026lt;code\u0026gt;malloc()\u0026lt;/code\u0026gt; is not necessary now, but I\u0026apos;d like to add one point that seems no one has pointed out:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In the ancient days, that is, before \u0026lt;strong\u0026gt;ANSI C\u0026lt;/strong\u0026gt; provides the \u0026lt;code\u0026gt;void *\u0026lt;/code\u0026gt; as the generic type of pointers, \u0026lt;code\u0026gt;char *\u0026lt;/code\u0026gt; is the type for such usage. In that case, the cast can shut down the compiler warnings.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Reference: \u0026lt;a href=\u0026quot;http://c-faq.com/malloc/cast.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;C FAQ\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Just adding my experience, studying computer engineering I see that the two or three professors that I have seen writing in C always cast malloc, however the one I asked (with an immense CV and understanding of C) told me that it is absolutely unnecessary but only used to be absolutely specific, and to get the students into the mentality of being absolutely specific. Essentially casting will not change anything in how it works, it does exactly what it says, allocates memory, and casting does not effect it, you get the same memory, and even if you cast it to something else by mistake (and somehow evade compiler errors) C will access it the same way.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Edit:\u0026lt;/strong\u0026gt; Casting has a certain point. When you use array notation, the code generated has to know how many memory places it has to advance to reach the beginning of the next element, this is achieved through casting. This way you know that for a double you go 8 bytes ahead while for an int you go 4, and so on. Thus it has no effect if you use pointer notation, in array notation it becomes necessary.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It is not mandatory to cast the results of \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt;, since it returns \u0026lt;code\u0026gt;void*\u0026lt;/code\u0026gt; , and a \u0026lt;code\u0026gt;void*\u0026lt;/code\u0026gt; can be pointed to any datatype. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is what \u0026lt;a href=\u0026quot;http://www.gnu.org/software/libc/manual/html_node/Basic-Allocation.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;The GNU C Library Reference\u0026lt;/a\u0026gt; manual says: \u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;You can store the result of \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; into any pointer variable without a\n  cast, because ISO C automatically converts the type \u0026lt;code\u0026gt;void *\u0026lt;/code\u0026gt; to another\n  type of pointer when necessary. But the cast is necessary in contexts\n  other than assignment operators or if you might want your code to run\n  in traditional C.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;And indeed the \u0026lt;a href=\u0026quot;http://www.compsci.hunter.cuny.edu/~sweiss/resources/c11standard.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;ISO C11 standard\u0026lt;/a\u0026gt; (p347) says so: \u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The pointer returned if the allocation succeeds is suitably aligned so\n  that it may be assigned to a pointer to any type of object with a\n  fundamental alignment requirement and then used to access such an\n  object or an array of such objects in the space allocated (until the\n  space is explicitly deallocated)\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A void pointer is a generic object pointer and C supports implicit conversion from a void pointer type to other types, so there is no need of explicitly typecasting it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However, if you want the same code work perfectly compatible on a C++ platform, which does not support implicit conversion, you need to do the typecasting, so it all depends on usability.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The returned type is void*, which can be cast to the desired type of data pointer in order to be dereferenceable.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It depends on the programming language and compiler. If you use \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; in C, there is no need to type cast it, as it will automatically type cast. However, if you are using C++, then you should type cast because \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; will return a \u0026lt;code\u0026gt;void*\u0026lt;/code\u0026gt; type.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In the C language, a void pointer can be assigned to any pointer, which is why you should not use a type cast. If you want \u0026quot;type safe\u0026quot; allocation, I can recommend the following macro functions, which I always use in my C projects:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdlib.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; NEW_ARRAY(ptr, n) (ptr) = malloc((n) * sizeof *(ptr))\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; NEW(ptr) NEW_ARRAY((ptr), 1)\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;With these in place you can simply say\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;NEW_ARRAY(sieve, length);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;For non-dynamic arrays, the third must-have function macro is\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; LEN(arr) (sizeof (arr) / sizeof (arr)[0])\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;which makes array loops safer and more convenient:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i, a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;];\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; LEN(a); i++) {\n   ...\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;People used to GCC and Clang are spoiled.  It\u0026apos;s not all that good out there.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I have been pretty horrified over the years by the staggeringly aged compilers I\u0026apos;ve been required to use.  Often companies and managers adopt an ultra-conservative approach to changing compilers and will not even \u0026lt;em\u0026gt;test\u0026lt;/em\u0026gt; if a new compiler ( with better standards compliance and code optimization ) will work in their system.  The practical reality for working developers is that when you\u0026apos;re coding you need to cover your bases and, unfortunately, casting mallocs is a good habit if you cannot control what compiler may be applied to your code.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I would also suggest that many organizations apply a coding standard of their own and that \u0026lt;em\u0026gt;that\u0026lt;/em\u0026gt; should be the method people follow if it is defined.  In the absence of explicit guidance I tend to go for most likely to compile everywhere, rather than slavish adherence to a standard.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The argument that it\u0026apos;s not necessary under current standards is quite valid.  But that argument omits the practicalities of the real world.  We do not code in a world ruled exclusively by the standard of the day, but by the practicalities of what I like to call \u0026quot;local management\u0026apos;s reality field\u0026quot;.  And that\u0026apos;s bent and twisted more than space time ever was. :-)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;YMMV.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I tend to think of casting malloc as a defensive operation.  Not pretty, not perfect, but generally safe.  ( Honestly, if you\u0026apos;ve not included stdlib.h then you\u0026apos;ve \u0026lt;em\u0026gt;way\u0026lt;/em\u0026gt; more problems than casting malloc ! ).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;\u0026lt;strong\u0026gt;This question is subject of opinion-based abuse.\u0026lt;/strong\u0026gt;\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;Sometimes I notice comments like that:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc\u0026quot;\u0026gt;Don\u0026apos;t cast the result of malloc\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;or\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc\u0026quot;\u0026gt;Why you don\u0026apos;t cast the result of malloc\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;on questions where OP uses casting. The comments itself contain a hyperlink to this question.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;That is in \u0026lt;em\u0026gt;any\u0026lt;/em\u0026gt; possible manner inappropriate and incorrect as well. There is no right and no wrong when it is truly a matter of one\u0026apos;s own coding-style.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;Why is this happening?\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;It\u0026apos;s based upon two reasons:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;This question is indeed opinion-based. Technically, the question should have been closed as opinion-based years ago. A \u0026quot;\u0026lt;em\u0026gt;Do I\u0026lt;/em\u0026gt;\u0026quot; or \u0026quot;\u0026lt;em\u0026gt;Don\u0026apos;t I\u0026lt;/em\u0026gt;\u0026quot; or equivalent \u0026quot;\u0026lt;em\u0026gt;Should I\u0026lt;/em\u0026gt;\u0026quot; or \u0026quot;\u0026lt;em\u0026gt;Shouldn\u0026apos;t I\u0026lt;/em\u0026gt;\u0026quot; question, you just can\u0026apos;t answer focused without an attitude of one\u0026apos;s own opinion. One of the reason to close a question is because it \u0026quot;might lead to opinion-based answers\u0026quot; as it is well shown here.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Many answers (including the most apparent and accepted \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/605858/12139179\u0026quot;\u0026gt;answer\u0026lt;/a\u0026gt; of \u0026lt;a href=\u0026quot;https://stackoverflow.com/users/28169/unwind\u0026quot;\u0026gt;@unwind\u0026lt;/a\u0026gt;) are either completely or almost entirely opinion-based (f.e. a mysterious \u0026quot;clutter\u0026quot; that would be added to your code if you do casting or repeating yourself would be bad) and show a clear and focused tendency to omit the cast. They argue about the redundancy of the cast on one side but also and even worse argue to solve a bug caused by a bug/failure of programming itself - to not \u0026lt;code\u0026gt;#include \u0026amp;lt;stdlib.h\u0026amp;gt;\u0026lt;/code\u0026gt; if one want to use \u0026lt;code\u0026gt;malloc()\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;I want to bring a true view of some points discussed, with less of my personal opinion. A few points need to be noted especially:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Such a very susceptible question to fall into one\u0026apos;s own opinion needs an answer with neutral pros and cons. Not only cons or pros.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A good overview of pros and cons is listed in this answer:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/a/33047365/12139179\u0026quot;\u0026gt;https://stackoverflow.com/a/33047365/12139179\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;(I personally consider this because of that reason the best answer, so far.)\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;ol start=\u0026quot;2\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;One reason which is encountered at most to reason the omission of the cast is that the cast might hide a bug.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If someone uses an implicit declared \u0026lt;code\u0026gt;malloc()\u0026lt;/code\u0026gt; that returns \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; (implicit functions are gone from the standard since C99) and \u0026lt;code\u0026gt;sizeof(int) != sizeof(int*)\u0026lt;/code\u0026gt;, as shown in this question\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://stackoverflow.com/q/7545365/168175\u0026quot;\u0026gt;Why does this code segfault on 64-bit architecture but work fine on 32-bit?\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;the cast would hide a bug.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;While this is true, it only shows half of the story as the omission of the cast would only be a forward-bringing solution to an even bigger bug - not including \u0026lt;code\u0026gt;stdlib.h\u0026lt;/code\u0026gt; when using \u0026lt;code\u0026gt;malloc()\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This will never be a serious issue, If you,\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Use a compiler compliant to C99 or above (which is recommended and should be mandatory), and\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Aren\u0026apos;t so absent to forgot to include \u0026lt;code\u0026gt;stdlib.h\u0026lt;/code\u0026gt;, when you want to use \u0026lt;code\u0026gt;malloc()\u0026lt;/code\u0026gt; in your code, which is a huge bug itself.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;ol start=\u0026quot;3\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Some people argue about C++ compliance of C code, as the cast is obliged in C++.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;First of all to say in general: Compiling C code with a C++ compiler is not a good practice.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;C and C++ are in fact two completely different languages with different semantics.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;But If you really want/need to make C code compliant to C++ and vice versa use compiler switches instead of any cast.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Since the cast is with tendency declared as redundant or even harmful, I want to take a focus on these questions, which give good reasons why casting can be useful or even necessary:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/a/34094068/12139179\u0026quot;\u0026gt;https://stackoverflow.com/a/34094068/12139179\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/a/36297486/12139179\u0026quot;\u0026gt;https://stackoverflow.com/a/36297486/12139179\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/a/33044300/12139179\u0026quot;\u0026gt;https://stackoverflow.com/a/33044300/12139179\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;ol start=\u0026quot;4\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;The cast can be non-beneficial when your code, respectively the type of the assigned pointer (and with that the type of the cast), changes, although this is in most cases unlikely. Then you would need to maintain/change all casts too and if you have a few thousand calls to memory-management functions in your code, this can really summarizing up and decrease the maintenance efficiency.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;Summary:\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Fact is, that the cast is redundant per the C standard (already since ANSI-C (C89/C90)) if the assigned pointer point to an object of fundamental alignment requirement (which includes the most of all objects).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;You don\u0026apos;t need to do the cast as the pointer is automatically aligned in this case:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026quot;The order and contiguity of storage allocated by successive calls to the aligned_alloc, calloc, malloc, and realloc functions is unspecified. \u0026lt;strong\u0026gt;The pointer returned if the allocation succeeds is suitably aligned so that it may be assigned to a pointer to any type of object with a fundamental alignment requirement\u0026lt;/strong\u0026gt; and then used to access such an object or an array of such objects in the space allocated (until the space is explicitly deallocated).\u0026quot;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Source: C18, §7.22.3/1\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026quot;A \u0026lt;em\u0026gt;fundamental alignment\u0026lt;/em\u0026gt; is a valid alignment less than or equal to \u0026lt;code\u0026gt;_Alignof (max_align_t)\u0026lt;/code\u0026gt;. Fundamental alignments shall be supported by the implementation for objects of all storage durations. The alignment requirements of the following types shall be fundamental alignments:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;  all atomic, qualified, or unqualified basic types;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;  all atomic, qualified, or unqualified enumerated types;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;  all atomic, qualified, or unqualified pointer types;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;  all array types whose element type has a fundamental alignment requirement;57)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;  all types specified in Clause 7 as complete object types;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;  all structure or union types all of whose elements have types with fundamental alignment requirements and none of whose elements have an alignment specifier specifying an alignment that is not a fundamental alignment.\u0026lt;/p\u0026gt;\n\u0026lt;ol start=\u0026quot;57\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;As specified in 6.2.1, the later declaration might hide the prior declaration.\u0026quot;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;Source: C18, §6.2.8/2\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;However, if you allocate memory for an implementation-defined object of extended alignment requirement, the cast would be needed.\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;An \u0026lt;em\u0026gt;extended alignment\u0026lt;/em\u0026gt; is represented by an alignment greater than \u0026lt;code\u0026gt;_Alignof (max_align_t)\u0026lt;/code\u0026gt;. It is implementation-defined whether any extended alignments are supported and the storage durations for which they are supported. A type having an extended alignment requirement is an over-aligned type.58)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Source. C18, §6.2.8/3\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Everything else is a matter of the specific use case and one\u0026apos;s own opinion.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Please be careful how you educate yourself.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I recommend you to read \u0026lt;em\u0026gt;all\u0026lt;/em\u0026gt; of the answers made so far carefully first (as well as their comments which may point at a failure) and then build your own opinion if you or if you not cast the result of \u0026lt;code\u0026gt;malloc()\u0026lt;/code\u0026gt; at a specific case.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Please note:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;There is no right and wrong answer to that question. It is a matter of style and you yourself decide which way you choose (if you aren\u0026apos;t forced to by education or job of course). Please be aware of that and don\u0026apos;t let trick you\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;Last note: I voted to lately close this question as opinion-based, which is indeed needed since years. If you got the close/reopen privilege I would like to invite you to do so, too.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;No, you don\u0026apos;t cast the result of \u0026lt;code\u0026gt;malloc()\u0026lt;/code\u0026gt;.\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;In general, you \u0026lt;strong\u0026gt;don\u0026apos;t cast to or from \u0026lt;code\u0026gt;void *\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A typical reason given for not doing so is that failure to \u0026lt;code\u0026gt;#include \u0026amp;lt;stdlib.h\u0026amp;gt;\u0026lt;/code\u0026gt; could go unnoticed. This isn\u0026apos;t an issue anymore for a long time now as C99 made \u0026lt;em\u0026gt;implicit function declarations\u0026lt;/em\u0026gt; illegal, so if your compiler conforms to at least C99, you will get a diagnostic message.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But there\u0026apos;s a \u0026lt;strong\u0026gt;much stronger reason\u0026lt;/strong\u0026gt; not to introduce unnecessary pointer casts:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In C, a \u0026lt;strong\u0026gt;pointer cast is almost always an error\u0026lt;/strong\u0026gt;. This is because of the following rule (\u0026lt;strong\u0026gt;§6.5 p7\u0026lt;/strong\u0026gt; in N1570, the latest draft for C11):\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;An object shall have its stored value accessed only by an lvalue expression that has one of\n  the following types:\u0026lt;br\u0026gt;\n   a type compatible with the effective type of the object,\u0026lt;br\u0026gt;\n   a qualified version of a type compatible with the effective type of the object,\u0026lt;br\u0026gt;\n   a type that is the signed or unsigned type corresponding to the effective type of the\n  object,\u0026lt;br\u0026gt;\n   a type that is the signed or unsigned type corresponding to a qualified version of the\n  effective type of the object,\u0026lt;br\u0026gt;\n   an aggregate or union type that includes one of the aforementioned types among its\n  members (including, recursively, a member of a subaggregate or contained union), or\u0026lt;br\u0026gt;\n   a character type.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;This is also known as the \u0026lt;em\u0026gt;strict aliasing rule\u0026lt;/em\u0026gt;. So the following code is \u0026lt;em\u0026gt;undefined behavior\u0026lt;/em\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; *p = (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; *)\u0026amp;amp;x;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; y = *p;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And, sometimes surprisingly, the following is as well:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-class\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt; {\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x; };\n\u0026lt;span class=\u0026quot;hljs-class\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt; {\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; y; };\n\u0026lt;span class=\u0026quot;hljs-class\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt; =\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;};\n\u0026lt;span class=\u0026quot;hljs-class\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;p\u0026lt;/span\u0026gt; =\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; foo *)\u0026amp;amp;b;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; z = p-\u0026amp;gt;x;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Sometimes, you \u0026lt;strong\u0026gt;do\u0026lt;/strong\u0026gt; need to cast pointers, but given the \u0026lt;em\u0026gt;strict aliasing rule\u0026lt;/em\u0026gt;, you have to be very careful with it. So, any occurrence of a pointer cast in your code is a place you \u0026lt;strong\u0026gt;have to double-check for its validity\u0026lt;/strong\u0026gt;. Therefore, you never write an unnecessary pointer cast.\u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;tl;dr\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;In a nutshell: Because in C, \u0026lt;strong\u0026gt;any\u0026lt;/strong\u0026gt; occurrence of a \u0026lt;em\u0026gt;pointer cast\u0026lt;/em\u0026gt; should raise a red flag for code requiring special attention, you should never write \u0026lt;em\u0026gt;unnecessary\u0026lt;/em\u0026gt; pointer casts.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Side notes:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;There are cases where you actually \u0026lt;em\u0026gt;need\u0026lt;/em\u0026gt; a cast to \u0026lt;code\u0026gt;void *\u0026lt;/code\u0026gt;, e.g. if you want to print a pointer:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%p\\n\u0026quot;\u0026lt;/span\u0026gt;, (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; *)\u0026amp;amp;x);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The cast is necessary here, because \u0026lt;code\u0026gt;printf()\u0026lt;/code\u0026gt; is a variadic function, so implicit conversions don\u0026apos;t work.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;In C++, the situation is different. Casting pointer types is somewhat common (and correct) when dealing with objects of derived classes. Therefore, it makes sense that in C++, the conversion to and from \u0026lt;code\u0026gt;void *\u0026lt;/code\u0026gt; is \u0026lt;strong\u0026gt;not\u0026lt;/strong\u0026gt; implicit. C++ has a whole set of different flavors of casting.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I put in the cast simply to show disapproval of the ugly hole in the type system, which allows code such as the following snippet to compile without diagnostics, even though no casts are used to bring about the bad conversion:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; d;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; *p = \u0026amp;amp;d;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *q = p;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I wish that didn\u0026apos;t exist (and it doesn\u0026apos;t in C++) and so I cast. It represents my taste, and my programming politics. I\u0026apos;m not only casting a pointer, but effectively, casting a ballot, and \u0026lt;a href=\u0026quot;http://dilbert.com/strip/1994-02-03\u0026quot;\u0026gt;casting out demons of stupidity\u0026lt;/a\u0026gt;. If I can\u0026apos;t \u0026lt;em\u0026gt;actually\u0026lt;/em\u0026gt; \u0026lt;a href=\u0026quot;http://dilbert.com/strip/1994-02-02\u0026quot;\u0026gt;cast out stupidity\u0026lt;/a\u0026gt;, then at least let me express the wish to do so with a gesture of protest.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In fact, a good practice is to wrap \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; (and friends) with functions that return \u0026lt;code\u0026gt;unsigned char *\u0026lt;/code\u0026gt;, and basically never to use \u0026lt;code\u0026gt;void *\u0026lt;/code\u0026gt; in your code.  If you need a generic pointer-to-any-object, use a \u0026lt;code\u0026gt;char *\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;unsigned char *\u0026lt;/code\u0026gt;, and have casts in both directions. The one relaxation that can be indulged, perhaps, is using functions like \u0026lt;code\u0026gt;memset\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;memcpy\u0026lt;/code\u0026gt; without casts.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;On the topic of casting and C++ compatibility, if you write your code so that it compiles as both C and C++ (in which case you \u0026lt;em\u0026gt;have to\u0026lt;/em\u0026gt; cast the return value of \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; when assigning it to something other than \u0026lt;code\u0026gt;void *\u0026lt;/code\u0026gt;), you can do a very helpful thing for yourself: you can use macros for casting which translate to C++ style casts when compiling as C++, but reduce to a C cast when compiling as C:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* In a header somewhere */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ifdef\u0026lt;/span\u0026gt; __cplusplus\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; strip_qual(TYPE, EXPR) (const_cast\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;TYPE\u0026amp;gt;\u0026lt;/span\u0026gt;(EXPR))\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; convert(TYPE, EXPR) (static_cast\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;TYPE\u0026amp;gt;\u0026lt;/span\u0026gt;(EXPR))\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; coerce(TYPE, EXPR) (reinterpret_cast\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;TYPE\u0026amp;gt;\u0026lt;/span\u0026gt;(EXPR))\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; strip_qual(TYPE, EXPR) ((TYPE) (EXPR))\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; convert(TYPE, EXPR) ((TYPE) (EXPR))\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; coerce(TYPE, EXPR) ((TYPE) (EXPR))\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;endif\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If you adhere to these macros, then a simple \u0026lt;code\u0026gt;grep\u0026lt;/code\u0026gt; search of your code base for these identifiers will show you where all your casts are, so you can review whether any of them are incorrect.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Then, going forward, if you regularly compile the code with C++, it will enforce the use of an appropriate cast. For instance, if you use \u0026lt;code\u0026gt;strip_qual\u0026lt;/code\u0026gt; just to remove a \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;volatile\u0026lt;/code\u0026gt;, but the program changes in such a way that a type conversion is now involved, you will get a diagnostic, and you will have to use a combination of casts to get the desired conversion.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To help you adhere to these macros, the the GNU C++ (not C!) compiler has a beautiful feature: an optional diagnostic which is produced for all occurrences of C style casts.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;     -Wold-style-cast (C++ and Objective-C++ only)\n         Warn if an old-style (C-style) cast to a non-void type is used\n         within a C++ program.  The new-style casts (dynamic_cast,\n         static_cast, reinterpret_cast, and const_cast) are less vulnerable\n         to unintended effects and much easier to search for.\n\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If your C code compiles as C++, you can use this \u0026lt;code\u0026gt;-Wold-style-cast\u0026lt;/code\u0026gt; option to find out all occurrences of the \u0026lt;code\u0026gt;(type)\u0026lt;/code\u0026gt; casting syntax that may creep into the code, and follow up on these diagnostics by replacing it with an appropriate choice from among the above macros (or a combination, if necessary).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This treatment of conversions is the single largest standalone technical justification for working in a \u0026quot;Clean C\u0026quot;: the combined C and C++ dialect, which in turn technically justifies casting the return value of \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The best thing to do when programming in C whenever it is possible:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Make your program compile through a C compiler with all warnings turned on \u0026lt;code\u0026gt;-Wall\u0026lt;/code\u0026gt; and fix all errors and warnings\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Make sure there are no variables declared as \u0026lt;code\u0026gt;auto\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Then compile it using a C++ compiler with \u0026lt;code\u0026gt;-Wall\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;-std=c++11\u0026lt;/code\u0026gt;. Fix all errors and warnings.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Now compile using the C compiler again. Your program should now compile without any warning and contain fewer bugs.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;This procedure lets you take advantage of C++ strict type checking, thus reducing the number of bugs. In particular, this procedure forces you to include \u0026lt;code\u0026gt;stdlib.h\u0026lt;/code\u0026gt;or you will get\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; was not declared within this scope\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;and also forces you to cast the result of \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; or you will get\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;invalid conversion from \u0026lt;code\u0026gt;void*\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;T*\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;or what ever your target type is.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The only benefits from writing in C instead of C++ I can find are\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;C has a well specified ABI\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;C++ may generate more code [exceptions, RTTI, templates, \u0026lt;em\u0026gt;runtime\u0026lt;/em\u0026gt; polymorphism]\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;Notice that the second cons should in the ideal case disappear when using the subset common to C together with the \u0026lt;em\u0026gt;static\u0026lt;/em\u0026gt; polymorphic feature.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For those that finds C++ strict rules inconvenient, we can use the C++11 feature with inferred  type\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; memblock=static_cast\u0026amp;lt;T*\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(n*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(T))); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Mult may overflow...\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I prefer to do the cast, but not manually. My favorite is using \u0026lt;code\u0026gt;g_new\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;g_new0\u0026lt;/code\u0026gt; macros from glib. If glib is not used, I would add similar macros. Those macros reduce code duplication without compromising type safety. If you get the type wrong, you would get an implicit cast between non-void pointers, which would cause a warning (error in C++). If you forget to include the header that defines \u0026lt;code\u0026gt;g_new\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;g_new0\u0026lt;/code\u0026gt;, you would get an error. \u0026lt;code\u0026gt;g_new\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;g_new0\u0026lt;/code\u0026gt; both take the same arguments, unlike \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; that takes fewer arguments than \u0026lt;code\u0026gt;calloc\u0026lt;/code\u0026gt;. Just add \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt; to get zero-initialized memory. The code can be compiled with a C++ compiler without changes.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Casting is only for C++ not C.In case you are using a C++ compiler you better change it to C compiler.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;The casting of malloc is unnecessary in C but mandatory in C++.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Casting is unnecessary in C because of:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;void *\u0026lt;/code\u0026gt; is automatically and safely promoted to any other pointer type in the case of C.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It can hide an error if you forgot to include \u0026lt;code\u0026gt;\u0026amp;lt;stdlib.h\u0026amp;gt;\u0026lt;/code\u0026gt;. This can cause crashes.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If pointers and integers are differently sized, then you\u0026apos;re hiding a warning by casting and might lose bits of your returned address.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the type of the pointer is changed at its declaration, one may also need to change all lines where \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; is called and cast.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;On the other hand, casting may increase the portability of your program. i.e, it allows a C program or function to compile as C++.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The concept behind void pointer is that it can be casted to any data type that is why malloc returns void. Also you must be aware of automatic typecasting. So it is not mandatory to cast the pointer though you must do it. It helps in keeping the code clean and helps debugging\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A void pointer is a generic pointer and C supports implicit conversion from a void pointer type to other types, so there is no need of explicitly typecasting it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However, if you want the same code work perfectly compatible on a C++ platform, which does not support implicit conversion, you need to do the typecasting, so it all depends on usability.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;As other stated, it is not needed for C, but for C++.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Including the cast may allow a C program or function to compile as C++.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;In C it is unnecessary, as void * is automatically and safely promoted to any other pointer type.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;But if you cast then, it can hide an error if you forgot to include\n\u0026lt;strong\u0026gt;stdlib.h\u0026lt;/strong\u0026gt;. This can cause crashes (or, worse, not cause a crash\nuntil way later in some totally different part of the code).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Because \u0026lt;strong\u0026gt;stdlib.h\u0026lt;/strong\u0026gt; contains the prototype for malloc is found. In the\nabsence of a prototype for malloc, the standard requires that the C\ncompiler assumes malloc returns an int. If there is no cast, a\nwarning is issued when this integer is assigned to the pointer;\nhowever, with the cast, this warning is not produced, hiding a bug.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The main issue with \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; is to get the \u0026lt;em\u0026gt;right size\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The memory returned form \u0026lt;code\u0026gt;malloc()\u0026lt;/code\u0026gt; is \u0026lt;em\u0026gt;untyped\u0026lt;/em\u0026gt;, and it will not magically gain an \u0026lt;em\u0026gt;effective type\u0026lt;/em\u0026gt; due to a simple cast.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I guess that both approaches are fine and the choice should depend on programmer intention.\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;If allocating memory for a \u0026lt;strong\u0026gt;type\u0026lt;/strong\u0026gt;, then use a cast.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;ptr = (T*)malloc(sizeof(T));\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ol start=\u0026quot;2\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;If allocating memory for a given pointer, then don\u0026apos;t use a cast.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;ptr = malloc(sizeof *ptr);\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Ad 1\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;The first method assures the correct size by allocating memory for a given type, and then casting it to assure that it is assigned to the right pointer. If incorrect type of \u0026lt;code\u0026gt;ptr\u0026lt;/code\u0026gt; is used then the compiler will issue a warning/error. If the type of \u0026lt;code\u0026gt;ptr\u0026lt;/code\u0026gt; is changed, then the compiler will point the places where the code needs refactoring.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Moreover, the first method can be combined into a macro similar to \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; operator in C++.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; NEW(T) ((T*)malloc(sizeof(T)))\u0026lt;/span\u0026gt;\n...\nptr = NEW(T);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Moreover this method works if \u0026lt;code\u0026gt;ptr\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;void*\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Ad 2\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;The second methods does not care about the types, it assures the correct size by taking it from the pointer\u0026apos;s type. The main advantage of this method is the automatic adjustment of storage size whenever the type of \u0026lt;code\u0026gt;ptr\u0026lt;/code\u0026gt; is changed.\nIt can save some time (or errors) when refactoring.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The disadvantage is that the method does not work if \u0026lt;code\u0026gt;ptr\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;void*\u0026lt;/code\u0026gt; but it may be perceived as a good thing. And that it does not work with C++ so it should not be used in inlined functions in headers that are going to be used by C++ programs.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Personally, I prefer the second option.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;For me, the take home and conclusion here is that casting \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; in C is totally NOT necessary but if you however cast, it wont affect \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; as \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; will still allocate to you your requested blessed memory space.\nAnother take home is the reason or one of the reasons people do casting and this is to enable them compile same program either in C or C++.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There may be other reasons but other reasons, almost certainly, would land you in serious trouble sooner or later.\u0026lt;/p\u0026gt;\n    "],"comment":["\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026lt;a href=\u0026quot;http://stackoverflow.com/q/7545365/168175\u0026quot;\u0026gt;stackoverflow.com/q/7545365/168175\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/168175/flexo\u0026quot; title=\u0026quot;85,154 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Flexo\u0026lt;/a\u0026gt;\n\u0026lt;span class=\u0026quot;mod-flair \u0026quot; title=\u0026quot;Moderator\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment11088903_605845\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-01-15 20:06:32Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 15, 2012 at 20:06\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Casts are evil.  I see so many cast in code just as a result of bad coding practice. Whenever you need to insert one the first thing you should ask yourselves is \u0026quot; what is wrong here\u0026quot; . Is everything declared as it should  be ? If it is no cast would be needed so something is declared wrong. If you really do need to do some low level stuff on individual bytes in an int or so consider a union to access them. That\u0026apos;ll declare them just fine. As a rule of thumb do not insert them unless the compiler complains. Then avoid them. This example will not complain. void pointer will promote to any type.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/5717390/hans-lepoeter\u0026quot; title=\u0026quot;139 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Hans Lepoeter\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment117225829_605845\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2021-02-21 21:52:05Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 21, 2021 at 21:52\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@HansLepoeter in C++ , those are necessary for malloc, giving some basis to my notion that there\u0026apos;s something wrong with it\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/13651625/an-ant\u0026quot; title=\u0026quot;172 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;An Ant\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment117385253_605845\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2021-02-27 11:51:14Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 27, 2021 at 11:51\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Please consider updating the answer. The cast is no longer dangerous, and repeating oneself is not necessarily a bad thing (redundancy can help catch errors).\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/775806/n-1-8e9-wheres-my-share-m\u0026quot; title=\u0026quot;103,757 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;n. 1.8e9-where\u0026apos;s-my-share m.\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment69286315_605858\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-12-08 12:30:35Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 8, 2016 at 12:30\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Compilers have changed. An up-to-date compiler will warn you about a missing declaration of malloc.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/775806/n-1-8e9-wheres-my-share-m\u0026quot; title=\u0026quot;103,757 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;n. 1.8e9-where\u0026apos;s-my-share m.\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment69286663_605858\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-12-08 12:40:04Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 8, 2016 at 12:40\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@n.m. Ok. I think it\u0026apos;s bad to assume that anyone reading here has a particular compiler. Also, since C11 the entire \u0026quot;implicit function\u0026quot; concept is gone, I didn\u0026apos;t know that. Still, I don\u0026apos;t see the point in adding a pointless cast. Do you also do \u0026lt;code\u0026gt;int x = (int) 12;\u0026lt;/code\u0026gt; just to make things clear?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/28169/unwind\u0026quot; title=\u0026quot;380,300 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;unwind\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment69286973_605858\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-12-08 12:48:47Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 8, 2016 at 12:48\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@n.m. if explicitly casting a void pointer \u0026quot;helped\u0026quot; solve a bug, you more likely encountered undefined behavior, which would mean the program in question likely has a far worse, undiscovered bug that you haven\u0026apos;t run into yet. And one day, on a cold winter evening, you\u0026apos;ll come home from work to find your GitHub page flooded with issue reports complaining about demons flying out of the users\u0026apos; noses\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1175714/braden-best\u0026quot; title=\u0026quot;8,310 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Braden Best\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment69603081_605858\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-12-17 18:49:29Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 17, 2016 at 18:49\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@unwind Even I agree with you, \u0026lt;code\u0026gt;(int)12\u0026lt;/code\u0026gt; is not comparable. \u0026lt;code\u0026gt;12\u0026lt;/code\u0026gt; \u0026lt;i\u0026gt;is\u0026lt;/i\u0026gt; an \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;, the cast does simply nothing. The retval of \u0026lt;code\u0026gt;malloc()\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;void *\u0026lt;/code\u0026gt;, not the pointer type casted to. (If it is not \u0026lt;code\u0026gt;void *\u0026lt;/code\u0026gt;. So the analogy to \u0026lt;code\u0026gt;(int)12\u0026lt;/code\u0026gt; would be \u0026lt;code\u0026gt;(void*)malloc()\u0026lt;/code\u0026gt; what nobody is discussing.)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/676558/amin-negm-awad\u0026quot; title=\u0026quot;16,329 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Amin Negm-Awad\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment70264633_605858\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-01-08 04:30:50Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 8, 2017 at 4:30\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@MAKZ I\u0026apos;d argue that \u0026lt;code\u0026gt;malloc(length * sizeof *sieve)\u0026lt;/code\u0026gt; makes it look like \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt; is a variable - so I think \u0026lt;code\u0026gt;malloc(length * sizeof(*sieve))\u0026lt;/code\u0026gt; is more readable.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/221955/michael-anderson\u0026quot; title=\u0026quot;66,515 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Michael Anderson\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment48042597_605856\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-04-30 07:02:33Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 30, 2015 at 7:02\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;And \u0026lt;code\u0026gt;malloc(length * (sizeof *sieve))\u0026lt;/code\u0026gt; more readable still.  IMHO.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/4850040/toby-speight\u0026quot; title=\u0026quot;25,310 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Toby Speight\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment52130296_605856\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-08-20 13:01:17Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 20, 2015 at 13:01\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Michael Anderson \u0026lt;code\u0026gt;()\u0026lt;/code\u0026gt; issue aside, note that your suggested style switched the order.,  Consider when element count is computed like \u0026lt;code\u0026gt;length*width\u0026lt;/code\u0026gt;, keeping the \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt; first in this case insures multiplication is done with at least \u0026lt;code\u0026gt;size_t\u0026lt;/code\u0026gt; math.  Compare \u0026lt;code\u0026gt;malloc(sizeof( *ptr) * length * width)\u0026lt;/code\u0026gt; vs.  \u0026lt;code\u0026gt;malloc(length * width * sizeof (*ptr))\u0026lt;/code\u0026gt; - the 2nd may overflow the \u0026lt;code\u0026gt;length*width\u0026lt;/code\u0026gt; when \u0026lt;code\u0026gt;width,length\u0026lt;/code\u0026gt; are smaller types that \u0026lt;code\u0026gt;size_t\u0026lt;/code\u0026gt;.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2410359/chux-reinstate-monica\u0026quot; title=\u0026quot;128,312 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;chux - Reinstate Monica\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment56158851_605856\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-12-10 16:40:42Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 10, 2015 at 16:40\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@chux it\u0026apos;s not obvious, but the answer has been edited so that my comment is less pertinent - the original suggestion was \u0026lt;code\u0026gt;malloc(sizeof *sieve * length)\u0026lt;/code\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/221955/michael-anderson\u0026quot; title=\u0026quot;66,515 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Michael Anderson\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment56172863_605856\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-12-11 00:18:32Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 11, 2015 at 0:18\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;C is not C++.  Pretending that they are will ultimately lead to confusion and sadness.  If you\u0026apos;re using C++, then a C-style cast is also bad (unless you\u0026apos;re using a very old C++ compiler).  And \u0026lt;code\u0026gt;static_cast\u0026amp;gt;()\u0026lt;/code\u0026gt; (or \u0026lt;code\u0026gt;reinterpret_cast\u0026amp;lt;\u0026amp;gt;()\u0026lt;/code\u0026gt; )is not compatible with any dialect of C.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3754173/david-c\u0026quot; title=\u0026quot;635 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;David C.\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment58453424_605856\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-02-12 23:12:57Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 12, 2016 at 23:12\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@ulidtko In case you did not know, it\u0026apos;s possible to write code which compiles both as C and as C++. In fact most header files are like this, and they often contain code (macros and inline functions). Having a \u0026lt;code\u0026gt;.c\u0026lt;/code\u0026gt;/\u0026lt;code\u0026gt;.cpp\u0026lt;/code\u0026gt; file to compile as both is not useful very often, but one case is adding C++ \u0026lt;code\u0026gt;throw\u0026lt;/code\u0026gt; support when compiled with C++ compiler (but \u0026lt;code\u0026gt;return -1;\u0026lt;/code\u0026gt; when compiled with C compiler, or whatever).\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1717300/hyde\u0026quot; title=\u0026quot;56,062 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;hyde\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment22182515_14879184\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-03-26 11:09:25Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 26, 2013 at 11:09\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 3 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;If someone had malloc calls inline in a header I wouldn\u0026apos;t be impressed, #ifdef __cplusplus and extern \u0026quot;C\u0026quot; {} are for this job, not adding in extra casts.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1124744/paulm\u0026quot; title=\u0026quot;5,428 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;paulm\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment23517131_14879184\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-05-06 17:55:52Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 6, 2013 at 17:55\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Well, point 1 is irrelevant, since C != C++, the other points are also trivial, if you use \u0026lt;i\u0026gt;the variable\u0026lt;/i\u0026gt; in your \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; call: \u0026lt;code\u0026gt;char **foo = malloc(3*sizeof(*foo));\u0026lt;/code\u0026gt; if quite full-proof: 3 pointers to char pointers. then loop, and do \u0026lt;code\u0026gt;foo[i] = calloc(101, sizeof(*(foo[i])));\u0026lt;/code\u0026gt;. Allocate array of 101 chars, neatly initialized to zeroes. No cast needed. change the declaration to \u0026lt;code\u0026gt;unsigned char\u0026lt;/code\u0026gt; or any other type, for that matter, and you\u0026apos;re still good\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1230836/elias-van-ootegem\u0026quot; title=\u0026quot;71,388 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Elias Van Ootegem\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment31087918_14879184\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-12-23 15:37:42Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 23, 2013 at 15:37\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;When I tought I got it, there it comes! Fantastic answer. Its the first time here in StackOverflow that I +1 two opposite answers! +1 No, you dont cast, and +1 Yes, you do cast! LOL. You guys are terrific. And for me and my students, I made my mind: I do cast. The kind of errors students make are more easily spotted when casting.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/670521/drbeco\u0026quot; title=\u0026quot;10,614 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;DrBeco\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment40812095_14879184\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-09-26 03:22:34Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 26, 2014 at 3:22\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Leushenko: Repeating yourself in a way that cannot be validated by machine nor by local inspection is bad.  Repeating yourself in ways that can be validated by such means is less bad.  Given \u0026lt;code\u0026gt;struct Zebra *p; ... p=malloc(sizeof struct Zebra);\u0026lt;/code\u0026gt;, the malloc can\u0026apos;t avoid duplciating information about p\u0026apos;s type, but neither the compiler nor local code inspection would detect any problem if one type changed but the other didn\u0026apos;t.  Change the code to \u0026lt;code\u0026gt;p=(struct Zebra*)malloc(sizeof struct Zebra);\u0026lt;/code\u0026gt; and the compiler will squawk if the cast type doesn\u0026apos;t match \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt;, and \u0026lt;i\u0026gt;local\u0026lt;/i\u0026gt; inspection will reveal...\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/363751/supercat\u0026quot; title=\u0026quot;73,697 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;supercat\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment53162479_14879184\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-09-18 17:46:23Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 18, 2015 at 17:46\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Since you\u0026apos;re using a macro anyway, why don\u0026apos;t you use \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; in the definition of C++?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/41283/hosam-aly\u0026quot; title=\u0026quot;40,351 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Hosam Aly\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment421855_605994\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-03-04 06:13:08Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 4, 2009 at 6:13\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Because there is no reason to do so. It is mainly for C programs that are compiled with a C++ compiler. If you are going to use \u0026apos;new\u0026apos;, the only thing you get are problems. You need then also a macro for free. And you need a macro to free an array, a differentiation that doesn\u0026apos;t exists in C.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/18687/quinmars\u0026quot; title=\u0026quot;10,865 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;quinmars\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment422157_605994\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-03-04 08:51:30Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 4, 2009 at 8:51\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Not to mention if it\u0026apos;s not you who frees the memory but maybe a C library you are using, etc. Many possible problems without any gain.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/18687/quinmars\u0026quot; title=\u0026quot;10,865 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;quinmars\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment422160_605994\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-03-04 08:53:28Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 4, 2009 at 8:53\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Hosam: Yes, it definitely is. If you use \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; you must use \u0026lt;code\u0026gt;delete\u0026lt;/code\u0026gt; and if you use \u0026lt;code\u0026gt;malloc()\u0026lt;/code\u0026gt; you must you \u0026lt;code\u0026gt;free()\u0026lt;/code\u0026gt;. Never mix them.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1821/graeme-perrow\u0026quot; title=\u0026quot;54,451 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Graeme Perrow\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment7956940_605994\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-07-16 17:10:33Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 16, 2011 at 17:10\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;If one is going to take this approach, calling the macro \u0026lt;code\u0026gt;NEW\u0026lt;/code\u0026gt; is probably a bad idea since the resource is never returned using \u0026lt;code\u0026gt;delete\u0026lt;/code\u0026gt; (or \u0026lt;code\u0026gt;DELETE\u0026lt;/code\u0026gt;) so you\u0026apos;re mixing your vocabulary. Instead, naming it \u0026lt;code\u0026gt;MALLOC\u0026lt;/code\u0026gt;, or rather \u0026lt;code\u0026gt;CALLOC\u0026lt;/code\u0026gt; in this case, would make more sense.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/749284/mah\u0026quot; title=\u0026quot;38,308 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;mah\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment35332989_605994\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-04-16 15:23:27Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 16, 2014 at 15:23\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;What does \u0026quot;\u0026lt;i\u0026gt;Casting can help the developer identify inconsistencies in type sizing should the destination pointer type change, particularly if the pointer is declared far from the \u0026lt;code\u0026gt;malloc()\u0026lt;/code\u0026gt; call\u0026lt;/i\u0026gt;\u0026quot; mean? Could you give an example?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3049655/spikatrix\u0026quot; title=\u0026quot;19,842 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Spikatrix\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment61976917_33047365\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-05-14 06:26:46Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 14, 2016 at 6:26\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@CoolGuy: \u0026lt;a href=\u0026quot;http://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc?rq=1#comment53162479_14879184\u0026quot;\u0026gt;See an earlier comment on another answer\u0026lt;/a\u0026gt;.  But note that the \u0026lt;code\u0026gt;p = malloc(sizeof(*p) * count)\u0026lt;/code\u0026gt; idiom picks up changes in the type automatically, so you don\u0026apos;t have to get warnings and go change anything.  So this isn\u0026apos;t a real advantage vs. the best alternative for not-casting.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/224132/peter-cordes\u0026quot; title=\u0026quot;289,881 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Peter Cordes\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment67706628_33047365\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-10-24 15:02:51Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 24, 2016 at 15:02\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;This is the proper answer: There are pros and cons, and it boils down to a matter of taste (unless the code must compile as C++ -- then the cast is mandatory).\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3150802/peter-reinstate-monica\u0026quot; title=\u0026quot;14,033 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Peter - Reinstate Monica\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment68465173_33047365\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-11-15 17:00:22Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 15, 2016 at 17:00\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Point 3 is moot, since  If the type of the pointer is changed at its declaration, one should check every instance of malloc, realloc and free inolving that type.  Casting will force you to do just that.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2430669/micha%c3%abl-roy\u0026quot; title=\u0026quot;5,751 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Michaël Roy\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment76208723_33047365\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-06-18 01:46:57Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 18, 2017 at 1:46\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;If one forgets to include stdlib.h, and the program compiles, how does it link without a definition for malloc?  If it links and runs anyway, which instructions actually get run on that line for any given CPU?  I guess I should check godbolt...\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3638059/so-fix-the-vote-sorting-bug\u0026quot; title=\u0026quot;322 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;SO_fix_the_vote_sorting_bug\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment121385265_33047365\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2021-08-06 18:04:33Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 6, 2021 at 18:04\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Without the explicitly annotated type in the declarator, the cast is usually more common misleading by easily confusing between the intent to allocate an object (uninterested the initial value) and to allocate merely some (uninitialized) memory.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2307646/frankhb\u0026quot; title=\u0026quot;2,002 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;FrankHB\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment127609852_605862\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2022-05-13 09:02:37Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 13 at 9:02\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026quot;pointless clutter\u0026quot; is dismissive hyperbole that tends to derail any possibility of convincing anyone who doesn\u0026apos;t already agree with you.  A cast certainly isn\u0026apos;t pointless; Ron Burk\u0026apos;s and Kaz\u0026apos;s answers make arguments in favor of casting that I very much agree with.  Whether those concerns weigh more than the concerns you mention is a reasonable question to ask.  To me, your concerns look relatively minor compared to theirs.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2552290/don-hatch\u0026quot; title=\u0026quot;4,565 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Don Hatch\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment68003647_22538350\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-11-02 08:43:50Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 2, 2016 at 8:43\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026quot;A void pointer can be converted to/from any other pointer type without an explicit cast\u0026quot; is not supported by 6.3.2.3.  Perhaps you are thinking of \u0026quot;pointer to any object type\u0026quot;?  \u0026quot;void pointer\u0026quot; and \u0026quot;pointer to a function\u0026quot; are not so readily convertible.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2410359/chux-reinstate-monica\u0026quot; title=\u0026quot;128,312 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;chux - Reinstate Monica\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment77683368_22538350\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-07-27 21:07:44Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 27, 2017 at 21:07\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Indeed the reference was incomplete. The relevant part for the \u0026quot;implicitness\u0026quot; is the rule of simple assignment 6.5.16.1. \u0026quot;one operand is a pointer to an object type, and the other is a pointer to a qualified or unqualified version of void\u0026quot;. I\u0026apos;ve added this reference to the answer for completeness.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/584518/lundin\u0026quot; title=\u0026quot;175,730 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Lundin\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment86598794_22538350\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-04-12 08:55:08Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 12, 2018 at 8:55\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;As I\u0026apos;ve commented to \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/605858\u0026quot;\u0026gt;another answer\u0026lt;/a\u0026gt;, the reason is to prevent some confusion by abusing the C language rules. Also you cannot resolve the confusion without the complete rules of object creation of C (including how \u0026lt;i\u0026gt;effective type\u0026lt;/i\u0026gt; works), so the reasoning is quite incomplete. OTOH, the similar effects in the source code can be achieved in C++ by a class type with member \u0026lt;code\u0026gt;template\u0026amp;lt;T\u0026amp;gt; operator T*() const {...}\u0026lt;/code\u0026gt; to replace \u0026lt;code\u0026gt;void*\u0026lt;/code\u0026gt; here, but C++ still incurs no such confusion due to the stricter rules. The answer is also incomplete in this sense.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2307646/frankhb\u0026quot; title=\u0026quot;2,002 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;FrankHB\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment127608863_22538350\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2022-05-13 08:15:55Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 13 at 8:15\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@FrankHB What do you mean? The effective type isn\u0026apos;t affected by the cast. The returned object does not get an effective type until you write to it (\u0026quot;lvalue access\u0026quot;).\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/584518/lundin\u0026quot; title=\u0026quot;175,730 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Lundin\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment127609004_22538350\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2022-05-13 08:22:43Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 13 at 8:22\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Jens: OK, maybe the more proper wording is \u0026quot;implicit conversion\u0026quot;. Like use of integral variable in floating point expression.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/72896/efraim\u0026quot; title=\u0026quot;12,476 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;EFraim\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment13365767_605854\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-04-29 07:17:41Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 29, 2012 at 7:17\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@EFraim That would actually result in a cast, and an implicit one at that.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2988730/mad-physicist\u0026quot; title=\u0026quot;96,777 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Mad Physicist\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment54797826_605854\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-11-03 19:13:22Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 3, 2015 at 19:13\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Shutting up compiler warnings is a bad idea.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1374975/albert-van-der-horst\u0026quot; title=\u0026quot;760 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Albert van der Horst\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment60344374_17012303\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-04-01 17:33:56Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 1, 2016 at 17:33\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@AlbertvanderHorst Not if you\u0026apos;re doing so by solving the exact problem the warning is there to warn you of.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/770230/dan-bechard\u0026quot; title=\u0026quot;4,871 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Dan Bechard\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment60710635_17012303\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-04-11 17:17:37Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 11, 2016 at 17:17\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Dan . If by solving the exact problem is meant a rewrite of a subroutine to return modern ANSI C types instead of char *, I agree. I wouldn\u0026apos;t call that shutting up the compiler. Do not give in to managers who insists that there are no compiler warnings , instead of using them by each recompilation to find possible problems. Groetjes Albert\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1374975/albert-van-der-horst\u0026quot; title=\u0026quot;760 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Albert van der Horst\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment68022644_17012303\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-11-02 16:51:18Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 2, 2016 at 16:51\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Except as already mentioned, the cast might hide bugs and make the code harder to analyse for the compiler or static analyser.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/584518/lundin\u0026quot; title=\u0026quot;175,730 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Lundin\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment36768075_22720432\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-05-27 07:56:53Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 27, 2014 at 7:56\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026quot;Essentially casting will not change anything in how it works\u0026quot;.  Casting to the matching type should not change anything, but should the var\u0026apos;s type change and the cast no longer match, could problems come up?  IWOs, the cast and var type should be kept in sync - twice the maintenance work.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2410359/chux-reinstate-monica\u0026quot; title=\u0026quot;128,312 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;chux - Reinstate Monica\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment39739282_22720432\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-08-23 19:29:50Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 23, 2014 at 19:29\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I can see why Profs prefer casting.  Casting may be useful from an educational standpoint where it conveys to the instructor information and the student code does not need to be maintained - its throw-away code.  Yet from a coding, peer-review and \u0026lt;b\u0026gt;maintenance\u0026lt;/b\u0026gt; perspective, \u0026lt;code\u0026gt;p = malloc(sizeof *p * n);\u0026lt;/code\u0026gt; is so simple and better.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2410359/chux-reinstate-monica\u0026quot; title=\u0026quot;128,312 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;chux - Reinstate Monica\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment77684200_22720432\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-07-27 21:38:01Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 27, 2017 at 21:38\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;It\u0026apos;s not the fact that \u0026lt;code\u0026gt;void*\u0026lt;/code\u0026gt; can point to anything that enables this; it\u0026apos;s the fact that a \u0026lt;code\u0026gt;void*\u0026lt;/code\u0026gt; can be \u0026lt;i\u0026gt;implicitly converted\u0026lt;/i\u0026gt; to any other pointer type. To clarify the distinction, in C++ a \u0026lt;code\u0026gt;void*\u0026lt;/code\u0026gt; can still point to anything, but implicit conversion was removed, so one must cast.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2757035/underscore-d\u0026quot; title=\u0026quot;5,910 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;underscore_d\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment110832093_14762179\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2020-07-01 08:38:51Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 1, 2020 at 8:38\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;It\u0026apos;s not a normal use case to compile a single source as both C and C++ (as opposed, say, to using a header file containing declarations to link C and C++ code together).  Using \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; and friends in C++ is a good warning sign that it deserves special attention (or re-writing in C).\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/4850040/toby-speight\u0026quot; title=\u0026quot;25,310 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Toby Speight\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment52130152_24720210\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-08-20 12:57:54Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 20, 2015 at 12:57\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026lt;code\u0026gt;void*\u0026lt;/code\u0026gt; \u0026lt;i\u0026gt;can\u0026lt;/i\u0026gt; be cast to the desired type, but there is no need to do so as it will be automatically converted.  So the cast is not necessary, and in fact undesirable for the reasons mentioned in the high-scoring answers.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/4850040/toby-speight\u0026quot; title=\u0026quot;25,310 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Toby Speight\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment52130224_16241328\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-08-20 12:59:37Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 20, 2015 at 12:59\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;but only if you need to dereference it \u0026quot;on the fly\u0026quot;, if you create a variable instead it will be converted safely and automatically into the variable\u0026apos;s effective type, without casting (in C).\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2579927/ferrarezi\u0026quot; title=\u0026quot;723 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Ferrarezi\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment105458195_16241328\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2020-01-08 15:04:37Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 8, 2020 at 15:04\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;The function \u0026lt;i\u0026gt;malloc\u0026lt;/i\u0026gt; returns a void pointer in C as well but the rules of the language are different from C++.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/337149/august-karlstrom\u0026quot; title=\u0026quot;10,062 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;August Karlstrom\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment52690314_22455329\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-09-05 09:19:39Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 5, 2015 at 9:19\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 3 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026quot;a void pointer can be assigned to any \u0026lt;i\u0026gt;object\u0026lt;/i\u0026gt; pointer\u0026quot;  Function pointers are another issue, albeit not a \u0026lt;code\u0026gt;malloc()\u0026lt;/code\u0026gt; one.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2410359/chux-reinstate-monica\u0026quot; title=\u0026quot;128,312 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;chux - Reinstate Monica\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment77684243_32397391\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-07-27 21:39:36Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 27, 2017 at 21:39\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Assigning a \u0026lt;code\u0026gt;void*\u0026lt;/code\u0026gt; to/from a function pointer may lose information so \u0026quot;a void pointer can be assigned to any pointer,\u0026quot; is a problem in those cases.  Assigning  a \u0026lt;code\u0026gt;void*\u0026lt;/code\u0026gt;, from \u0026lt;code\u0026gt;malloc()\u0026lt;/code\u0026gt;  to any \u0026lt;i\u0026gt;object\u0026lt;/i\u0026gt; pointer is not an issue though.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2410359/chux-reinstate-monica\u0026quot; title=\u0026quot;128,312 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;chux - Reinstate Monica\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment82933971_32397391\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-12-26 19:09:04Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 26, 2017 at 19:09\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;This is pretty much the same thing as said in this old answer though: \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/22538350/584518\u0026quot;\u0026gt;stackoverflow.com/a/22538350/584518\u0026lt;/a\u0026gt;.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/584518/lundin\u0026quot; title=\u0026quot;175,730 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Lundin\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment110448709_62351067\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2020-06-18 14:03:35Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 18, 2020 at 14:03\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Lundin You must have pasted the wrong link, this answer is completely unrelated to this one afaics\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/5636775/ctx\u0026quot; title=\u0026quot;17,598 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Ctx\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment110449121_62351067\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2020-06-18 14:15:14Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 18, 2020 at 14:15\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@RobertSsupportsMonicaCellio What would you call the cast in this expression: \u0026lt;code\u0026gt;int x, y; x = (int)y;\u0026lt;/code\u0026gt; then? A matter of subjective coding style?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/584518/lundin\u0026quot; title=\u0026quot;175,730 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Lundin\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment110450453_62351067\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2020-06-18 14:49:44Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 18, 2020 at 14:49\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;This is a bad answer because it relies on the implicit claim that all arguments in this debate are of equal value, whereas this is obviously not the case. The arguments \u0026lt;i\u0026gt;in favour\u0026lt;/i\u0026gt; of the cast  with one niche exception (adherence to external code style requirements)  are simply bad arguments, for various reasons (from subjective to factually wrong). Its fallacious to conclude that, just because sides have nominal arguments, the decision is therefore a toss-up, or opinion-based. In the same vein youd both-side the non-scientific debates about biological evolution or global warming.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1968/konrad-rudolph\u0026quot; title=\u0026quot;508,410 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Konrad Rudolph\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment111683268_62351067\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2020-07-29 15:48:59Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 29, 2020 at 15:48\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@KonradRudolph I don\u0026apos;t see how opinion-based arguments in favor of the omission of the cast would have more value than arguments about that it is being allowed and can be used and I also do not understand why \u0026lt;i\u0026gt;all\u0026lt;/i\u0026gt; of the given arguments for casting are \u0026quot;\u0026lt;i\u0026gt;bad\u0026lt;/i\u0026gt;\u0026quot; arguments. The classification as \u0026quot;\u0026lt;i\u0026gt;bad\u0026lt;/i\u0026gt;\u0026quot; is also subjective and opinion-based and what I wanted to prevent with this answer with just plain facts.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/12139179/roberts-supports-monica-cellio\u0026quot; title=\u0026quot;13,801 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;RobertS supports Monica Cellio\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment111814017_62351067\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2020-08-03 15:40:19Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 3, 2020 at 15:40\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;In your examples you avoid void *. there is a difference between cast from double * to int * and vice versa. malloc returns pointel aligned to the largest standard type so there are no aliasing rules broken even if someone casts form this aligned pointer to other type.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/6110094/0\u0026quot; title=\u0026quot;47,460 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;0___________\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment78603919_45713482\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-08-22 16:38:37Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 22, 2017 at 16:38\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Aliasing has \u0026lt;b\u0026gt;nothing\u0026lt;/b\u0026gt; at all to do with alignment and for the rest of your comment -- you obviously didn\u0026apos;t get the point.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;span class=\u0026quot;comment-user\u0026quot;\u0026gt;user2371524\u0026lt;/span\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment78604066_45713482\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-08-22 16:43:08Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 22, 2017 at 16:43\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@PeterJ: just in case, the point is to \u0026lt;i\u0026gt;avoid\u0026lt;/i\u0026gt; an unnecessary pointer cast, so it doesn\u0026apos;t \u0026lt;i\u0026gt;look like\u0026lt;/i\u0026gt; a piece of code you have to pay special attention to.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;span class=\u0026quot;comment-user\u0026quot;\u0026gt;user2371524\u0026lt;/span\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment78604247_45713482\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-08-22 16:48:26Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 22, 2017 at 16:48\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;The strict aliasing issue doesn\u0026apos;t really have anything to do with void pointers. In order to get bugs caused by strict aliasing violations, you must de-reference the pointed-at data. And since you can\u0026apos;t de-reference a void pointer, such bugs are per definition not related to the void pointer but to something else.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/584518/lundin\u0026quot; title=\u0026quot;175,730 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Lundin\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment78621615_45713482\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-08-23 06:33:07Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 23, 2017 at 6:33\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Rather, you would have to make a rule to ban all pointer casts. But then how would you write things like serialization routines and hardware-related programming? Things that are C\u0026apos;s strength. Such casts are fine if you know what you are doing.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/584518/lundin\u0026quot; title=\u0026quot;175,730 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Lundin\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment78621736_45713482\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-08-23 06:36:40Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 23, 2017 at 6:36\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;As other pointed out, I would usually recommend to not mix C and C++ code. However, if you have good reason to do it, then macros might be useful.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2208372/phil1970\u0026quot; title=\u0026quot;2,543 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Phil1970\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment62974336_36297486\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-06-10 15:53:04Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 10, 2016 at 15:53\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Phil1970  It\u0026apos;s all written in one cohesive dialect, which happens to be portable to C and C++ compilers, and takes advantage of some capabilities of C++. It must be all compiled as C++, or else all compiled as C.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1250772/kaz\u0026quot; title=\u0026quot;52,154 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Kaz\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment62976218_36297486\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-06-10 16:45:03Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 10, 2016 at 16:45\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I.e. what I was trying to say in the previous comment is that there is no mixing of C and C++. The intent is that the code is all compiled as C or all compiled as C++.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1250772/kaz\u0026quot; title=\u0026quot;52,154 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Kaz\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment63101490_36297486\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-06-14 17:35:46Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 14, 2016 at 17:35\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Use a C compiler for C code.  Use a C++ compiler for C++ code.  No ifs, no buts.  Rewriting your C code in C++ is another thing entirely, and may - or may not be - worth the time and the risks.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/4850040/toby-speight\u0026quot; title=\u0026quot;25,310 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Toby Speight\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment50142059_30806757\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-06-25 21:06:29Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 25, 2015 at 21:06\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I\u0026apos;d like to add to @TobySpeight advice: If you need to use C code in a C++ project, you can usually compile the C code as C (e.g. \u0026lt;code\u0026gt;gcc -c c_code.c\u0026lt;/code\u0026gt;), the C++ code as C++ (e.g. \u0026lt;code\u0026gt;g++ -c cpp_code.cpp\u0026lt;/code\u0026gt;), \u0026lt;b\u0026gt;and then link them together\u0026lt;/b\u0026gt; (e.g. \u0026lt;code\u0026gt;gcc c_code.o cpp_code.o\u0026lt;/code\u0026gt; or vice-versa depending upon the project dependencies). Now there should be no reason to deprive yourself of any nice features of either language...\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1989425/autistic\u0026quot; title=\u0026quot;14,900 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;autistic\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment56023717_30806757\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-12-07 16:06:56Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 7, 2015 at 16:06\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@user877329 It\u0026apos;s a more sensible alternative to painstakingly adding casts to code that reduce the code\u0026apos;s legibility, only for the sake of being \u0026quot;C++ compatible\u0026quot;.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1989425/autistic\u0026quot; title=\u0026quot;14,900 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;autistic\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment56040155_30806757\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-12-08 00:54:29Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 8, 2015 at 0:54\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Other advantages to C over C++: C99 variable-length arrays for very efficient allocation/deallocation of scratch space.  You can\u0026apos;t accidentally write non-constant initializers when you didn\u0026apos;t mean to (e.g. if you thought you were being clever by putting \u0026lt;code\u0026gt;static const __m128 ones = _mm_set1_ps(1.0f);\u0026lt;/code\u0026gt; at the global scope so multiple functions could share a constant, the fact that constructors aren\u0026apos;t a thing in C stops you from generating worse code.  (This is really finding a silver lining to a C limitation...))\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/224132/peter-cordes\u0026quot; title=\u0026quot;289,881 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Peter Cordes\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment67706954_30806757\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-10-24 15:11:33Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 24, 2016 at 15:11\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Probably the main advantage in this context is that C lets you write \u0026lt;code\u0026gt;p = malloc(sizeof(*p));\u0026lt;/code\u0026gt;, which doesn\u0026apos;t need changing in the first place if \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt; changes to a different type name.  The proposed \u0026quot;advantage\u0026quot; of casting is that you get a compile error if \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt; is the wrong type, but it\u0026apos;s even better if it Just Works.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/224132/peter-cordes\u0026quot; title=\u0026quot;289,881 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Peter Cordes\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment67707050_30806757\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-10-24 15:13:48Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 24, 2016 at 15:13\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026quot;\u0026lt;i\u0026gt;It is not mandatory -- though you must do it\u0026lt;/i\u0026gt;\u0026quot; - I think there\u0026apos;s a contradiction there!\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/4850040/toby-speight\u0026quot; title=\u0026quot;25,310 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Toby Speight\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment52130016_31692193\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-08-20 12:54:52Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 20, 2015 at 12:54\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I think you should read this post to someone, and see if they understand what you are trying to say. Then rewrite it, making it clear what you want to say. I really can\u0026apos;t understand what your answer is.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1927206/bill-woodger\u0026quot; title=\u0026quot;12,850 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Bill Woodger\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment52777614_31692193\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-09-08 12:28:48Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 8, 2015 at 12:28\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        "],"id":15,"title":"Do I cast the result of malloc?","content":"\n                \n\u0026lt;p\u0026gt;In \u0026lt;a href=\u0026quot;http://stackoverflow.com/questions/571945/getting-a-stack-overflow-exception-when-declaring-a-large-array\u0026quot;\u0026gt;this question\u0026lt;/a\u0026gt;, someone suggested in a \u0026lt;a href=\u0026quot;http://stackoverflow.com/questions/571945/getting-a-stack-overflow-exception-when-declaring-a-large-array#comment388297_571961\u0026quot;\u0026gt;comment\u0026lt;/a\u0026gt; that I should \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;not\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; cast the result of \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt;. i.e., I should do this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *sieve = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(*sieve) * length);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;rather than:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *sieve = (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *) \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(*sieve) * length);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Why would this be the case?\u0026lt;/p\u0026gt;\n    ","slug":"do-i-cast-the-result-of-malloc-1657384271583","postType":"QUESTION","createdAt":"2022-07-09T16:31:11.000Z","updatedAt":"2022-07-09T16:31:11.000Z","tags":[{"id":51,"name":"malloc","slug":"malloc","createdAt":"2022-07-09T16:31:11.000Z","updatedAt":"2022-07-09T16:31:11.000Z","Questions_Tags":{"questionId":15,"tagId":51}},{"id":52,"name":"casting","slug":"casting","createdAt":"2022-07-09T16:31:11.000Z","updatedAt":"2022-07-09T16:31:11.000Z","Questions_Tags":{"questionId":15,"tagId":52}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"do-i-cast-the-result-of-malloc-1657384271583"},"buildId":"4Y8KGE-c2lolBeBmcum_I","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>