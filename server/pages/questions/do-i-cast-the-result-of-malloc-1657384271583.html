<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>Do I cast the result of malloc? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="In this question, someone suggested in a comment that I should not cast the result of malloc. i.e., I should do this:
int *sieve = malloc(sizeof(*sieve) * length);

rather than:
int *sieve = (int *) malloc(sizeof(*sieve) * length);

Why would this be the case?
    "/><meta property="og:title" content="Do I cast the result of malloc? | Solutions Checker"/><meta property="og:description" content="In this question, someone suggested in a comment that I should not cast the result of malloc. i.e., I should do this:
int *sieve = malloc(sizeof(*sieve) * length);

rather than:
int *sieve = (int *) malloc(sizeof(*sieve) * length);

Why would this be the case?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Do I cast the result of malloc?","text":"In this question, someone suggested in a comment that I should not cast the result of malloc. i.e., I should do this:\nint *sieve = malloc(sizeof(*sieve) * length);\n\nrather than:\nint *sieve = (int *) malloc(sizeof(*sieve) * length);\n\nWhy would this be the case?\n    ","answerCount":29,"upVoteCount":500,"suggestedAnswer":[{"text":"TL;DR\nint *sieve = (int *) malloc(sizeof(int) * length);\n\nhas two problems. The cast and that you&apos;re using the type instead of variable as argument for sizeof. Instead, do like this:\nint *sieve = malloc(sizeof *sieve * length);\n\nLong version\nNo; you don&apos;t cast the result, since:\n\nIt is unnecessary, as void * is automatically and safely promoted to any other pointer type in this case.\nIt adds clutter to the code, casts are not very easy to read (especially if the pointer type is long).\nIt makes you repeat yourself, which is generally bad.\nIt can hide an error if you forgot to include &lt;stdlib.h&gt;. This can cause crashes (or, worse, not cause a crash until way later in some totally different part of the code). Consider what happens if pointers and integers are differently sized; then you&apos;re hiding a warning by casting and might lose bits of your returned address. Note: as of C99 implicit functions are gone from C, and this point is no longer relevant since there&apos;s no automatic assumption that undeclared functions return int.\n\nAs a clarification, note that I said &quot;you don&apos;t cast&quot;, not &quot;you don&apos;t need to cast&quot;. In my opinion, it&apos;s a failure to include the cast, even if you got it right. There are simply no benefits to doing it, but a bunch of potential risks, and including the cast indicates that you don&apos;t know about the risks.\nAlso note, as commentators point out, that the above talks about straight C, not C++. I very firmly believe in C and C++ as separate languages.\nTo add further, your code needlessly repeats the type information (int) which can cause errors. It&apos;s better to de-reference the pointer being used to store the return value, to &quot;lock&quot; the two together:\nint *sieve = malloc(length * sizeof *sieve);\n\nThis also moves the length to the front for increased visibility, and drops the redundant parentheses with sizeof; they are only needed when the argument is a type name. Many people seem to not know (or ignore) this, which makes their code more verbose. Remember: sizeof is not a function! :)\n\nWhile moving length to the front may increase visibility in some rare cases, one should also pay attention that in the general case, it should be better to write the expression as:\nint *sieve = malloc(sizeof *sieve * length);\n\nSince keeping the sizeof first, in this case, ensures multiplication is done with at least size_t math.\nCompare: malloc(sizeof *sieve * length * width) vs. malloc(length * width * sizeof *sieve) the second may overflow the length * width when width and length are smaller types than size_t.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"In C, you don&apos;t need to cast the return value of malloc. The pointer to void returned by malloc is automagically converted to the correct type. However, if you want your code to compile with a C++ compiler, a cast is needed. A preferred alternative among the community is to use the following:\n\nint *sieve = malloc(sizeof *sieve * length);\n\n\nwhich additionally frees you from having to worry about changing the right-hand side of the expression if ever you change the type of sieve.\n\nCasts are bad, as people have pointed out. Especially pointer casts. \n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"You do cast, because:\n\n\nIt makes your code more portable between C and C++, and as SO experience shows, a great many programmers claim they are writing in C when they are really writing in C++ (or C plus local compiler extensions).\nFailing to do so can hide an error: note all the SO examples of confusing when to write type * versus type **.\nThe idea that it keeps you from noticing you failed to #include an appropriate header file misses the forest for the trees. It&apos;s the same as saying &quot;don&apos;t worry about the fact you failed to ask the compiler to complain about not seeing prototypes -- that pesky stdlib.h is the REAL important thing to remember!&quot;\nIt forces an extra cognitive cross-check. It puts the (alleged) desired type right next to the arithmetic you&apos;re doing for the raw size of that variable. I bet you could do an SO study that shows that malloc() bugs are caught much faster when there&apos;s a cast. As with assertions, annotations that reveal intent decrease bugs. \nRepeating yourself in a way that the machine can check is often a great idea. In fact, that&apos;s what an assertion is, and this use of cast is an assertion. Assertions are still the most general technique we have for getting code correct, since Turing came up with the idea so many years ago.\n\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"As others stated, it is not needed for C, but necessary for C++. If you think you are going to compile your C code with a C++ compiler, for whatever reasons, you can use a macro instead, like:\n\n#ifdef __cplusplus\n# define NEW(type, count) ((type *)calloc(count, sizeof(type)))\n#else\n# define NEW(type, count) (calloc(count, sizeof(type)))\n#endif\n\n\nThat way you can still write it in a very compact way:\n\nint *sieve = NEW(int, 1);\n\n\nand it will compile for C and C++.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"From the Wikipedia:\n\n\n  Advantages to casting\n  \n  \n  Including the cast may allow a C program or function to compile as C++.\n  The cast allows for pre-1989 versions of malloc that originally returned a char *.\n  Casting can help the developer identify inconsistencies in type sizing should the destination pointer type change, particularly if the pointer is declared far from the malloc() call (although modern compilers and static analyzers can warn on such behaviour without requiring the cast).\n  \n  \n  Disadvantages to casting\n  \n  \n  Under the ANSI C standard, the cast is redundant.\n  Adding the cast may mask failure to include the header stdlib.h, in\n  which the prototype for malloc is found. In the absence of a\n  prototype for malloc, the standard requires that the C compiler\n  assume malloc returns an int. If there is no cast, a warning is\n  issued when this integer is assigned to the pointer; however, with\n  the cast, this warning is not produced, hiding a bug. On certain\n  architectures and data models (such as LP64 on 64-bit systems, where\n  long and pointers are 64-bit and int is 32-bit), this error can\n  actually result in undefined behaviour, as the implicitly declared\n  malloc returns a 32-bit value whereas the actually defined function\n  returns a 64-bit value. Depending on calling conventions and memory\n  layout, this may result in stack smashing. This issue is less likely\n  to go unnoticed in modern compilers, as they uniformly produce\n  warnings that an undeclared function has been used, so a warning will\n  still appear. For example, GCC&apos;s default behaviour is to show a\n  warning that reads &quot;incompatible implicit declaration of built-in\n  function&quot; regardless of whether the cast is present or not.\n  If the type of the pointer is changed at its declaration, one may\n  also, need to change all lines where malloc is called and cast.\n  \n\n\nAlthough malloc without casting is preferred method and most experienced programmers choose it, you should use whichever you like having aware of the issues.\n\ni.e: If you need to compile C program as C++ (Although it is a separate language) you must cast the result of use malloc. \n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"In C you can implicitly convert a void pointer to any other kind of pointer, so a cast is not necessary. Using one may suggest to the casual observer that there is some reason why one is needed, which may be misleading.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"You don&apos;t cast the result of malloc, because doing so adds pointless clutter to your code.\nThe most common reason why people cast the result of malloc is because they are unsure about how the C language works. That&apos;s a warning sign: if you don&apos;t know how a particular language mechanism works, then don&apos;t take a guess. Look it up or ask on Stack Overflow.\nSome comments:\n\nA void pointer can be converted to/from any other pointer type without an explicit cast (C11 6.3.2.3 and 6.5.16.1).\n\nC++ will however not allow an implicit cast between void* and another pointer type. So in C++, the cast would have been correct. But if you program in C++, you should use new and not malloc(). And you should never compile C code using a C++ compiler.\nIf you need to support both C and C++ with the same source code, use compiler switches to mark the differences. Do not attempt to sate both language standards with the same code, because they are not compatible.\n\nIf a C compiler cannot find a function because you forgot to include the header, you will get a compiler/linker error about that. So if you forgot to include &lt;stdlib.h&gt; that&apos;s no biggie, you won&apos;t be able to build your program.\n\nOn ancient compilers that follow a version of the standard which is more than 25 years old, forgetting to include &lt;stdlib.h&gt; would result in dangerous behavior. Because in that ancient standard, functions without a visible prototype implicitly converted the return type to int. Casting the result from malloc explicitly would then hide away this bug.\nBut that is really a non-issue. You aren&apos;t using a 25 years old computer, so why would you use a 25 years old compiler?\n\n\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"In C you get an implicit conversion from void * to any other (data) pointer.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"Casting the value returned by malloc() is not necessary now, but I&apos;d like to add one point that seems no one has pointed out:\n\nIn the ancient days, that is, before ANSI C provides the void * as the generic type of pointers, char * is the type for such usage. In that case, the cast can shut down the compiler warnings.\n\nReference: C FAQ\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"Just adding my experience, studying computer engineering I see that the two or three professors that I have seen writing in C always cast malloc, however the one I asked (with an immense CV and understanding of C) told me that it is absolutely unnecessary but only used to be absolutely specific, and to get the students into the mentality of being absolutely specific. Essentially casting will not change anything in how it works, it does exactly what it says, allocates memory, and casting does not effect it, you get the same memory, and even if you cast it to something else by mistake (and somehow evade compiler errors) C will access it the same way.\n\nEdit: Casting has a certain point. When you use array notation, the code generated has to know how many memory places it has to advance to reach the beginning of the next element, this is achieved through casting. This way you know that for a double you go 8 bytes ahead while for an int you go 4, and so on. Thus it has no effect if you use pointer notation, in array notation it becomes necessary.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"It is not mandatory to cast the results of malloc, since it returns void* , and a void* can be pointed to any datatype. \n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"This is what The GNU C Library Reference manual says: \n\n\n  You can store the result of malloc into any pointer variable without a\n  cast, because ISO C automatically converts the type void * to another\n  type of pointer when necessary. But the cast is necessary in contexts\n  other than assignment operators or if you might want your code to run\n  in traditional C.\n\n\nAnd indeed the ISO C11 standard (p347) says so: \n\n\n  The pointer returned if the allocation succeeds is suitably aligned so\n  that it may be assigned to a pointer to any type of object with a\n  fundamental alignment requirement and then used to access such an\n  object or an array of such objects in the space allocated (until the\n  space is explicitly deallocated)\n\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"A void pointer is a generic object pointer and C supports implicit conversion from a void pointer type to other types, so there is no need of explicitly typecasting it.\n\nHowever, if you want the same code work perfectly compatible on a C++ platform, which does not support implicit conversion, you need to do the typecasting, so it all depends on usability.\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"The returned type is void*, which can be cast to the desired type of data pointer in order to be dereferenceable.\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"It depends on the programming language and compiler. If you use malloc in C, there is no need to type cast it, as it will automatically type cast. However, if you are using C++, then you should type cast because malloc will return a void* type.\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"In the C language, a void pointer can be assigned to any pointer, which is why you should not use a type cast. If you want &quot;type safe&quot; allocation, I can recommend the following macro functions, which I always use in my C projects:\n\n#include &lt;stdlib.h&gt;\n#define NEW_ARRAY(ptr, n) (ptr) = malloc((n) * sizeof *(ptr))\n#define NEW(ptr) NEW_ARRAY((ptr), 1)\n\n\nWith these in place you can simply say\n\nNEW_ARRAY(sieve, length);\n\n\nFor non-dynamic arrays, the third must-have function macro is\n\n#define LEN(arr) (sizeof (arr) / sizeof (arr)[0])\n\n\nwhich makes array loops safer and more convenient:\n\nint i, a[100];\n\nfor (i = 0; i &lt; LEN(a); i++) {\n   ...\n}\n\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"People used to GCC and Clang are spoiled.  It&apos;s not all that good out there.\n\nI have been pretty horrified over the years by the staggeringly aged compilers I&apos;ve been required to use.  Often companies and managers adopt an ultra-conservative approach to changing compilers and will not even test if a new compiler ( with better standards compliance and code optimization ) will work in their system.  The practical reality for working developers is that when you&apos;re coding you need to cover your bases and, unfortunately, casting mallocs is a good habit if you cannot control what compiler may be applied to your code.\n\nI would also suggest that many organizations apply a coding standard of their own and that that should be the method people follow if it is defined.  In the absence of explicit guidance I tend to go for most likely to compile everywhere, rather than slavish adherence to a standard.\n\nThe argument that it&apos;s not necessary under current standards is quite valid.  But that argument omits the practicalities of the real world.  We do not code in a world ruled exclusively by the standard of the day, but by the practicalities of what I like to call &quot;local management&apos;s reality field&quot;.  And that&apos;s bent and twisted more than space time ever was. :-)\n\nYMMV.\n\nI tend to think of casting malloc as a defensive operation.  Not pretty, not perfect, but generally safe.  ( Honestly, if you&apos;ve not included stdlib.h then you&apos;ve way more problems than casting malloc ! ).\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"This question is subject of opinion-based abuse.\nSometimes I notice comments like that:\n\nDon&apos;t cast the result of malloc\n\nor\n\nWhy you don&apos;t cast the result of malloc\n\non questions where OP uses casting. The comments itself contain a hyperlink to this question.\nThat is in any possible manner inappropriate and incorrect as well. There is no right and no wrong when it is truly a matter of one&apos;s own coding-style.\n\nWhy is this happening?\nIt&apos;s based upon two reasons:\n\nThis question is indeed opinion-based. Technically, the question should have been closed as opinion-based years ago. A &quot;Do I&quot; or &quot;Don&apos;t I&quot; or equivalent &quot;Should I&quot; or &quot;Shouldn&apos;t I&quot; question, you just can&apos;t answer focused without an attitude of one&apos;s own opinion. One of the reason to close a question is because it &quot;might lead to opinion-based answers&quot; as it is well shown here.\n\nMany answers (including the most apparent and accepted answer of @unwind) are either completely or almost entirely opinion-based (f.e. a mysterious &quot;clutter&quot; that would be added to your code if you do casting or repeating yourself would be bad) and show a clear and focused tendency to omit the cast. They argue about the redundancy of the cast on one side but also and even worse argue to solve a bug caused by a bug/failure of programming itself - to not #include &lt;stdlib.h&gt; if one want to use malloc().\n\n\n\nI want to bring a true view of some points discussed, with less of my personal opinion. A few points need to be noted especially:\n\nSuch a very susceptible question to fall into one&apos;s own opinion needs an answer with neutral pros and cons. Not only cons or pros.\nA good overview of pros and cons is listed in this answer:\nhttps://stackoverflow.com/a/33047365/12139179\n(I personally consider this because of that reason the best answer, so far.)\n\n\n\n\nOne reason which is encountered at most to reason the omission of the cast is that the cast might hide a bug.\nIf someone uses an implicit declared malloc() that returns int (implicit functions are gone from the standard since C99) and sizeof(int) != sizeof(int*), as shown in this question\nWhy does this code segfault on 64-bit architecture but work fine on 32-bit?\nthe cast would hide a bug.\nWhile this is true, it only shows half of the story as the omission of the cast would only be a forward-bringing solution to an even bigger bug - not including stdlib.h when using malloc().\nThis will never be a serious issue, If you,\n\nUse a compiler compliant to C99 or above (which is recommended and should be mandatory), and\n\nAren&apos;t so absent to forgot to include stdlib.h, when you want to use malloc() in your code, which is a huge bug itself.\n\n\n\n\n\n\nSome people argue about C++ compliance of C code, as the cast is obliged in C++.\nFirst of all to say in general: Compiling C code with a C++ compiler is not a good practice.\nC and C++ are in fact two completely different languages with different semantics.\nBut If you really want/need to make C code compliant to C++ and vice versa use compiler switches instead of any cast.\nSince the cast is with tendency declared as redundant or even harmful, I want to take a focus on these questions, which give good reasons why casting can be useful or even necessary:\n\nhttps://stackoverflow.com/a/34094068/12139179\n\nhttps://stackoverflow.com/a/36297486/12139179\n\nhttps://stackoverflow.com/a/33044300/12139179\n\n\n\n\n\n\nThe cast can be non-beneficial when your code, respectively the type of the assigned pointer (and with that the type of the cast), changes, although this is in most cases unlikely. Then you would need to maintain/change all casts too and if you have a few thousand calls to memory-management functions in your code, this can really summarizing up and decrease the maintenance efficiency.\n\n\nSummary:\nFact is, that the cast is redundant per the C standard (already since ANSI-C (C89/C90)) if the assigned pointer point to an object of fundamental alignment requirement (which includes the most of all objects).\nYou don&apos;t need to do the cast as the pointer is automatically aligned in this case:\n\n&quot;The order and contiguity of storage allocated by successive calls to the aligned_alloc, calloc, malloc, and realloc functions is unspecified. The pointer returned if the allocation succeeds is suitably aligned so that it may be assigned to a pointer to any type of object with a fundamental alignment requirement and then used to access such an object or an array of such objects in the space allocated (until the space is explicitly deallocated).&quot;\nSource: C18, ยง7.22.3/1\n\n\n\n&quot;A fundamental alignment is a valid alignment less than or equal to _Alignof (max_align_t). Fundamental alignments shall be supported by the implementation for objects of all storage durations. The alignment requirements of the following types shall be fundamental alignments:\n  all atomic, qualified, or unqualified basic types;\n  all atomic, qualified, or unqualified enumerated types;\n  all atomic, qualified, or unqualified pointer types;\n  all array types whose element type has a fundamental alignment requirement;57)\n  all types specified in Clause 7 as complete object types;\n  all structure or union types all of whose elements have types with fundamental alignment requirements and none of whose elements have an alignment specifier specifying an alignment that is not a fundamental alignment.\n\nAs specified in 6.2.1, the later declaration might hide the prior declaration.&quot;\n\nSource: C18, ยง6.2.8/2\n\nHowever, if you allocate memory for an implementation-defined object of extended alignment requirement, the cast would be needed.\n\nAn extended alignment is represented by an alignment greater than _Alignof (max_align_t). It is implementation-defined whether any extended alignments are supported and the storage durations for which they are supported. A type having an extended alignment requirement is an over-aligned type.58)\nSource. C18, ยง6.2.8/3\n\nEverything else is a matter of the specific use case and one&apos;s own opinion.\nPlease be careful how you educate yourself.\nI recommend you to read all of the answers made so far carefully first (as well as their comments which may point at a failure) and then build your own opinion if you or if you not cast the result of malloc() at a specific case.\nPlease note:\nThere is no right and wrong answer to that question. It is a matter of style and you yourself decide which way you choose (if you aren&apos;t forced to by education or job of course). Please be aware of that and don&apos;t let trick you.\n\nLast note: I voted to lately close this question as opinion-based, which is indeed needed since years. If you got the close/reopen privilege I would like to invite you to do so, too.\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0},{"text":"No, you don&apos;t cast the result of malloc().\n\nIn general, you don&apos;t cast to or from void *.\n\nA typical reason given for not doing so is that failure to #include &lt;stdlib.h&gt; could go unnoticed. This isn&apos;t an issue anymore for a long time now as C99 made implicit function declarations illegal, so if your compiler conforms to at least C99, you will get a diagnostic message.\n\nBut there&apos;s a much stronger reason not to introduce unnecessary pointer casts:\n\nIn C, a pointer cast is almost always an error. This is because of the following rule (ยง6.5 p7 in N1570, the latest draft for C11):\n\n\n  An object shall have its stored value accessed only by an lvalue expression that has one of\n  the following types:\n   a type compatible with the effective type of the object,\n   a qualified version of a type compatible with the effective type of the object,\n   a type that is the signed or unsigned type corresponding to the effective type of the\n  object,\n   a type that is the signed or unsigned type corresponding to a qualified version of the\n  effective type of the object,\n   an aggregate or union type that includes one of the aforementioned types among its\n  members (including, recursively, a member of a subaggregate or contained union), or\n   a character type.\n\n\nThis is also known as the strict aliasing rule. So the following code is undefined behavior:\n\nlong x = 5;\ndouble *p = (double *)&amp;x;\ndouble y = *p;\n\n\nAnd, sometimes surprisingly, the following is as well:\n\nstruct foo { int x; };\nstruct bar { int x; int y; };\nstruct bar b = { 1, 2};\nstruct foo *p = (struct foo *)&amp;b;\nint z = p-&gt;x;\n\n\nSometimes, you do need to cast pointers, but given the strict aliasing rule, you have to be very careful with it. So, any occurrence of a pointer cast in your code is a place you have to double-check for its validity. Therefore, you never write an unnecessary pointer cast.\n\ntl;dr\n\nIn a nutshell: Because in C, any occurrence of a pointer cast should raise a red flag for code requiring special attention, you should never write unnecessary pointer casts.\n\n\n\nSide notes:\n\n\nThere are cases where you actually need a cast to void *, e.g. if you want to print a pointer:\n\nint x = 5;\nprintf(&quot;%p\\n&quot;, (void *)&amp;x);\n\n\nThe cast is necessary here, because printf() is a variadic function, so implicit conversions don&apos;t work.\nIn C++, the situation is different. Casting pointer types is somewhat common (and correct) when dealing with objects of derived classes. Therefore, it makes sense that in C++, the conversion to and from void * is not implicit. C++ has a whole set of different flavors of casting.\n\n    ","url":"/questions/[slug]#solution19","@type":"Answer","upvoteCount":0},{"text":"I put in the cast simply to show disapproval of the ugly hole in the type system, which allows code such as the following snippet to compile without diagnostics, even though no casts are used to bring about the bad conversion:\n\ndouble d;\nvoid *p = &amp;d;\nint *q = p;\n\n\nI wish that didn&apos;t exist (and it doesn&apos;t in C++) and so I cast. It represents my taste, and my programming politics. I&apos;m not only casting a pointer, but effectively, casting a ballot, and casting out demons of stupidity. If I can&apos;t actually cast out stupidity, then at least let me express the wish to do so with a gesture of protest.\n\nIn fact, a good practice is to wrap malloc (and friends) with functions that return unsigned char *, and basically never to use void * in your code.  If you need a generic pointer-to-any-object, use a char * or unsigned char *, and have casts in both directions. The one relaxation that can be indulged, perhaps, is using functions like memset and memcpy without casts.\n\nOn the topic of casting and C++ compatibility, if you write your code so that it compiles as both C and C++ (in which case you have to cast the return value of malloc when assigning it to something other than void *), you can do a very helpful thing for yourself: you can use macros for casting which translate to C++ style casts when compiling as C++, but reduce to a C cast when compiling as C:\n\n/* In a header somewhere */\n#ifdef __cplusplus\n#define strip_qual(TYPE, EXPR) (const_cast&lt;TYPE&gt;(EXPR))\n#define convert(TYPE, EXPR) (static_cast&lt;TYPE&gt;(EXPR))\n#define coerce(TYPE, EXPR) (reinterpret_cast&lt;TYPE&gt;(EXPR))\n#else\n#define strip_qual(TYPE, EXPR) ((TYPE) (EXPR))\n#define convert(TYPE, EXPR) ((TYPE) (EXPR))\n#define coerce(TYPE, EXPR) ((TYPE) (EXPR))\n#endif\n\n\nIf you adhere to these macros, then a simple grep search of your code base for these identifiers will show you where all your casts are, so you can review whether any of them are incorrect.\n\nThen, going forward, if you regularly compile the code with C++, it will enforce the use of an appropriate cast. For instance, if you use strip_qual just to remove a const or volatile, but the program changes in such a way that a type conversion is now involved, you will get a diagnostic, and you will have to use a combination of casts to get the desired conversion.\n\nTo help you adhere to these macros, the the GNU C++ (not C!) compiler has a beautiful feature: an optional diagnostic which is produced for all occurrences of C style casts.\n\n     -Wold-style-cast (C++ and Objective-C++ only)\n         Warn if an old-style (C-style) cast to a non-void type is used\n         within a C++ program.  The new-style casts (dynamic_cast,\n         static_cast, reinterpret_cast, and const_cast) are less vulnerable\n         to unintended effects and much easier to search for.\n\n\nIf your C code compiles as C++, you can use this -Wold-style-cast option to find out all occurrences of the (type) casting syntax that may creep into the code, and follow up on these diagnostics by replacing it with an appropriate choice from among the above macros (or a combination, if necessary).\n\nThis treatment of conversions is the single largest standalone technical justification for working in a &quot;Clean C&quot;: the combined C and C++ dialect, which in turn technically justifies casting the return value of malloc.\n    ","url":"/questions/[slug]#solution20","@type":"Answer","upvoteCount":0},{"text":"The best thing to do when programming in C whenever it is possible:\n\n\nMake your program compile through a C compiler with all warnings turned on -Wall and fix all errors and warnings\nMake sure there are no variables declared as auto\nThen compile it using a C++ compiler with -Wall and -std=c++11. Fix all errors and warnings.\nNow compile using the C compiler again. Your program should now compile without any warning and contain fewer bugs.\n\n\nThis procedure lets you take advantage of C++ strict type checking, thus reducing the number of bugs. In particular, this procedure forces you to include stdlib.hor you will get\n\n\n  malloc was not declared within this scope\n\n\nand also forces you to cast the result of malloc or you will get\n\n\n  invalid conversion from void* to T*\n\n\nor what ever your target type is.\n\nThe only benefits from writing in C instead of C++ I can find are\n\n\nC has a well specified ABI\nC++ may generate more code [exceptions, RTTI, templates, runtime polymorphism]\n\n\nNotice that the second cons should in the ideal case disappear when using the subset common to C together with the static polymorphic feature.\n\nFor those that finds C++ strict rules inconvenient, we can use the C++11 feature with inferred  type\n\nauto memblock=static_cast&lt;T*&gt;(malloc(n*sizeof(T))); //Mult may overflow...\n\n    ","url":"/questions/[slug]#solution21","@type":"Answer","upvoteCount":0},{"text":"I prefer to do the cast, but not manually. My favorite is using g_new and g_new0 macros from glib. If glib is not used, I would add similar macros. Those macros reduce code duplication without compromising type safety. If you get the type wrong, you would get an implicit cast between non-void pointers, which would cause a warning (error in C++). If you forget to include the header that defines g_new and g_new0, you would get an error. g_new and g_new0 both take the same arguments, unlike malloc that takes fewer arguments than calloc. Just add 0 to get zero-initialized memory. The code can be compiled with a C++ compiler without changes.\n    ","url":"/questions/[slug]#solution22","@type":"Answer","upvoteCount":0},{"text":"Casting is only for C++ not C.In case you are using a C++ compiler you better change it to C compiler.\n    ","url":"/questions/[slug]#solution23","@type":"Answer","upvoteCount":0},{"text":"The casting of malloc is unnecessary in C but mandatory in C++.\n\nCasting is unnecessary in C because of:\n\n\nvoid * is automatically and safely promoted to any other pointer type in the case of C.\nIt can hide an error if you forgot to include &lt;stdlib.h&gt;. This can cause crashes.\nIf pointers and integers are differently sized, then you&apos;re hiding a warning by casting and might lose bits of your returned address.\nIf the type of the pointer is changed at its declaration, one may also need to change all lines where malloc is called and cast.\n\n\nOn the other hand, casting may increase the portability of your program. i.e, it allows a C program or function to compile as C++.\n    ","url":"/questions/[slug]#solution24","@type":"Answer","upvoteCount":0},{"text":"The concept behind void pointer is that it can be casted to any data type that is why malloc returns void. Also you must be aware of automatic typecasting. So it is not mandatory to cast the pointer though you must do it. It helps in keeping the code clean and helps debugging\n    ","url":"/questions/[slug]#solution25","@type":"Answer","upvoteCount":0},{"text":"A void pointer is a generic pointer and C supports implicit conversion from a void pointer type to other types, so there is no need of explicitly typecasting it.\n\nHowever, if you want the same code work perfectly compatible on a C++ platform, which does not support implicit conversion, you need to do the typecasting, so it all depends on usability.\n    ","url":"/questions/[slug]#solution26","@type":"Answer","upvoteCount":0},{"text":"\nAs other stated, it is not needed for C, but for C++.\nIncluding the cast may allow a C program or function to compile as C++.\nIn C it is unnecessary, as void * is automatically and safely promoted to any other pointer type.\nBut if you cast then, it can hide an error if you forgot to include\nstdlib.h. This can cause crashes (or, worse, not cause a crash\nuntil way later in some totally different part of the code).\n\nBecause stdlib.h contains the prototype for malloc is found. In the\nabsence of a prototype for malloc, the standard requires that the C\ncompiler assumes malloc returns an int. If there is no cast, a\nwarning is issued when this integer is assigned to the pointer;\nhowever, with the cast, this warning is not produced, hiding a bug.\n\n    ","url":"/questions/[slug]#solution27","@type":"Answer","upvoteCount":0},{"text":"The main issue with malloc is to get the right size.\nThe memory returned form malloc() is untyped, and it will not magically gain an effective type due to a simple cast.\nI guess that both approaches are fine and the choice should depend on programmer intention.\n\nIf allocating memory for a type, then use a cast.\n\nptr = (T*)malloc(sizeof(T));\n\nIf allocating memory for a given pointer, then don&apos;t use a cast.\n\nptr = malloc(sizeof *ptr);\nAd 1\nThe first method assures the correct size by allocating memory for a given type, and then casting it to assure that it is assigned to the right pointer. If incorrect type of ptr is used then the compiler will issue a warning/error. If the type of ptr is changed, then the compiler will point the places where the code needs refactoring.\nMoreover, the first method can be combined into a macro similar to new operator in C++.\n#define NEW(T) ((T*)malloc(sizeof(T)))\n...\nptr = NEW(T);\n\nMoreover this method works if ptr is void*.\nAd 2\nThe second methods does not care about the types, it assures the correct size by taking it from the pointer&apos;s type. The main advantage of this method is the automatic adjustment of storage size whenever the type of ptr is changed.\nIt can save some time (or errors) when refactoring.\nThe disadvantage is that the method does not work if ptr is void* but it may be perceived as a good thing. And that it does not work with C++ so it should not be used in inlined functions in headers that are going to be used by C++ programs.\nPersonally, I prefer the second option.\n    ","url":"/questions/[slug]#solution28","@type":"Answer","upvoteCount":0},{"text":"For me, the take home and conclusion here is that casting malloc in C is totally NOT necessary but if you however cast, it wont affect malloc as malloc will still allocate to you your requested blessed memory space.\nAnother take home is the reason or one of the reasons people do casting and this is to enable them compile same program either in C or C++.\n\nThere may be other reasons but other reasons, almost certainly, would land you in serious trouble sooner or later.\n    ","url":"/questions/[slug]#solution29","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-12e9794e898cd5f3.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-928c5d1eb8fb0bba.js" defer=""></script><script src="/_next/static/BnkbnjkWYxefPXjTJLVVv/_buildManifest.js" defer=""></script><script src="/_next/static/BnkbnjkWYxefPXjTJLVVv/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/do-i-cast-the-result-of-malloc-1657384271583#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/do-i-cast-the-result-of-malloc-1657384271583"><h1>Do I cast the result of malloc?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/casting">casting</a></div></div><div class="question-content mt-5">
                
<p>In <a href="http://stackoverflow.com/questions/571945/getting-a-stack-overflow-exception-when-declaring-a-large-array">this question</a>, someone suggested in a <a href="http://stackoverflow.com/questions/571945/getting-a-stack-overflow-exception-when-declaring-a-large-array#comment388297_571961">comment</a> that I should <em><strong>not</strong></em> cast the result of <code>malloc</code>. i.e., I should do this:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> *sieve = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(*sieve) * length);
</code></pre>
<p>rather than:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> *sieve = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(*sieve) * length);
</code></pre>
<p>Why would this be the case?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li><li class="pagination-solution-item"><span data-id="#solution19" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">19</span></li><li class="pagination-solution-item"><span data-id="#solution20" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">20</span></li><li class="pagination-solution-item"><span data-id="#solution21" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">21</span></li><li class="pagination-solution-item"><span data-id="#solution22" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">22</span></li><li class="pagination-solution-item"><span data-id="#solution23" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">23</span></li><li class="pagination-solution-item"><span data-id="#solution24" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">24</span></li><li class="pagination-solution-item"><span data-id="#solution25" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">25</span></li><li class="pagination-solution-item"><span data-id="#solution26" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">26</span></li><li class="pagination-solution-item"><span data-id="#solution27" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">27</span></li><li class="pagination-solution-item"><span data-id="#solution28" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">28</span></li><li class="pagination-solution-item"><span data-id="#solution29" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">29</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/casting">casting</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h3>TL;DR</h3>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> *sieve = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * length);
</code></pre>
<p>has two problems. The cast and that you're using the type instead of variable as argument for sizeof. Instead, do like this:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> *sieve = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span> *sieve * length);
</code></pre>
<h3>Long version</h3>
<p><strong>No</strong>; you <em>don't</em> cast the result, since:</p>
<ul>
<li>It is unnecessary, as <code>void *</code> is automatically and safely promoted to any other pointer type in this case.</li>
<li>It adds clutter to the code, casts are not very easy to read (especially if the pointer type is long).</li>
<li>It makes you repeat yourself, which is generally bad.</li>
<li>It can hide an error if you forgot to include <code>&lt;stdlib.h&gt;</code>. This can cause crashes (or, worse, <em>not</em> cause a crash until way later in some totally different part of the code). Consider what happens if pointers and integers are differently sized; then you're hiding a warning by casting and might lose bits of your returned address. Note: as of C99 implicit functions are gone from C, and this point is no longer relevant since there's no automatic assumption that undeclared functions return <code>int</code>.</li>
</ul>
<p>As a clarification, note that I said "you don't cast", not "you don't <em>need</em> to cast". In my opinion, it's a failure to include the cast, even if you got it right. There are simply no benefits to doing it, but a bunch of potential risks, and including the cast indicates that you don't know about the risks.</p>
<p>Also note, as commentators point out, that the above talks about straight C, not C++. I very firmly believe in C and C++ as separate languages.</p>
<p>To add further, your code needlessly repeats the type information (<code>int</code>) which can cause errors. It's better to de-reference the pointer being used to store the return value, to "lock" the two together:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> *sieve = <span class="hljs-built_in">malloc</span>(length * <span class="hljs-keyword">sizeof</span> *sieve);
</code></pre>
<p>This also moves the <code>length</code> to the front for increased visibility, and drops the redundant parentheses with <code>sizeof</code>; they <em>are only needed</em> when the argument is a type name. Many people seem to not know (or ignore) this, which makes their code more verbose. Remember: <code>sizeof</code> is not a function! :)</p>
<hr>
<p>While moving <code>length</code> to the front <em>may</em> increase visibility in some rare cases, one should also pay attention that in the general case, it should be better to write the expression as:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> *sieve = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span> *sieve * length);
</code></pre>
<p>Since keeping the <code>sizeof</code> first, in this case, ensures multiplication is done with at least <code>size_t</code> math.</p>
<p>Compare: <code>malloc(sizeof *sieve * length * width)</code> vs. <code>malloc(length * width * sizeof *sieve)</code> the second may overflow the <code>length * width</code> when <code>width</code> and <code>length</code> are smaller types than <code>size_t</code>.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/casting">casting</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In C, you don't need to cast the return value of <code>malloc</code>. The pointer to void returned by <code>malloc</code> is automagically converted to the correct type. However, if you want your code to compile with a C++ compiler, a cast is needed. A preferred alternative among the community is to use the following:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> *sieve = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span> *sieve * length);
</code></pre>

<p>which additionally frees you from having to worry about changing the right-hand side of the expression if ever you change the type of <code>sieve</code>.</p>

<p>Casts are bad, as people have pointed out. Especially pointer casts. </p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/casting">casting</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You <strong>do</strong> cast, because:</p>

<ul>
<li>It makes your code <strong>more portable</strong> between C and C++, and as SO experience shows, a great many programmers claim they are writing in C when they are really writing in C++ (or C plus local compiler extensions).</li>
<li>Failing to do so <strong>can hide an error</strong>: note all the SO examples of confusing when to write <code>type *</code> versus <code>type **</code>.</li>
<li>The idea that it keeps you from noticing you failed to <code>#include</code> an appropriate header file misses <strong>the forest for the trees</strong>. It's the same as saying "don't worry about the fact you failed to ask the compiler to complain about not seeing prototypes -- that pesky stdlib.h is the REAL important thing to remember!"</li>
<li>It forces an <strong>extra cognitive cross-check</strong>. It puts the (alleged) desired type right next to the arithmetic you're doing for the raw size of that variable. I bet you could do an SO study that shows that <code>malloc()</code> bugs are caught much faster when there's a cast. As with assertions, annotations that reveal intent decrease bugs. </li>
<li>Repeating yourself in a way that the machine can check is often a <strong>great</strong> idea. In fact, that's what an assertion is, and this use of cast is an assertion. Assertions are still the most general technique we have for getting code correct, since Turing came up with the idea so many years ago.</li>
</ul>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/casting">casting</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As others stated, it is not needed for C, but necessary for C++. If you think you are going to compile your C code with a C++ compiler, for whatever reasons, you can use a macro instead, like:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span>
<span class="hljs-meta"># <span class="hljs-keyword">define</span> NEW(type, count) ((type *)calloc(count, sizeof(type)))</span>
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
<span class="hljs-meta"># <span class="hljs-keyword">define</span> NEW(type, count) (calloc(count, sizeof(type)))</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>

<p>That way you can still write it in a very compact way:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> *sieve = NEW(<span class="hljs-type">int</span>, <span class="hljs-number">1</span>);
</code></pre>

<p>and it will compile for C and C++.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/casting">casting</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>From the <a href="https://en.wikipedia.org/wiki/C_dynamic_memory_allocation#Advantages_to_casting" rel="noreferrer">Wikipedia</a>:</p>

<blockquote>
  <p><strong>Advantages to casting</strong></p>
  
  <ul>
  <li><p>Including the cast may allow a C program or function to compile as C++.</p></li>
  <li><p>The cast allows for pre-1989 versions of malloc that originally returned a char *.</p></li>
  <li><p>Casting can help the developer identify inconsistencies in type sizing should the destination pointer type change, particularly if the pointer is declared far from the malloc() call (although modern compilers and static analyzers can warn on such behaviour without requiring the cast).</p></li>
  </ul>
  
  <p><strong>Disadvantages to casting</strong></p>
  
  <ul>
  <li><p>Under the ANSI C standard, the cast is redundant.</p></li>
  <li><p>Adding the cast may mask failure to include the header <em>stdlib.h</em>, in
  which the prototype for malloc is found. In the absence of a
  prototype for malloc, the standard requires that the C compiler
  assume malloc returns an int. If there is no cast, a warning is
  issued when this integer is assigned to the pointer; however, with
  the cast, this warning is not produced, hiding a bug. On certain
  architectures and data models (such as LP64 on 64-bit systems, where
  long and pointers are 64-bit and int is 32-bit), this error can
  actually result in undefined behaviour, as the implicitly declared
  malloc returns a 32-bit value whereas the actually defined function
  returns a 64-bit value. Depending on calling conventions and memory
  layout, this may result in stack smashing. This issue is less likely
  to go unnoticed in modern compilers, as they uniformly produce
  warnings that an undeclared function has been used, so a warning will
  still appear. For example, GCC's default behaviour is to show a
  warning that reads "incompatible implicit declaration of built-in
  function" regardless of whether the cast is present or not.</p></li>
  <li><p>If the type of the pointer is changed at its declaration, one may
  also, need to change all lines where malloc is called and cast.</p></li>
  </ul>
</blockquote>

<p>Although <strong>malloc without casting is preferred method and most experienced programmers choose it</strong>, you should use whichever you like having aware of the issues.</p>

<p>i.e: If you need to compile C program as C++ (Although it is a separate language) you must cast the result of use <code>malloc</code>. </p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/casting">casting</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In C you can implicitly convert a <code>void</code> pointer to any other kind of pointer, so a cast is not necessary. Using one may suggest to the casual observer that there is some reason why one is needed, which may be misleading.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/casting">casting</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You don't cast the result of <code>malloc</code>, because doing so adds pointless clutter to your code.</p>
<p>The most common reason why people cast the result of <code>malloc</code> is because they are unsure about how the C language works. That's a warning sign: if you don't know how a particular language mechanism works, then <em>don't</em> take a guess. Look it up or ask on Stack Overflow.</p>
<p>Some comments:</p>
<ul>
<li><p>A void pointer can be converted to/from any other pointer type without an explicit cast (C11 6.3.2.3 and 6.5.16.1).</p>
</li>
<li><p>C++ will however not allow an implicit cast between <code>void*</code> and another pointer type. So in C++, the cast would have been correct. But if you program in C++, you should use <code>new</code> and not <code>malloc()</code>. And you should never compile C code using a C++ compiler.</p>
<p>If you need to support both C and C++ with the same source code, use compiler switches to mark the differences. Do not attempt to sate both language standards with the same code, because they are not compatible.</p>
</li>
<li><p>If a C compiler cannot find a function because you forgot to include the header, you will get a compiler/linker error about that. So if you forgot to include <code>&lt;stdlib.h&gt;</code> that's no biggie, you won't be able to build your program.</p>
</li>
<li><p>On ancient compilers that follow a version of the standard which is more than 25 years old, forgetting to include <code>&lt;stdlib.h&gt;</code> would result in dangerous behavior. Because in that ancient standard, functions without a visible prototype implicitly converted the return type to <code>int</code>. Casting the result from <code>malloc</code> explicitly would then hide away this bug.</p>
<p>But that is really a non-issue. You aren't using a 25 years old computer, so why would you use a 25 years old compiler?</p>
</li>
</ul>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/casting">casting</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In C you get an implicit conversion from <code>void *</code> to any other (data) pointer.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/casting">casting</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Casting the value returned by <code>malloc()</code> is not necessary now, but I'd like to add one point that seems no one has pointed out:</p>

<p>In the ancient days, that is, before <strong>ANSI C</strong> provides the <code>void *</code> as the generic type of pointers, <code>char *</code> is the type for such usage. In that case, the cast can shut down the compiler warnings.</p>

<p>Reference: <a href="http://c-faq.com/malloc/cast.html" rel="noreferrer">C FAQ</a></p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/casting">casting</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Just adding my experience, studying computer engineering I see that the two or three professors that I have seen writing in C always cast malloc, however the one I asked (with an immense CV and understanding of C) told me that it is absolutely unnecessary but only used to be absolutely specific, and to get the students into the mentality of being absolutely specific. Essentially casting will not change anything in how it works, it does exactly what it says, allocates memory, and casting does not effect it, you get the same memory, and even if you cast it to something else by mistake (and somehow evade compiler errors) C will access it the same way.</p>

<p><strong>Edit:</strong> Casting has a certain point. When you use array notation, the code generated has to know how many memory places it has to advance to reach the beginning of the next element, this is achieved through casting. This way you know that for a double you go 8 bytes ahead while for an int you go 4, and so on. Thus it has no effect if you use pointer notation, in array notation it becomes necessary.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/casting">casting</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It is not mandatory to cast the results of <code>malloc</code>, since it returns <code>void*</code> , and a <code>void*</code> can be pointed to any datatype. </p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/casting">casting</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This is what <a href="http://www.gnu.org/software/libc/manual/html_node/Basic-Allocation.html" rel="noreferrer">The GNU C Library Reference</a> manual says: </p>

<blockquote>
  <p>You can store the result of <code>malloc</code> into any pointer variable without a
  cast, because ISO C automatically converts the type <code>void *</code> to another
  type of pointer when necessary. But the cast is necessary in contexts
  other than assignment operators or if you might want your code to run
  in traditional C.</p>
</blockquote>

<p>And indeed the <a href="http://www.compsci.hunter.cuny.edu/~sweiss/resources/c11standard.pdf" rel="noreferrer">ISO C11 standard</a> (p347) says so: </p>

<blockquote>
  <p>The pointer returned if the allocation succeeds is suitably aligned so
  that it may be assigned to a pointer to any type of object with a
  fundamental alignment requirement and then used to access such an
  object or an array of such objects in the space allocated (until the
  space is explicitly deallocated)</p>
</blockquote>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/casting">casting</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A void pointer is a generic object pointer and C supports implicit conversion from a void pointer type to other types, so there is no need of explicitly typecasting it.</p>

<p>However, if you want the same code work perfectly compatible on a C++ platform, which does not support implicit conversion, you need to do the typecasting, so it all depends on usability.</p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/casting">casting</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The returned type is void*, which can be cast to the desired type of data pointer in order to be dereferenceable.</p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/casting">casting</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It depends on the programming language and compiler. If you use <code>malloc</code> in C, there is no need to type cast it, as it will automatically type cast. However, if you are using C++, then you should type cast because <code>malloc</code> will return a <code>void*</code> type.</p>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/casting">casting</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In the C language, a void pointer can be assigned to any pointer, which is why you should not use a type cast. If you want "type safe" allocation, I can recommend the following macro functions, which I always use in my C projects:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> NEW_ARRAY(ptr, n) (ptr) = malloc((n) * sizeof *(ptr))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> NEW(ptr) NEW_ARRAY((ptr), 1)</span>
</code></pre>

<p>With these in place you can simply say</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">NEW_ARRAY(sieve, length);
</code></pre>

<p>For non-dynamic arrays, the third must-have function macro is</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEN(arr) (sizeof (arr) / sizeof (arr)[0])</span>
</code></pre>

<p>which makes array loops safer and more convenient:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> i, a[<span class="hljs-number">100</span>];

<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; LEN(a); i++) {
   ...
}
</code></pre>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/casting">casting</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>People used to GCC and Clang are spoiled.  It's not all that good out there.</p>

<p>I have been pretty horrified over the years by the staggeringly aged compilers I've been required to use.  Often companies and managers adopt an ultra-conservative approach to changing compilers and will not even <em>test</em> if a new compiler ( with better standards compliance and code optimization ) will work in their system.  The practical reality for working developers is that when you're coding you need to cover your bases and, unfortunately, casting mallocs is a good habit if you cannot control what compiler may be applied to your code.</p>

<p>I would also suggest that many organizations apply a coding standard of their own and that <em>that</em> should be the method people follow if it is defined.  In the absence of explicit guidance I tend to go for most likely to compile everywhere, rather than slavish adherence to a standard.</p>

<p>The argument that it's not necessary under current standards is quite valid.  But that argument omits the practicalities of the real world.  We do not code in a world ruled exclusively by the standard of the day, but by the practicalities of what I like to call "local management's reality field".  And that's bent and twisted more than space time ever was. :-)</p>

<p>YMMV.</p>

<p>I tend to think of casting malloc as a defensive operation.  Not pretty, not perfect, but generally safe.  ( Honestly, if you've not included stdlib.h then you've <em>way</em> more problems than casting malloc ! ).</p>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 18</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/casting">casting</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1><strong>This question is subject of opinion-based abuse.</strong></h1>
<p>Sometimes I notice comments like that:</p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc">Don't cast the result of malloc</a></p>
</blockquote>
<p>or</p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc">Why you don't cast the result of malloc</a></p>
</blockquote>
<p>on questions where OP uses casting. The comments itself contain a hyperlink to this question.</p>
<p>That is in <em>any</em> possible manner inappropriate and incorrect as well. There is no right and no wrong when it is truly a matter of one's own coding-style.</p>
<hr>
<h3>Why is this happening?</h3>
<p>It's based upon two reasons:</p>
<ol>
<li><p>This question is indeed opinion-based. Technically, the question should have been closed as opinion-based years ago. A "<em>Do I</em>" or "<em>Don't I</em>" or equivalent "<em>Should I</em>" or "<em>Shouldn't I</em>" question, you just can't answer focused without an attitude of one's own opinion. One of the reason to close a question is because it "might lead to opinion-based answers" as it is well shown here.</p>
</li>
<li><p>Many answers (including the most apparent and accepted <a href="https://stackoverflow.com/a/605858/12139179">answer</a> of <a href="https://stackoverflow.com/users/28169/unwind">@unwind</a>) are either completely or almost entirely opinion-based (f.e. a mysterious "clutter" that would be added to your code if you do casting or repeating yourself would be bad) and show a clear and focused tendency to omit the cast. They argue about the redundancy of the cast on one side but also and even worse argue to solve a bug caused by a bug/failure of programming itself - to not <code>#include &lt;stdlib.h&gt;</code> if one want to use <code>malloc()</code>.</p>
</li>
</ol>
<hr>
<p>I want to bring a true view of some points discussed, with less of my personal opinion. A few points need to be noted especially:</p>
<ol>
<li><p>Such a very susceptible question to fall into one's own opinion needs an answer with neutral pros and cons. Not only cons or pros.</p>
<p>A good overview of pros and cons is listed in this answer:</p>
<p><a href="https://stackoverflow.com/a/33047365/12139179">https://stackoverflow.com/a/33047365/12139179</a></p>
<p>(I personally consider this because of that reason the best answer, so far.)</p>
</li>
</ol>
<hr>
<ol start="2">
<li><p>One reason which is encountered at most to reason the omission of the cast is that the cast might hide a bug.</p>
<p>If someone uses an implicit declared <code>malloc()</code> that returns <code>int</code> (implicit functions are gone from the standard since C99) and <code>sizeof(int) != sizeof(int*)</code>, as shown in this question</p>
<p><a href="http://stackoverflow.com/q/7545365/168175">Why does this code segfault on 64-bit architecture but work fine on 32-bit?</a></p>
<p>the cast would hide a bug.</p>
<p>While this is true, it only shows half of the story as the omission of the cast would only be a forward-bringing solution to an even bigger bug - not including <code>stdlib.h</code> when using <code>malloc()</code>.</p>
<p>This will never be a serious issue, If you,</p>
<ol>
<li><p>Use a compiler compliant to C99 or above (which is recommended and should be mandatory), and</p>
</li>
<li><p>Aren't so absent to forgot to include <code>stdlib.h</code>, when you want to use <code>malloc()</code> in your code, which is a huge bug itself.</p>
</li>
</ol>
</li>
</ol>
<hr>
<ol start="3">
<li><p>Some people argue about C++ compliance of C code, as the cast is obliged in C++.</p>
<p>First of all to say in general: Compiling C code with a C++ compiler is not a good practice.</p>
<p>C and C++ are in fact two completely different languages with different semantics.</p>
<p>But If you really want/need to make C code compliant to C++ and vice versa use compiler switches instead of any cast.</p>
<p>Since the cast is with tendency declared as redundant or even harmful, I want to take a focus on these questions, which give good reasons why casting can be useful or even necessary:</p>
<ul>
<li><p><a href="https://stackoverflow.com/a/34094068/12139179">https://stackoverflow.com/a/34094068/12139179</a></p>
</li>
<li><p><a href="https://stackoverflow.com/a/36297486/12139179">https://stackoverflow.com/a/36297486/12139179</a></p>
</li>
<li><p><a href="https://stackoverflow.com/a/33044300/12139179">https://stackoverflow.com/a/33044300/12139179</a></p>
</li>
</ul>
</li>
</ol>
<hr>
<ol start="4">
<li>The cast can be non-beneficial when your code, respectively the type of the assigned pointer (and with that the type of the cast), changes, although this is in most cases unlikely. Then you would need to maintain/change all casts too and if you have a few thousand calls to memory-management functions in your code, this can really summarizing up and decrease the maintenance efficiency.</li>
</ol>
<hr>
<h3>Summary:</h3>
<p>Fact is, that the cast is redundant per the C standard (already since ANSI-C (C89/C90)) if the assigned pointer point to an object of fundamental alignment requirement (which includes the most of all objects).</p>
<p>You don't need to do the cast as the pointer is automatically aligned in this case:</p>
<blockquote>
<p>"The order and contiguity of storage allocated by successive calls to the aligned_alloc, calloc, malloc, and realloc functions is unspecified. <strong>The pointer returned if the allocation succeeds is suitably aligned so that it may be assigned to a pointer to any type of object with a fundamental alignment requirement</strong> and then used to access such an object or an array of such objects in the space allocated (until the space is explicitly deallocated)."</p>
<p>Source: C18, ยง7.22.3/1</p>
</blockquote>
<hr>
<blockquote>
<p>"A <em>fundamental alignment</em> is a valid alignment less than or equal to <code>_Alignof (max_align_t)</code>. Fundamental alignments shall be supported by the implementation for objects of all storage durations. The alignment requirements of the following types shall be fundamental alignments:</p>
<p>  all atomic, qualified, or unqualified basic types;</p>
<p>  all atomic, qualified, or unqualified enumerated types;</p>
<p>  all atomic, qualified, or unqualified pointer types;</p>
<p>  all array types whose element type has a fundamental alignment requirement;57)</p>
<p>  all types specified in Clause 7 as complete object types;</p>
<p>  all structure or union types all of whose elements have types with fundamental alignment requirements and none of whose elements have an alignment specifier specifying an alignment that is not a fundamental alignment.</p>
<ol start="57">
<li>As specified in 6.2.1, the later declaration might hide the prior declaration."</li>
</ol>
<p>Source: C18, ยง6.2.8/2</p>
</blockquote>
<p>However, if you allocate memory for an implementation-defined object of extended alignment requirement, the cast would be needed.</p>
<blockquote>
<p>An <em>extended alignment</em> is represented by an alignment greater than <code>_Alignof (max_align_t)</code>. It is implementation-defined whether any extended alignments are supported and the storage durations for which they are supported. A type having an extended alignment requirement is an over-aligned type.58)</p>
<p>Source. C18, ยง6.2.8/3</p>
</blockquote>
<p>Everything else is a matter of the specific use case and one's own opinion.</p>
<p>Please be careful how you educate yourself.</p>
<p>I recommend you to read <em>all</em> of the answers made so far carefully first (as well as their comments which may point at a failure) and then build your own opinion if you or if you not cast the result of <code>malloc()</code> at a specific case.</p>
<p>Please note:</p>
<p><strong>There is no right and wrong answer to that question. It is a matter of style and you yourself decide which way you choose (if you aren't forced to by education or job of course). Please be aware of that and don't let trick you</strong>.</p>
<hr>
<p>Last note: I voted to lately close this question as opinion-based, which is indeed needed since years. If you got the close/reopen privilege I would like to invite you to do so, too.</p>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 19</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/casting">casting</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2>No, you don't cast the result of <code>malloc()</code>.</h2>

<p>In general, you <strong>don't cast to or from <code>void *</code></strong>.</p>

<p>A typical reason given for not doing so is that failure to <code>#include &lt;stdlib.h&gt;</code> could go unnoticed. This isn't an issue anymore for a long time now as C99 made <em>implicit function declarations</em> illegal, so if your compiler conforms to at least C99, you will get a diagnostic message.</p>

<p>But there's a <strong>much stronger reason</strong> not to introduce unnecessary pointer casts:</p>

<p>In C, a <strong>pointer cast is almost always an error</strong>. This is because of the following rule (<strong>ยง6.5 p7</strong> in N1570, the latest draft for C11):</p>

<blockquote>
  <p>An object shall have its stored value accessed only by an lvalue expression that has one of
  the following types:<br>
   a type compatible with the effective type of the object,<br>
   a qualified version of a type compatible with the effective type of the object,<br>
   a type that is the signed or unsigned type corresponding to the effective type of the
  object,<br>
   a type that is the signed or unsigned type corresponding to a qualified version of the
  effective type of the object,<br>
   an aggregate or union type that includes one of the aforementioned types among its
  members (including, recursively, a member of a subaggregate or contained union), or<br>
   a character type.</p>
</blockquote>

<p>This is also known as the <em>strict aliasing rule</em>. So the following code is <em>undefined behavior</em>:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">long</span> x = <span class="hljs-number">5</span>;
<span class="hljs-type">double</span> *p = (<span class="hljs-type">double</span> *)&amp;x;
<span class="hljs-type">double</span> y = *p;
</code></pre>

<p>And, sometimes surprisingly, the following is as well:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">foo</span> {</span> <span class="hljs-type">int</span> x; };
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bar</span> {</span> <span class="hljs-type">int</span> x; <span class="hljs-type">int</span> y; };
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bar</span> <span class="hljs-title">b</span> =</span> { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>};
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">foo</span> *<span class="hljs-title">p</span> =</span> (<span class="hljs-keyword">struct</span> foo *)&amp;b;
<span class="hljs-type">int</span> z = p-&gt;x;
</code></pre>

<p>Sometimes, you <strong>do</strong> need to cast pointers, but given the <em>strict aliasing rule</em>, you have to be very careful with it. So, any occurrence of a pointer cast in your code is a place you <strong>have to double-check for its validity</strong>. Therefore, you never write an unnecessary pointer cast.</p>

<h3>tl;dr</h3>

<p>In a nutshell: Because in C, <strong>any</strong> occurrence of a <em>pointer cast</em> should raise a red flag for code requiring special attention, you should never write <em>unnecessary</em> pointer casts.</p>

<hr>

<p>Side notes:</p>

<ul>
<li><p>There are cases where you actually <em>need</em> a cast to <code>void *</code>, e.g. if you want to print a pointer:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%p\n"</span>, (<span class="hljs-type">void</span> *)&amp;x);
</code></pre>

<p>The cast is necessary here, because <code>printf()</code> is a variadic function, so implicit conversions don't work.</p></li>
<li><p>In C++, the situation is different. Casting pointer types is somewhat common (and correct) when dealing with objects of derived classes. Therefore, it makes sense that in C++, the conversion to and from <code>void *</code> is <strong>not</strong> implicit. C++ has a whole set of different flavors of casting.</p></li>
</ul>
    </div></div></div></div><div id="solution20" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 20</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/casting">casting</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I put in the cast simply to show disapproval of the ugly hole in the type system, which allows code such as the following snippet to compile without diagnostics, even though no casts are used to bring about the bad conversion:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">double</span> d;
<span class="hljs-type">void</span> *p = &amp;d;
<span class="hljs-type">int</span> *q = p;
</code></pre>

<p>I wish that didn't exist (and it doesn't in C++) and so I cast. It represents my taste, and my programming politics. I'm not only casting a pointer, but effectively, casting a ballot, and <a href="http://dilbert.com/strip/1994-02-03">casting out demons of stupidity</a>. If I can't <em>actually</em> <a href="http://dilbert.com/strip/1994-02-02">cast out stupidity</a>, then at least let me express the wish to do so with a gesture of protest.</p>

<p>In fact, a good practice is to wrap <code>malloc</code> (and friends) with functions that return <code>unsigned char *</code>, and basically never to use <code>void *</code> in your code.  If you need a generic pointer-to-any-object, use a <code>char *</code> or <code>unsigned char *</code>, and have casts in both directions. The one relaxation that can be indulged, perhaps, is using functions like <code>memset</code> and <code>memcpy</code> without casts.</p>

<p>On the topic of casting and C++ compatibility, if you write your code so that it compiles as both C and C++ (in which case you <em>have to</em> cast the return value of <code>malloc</code> when assigning it to something other than <code>void *</code>), you can do a very helpful thing for yourself: you can use macros for casting which translate to C++ style casts when compiling as C++, but reduce to a C cast when compiling as C:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-comment">/* In a header somewhere */</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> strip_qual(TYPE, EXPR) (const_cast<span class="hljs-string">&lt;TYPE&gt;</span>(EXPR))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> convert(TYPE, EXPR) (static_cast<span class="hljs-string">&lt;TYPE&gt;</span>(EXPR))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> coerce(TYPE, EXPR) (reinterpret_cast<span class="hljs-string">&lt;TYPE&gt;</span>(EXPR))</span>
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> strip_qual(TYPE, EXPR) ((TYPE) (EXPR))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> convert(TYPE, EXPR) ((TYPE) (EXPR))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> coerce(TYPE, EXPR) ((TYPE) (EXPR))</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>

<p>If you adhere to these macros, then a simple <code>grep</code> search of your code base for these identifiers will show you where all your casts are, so you can review whether any of them are incorrect.</p>

<p>Then, going forward, if you regularly compile the code with C++, it will enforce the use of an appropriate cast. For instance, if you use <code>strip_qual</code> just to remove a <code>const</code> or <code>volatile</code>, but the program changes in such a way that a type conversion is now involved, you will get a diagnostic, and you will have to use a combination of casts to get the desired conversion.</p>

<p>To help you adhere to these macros, the the GNU C++ (not C!) compiler has a beautiful feature: an optional diagnostic which is produced for all occurrences of C style casts.</p>

<pre>     -Wold-style-cast (C++ and Objective-C++ only)
         Warn if an old-style (C-style) cast to a non-void type is used
         within a C++ program.  The new-style casts (dynamic_cast,
         static_cast, reinterpret_cast, and const_cast) are less vulnerable
         to unintended effects and much easier to search for.
</pre>

<p>If your C code compiles as C++, you can use this <code>-Wold-style-cast</code> option to find out all occurrences of the <code>(type)</code> casting syntax that may creep into the code, and follow up on these diagnostics by replacing it with an appropriate choice from among the above macros (or a combination, if necessary).</p>

<p>This treatment of conversions is the single largest standalone technical justification for working in a "Clean C": the combined C and C++ dialect, which in turn technically justifies casting the return value of <code>malloc</code>.</p>
    </div></div></div></div><div id="solution21" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 21</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/casting">casting</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The best thing to do when programming in C whenever it is possible:</p>

<ol>
<li>Make your program compile through a C compiler with all warnings turned on <code>-Wall</code> and fix all errors and warnings</li>
<li>Make sure there are no variables declared as <code>auto</code></li>
<li>Then compile it using a C++ compiler with <code>-Wall</code> and <code>-std=c++11</code>. Fix all errors and warnings.</li>
<li>Now compile using the C compiler again. Your program should now compile without any warning and contain fewer bugs.</li>
</ol>

<p>This procedure lets you take advantage of C++ strict type checking, thus reducing the number of bugs. In particular, this procedure forces you to include <code>stdlib.h</code>or you will get</p>

<blockquote>
  <p><code>malloc</code> was not declared within this scope</p>
</blockquote>

<p>and also forces you to cast the result of <code>malloc</code> or you will get</p>

<blockquote>
  <p>invalid conversion from <code>void*</code> to <code>T*</code></p>
</blockquote>

<p>or what ever your target type is.</p>

<p>The only benefits from writing in C instead of C++ I can find are</p>

<ol>
<li>C has a well specified ABI</li>
<li>C++ may generate more code [exceptions, RTTI, templates, <em>runtime</em> polymorphism]</li>
</ol>

<p>Notice that the second cons should in the ideal case disappear when using the subset common to C together with the <em>static</em> polymorphic feature.</p>

<p>For those that finds C++ strict rules inconvenient, we can use the C++11 feature with inferred  type</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-keyword">auto</span> memblock=static_cast&lt;T*&gt;(<span class="hljs-built_in">malloc</span>(n*<span class="hljs-keyword">sizeof</span>(T))); <span class="hljs-comment">//Mult may overflow...</span>
</code></pre>
    </div></div></div></div><div id="solution22" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 22</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/casting">casting</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I prefer to do the cast, but not manually. My favorite is using <code>g_new</code> and <code>g_new0</code> macros from glib. If glib is not used, I would add similar macros. Those macros reduce code duplication without compromising type safety. If you get the type wrong, you would get an implicit cast between non-void pointers, which would cause a warning (error in C++). If you forget to include the header that defines <code>g_new</code> and <code>g_new0</code>, you would get an error. <code>g_new</code> and <code>g_new0</code> both take the same arguments, unlike <code>malloc</code> that takes fewer arguments than <code>calloc</code>. Just add <code>0</code> to get zero-initialized memory. The code can be compiled with a C++ compiler without changes.</p>
    </div></div></div></div><div id="solution23" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 23</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/casting">casting</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Casting is only for C++ not C.In case you are using a C++ compiler you better change it to C compiler.</p>
    </div></div></div></div><div id="solution24" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 24</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/casting">casting</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>The casting of malloc is unnecessary in C but mandatory in C++.</strong></p>

<p>Casting is unnecessary in C because of:</p>

<ul>
<li><code>void *</code> is automatically and safely promoted to any other pointer type in the case of C.</li>
<li>It can hide an error if you forgot to include <code>&lt;stdlib.h&gt;</code>. This can cause crashes.</li>
<li>If pointers and integers are differently sized, then you're hiding a warning by casting and might lose bits of your returned address.</li>
<li>If the type of the pointer is changed at its declaration, one may also need to change all lines where <code>malloc</code> is called and cast.</li>
</ul>

<p>On the other hand, casting may increase the portability of your program. i.e, it allows a C program or function to compile as C++.</p>
    </div></div></div></div><div id="solution25" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 25</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/casting">casting</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The concept behind void pointer is that it can be casted to any data type that is why malloc returns void. Also you must be aware of automatic typecasting. So it is not mandatory to cast the pointer though you must do it. It helps in keeping the code clean and helps debugging</p>
    </div></div></div></div><div id="solution26" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 26</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/casting">casting</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A void pointer is a generic pointer and C supports implicit conversion from a void pointer type to other types, so there is no need of explicitly typecasting it.</p>

<p>However, if you want the same code work perfectly compatible on a C++ platform, which does not support implicit conversion, you need to do the typecasting, so it all depends on usability.</p>
    </div></div></div></div><div id="solution27" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 27</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/casting">casting</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<ol>
<li><p>As other stated, it is not needed for C, but for C++.</p></li>
<li><p>Including the cast may allow a C program or function to compile as C++.</p></li>
<li><p>In C it is unnecessary, as void * is automatically and safely promoted to any other pointer type.</p></li>
<li><p>But if you cast then, it can hide an error if you forgot to include
<strong>stdlib.h</strong>. This can cause crashes (or, worse, not cause a crash
until way later in some totally different part of the code).</p>

<p>Because <strong>stdlib.h</strong> contains the prototype for malloc is found. In the
absence of a prototype for malloc, the standard requires that the C
compiler assumes malloc returns an int. If there is no cast, a
warning is issued when this integer is assigned to the pointer;
however, with the cast, this warning is not produced, hiding a bug.</p></li>
</ol>
    </div></div></div></div><div id="solution28" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 28</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/casting">casting</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The main issue with <code>malloc</code> is to get the <em>right size</em>.</p>
<p>The memory returned form <code>malloc()</code> is <em>untyped</em>, and it will not magically gain an <em>effective type</em> due to a simple cast.</p>
<p>I guess that both approaches are fine and the choice should depend on programmer intention.</p>
<ol>
<li>If allocating memory for a <strong>type</strong>, then use a cast.</li>
</ol>
<p><code>ptr = (T*)malloc(sizeof(T));</code></p>
<ol start="2">
<li>If allocating memory for a given pointer, then don't use a cast.</li>
</ol>
<p><code>ptr = malloc(sizeof *ptr);</code></p>
<h3>Ad 1</h3>
<p>The first method assures the correct size by allocating memory for a given type, and then casting it to assure that it is assigned to the right pointer. If incorrect type of <code>ptr</code> is used then the compiler will issue a warning/error. If the type of <code>ptr</code> is changed, then the compiler will point the places where the code needs refactoring.</p>
<p>Moreover, the first method can be combined into a macro similar to <code>new</code> operator in C++.</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NEW(T) ((T*)malloc(sizeof(T)))</span>
...
ptr = NEW(T);
</code></pre>
<p>Moreover this method works if <code>ptr</code> is <code>void*</code>.</p>
<h2>Ad 2</h2>
<p>The second methods does not care about the types, it assures the correct size by taking it from the pointer's type. The main advantage of this method is the automatic adjustment of storage size whenever the type of <code>ptr</code> is changed.
It can save some time (or errors) when refactoring.</p>
<p>The disadvantage is that the method does not work if <code>ptr</code> is <code>void*</code> but it may be perceived as a good thing. And that it does not work with C++ so it should not be used in inlined functions in headers that are going to be used by C++ programs.</p>
<p>Personally, I prefer the second option.</p>
    </div></div></div></div><div id="solution29" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 29</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/malloc">malloc</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/casting">casting</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>For me, the take home and conclusion here is that casting <code>malloc</code> in C is totally NOT necessary but if you however cast, it wont affect <code>malloc</code> as <code>malloc</code> will still allocate to you your requested blessed memory space.
Another take home is the reason or one of the reasons people do casting and this is to enable them compile same program either in C or C++.</p>

<p>There may be other reasons but other reasons, almost certainly, would land you in serious trouble sooner or later.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/syntax-error-due-to-using-a-reserved-word-as-a-table-or-column-name-in-mysql-1657384689274">Syntax error due to using a reserved word as a table or column name in MySQL</a><a href="/questions/what-is-a-plain-english-explanation-of-%22big-o%22-notation-1657387641953">What is a plain English explanation of &quot;Big O&quot; notation?</a><a href="/questions/why-does-my-function-that-calls-an-api-or-launches-a-coroutine-return-an-empty-or-null-value-1657388483820">Why does my function that calls an API or launches a coroutine return an empty or null value?</a><a href="/questions/iterating-through-a-collection-avoiding-concurrentmodificationexception-when-removing-objects-in-a-loop-1657387311824">Iterating through a Collection, avoiding ConcurrentModificationException when removing objects in a loop</a><a href="/questions/what-is-the-copy-and-swap-idiom-1657384840329">What is the copy-and-swap idiom?</a><a href="/questions/the-difference-between-bracket-and-double-bracket-for-accessing-the-elements-of-a-list-or-dataframe-1657388451711">The difference between bracket [ ] and double bracket [[ ]] for accessing the elements of a list or dataframe</a><a href="/questions/test-for-existence-of-nested-javascript-object-key-1657387935411">Test for existence of nested JavaScript object key</a><a href="/questions/how-do-i-use-arrays-in-c++-1657387456118">How do I use arrays in C++?</a><a href="/questions/deep-cloning-objects-1657387930865">Deep cloning objects</a><a href="/questions/can-i-mix-mysql-apis-in-php-1657384597444">Can I mix MySQL APIs in PHP?</a><a href="/questions/mergeflatten-an-array-of-arrays-1657387827427">Merge/flatten an array of arrays</a><a href="/questions/should-i-avoid-the-use-of-set(preferredormaximumorminimum)size-methods-in-java-swing-1657384628399">Should I avoid the use of set(Preferred|Maximum|Minimum)Size methods in Java Swing?</a><a href="/questions/asynctask-android-example-1657388127898">AsyncTask Android example</a><a href="/questions/how-to-count-the-number-of-set-bits-in-a-32-bit-integer-1657388437370">How to count the number of set bits in a 32-bit integer?</a><a href="/questions/what-is-a-clearfix-1657387337825">What is a clearfix?</a><a href="/questions/how-to-include-a-php-variable-inside-a-mysql-statement-1657387669365">How to include a PHP variable inside a MySQL statement</a><a href="/questions/why-is-%22while(-!feof(file)-)%22-always-wrong-1657384367349">Why is โwhile( !feof(file) )โ always wrong?</a><a href="/questions/how-do-you-use-a-variable-in-a-regular-expression-1657387939007">How do you use a variable in a regular expression?</a><a href="/questions/how-do-we-control-web-page-caching-across-all-browsers-1657387529059">How do we control web page caching, across all browsers?</a><a href="/questions/when-does-sqliteopenhelper-oncreate()-onupgrade()-run-1657384883864">When does SQLiteOpenHelper onCreate() / onUpgrade() run?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;h3\u0026gt;TL;DR\u0026lt;/h3\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *sieve = (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *) \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;) * length);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;has two problems. The cast and that you\u0026apos;re using the type instead of variable as argument for sizeof. Instead, do like this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *sieve = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; *sieve * length);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h3\u0026gt;Long version\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;No\u0026lt;/strong\u0026gt;; you \u0026lt;em\u0026gt;don\u0026apos;t\u0026lt;/em\u0026gt; cast the result, since:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;It is unnecessary, as \u0026lt;code\u0026gt;void *\u0026lt;/code\u0026gt; is automatically and safely promoted to any other pointer type in this case.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It adds clutter to the code, casts are not very easy to read (especially if the pointer type is long).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It makes you repeat yourself, which is generally bad.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It can hide an error if you forgot to include \u0026lt;code\u0026gt;\u0026amp;lt;stdlib.h\u0026amp;gt;\u0026lt;/code\u0026gt;. This can cause crashes (or, worse, \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; cause a crash until way later in some totally different part of the code). Consider what happens if pointers and integers are differently sized; then you\u0026apos;re hiding a warning by casting and might lose bits of your returned address. Note: as of C99 implicit functions are gone from C, and this point is no longer relevant since there\u0026apos;s no automatic assumption that undeclared functions return \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;As a clarification, note that I said \u0026quot;you don\u0026apos;t cast\u0026quot;, not \u0026quot;you don\u0026apos;t \u0026lt;em\u0026gt;need\u0026lt;/em\u0026gt; to cast\u0026quot;. In my opinion, it\u0026apos;s a failure to include the cast, even if you got it right. There are simply no benefits to doing it, but a bunch of potential risks, and including the cast indicates that you don\u0026apos;t know about the risks.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Also note, as commentators point out, that the above talks about straight C, not C++. I very firmly believe in C and C++ as separate languages.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;To add further, your code needlessly repeats the type information (\u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;) which can cause errors. It\u0026apos;s better to de-reference the pointer being used to store the return value, to \u0026quot;lock\u0026quot; the two together:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *sieve = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(length * \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; *sieve);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This also moves the \u0026lt;code\u0026gt;length\u0026lt;/code\u0026gt; to the front for increased visibility, and drops the redundant parentheses with \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt;; they \u0026lt;em\u0026gt;are only needed\u0026lt;/em\u0026gt; when the argument is a type name. Many people seem to not know (or ignore) this, which makes their code more verbose. Remember: \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt; is not a function! :)\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;While moving \u0026lt;code\u0026gt;length\u0026lt;/code\u0026gt; to the front \u0026lt;em\u0026gt;may\u0026lt;/em\u0026gt; increase visibility in some rare cases, one should also pay attention that in the general case, it should be better to write the expression as:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *sieve = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; *sieve * length);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Since keeping the \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt; first, in this case, ensures multiplication is done with at least \u0026lt;code\u0026gt;size_t\u0026lt;/code\u0026gt; math.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Compare: \u0026lt;code\u0026gt;malloc(sizeof *sieve * length * width)\u0026lt;/code\u0026gt; vs. \u0026lt;code\u0026gt;malloc(length * width * sizeof *sieve)\u0026lt;/code\u0026gt; the second may overflow the \u0026lt;code\u0026gt;length * width\u0026lt;/code\u0026gt; when \u0026lt;code\u0026gt;width\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;length\u0026lt;/code\u0026gt; are smaller types than \u0026lt;code\u0026gt;size_t\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In C, you don\u0026apos;t need to cast the return value of \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt;. The pointer to void returned by \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; is automagically converted to the correct type. However, if you want your code to compile with a C++ compiler, a cast is needed. A preferred alternative among the community is to use the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *sieve = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; *sieve * length);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;which additionally frees you from having to worry about changing the right-hand side of the expression if ever you change the type of \u0026lt;code\u0026gt;sieve\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Casts are bad, as people have pointed out. Especially pointer casts. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You \u0026lt;strong\u0026gt;do\u0026lt;/strong\u0026gt; cast, because:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;It makes your code \u0026lt;strong\u0026gt;more portable\u0026lt;/strong\u0026gt; between C and C++, and as SO experience shows, a great many programmers claim they are writing in C when they are really writing in C++ (or C plus local compiler extensions).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Failing to do so \u0026lt;strong\u0026gt;can hide an error\u0026lt;/strong\u0026gt;: note all the SO examples of confusing when to write \u0026lt;code\u0026gt;type *\u0026lt;/code\u0026gt; versus \u0026lt;code\u0026gt;type **\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The idea that it keeps you from noticing you failed to \u0026lt;code\u0026gt;#include\u0026lt;/code\u0026gt; an appropriate header file misses \u0026lt;strong\u0026gt;the forest for the trees\u0026lt;/strong\u0026gt;. It\u0026apos;s the same as saying \u0026quot;don\u0026apos;t worry about the fact you failed to ask the compiler to complain about not seeing prototypes -- that pesky stdlib.h is the REAL important thing to remember!\u0026quot;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It forces an \u0026lt;strong\u0026gt;extra cognitive cross-check\u0026lt;/strong\u0026gt;. It puts the (alleged) desired type right next to the arithmetic you\u0026apos;re doing for the raw size of that variable. I bet you could do an SO study that shows that \u0026lt;code\u0026gt;malloc()\u0026lt;/code\u0026gt; bugs are caught much faster when there\u0026apos;s a cast. As with assertions, annotations that reveal intent decrease bugs. \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Repeating yourself in a way that the machine can check is often a \u0026lt;strong\u0026gt;great\u0026lt;/strong\u0026gt; idea. In fact, that\u0026apos;s what an assertion is, and this use of cast is an assertion. Assertions are still the most general technique we have for getting code correct, since Turing came up with the idea so many years ago.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As others stated, it is not needed for C, but necessary for C++. If you think you are going to compile your C code with a C++ compiler, for whatever reasons, you can use a macro instead, like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ifdef\u0026lt;/span\u0026gt; __cplusplus\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; NEW(type, count) ((type *)calloc(count, sizeof(type)))\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; NEW(type, count) (calloc(count, sizeof(type)))\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;endif\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;That way you can still write it in a very compact way:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *sieve = NEW(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and it will compile for C and C++.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;From the \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/C_dynamic_memory_allocation#Advantages_to_casting\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Wikipedia\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Advantages to casting\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n  \n  \u0026lt;ul\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Including the cast may allow a C program or function to compile as C++.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;p\u0026gt;The cast allows for pre-1989 versions of malloc that originally returned a char *.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Casting can help the developer identify inconsistencies in type sizing should the destination pointer type change, particularly if the pointer is declared far from the malloc() call (although modern compilers and static analyzers can warn on such behaviour without requiring the cast).\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n  \u0026lt;/ul\u0026gt;\n  \n  \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Disadvantages to casting\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n  \n  \u0026lt;ul\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Under the ANSI C standard, the cast is redundant.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Adding the cast may mask failure to include the header \u0026lt;em\u0026gt;stdlib.h\u0026lt;/em\u0026gt;, in\n  which the prototype for malloc is found. In the absence of a\n  prototype for malloc, the standard requires that the C compiler\n  assume malloc returns an int. If there is no cast, a warning is\n  issued when this integer is assigned to the pointer; however, with\n  the cast, this warning is not produced, hiding a bug. On certain\n  architectures and data models (such as LP64 on 64-bit systems, where\n  long and pointers are 64-bit and int is 32-bit), this error can\n  actually result in undefined behaviour, as the implicitly declared\n  malloc returns a 32-bit value whereas the actually defined function\n  returns a 64-bit value. Depending on calling conventions and memory\n  layout, this may result in stack smashing. This issue is less likely\n  to go unnoticed in modern compilers, as they uniformly produce\n  warnings that an undeclared function has been used, so a warning will\n  still appear. For example, GCC\u0026apos;s default behaviour is to show a\n  warning that reads \u0026quot;incompatible implicit declaration of built-in\n  function\u0026quot; regardless of whether the cast is present or not.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If the type of the pointer is changed at its declaration, one may\n  also, need to change all lines where malloc is called and cast.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n  \u0026lt;/ul\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Although \u0026lt;strong\u0026gt;malloc without casting is preferred method and most experienced programmers choose it\u0026lt;/strong\u0026gt;, you should use whichever you like having aware of the issues.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;i.e: If you need to compile C program as C++ (Although it is a separate language) you must cast the result of use \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt;. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In C you can implicitly convert a \u0026lt;code\u0026gt;void\u0026lt;/code\u0026gt; pointer to any other kind of pointer, so a cast is not necessary. Using one may suggest to the casual observer that there is some reason why one is needed, which may be misleading.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You don\u0026apos;t cast the result of \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt;, because doing so adds pointless clutter to your code.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The most common reason why people cast the result of \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; is because they are unsure about how the C language works. That\u0026apos;s a warning sign: if you don\u0026apos;t know how a particular language mechanism works, then \u0026lt;em\u0026gt;don\u0026apos;t\u0026lt;/em\u0026gt; take a guess. Look it up or ask on Stack Overflow.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Some comments:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;A void pointer can be converted to/from any other pointer type without an explicit cast (C11 6.3.2.3 and 6.5.16.1).\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;C++ will however not allow an implicit cast between \u0026lt;code\u0026gt;void*\u0026lt;/code\u0026gt; and another pointer type. So in C++, the cast would have been correct. But if you program in C++, you should use \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; and not \u0026lt;code\u0026gt;malloc()\u0026lt;/code\u0026gt;. And you should never compile C code using a C++ compiler.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If you need to support both C and C++ with the same source code, use compiler switches to mark the differences. Do not attempt to sate both language standards with the same code, because they are not compatible.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If a C compiler cannot find a function because you forgot to include the header, you will get a compiler/linker error about that. So if you forgot to include \u0026lt;code\u0026gt;\u0026amp;lt;stdlib.h\u0026amp;gt;\u0026lt;/code\u0026gt; that\u0026apos;s no biggie, you won\u0026apos;t be able to build your program.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;On ancient compilers that follow a version of the standard which is more than 25 years old, forgetting to include \u0026lt;code\u0026gt;\u0026amp;lt;stdlib.h\u0026amp;gt;\u0026lt;/code\u0026gt; would result in dangerous behavior. Because in that ancient standard, functions without a visible prototype implicitly converted the return type to \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;. Casting the result from \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; explicitly would then hide away this bug.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;But that is really a non-issue. You aren\u0026apos;t using a 25 years old computer, so why would you use a 25 years old compiler?\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In C you get an implicit conversion from \u0026lt;code\u0026gt;void *\u0026lt;/code\u0026gt; to any other (data) pointer.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Casting the value returned by \u0026lt;code\u0026gt;malloc()\u0026lt;/code\u0026gt; is not necessary now, but I\u0026apos;d like to add one point that seems no one has pointed out:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In the ancient days, that is, before \u0026lt;strong\u0026gt;ANSI C\u0026lt;/strong\u0026gt; provides the \u0026lt;code\u0026gt;void *\u0026lt;/code\u0026gt; as the generic type of pointers, \u0026lt;code\u0026gt;char *\u0026lt;/code\u0026gt; is the type for such usage. In that case, the cast can shut down the compiler warnings.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Reference: \u0026lt;a href=\u0026quot;http://c-faq.com/malloc/cast.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;C FAQ\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Just adding my experience, studying computer engineering I see that the two or three professors that I have seen writing in C always cast malloc, however the one I asked (with an immense CV and understanding of C) told me that it is absolutely unnecessary but only used to be absolutely specific, and to get the students into the mentality of being absolutely specific. Essentially casting will not change anything in how it works, it does exactly what it says, allocates memory, and casting does not effect it, you get the same memory, and even if you cast it to something else by mistake (and somehow evade compiler errors) C will access it the same way.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Edit:\u0026lt;/strong\u0026gt; Casting has a certain point. When you use array notation, the code generated has to know how many memory places it has to advance to reach the beginning of the next element, this is achieved through casting. This way you know that for a double you go 8 bytes ahead while for an int you go 4, and so on. Thus it has no effect if you use pointer notation, in array notation it becomes necessary.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It is not mandatory to cast the results of \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt;, since it returns \u0026lt;code\u0026gt;void*\u0026lt;/code\u0026gt; , and a \u0026lt;code\u0026gt;void*\u0026lt;/code\u0026gt; can be pointed to any datatype. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is what \u0026lt;a href=\u0026quot;http://www.gnu.org/software/libc/manual/html_node/Basic-Allocation.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;The GNU C Library Reference\u0026lt;/a\u0026gt; manual says: \u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;You can store the result of \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; into any pointer variable without a\n  cast, because ISO C automatically converts the type \u0026lt;code\u0026gt;void *\u0026lt;/code\u0026gt; to another\n  type of pointer when necessary. But the cast is necessary in contexts\n  other than assignment operators or if you might want your code to run\n  in traditional C.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;And indeed the \u0026lt;a href=\u0026quot;http://www.compsci.hunter.cuny.edu/~sweiss/resources/c11standard.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;ISO C11 standard\u0026lt;/a\u0026gt; (p347) says so: \u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The pointer returned if the allocation succeeds is suitably aligned so\n  that it may be assigned to a pointer to any type of object with a\n  fundamental alignment requirement and then used to access such an\n  object or an array of such objects in the space allocated (until the\n  space is explicitly deallocated)\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A void pointer is a generic object pointer and C supports implicit conversion from a void pointer type to other types, so there is no need of explicitly typecasting it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However, if you want the same code work perfectly compatible on a C++ platform, which does not support implicit conversion, you need to do the typecasting, so it all depends on usability.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The returned type is void*, which can be cast to the desired type of data pointer in order to be dereferenceable.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It depends on the programming language and compiler. If you use \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; in C, there is no need to type cast it, as it will automatically type cast. However, if you are using C++, then you should type cast because \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; will return a \u0026lt;code\u0026gt;void*\u0026lt;/code\u0026gt; type.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In the C language, a void pointer can be assigned to any pointer, which is why you should not use a type cast. If you want \u0026quot;type safe\u0026quot; allocation, I can recommend the following macro functions, which I always use in my C projects:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdlib.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; NEW_ARRAY(ptr, n) (ptr) = malloc((n) * sizeof *(ptr))\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; NEW(ptr) NEW_ARRAY((ptr), 1)\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;With these in place you can simply say\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;NEW_ARRAY(sieve, length);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;For non-dynamic arrays, the third must-have function macro is\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; LEN(arr) (sizeof (arr) / sizeof (arr)[0])\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;which makes array loops safer and more convenient:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i, a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;];\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; LEN(a); i++) {\n   ...\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;People used to GCC and Clang are spoiled.  It\u0026apos;s not all that good out there.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I have been pretty horrified over the years by the staggeringly aged compilers I\u0026apos;ve been required to use.  Often companies and managers adopt an ultra-conservative approach to changing compilers and will not even \u0026lt;em\u0026gt;test\u0026lt;/em\u0026gt; if a new compiler ( with better standards compliance and code optimization ) will work in their system.  The practical reality for working developers is that when you\u0026apos;re coding you need to cover your bases and, unfortunately, casting mallocs is a good habit if you cannot control what compiler may be applied to your code.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I would also suggest that many organizations apply a coding standard of their own and that \u0026lt;em\u0026gt;that\u0026lt;/em\u0026gt; should be the method people follow if it is defined.  In the absence of explicit guidance I tend to go for most likely to compile everywhere, rather than slavish adherence to a standard.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The argument that it\u0026apos;s not necessary under current standards is quite valid.  But that argument omits the practicalities of the real world.  We do not code in a world ruled exclusively by the standard of the day, but by the practicalities of what I like to call \u0026quot;local management\u0026apos;s reality field\u0026quot;.  And that\u0026apos;s bent and twisted more than space time ever was. :-)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;YMMV.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I tend to think of casting malloc as a defensive operation.  Not pretty, not perfect, but generally safe.  ( Honestly, if you\u0026apos;ve not included stdlib.h then you\u0026apos;ve \u0026lt;em\u0026gt;way\u0026lt;/em\u0026gt; more problems than casting malloc ! ).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;\u0026lt;strong\u0026gt;This question is subject of opinion-based abuse.\u0026lt;/strong\u0026gt;\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;Sometimes I notice comments like that:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc\u0026quot;\u0026gt;Don\u0026apos;t cast the result of malloc\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;or\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc\u0026quot;\u0026gt;Why you don\u0026apos;t cast the result of malloc\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;on questions where OP uses casting. The comments itself contain a hyperlink to this question.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;That is in \u0026lt;em\u0026gt;any\u0026lt;/em\u0026gt; possible manner inappropriate and incorrect as well. There is no right and no wrong when it is truly a matter of one\u0026apos;s own coding-style.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;Why is this happening?\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;It\u0026apos;s based upon two reasons:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;This question is indeed opinion-based. Technically, the question should have been closed as opinion-based years ago. A \u0026quot;\u0026lt;em\u0026gt;Do I\u0026lt;/em\u0026gt;\u0026quot; or \u0026quot;\u0026lt;em\u0026gt;Don\u0026apos;t I\u0026lt;/em\u0026gt;\u0026quot; or equivalent \u0026quot;\u0026lt;em\u0026gt;Should I\u0026lt;/em\u0026gt;\u0026quot; or \u0026quot;\u0026lt;em\u0026gt;Shouldn\u0026apos;t I\u0026lt;/em\u0026gt;\u0026quot; question, you just can\u0026apos;t answer focused without an attitude of one\u0026apos;s own opinion. One of the reason to close a question is because it \u0026quot;might lead to opinion-based answers\u0026quot; as it is well shown here.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Many answers (including the most apparent and accepted \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/605858/12139179\u0026quot;\u0026gt;answer\u0026lt;/a\u0026gt; of \u0026lt;a href=\u0026quot;https://stackoverflow.com/users/28169/unwind\u0026quot;\u0026gt;@unwind\u0026lt;/a\u0026gt;) are either completely or almost entirely opinion-based (f.e. a mysterious \u0026quot;clutter\u0026quot; that would be added to your code if you do casting or repeating yourself would be bad) and show a clear and focused tendency to omit the cast. They argue about the redundancy of the cast on one side but also and even worse argue to solve a bug caused by a bug/failure of programming itself - to not \u0026lt;code\u0026gt;#include \u0026amp;lt;stdlib.h\u0026amp;gt;\u0026lt;/code\u0026gt; if one want to use \u0026lt;code\u0026gt;malloc()\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;I want to bring a true view of some points discussed, with less of my personal opinion. A few points need to be noted especially:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Such a very susceptible question to fall into one\u0026apos;s own opinion needs an answer with neutral pros and cons. Not only cons or pros.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A good overview of pros and cons is listed in this answer:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/a/33047365/12139179\u0026quot;\u0026gt;https://stackoverflow.com/a/33047365/12139179\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;(I personally consider this because of that reason the best answer, so far.)\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;ol start=\u0026quot;2\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;One reason which is encountered at most to reason the omission of the cast is that the cast might hide a bug.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If someone uses an implicit declared \u0026lt;code\u0026gt;malloc()\u0026lt;/code\u0026gt; that returns \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; (implicit functions are gone from the standard since C99) and \u0026lt;code\u0026gt;sizeof(int) != sizeof(int*)\u0026lt;/code\u0026gt;, as shown in this question\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://stackoverflow.com/q/7545365/168175\u0026quot;\u0026gt;Why does this code segfault on 64-bit architecture but work fine on 32-bit?\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;the cast would hide a bug.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;While this is true, it only shows half of the story as the omission of the cast would only be a forward-bringing solution to an even bigger bug - not including \u0026lt;code\u0026gt;stdlib.h\u0026lt;/code\u0026gt; when using \u0026lt;code\u0026gt;malloc()\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This will never be a serious issue, If you,\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Use a compiler compliant to C99 or above (which is recommended and should be mandatory), and\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Aren\u0026apos;t so absent to forgot to include \u0026lt;code\u0026gt;stdlib.h\u0026lt;/code\u0026gt;, when you want to use \u0026lt;code\u0026gt;malloc()\u0026lt;/code\u0026gt; in your code, which is a huge bug itself.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;ol start=\u0026quot;3\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Some people argue about C++ compliance of C code, as the cast is obliged in C++.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;First of all to say in general: Compiling C code with a C++ compiler is not a good practice.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;C and C++ are in fact two completely different languages with different semantics.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;But If you really want/need to make C code compliant to C++ and vice versa use compiler switches instead of any cast.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Since the cast is with tendency declared as redundant or even harmful, I want to take a focus on these questions, which give good reasons why casting can be useful or even necessary:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/a/34094068/12139179\u0026quot;\u0026gt;https://stackoverflow.com/a/34094068/12139179\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/a/36297486/12139179\u0026quot;\u0026gt;https://stackoverflow.com/a/36297486/12139179\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/a/33044300/12139179\u0026quot;\u0026gt;https://stackoverflow.com/a/33044300/12139179\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;ol start=\u0026quot;4\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;The cast can be non-beneficial when your code, respectively the type of the assigned pointer (and with that the type of the cast), changes, although this is in most cases unlikely. Then you would need to maintain/change all casts too and if you have a few thousand calls to memory-management functions in your code, this can really summarizing up and decrease the maintenance efficiency.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;Summary:\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Fact is, that the cast is redundant per the C standard (already since ANSI-C (C89/C90)) if the assigned pointer point to an object of fundamental alignment requirement (which includes the most of all objects).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;You don\u0026apos;t need to do the cast as the pointer is automatically aligned in this case:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026quot;The order and contiguity of storage allocated by successive calls to the aligned_alloc, calloc, malloc, and realloc functions is unspecified. \u0026lt;strong\u0026gt;The pointer returned if the allocation succeeds is suitably aligned so that it may be assigned to a pointer to any type of object with a fundamental alignment requirement\u0026lt;/strong\u0026gt; and then used to access such an object or an array of such objects in the space allocated (until the space is explicitly deallocated).\u0026quot;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Source: C18, ยง7.22.3/1\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026quot;A \u0026lt;em\u0026gt;fundamental alignment\u0026lt;/em\u0026gt; is a valid alignment less than or equal to \u0026lt;code\u0026gt;_Alignof (max_align_t)\u0026lt;/code\u0026gt;. Fundamental alignments shall be supported by the implementation for objects of all storage durations. The alignment requirements of the following types shall be fundamental alignments:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;  all atomic, qualified, or unqualified basic types;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;  all atomic, qualified, or unqualified enumerated types;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;  all atomic, qualified, or unqualified pointer types;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;  all array types whose element type has a fundamental alignment requirement;57)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;  all types specified in Clause 7 as complete object types;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;  all structure or union types all of whose elements have types with fundamental alignment requirements and none of whose elements have an alignment specifier specifying an alignment that is not a fundamental alignment.\u0026lt;/p\u0026gt;\n\u0026lt;ol start=\u0026quot;57\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;As specified in 6.2.1, the later declaration might hide the prior declaration.\u0026quot;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;Source: C18, ยง6.2.8/2\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;However, if you allocate memory for an implementation-defined object of extended alignment requirement, the cast would be needed.\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;An \u0026lt;em\u0026gt;extended alignment\u0026lt;/em\u0026gt; is represented by an alignment greater than \u0026lt;code\u0026gt;_Alignof (max_align_t)\u0026lt;/code\u0026gt;. It is implementation-defined whether any extended alignments are supported and the storage durations for which they are supported. A type having an extended alignment requirement is an over-aligned type.58)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Source. C18, ยง6.2.8/3\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Everything else is a matter of the specific use case and one\u0026apos;s own opinion.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Please be careful how you educate yourself.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I recommend you to read \u0026lt;em\u0026gt;all\u0026lt;/em\u0026gt; of the answers made so far carefully first (as well as their comments which may point at a failure) and then build your own opinion if you or if you not cast the result of \u0026lt;code\u0026gt;malloc()\u0026lt;/code\u0026gt; at a specific case.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Please note:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;There is no right and wrong answer to that question. It is a matter of style and you yourself decide which way you choose (if you aren\u0026apos;t forced to by education or job of course). Please be aware of that and don\u0026apos;t let trick you\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;Last note: I voted to lately close this question as opinion-based, which is indeed needed since years. If you got the close/reopen privilege I would like to invite you to do so, too.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;No, you don\u0026apos;t cast the result of \u0026lt;code\u0026gt;malloc()\u0026lt;/code\u0026gt;.\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;In general, you \u0026lt;strong\u0026gt;don\u0026apos;t cast to or from \u0026lt;code\u0026gt;void *\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A typical reason given for not doing so is that failure to \u0026lt;code\u0026gt;#include \u0026amp;lt;stdlib.h\u0026amp;gt;\u0026lt;/code\u0026gt; could go unnoticed. This isn\u0026apos;t an issue anymore for a long time now as C99 made \u0026lt;em\u0026gt;implicit function declarations\u0026lt;/em\u0026gt; illegal, so if your compiler conforms to at least C99, you will get a diagnostic message.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But there\u0026apos;s a \u0026lt;strong\u0026gt;much stronger reason\u0026lt;/strong\u0026gt; not to introduce unnecessary pointer casts:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In C, a \u0026lt;strong\u0026gt;pointer cast is almost always an error\u0026lt;/strong\u0026gt;. This is because of the following rule (\u0026lt;strong\u0026gt;ยง6.5 p7\u0026lt;/strong\u0026gt; in N1570, the latest draft for C11):\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;An object shall have its stored value accessed only by an lvalue expression that has one of\n  the following types:\u0026lt;br\u0026gt;\n   a type compatible with the effective type of the object,\u0026lt;br\u0026gt;\n   a qualified version of a type compatible with the effective type of the object,\u0026lt;br\u0026gt;\n   a type that is the signed or unsigned type corresponding to the effective type of the\n  object,\u0026lt;br\u0026gt;\n   a type that is the signed or unsigned type corresponding to a qualified version of the\n  effective type of the object,\u0026lt;br\u0026gt;\n   an aggregate or union type that includes one of the aforementioned types among its\n  members (including, recursively, a member of a subaggregate or contained union), or\u0026lt;br\u0026gt;\n   a character type.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;This is also known as the \u0026lt;em\u0026gt;strict aliasing rule\u0026lt;/em\u0026gt;. So the following code is \u0026lt;em\u0026gt;undefined behavior\u0026lt;/em\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; *p = (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; *)\u0026amp;amp;x;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; y = *p;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And, sometimes surprisingly, the following is as well:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-class\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt; {\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x; };\n\u0026lt;span class=\u0026quot;hljs-class\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt; {\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; y; };\n\u0026lt;span class=\u0026quot;hljs-class\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt; =\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;};\n\u0026lt;span class=\u0026quot;hljs-class\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;p\u0026lt;/span\u0026gt; =\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; foo *)\u0026amp;amp;b;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; z = p-\u0026amp;gt;x;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Sometimes, you \u0026lt;strong\u0026gt;do\u0026lt;/strong\u0026gt; need to cast pointers, but given the \u0026lt;em\u0026gt;strict aliasing rule\u0026lt;/em\u0026gt;, you have to be very careful with it. So, any occurrence of a pointer cast in your code is a place you \u0026lt;strong\u0026gt;have to double-check for its validity\u0026lt;/strong\u0026gt;. Therefore, you never write an unnecessary pointer cast.\u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;tl;dr\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;In a nutshell: Because in C, \u0026lt;strong\u0026gt;any\u0026lt;/strong\u0026gt; occurrence of a \u0026lt;em\u0026gt;pointer cast\u0026lt;/em\u0026gt; should raise a red flag for code requiring special attention, you should never write \u0026lt;em\u0026gt;unnecessary\u0026lt;/em\u0026gt; pointer casts.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Side notes:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;There are cases where you actually \u0026lt;em\u0026gt;need\u0026lt;/em\u0026gt; a cast to \u0026lt;code\u0026gt;void *\u0026lt;/code\u0026gt;, e.g. if you want to print a pointer:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%p\\n\u0026quot;\u0026lt;/span\u0026gt;, (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; *)\u0026amp;amp;x);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The cast is necessary here, because \u0026lt;code\u0026gt;printf()\u0026lt;/code\u0026gt; is a variadic function, so implicit conversions don\u0026apos;t work.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;In C++, the situation is different. Casting pointer types is somewhat common (and correct) when dealing with objects of derived classes. Therefore, it makes sense that in C++, the conversion to and from \u0026lt;code\u0026gt;void *\u0026lt;/code\u0026gt; is \u0026lt;strong\u0026gt;not\u0026lt;/strong\u0026gt; implicit. C++ has a whole set of different flavors of casting.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I put in the cast simply to show disapproval of the ugly hole in the type system, which allows code such as the following snippet to compile without diagnostics, even though no casts are used to bring about the bad conversion:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; d;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; *p = \u0026amp;amp;d;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *q = p;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I wish that didn\u0026apos;t exist (and it doesn\u0026apos;t in C++) and so I cast. It represents my taste, and my programming politics. I\u0026apos;m not only casting a pointer, but effectively, casting a ballot, and \u0026lt;a href=\u0026quot;http://dilbert.com/strip/1994-02-03\u0026quot;\u0026gt;casting out demons of stupidity\u0026lt;/a\u0026gt;. If I can\u0026apos;t \u0026lt;em\u0026gt;actually\u0026lt;/em\u0026gt; \u0026lt;a href=\u0026quot;http://dilbert.com/strip/1994-02-02\u0026quot;\u0026gt;cast out stupidity\u0026lt;/a\u0026gt;, then at least let me express the wish to do so with a gesture of protest.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In fact, a good practice is to wrap \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; (and friends) with functions that return \u0026lt;code\u0026gt;unsigned char *\u0026lt;/code\u0026gt;, and basically never to use \u0026lt;code\u0026gt;void *\u0026lt;/code\u0026gt; in your code.  If you need a generic pointer-to-any-object, use a \u0026lt;code\u0026gt;char *\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;unsigned char *\u0026lt;/code\u0026gt;, and have casts in both directions. The one relaxation that can be indulged, perhaps, is using functions like \u0026lt;code\u0026gt;memset\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;memcpy\u0026lt;/code\u0026gt; without casts.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;On the topic of casting and C++ compatibility, if you write your code so that it compiles as both C and C++ (in which case you \u0026lt;em\u0026gt;have to\u0026lt;/em\u0026gt; cast the return value of \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; when assigning it to something other than \u0026lt;code\u0026gt;void *\u0026lt;/code\u0026gt;), you can do a very helpful thing for yourself: you can use macros for casting which translate to C++ style casts when compiling as C++, but reduce to a C cast when compiling as C:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* In a header somewhere */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ifdef\u0026lt;/span\u0026gt; __cplusplus\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; strip_qual(TYPE, EXPR) (const_cast\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;TYPE\u0026amp;gt;\u0026lt;/span\u0026gt;(EXPR))\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; convert(TYPE, EXPR) (static_cast\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;TYPE\u0026amp;gt;\u0026lt;/span\u0026gt;(EXPR))\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; coerce(TYPE, EXPR) (reinterpret_cast\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;TYPE\u0026amp;gt;\u0026lt;/span\u0026gt;(EXPR))\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; strip_qual(TYPE, EXPR) ((TYPE) (EXPR))\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; convert(TYPE, EXPR) ((TYPE) (EXPR))\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; coerce(TYPE, EXPR) ((TYPE) (EXPR))\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;endif\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If you adhere to these macros, then a simple \u0026lt;code\u0026gt;grep\u0026lt;/code\u0026gt; search of your code base for these identifiers will show you where all your casts are, so you can review whether any of them are incorrect.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Then, going forward, if you regularly compile the code with C++, it will enforce the use of an appropriate cast. For instance, if you use \u0026lt;code\u0026gt;strip_qual\u0026lt;/code\u0026gt; just to remove a \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;volatile\u0026lt;/code\u0026gt;, but the program changes in such a way that a type conversion is now involved, you will get a diagnostic, and you will have to use a combination of casts to get the desired conversion.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To help you adhere to these macros, the the GNU C++ (not C!) compiler has a beautiful feature: an optional diagnostic which is produced for all occurrences of C style casts.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;     -Wold-style-cast (C++ and Objective-C++ only)\n         Warn if an old-style (C-style) cast to a non-void type is used\n         within a C++ program.  The new-style casts (dynamic_cast,\n         static_cast, reinterpret_cast, and const_cast) are less vulnerable\n         to unintended effects and much easier to search for.\n\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If your C code compiles as C++, you can use this \u0026lt;code\u0026gt;-Wold-style-cast\u0026lt;/code\u0026gt; option to find out all occurrences of the \u0026lt;code\u0026gt;(type)\u0026lt;/code\u0026gt; casting syntax that may creep into the code, and follow up on these diagnostics by replacing it with an appropriate choice from among the above macros (or a combination, if necessary).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This treatment of conversions is the single largest standalone technical justification for working in a \u0026quot;Clean C\u0026quot;: the combined C and C++ dialect, which in turn technically justifies casting the return value of \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The best thing to do when programming in C whenever it is possible:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Make your program compile through a C compiler with all warnings turned on \u0026lt;code\u0026gt;-Wall\u0026lt;/code\u0026gt; and fix all errors and warnings\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Make sure there are no variables declared as \u0026lt;code\u0026gt;auto\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Then compile it using a C++ compiler with \u0026lt;code\u0026gt;-Wall\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;-std=c++11\u0026lt;/code\u0026gt;. Fix all errors and warnings.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Now compile using the C compiler again. Your program should now compile without any warning and contain fewer bugs.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;This procedure lets you take advantage of C++ strict type checking, thus reducing the number of bugs. In particular, this procedure forces you to include \u0026lt;code\u0026gt;stdlib.h\u0026lt;/code\u0026gt;or you will get\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; was not declared within this scope\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;and also forces you to cast the result of \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; or you will get\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;invalid conversion from \u0026lt;code\u0026gt;void*\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;T*\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;or what ever your target type is.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The only benefits from writing in C instead of C++ I can find are\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;C has a well specified ABI\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;C++ may generate more code [exceptions, RTTI, templates, \u0026lt;em\u0026gt;runtime\u0026lt;/em\u0026gt; polymorphism]\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;Notice that the second cons should in the ideal case disappear when using the subset common to C together with the \u0026lt;em\u0026gt;static\u0026lt;/em\u0026gt; polymorphic feature.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For those that finds C++ strict rules inconvenient, we can use the C++11 feature with inferred  type\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; memblock=static_cast\u0026amp;lt;T*\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(n*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(T))); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Mult may overflow...\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I prefer to do the cast, but not manually. My favorite is using \u0026lt;code\u0026gt;g_new\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;g_new0\u0026lt;/code\u0026gt; macros from glib. If glib is not used, I would add similar macros. Those macros reduce code duplication without compromising type safety. If you get the type wrong, you would get an implicit cast between non-void pointers, which would cause a warning (error in C++). If you forget to include the header that defines \u0026lt;code\u0026gt;g_new\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;g_new0\u0026lt;/code\u0026gt;, you would get an error. \u0026lt;code\u0026gt;g_new\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;g_new0\u0026lt;/code\u0026gt; both take the same arguments, unlike \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; that takes fewer arguments than \u0026lt;code\u0026gt;calloc\u0026lt;/code\u0026gt;. Just add \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt; to get zero-initialized memory. The code can be compiled with a C++ compiler without changes.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Casting is only for C++ not C.In case you are using a C++ compiler you better change it to C compiler.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;The casting of malloc is unnecessary in C but mandatory in C++.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Casting is unnecessary in C because of:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;void *\u0026lt;/code\u0026gt; is automatically and safely promoted to any other pointer type in the case of C.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It can hide an error if you forgot to include \u0026lt;code\u0026gt;\u0026amp;lt;stdlib.h\u0026amp;gt;\u0026lt;/code\u0026gt;. This can cause crashes.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If pointers and integers are differently sized, then you\u0026apos;re hiding a warning by casting and might lose bits of your returned address.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the type of the pointer is changed at its declaration, one may also need to change all lines where \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; is called and cast.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;On the other hand, casting may increase the portability of your program. i.e, it allows a C program or function to compile as C++.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The concept behind void pointer is that it can be casted to any data type that is why malloc returns void. Also you must be aware of automatic typecasting. So it is not mandatory to cast the pointer though you must do it. It helps in keeping the code clean and helps debugging\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A void pointer is a generic pointer and C supports implicit conversion from a void pointer type to other types, so there is no need of explicitly typecasting it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However, if you want the same code work perfectly compatible on a C++ platform, which does not support implicit conversion, you need to do the typecasting, so it all depends on usability.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;As other stated, it is not needed for C, but for C++.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Including the cast may allow a C program or function to compile as C++.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;In C it is unnecessary, as void * is automatically and safely promoted to any other pointer type.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;But if you cast then, it can hide an error if you forgot to include\n\u0026lt;strong\u0026gt;stdlib.h\u0026lt;/strong\u0026gt;. This can cause crashes (or, worse, not cause a crash\nuntil way later in some totally different part of the code).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Because \u0026lt;strong\u0026gt;stdlib.h\u0026lt;/strong\u0026gt; contains the prototype for malloc is found. In the\nabsence of a prototype for malloc, the standard requires that the C\ncompiler assumes malloc returns an int. If there is no cast, a\nwarning is issued when this integer is assigned to the pointer;\nhowever, with the cast, this warning is not produced, hiding a bug.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The main issue with \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; is to get the \u0026lt;em\u0026gt;right size\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The memory returned form \u0026lt;code\u0026gt;malloc()\u0026lt;/code\u0026gt; is \u0026lt;em\u0026gt;untyped\u0026lt;/em\u0026gt;, and it will not magically gain an \u0026lt;em\u0026gt;effective type\u0026lt;/em\u0026gt; due to a simple cast.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I guess that both approaches are fine and the choice should depend on programmer intention.\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;If allocating memory for a \u0026lt;strong\u0026gt;type\u0026lt;/strong\u0026gt;, then use a cast.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;ptr = (T*)malloc(sizeof(T));\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ol start=\u0026quot;2\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;If allocating memory for a given pointer, then don\u0026apos;t use a cast.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;ptr = malloc(sizeof *ptr);\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Ad 1\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;The first method assures the correct size by allocating memory for a given type, and then casting it to assure that it is assigned to the right pointer. If incorrect type of \u0026lt;code\u0026gt;ptr\u0026lt;/code\u0026gt; is used then the compiler will issue a warning/error. If the type of \u0026lt;code\u0026gt;ptr\u0026lt;/code\u0026gt; is changed, then the compiler will point the places where the code needs refactoring.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Moreover, the first method can be combined into a macro similar to \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; operator in C++.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; NEW(T) ((T*)malloc(sizeof(T)))\u0026lt;/span\u0026gt;\n...\nptr = NEW(T);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Moreover this method works if \u0026lt;code\u0026gt;ptr\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;void*\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Ad 2\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;The second methods does not care about the types, it assures the correct size by taking it from the pointer\u0026apos;s type. The main advantage of this method is the automatic adjustment of storage size whenever the type of \u0026lt;code\u0026gt;ptr\u0026lt;/code\u0026gt; is changed.\nIt can save some time (or errors) when refactoring.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The disadvantage is that the method does not work if \u0026lt;code\u0026gt;ptr\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;void*\u0026lt;/code\u0026gt; but it may be perceived as a good thing. And that it does not work with C++ so it should not be used in inlined functions in headers that are going to be used by C++ programs.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Personally, I prefer the second option.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;For me, the take home and conclusion here is that casting \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; in C is totally NOT necessary but if you however cast, it wont affect \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; as \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; will still allocate to you your requested blessed memory space.\nAnother take home is the reason or one of the reasons people do casting and this is to enable them compile same program either in C or C++.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There may be other reasons but other reasons, almost certainly, would land you in serious trouble sooner or later.\u0026lt;/p\u0026gt;\n    "],"id":15,"title":"Do I cast the result of malloc?","content":"\n                \n\u0026lt;p\u0026gt;In \u0026lt;a href=\u0026quot;http://stackoverflow.com/questions/571945/getting-a-stack-overflow-exception-when-declaring-a-large-array\u0026quot;\u0026gt;this question\u0026lt;/a\u0026gt;, someone suggested in a \u0026lt;a href=\u0026quot;http://stackoverflow.com/questions/571945/getting-a-stack-overflow-exception-when-declaring-a-large-array#comment388297_571961\u0026quot;\u0026gt;comment\u0026lt;/a\u0026gt; that I should \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;not\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; cast the result of \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt;. i.e., I should do this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *sieve = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(*sieve) * length);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;rather than:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *sieve = (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *) \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(*sieve) * length);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Why would this be the case?\u0026lt;/p\u0026gt;\n    ","slug":"do-i-cast-the-result-of-malloc-1657384271583","postType":"QUESTION","createdAt":"2022-07-09T16:31:11.000Z","updatedAt":"2022-07-09T16:31:11.000Z","tags":[{"id":51,"name":"malloc","slug":"malloc","createdAt":"2022-07-09T16:31:11.000Z","updatedAt":"2022-07-09T16:31:11.000Z","Questions_Tags":{"questionId":15,"tagId":51}},{"id":52,"name":"casting","slug":"casting","createdAt":"2022-07-09T16:31:11.000Z","updatedAt":"2022-07-09T16:31:11.000Z","Questions_Tags":{"questionId":15,"tagId":52}}],"relatedQuestions":[{"title":"Do I cast the result of malloc?","slug":"do-i-cast-the-result-of-malloc-1657384271583","tags":[{"name":"malloc","Questions_Tags":{"questionId":15,"tagId":51}},{"name":"casting","Questions_Tags":{"questionId":15,"tagId":52}}]}]},"randomQuestions":[{"title":"Syntax error due to using a reserved word as a table or column name in MySQL","slug":"syntax-error-due-to-using-a-reserved-word-as-a-table-or-column-name-in-mysql-1657384689274"},{"title":"What is a plain English explanation of \"Big O\" notation?","slug":"what-is-a-plain-english-explanation-of-\"big-o\"-notation-1657387641953"},{"title":"Why does my function that calls an API or launches a coroutine return an empty or null value?","slug":"why-does-my-function-that-calls-an-api-or-launches-a-coroutine-return-an-empty-or-null-value-1657388483820"},{"title":"Iterating through a Collection, avoiding ConcurrentModificationException when removing objects in a loop","slug":"iterating-through-a-collection-avoiding-concurrentmodificationexception-when-removing-objects-in-a-loop-1657387311824"},{"title":"What is the copy-and-swap idiom?","slug":"what-is-the-copy-and-swap-idiom-1657384840329"},{"title":"The difference between bracket [ ] and double bracket [[ ]] for accessing the elements of a list or dataframe","slug":"the-difference-between-bracket-and-double-bracket-for-accessing-the-elements-of-a-list-or-dataframe-1657388451711"},{"title":"Test for existence of nested JavaScript object key","slug":"test-for-existence-of-nested-javascript-object-key-1657387935411"},{"title":"How do I use arrays in C++?","slug":"how-do-i-use-arrays-in-c++-1657387456118"},{"title":"Deep cloning objects","slug":"deep-cloning-objects-1657387930865"},{"title":"Can I mix MySQL APIs in PHP?","slug":"can-i-mix-mysql-apis-in-php-1657384597444"},{"title":"Merge/flatten an array of arrays","slug":"mergeflatten-an-array-of-arrays-1657387827427"},{"title":"Should I avoid the use of set(Preferred|Maximum|Minimum)Size methods in Java Swing?","slug":"should-i-avoid-the-use-of-set(preferredormaximumorminimum)size-methods-in-java-swing-1657384628399"},{"title":"AsyncTask Android example","slug":"asynctask-android-example-1657388127898"},{"title":"How to count the number of set bits in a 32-bit integer?","slug":"how-to-count-the-number-of-set-bits-in-a-32-bit-integer-1657388437370"},{"title":"What is a clearfix?","slug":"what-is-a-clearfix-1657387337825"},{"title":"How to include a PHP variable inside a MySQL statement","slug":"how-to-include-a-php-variable-inside-a-mysql-statement-1657387669365"},{"title":"Why is โwhile( !feof(file) )โ always wrong?","slug":"why-is-\"while(-!feof(file)-)\"-always-wrong-1657384367349"},{"title":"How do you use a variable in a regular expression?","slug":"how-do-you-use-a-variable-in-a-regular-expression-1657387939007"},{"title":"How do we control web page caching, across all browsers?","slug":"how-do-we-control-web-page-caching-across-all-browsers-1657387529059"},{"title":"When does SQLiteOpenHelper onCreate() / onUpgrade() run?","slug":"when-does-sqliteopenhelper-oncreate()-onupgrade()-run-1657384883864"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"do-i-cast-the-result-of-malloc-1657384271583"},"buildId":"BnkbnjkWYxefPXjTJLVVv","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>