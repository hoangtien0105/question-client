{"pageProps":{"data":{"answer":["\n&lt;p&gt;Structs are value types which means they are copied when they are passed around. &lt;/p&gt;\n\n&lt;p&gt;So if you change a copy you are changing only that copy, not the original and not any other copies which might be around.&lt;/p&gt;\n\n&lt;p&gt;If your struct is immutable then all automatic copies resulting from being passed by value will be the same.&lt;/p&gt;\n\n&lt;p&gt;If you want to change it you have to consciously do it by creating a new instance of the struct with the modified data. (not a copy)&lt;/p&gt;\n    ","\n&lt;p&gt;Where to start ;-p&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/archive/blogs/ericlippert/mutating-readonly-structs&quot; rel=&quot;noreferrer&quot;&gt;Eric Lippert&apos;s blog&lt;/a&gt; is always good for a quote:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;This is yet another reason why mutable\n  value types are evil. Try to always\n  make value types immutable.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;First, you tend to lose changes quite easily... for example, getting things out of a list:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;Foo foo = list[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;];\nfoo.Name = &lt;span class=&quot;hljs-string&quot;&gt;&quot;abc&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;what did that change? Nothing useful...&lt;/p&gt;\n\n&lt;p&gt;The same with properties:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;myObj.SomeProperty.Size = &lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// the compiler spots this one&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;forcing you to do:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;Bar bar = myObj.SomeProperty;\nbar.Size = &lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt;;\nmyObj.SomeProperty = bar;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;less critically, there is a size issue; mutable objects &lt;strong&gt;tend&lt;/strong&gt; to have multiple properties; yet if you have a struct with two &lt;code&gt;int&lt;/code&gt;s, a &lt;code&gt;string&lt;/code&gt;, a &lt;code&gt;DateTime&lt;/code&gt; and a &lt;code&gt;bool&lt;/code&gt;, you can very quickly burn through a lot of memory. With a class, multiple callers can share a reference to the same instance (references are small).&lt;/p&gt;\n    ","\n&lt;p&gt;I wouldn&apos;t say &lt;em&gt;evil&lt;/em&gt; but mutability is often a sign of overeagerness on the part of the programmer to provide a maximum of functionality. In reality, this is often not needed and that, in turn, makes the interface smaller, easier to use and harder to use wrong (= more robust).&lt;/p&gt;\n\n&lt;p&gt;One example of this is read/write and write/write conflicts in race conditions. These simply can&apos;t occur in immutable structures, since a write is not a valid operation.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/406760/whats-your-most-controversial-programming-opinion/407007#407007&quot;&gt;Also, I claim that &lt;strong&gt;mutability is almost never actually needed&lt;/strong&gt;&lt;/a&gt;, the programmer just &lt;em&gt;thinks&lt;/em&gt; that it &lt;em&gt;might&lt;/em&gt; be in the future. For example, it simply doesn&apos;t make sense to change a date. Rather, create a new date based off the old one. This is a cheap operation, so performance is not a consideration.&lt;/p&gt;\n    ","\n&lt;p&gt;Mutable structs are not evil. &lt;/p&gt;\n\n&lt;p&gt;They are absolutely necessary in high performance circumstances. For example when cache lines and or garbage collection become a bottleneck.&lt;/p&gt;\n\n&lt;p&gt;I would not call the use of a immutable struct in these perfectly valid use-cases &quot;evil&quot;.&lt;/p&gt;\n\n&lt;p&gt;I can see the point that C#&apos;s syntax does not help to distinguish the access of a member of a value type or of a reference type, so I am all for &lt;em&gt;preferring&lt;/em&gt; immutable structs, that enforce immutability, over mutable structs.&lt;/p&gt;\n\n&lt;p&gt;However, instead of simply labelling immutable structs as &quot;evil&quot;, I would advise to embrace the language and advocate more helpful and constructive rule of thumbs.&lt;/p&gt;\n\n&lt;p&gt;For example: &lt;em&gt;&quot;structs are value types, which are copied by default. you need a reference if you don&apos;t want to copy them&quot;&lt;/em&gt; or\n&lt;em&gt;&quot;try to work with readonly structs first&quot;&lt;/em&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;b&gt;Structs with public mutable fields or properties are not evil.&lt;/b&gt;&lt;/p&gt;\n\n&lt;p&gt;Struct methods (as distinct from property setters) which mutate &quot;this&quot; are somewhat evil, only because .net doesn&apos;t provide a means of distinguishing them from methods which do not.  Struct methods that do not mutate &quot;this&quot; should be invokable even on read-only structs without any need for defensive copying.  Methods which do mutate &quot;this&quot; should not be invokable at all on read-only structs.  Since .net doesn&apos;t want to forbid struct methods that don&apos;t modify &quot;this&quot; from being invoked on read-only structs, but doesn&apos;t want to allow read-only structs to be mutated, it defensively copies structs in read-only contexts, arguably getting the worst of both worlds.&lt;/p&gt;\n\n&lt;p&gt;Despite the problems with the handling of self-mutating methods in read-only contexts, however, mutable structs often offer semantics far superior to mutable class types.  Consider the following three method signatures:&lt;/p&gt;\n\n&lt;pre&gt;struct PointyStruct {public int x,y,z;};\nclass PointyClass {public int x,y,z;};\n\nvoid Method1(PointyStruct foo);\nvoid Method2(ref PointyStruct foo);\nvoid Method3(PointyClass foo);\n&lt;/pre&gt;\n\n&lt;p&gt;For each method, answer the following questions:&lt;/p&gt;\n\n&lt;ol&gt;&lt;li&gt;Assuming the method doesn&apos;t use any &quot;unsafe&quot; code, might it modify foo?\n&lt;/li&gt;&lt;li&gt;If no outside references to &apos;foo&apos; exist before the method is called, could an outside reference exist after?\n&lt;/li&gt;&lt;/ol&gt;\n\n&lt;p&gt;&lt;sub&gt;Answers:&lt;/sub&gt;&lt;/p&gt;\n\n&lt;blockquote class=&quot;spoiler&quot; data-spoiler=&quot;Reveal spoiler&quot;&gt;\n  &lt;p&gt; Question 1:&lt;br&gt;\n  &lt;code&gt;Method1()&lt;/code&gt;: no &lt;em&gt;(clear intent)&lt;/em&gt;&lt;br&gt;\n  &lt;code&gt;Method2()&lt;/code&gt;: yes &lt;em&gt;(clear intent)&lt;/em&gt;&lt;br&gt;\n  &lt;code&gt;Method3()&lt;/code&gt;: yes &lt;em&gt;(uncertain intent)&lt;/em&gt;&lt;br&gt;\n Question 2:&lt;br&gt;\n  &lt;code&gt;Method1()&lt;/code&gt;: no&lt;br&gt;\n  &lt;code&gt;Method2()&lt;/code&gt;: no &lt;em&gt;(unless unsafe)&lt;/em&gt;&lt;br&gt;\n  &lt;code&gt;Method3()&lt;/code&gt;: yes&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Method1 can&apos;t modify foo, and never gets a reference.  Method2 gets a short-lived reference to foo, which it can use modify the fields of foo any number of times, in any order, until it returns, but it can&apos;t persist that reference.  Before Method2 returns, unless it uses unsafe code, any and all copies that might have been made of its &apos;foo&apos; reference will have disappeared.  Method3, unlike Method2, gets a promiscuously-sharable reference to foo, and there&apos;s no telling what it might do with it.  It might not change foo at all, it might change foo and then return, or it might give a reference to foo to another thread which might mutate it in some arbitrary way at some arbitrary future time.  The only way to limit what Method3 might do to a mutable class object passed into it would be to encapsulate the mutable object into a read-only wrapper, which is ugly and cumbersome.&lt;/p&gt;\n\n&lt;p&gt;Arrays of structures offer wonderful semantics.  Given RectArray[500] of type Rectangle, it&apos;s clear and obvious how to e.g. copy element 123 to element 456 and then some time later set the width of element 123 to 555, without disturbing element 456.  &quot;RectArray[432] = RectArray[321]; ...; RectArray[123].Width = 555;&quot;.  Knowing that Rectangle is a struct with an integer field called Width will tell one all one needs to know about the above statements.&lt;/p&gt;\n\n&lt;p&gt;Now suppose RectClass was a class with the same fields as Rectangle and one wanted to do the same operations on a RectClassArray[500] of type RectClass.  Perhaps the array is supposed to hold 500 pre-initialized immutable references to mutable RectClass objects.  in that case, the proper code would be something like &quot;RectClassArray[321].SetBounds(RectClassArray[456]); ...; RectClassArray[321].X = 555;&quot;.  Perhaps the array is assumed to hold instances that aren&apos;t going to change, so the proper code would be more like &quot;RectClassArray[321] = RectClassArray[456]; ...; RectClassArray[321] = New RectClass(RectClassArray[321]); RectClassArray[321].X = 555;&quot;  To know what one is supposed to do, one would have to know a lot more both about RectClass (e.g. does it support a copy constructor, a copy-from method, etc.) and the intended usage of the array.  Nowhere near as clean as using a struct.&lt;/p&gt;\n\n&lt;p&gt;To be sure, there is unfortunately no nice way for any container class other than an array to offer the clean semantics of a struct array.  The best one could do, if one wanted a collection to be indexed with e.g. a string, would probably be to offer a generic &quot;ActOnItem&quot; method which would accept a string for the index, a generic parameter, and a delegate which would be passed by reference both the generic parameter and the collection item.  That would allow nearly the same semantics as struct arrays, but unless the vb.net and C# people can be pursuaded to offer a nice syntax, the code is going to be clunky-looking even if it is reasonably performance (passing a generic parameter would allow for use of a static delegate and would avoid any need to create any temporary class instances).&lt;/p&gt;\n\n&lt;p&gt;Personally, I&apos;m peeved at the hatred Eric Lippert et al. spew regarding mutable value types.  They offer much cleaner semantics than the promiscuous reference types that are used all over the place.  Despite some of the limitations with .net&apos;s support for value types, there are many cases where mutable value types are a better fit than any other kind of entity.&lt;/p&gt;\n    ","\n&lt;p&gt;There are a couple other corner cases that could lead to unpredictable behavior from the programmer&apos;s point of view.&lt;/p&gt;\n\n&lt;h1&gt;Immutable value types and readonly fields&lt;/h1&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;// Simple mutable structure. &lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Method IncrementI mutates current state.&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; Mutable\n    {\n        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Mutable&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; i&lt;/span&gt;) : &lt;span class=&quot;hljs-title&quot;&gt;this&lt;/span&gt;()&lt;/span&gt; \n        {\n            I = i;\n        }\n\n        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;IncrementI&lt;/span&gt;()&lt;/span&gt; { I++; }\n\n        &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; I { &lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt;; }\n    }\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Simple class that contains Mutable structure&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// as readonly field&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;SomeClass&lt;/span&gt; \n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;readonly&lt;/span&gt; Mutable mutable = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Mutable(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;);\n    }\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Simple class that contains Mutable structure&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// as ordinary (non-readonly) field&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;AnotherClass&lt;/span&gt; \n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Mutable mutable = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Mutable(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;);\n    }\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Program&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Main&lt;/span&gt;()&lt;/span&gt;\n        {\n            &lt;span class=&quot;hljs-comment&quot;&gt;// Case 1. Mutable readonly field&lt;/span&gt;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; someClass = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; SomeClass();\n            someClass.mutable.IncrementI();\n            &lt;span class=&quot;hljs-comment&quot;&gt;// still 5, not 6, because SomeClass.mutable field is readonly&lt;/span&gt;\n            &lt;span class=&quot;hljs-comment&quot;&gt;// and compiler creates temporary copy every time when you trying to&lt;/span&gt;\n            &lt;span class=&quot;hljs-comment&quot;&gt;// access this field&lt;/span&gt;\n            Console.WriteLine(someClass.mutable.I);\n\n            &lt;span class=&quot;hljs-comment&quot;&gt;// Case 2. Mutable ordinary field&lt;/span&gt;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; anotherClass = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; AnotherClass();\n            anotherClass.mutable.IncrementI();\n\n            &lt;span class=&quot;hljs-comment&quot;&gt;// Prints 6, because AnotherClass.mutable field is not readonly&lt;/span&gt;\n            Console.WriteLine(anotherClass.mutable.I);\n        }\n    }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h1&gt;Mutable value types and array&lt;/h1&gt;\n\n&lt;p&gt;Suppose we have an array of our &lt;code&gt;Mutable&lt;/code&gt; struct and we&apos;re calling the &lt;code&gt;IncrementI&lt;/code&gt; method for the first element of that array. What behavior are you expecting from this call? Should it change the array&apos;s value or only a copy?&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;    Mutable[] arrayOfMutables = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Mutable[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;];\n    arrayOfMutables[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Mutable(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;);\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Now we actually accessing reference to the first element&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// without making any additional copy&lt;/span&gt;\n    arrayOfMutables[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;].IncrementI();\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Prints 6!!&lt;/span&gt;\n    Console.WriteLine(arrayOfMutables[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;].I);\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Every array implements IList&amp;lt;T&amp;gt; interface&lt;/span&gt;\n    IList&amp;lt;Mutable&amp;gt; listOfMutables = arrayOfMutables;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// But accessing values through this interface lead&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// to different behavior: IList indexer returns a copy&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// instead of an managed reference&lt;/span&gt;\n    listOfMutables[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;].IncrementI(); &lt;span class=&quot;hljs-comment&quot;&gt;// Should change I to 7&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Nope! we still have 6, because previous line of code&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// mutate a copy instead of a list value&lt;/span&gt;\n    Console.WriteLine(listOfMutables[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;].I);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So, mutable structs are not evil as long as you and the rest of the team clearly understand what you are doing. But there are too many corner cases when the program behavior would be different from what&apos;s expected, that could lead to subtle hard to produce and hard to understand errors.&lt;/p&gt;\n    ","\n&lt;p&gt;Value types basically represents immutable concepts. Fx, it makes no sense to have a mathematical value such as an integer, vector etc. and then be able to modify it. That would be like redefining the meaning of a value. Instead of changing a value type, it makes more sense to assign another unique value. Think about the fact that value types are compared by comparing all the values of its properties. The point is that if the properties are the same then it is the same universal representation of that value.&lt;/p&gt;\n\n&lt;p&gt;As Konrad mentions it doesn&apos;t make sense to change a date either, as the value represents that unique point in time and not an instance of a time object which has any state or context-dependency.&lt;/p&gt;\n\n&lt;p&gt;Hopes this makes any sense to you. It is more about the concept you try to capture with value types than practical details, to be sure. &lt;/p&gt;\n    ","\n&lt;p&gt;If you have ever programmed in a language like C/C++, structs are fine to use as mutable. Just pass them with ref, around and there is nothing that can go wrong. The only problem I find are the restrictions of the C# compiler and that, in some cases, I am unable to force the stupid thing to use a reference to the struct, instead of a Copy(like when a struct is part of a C# class).&lt;/p&gt;\n\n&lt;p&gt;So, mutable structs are not evil, C# has &lt;em&gt;made&lt;/em&gt; them evil. I use mutable structs in C++ all the time and they are very convenient and intuitive. In contrast, C# has made me to completely abandon structs as members of classes because of the way they handle objects. Their convenience has cost us ours.&lt;/p&gt;\n    ","\n&lt;p&gt;If you stick to what structs are intended for (in C#, Visual Basic 6, Pascal/Delphi, C++ struct type (or classes) when they are not used as pointers), you will find that a structure is not more than a &lt;em&gt;compound variable&lt;/em&gt;. This means: you will treat them as a packed set of variables, under a common name (a record variable you reference members from).&lt;/p&gt;\n\n&lt;p&gt;I know that would confuse a lot of people deeply used to OOP, but that&apos;s not enough reason to say such things are inherently evil, if used correctly. Some structures are inmutable as they intend (this is the case of Python&apos;s &lt;code&gt;namedtuple&lt;/code&gt;), but it is another paradigm to consider.&lt;/p&gt;\n\n&lt;p&gt;Yes: structs involve a lot of memory, but it will not be precisely more memory by doing:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;point.x = point.x + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;compared to:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;point = Point(point.x + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, point.y)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The memory consumption will be at least the same, or even more in the inmutable case (although that case would be temporary, for the current stack, depending on the language).&lt;/p&gt;\n\n&lt;p&gt;But, finally, structures are &lt;em&gt;structures&lt;/em&gt;, not objects. In POO, the main property of an object is their &lt;em&gt;identity&lt;/em&gt;, which most of the times is not more than its memory address. Struct stands for data structure (not a proper object, and so they don&apos;t have identity anyhow), and data can be modified. In other languages, &lt;em&gt;record&lt;/em&gt; (instead of &lt;em&gt;struct&lt;/em&gt;, as is the case for Pascal) is the word and holds the same purpose: just a data record variable, intended to be read from files, modified, and dumped into files (that is the main use and, in many languages, you can even define data alignment in the record, while that&apos;s not necessarily the case for properly called Objects).&lt;/p&gt;\n\n&lt;p&gt;Want a good example? Structs are used to read files easily. Python has &lt;a href=&quot;https://docs.python.org/2/library/struct.html&quot;&gt;this library&lt;/a&gt; because, since it is object-oriented and has no support for structs, it had to implement it in another way, which is somewhat ugly. Languages implementing structs have that feature... built-in. Try reading a bitmap header with an appropriate struct in languages like Pascal or C. It will be easy (if the struct is properly built and aligned; in Pascal you would not use a record-based access but functions to read arbitrary binary data). So, for files and direct (local) memory access, structs are better than objects. As for today, we&apos;re used to JSON and XML, and so we forget the use of binary files (and as a side effect, the use of structs). But yes: they exist, and have a purpose.&lt;/p&gt;\n\n&lt;p&gt;They are not evil. Just use them for the right purpose.&lt;/p&gt;\n\n&lt;p&gt;If you think in terms of hammers, you will want to treat screws as nails, to find screws are harder to plunge in the wall, and it will be screws&apos; fault, and they will be the evil ones.&lt;/p&gt;\n    ","\n&lt;p&gt;Imagine you have an array of 1,000,000 structs. Each struct representing an equity with stuff like bid_price, offer_price (perhaps decimals) and so on, this is created by C#/VB.&lt;/p&gt;\n\n&lt;p&gt;Imagine that array is created in a block of memory allocated in the unmanaged heap so that some other native code thread is able to concurrently access the array (perhaps some high-perf code doing math).&lt;/p&gt;\n\n&lt;p&gt;Imagine the C#/VB code is listening to a market feed of price changes, that code may have to access some element of the array (for whichever security) and then modify some price field(s).&lt;/p&gt;\n\n&lt;p&gt;Imagine this is being done tens or even hundreds of thousands of times per second.&lt;/p&gt;\n\n&lt;p&gt;Well lets face facts, in this case we really do want these structs to be mutable, they need to be because they are being shared by some other native code so creating copies isn&apos;t gonna help; they need to be because making a copy of some 120 byte struct at these rates is lunacy, especially when an update may actually impact just a byte or two.&lt;/p&gt;\n\n&lt;p&gt;Hugo&lt;/p&gt;\n    ","\n&lt;p&gt;When something can be mutated, it gains a sense of identity.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; Person {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; name; &lt;span class=&quot;hljs-comment&quot;&gt;// mutable&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Point position = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Point(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;// mutable&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Person&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; name, Point position&lt;/span&gt;)&lt;/span&gt; { ... }\n}\n\nPerson eric = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Eric Lippert&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Point(&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;));\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Because &lt;code&gt;Person&lt;/code&gt; is mutable, it&apos;s more natural to think about &lt;em&gt;changing Eric&apos;s position&lt;/em&gt; than &lt;em&gt;cloning Eric, moving the clone, and destroying the original&lt;/em&gt;. Both operations would succeed in changing the contents of &lt;code&gt;eric.position&lt;/code&gt;, but one is more intuitive than the other. Likewise, it&apos;s more intuitive to pass Eric around (as a reference) for methods to modify him. Giving a method a clone of Eric is almost always going to be surprising. Anyone wanting to mutate &lt;code&gt;Person&lt;/code&gt; must remember to ask for a reference to &lt;code&gt;Person&lt;/code&gt; or they&apos;ll be doing the wrong thing.&lt;/p&gt;\n\n&lt;p&gt;If you make the type immutable, the problem goes away; if I can&apos;t modify &lt;code&gt;eric&lt;/code&gt;, it makes no difference to me whether I receive &lt;code&gt;eric&lt;/code&gt; or a clone of &lt;code&gt;eric&lt;/code&gt;. More generally, a type is safe to pass by value if all of its observable state is held in members that are either:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;immutable&lt;/li&gt;\n&lt;li&gt;reference types&lt;/li&gt;\n&lt;li&gt;safe to pass by value&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;If those conditions are met then a mutable value type behaves like a reference type because a shallow copy will still allow the receiver to modify the original data.&lt;/p&gt;\n\n&lt;p&gt;The intuitiveness of an immutable &lt;code&gt;Person&lt;/code&gt; depends on what you&apos;re trying to do though. If &lt;code&gt;Person&lt;/code&gt; just represents a &lt;em&gt;set of data&lt;/em&gt; about a person, there&apos;s nothing unintuitive about it; &lt;code&gt;Person&lt;/code&gt; variables truly represent abstract &lt;em&gt;values&lt;/em&gt;, not objects. (In that case, it&apos;d probably be more appropriate to rename it to &lt;code&gt;PersonData&lt;/code&gt;.) If &lt;code&gt;Person&lt;/code&gt; is actually modeling a person itself, the idea of constantly creating and moving clones is silly even if you&apos;ve avoided the pitfall of thinking you&apos;re modifying the original. In that case it&apos;d probably be more natural to simply make &lt;code&gt;Person&lt;/code&gt; a reference type (that is, a class.) &lt;/p&gt;\n\n&lt;p&gt;Granted, as functional programming has taught us there are benefits to making &lt;em&gt;everything&lt;/em&gt; immutable (no one can secretly hold on to a reference to &lt;code&gt;eric&lt;/code&gt; and mutate him), but since that&apos;s not idiomatic in OOP it&apos;s still going to be unintuitive to anyone else working with your code.&lt;/p&gt;\n    ","\n&lt;p&gt;It doesnt have anything to do with structs (and not with C#, either) but in Java you might get problems with mutable objects when they are e.g. keys in a hash map. If you change them after adding them to a map and it changes its &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#hashCode()&quot; rel=&quot;noreferrer&quot;&gt;hash code&lt;/a&gt;, evil things might happen.&lt;/p&gt;\n    ","\n&lt;p&gt;There are many advantages and disadvantages to mutable data.  The million-dollar disadvantage is aliasing.  If the same value is being used in multiple places, and one of them changes it, then it will appear to have magically changed to the other places that are using it.  This is related to, but not identical with, race conditions.&lt;/p&gt;\n\n&lt;p&gt;The million-dollar advantage is modularity, sometimes.  Mutable state can allow you to hide changing information from code that doesn&apos;t need to know about it.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://dspace.mit.edu/handle/1721.1/6094&quot; rel=&quot;noreferrer&quot;&gt;The Art of the Interpreter&lt;/a&gt; goes into these trade offs in some detail, and gives some examples.&lt;/p&gt;\n    ","\n&lt;p&gt;Personally when I look at code the following looks pretty clunky to me:&lt;/p&gt;\n\n&lt;p&gt;data.value.set ( data.value.get () + 1 ) ;&lt;/p&gt;\n\n&lt;p&gt;rather than simply&lt;/p&gt;\n\n&lt;p&gt;data.value++ ; or data.value = data.value + 1 ;&lt;/p&gt;\n\n&lt;p&gt;Data encapsulation is useful when passing a class around and you want to ensure the value is modified in a controlled fashion.  However when you have public set and get functions that do little more than set the value to what ever is passed in, how is this an improvement over simply passing a public data structure around?&lt;/p&gt;\n\n&lt;p&gt;When I create a private structure inside a class, I created that structure to organize a set of variables into one group.  I want to be able to modify that structure within the class scope, not get copies of that structure and create new instances.&lt;/p&gt;\n\n&lt;p&gt;To me this prevents a valid use of structures being used to organize public variables, if I wanted access control I&apos;d use a class.&lt;/p&gt;\n    ","\n&lt;p&gt;There are several issues with Mr. Eric Lippert&apos;s example. It is contrived to illustrate the point that structs are copied and how that could be a problem if you are not careful. Looking at the example I see it as a result of a bad programming habit and not really a problem with either struct or the class. &lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;A struct is supposed to have only public members and should not require any encapsulation. If it does then it really should be a type/class. You really do not need two constructs to say the same thing.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;If you have class enclosing a struct, you would call a method in the class to mutate the member struct. This is what I would do as a good programming habit.&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;A proper implementation would be as follows.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; Mutable {\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; x;\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Test&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; Mutable m = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Mutable();\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;mutate&lt;/span&gt;()&lt;/span&gt;\n    { \n        m.x = m.x + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; m.x;\n    }\n  }\n  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Main&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;[] args&lt;/span&gt;)&lt;/span&gt; {\n        Test t = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Test();\n        System.Console.WriteLine(t.mutate());\n        System.Console.WriteLine(t.mutate());\n        System.Console.WriteLine(t.mutate());\n    }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It looks like it is an issue with programming habit as opposed to an issue with struct itself. Structs are supposed to be mutable, that is the idea and intent.&lt;/p&gt;\n\n&lt;p&gt;The result of the changes voila behaves as expected:&lt;/p&gt;\n\n&lt;p&gt;1\n2\n3\nPress any key to continue . . .&lt;/p&gt;\n    ","\n&lt;p&gt;I don&apos;t believe they&apos;re evil if used correctly. I wouldn&apos;t put it in my production code, but I would for something like structured unit testing mocks, where the lifespan of a struct is relatively small.&lt;/p&gt;\n\n&lt;p&gt;Using the Eric example, perhaps you want to create a second instance of that Eric, but make adjustments, as that&apos;s the nature of your test (ie duplication, then modifying). It doesn&apos;t matter what happens with the first instance of Eric if we&apos;re just using Eric2 for the remainder of the test script, unless you&apos;re planning on using him as a test comparison.&lt;/p&gt;\n\n&lt;p&gt;This would be mostly useful for testing or modifying legacy code that shallow defines a particular object (the point of structs), but by having an immutable struct, this prevents it&apos;s usage annoyingly.&lt;/p&gt;\n    "],"comment":["\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Claiming mutable structs are evil is like claiming mutable &lt;code&gt;int&lt;/code&gt;s, &lt;code&gt;bool&lt;/code&gt;s, and all other value types are evil.  There are cases for mutability and for immutability.  Those cases hinge on the role the data plays, not the type of memory allocation/sharing.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/177525/slipp-d-thompson&quot; title=&quot;30,765 reputation&quot; class=&quot;comment-user&quot;&gt;Slipp D. Thompson&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment38602719_441309&quot;&gt;&lt;span title=&quot;2014-07-21 05:05:14Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jul 21, 2014 at 5:05&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 2 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@slipp &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;bool&lt;/code&gt; are &lt;i&gt;not&lt;/i&gt; mutable..&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/369/blorgbeard&quot; title=&quot;97,589 reputation&quot; class=&quot;comment-user&quot;&gt;Blorgbeard&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment46003501_441309&quot;&gt;&lt;span title=&quot;2015-03-05 04:04:49Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 5, 2015 at 4:04&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt; &lt;code&gt;.&lt;/code&gt;-syntax, making operations with ref-typed data and value-typed data look the same even though they&apos;re distinctly different.  This is a fault of C#&apos;s properties, not structs some languages offer an alternate &lt;code&gt;a[V][X] = 3.14&lt;/code&gt; syntax for mutating in-place.  In C#, you&apos;d do better to offer struct-member mutator methods like MutateV(Action&amp;lt;ref Vector2&amp;gt; mutator)` and use it like &lt;code&gt;a.MutateV((v) =&amp;gt; { v.X = 3; })&lt;/code&gt; &lt;i&gt;(example is over-simplified because of the limitations C# has regarding the &lt;code&gt;ref&lt;/code&gt; keyword, but with some workarounds should be possible)&lt;/i&gt;.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/177525/slipp-d-thompson&quot; title=&quot;30,765 reputation&quot; class=&quot;comment-user&quot;&gt;Slipp D. Thompson&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment48239374_441309&quot;&gt;&lt;span title=&quot;2015-05-05 19:58:31Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;May 5, 2015 at 19:58&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Slipp Well, I think exactly opposite about these kind of structs. Why do you think that structs that are already implemented in .NET library, like DateTime or TimeSpan (so similar ones) are immutable? Maybe it could be useful to change only one member of such struct&apos;s var, but it&apos;s just too inconvenient, leads to too many problems. Actually you are wrong about what does the processor calc, since C# does not compile to assembler, it compiles to IL. In IL (providing we already have the variable named &lt;code&gt;x&lt;/code&gt;) this single operation is 4 instructions: &lt;code&gt;ldloc.0&lt;/code&gt; (loads the 0-index variable into...&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1425153/sushi271&quot; title=&quot;534 reputation&quot; class=&quot;comment-user&quot;&gt;Sushi271&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment48256708_441309&quot;&gt;&lt;span title=&quot;2015-05-06 08:28:24Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;May 6, 2015 at 8:28&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;... type. &lt;code&gt;T&lt;/code&gt; is type. Ref is just a keyword that makes variable being passed to a method itself, not a copy of it. It also has sense for the reference types, since we can change &lt;b&gt;the variable&lt;/b&gt;, i.e. the reference outside the method will point to other object after being changed within the method. Since &lt;code&gt;ref T&lt;/code&gt; is not a type, but fashion of passing a method parameter, you cannot put it into &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;, cause only types can be put there. So it&apos;s just incorrect. Maybe it would be convenient to do so, maybe the C# team could make this for some new version, but right now they&apos;re working on some...&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1425153/sushi271&quot; title=&quot;534 reputation&quot; class=&quot;comment-user&quot;&gt;Sushi271&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment48257433_441309&quot;&gt;&lt;span title=&quot;2015-05-06 08:46:59Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;May 6, 2015 at 8:46&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;&quot;If your struct is immutable then all copies will be the same.&quot; No, it means that you have to consciously make a copy if you want a different value. It means you won&apos;t get caught modifying a copy thinking you are modifying the original.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/24231/lucas&quot; title=&quot;16,994 reputation&quot; class=&quot;comment-user&quot;&gt;Lucas&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment676958_441357&quot;&gt;&lt;span title=&quot;2009-05-15 15:43:30Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;May 15, 2009 at 15:43&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Lucas I think you are talking about a different kind of copy I am talking about the automatic copies made as a result of being passed by value, Your &apos;consciously made copy&apos; is different on purpose you didn&apos;t make it by mistake and its not really a copy its a deliberate new instants containing different data.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/78561/trampster&quot; title=&quot;8,074 reputation&quot; class=&quot;comment-user&quot;&gt;trampster&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment2968925_441357&quot;&gt;&lt;span title=&quot;2010-05-26 21:34:58Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;May 26, 2010 at 21:34&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Your edit (16 months later) makes that a little clearer. I still stand by &quot;(immutable struct) means you won&apos;t get caught modifying a copy thinking you are modifying the original&quot;, though.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/24231/lucas&quot; title=&quot;16,994 reputation&quot; class=&quot;comment-user&quot;&gt;Lucas&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment2974835_441357&quot;&gt;&lt;span title=&quot;2010-05-27 15:00:44Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;May 27, 2010 at 15:00&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Lucas: The danger of making a copy of a struct, modifying it, and somehow thinking one is modifying the original (when the fact that one is writing a struct field makes &lt;i&gt;self-apparent&lt;/i&gt; the fact that one is only writing one&apos;s copy) seems pretty small compared to the danger that someone who holds a class object as a means of holding the information contained therein will mutate the object to update its own information and in the process corrupt the information held by some other object.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment9690331_441357&quot;&gt;&lt;span title=&quot;2011-10-28 16:11:28Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Oct 28, 2011 at 16:11&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;The 3rd paragraph sounds wrong or unclear at best. If your struct is immutable then you simply won&apos;t be able to modify its fields or the fields of any copies made. &lt;i&gt;&quot;If you want to change it you have to...&quot;&lt;/i&gt; that&apos;s misleading too, you can&apos;t change &lt;b&gt;it&lt;/b&gt; &lt;i&gt;ever&lt;/i&gt;, neither consciously nor unconsciously. Creating a new instance which the data you want has nothing to do with the original copy other than having the same data structure.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/68080/saeb-amini&quot; title=&quot;21,271 reputation&quot; class=&quot;comment-user&quot;&gt;Saeb Amini&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment62258181_441357&quot;&gt;&lt;span title=&quot;2016-05-22 10:48:51Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;May 22, 2016 at 10:48&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Well yes but the compiler is just stupid that way. Not to allow assignment to property-struct members was IMHO a stupid design decision, because it &lt;i&gt;is&lt;/i&gt; allowed for &lt;code&gt;++&lt;/code&gt; operator. In this case, the compiler just writes the explicit assignment itself instead of hustling the programmer.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1968/konrad-rudolph&quot; title=&quot;508,410 reputation&quot; class=&quot;comment-user&quot;&gt;Konrad Rudolph&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment264132_441323&quot;&gt;&lt;span title=&quot;2009-01-14 08:08:02Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Jan 14, 2009 at 8:08&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Konrad: myObj.SomeProperty.Size = 22 would modify a COPY of myObj.SomeProperty. The compiler is saving you from an obvious bug. And it is NOT allowed for ++.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/24231/lucas&quot; title=&quot;16,994 reputation&quot; class=&quot;comment-user&quot;&gt;Lucas&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment676927_441323&quot;&gt;&lt;span title=&quot;2009-05-15 15:38:12Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;May 15, 2009 at 15:38&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Konrad - with one less indirection it should work; it is the &quot;mutating a value of something that only exists as a transient value on the stack and which is about to evaporate into nothingness&quot; which is the case that is blocked.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/23354/marc-gravell&quot; title=&quot;980,686 reputation&quot; class=&quot;comment-user&quot;&gt;Marc Gravell&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment3965774_441323&quot;&gt;&lt;span title=&quot;2010-09-20 11:13:28Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Sep 20, 2010 at 11:13&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Marc Gravell: In the former piece of code, you end up with a &quot;Foo&quot; whose name is &quot;abc&quot; and whose other attributes are those of List[0], without disturbing List[0].  If Foo were a class, it would be necessary to clone it and then change the copy.  To my mind, the big problem with the value-type vs class distinction is the use of the &quot;.&quot; operator for two purposes.  If I had my druthers, classes could support both &quot;.&quot; and &quot;-&amp;gt;&quot; for methods and properties, but the normal semantics for &quot;.&quot; properties would be to create a new instance with the appropriate field modified.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment4152593_441323&quot;&gt;&lt;span title=&quot;2010-10-09 20:52:08Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Oct 9, 2010 at 20:52&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Backwards_Dave you might be comparing a different scenario, then; either &lt;code&gt;SomeProperty&lt;/code&gt; is not actually a property (perhaps it is a field?), or the &lt;i&gt;type&lt;/i&gt; of &lt;code&gt;SomeProperty&lt;/code&gt; is not actually a &lt;code&gt;struct&lt;/code&gt;. Here&apos;s a minimal repro that shows CS1612: &lt;a href=&quot;https://sharplab.io/#v2:EYLgtghgzgLgpgJwDQxASwDYB8ACAGAAhwEYBuAWACgcBmIgJgIGECBvKgzougZQHswcHjAQBXAMYwC/QQAUEfAA6IYATzYBzODFJRtpAL4cutIgBYCAWQAUASjbGuXGXHlKVqgHQ80ALzgEALwE9HgUlE5GlFFUprBiktICQiISUuwRJnRoAHZSPv7hBkA=&quot; rel=&quot;nofollow noreferrer&quot;&gt;sharplab.io/&lt;/a&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/23354/marc-gravell&quot; title=&quot;980,686 reputation&quot; class=&quot;comment-user&quot;&gt;Marc Gravell&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment86269707_441323&quot;&gt;&lt;span title=&quot;2018-04-03 13:30:13Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 3, 2018 at 13:30&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Eric Lippert says they are... see my answer.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/23354/marc-gravell&quot; title=&quot;980,686 reputation&quot; class=&quot;comment-user&quot;&gt;Marc Gravell&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment263318_441337&quot;&gt;&lt;span title=&quot;2009-01-13 23:37:58Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Jan 13, 2009 at 23:37&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Much as I respect Eric Lippert he isn&apos;t God (or at least not yet). The blog post you link to and your post above are reasonable arguments for making structs immutable as matter of course but they are actually very weak as arguments for &lt;b&gt;never&lt;/b&gt; using mutable structs. This post, however, is a +1.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/12845/stephen-martin&quot; title=&quot;9,296 reputation&quot; class=&quot;comment-user&quot;&gt;Stephen Martin&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment263534_441337&quot;&gt;&lt;span title=&quot;2009-01-14 01:12:06Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Jan 14, 2009 at 1:12&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Developing in C#, you usually need mutability ever now and then - especially with your Business Model, where you want streaming etc. to work smoothly with existing solutions. I wrote an article on how to work with mutable AND immutable data, solving most issues around mutability (I hope): &lt;a href=&quot;http://rickyhelgesson.wordpress.com/2012/07/17/mutable-or-immutable-in-a-parallel-world/&quot; rel=&quot;nofollow noreferrer&quot;&gt;rickyhelgesson.wordpress.com/2012/07/17/&lt;/a&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/947853/ricky-helgesson&quot; title=&quot;3,586 reputation&quot; class=&quot;comment-user&quot;&gt;Ricky Helgesson&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment15573803_441337&quot;&gt;&lt;span title=&quot;2012-07-31 07:42:51Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jul 31, 2012 at 7:42&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@StephenMartin: Structs which encapsulate a single value often should be immutable, but structs are by far the best medium for encapsulating fixed sets of independent but related variables (like the X and Y coordinates of a point) which have no &quot;identity&quot; as a group.  Structs which are used for &lt;i&gt;that&lt;/i&gt; purpose should generally expose their variables as public fields.  I would consider the notion that it&apos;s more appropriate to use a class than a struct for such purposes to be just plain wrong.  Immutable classes are often less efficient, and mutable classes often have dreadful semantics.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment24440393_441337&quot;&gt;&lt;span title=&quot;2013-06-04 23:49:59Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 4, 2013 at 23:49&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@StephenMartin: Consider, for example, a method or property that is supposed to returns the six &lt;code&gt;float&lt;/code&gt; components of a graphics transform.  If such a method returns an exposed-field struct with six components, it&apos;s obvious that modifying the fields of the struct won&apos;t modify the graphics object from which it was received.  If such a method returns a mutable class object, maybe changing its properties will change the underlying graphics object and maybe it won&apos;t--nobody really knows.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment24440426_441337&quot;&gt;&lt;span title=&quot;2013-06-04 23:51:53Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 4, 2013 at 23:51&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;I would also posit that if  one wants to fasten a fixed set of variables together with duct tape so their values can be processed or stored either separately or as a unit, it makes a lot more sense to ask the compiler to fasten a fixed set of variables together (i.e. declare a &lt;code&gt;struct&lt;/code&gt; with public fields) than to define a class which can be used, clumsily, to achieve the same ends, or to add a bunch of junk to a struct to make it emulate such a class (rather than having it behave like a set of variables stuck together with duct tape, which is what one really wants in the first place)&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment24432968_16912761&quot;&gt;&lt;span title=&quot;2013-06-04 18:41:39Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 4, 2013 at 18:41&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Ron Warholic: it&apos;s not self-apparent that SomeRect is a Rectangle.  It could be some other type which can be implicitly typecast from Rectangle.  Although, the only system-defined type which can be implicitly typecast from Rectangle is RectangleF, and the compiler would squawk if one tried to pass the fields of a RectangleF to the constructor of Rectangle (since the former are Single, and the latter Integer), there could be user-defined structs which allow such implicit typecasts.  BTW, the first statement would work equally well whether SomeRect were a Rectangle or a RectangleF.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment9689046_7592128&quot;&gt;&lt;span title=&quot;2011-10-28 14:59:01Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Oct 28, 2011 at 14:59&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 3 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;All you&apos;ve shown is that in a contrived example you believe one method is clearer. If we take your example with &lt;code&gt;Rectangle&lt;/code&gt; I could easily come up with a common sitation where you get highly &lt;i&gt;unclear&lt;/i&gt; behaviour.  Consider that WinForms implements a mutable &lt;code&gt;Rectangle&lt;/code&gt; type used in the form&apos;s &lt;code&gt;Bounds&lt;/code&gt; property.  If I want to change bounds I would want to use your nice syntax: &lt;code&gt;form.Bounds.X = 10;&lt;/code&gt; However this changes precisely &lt;i&gt;nothing&lt;/i&gt; on the form (and generates a lovely error informing you of such). Inconsistency is the bane of programming and is why immutability is wanted.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/22780/ron-warholic&quot; title=&quot;9,894 reputation&quot; class=&quot;comment-user&quot;&gt;Ron Warholic&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment9690599_7592128&quot;&gt;&lt;span title=&quot;2011-10-28 16:28:10Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Oct 28, 2011 at 16:28&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Ron Warholic: BTW, I would &lt;i&gt;like&lt;/i&gt; to be able to say &quot;form.Bounds.X = 10;&quot; and have it just work, but the system doesn&apos;t provide any clean way of doing so.  A convention for exposing value-type properties as methods accepting call-backs could offer much cleaner, efficient, and confirmably-correct code than any approach using classes.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment9691276_7592128&quot;&gt;&lt;span title=&quot;2011-10-28 17:11:45Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Oct 28, 2011 at 17:11&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;This answer is so much more insightful than a few of the top-voted answers.  It&apos;s sort of absurd that the argument against mutable value types relies on the notion of &quot;what you expect&quot; to have happen when you mix aliasing and mutation.  That&apos;s a terrible thing to do &lt;i&gt;anyhow&lt;/i&gt;!&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/42921/eamon-nerbonne&quot; title=&quot;45,391 reputation&quot; class=&quot;comment-user&quot;&gt;Eamon Nerbonne&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment61692744_7592128&quot;&gt;&lt;span title=&quot;2016-05-06 13:49:30Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;May 6, 2016 at 13:49&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@supercat: Who knows, maybe that ref-return feature they&apos;re talking about for C# 7 might cover that base (I haven&apos;t actually looked at it in detail, but it superficially sounds similar).&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/42921/eamon-nerbonne&quot; title=&quot;45,391 reputation&quot; class=&quot;comment-user&quot;&gt;Eamon Nerbonne&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment61695771_7592128&quot;&gt;&lt;span title=&quot;2016-05-06 15:00:34Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;May 6, 2016 at 15:00&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;What should happen, if .net languages had slightly better value-type support, would be struct methods should be forbidden from mutating &apos;this&apos; unless they are explicitly declared as doing so, and methods that are so declared should be forbidden in read-only contexts.  Arrays of mutable structs offer useful semantics which cannot be efficiently achieved via other means.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment9207265_6691740&quot;&gt;&lt;span title=&quot;2011-09-28 23:09:03Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Sep 28, 2011 at 23:09&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;these are good examples of very subtle issue that would arise from mutable structs. I would not have expected any of this behaviour. Why would an array give you a reference, but an interface give you a value? I would have thought, aside from values-all-the-time (which is what I&apos;d really expect), that it would at least be the other way around: interface giving references; arrays giving values...&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/621316/dave-cousineau&quot; title=&quot;11,083 reputation&quot; class=&quot;comment-user&quot;&gt;Dave Cousineau&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment11519413_6691740&quot;&gt;&lt;span title=&quot;2012-02-06 11:54:33Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Feb 6, 2012 at 11:54&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Oh my... this makes mutable structs damn evil!&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/661933/nawfal&quot; title=&quot;66,732 reputation&quot; class=&quot;comment-user&quot;&gt;nawfal&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment28479846_6691740&quot;&gt;&lt;span title=&quot;2013-10-08 06:40:03Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Oct 8, 2013 at 6:40&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;When you refactor the mutating methods into static methods requiring a ref parameter: &lt;code&gt;public static void IncrementI(ref Mutable m) { m.I++; }&lt;/code&gt; then the compiler should stop you from doing the &quot;wrong&quot; things most at the time.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/442376/springy76&quot; title=&quot;3,528 reputation&quot; class=&quot;comment-user&quot;&gt;springy76&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment67530708_6691740&quot;&gt;&lt;span title=&quot;2016-10-19 11:43:19Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Oct 19, 2016 at 11:43&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;I like this answer because it contains very valuable information that is non obvious. But really though, this is not an argument against mutable structs as some claim. Yes what we see here is a &quot;pit of despair&quot; as Eric would have put it, but the source of this despair isn&apos;t mutability. The source of despair is the structs self-mutating &lt;i&gt;methods&lt;/i&gt;. (As for why arrays and lists behave differently it&apos;s because one is basically an operator that calculates a memory address and the other is a property. In general it all becomes clear once you understanding that a &quot;reference&quot; is an address &lt;i&gt;value&lt;/i&gt;.)&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/533837/anorzaken&quot; title=&quot;1,677 reputation&quot; class=&quot;comment-user&quot;&gt;AnorZaken&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment78928641_6691740&quot;&gt;&lt;span title=&quot;2017-08-31 14:54:50Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Aug 31, 2017 at 14:54&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Well, I suppose they could have made System.Drawing.Point immutable but it would have been a serious design error IMHO. I think points are actually an archetypical value type and they are mutable. And they don&apos;t cause any problems for anyone beyond really early programming 101 beginners.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/12845/stephen-martin&quot; title=&quot;9,296 reputation&quot; class=&quot;comment-user&quot;&gt;Stephen Martin&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment263587_441375&quot;&gt;&lt;span title=&quot;2009-01-14 01:29:46Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Jan 14, 2009 at 1:29&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;In principle I think points should also be immutable but if it makes the type harder or less elegant to use then of course that has to be considered too. There&apos;s no point in having code constructs which uphold the finest princicples if no one wants to use them ;)&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/4055/morten-christiansen&quot; title=&quot;18,372 reputation&quot; class=&quot;comment-user&quot;&gt;Morten Christiansen&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment264323_441375&quot;&gt;&lt;span title=&quot;2009-01-14 10:19:23Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Jan 14, 2009 at 10:19&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Value-types are useful for representing simple immutable concepts, but exposed-field structures are the best types to use to hold or pass around small fixed sets of related but independent values (such as the coordinates of a point).  A storage location of such a value type encapsulates the values of its fields and nothing else.  By contrast, a storage location of a mutable reference type may be used for the purpose of holding the state of the mutable object, but also encapsulates the identity of all other references throughout the universe that exist to that same object.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment24728284_441375&quot;&gt;&lt;span title=&quot;2013-06-13 18:51:16Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 13, 2013 at 18:51&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;&lt;i&gt;Value types basically represents immutable concepts.&lt;/i&gt;  No, they don&apos;t.  One of the oldest and most useful applications of a value-typed variable is an &lt;code&gt;int&lt;/code&gt; iterator, which would be completely useless if it were immutable.  I think you&apos;re conflating value types&apos; compiler/runtime implementations with variables typed to a value type the latter is certainly mutable to any of the possible values.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/177525/slipp-d-thompson&quot; title=&quot;30,765 reputation&quot; class=&quot;comment-user&quot;&gt;Slipp D. Thompson&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment47124262_441375&quot;&gt;&lt;span title=&quot;2015-04-07 00:37:37Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 7, 2015 at 0:37&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;By the logic you&apos;ve stated in this answer, all types are immutable.  Classes are stored as collections of value types and references (memory address pointers/handles)  therefore they&apos;re also immutable since you don&apos;t change the memory address, you just &lt;i&gt;assign another unique value&lt;/i&gt;.  The Q is clearly about the proposed usage of struct-category data structures in a way that changes what values and memory locations they contain at a time after initialization, from a high-level programmers&apos; perspective.  &lt;b&gt;Switching the discussion to compiler optimizations makes this A irrelevant.&lt;/b&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/177525/slipp-d-thompson&quot; title=&quot;30,765 reputation&quot; class=&quot;comment-user&quot;&gt;Slipp D. Thompson&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment47124317_441375&quot;&gt;&lt;span title=&quot;2015-04-07 00:42:15Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 7, 2015 at 0:42&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 6 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Having class fields of structure types can often be a very useful pattern, though admittedly there are some limitations.  Performance will be degraded if one uses properties rather than fields, or uses &lt;code&gt;readonly&lt;/code&gt;, but if one avoids doing those things class fields of structure types are just fine.  The only really fundamental limitation of structures is that a struct field of a mutable class type like &lt;code&gt;int[]&lt;/code&gt; may encapsulate identity or an unchanging set of values, but cannot be used to encapsulate mutable values without also encapsulating an unwanted identity.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment29674653_19448476&quot;&gt;&lt;span title=&quot;2013-11-12 20:59:55Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Nov 12, 2013 at 20:59&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;True, but in this case the reason for using a struct is that doing so is imposed upon the application design by outside constraints (those by the native code&apos;s use). Everything else you describe about these objects suggests they should clearly be classes in C# or VB.NET.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/400547/jon-hanna&quot; title=&quot;107,247 reputation&quot; class=&quot;comment-user&quot;&gt;Jon Hanna&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment4209824_2489036&quot;&gt;&lt;span title=&quot;2010-10-15 14:20:11Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Oct 15, 2010 at 14:20&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;I&apos;m not sure why some people think the things should be class objects.  If all array slots are populated with references distinct instances, using a class type will add an extra twelve or twenty-four bytes to the memory requirement, and sequential access on an array of class object references is apt to be much slower than sequential access on an array of structs.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment24440460_2489036&quot;&gt;&lt;span title=&quot;2013-06-04 23:55:10Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 4, 2013 at 23:55&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Your point about &lt;i&gt;identity&lt;/i&gt; is a good one; it may be worth noting that identity is relevant only when multiple references exists to something. If &lt;code&gt;foo&lt;/code&gt; holds the only reference to its target anywhere in the universe, and nothing has captured that object&apos;s identity-hash value, then mutating field &lt;code&gt;foo.X&lt;/code&gt; is semantically equivalent to making &lt;code&gt;foo&lt;/code&gt; point to a new object which is just like the one it previously referred to, but with &lt;code&gt;X&lt;/code&gt; holding the desired value. With class types, it&apos;s generally hard to know whether multiple references exist to something, but with structs it&apos;s easy: they don&apos;t.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment28356714_19138576&quot;&gt;&lt;span title=&quot;2013-10-03 19:59:38Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Oct 3, 2013 at 19:59&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;If &lt;code&gt;Thing&lt;/code&gt; is a mutable class type, a &lt;code&gt;Thing[]&lt;/code&gt; &lt;i&gt;will&lt;/i&gt; encapsulate object identities--whether one wants it to or not--unless one can ensure that no &lt;code&gt;Thing&lt;/code&gt; in the array to which any outside references exist will ever be mutated. If one doesn&apos;t want the array elements to encapsulate identity, one must generally ensure either that no items to which it holds references will ever be mutated, or that no outside references will ever exist to any items it holds [hybrid approaches can also work]. Neither approach is terribly convenient. If &lt;code&gt;Thing&lt;/code&gt; is a structure, a &lt;code&gt;Thing[]&lt;/code&gt; encapsulates values only.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment28357170_19138576&quot;&gt;&lt;span title=&quot;2013-10-03 20:15:04Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Oct 3, 2013 at 20:15&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;For objects, their identity comes from their location. Reference types&apos; instances have their identity thanks to their location in the memory and you only pass around their identity (a reference), not their data, while value types have their identity in the outer place where they are stored. The identity of your Eric value type comes only from the variable where he is stored. If you pass him around, he&apos;ll lose his identity.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1424244/is4&quot; title=&quot;10,592 reputation&quot; class=&quot;comment-user&quot;&gt;IS4&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment42339719_19138576&quot;&gt;&lt;span title=&quot;2014-11-12 17:35:49Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Nov 12, 2014 at 17:35&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;That is true if you use a class as the key in a map, too.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/23354/marc-gravell&quot; title=&quot;980,686 reputation&quot; class=&quot;comment-user&quot;&gt;Marc Gravell&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment263313_441335&quot;&gt;&lt;span title=&quot;2009-01-13 23:37:04Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Jan 13, 2009 at 23:37&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;structs are not be aliased in c#. Every struct assignment is a copy.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/44743/recursive&quot; title=&quot;81,259 reputation&quot; class=&quot;comment-user&quot;&gt;recursive&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment4016062_441362&quot;&gt;&lt;span title=&quot;2010-09-24 19:24:33Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Sep 24, 2010 at 19:24&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@recursive: In some cases, that&apos;s a major advantage of mutable structs, and one which makes me question the notion that structs should not be mutable.  The fact that compilers sometimes implicitly copy structs doesn&apos;t reduce the usefulness of mutable structs.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment4152550_441362&quot;&gt;&lt;span title=&quot;2010-10-09 20:44:22Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Oct 9, 2010 at 20:44&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Straight to the point! Structures are organization units without access control restrictions! Unfortunately, C# has made them useless for this purpose!&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1145669/thundergr&quot; title=&quot;2,229 reputation&quot; class=&quot;comment-user&quot;&gt;ThunderGr&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment28836495_4924430&quot;&gt;&lt;span title=&quot;2013-10-18 11:16:47Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Oct 18, 2013 at 11:16&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;this &lt;i&gt;completely&lt;/i&gt; misses the point as both your examples show mutable structs.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363437/vidstige&quot; title=&quot;11,928 reputation&quot; class=&quot;comment-user&quot;&gt;vidstige&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment53496235_4924430&quot;&gt;&lt;span title=&quot;2015-09-28 19:19:36Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Sep 28, 2015 at 19:19&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;C# made them useless for this purpose because that&apos;s not the purpose of the structures&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1964796/luiz-felipe&quot; title=&quot;1,003 reputation&quot; class=&quot;comment-user&quot;&gt;Luiz Felipe&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment71465528_4924430&quot;&gt;&lt;span title=&quot;2017-02-10 00:44:20Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Feb 10, 2017 at 0:44&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;There is nothing wrong with designing small opaque structures to behave like immutable class objects; the MSDN guidelines are reasonable &lt;i&gt;when one is trying to make something that behaves like an object&lt;/i&gt;.  Structures are appropriate in some cases where one needs lightweight things that behave like objects, and in cases where one needs a bunch of variables stuck together with duct tape.  For some reason, however, many people fail to realize that structures have two distinct usages, and that guidelines appropriate for one are inappropriate for the other.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment48509011_30198293&quot;&gt;&lt;span title=&quot;2015-05-12 21:27:16Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;May 12, 2015 at 21:27&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;As I see it, a struct is at its heart a bunch of variables stuck together with duct tape.  It&apos;s possible in .NET for a struct to pretend to be something other than a bunch of variables stuck together with duct tape, and I would suggest that when practical a type which is going to pretend to be something other than a bunch of variables stuck together with duct tape should behave as a unified object (which for a struct would imply immutability), but sometimes it is useful to stick a bunch of variables together with duct tape.  Even in production code, I would consider it better to have a type...&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment30979160_20681769&quot;&gt;&lt;span title=&quot;2013-12-19 16:24:35Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Dec 19, 2013 at 16:24&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;...which clearly has no semantics beyond &quot;each field contains the last thing written to it&quot;, pushing all semantics into the code which &lt;i&gt;uses&lt;/i&gt; the structure, than to try to have a struct do more.  Given, for example, a &lt;code&gt;Range&amp;lt;T&amp;gt;&lt;/code&gt; type with members &lt;code&gt;Minimum&lt;/code&gt; and &lt;code&gt;Maximum&lt;/code&gt; fields of type &lt;code&gt;T&lt;/code&gt;, and code &lt;code&gt;Range&amp;lt;double&amp;gt; myRange = foo.getRange();&lt;/code&gt;, any guarantees about what &lt;code&gt;Minimum&lt;/code&gt; and &lt;code&gt;Maximum&lt;/code&gt; contain should come from &lt;code&gt;foo.GetRange();&lt;/code&gt;.  Having &lt;code&gt;Range&lt;/code&gt; be an exposed-field struct would make clear that it&apos;s not going to add any behavior of its own.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/363751/supercat&quot; title=&quot;73,697 reputation&quot; class=&quot;comment-user&quot;&gt;supercat&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment30979799_20681769&quot;&gt;&lt;span title=&quot;2013-12-19 16:39:27Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Dec 19, 2013 at 16:39&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        "],"id":592,"title":"Why are mutable structs “evil”?","content":"\n                \n&lt;p&gt;Following the discussions here on SO I already read several times the remark that mutable structs are “evil” (like in the answer to this &lt;a href=&quot;https://stackoverflow.com/questions/292676/is-there-a-workaround-for-overloading-the-assignment-operator-in-c&quot;&gt;question&lt;/a&gt;).&lt;/p&gt;\n\n&lt;p&gt;What&apos;s the actual problem with mutability and structs in C#? &lt;/p&gt;\n    ","slug":"why-are-mutable-structs-\"evil\"-1657388508974","postType":"QUESTION","createdAt":"2022-07-09T17:41:48.000Z","updatedAt":"2022-07-09T17:41:48.000Z","tags":[{"id":2815,"name":"struct","slug":"struct","createdAt":"2022-07-09T17:41:49.000Z","updatedAt":"2022-07-09T17:41:49.000Z","Questions_Tags":{"questionId":592,"tagId":2815}},{"id":2816,"name":"immutability","slug":"immutability","createdAt":"2022-07-09T17:41:49.000Z","updatedAt":"2022-07-09T17:41:49.000Z","Questions_Tags":{"questionId":592,"tagId":2816}}]}},"__N_SSG":true}