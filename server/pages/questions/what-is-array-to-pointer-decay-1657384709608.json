{"pageProps":{"data":{"answer":["\n&lt;p&gt;It&apos;s said that arrays &quot;decay&quot; into pointers.  A C++ array declared as &lt;code&gt;int numbers [5]&lt;/code&gt; cannot be re-pointed, i.e. you can&apos;t say &lt;code&gt;numbers = 0x5a5aff23&lt;/code&gt;. More importantly the term decay signifies loss of type and dimension; &lt;code&gt;numbers&lt;/code&gt; decay into &lt;code&gt;int*&lt;/code&gt; by losing the dimension information (count 5) and the type is not &lt;code&gt;int [5]&lt;/code&gt; any more. Look here for &lt;a href=&quot;https://stackoverflow.com/questions/17752978/exception-to-array-not-decaying-into-a-pointer&quot;&gt;cases where the decay doesn&apos;t happen&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;If you&apos;re passing an array by value, what you&apos;re really doing is copying a pointer - a pointer to the array&apos;s first element is copied to the parameter (whose type should also be a pointer the array element&apos;s type). This works due to array&apos;s decaying nature; once decayed, &lt;code&gt;sizeof&lt;/code&gt; no longer gives the complete array&apos;s size, because it essentially becomes a pointer.  This is why it&apos;s preferred (among other reasons) to pass by reference or pointer.&lt;/p&gt;\n\n&lt;p&gt;Three ways to pass in an array&lt;sup&gt;1&lt;/sup&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;by_value&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; T* &lt;span class=&quot;hljs-keyword&quot;&gt;array&lt;/span&gt;)   &lt;span class=&quot;hljs-comment&quot;&gt;// const T array[] means the same&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;by_pointer&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;T&lt;/span&gt; (*&lt;span class=&quot;hljs-keyword&quot;&gt;array&lt;/span&gt;)[U])\n&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;by_reference&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;T&lt;/span&gt; (&amp;amp;&lt;span class=&quot;hljs-keyword&quot;&gt;array&lt;/span&gt;)[U])\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The last two will give proper &lt;code&gt;sizeof&lt;/code&gt; info, while the first one won&apos;t since the array argument has decayed to be assigned to the parameter.&lt;/p&gt;\n\n&lt;p&gt;&lt;sup&gt;1 The constant U should be known at compile-time.&lt;/sup&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Arrays are basically the same as pointers in C/C++, but not quite. Once you convert an array:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; a[] = { &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt; };\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;into a pointer (which works without casting, and therefore can happen unexpectedly in some cases):&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;* p = a;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;you lose the ability of the &lt;code&gt;sizeof&lt;/code&gt; operator to count elements in the array:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;assert( &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(p) != &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(a) );  &lt;span class=&quot;hljs-comment&quot;&gt;// sizes are not equal&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This lost ability is referred to as &quot;decay&quot;.&lt;/p&gt;\n\n&lt;p&gt;For more details, check out this &lt;a href=&quot;http://web.archive.org/web/20081208122434/http://www.transcendentaxis.com/dthompson/blog/archives/9&quot; rel=&quot;noreferrer&quot;&gt;article about array decay&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;Here&apos;s what the standard says (C99 6.3.2.1/3 - Other operands - Lvalues, arrays, and function designators):&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Except when it is the operand of the sizeof operator or the unary &amp;amp; operator, or is a\n  string literal used to initialize an array, an expression that has type array of type is\n  converted to an expression with type pointer to type that points to the initial element of\n  the array object and is not an lvalue.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;This means that pretty much anytime the array name is used in an expression, it is automatically converted to a pointer to the 1st item in the array.&lt;/p&gt;\n\n&lt;p&gt;Note that function names act in a similar way, but function pointers are used far less and in a much more specialized way that it doesn&apos;t cause nearly as much confusion as the automatic conversion of array names to pointers.&lt;/p&gt;\n\n&lt;p&gt;The C++ standard (4.2 Array-to-pointer conversion) loosens the conversion requirement to (emphasis mine):&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;An lvalue or rvalue of type array of N T or array of unknown bound of T &lt;strong&gt;can&lt;/strong&gt; be converted to an rvalue\n  of type pointer to T.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;So the conversion doesn&apos;t &lt;em&gt;have&lt;/em&gt; to happen like it pretty much always does in C (this lets functions overload or templates match on the array type).&lt;/p&gt;\n\n&lt;p&gt;This is also why in C you should avoid using array parameters in function prototypes/definitions (in my opinion - I&apos;m not sure if there&apos;s any general agreement).  They cause confusion and are a fiction anyway - use pointer parameters and the confusion might not go away entirely, but at least the parameter declaration isn&apos;t lying.&lt;/p&gt;\n    ","\n&lt;p&gt;&quot;Decay&quot; refers to the implicit conversion of an expression from an array type to a pointer type.  In most contexts, when the compiler sees an array expression it converts the type of the expression from &quot;N-element array of T&quot; to &quot;pointer to T&quot; and sets the value of the expression to the address of the first element of the array.  The exceptions to this rule are when an array is an operand of either the &lt;code&gt;sizeof&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt; operators, or the array is a string literal being used as an initializer in a declaration.&lt;/p&gt;\n&lt;p&gt;Assume the following code:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-css&quot;&gt;char &lt;span class=&quot;hljs-selector-tag&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;hljs-selector-attr&quot;&gt;[80]&lt;/span&gt;;\nstrcpy(&lt;span class=&quot;hljs-selector-tag&quot;&gt;a&lt;/span&gt;, &quot;This is &lt;span class=&quot;hljs-selector-tag&quot;&gt;a&lt;/span&gt; test&quot;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The expression &lt;code&gt;a&lt;/code&gt; is of type &quot;80-element array of char&quot; and the expression &quot;This is a test&quot; is of type &quot;15-element array of char&quot; (in C; in C++ string literals are arrays of const char).  However, in the call to &lt;code&gt;strcpy()&lt;/code&gt;, neither expression is an operand of &lt;code&gt;sizeof&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt;, so their types are implicitly converted to &quot;pointer to char&quot;, and their values are set to the address of the first element in each.  What &lt;code&gt;strcpy()&lt;/code&gt; receives are not arrays, but pointers, as seen in its prototype:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *&lt;span class=&quot;hljs-title&quot;&gt;strcpy&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *dest, &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *src)&lt;/span&gt;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This is not the same thing as an array pointer.  For example:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;];\n&lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt; *ptr_to_first_element = a;\n&lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt; (*ptr_to_array)[&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;] = &amp;amp;a;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Both &lt;code&gt;ptr_to_first_element&lt;/code&gt; and &lt;code&gt;ptr_to_array&lt;/code&gt; have the same &lt;em&gt;value&lt;/em&gt;; the base address of a.  However, they are different types and are treated differently, as shown below:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-yaml&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;a[i]&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;ptr_to_first_element[i]&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;(*ptr_to_array)[i]&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;*ptr_to_array[i]&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;ptr_to_array[i]&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Remember that the expression &lt;code&gt;a[i]&lt;/code&gt; is interpreted as &lt;code&gt;*(a+i)&lt;/code&gt; (which only works if the array type is converted to a pointer type), so both &lt;code&gt;a[i]&lt;/code&gt; and &lt;code&gt;ptr_to_first_element[i]&lt;/code&gt; work the same. The expression &lt;code&gt;(*ptr_to_array)[i]&lt;/code&gt; is interpreted as &lt;code&gt;*(*a+i)&lt;/code&gt;.  The expressions &lt;code&gt;*ptr_to_array[i]&lt;/code&gt; and &lt;code&gt;ptr_to_array[i]&lt;/code&gt; may lead to compiler warnings or errors depending on the context; they&apos;ll definitely do the wrong thing if you&apos;re expecting them to evaluate to &lt;code&gt;a[i]&lt;/code&gt;.&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; a == &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; *ptr_to_array == &lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Again, when an array is an operand of &lt;code&gt;sizeof&lt;/code&gt;, it&apos;s not converted to a pointer type.&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; *ptr_to_first_element == &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt;) == &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; ptr_to_first_element == &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt; *) == whatever the pointer size\n                                                  &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;on&lt;/span&gt; your platform\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;ptr_to_first_element&lt;/code&gt; is a simple pointer to char.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;b&gt;Arrays, in C, have no value.&lt;/b&gt;&lt;/p&gt;\n\n&lt;p&gt;Wherever the value of an object is expected but the object is an array, the address of its first element is used instead, with type &lt;code&gt;pointer to (type of array elements)&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;In a function, all parameters are passed by value (arrays are no exception). When you pass an array in a function it &quot;decays into a pointer&quot; (sic); when you compare an array to something else, again it &quot;decays into a pointer&quot; (sic); ...&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; arr[]&lt;/span&gt;)&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Function foo expects the value of an array. But, in C, arrays have no value! So &lt;code&gt;foo&lt;/code&gt; gets instead the address of the first element of the array.&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; arr[&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;];\n&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; *ip = &amp;amp;(arr[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]);\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (arr == ip) { &lt;span class=&quot;hljs-comment&quot;&gt;/* something; */&lt;/span&gt; }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In the comparison above, &lt;code&gt;arr&lt;/code&gt; has no value, so it becomes a pointer. It becomes a pointer to int. That pointer can be compared with the variable &lt;code&gt;ip&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;In the array indexing syntax you are used to seeing, again, the arr is &apos;decayed to a pointer&apos;&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-css&quot;&gt;arr&lt;span class=&quot;hljs-selector-attr&quot;&gt;[42]&lt;/span&gt;;\n&lt;span class=&quot;hljs-comment&quot;&gt;/* same as *(arr + 42); */&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;/* same as *(&amp;amp;(arr[0]) + 42); */&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The only times an array doesn&apos;t decay into a pointer are when it is the operand of the sizeof operator, or the &amp;amp; operator (the &apos;address of&apos; operator), or as a string literal used to initialize a character array.&lt;/p&gt;\n    ","\n&lt;p&gt;It&apos;s when array rots and is being pointed at ;-)&lt;/p&gt;\n\n&lt;p&gt;Actually, it&apos;s just that if you want to pass an array somewhere, but the pointer is passed instead (because who the hell would pass the whole array for you), people say that poor array decayed to pointer.&lt;/p&gt;\n    ","\n&lt;p&gt;Array decaying means that, when an array is passed as a parameter to a function, it&apos;s treated identically to (&quot;decays to&quot;) a pointer.&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-scss&quot;&gt;void &lt;span class=&quot;hljs-built_in&quot;&gt;do_something&lt;/span&gt;(int *array) {\n  &lt;span class=&quot;hljs-comment&quot;&gt;// We don&apos;t know how big array is here, because it&apos;s decayed to a pointer.&lt;/span&gt;\n  &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&quot;%i\\n&quot;, sizeof(array));  &lt;span class=&quot;hljs-comment&quot;&gt;// always prints 4 on a 32-bit machine&lt;/span&gt;\n}\n\nint &lt;span class=&quot;hljs-selector-tag&quot;&gt;main&lt;/span&gt; (int argc, char **argv) {\n    int &lt;span class=&quot;hljs-selector-tag&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;hljs-selector-attr&quot;&gt;[10]&lt;/span&gt;;\n    int &lt;span class=&quot;hljs-selector-tag&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;hljs-selector-attr&quot;&gt;[20]&lt;/span&gt;;\n    int *c;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&quot;%zu\\n&quot;, sizeof(a)); &lt;span class=&quot;hljs-comment&quot;&gt;//prints 40 on a 32-bit machine&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&quot;%zu\\n&quot;, sizeof(b)); &lt;span class=&quot;hljs-comment&quot;&gt;//prints 80 on a 32-bit machine&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&quot;%zu\\n&quot;, sizeof(c)); &lt;span class=&quot;hljs-comment&quot;&gt;//prints 4 on a 32-bit machine&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;do_something&lt;/span&gt;(a);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;do_something&lt;/span&gt;(b);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;do_something&lt;/span&gt;(c);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;There are two complications or exceptions to the above.&lt;/p&gt;\n\n&lt;p&gt;First, when dealing with multidimensional arrays in C and C++, only the first dimension is lost.  This is because arrays are layed out contiguously in memory, so the compiler must know all but the first dimension to be able to calculate offsets into that block of memory.&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-scss&quot;&gt;void &lt;span class=&quot;hljs-built_in&quot;&gt;do_something&lt;/span&gt;(int array[][&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;])\n{\n    &lt;span class=&quot;hljs-comment&quot;&gt;// We don&apos;t know how big the first dimension is.&lt;/span&gt;\n}\n\nint &lt;span class=&quot;hljs-selector-tag&quot;&gt;main&lt;/span&gt;(int argc, char *argv[]) {\n    int &lt;span class=&quot;hljs-selector-tag&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;hljs-selector-attr&quot;&gt;[5]&lt;/span&gt;&lt;span class=&quot;hljs-selector-attr&quot;&gt;[10]&lt;/span&gt;;\n    int &lt;span class=&quot;hljs-selector-tag&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;hljs-selector-attr&quot;&gt;[20]&lt;/span&gt;&lt;span class=&quot;hljs-selector-attr&quot;&gt;[10]&lt;/span&gt;;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;do_something&lt;/span&gt;(a);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;do_something&lt;/span&gt;(b);\n    return &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Second, in C++, you can use templates to deduce the size of arrays.  Microsoft uses this for the C++ versions of Secure CRT functions like &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/td1esda9%28VS.80%29.aspx&quot; rel=&quot;nofollow noreferrer&quot;&gt;strcpy_s&lt;/a&gt;, and you can use a similar trick to reliably &lt;a href=&quot;https://stackoverflow.com/questions/469696/what-is-your-most-useful-c-c-snippet/470221#470221&quot;&gt;get the number of elements in an array&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;h3&gt;tl;dr: When you use an array you&apos;ve defined, you&apos;ll actually be using a pointer to its first element.&lt;/h3&gt;\n&lt;p&gt;Thus:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;When you write &lt;code&gt;arr[idx]&lt;/code&gt; you&apos;re really just saying &lt;code&gt;*(arr + idx)&lt;/code&gt;.&lt;/li&gt;\n&lt;li&gt;functions never really take arrays as parameters, only pointers - either directly, when you specify an array parameter, or indirectly, if you pass a reference to an array.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Sort-of exceptions to this rule:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;You can pass fixed-length arrays to functions within a &lt;code&gt;struct&lt;/code&gt;.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;sizeof()&lt;/code&gt; gives the size taken up by the array, not the size of a pointer.&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;Arrays are automatically passed by pointer in C. &lt;a href=&quot;https://stackoverflow.com/a/671348/7194773&quot;&gt;The rationale behind it can only be speculated&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;int a[5]&lt;/code&gt;, &lt;code&gt;int *a&lt;/code&gt; and &lt;code&gt;int (*a)[5]&lt;/code&gt; are all glorified addresses meaning that the compiler treats arithmetic and deference operators on them differently depending on the type, so when they refer to the same address they are not treated the same by the compiler. &lt;code&gt;int a[5]&lt;/code&gt; is different to the other 2 in that the address is implicit and does not manifest on the stack or the executable as part of the array itself, it is only used by the compiler to resolve certain arithmetic operations, like taking its address or pointer arithmetic. &lt;code&gt;int a[5]&lt;/code&gt; is therefore an array as well as an implicit address, but as soon as you talk about the address itself and place it on the stack, the address itself is no longer an array, and can only be a pointer to an array or a decayed array i.e. a pointer to the first member of the array.&lt;/p&gt;\n&lt;p&gt;For instance, on &lt;code&gt;int (*a)[5]&lt;/code&gt;, the first dereference on &lt;code&gt;a&lt;/code&gt; will produce an &lt;code&gt;int *&lt;/code&gt; (so the same address, just a different type, and note not &lt;code&gt;int a[5]&lt;/code&gt;), and pointer arithmetic on &lt;code&gt;a&lt;/code&gt; i.e. &lt;code&gt;a+1&lt;/code&gt; or &lt;code&gt;*(a+1)&lt;/code&gt; will be in terms of the size of an array of 5 ints (which is the data type it points to), and the second dereference will produce the &lt;code&gt;int&lt;/code&gt;. On &lt;code&gt;int a[5]&lt;/code&gt; however, the first dereference will produce the &lt;code&gt;int&lt;/code&gt; and the pointer arithmetic will be in terms of the size of an &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;To a function, you can only pass &lt;code&gt;int *&lt;/code&gt; and &lt;code&gt;int (*)[5]&lt;/code&gt;, and the function casts it to whatever the parameter type is, so within the function you have a choice whether to treat an address that is being passed as a decayed array or a pointer to an array (where the function has to specify the size of the array being passed). If you pass &lt;code&gt;a&lt;/code&gt; to a function and &lt;code&gt;a&lt;/code&gt; is defined &lt;code&gt;int a[5]&lt;/code&gt;, then as &lt;code&gt;a&lt;/code&gt; resolves to an address, you are passing an address, and an address can only be a pointer type. In the function, the parameter it accesses is then an address on the stack or in a register, which can only be a pointer type and not an array type -- this is because it&apos;s an actual address on the stack and is therefore clearly not the array itself.&lt;/p&gt;\n&lt;p&gt;You lose the size of the array because the type of the parameter, being an address, is a pointer and not an array, which does not have an array size, as can be seen when using &lt;code&gt;sizeof&lt;/code&gt;, which works on the type of the value being passed to it. The parameter type &lt;code&gt;int a[5]&lt;/code&gt; instead of &lt;code&gt;int *a&lt;/code&gt; is allowed but is treated as &lt;code&gt;int *&lt;/code&gt; instead of disallowing it outright, though it should be disallowed, because it is misleading, because it makes you think that the size information can be used, but you can only do this by casting it to &lt;code&gt;int (*a)[5]&lt;/code&gt;, and of course, the function has to specify the size of the array because there is no way to pass the size of the array because the size of the array needs to be a compile-time constant.&lt;/p&gt;\n    ","\n&lt;p&gt;I might be so bold to think there are four (4) ways to pass an array as the function argument. Also here is the short but working code for your perusal.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;cassert&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// test data&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// notice native array init with no copy aka &quot;=&quot;&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// not possible in C&lt;/span&gt;\n &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;* specimen[]{ __TIME__, __DATE__, __TIMESTAMP__ };\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// ONE&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// simple, dangerous and useless&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;as_pointer&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; T* array)&lt;/span&gt; &lt;/span&gt;{ \n    &lt;span class=&quot;hljs-comment&quot;&gt;// a pointer&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;assert&lt;/span&gt;(array != &lt;span class=&quot;hljs-literal&quot;&gt;nullptr&lt;/span&gt;); \n} ;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// TWO&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// for above const T array[] means the same&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// but and also , minimum array size indication might be given too&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// this also does not stop the array decay into T *&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// thus size information is lost&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;by_value_no_size&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; T array[&lt;span class=&quot;hljs-number&quot;&gt;0xFF&lt;/span&gt;])&lt;/span&gt; &lt;/span&gt;{ \n    &lt;span class=&quot;hljs-comment&quot;&gt;// decayed to a pointer&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;assert&lt;/span&gt;( array != &lt;span class=&quot;hljs-literal&quot;&gt;nullptr&lt;/span&gt; ); \n}\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// THREE&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// size information is preserved&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// but pointer is asked for&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T, &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; N&amp;gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;pointer_to_array&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; T (*array)[N])&lt;/span&gt;\n&lt;/span&gt;{\n   &lt;span class=&quot;hljs-comment&quot;&gt;// dealing with native pointer &lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;assert&lt;/span&gt;( array != &lt;span class=&quot;hljs-literal&quot;&gt;nullptr&lt;/span&gt; ); \n}\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// FOUR&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// no C equivalent&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// array by reference&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// size is preserved&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T, &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; N&amp;gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;reference_to_array&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; T (&amp;amp;array)[N])&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-comment&quot;&gt;// array is not a pointer here&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// it is (almost) a container&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// most of the std:: lib algorithms &lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// do work on array reference, for example&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// range for requires std::begin() and std::end()&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// on the type passed as range to iterate over&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; &amp;amp;&amp;amp; elem : array )\n    {\n        cout &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; elem ;\n    }\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n     &lt;span class=&quot;hljs-comment&quot;&gt;// ONE&lt;/span&gt;\n     &lt;span class=&quot;hljs-built_in&quot;&gt;as_pointer&lt;/span&gt;(specimen);\n     &lt;span class=&quot;hljs-comment&quot;&gt;// TWO&lt;/span&gt;\n     &lt;span class=&quot;hljs-built_in&quot;&gt;by_value_no_size&lt;/span&gt;(specimen);\n     &lt;span class=&quot;hljs-comment&quot;&gt;// THREE&lt;/span&gt;\n     &lt;span class=&quot;hljs-built_in&quot;&gt;pointer_to_array&lt;/span&gt;(&amp;amp;specimen);\n     &lt;span class=&quot;hljs-comment&quot;&gt;// FOUR&lt;/span&gt;\n     &lt;span class=&quot;hljs-built_in&quot;&gt;reference_to_array&lt;/span&gt;( specimen ) ;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I might also think this shows the superiority of C++ vs C. At least in reference (pun intended) of passing an array by reference.&lt;/p&gt;\n\n&lt;p&gt;Of course there are extremely strict projects with no heap allocation, no exceptions and no std:: lib. C++ native array handling is mission critical language feature, one might say.&lt;/p&gt;\n    ","\n&lt;p&gt;Try this code&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;double&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;]&lt;/span&gt;)&lt;/span&gt; {\n    printf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;in function: %d&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(a));\n    printf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;pointer size: %d\\n&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;double&lt;/span&gt; *));\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;()&lt;/span&gt; {\n    &lt;span class=&quot;hljs-built_in&quot;&gt;double&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;];\n    printf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;in main: %d&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(a));\n    f(a);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;and you will see that the size of the array inside the function is not equal to the size of the array in main, but it is equal to the size of a pointer.&lt;/p&gt;\n&lt;p&gt;You probably heard that &quot;arrays are pointers&quot;, but, this is not exactly true (the &lt;code&gt;sizeof&lt;/code&gt; inside &lt;code&gt;main&lt;/code&gt; prints the correct size). However, when passed, the array &lt;em&gt;decays&lt;/em&gt; to pointer. That is, regardless of what the syntax shows, you actually pass a pointer, and the function actually receives a pointer.&lt;/p&gt;\n&lt;p&gt;In this case, the definition &lt;code&gt;void f(double a[10]&lt;/code&gt; is implicitly transformed by the compiler to &lt;code&gt;void f(double *a)&lt;/code&gt;. You could have equivalently declared the function argument directly as &lt;code&gt;*a&lt;/code&gt;. You could have even written &lt;code&gt;a[100]&lt;/code&gt; or &lt;code&gt;a[1]&lt;/code&gt;, instead of &lt;code&gt;a[10]&lt;/code&gt;, since it is never actually compiled that way (however, you shouldn&apos;t do it obviously, it would confuse the reader).&lt;/p&gt;\n    "],"comment":["\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;little known: The unary plus operator can be used as an &quot;decay operator&quot;: Given &lt;code&gt;int a[10]; int b(void);&lt;/code&gt;, then &lt;code&gt;+a&lt;/code&gt; is an int pointer and &lt;code&gt;+b&lt;/code&gt; is a function pointer. Useful if you want to pass it to a template accepting a reference.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/34509/johannes-schaub-litb&quot; title=&quot;482,727 reputation&quot; class=&quot;comment-user&quot;&gt;Johannes Schaub - litb&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment1310243_1461432&quot;&gt;&lt;span title=&quot;2009-09-22 18:36:39Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Sep 22, 2009 at 18:36&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@litb - parens would do the same (e.g., (a) should be an expression that evaluates to a pointer), right?.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/12711/michael-burr&quot; title=&quot;322,345 reputation&quot; class=&quot;comment-user&quot;&gt;Michael Burr&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment1310553_1461432&quot;&gt;&lt;span title=&quot;2009-09-22 19:30:09Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Sep 22, 2009 at 19:30&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;&lt;code&gt;std::decay&lt;/code&gt; from C++14 would be a less obscure way of decaying an array over unary +.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/183120/legends2k&quot; title=&quot;29,643 reputation&quot; class=&quot;comment-user&quot;&gt;legends2k&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment46702561_1461432&quot;&gt;&lt;span title=&quot;2015-03-25 06:43:52Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 25, 2015 at 6:43&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@JohannesSchaub-litb since this question is tagged both C and C++, I&apos;d like to clarify that although &lt;code&gt;+a&lt;/code&gt; and &lt;code&gt;+b&lt;/code&gt; are legal in C++ , it is illegal in C  (C11 6.5.3.3/1 &quot;The operand of the unary &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; operator shall have arithmetic type&quot;)&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1505939/m-m&quot; title=&quot;135,063 reputation&quot; class=&quot;comment-user&quot;&gt;M.M&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment49187761_1461432&quot;&gt;&lt;span title=&quot;2015-05-31 13:41:11Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;May 31, 2015 at 13:41&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@lege Right. But I suppose that is not as little known as the trick with unary +. The reason I mentioned it wasn&apos;t merely because it decays but because it is some fun stuff to play with ;)&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/34509/johannes-schaub-litb&quot; title=&quot;482,727 reputation&quot; class=&quot;comment-user&quot;&gt;Johannes Schaub - litb&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment49191457_1461432&quot;&gt;&lt;span title=&quot;2015-05-31 16:54:11Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;May 31, 2015 at 16:54&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;How is the first passing by value?&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/72631/rlbond&quot; title=&quot;63,019 reputation&quot; class=&quot;comment-user&quot;&gt;rlbond&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment1310349_1461449&quot;&gt;&lt;span title=&quot;2009-09-22 18:54:33Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Sep 22, 2009 at 18:54&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;by_value is passing a pointer to the first element of the array; in the context of function parameters, &lt;code&gt;T a[]&lt;/code&gt; is identical to &lt;code&gt;T *a&lt;/code&gt;.  by_pointer is passing the same thing, except the pointer value is now qualified &lt;code&gt;const&lt;/code&gt;.  If you want to pass a pointer &lt;i&gt;to the array&lt;/i&gt; (as opposed to a pointer to the first element of the array), the syntax is &lt;code&gt;T (*array)[U]&lt;/code&gt;.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/134554/john-bode&quot; title=&quot;113,771 reputation&quot; class=&quot;comment-user&quot;&gt;John Bode&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment1310591_1461449&quot;&gt;&lt;span title=&quot;2009-09-22 19:35:06Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Sep 22, 2009 at 19:35&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;&quot;with an explicit pointer to that array&quot; - this is incorrect. If &lt;code&gt;a&lt;/code&gt; is an array of &lt;code&gt;char&lt;/code&gt;, then &lt;code&gt;a&lt;/code&gt; is of type &lt;code&gt;char[N]&lt;/code&gt;, and will decay to &lt;code&gt;char*&lt;/code&gt;; but &lt;code&gt;&amp;amp;a&lt;/code&gt; is of type &lt;code&gt;char(*)[N]&lt;/code&gt;, and will &lt;i&gt;not&lt;/i&gt; decay.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/111335/pavel-minaev&quot; title=&quot;97,699 reputation&quot; class=&quot;comment-user&quot;&gt;Pavel Minaev&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment1310611_1461449&quot;&gt;&lt;span title=&quot;2009-09-22 19:39:26Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Sep 22, 2009 at 19:39&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@FredOverflow: So if &lt;code&gt;U&lt;/code&gt; changes you don&apos;t have to remember to change it in two places, or risk silent bugs... Autonomy!&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/560648/lightness-races-in-orbit&quot; title=&quot;369,871 reputation&quot; class=&quot;comment-user&quot;&gt;Lightness Races in Orbit&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment37094796_1461449&quot;&gt;&lt;span title=&quot;2014-06-05 10:40:27Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 5, 2014 at 10:40&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 2 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;&quot;If you&apos;re passing an array by value, what you&apos;re really doing is copying a pointer&quot; That makes no sense, because arrays can&apos;&apos;t be passed by value, period.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/661519/juanchopanza&quot; title=&quot;217,673 reputation&quot; class=&quot;comment-user&quot;&gt;juanchopanza&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment53204453_1461449&quot;&gt;&lt;span title=&quot;2015-09-20 13:38:53Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Sep 20, 2015 at 13:38&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Arrays are &lt;i&gt;not&lt;/i&gt; basically the same as pointers; they are completely different animals.  In most contexts, an array can be treated &lt;i&gt;as though&lt;/i&gt; it were a pointer, and a pointer can be treated &lt;i&gt;as though&lt;/i&gt; it were an array, but that&apos;s as close as they get.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/134554/john-bode&quot; title=&quot;113,771 reputation&quot; class=&quot;comment-user&quot;&gt;John Bode&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment1310614_1461466&quot;&gt;&lt;span title=&quot;2009-09-22 19:39:54Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Sep 22, 2009 at 19:39&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@John, please pardon my imprecise language. I was trying to get to the answer without getting bogged down in a lengthy backstory, and &quot;basically...but not quite&quot; is as good an explanation as I ever got in college. I&apos;m sure anyone who&apos;s interested can get a more accurate picture from your upvoted comment.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/52963/system-pause&quot; title=&quot;35,418 reputation&quot; class=&quot;comment-user&quot;&gt;system PAUSE&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment1315571_1461466&quot;&gt;&lt;span title=&quot;2009-09-23 15:17:59Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Sep 23, 2009 at 15:17&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;&quot;works without casting&quot; means the same as &quot;happen implicitly&quot; when talking about type conversions&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1505939/m-m&quot; title=&quot;135,063 reputation&quot; class=&quot;comment-user&quot;&gt;M.M&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment46413983_1461466&quot;&gt;&lt;span title=&quot;2015-03-17 03:39:13Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 17, 2015 at 3:39&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;The fact that the array variable works almost like a pointer does not necessarily mean that they are the same thing. They have different types. That&apos;s why the operator &lt;code&gt;sizeof&lt;/code&gt; works on an array not on a pointer pointing to an array, although they both have the same address.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/8163530/wu-xiliang&quot; title=&quot;306 reputation&quot; class=&quot;comment-user&quot;&gt;Wu Xiliang&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment124995048_1461466&quot;&gt;&lt;span title=&quot;2022-01-14 02:10:00Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Jan 14 at 2:10&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;What is an example line of code where an &quot;expression that has type &apos;array of type&apos;&quot; is &quot;a string literal used to initialize an array&quot;?&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/2223706/garrett&quot; title=&quot;3,153 reputation&quot; class=&quot;comment-user&quot;&gt;Garrett&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment38159249_1462103&quot;&gt;&lt;span title=&quot;2014-07-08 02:45:01Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jul 8, 2014 at 2:45&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 3 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Garrett &lt;code&gt;char x[] = &quot;Hello&quot;;&lt;/code&gt; . The array of 6 elements &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; does not decay; instead &lt;code&gt;x&lt;/code&gt; gets size &lt;code&gt;6&lt;/code&gt; and its elements are initialized from the elements of &lt;code&gt;&quot;Hello&quot;&lt;/code&gt;.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1505939/m-m&quot; title=&quot;135,063 reputation&quot; class=&quot;comment-user&quot;&gt;M.M&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment46414004_1462103&quot;&gt;&lt;span title=&quot;2015-03-17 03:40:19Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 17, 2015 at 3:40&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 2 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Isn&apos;t &lt;code&gt;&quot;This is a test&quot; is of type &quot;16-element array of char&quot;&lt;/code&gt; a &lt;code&gt;&quot;15-element array of char&quot;&lt;/code&gt;?  (length 14 + 1 for \\0)&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/2410359/chux-reinstate-monica&quot; title=&quot;128,312 reputation&quot; class=&quot;comment-user&quot;&gt;chux - Reinstate Monica&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment30543156_1462352&quot;&gt;&lt;span title=&quot;2013-12-07 17:47:44Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Dec 7, 2013 at 17:47&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Note that &lt;code&gt;*ptr_to_array&lt;/code&gt; evalutes to the array value, which then immediately decays into a pointer to the array&apos;s first element, unless it it the operand of &lt;code&gt;sizeof&lt;/code&gt; or unary &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/16406/chris-dodd&quot; title=&quot;112,580 reputation&quot; class=&quot;comment-user&quot;&gt;Chris Dodd&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment122578272_1462352&quot;&gt;&lt;span title=&quot;2021-09-27 19:17:59Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Sep 27, 2021 at 19:17&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;&quot;Arrays have no value&quot; - what&apos;s that supposed to mean? Of course arrays have value... they&apos;re objects, you can have pointers, and, in C++, references to them, etc.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/111335/pavel-minaev&quot; title=&quot;97,699 reputation&quot; class=&quot;comment-user&quot;&gt;Pavel Minaev&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment1310621_1461580&quot;&gt;&lt;span title=&quot;2009-09-22 19:40:50Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Sep 22, 2009 at 19:40&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;I believe, strictly, &quot;Value&quot; is defined in C as the interpretation of an object&apos;s bits according to a type. I have a hard time figuring out a useful meaning of that with an array type. Instead, you can say that you convert to a pointer, but that&apos;s not interpreting the array&apos;s contents, it just gets its location. What you get is the value of a pointer (and it&apos;s an address), not the value of an array (this would be &quot;the sequence of values of the contained items&quot;, as used in the definition of &quot;string&quot;). That said, i think it&apos;s fair to say &quot;value of array&quot; when one means the pointer one gets.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/34509/johannes-schaub-litb&quot; title=&quot;482,727 reputation&quot; class=&quot;comment-user&quot;&gt;Johannes Schaub - litb&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment1310744_1461580&quot;&gt;&lt;span title=&quot;2009-09-22 19:56:16Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Sep 22, 2009 at 19:56&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;anyway, i think there is a slight ambiguity: Value of an object, and value of an expression (as in, &quot;rvalue&quot;). If interpreted the latter way, then an array expression surely has a value: It&apos;s the one resulting from decaying it to an rvalue, and is the pointer expression. But if interpreted the former way, then of course there is no useful meaning for an array object.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/34509/johannes-schaub-litb&quot; title=&quot;482,727 reputation&quot; class=&quot;comment-user&quot;&gt;Johannes Schaub - litb&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment1310782_1461580&quot;&gt;&lt;span title=&quot;2009-09-22 20:01:20Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Sep 22, 2009 at 20:01&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;+1 for the phrase with a small fix; for arrays it&apos;s not even a triplet just a couplet [location, type]. Did you have something else in mind for the third location in array&apos;s case? I can&apos;t think of any.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/183120/legends2k&quot; title=&quot;29,643 reputation&quot; class=&quot;comment-user&quot;&gt;legends2k&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment38181461_1461580&quot;&gt;&lt;span title=&quot;2014-07-08 14:50:15Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jul 8, 2014 at 14:50&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 2 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@legends2k: I think I used the third location in arrays to avoid making them a special case of only having a couplet. Maybe [location, type, &lt;i&gt;void&lt;/i&gt;] would have been better.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/25324/pmg&quot; title=&quot;103,914 reputation&quot; class=&quot;comment-user&quot;&gt;pmg&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment38184220_1461580&quot;&gt;&lt;span title=&quot;2014-07-08 15:55:12Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jul 8, 2014 at 15:55&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Nicely said. What would be a nice array that does not decay to a pointer or one that is prevented from decaying? Can you cite an example in C? Thanks.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/2227834/unheilig&quot; title=&quot;15,964 reputation&quot; class=&quot;comment-user&quot;&gt;Unheilig&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment31625709_1461447&quot;&gt;&lt;span title=&quot;2014-01-10 05:20:51Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jan 10, 2014 at 5:20&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Unheilig, sure, one can vacuum-pack an array into struct and pass the struct.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/95382/michael-krelin-hacker&quot; title=&quot;132,233 reputation&quot; class=&quot;comment-user&quot;&gt;Michael Krelin - hacker&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment31631313_1461447&quot;&gt;&lt;span title=&quot;2014-01-10 09:13:55Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jan 10, 2014 at 9:13&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;I&apos;m not sure what do you mean by &quot;work&quot;. It&apos;s not allowed to access past the array, though it works as expected if you expect what is really to happen. That behaviour (though, again, officially undefined) is preserved.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/95382/michael-krelin-hacker&quot; title=&quot;132,233 reputation&quot; class=&quot;comment-user&quot;&gt;Michael Krelin - hacker&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment31655697_1461447&quot;&gt;&lt;span title=&quot;2014-01-10 20:08:32Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jan 10, 2014 at 20:08&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Decay also happens in many situations that are not passing the array anywhere (as described by other answers). For example, &lt;code&gt;a + 1&lt;/code&gt; .&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1505939/m-m&quot; title=&quot;135,063 reputation&quot; class=&quot;comment-user&quot;&gt;M.M&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment46414044_1461447&quot;&gt;&lt;span title=&quot;2015-03-17 03:42:32Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 17, 2015 at 3:42&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;decay happens in many other situations, not just passing an array to a function.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1505939/m-m&quot; title=&quot;135,063 reputation&quot; class=&quot;comment-user&quot;&gt;M.M&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment46414075_1461487&quot;&gt;&lt;span title=&quot;2015-03-17 03:44:47Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 17, 2015 at 3:44&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;arrays can be passed by reference to functions. And I don&apos;t get how &lt;code&gt;sizeof&lt;/code&gt; giving the size of the array instead of the pointer is an exception to functions not taking arrays as parameters. The common problem is that &lt;code&gt;sizeof&lt;/code&gt; does return the size of a pointer when used on a pointer originating from passing an array to a function&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/4117728/463035818-is-not-a-number&quot; title=&quot;90,229 reputation&quot; class=&quot;comment-user&quot;&gt;463035818_is_not_a_number&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment118077087_49253162&quot;&gt;&lt;span title=&quot;2021-03-25 10:35:07Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 25, 2021 at 10:35&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@largest_prime_is_463035818 : My TL;DR talked about using an array in general, not just about passing it to a function. Also, edited to clarify you can pass an array by reference.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1593077/einpoklum&quot; title=&quot;103,988 reputation&quot; class=&quot;comment-user&quot;&gt;einpoklum&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment118078741_49253162&quot;&gt;&lt;span title=&quot;2021-03-25 11:30:45Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 25, 2021 at 11:30&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;thanks, got it. &quot;Sort-of exception&quot; refers to the first line not to the &quot;Thus&quot; as I first misread it&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/4117728/463035818-is-not-a-number&quot; title=&quot;90,229 reputation&quot; class=&quot;comment-user&quot;&gt;463035818_is_not_a_number&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment118078853_49253162&quot;&gt;&lt;span title=&quot;2021-03-25 11:34:18Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 25, 2021 at 11:34&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        "],"id":129,"title":"What is array to pointer decay?","content":"\n                \n&lt;p&gt;What is array to pointer decay? Is there any relation to array pointers?&lt;/p&gt;\n    ","slug":"what-is-array-to-pointer-decay-1657384709608","postType":"QUESTION","createdAt":"2022-07-09T16:38:29.000Z","updatedAt":"2022-07-09T16:38:29.000Z","tags":[{"id":471,"name":"pointers","slug":"pointers","createdAt":"2022-07-09T16:38:29.000Z","updatedAt":"2022-07-09T16:38:29.000Z","Questions_Tags":{"questionId":129,"tagId":471}}]}},"__N_SSG":true}