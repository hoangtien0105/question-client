{"pageProps":{"data":{"answer":["\n&lt;p&gt;Python treats variables in functions differently depending on whether you assign values to them from inside or outside the function.  If a variable is assigned within a function, it is treated by default as a local variable.  Therefore, when you uncomment the line, you are trying to reference the local variable &lt;code&gt;c&lt;/code&gt; before any value has been assigned to it.&lt;/p&gt;\n&lt;p&gt;If you want the variable &lt;code&gt;c&lt;/code&gt; to refer to the global &lt;code&gt;c = 3&lt;/code&gt; assigned before the function, put&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;global&lt;/span&gt; c\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;as the first line of the function.&lt;/p&gt;\n&lt;p&gt;As for python 3, there is now&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;nonlocal&lt;/span&gt; c\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;that you can use to refer to the nearest enclosing function scope that has a &lt;code&gt;c&lt;/code&gt; variable.&lt;/p&gt;\n    ","\n&lt;p&gt;Python is a little weird in that it keeps everything in a dictionary for the various scopes.  The original a,b,c are in the uppermost scope and so in that uppermost dictionary.  The function has its own dictionary.  When you reach the &lt;code&gt;print(a)&lt;/code&gt; and &lt;code&gt;print(b)&lt;/code&gt; statements, there&apos;s nothing by that name in the dictionary, so Python looks up the list and finds them in the global dictionary.&lt;/p&gt;\n\n&lt;p&gt;Now we get to &lt;code&gt;c+=1&lt;/code&gt;, which is, of course, equivalent to &lt;code&gt;c=c+1&lt;/code&gt;.  When Python scans that line, it says &quot;aha, there&apos;s a variable named c, I&apos;ll put it into my local scope dictionary.&quot;  Then when it goes looking for a value for c for the c on the right hand side of the assignment, it finds its &lt;em&gt;local variable named c&lt;/em&gt;, which has no value yet, and so throws the error.&lt;/p&gt;\n\n&lt;p&gt;The statement &lt;code&gt;global c&lt;/code&gt; mentioned above simply tells the parser that it uses the &lt;code&gt;c&lt;/code&gt; from the global scope and so doesn&apos;t need a new one.&lt;/p&gt;\n\n&lt;p&gt;The reason it says there&apos;s an issue on the line it does is because it is effectively looking for the names before it tries to generate code, and so in some sense doesn&apos;t think it&apos;s really doing that line yet.  I&apos;d argue that is a usability bug, but it&apos;s generally a good practice to just learn not to take a compiler&apos;s messages &lt;em&gt;too&lt;/em&gt; seriously.&lt;/p&gt;\n\n&lt;p&gt;If it&apos;s any comfort, I spent probably a day digging and experimenting with this same issue before I found something Guido had written about the dictionaries that Explained Everything.&lt;/p&gt;\n\n&lt;h3&gt;Update, see comments:&lt;/h3&gt;\n\n&lt;p&gt;It doesn&apos;t scan the code twice, but it does scan the code in two phases, lexing and parsing.&lt;/p&gt;\n\n&lt;p&gt;Consider how the parse of this line of code works.  The lexer reads the source text and breaks it into lexemes, the &quot;smallest components&quot; of the grammar.  So when it hits the line&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;c+=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;it breaks it up into something like&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;SYMBOL(c) OPERATOR(+=) DIGIT(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The parser eventually wants to make this into a parse tree and execute it, but since it&apos;s an assignment, before it does, it looks for the name c in the local dictionary, doesn&apos;t see it, and inserts it in the dictionary, marking it as uninitialized. In a fully compiled language, it would just go into the symbol table and wait for the parse, but since it WON&apos;T have the luxury of a second pass, the lexer does a little extra work to make life easier later on.   Only, then it sees the OPERATOR, sees that the rules say &quot;if you have an operator += the left hand side must have been initialized&quot; and says &quot;whoops!&quot;&lt;/p&gt;\n\n&lt;p&gt;The point here is that it &lt;em&gt;hasn&apos;t really started the parse of the line yet&lt;/em&gt;.  This is all happening sort of preparatory to the actual parse, so the line counter hasn&apos;t advanced to the next line.  Thus when it signals the error, it still thinks its on the previous line.&lt;/p&gt;\n\n&lt;p&gt;As I say, you could argue it&apos;s a usability bug, but its actually a fairly common thing.  Some compilers are more honest about it and say &quot;error on or around line XXX&quot;, but this one doesn&apos;t.&lt;/p&gt;\n    ","\n&lt;p&gt;Taking a look at the disassembly may clarify what is happening:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;f&lt;/span&gt;():\n&lt;span class=&quot;hljs-meta&quot;&gt;... &lt;/span&gt;   &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; a\n&lt;span class=&quot;hljs-meta&quot;&gt;... &lt;/span&gt;   &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; b\n&lt;span class=&quot;hljs-meta&quot;&gt;... &lt;/span&gt;   a = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; dis\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;dis.dis(f)\n\n  &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;           &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; LOAD_FAST                &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; (a)\n              &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; PRINT_ITEM\n              &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; PRINT_NEWLINE\n\n  &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;           &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; LOAD_GLOBAL              &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; (b)\n              &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt; PRINT_ITEM\n              &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt; PRINT_NEWLINE\n\n  &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;          &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt; LOAD_CONST               &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; (&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)\n             &lt;span class=&quot;hljs-number&quot;&gt;13&lt;/span&gt; STORE_FAST               &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; (a)\n             &lt;span class=&quot;hljs-number&quot;&gt;16&lt;/span&gt; LOAD_CONST               &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; (&lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;)\n             &lt;span class=&quot;hljs-number&quot;&gt;19&lt;/span&gt; RETURN_VALUE\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;As you can see, the bytecode for accessing a is &lt;code&gt;LOAD_FAST&lt;/code&gt;, and for b, &lt;code&gt;LOAD_GLOBAL&lt;/code&gt;.  This is because the compiler has identified that a is assigned to within the function, and classified it as a local variable.  The access mechanism for locals is fundamentally different for globals - they are statically assigned an offset in the frame&apos;s variables table, meaning lookup is a quick index, rather than the more expensive dict lookup as for globals.  Because of this, Python is reading the &lt;code&gt;print a&lt;/code&gt; line as &quot;get the value of local variable &apos;a&apos; held in slot 0, and print it&quot;, and when it detects that this variable is still uninitialised, raises an exception.&lt;/p&gt;\n    ","\n&lt;p&gt;Python has rather interesting behavior when you try traditional global variable semantics.  I don&apos;t remember the details, but you can read the value of a variable declared in &apos;global&apos; scope just fine, but if you want to modify it, you have to use the &lt;code&gt;global&lt;/code&gt; keyword.  Try changing &lt;code&gt;test()&lt;/code&gt; to this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;test&lt;/span&gt;():\n    &lt;span class=&quot;hljs-keyword&quot;&gt;global&lt;/span&gt; c\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(a)\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(b)\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(c)    &lt;span class=&quot;hljs-comment&quot;&gt;# (A)&lt;/span&gt;\n    c+=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;        &lt;span class=&quot;hljs-comment&quot;&gt;# (B)&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Also, the reason you are getting this error is because you can also declare a new variable inside that function with the same name as a &apos;global&apos; one, and it would be completely separate.  The interpreter thinks you are trying to make a new variable in this scope called &lt;code&gt;c&lt;/code&gt; and modify it all in one operation, which isn&apos;t allowed in Python because this new &lt;code&gt;c&lt;/code&gt; wasn&apos;t initialized.&lt;/p&gt;\n    ","\n&lt;p&gt;The best example that makes it clear is:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;bar = &lt;span class=&quot;hljs-number&quot;&gt;42&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;foo&lt;/span&gt;():\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; bar\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;:\n        bar = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;when calling &lt;code&gt;foo()&lt;/code&gt; , this also &lt;strong&gt;raises&lt;/strong&gt; &lt;code&gt;UnboundLocalError&lt;/code&gt; although we will never reach to line &lt;code&gt;bar=0&lt;/code&gt;, so logically local variable should never be created.&lt;/p&gt;\n\n&lt;p&gt;The mystery lies in &quot;&lt;strong&gt;Python is an Interpreted Language&lt;/strong&gt;&quot; and the declaration of the function &lt;code&gt;foo&lt;/code&gt; is interpreted as a single statement (i.e. a compound statement), it just interprets it dumbly and creates local and global scopes. So &lt;code&gt;bar&lt;/code&gt; is recognized in local scope before execution.&lt;/p&gt;\n\n&lt;p&gt;For &lt;strong&gt;more examples&lt;/strong&gt; like this Read this post: &lt;a href=&quot;http://blog.amir.rachum.com/blog/2013/07/09/python-common-newbie-mistakes-part-2/&quot; rel=&quot;noreferrer&quot;&gt;http://blog.amir.rachum.com/blog/2013/07/09/python-common-newbie-mistakes-part-2/&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;This post provides a Complete Description and Analyses of the Python Scoping of variables:&lt;/p&gt;\n    ","\n&lt;p&gt;Here are two links that may help&lt;/p&gt;\n\n&lt;p&gt;1: &lt;a href=&quot;http://docs.python.org/3.1/faq/programming.html?highlight=nonlocal#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value&quot; rel=&quot;nofollow noreferrer&quot;&gt;docs.python.org/3.1/faq/programming.html?highlight=nonlocal#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;2: &lt;a href=&quot;http://docs.python.org/3.1/faq/programming.html?highlight=nonlocal#how-do-i-write-a-function-with-output-parameters-call-by-reference&quot; rel=&quot;nofollow noreferrer&quot;&gt;docs.python.org/3.1/faq/programming.html?highlight=nonlocal#how-do-i-write-a-function-with-output-parameters-call-by-reference&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;link one describes the error UnboundLocalError.  Link two can help with with re-writing your test function.  Based on link two, the original problem could be rewritten as:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a, b, c = (&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;)\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; (a, b, c)\n(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;)\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;test&lt;/span&gt; (a, b, c):\n&lt;span class=&quot;hljs-meta&quot;&gt;... &lt;/span&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; (a)\n&lt;span class=&quot;hljs-meta&quot;&gt;... &lt;/span&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; (b)\n&lt;span class=&quot;hljs-meta&quot;&gt;... &lt;/span&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; (c)\n&lt;span class=&quot;hljs-meta&quot;&gt;... &lt;/span&gt;    c += &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;... &lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a, b, c\n...\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a, b, c = test (a, b, c)\n&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; (a, b ,c)\n(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;This is not a direct answer to your question, but it is closely related, as it&apos;s another gotcha caused by the relationship between augmented assignment and function scopes.&lt;/p&gt;\n\n&lt;p&gt;In most cases, you tend to think of augmented assignment (&lt;code&gt;a += b&lt;/code&gt;) as exactly equivalent to simple assignment (&lt;code&gt;a = a + b&lt;/code&gt;). It is possible to get into some trouble with this though, in one corner case. Let me explain:&lt;/p&gt;\n\n&lt;p&gt;The way Python&apos;s simple assignment works means that if &lt;code&gt;a&lt;/code&gt; is passed into a function (like &lt;code&gt;func(a)&lt;/code&gt;; note that Python is always pass-by-reference), then &lt;code&gt;a = a + b&lt;/code&gt; will not modify the &lt;code&gt;a&lt;/code&gt; that is passed in. Instead, it will just modify the local pointer to &lt;code&gt;a&lt;/code&gt;. &lt;/p&gt;\n\n&lt;p&gt;But if you use &lt;code&gt;a += b&lt;/code&gt;, then it is sometimes implemented as:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;a = a + b\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or sometimes (if the method exists) as:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;a.__iadd__(b)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In the first case (as long as &lt;code&gt;a&lt;/code&gt; is not declared global), there are no side-effects outside local scope, as the assignment to &lt;code&gt;a&lt;/code&gt; is just a pointer update.&lt;/p&gt;\n\n&lt;p&gt;In the second case, &lt;code&gt;a&lt;/code&gt; will actually modify itself, so all references to &lt;code&gt;a&lt;/code&gt; will point to the modified version. This is demonstrated by the following code:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;copy_on_write&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;a&lt;/span&gt;):\n      a = a + a\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;inplace_add&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;a&lt;/span&gt;):\n      a += a\na = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]\ncopy_on_write(a)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; a &lt;span class=&quot;hljs-comment&quot;&gt;# [1]&lt;/span&gt;\ninplace_add(a)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; a &lt;span class=&quot;hljs-comment&quot;&gt;# [1, 1]&lt;/span&gt;\nb = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\ncopy_on_write(b)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; b &lt;span class=&quot;hljs-comment&quot;&gt;# [1]&lt;/span&gt;\ninplace_add(b)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; b &lt;span class=&quot;hljs-comment&quot;&gt;# 1&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So the trick is to avoid augmented assignment on function arguments (I try to only use it for local/loop variables). Use simple assignment, and you will be safe from ambiguous behaviour. &lt;/p&gt;\n    ","\n&lt;p&gt;The Python interpreter will read a function as a complete unit. I think of it as reading it in two passes, once to gather its closure (the local variables), then again to turn it into byte-code.&lt;/p&gt;\n\n&lt;p&gt;As I&apos;m sure you were already aware, any name used on the left of a &apos;=&apos; is implicitly a local variable. More than once I&apos;ve been caught out by changing a variable access to a += and it&apos;s suddenly a different variable.&lt;/p&gt;\n\n&lt;p&gt;I also wanted to point out it&apos;s not really anything to do with global scope specifically. You get the same behaviour with nested functions.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;code&gt;c+=1&lt;/code&gt; assigns &lt;code&gt;c&lt;/code&gt;, python assumes assigned variables are local, but in this case it hasn&apos;t been declared locally.&lt;/p&gt;\n\n&lt;p&gt;Either use the &lt;code&gt;global&lt;/code&gt; or &lt;code&gt;nonlocal&lt;/code&gt; keywords. &lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;nonlocal&lt;/code&gt; works only in python 3, so if you&apos;re using python 2 and don&apos;t want to make your variable global, you can use a mutable object:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;my_variables = { &lt;span class=&quot;hljs-comment&quot;&gt;# a mutable object&lt;/span&gt;\n    &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;test&lt;/span&gt;():\n    my_variables[&lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;] +=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n\ntest()\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;The best way to reach class variable is directly accesing by class name&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Employee&lt;/span&gt;:\n    counter=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n        Employee.counter+=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;You can also get this message if you define a variable with the same name as a method.&lt;/p&gt;\n&lt;p&gt;For example:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;teams&lt;/span&gt;():\n    ...\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;some_other_method&lt;/span&gt;():\n    teams = teams()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The solution, is to rename method &lt;code&gt;teams()&lt;/code&gt; to something else like &lt;code&gt;get_teams()&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;Since it is only used locally, the Python message is rather misleading!&lt;/p&gt;\n&lt;p&gt;You end up with something like this to get around it:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;teams&lt;/span&gt;():\n    ...\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;some_other_method&lt;/span&gt;():\n    teams = get_teams()\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;This issue can also occur when the &lt;code&gt;del&lt;/code&gt; keyword is utilized on the variable down the line, after initialization, typically in a loop or a conditional block.&lt;/p&gt;\n    ","\n&lt;p&gt;The same problem bothers me. Using &lt;code&gt;nonlocal&lt;/code&gt; and &lt;code&gt;global&lt;/code&gt; can solve the problem.&lt;br&gt;\nHowever, attention is needed for the usage of &lt;code&gt;nonlocal&lt;/code&gt;, it works for nested functions. However, at the module level, it does not work. See &lt;a href=&quot;https://www.programiz.com/python-programming/global-local-nonlocal-variables#Nonlocal%20Variables&quot; rel=&quot;nofollow noreferrer&quot;&gt;examples&lt;/a&gt; here.&lt;/p&gt;\n    "],"id":339,"title":"UnboundLocalError on local variable when reassigned after first use","content":"\n                \n&lt;p&gt;The following code works as expected in both Python 2.5 and 3.0:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;a, b, c = (&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;)\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(a, b, c)\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;test&lt;/span&gt;():\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(a)\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(b)\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(c)    &lt;span class=&quot;hljs-comment&quot;&gt;# (A)&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;#c+=1       # (B)&lt;/span&gt;\ntest()\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;However, when I uncomment line &lt;strong&gt;(B)&lt;/strong&gt;, I get an &lt;code&gt;UnboundLocalError: &apos;c&apos; not assigned&lt;/code&gt; at line &lt;strong&gt;(A)&lt;/strong&gt;. The values of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are printed correctly. This has me completely baffled for two reasons:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;Why is there a runtime error thrown at line &lt;strong&gt;(A)&lt;/strong&gt; because of a later statement on line &lt;strong&gt;(B)&lt;/strong&gt;?&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Why are variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; printed as expected, while &lt;code&gt;c&lt;/code&gt; raises an error?&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;The only explanation I can come up with is that a &lt;strong&gt;local&lt;/strong&gt; variable &lt;code&gt;c&lt;/code&gt; is created by the assignment &lt;code&gt;c+=1&lt;/code&gt;, which takes precedent over the &quot;global&quot; variable &lt;code&gt;c&lt;/code&gt; even before the local variable is created. Of course, it doesn&apos;t make sense for a variable to &quot;steal&quot; scope before it exists.&lt;/p&gt;\n\n&lt;p&gt;Could someone please explain this behavior?&lt;/p&gt;\n    ","slug":"unboundlocalerror-on-local-variable-when-reassigned-after-first-use-1657387685248","postType":"QUESTION","createdAt":"2022-07-09T17:28:05.000Z","updatedAt":"2022-07-09T17:28:05.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"What is the strict aliasing rule?","slug":"what-is-the-strict-aliasing-rule-1657384742852"},{"title":"Ways to deal with #document under iframe","slug":"ways-to-deal-with-document-under-iframe-1657388403345"},{"title":"How do I add a delay in a JavaScript loop?","slug":"how-do-i-add-a-delay-in-a-javascript-loop-1657388544679"},{"title":"What is the behavior of integer division?","slug":"what-is-the-behavior-of-integer-division-1657388222571"},{"title":"What is the best way to detect a mobile device?","slug":"what-is-the-best-way-to-detect-a-mobile-device-1657387665025"},{"title":"How do I write a correct micro-benchmark in Java?","slug":"how-do-i-write-a-correct-micro-benchmark-in-java-1657384488725"},{"title":"How do I list all files of a directory?","slug":"how-do-i-list-all-files-of-a-directory-1657388340404"},{"title":"Pandas conditional creation of a series/dataframe column","slug":"pandas-conditional-creation-of-a-seriesdataframe-column-1657387461003"},{"title":"Why does printf not flush after the call unless a newline is in the format string?","slug":"why-does-printf-not-flush-after-the-call-unless-a-newline-is-in-the-format-string-1657387853407"},{"title":"The model item passed into the dictionary is of type .. but this dictionary requires a model item of type","slug":"the-model-item-passed-into-the-dictionary-is-of-type-..-but-this-dictionary-requires-a-model-item-of-type-1657388480874"},{"title":"How to deal with mysqli problems? mysqli_fetch_array(): Argument #1 must be of type mysqli_result","slug":"how-to-deal-with-mysqli-problems-mysqli_fetch_array():-argument-1-must-be-of-type-mysqli_result-1657384360922"},{"title":"When to use virtual destructors?","slug":"when-to-use-virtual-destructors-1657388152135"},{"title":"Why does a RegExp with global flag give wrong results?","slug":"why-does-a-regexp-with-global-flag-give-wrong-results-1657387788550"},{"title":"How can I prevent SQL injection in PHP?","slug":"how-can-i-prevent-sql-injection-in-php-1657384220094"},{"title":"When should I wrap quotes around a shell variable?","slug":"when-should-i-wrap-quotes-around-a-shell-variable-1657384659265"},{"title":"What is the difference between client-side and server-side programming?","slug":"what-is-the-difference-between-client-side-and-server-side-programming-1657384372926"},{"title":"Do I cast the result of malloc?","slug":"do-i-cast-the-result-of-malloc-1657384271583"},{"title":"Converting string into datetime","slug":"converting-string-into-datetime-1657387717295"},{"title":"How can I tell if a DOM element is visible in the current viewport?","slug":"how-can-i-tell-if-a-dom-element-is-visible-in-the-current-viewport-1657388316510"},{"title":"Self-references in object literals / initializers","slug":"self-references-in-object-literals-initializers-1657384835356"}]},"__N_SSG":true}