<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2eccd4d47c856f2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2eccd4d47c856f2b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/471-84c36aa98dd4107c.js" defer=""></script><script src="/_next/static/chunks/81-096e453de8a27667.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-e3d1b60e109d3ba1.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_buildManifest.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.hFcsiD code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-6e32c308-0"]{content:"hFcsiD,"}/*!sc*/
.ljvTUN .comment-item .comment-body .d-inline-flex.ai-center{text-align:right;}/*!sc*/
.ljvTUN .comment-item .comment-body .comment-date{float:right;}/*!sc*/
data-styled.g6[id="sc-6e32c308-1"]{content:"ljvTUN,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="https://flowbite.com/docs/images/logo.svg" class="mr-3 h-6 sm:h-9" alt="Flowbite Logo"/><span class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Hunter</span></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/calculate-distance-between-two-latitude-longitude-points-(haversine-formula)-1657388500103#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-6e32c308-0 hFcsiD flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/calculate-distance-between-two-latitude-longitude-points-(haversine-formula)-1657388500103">Calculate distance between two latitude-longitude points? (Haversine formula)</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/haversine">haversine</a></div></div><div class="question-content mt-5">
                
<p>How do I calculate the distance between two points specified by latitude and longitude?</p>

<p>For clarification, I'd like the distance in kilometers; the points use the WGS84 system and I'd like to understand the relative accuracies of the approaches available.</p>
    </div></div></div><div class="sc-6e32c308-1 ljvTUN flex text-xs pl-10 flex-col comment items-center justify-center"><h4 class="text-left mt-10 text-lg font-semibold">Comments</h4><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy">For better accuracy - see <a href="https://stackoverflow.com/questions/1420045/how-to-find-distance-from-the-latitude-and-longitude-of-two-locations/1422562#1422562" title="how to find distance from the latitude and longitude of two locations">stackoverflow.com/questions/1420045/</a></span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/171006/lior-kogan" title="18,914 reputation" class="comment-user">Lior Kogan</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment77429769_27928"><span title="2017-07-21 07:54:19Z, License: CC BY-SA 3.0" class="relativetime-clean">Jul 21, 2017 at 7:54</span></a></span>
            </div>
        </div><span class="divide-x-8 "></span><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy">Note that you cannot apply a Haversine formula on an ellipsoid of revolution like WGS 84. You can only apply this method on a sphere with a radius.</span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/327026/mike-t" title="38,306 reputation" class="comment-user">Mike T</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment89909816_27928"><span title="2018-07-23 02:05:23Z, License: CC BY-SA 4.0" class="relativetime-clean">Jul 23, 2018 at 2:05</span></a></span>
            </div>
        </div><span class="divide-x-8 "></span><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy">Most of the answers here are using simple spherical trigonometry, so the results are rather crude compared to the WGS84 ellipsoid distances used in the GPS system. Some of the answers do refer to Vincenty's formula for ellipsoids, but that algorithm was designed for use on 1960s' era desk calculators and it has stability &amp; accuracy issues; we have better hardware and software now. Please see <a href="https://geographiclib.sourceforge.io/" rel="nofollow noreferrer">GeographicLib</a> for a high quality library with implementations in various languages.</span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/4014959/pm-2ring" title="52,419 reputation" class="comment-user">PM 2Ring</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment90310172_27928"><span title="2018-08-03 13:26:32Z, License: CC BY-SA 4.0" class="relativetime-clean">Aug 3, 2018 at 13:26</span></a></span>
            </div>
        </div><span class="divide-x-8 "></span><button class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">See more</button></div><div class="sc-6e32c308-2 bFXWFO"><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This <a href="http://www.movable-type.co.uk/scripts/latlong.html" rel="noreferrer">link</a> might be helpful to you, as it details the use of the <a href="http://en.wikipedia.org/wiki/Haversine_formula" rel="noreferrer">Haversine formula</a> to calculate the distance.</p>

<p>Excerpt:</p>



<blockquote>
  <p>This script [in Javascript] calculates great-circle distances between the two points 
  that is, the shortest distance over the earths surface  using the
  Haversine formula.</p>
</blockquote>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDistanceFromLatLonInKm</span>(<span class="hljs-params">lat1,lon1,lat2,lon2</span>) {
  <span class="hljs-keyword">var</span> R = <span class="hljs-number">6371</span>; <span class="hljs-comment">// Radius of the earth in km</span>
  <span class="hljs-keyword">var</span> dLat = <span class="hljs-title function_">deg2rad</span>(lat2-lat1);  <span class="hljs-comment">// deg2rad below</span>
  <span class="hljs-keyword">var</span> dLon = <span class="hljs-title function_">deg2rad</span>(lon2-lon1); 
  <span class="hljs-keyword">var</span> a = 
    <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(dLat/<span class="hljs-number">2</span>) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(dLat/<span class="hljs-number">2</span>) +
    <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(<span class="hljs-title function_">deg2rad</span>(lat1)) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(<span class="hljs-title function_">deg2rad</span>(lat2)) * 
    <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(dLon/<span class="hljs-number">2</span>) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(dLon/<span class="hljs-number">2</span>)
    ; 
  <span class="hljs-keyword">var</span> c = <span class="hljs-number">2</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">atan2</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(a), <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(<span class="hljs-number">1</span>-a)); 
  <span class="hljs-keyword">var</span> d = R * c; <span class="hljs-comment">// Distance in km</span>
  <span class="hljs-keyword">return</span> d;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">deg2rad</span>(<span class="hljs-params">deg</span>) {
  <span class="hljs-keyword">return</span> deg * (<span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>/<span class="hljs-number">180</span>)
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I needed to calculate a lot of distances between the points for my project, so I went ahead and tried to optimize the code, I have found here. On average in different browsers my new implementation <strong>runs 2 times faster</strong> than the most upvoted answer.</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">distance</span>(<span class="hljs-params">lat1, lon1, lat2, lon2</span>) {
  <span class="hljs-keyword">var</span> p = <span class="hljs-number">0.017453292519943295</span>;    <span class="hljs-comment">// Math.PI / 180</span>
  <span class="hljs-keyword">var</span> c = <span class="hljs-title class_">Math</span>.<span class="hljs-property">cos</span>;
  <span class="hljs-keyword">var</span> a = <span class="hljs-number">0.5</span> - <span class="hljs-title function_">c</span>((lat2 - lat1) * p)/<span class="hljs-number">2</span> + 
          <span class="hljs-title function_">c</span>(lat1 * p) * <span class="hljs-title function_">c</span>(lat2 * p) * 
          (<span class="hljs-number">1</span> - <span class="hljs-title function_">c</span>((lon2 - lon1) * p))/<span class="hljs-number">2</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-number">12742</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">asin</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(a)); <span class="hljs-comment">// 2 * R; R = 6371 km</span>
}
</code></pre>
<p>You can play with my jsPerf and see the <a href="http://jsperf.com/haversine-salvador/8" rel="noreferrer">results here</a>.</p>
<p>Recently I needed to do the same in python, so here is a <strong>python implementation</strong>:</p>
<pre class="lang-python s-code-block"><code class="hljs language-python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> cos, asin, sqrt, pi

<span class="hljs-keyword">def</span> <span class="hljs-title function_">distance</span>(<span class="hljs-params">lat1, lon1, lat2, lon2</span>):
    p = pi/<span class="hljs-number">180</span>
    a = <span class="hljs-number">0.5</span> - cos((lat2-lat1)*p)/<span class="hljs-number">2</span> + cos(lat1*p) * cos(lat2*p) * (<span class="hljs-number">1</span>-cos((lon2-lon1)*p))/<span class="hljs-number">2</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">12742</span> * asin(sqrt(a)) <span class="hljs-comment">#2*R*asin...</span>
</code></pre>
<p>And for the sake of completeness: <a href="https://en.wikipedia.org/wiki/Haversine_formula" rel="noreferrer">Haversine</a> on Wikipedia.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is a C# Implementation:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DistanceAlgorithm</span>
{
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> PIx = <span class="hljs-number">3.141592653589793</span>;
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> RADIUS = <span class="hljs-number">6378.16</span>;

    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> Convert degrees to Radians</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="x"&gt;</span>Degrees<span class="hljs-doctag">&lt;/param&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>The equivalent in radians<span class="hljs-doctag">&lt;/returns&gt;</span></span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Radians</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> x</span>)</span>
    {
        <span class="hljs-keyword">return</span> x * PIx / <span class="hljs-number">180</span>;
    }

    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> Calculate the distance between two places.</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="lon1"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="lat1"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="lon2"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="lat2"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> <span class="hljs-title">DistanceBetweenPlaces</span>(<span class="hljs-params">
        <span class="hljs-built_in">double</span> lon1,
        <span class="hljs-built_in">double</span> lat1,
        <span class="hljs-built_in">double</span> lon2,
        <span class="hljs-built_in">double</span> lat2</span>)</span>
    {
        <span class="hljs-built_in">double</span> dlon = Radians(lon2 - lon1);
        <span class="hljs-built_in">double</span> dlat = Radians(lat2 - lat1);

        <span class="hljs-built_in">double</span> a = (Math.Sin(dlat / <span class="hljs-number">2</span>) * Math.Sin(dlat / <span class="hljs-number">2</span>)) + Math.Cos(Radians(lat1)) * Math.Cos(Radians(lat2)) * (Math.Sin(dlon / <span class="hljs-number">2</span>) * Math.Sin(dlon / <span class="hljs-number">2</span>));
        <span class="hljs-built_in">double</span> angle = <span class="hljs-number">2</span> * Math.Atan2(Math.Sqrt(a), Math.Sqrt(<span class="hljs-number">1</span> - a));
        <span class="hljs-keyword">return</span> angle * RADIUS;
    }

}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is a java implementation of the Haversine formula.</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-variable">AVERAGE_RADIUS_OF_EARTH_KM</span> <span class="hljs-operator">=</span> <span class="hljs-number">6371</span>;
<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateDistanceInKilometer</span><span class="hljs-params">(<span class="hljs-type">double</span> userLat, <span class="hljs-type">double</span> userLng,
  <span class="hljs-type">double</span> venueLat, <span class="hljs-type">double</span> venueLng)</span> {

    <span class="hljs-type">double</span> <span class="hljs-variable">latDistance</span> <span class="hljs-operator">=</span> Math.toRadians(userLat - venueLat);
    <span class="hljs-type">double</span> <span class="hljs-variable">lngDistance</span> <span class="hljs-operator">=</span> Math.toRadians(userLng - venueLng);

    <span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Math.sin(latDistance / <span class="hljs-number">2</span>) * Math.sin(latDistance / <span class="hljs-number">2</span>)
      + Math.cos(Math.toRadians(userLat)) * Math.cos(Math.toRadians(venueLat))
      * Math.sin(lngDistance / <span class="hljs-number">2</span>) * Math.sin(lngDistance / <span class="hljs-number">2</span>);

    <span class="hljs-type">double</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * Math.atan2(Math.sqrt(a), Math.sqrt(<span class="hljs-number">1</span> - a));

    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (Math.round(AVERAGE_RADIUS_OF_EARTH_KM * c));
}
</code></pre>

<p>Note that here we are rounding the answer to the nearest km.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Thanks very much for all this. I used the following code in my Objective-C iPhone app:</p>



<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">const</span> <span class="hljs-type">double</span> PIx = <span class="hljs-number">3.141592653589793</span>;
<span class="hljs-type">const</span> <span class="hljs-type">double</span> RADIO = <span class="hljs-number">6371</span>; <span class="hljs-comment">// Mean radius of Earth in Km</span>

<span class="hljs-type">double</span> <span class="hljs-title function_">convertToRadians</span><span class="hljs-params">(<span class="hljs-type">double</span> val)</span> {

   <span class="hljs-keyword">return</span> val * PIx / <span class="hljs-number">180</span>;
}

-(<span class="hljs-type">double</span>)kilometresBetweenPlace1:(CLLocationCoordinate2D) place1 andPlace2:(CLLocationCoordinate2D) place2 {

        <span class="hljs-type">double</span> dlon = convertToRadians(place2.longitude - place1.longitude);
        <span class="hljs-type">double</span> dlat = convertToRadians(place2.latitude - place1.latitude);

        <span class="hljs-type">double</span> a = ( <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">sin</span>(dlat / <span class="hljs-number">2</span>), <span class="hljs-number">2</span>) + <span class="hljs-built_in">cos</span>(convertToRadians(place1.latitude))) * <span class="hljs-built_in">cos</span>(convertToRadians(place2.latitude)) * <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">sin</span>(dlon / <span class="hljs-number">2</span>), <span class="hljs-number">2</span>);
        <span class="hljs-type">double</span> angle = <span class="hljs-number">2</span> * <span class="hljs-built_in">asin</span>(<span class="hljs-built_in">sqrt</span>(a));

        <span class="hljs-keyword">return</span> angle * RADIO;
}
</code></pre>

<p>Latitude and Longitude are in decimal. I didn't use min() for the asin() call as the distances that I'm using are so small that they don't require it.</p>

<p>It gave incorrect answers until I passed in the values in Radians - now it's pretty much the same as the values obtained from Apple's Map app :-)</p>

<p>Extra update:</p>

<p>If you are using iOS4 or later then Apple provide some methods to do this so the same functionality would be achieved with:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">-(<span class="hljs-type">double</span>)kilometresBetweenPlace1:(CLLocationCoordinate2D) place1 andPlace2:(CLLocationCoordinate2D) place2 {

    MKMapPoint  start, finish;


    start = MKMapPointForCoordinate(place1);
    finish = MKMapPointForCoordinate(place2);

    <span class="hljs-keyword">return</span> MKMetersBetweenMapPoints(start, finish) / <span class="hljs-number">1000</span>;
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This is a simple PHP function that will give a very reasonable approximation (under +/-1% error margin).  </p>

<pre class="lang-php s-code-block"><code class="hljs language-php"><span class="hljs-meta">&lt;?php</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">distance</span>(<span class="hljs-params"><span class="hljs-variable">$lat1</span>, <span class="hljs-variable">$lon1</span>, <span class="hljs-variable">$lat2</span>, <span class="hljs-variable">$lon2</span></span>) </span>{

    <span class="hljs-variable">$pi80</span> = M_PI / <span class="hljs-number">180</span>;
    <span class="hljs-variable">$lat1</span> *= <span class="hljs-variable">$pi80</span>;
    <span class="hljs-variable">$lon1</span> *= <span class="hljs-variable">$pi80</span>;
    <span class="hljs-variable">$lat2</span> *= <span class="hljs-variable">$pi80</span>;
    <span class="hljs-variable">$lon2</span> *= <span class="hljs-variable">$pi80</span>;

    <span class="hljs-variable">$r</span> = <span class="hljs-number">6372.797</span>; <span class="hljs-comment">// mean radius of Earth in km</span>
    <span class="hljs-variable">$dlat</span> = <span class="hljs-variable">$lat2</span> - <span class="hljs-variable">$lat1</span>;
    <span class="hljs-variable">$dlon</span> = <span class="hljs-variable">$lon2</span> - <span class="hljs-variable">$lon1</span>;
    <span class="hljs-variable">$a</span> = <span class="hljs-title function_ invoke__">sin</span>(<span class="hljs-variable">$dlat</span> / <span class="hljs-number">2</span>) * <span class="hljs-title function_ invoke__">sin</span>(<span class="hljs-variable">$dlat</span> / <span class="hljs-number">2</span>) + <span class="hljs-title function_ invoke__">cos</span>(<span class="hljs-variable">$lat1</span>) * <span class="hljs-title function_ invoke__">cos</span>(<span class="hljs-variable">$lat2</span>) * <span class="hljs-title function_ invoke__">sin</span>(<span class="hljs-variable">$dlon</span> / <span class="hljs-number">2</span>) * <span class="hljs-title function_ invoke__">sin</span>(<span class="hljs-variable">$dlon</span> / <span class="hljs-number">2</span>);
    <span class="hljs-variable">$c</span> = <span class="hljs-number">2</span> * <span class="hljs-title function_ invoke__">atan2</span>(<span class="hljs-title function_ invoke__">sqrt</span>(<span class="hljs-variable">$a</span>), <span class="hljs-title function_ invoke__">sqrt</span>(<span class="hljs-number">1</span> - <span class="hljs-variable">$a</span>));
    <span class="hljs-variable">$km</span> = <span class="hljs-variable">$r</span> * <span class="hljs-variable">$c</span>;

    <span class="hljs-comment">//echo '&lt;br/&gt;'.$km;</span>
    <span class="hljs-keyword">return</span> <span class="hljs-variable">$km</span>;
}
<span class="hljs-meta">?&gt;</span>
</code></pre>

<p>As said before; the earth is NOT a sphere.  It is like an old, old baseball that Mark McGwire decided to practice with - it is full of dents and bumps.  The simpler calculations (like this) treat it like a sphere.</p>

<p>Different methods may be more or less precise according to where you are on this irregular ovoid AND how far apart your points are (the closer they are the smaller the absolute error margin).  The more precise your expectation, the more complex the math.</p>

<p>For more info: <a href="http://en.wikipedia.org/wiki/Geographical_distance" rel="noreferrer">wikipedia geographic distance</a></p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I post here my working example.</p>

<p>List all points in table having distance between a designated point (we use a random point - lat:45.20327, long:23.7806) less than 50 KM, with latitude &amp; longitude, in MySQL (the table fields are coord_lat and coord_long):</p>

<p><strong>List all having DISTANCE&lt;50, in Kilometres (considered Earth radius 6371 KM):</strong></p>

<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> denumire, (<span class="hljs-number">6371</span> <span class="hljs-operator">*</span> <span class="hljs-built_in">acos</span>( <span class="hljs-built_in">cos</span>( radians(<span class="hljs-number">45.20327</span>) ) <span class="hljs-operator">*</span> <span class="hljs-built_in">cos</span>( radians( coord_lat ) ) <span class="hljs-operator">*</span> <span class="hljs-built_in">cos</span>( radians( <span class="hljs-number">23.7806</span> ) <span class="hljs-operator">-</span> radians(coord_long) ) <span class="hljs-operator">+</span> <span class="hljs-built_in">sin</span>( radians(<span class="hljs-number">45.20327</span>) ) <span class="hljs-operator">*</span> <span class="hljs-built_in">sin</span>( radians(coord_lat) ) )) <span class="hljs-keyword">AS</span> distanta 
<span class="hljs-keyword">FROM</span> obiective 
<span class="hljs-keyword">WHERE</span> coord_lat<span class="hljs-operator">&lt;&gt;</span><span class="hljs-string">''</span> 
    <span class="hljs-keyword">AND</span> coord_long<span class="hljs-operator">&lt;&gt;</span><span class="hljs-string">''</span> 
<span class="hljs-keyword">HAVING</span> distanta<span class="hljs-operator">&lt;</span><span class="hljs-number">50</span> 
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> distanta <span class="hljs-keyword">desc</span>
</code></pre>

<p>The above example was tested in MySQL 5.0.95 and 5.5.16 (Linux). </p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In the other answers an implementation in <a href="/questions/tagged/r" class="post-tag" title="show questions tagged 'r'" rel="tag">r</a> is missing.</p>

<p>Calculating the distance between two point is quite straightforward with the <code>distm</code> function from the <code>geosphere</code> package:</p>

<pre><code>distm(p1, p2, fun = distHaversine)
</code></pre>

<p>where:</p>

<pre><code>p1 = longitude/latitude for point(s)
p2 = longitude/latitude for point(s)
# type of distance calculation
fun = distCosine / distHaversine / distVincentySphere / distVincentyEllipsoid 
</code></pre>

<p>As the earth is not perfectly spherical, the <a href="http://en.wikipedia.org/wiki/Vincenty%27s_formulae" rel="noreferrer">Vincenty formula for ellipsoids</a> is probably the best way to calculate distances. Thus in the <code>geosphere</code> package you use then:</p>

<pre><code>distm(p1, p2, fun = distVincentyEllipsoid)
</code></pre>

<hr>

<p>Off course you don't necessarily have to use <code>geosphere</code> package, you can also calculate the distance in base <code>R</code> with a function:</p>

<pre><code>hav.dist &lt;- function(long1, lat1, long2, lat2) {
  R &lt;- 6371
  diff.long &lt;- (long2 - long1)
  diff.lat &lt;- (lat2 - lat1)
  a &lt;- sin(diff.lat/2)^2 + cos(lat1) * cos(lat2) * sin(diff.long/2)^2
  b &lt;- 2 * asin(pmin(1, sqrt(a))) 
  d = R * b
  return(d)
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The haversine is definitely a good formula for probably most cases, other answers already include it so I am not going to take the space. But it is important to note that no matter what formula is used (yes not just one). Because of the huge range of accuracy possible as well as the computation time required. The choice of formula requires a bit more thought than a simple no brainer answer. </p>

<p>This posting from a person at nasa, is the best one I found at discussing the options</p>

<p><a href="http://www.cs.nyu.edu/visual/home/proj/tiger/gisfaq.html" rel="noreferrer">http://www.cs.nyu.edu/visual/home/proj/tiger/gisfaq.html</a></p>

<p>For example, if you are just sorting rows by distance in a 100 miles radius. The flat earth formula will be much faster than the haversine.</p>

<pre><code>HalfPi = 1.5707963;
R = 3956; /* the radius gives you the measurement unit*/

a = HalfPi - latoriginrad;
b = HalfPi - latdestrad;
u = a * a + b * b;
v = - 2 * a * b * cos(longdestrad - longoriginrad);
c = sqrt(abs(u + v));
return R * c;
</code></pre>

<p>Notice there is just one cosine and one square root. Vs 9 of them on the Haversine formula.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There could be a simpler solution, and more correct: The perimeter of earth is 40,000Km at the equator, about 37,000 on Greenwich (or any longitude) cycle. Thus:</p>

<pre><code>pythagoras = function (lat1, lon1, lat2, lon2) {
   function sqr(x) {return x * x;}
   function cosDeg(x) {return Math.cos(x * Math.PI / 180.0);}

   var earthCyclePerimeter = 40000000.0 * cosDeg((lat1 + lat2) / 2.0);
   var dx = (lon1 - lon2) * earthCyclePerimeter / 360.0;
   var dy = 37000000.0 * (lat1 - lat2) / 360.0;

   return Math.sqrt(sqr(dx) + sqr(dy));
};
</code></pre>

<p>I agree that it should be fine-tuned as, I myself said that it's an ellipsoid, so the radius to be multiplied by the cosine varies. But it's a bit more accurate. Compared with Google Maps and it did reduce the error significantly.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>All the above answers assumes the earth is a sphere. However, a more accurate approximation would be that of an oblate spheroid.</p>

<pre><code>a= 6378.137#equitorial radius in km
b= 6356.752#polar radius in km

def Distance(lat1, lons1, lat2, lons2):
    lat1=math.radians(lat1)
    lons1=math.radians(lons1)
    R1=(((((a**2)*math.cos(lat1))**2)+(((b**2)*math.sin(lat1))**2))/((a*math.cos(lat1))**2+(b*math.sin(lat1))**2))**0.5 #radius of earth at lat1
    x1=R*math.cos(lat1)*math.cos(lons1)
    y1=R*math.cos(lat1)*math.sin(lons1)
    z1=R*math.sin(lat1)

    lat2=math.radians(lat2)
    lons2=math.radians(lons2)
    R1=(((((a**2)*math.cos(lat2))**2)+(((b**2)*math.sin(lat2))**2))/((a*math.cos(lat2))**2+(b*math.sin(lat2))**2))**0.5 #radius of earth at lat2
    x2=R*math.cos(lat2)*math.cos(lons2)
    y2=R*math.cos(lat2)*math.sin(lons2)
    z2=R*math.sin(lat2)

    return ((x1-x2)**2+(y1-y2)**2+(z1-z2)**2)**0.5
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><code>pip install haversine</code></p>
<p>Python implementation</p>
<p>Origin is the center of the contiguous United States.</p>
<pre><code>from haversine import haversine, Unit
origin = (39.50, 98.35)
paris = (48.8567, 2.3508)
haversine(origin, paris, unit=Unit.MILES)
</code></pre>
<p>To get the answer in kilometers simply set <code>unit=Unit.KILOMETERS</code> (that's the default).</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I don't like adding yet another answer, but the Google maps API v.3 has spherical geometry (and more). After converting your WGS84 to decimal degrees you can do this:</p>

<pre><code>&lt;script src="http://maps.google.com/maps/api/js?sensor=false&amp;libraries=geometry" type="text/javascript"&gt;&lt;/script&gt;  

distance = google.maps.geometry.spherical.computeDistanceBetween(
    new google.maps.LatLng(fromLat, fromLng), 
    new google.maps.LatLng(toLat, toLng));
</code></pre>

<p>No word about how accurate Google's calculations are or even what model is used (though it does say "spherical" rather than "geoid".  By the way, the "straight line" distance will obviously be different from the distance if one travels on the surface of the earth which is what everyone seems to be presuming.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You can use the build in CLLocationDistance to calculate this:</p>

<pre><code>CLLocation *location1 = [[CLLocation alloc] initWithLatitude:latitude1 longitude:longitude1];
CLLocation *location2 = [[CLLocation alloc] initWithLatitude:latitude2 longitude:longitude2];
[self distanceInMetersFromLocation:location1 toLocation:location2]

- (int)distanceInMetersFromLocation:(CLLocation*)location1 toLocation:(CLLocation*)location2 {
    CLLocationDistance distanceInMeters = [location1 distanceFromLocation:location2];
    return distanceInMeters;
}
</code></pre>

<p>In your case if you want kilometers just divide by 1000.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is a <strong>typescript</strong> implementation of the Haversine formula</p>

<pre><code>static getDistanceFromLatLonInKm(lat1: number, lon1: number, lat2: number, lon2: number): number {
    var deg2Rad = deg =&gt; {
        return deg * Math.PI / 180;
    }

    var r = 6371; // Radius of the earth in km
    var dLat = deg2Rad(lat2 - lat1);   
    var dLon = deg2Rad(lon2 - lon1);
    var a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(deg2Rad(lat1)) * Math.cos(deg2Rad(lat2)) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2);
    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    var d = r * c; // Distance in km
    return d;
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As pointed out, an accurate calculation should take into account that the earth is not a perfect sphere. Here are some comparisons of the various algorithms offered here:</p>

<pre><code>geoDistance(50,5,58,3)
Haversine: 899 km
Maymenn: 833 km
Keerthana: 897 km
google.maps.geometry.spherical.computeDistanceBetween(): 900 km

geoDistance(50,5,-58,-3)
Haversine: 12030 km
Maymenn: 11135 km
Keerthana: 10310 km
google.maps.geometry.spherical.computeDistanceBetween(): 12044 km

geoDistance(.05,.005,.058,.003)
Haversine: 0.9169 km
Maymenn: 0.851723 km
Keerthana: 0.917964 km
google.maps.geometry.spherical.computeDistanceBetween(): 0.917964 km

geoDistance(.05,80,.058,80.3)
Haversine: 33.37 km
Maymenn: 33.34 km
Keerthana: 33.40767 km
google.maps.geometry.spherical.computeDistanceBetween(): 33.40770 km
</code></pre>

<p>Over small distances, Keerthana's algorithm does seem to coincide with that of Google Maps. Google Maps does not seem to follow any simple algorithm, suggesting that it may be the most accurate method here.</p>

<p>Anyway, here is a Javascript implementation of Keerthana's algorithm:</p>

<pre><code>function geoDistance(lat1, lng1, lat2, lng2){
    const a = 6378.137; // equitorial radius in km
    const b = 6356.752; // polar radius in km

    var sq = x =&gt; (x*x);
    var sqr = x =&gt; Math.sqrt(x);
    var cos = x =&gt; Math.cos(x);
    var sin = x =&gt; Math.sin(x);
    var radius = lat =&gt; sqr((sq(a*a*cos(lat))+sq(b*b*sin(lat)))/(sq(a*cos(lat))+sq(b*sin(lat))));

    lat1 = lat1 * Math.PI / 180;
    lng1 = lng1 * Math.PI / 180;
    lat2 = lat2 * Math.PI / 180;
    lng2 = lng2 * Math.PI / 180;

    var R1 = radius(lat1);
    var x1 = R1*cos(lat1)*cos(lng1);
    var y1 = R1*cos(lat1)*sin(lng1);
    var z1 = R1*sin(lat1);

    var R2 = radius(lat2);
    var x2 = R2*cos(lat2)*cos(lng2);
    var y2 = R2*cos(lat2)*sin(lng2);
    var z2 = R2*sin(lat2);

    return sqr(sq(x1-x2)+sq(y1-y2)+sq(z1-z2));
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is the SQL Implementation to calculate the distance in km,</p>

<pre><code>SELECT UserId, ( 3959 * acos( cos( radians( your latitude here ) ) * cos( radians(latitude) ) * 
cos( radians(longitude) - radians( your longitude here ) ) + sin( radians( your latitude here ) ) * 
sin( radians(latitude) ) ) ) AS distance FROM user HAVING
distance &lt; 5  ORDER BY distance LIMIT 0 , 5;
</code></pre>

<p>For further details in the implementation by programming langugage, you can just go through the php script given <a href="https://www.geodatasource.com/developers/php" rel="nofollow noreferrer">here</a></p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 18</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This script [in PHP] calculates distances between the two points.</p>

<pre><code>public static function getDistanceOfTwoPoints($source, $dest, $unit='K') {
        $lat1 = $source[0];
        $lon1 = $source[1];
        $lat2 = $dest[0];
        $lon2 = $dest[1];

        $theta = $lon1 - $lon2;
        $dist = sin(deg2rad($lat1)) * sin(deg2rad($lat2)) +  cos(deg2rad($lat1)) * cos(deg2rad($lat2)) * cos(deg2rad($theta));
        $dist = acos($dist);
        $dist = rad2deg($dist);
        $miles = $dist * 60 * 1.1515;
        $unit = strtoupper($unit);

        if ($unit == "K") {
            return ($miles * 1.609344);
        }
        else if ($unit == "M")
        {
            return ($miles * 1.609344 * 1000);
        }
        else if ($unit == "N") {
            return ($miles * 0.8684);
        } 
        else {
            return $miles;
        }
    }
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 19</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<blockquote>
  <p>Java implementation in according <a href="https://en.wikipedia.org/wiki/Haversine_formula" rel="nofollow noreferrer">Haversine formula</a></p>
</blockquote>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">double</span> <span class="hljs-title function_">calculateDistance</span><span class="hljs-params">(<span class="hljs-type">double</span> latPoint1, <span class="hljs-type">double</span> lngPoint1, 
                         <span class="hljs-type">double</span> latPoint2, <span class="hljs-type">double</span> lngPoint2)</span> {
    <span class="hljs-keyword">if</span>(latPoint1 == latPoint2 &amp;&amp; lngPoint1 == lngPoint2) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0d</span>;
    }

    <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">EARTH_RADIUS</span> <span class="hljs-operator">=</span> <span class="hljs-number">6371.0</span>; <span class="hljs-comment">//km value;</span>

    <span class="hljs-comment">//converting to radians</span>
    latPoint1 = Math.toRadians(latPoint1);
    lngPoint1 = Math.toRadians(lngPoint1);
    latPoint2 = Math.toRadians(latPoint2);
    lngPoint2 = Math.toRadians(lngPoint2);

    <span class="hljs-type">double</span> <span class="hljs-variable">distance</span> <span class="hljs-operator">=</span> Math.pow(Math.sin((latPoint2 - latPoint1) / <span class="hljs-number">2.0</span>), <span class="hljs-number">2</span>) 
            + Math.cos(latPoint1) * Math.cos(latPoint2)
            * Math.pow(Math.sin((lngPoint2 - lngPoint1) / <span class="hljs-number">2.0</span>), <span class="hljs-number">2</span>);
    distance = <span class="hljs-number">2.0</span> * EARTH_RADIUS * Math.asin(Math.sqrt(distance));

    <span class="hljs-keyword">return</span> distance; <span class="hljs-comment">//km value</span>
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 20</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>To calculate the distance between two points on a sphere you need to do the <a href="http://en.wikipedia.org/wiki/Great-circle_distance" rel="nofollow noreferrer">Great Circle calculation</a>. </p>

<p>There are a number of C/C++ libraries to help with map projection at <a href="http://www.maptools.org/" rel="nofollow noreferrer">MapTools</a> if you need to reproject your distances to a flat surface.  To do this you will need the projection string of the various coordinate systems.</p>

<p>You may also find <a href="http://www.mapwindow.org/" rel="nofollow noreferrer">MapWindow</a> a useful tool to visualise the points.  Also as its open source its a useful guide to how to use the proj.dll library, which appears to be the core open source projection library.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 21</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is my java implementation for calculation distance via decimal degrees after some search. I used mean radius of world (from wikipedia) in km. İf you want result miles then use world radius in miles.</p>

<pre><code>public static double distanceLatLong2(double lat1, double lng1, double lat2, double lng2) 
{
  double earthRadius = 6371.0d; // KM: use mile here if you want mile result

  double dLat = toRadian(lat2 - lat1);
  double dLng = toRadian(lng2 - lng1);

  double a = Math.pow(Math.sin(dLat/2), 2)  + 
          Math.cos(toRadian(lat1)) * Math.cos(toRadian(lat2)) * 
          Math.pow(Math.sin(dLng/2), 2);

  double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

  return earthRadius * c; // returns result kilometers
}

public static double toRadian(double degrees) 
{
  return (degrees * Math.PI) / 180.0d;
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 22</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here's the accepted answer implementation ported to Java in case anyone needs it.</p>

<pre><code>package com.project529.garage.util;


/**
 * Mean radius.
 */
private static double EARTH_RADIUS = 6371;

/**
 * Returns the distance between two sets of latitudes and longitudes in meters.
 * &lt;p/&gt;
 * Based from the following JavaScript SO answer:
 * http://stackoverflow.com/questions/27928/calculate-distance-between-two-latitude-longitude-points-haversine-formula,
 * which is based on https://en.wikipedia.org/wiki/Haversine_formula (error rate: ~0.55%).
 */
public double getDistanceBetween(double lat1, double lon1, double lat2, double lon2) {
    double dLat = toRadians(lat2 - lat1);
    double dLon = toRadians(lon2 - lon1);

    double a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(toRadians(lat1)) * Math.cos(toRadians(lat2)) *
                    Math.sin(dLon / 2) * Math.sin(dLon / 2);
    double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    double d = EARTH_RADIUS * c;

    return d;
}

public double toRadians(double degrees) {
    return degrees * (Math.PI / 180);
}
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 23</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>here is an example in <strong>postgres</strong> sql (in km, for miles version, replace 1.609344 by 0.8684 version)</p>

<pre><code>CREATE OR REPLACE FUNCTION public.geodistance(alat float, alng float, blat  

float, blng  float)
  RETURNS float AS
$BODY$
DECLARE
    v_distance float;
BEGIN

    v_distance = asin( sqrt(
            sin(radians(blat-alat)/2)^2 
                + (
                    (sin(radians(blng-alng)/2)^2) *
                    cos(radians(alat)) *
                    cos(radians(blat))
                )
          )
        ) * cast('7926.3352' as float) * cast('1.609344' as float) ;


    RETURN v_distance;
END 
$BODY$
language plpgsql VOLATILE SECURITY DEFINER;
alter function geodistance(alat float, alng float, blat float, blng float)
owner to postgres;
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 24</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>For those looking for an Excel formula based on WGS-84 &amp; GRS-80 standards:</p>

<pre><code>=ACOS(COS(RADIANS(90-Lat1))*COS(RADIANS(90-Lat2))+SIN(RADIANS(90-Lat1))*SIN(RADIANS(90-Lat2))*COS(RADIANS(Long1-Long2)))*6371
</code></pre>

<p><a href="https://bluemm.blogspot.com/2007/01/excel-formula-to-calculate-distance.html" rel="nofollow noreferrer">Source</a></p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 25</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I made a custom function in R to calculate haversine distance(km) between two spatial points using functions available in R base package.</p>
<pre><code>custom_hav_dist &lt;- function(lat1, lon1, lat2, lon2) {
R &lt;- 6371
Radian_factor &lt;- 0.0174533
lat_1 &lt;- (90-lat1)*Radian_factor
lat_2 &lt;- (90-lat2)*Radian_factor
diff_long &lt;-(lon1-lon2)*Radian_factor

distance_in_km &lt;- 6371*acos((cos(lat_1)*cos(lat_2))+ 
                 (sin(lat_1)*sin(lat_2)*cos(diff_long)))
rm(lat1, lon1, lat2, lon2)
return(distance_in_km)
}
</code></pre>
<p>Sample output</p>
<pre><code>custom_hav_dist(50.31,19.08,54.14,19.39)
[1] 426.3987
</code></pre>
<p>PS: To calculate distances in miles, substitute R in function (6371) with 3958.756 (and for nautical miles, use 3440.065).</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 26</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>there is a good example in here to calculate distance with PHP <a href="http://www.geodatasource.com/developers/php" rel="nofollow">http://www.geodatasource.com/developers/php</a> :</p>

<pre><code> function distance($lat1, $lon1, $lat2, $lon2, $unit) {

     $theta = $lon1 - $lon2;
     $dist = sin(deg2rad($lat1)) * sin(deg2rad($lat2)) +  cos(deg2rad($lat1)) * cos(deg2rad($lat2)) * cos(deg2rad($theta));
     $dist = acos($dist);
     $dist = rad2deg($dist);
     $miles = $dist * 60 * 1.1515;
     $unit = strtoupper($unit);

     if ($unit == "K") {
         return ($miles * 1.609344);
     } else if ($unit == "N") {
          return ($miles * 0.8684);
     } else {
          return $miles;
     }
 }
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 27</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is the implementation VB.NET, this implementation will give you the result in KM or Miles based on an Enum value you pass.</p>

<pre><code>Public Enum DistanceType
    Miles
    KiloMeters
End Enum

Public Structure Position
    Public Latitude As Double
    Public Longitude As Double
End Structure

Public Class Haversine

    Public Function Distance(Pos1 As Position,
                             Pos2 As Position,
                             DistType As DistanceType) As Double

        Dim R As Double = If((DistType = DistanceType.Miles), 3960, 6371)

        Dim dLat As Double = Me.toRadian(Pos2.Latitude - Pos1.Latitude)

        Dim dLon As Double = Me.toRadian(Pos2.Longitude - Pos1.Longitude)

        Dim a As Double = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) + Math.Cos(Me.toRadian(Pos1.Latitude)) * Math.Cos(Me.toRadian(Pos2.Latitude)) * Math.Sin(dLon / 2) * Math.Sin(dLon / 2)

        Dim c As Double = 2 * Math.Asin(Math.Min(1, Math.Sqrt(a)))

        Dim result As Double = R * c

        Return result

    End Function

    Private Function toRadian(val As Double) As Double

        Return (Math.PI / 180) * val

    End Function

End Class
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 28</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I condensed the computation down by simplifying the formula.</p>

<p>Here it is in Ruby:</p>

<pre><code>include Math
earth_radius_mi = 3959
radians = lambda { |deg| deg * PI / 180 }
coord_radians = lambda { |c| { :lat =&gt; radians[c[:lat]], :lng =&gt; radians[c[:lng]] } }

# from/to = { :lat =&gt; (latitude_in_degrees), :lng =&gt; (longitude_in_degrees) }
def haversine_distance(from, to)
  from, to = coord_radians[from], coord_radians[to]
  cosines_product = cos(to[:lat]) * cos(from[:lat]) * cos(from[:lng] - to[:lng])
  sines_product = sin(to[:lat]) * sin(from[:lat])
  return earth_radius_mi * acos(cosines_product + sines_product)
end
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 29</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre><code>function getDistanceFromLatLonInKm(lat1,lon1,lat2,lon2,units) {
  var R = 6371; // Radius of the earth in km
  var dLat = deg2rad(lat2-lat1);  // deg2rad below
  var dLon = deg2rad(lon2-lon1); 
  var a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * 
    Math.sin(dLon/2) * Math.sin(dLon/2)
    ; 
  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
  var d = R * c; 
  var miles = d / 1.609344; 

if ( units == 'km' ) {  
return d; 
 } else {
return miles;
}}
</code></pre>

<p>Chuck's solution, valid for miles also.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 30</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In Mysql use the following function pass the parameters as using  <code>POINT(LONG,LAT)</code></p>

<pre><code>CREATE FUNCTION `distance`(a POINT, b POINT)
 RETURNS double
    DETERMINISTIC
BEGIN

RETURN

GLength( LineString(( PointFromWKB(a)), (PointFromWKB(b)))) * 100000; -- To Make the distance in meters

END;
</code></pre>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;This \u0026lt;a href=\u0026quot;http://www.movable-type.co.uk/scripts/latlong.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;link\u0026lt;/a\u0026gt; might be helpful to you, as it details the use of the \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Haversine_formula\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Haversine formula\u0026lt;/a\u0026gt; to calculate the distance.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Excerpt:\u0026lt;/p\u0026gt;\n\n\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;This script [in Javascript] calculates great-circle distances between the two points \n  that is, the shortest distance over the earths surface  using the\n  Haversine formula.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getDistanceFromLatLonInKm\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;lat1,lon1,lat2,lon2\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; R = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6371\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Radius of the earth in km\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; dLat = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;deg2rad\u0026lt;/span\u0026gt;(lat2-lat1);  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// deg2rad below\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; dLon = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;deg2rad\u0026lt;/span\u0026gt;(lon2-lon1); \n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = \n    \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sin\u0026lt;/span\u0026gt;(dLat/\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) * \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sin\u0026lt;/span\u0026gt;(dLat/\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) +\n    \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;cos\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;deg2rad\u0026lt;/span\u0026gt;(lat1)) * \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;cos\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;deg2rad\u0026lt;/span\u0026gt;(lat2)) * \n    \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sin\u0026lt;/span\u0026gt;(dLon/\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) * \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sin\u0026lt;/span\u0026gt;(dLon/\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)\n    ; \n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; c = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; * \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;atan2\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sqrt\u0026lt;/span\u0026gt;(a), \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sqrt\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;-a)); \n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; d = R * c; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Distance in km\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; d;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;deg2rad\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;deg\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; deg * (\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;PI\u0026lt;/span\u0026gt;/\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;180\u0026lt;/span\u0026gt;)\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I needed to calculate a lot of distances between the points for my project, so I went ahead and tried to optimize the code, I have found here. On average in different browsers my new implementation \u0026lt;strong\u0026gt;runs 2 times faster\u0026lt;/strong\u0026gt; than the most upvoted answer.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;distance\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;lat1, lon1, lat2, lon2\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; p = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.017453292519943295\u0026lt;/span\u0026gt;;    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Math.PI / 180\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; c = \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;cos\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.5\u0026lt;/span\u0026gt; - \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt;((lat2 - lat1) * p)/\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; + \n          \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt;(lat1 * p) * \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt;(lat2 * p) * \n          (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; - \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt;((lon2 - lon1) * p))/\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12742\u0026lt;/span\u0026gt; * \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;asin\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sqrt\u0026lt;/span\u0026gt;(a)); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 2 * R; R = 6371 km\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;You can play with my jsPerf and see the \u0026lt;a href=\u0026quot;http://jsperf.com/haversine-salvador/8\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;results here\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Recently I needed to do the same in python, so here is a \u0026lt;strong\u0026gt;python implementation\u0026lt;/strong\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-python s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; math \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; cos, asin, sqrt, pi\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;distance\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;lat1, lon1, lat2, lon2\u0026lt;/span\u0026gt;):\n    p = pi/\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;180\u0026lt;/span\u0026gt;\n    a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.5\u0026lt;/span\u0026gt; - cos((lat2-lat1)*p)/\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; + cos(lat1*p) * cos(lat2*p) * (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;-cos((lon2-lon1)*p))/\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12742\u0026lt;/span\u0026gt; * asin(sqrt(a)) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#2*R*asin...\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;And for the sake of completeness: \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Haversine_formula\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Haversine\u0026lt;/a\u0026gt; on Wikipedia.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is a C# Implementation:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;DistanceAlgorithm\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; PIx = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3.141592653589793\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; RADIUS = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6378.16\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;summary\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; Convert degrees to Radians\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/summary\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;param name=\u0026quot;x\u0026quot;\u0026amp;gt;\u0026lt;/span\u0026gt;Degrees\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/param\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;returns\u0026amp;gt;\u0026lt;/span\u0026gt;The equivalent in radians\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/returns\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Radians\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; x\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; x * PIx / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;180\u0026lt;/span\u0026gt;;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;summary\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; Calculate the distance between two places.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/summary\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;param name=\u0026quot;lon1\u0026quot;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/param\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;param name=\u0026quot;lat1\u0026quot;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/param\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;param name=\u0026quot;lon2\u0026quot;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/param\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;param name=\u0026quot;lat2\u0026quot;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/param\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;returns\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/returns\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;DistanceBetweenPlaces\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; lon1,\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; lat1,\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; lon2,\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; lat2\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; dlon = Radians(lon2 - lon1);\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; dlat = Radians(lat2 - lat1);\n\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; a = (Math.Sin(dlat / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) * Math.Sin(dlat / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)) + Math.Cos(Radians(lat1)) * Math.Cos(Radians(lat2)) * (Math.Sin(dlon / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) * Math.Sin(dlon / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;));\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; angle = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; * Math.Atan2(Math.Sqrt(a), Math.Sqrt(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; - a));\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; angle * RADIUS;\n    }\n\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is a java implementation of the Haversine formula.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;AVERAGE_RADIUS_OF_EARTH_KM\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6371\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;calculateDistanceInKilometer\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; userLat, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; userLng,\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; venueLat, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; venueLng)\u0026lt;/span\u0026gt; {\n\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;latDistance\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; Math.toRadians(userLat - venueLat);\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;lngDistance\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; Math.toRadians(userLng - venueLng);\n\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; Math.sin(latDistance / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) * Math.sin(latDistance / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)\n      + Math.cos(Math.toRadians(userLat)) * Math.cos(Math.toRadians(venueLat))\n      * Math.sin(lngDistance / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) * Math.sin(lngDistance / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;);\n\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; * Math.atan2(Math.sqrt(a), Math.sqrt(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; - a));\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;) (Math.round(AVERAGE_RADIUS_OF_EARTH_KM * c));\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that here we are rounding the answer to the nearest km.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Thanks very much for all this. I used the following code in my Objective-C iPhone app:\u0026lt;/p\u0026gt;\n\n\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; PIx = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3.141592653589793\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; RADIO = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6371\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Mean radius of Earth in Km\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;convertToRadians\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; val)\u0026lt;/span\u0026gt; {\n\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; val * PIx / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;180\u0026lt;/span\u0026gt;;\n}\n\n-(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;)kilometresBetweenPlace1:(CLLocationCoordinate2D) place1 andPlace2:(CLLocationCoordinate2D) place2 {\n\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; dlon = convertToRadians(place2.longitude - place1.longitude);\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; dlat = convertToRadians(place2.latitude - place1.latitude);\n\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; a = ( \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;pow\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sin\u0026lt;/span\u0026gt;(dlat / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;), \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) + \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cos\u0026lt;/span\u0026gt;(convertToRadians(place1.latitude))) * \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cos\u0026lt;/span\u0026gt;(convertToRadians(place2.latitude)) * \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;pow\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sin\u0026lt;/span\u0026gt;(dlon / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;), \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; angle = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; * \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;asin\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sqrt\u0026lt;/span\u0026gt;(a));\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; angle * RADIO;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Latitude and Longitude are in decimal. I didn\u0026apos;t use min() for the asin() call as the distances that I\u0026apos;m using are so small that they don\u0026apos;t require it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It gave incorrect answers until I passed in the values in Radians - now it\u0026apos;s pretty much the same as the values obtained from Apple\u0026apos;s Map app :-)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Extra update:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you are using iOS4 or later then Apple provide some methods to do this so the same functionality would be achieved with:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;-(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;)kilometresBetweenPlace1:(CLLocationCoordinate2D) place1 andPlace2:(CLLocationCoordinate2D) place2 {\n\n    MKMapPoint  start, finish;\n\n\n    start = MKMapPointForCoordinate(place1);\n    finish = MKMapPointForCoordinate(place2);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; MKMetersBetweenMapPoints(start, finish) / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is a simple PHP function that will give a very reasonable approximation (under +/-1% error margin).  \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-php s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;lt;?php\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;distance\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$lat1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$lon1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$lat2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$lon2\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;) \u0026lt;/span\u0026gt;{\n\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$pi80\u0026lt;/span\u0026gt; = M_PI / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;180\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$lat1\u0026lt;/span\u0026gt; *= \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$pi80\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$lon1\u0026lt;/span\u0026gt; *= \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$pi80\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$lat2\u0026lt;/span\u0026gt; *= \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$pi80\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$lon2\u0026lt;/span\u0026gt; *= \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$pi80\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$r\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6372.797\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// mean radius of Earth in km\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$dlat\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$lat2\u0026lt;/span\u0026gt; - \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$lat1\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$dlon\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$lon2\u0026lt;/span\u0026gt; - \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$lon1\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$a\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;sin\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$dlat\u0026lt;/span\u0026gt; / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) * \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;sin\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$dlat\u0026lt;/span\u0026gt; / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) + \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;cos\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$lat1\u0026lt;/span\u0026gt;) * \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;cos\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$lat2\u0026lt;/span\u0026gt;) * \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;sin\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$dlon\u0026lt;/span\u0026gt; / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) * \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;sin\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$dlon\u0026lt;/span\u0026gt; / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$c\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; * \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;atan2\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;sqrt\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$a\u0026lt;/span\u0026gt;), \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;sqrt\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; - \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$a\u0026lt;/span\u0026gt;));\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$km\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$r\u0026lt;/span\u0026gt; * \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$c\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//echo \u0026apos;\u0026amp;lt;br/\u0026amp;gt;\u0026apos;.$km;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$km\u0026lt;/span\u0026gt;;\n}\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;?\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;As said before; the earth is NOT a sphere.  It is like an old, old baseball that Mark McGwire decided to practice with - it is full of dents and bumps.  The simpler calculations (like this) treat it like a sphere.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Different methods may be more or less precise according to where you are on this irregular ovoid AND how far apart your points are (the closer they are the smaller the absolute error margin).  The more precise your expectation, the more complex the math.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For more info: \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Geographical_distance\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;wikipedia geographic distance\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I post here my working example.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;List all points in table having distance between a designated point (we use a random point - lat:45.20327, long:23.7806) less than 50 KM, with latitude \u0026amp;amp; longitude, in MySQL (the table fields are coord_lat and coord_long):\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;List all having DISTANCE\u0026amp;lt;50, in Kilometres (considered Earth radius 6371 KM):\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; denumire, (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6371\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;acos\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cos\u0026lt;/span\u0026gt;( radians(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;45.20327\u0026lt;/span\u0026gt;) ) \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cos\u0026lt;/span\u0026gt;( radians( coord_lat ) ) \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cos\u0026lt;/span\u0026gt;( radians( \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;23.7806\u0026lt;/span\u0026gt; ) \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;-\u0026lt;/span\u0026gt; radians(coord_long) ) \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;+\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sin\u0026lt;/span\u0026gt;( radians(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;45.20327\u0026lt;/span\u0026gt;) ) \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sin\u0026lt;/span\u0026gt;( radians(coord_lat) ) )) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;AS\u0026lt;/span\u0026gt; distanta \n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; obiective \n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;WHERE\u0026lt;/span\u0026gt; coord_lat\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;\u0026amp;lt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026apos;\u0026lt;/span\u0026gt; \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;AND\u0026lt;/span\u0026gt; coord_long\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;\u0026amp;lt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026apos;\u0026lt;/span\u0026gt; \n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;HAVING\u0026lt;/span\u0026gt; distanta\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;50\u0026lt;/span\u0026gt; \n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ORDER\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;BY\u0026lt;/span\u0026gt; distanta \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;desc\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The above example was tested in MySQL 5.0.95 and 5.5.16 (Linux). \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In the other answers an implementation in \u0026lt;a href=\u0026quot;/questions/tagged/r\u0026quot; class=\u0026quot;post-tag\u0026quot; title=\u0026quot;show questions tagged \u0026apos;r\u0026apos;\u0026quot; rel=\u0026quot;tag\u0026quot;\u0026gt;r\u0026lt;/a\u0026gt; is missing.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Calculating the distance between two point is quite straightforward with the \u0026lt;code\u0026gt;distm\u0026lt;/code\u0026gt; function from the \u0026lt;code\u0026gt;geosphere\u0026lt;/code\u0026gt; package:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;distm(p1, p2, fun = distHaversine)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;where:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;p1 = longitude/latitude for point(s)\np2 = longitude/latitude for point(s)\n# type of distance calculation\nfun = distCosine / distHaversine / distVincentySphere / distVincentyEllipsoid \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;As the earth is not perfectly spherical, the \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Vincenty%27s_formulae\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Vincenty formula for ellipsoids\u0026lt;/a\u0026gt; is probably the best way to calculate distances. Thus in the \u0026lt;code\u0026gt;geosphere\u0026lt;/code\u0026gt; package you use then:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;distm(p1, p2, fun = distVincentyEllipsoid)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Off course you don\u0026apos;t necessarily have to use \u0026lt;code\u0026gt;geosphere\u0026lt;/code\u0026gt; package, you can also calculate the distance in base \u0026lt;code\u0026gt;R\u0026lt;/code\u0026gt; with a function:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;hav.dist \u0026amp;lt;- function(long1, lat1, long2, lat2) {\n  R \u0026amp;lt;- 6371\n  diff.long \u0026amp;lt;- (long2 - long1)\n  diff.lat \u0026amp;lt;- (lat2 - lat1)\n  a \u0026amp;lt;- sin(diff.lat/2)^2 + cos(lat1) * cos(lat2) * sin(diff.long/2)^2\n  b \u0026amp;lt;- 2 * asin(pmin(1, sqrt(a))) \n  d = R * b\n  return(d)\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The haversine is definitely a good formula for probably most cases, other answers already include it so I am not going to take the space. But it is important to note that no matter what formula is used (yes not just one). Because of the huge range of accuracy possible as well as the computation time required. The choice of formula requires a bit more thought than a simple no brainer answer. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This posting from a person at nasa, is the best one I found at discussing the options\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://www.cs.nyu.edu/visual/home/proj/tiger/gisfaq.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://www.cs.nyu.edu/visual/home/proj/tiger/gisfaq.html\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example, if you are just sorting rows by distance in a 100 miles radius. The flat earth formula will be much faster than the haversine.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;HalfPi = 1.5707963;\nR = 3956; /* the radius gives you the measurement unit*/\n\na = HalfPi - latoriginrad;\nb = HalfPi - latdestrad;\nu = a * a + b * b;\nv = - 2 * a * b * cos(longdestrad - longoriginrad);\nc = sqrt(abs(u + v));\nreturn R * c;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Notice there is just one cosine and one square root. Vs 9 of them on the Haversine formula.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There could be a simpler solution, and more correct: The perimeter of earth is 40,000Km at the equator, about 37,000 on Greenwich (or any longitude) cycle. Thus:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;pythagoras = function (lat1, lon1, lat2, lon2) {\n   function sqr(x) {return x * x;}\n   function cosDeg(x) {return Math.cos(x * Math.PI / 180.0);}\n\n   var earthCyclePerimeter = 40000000.0 * cosDeg((lat1 + lat2) / 2.0);\n   var dx = (lon1 - lon2) * earthCyclePerimeter / 360.0;\n   var dy = 37000000.0 * (lat1 - lat2) / 360.0;\n\n   return Math.sqrt(sqr(dx) + sqr(dy));\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I agree that it should be fine-tuned as, I myself said that it\u0026apos;s an ellipsoid, so the radius to be multiplied by the cosine varies. But it\u0026apos;s a bit more accurate. Compared with Google Maps and it did reduce the error significantly.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;All the above answers assumes the earth is a sphere. However, a more accurate approximation would be that of an oblate spheroid.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;a= 6378.137#equitorial radius in km\nb= 6356.752#polar radius in km\n\ndef Distance(lat1, lons1, lat2, lons2):\n    lat1=math.radians(lat1)\n    lons1=math.radians(lons1)\n    R1=(((((a**2)*math.cos(lat1))**2)+(((b**2)*math.sin(lat1))**2))/((a*math.cos(lat1))**2+(b*math.sin(lat1))**2))**0.5 #radius of earth at lat1\n    x1=R*math.cos(lat1)*math.cos(lons1)\n    y1=R*math.cos(lat1)*math.sin(lons1)\n    z1=R*math.sin(lat1)\n\n    lat2=math.radians(lat2)\n    lons2=math.radians(lons2)\n    R1=(((((a**2)*math.cos(lat2))**2)+(((b**2)*math.sin(lat2))**2))/((a*math.cos(lat2))**2+(b*math.sin(lat2))**2))**0.5 #radius of earth at lat2\n    x2=R*math.cos(lat2)*math.cos(lons2)\n    y2=R*math.cos(lat2)*math.sin(lons2)\n    z2=R*math.sin(lat2)\n\n    return ((x1-x2)**2+(y1-y2)**2+(z1-z2)**2)**0.5\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;pip install haversine\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Python implementation\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Origin is the center of the contiguous United States.\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;from haversine import haversine, Unit\norigin = (39.50, 98.35)\nparis = (48.8567, 2.3508)\nhaversine(origin, paris, unit=Unit.MILES)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;To get the answer in kilometers simply set \u0026lt;code\u0026gt;unit=Unit.KILOMETERS\u0026lt;/code\u0026gt; (that\u0026apos;s the default).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I don\u0026apos;t like adding yet another answer, but the Google maps API v.3 has spherical geometry (and more). After converting your WGS84 to decimal degrees you can do this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;\u0026amp;lt;script src=\u0026quot;http://maps.google.com/maps/api/js?sensor=false\u0026amp;amp;libraries=geometry\u0026quot; type=\u0026quot;text/javascript\u0026quot;\u0026amp;gt;\u0026amp;lt;/script\u0026amp;gt;  \n\ndistance = google.maps.geometry.spherical.computeDistanceBetween(\n    new google.maps.LatLng(fromLat, fromLng), \n    new google.maps.LatLng(toLat, toLng));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;No word about how accurate Google\u0026apos;s calculations are or even what model is used (though it does say \u0026quot;spherical\u0026quot; rather than \u0026quot;geoid\u0026quot;.  By the way, the \u0026quot;straight line\u0026quot; distance will obviously be different from the distance if one travels on the surface of the earth which is what everyone seems to be presuming.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You can use the build in CLLocationDistance to calculate this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;CLLocation *location1 = [[CLLocation alloc] initWithLatitude:latitude1 longitude:longitude1];\nCLLocation *location2 = [[CLLocation alloc] initWithLatitude:latitude2 longitude:longitude2];\n[self distanceInMetersFromLocation:location1 toLocation:location2]\n\n- (int)distanceInMetersFromLocation:(CLLocation*)location1 toLocation:(CLLocation*)location2 {\n    CLLocationDistance distanceInMeters = [location1 distanceFromLocation:location2];\n    return distanceInMeters;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In your case if you want kilometers just divide by 1000.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is a \u0026lt;strong\u0026gt;typescript\u0026lt;/strong\u0026gt; implementation of the Haversine formula\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;static getDistanceFromLatLonInKm(lat1: number, lon1: number, lat2: number, lon2: number): number {\n    var deg2Rad = deg =\u0026amp;gt; {\n        return deg * Math.PI / 180;\n    }\n\n    var r = 6371; // Radius of the earth in km\n    var dLat = deg2Rad(lat2 - lat1);   \n    var dLon = deg2Rad(lon2 - lon1);\n    var a =\n        Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n        Math.cos(deg2Rad(lat1)) * Math.cos(deg2Rad(lat2)) *\n        Math.sin(dLon / 2) * Math.sin(dLon / 2);\n    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    var d = r * c; // Distance in km\n    return d;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As pointed out, an accurate calculation should take into account that the earth is not a perfect sphere. Here are some comparisons of the various algorithms offered here:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;geoDistance(50,5,58,3)\nHaversine: 899 km\nMaymenn: 833 km\nKeerthana: 897 km\ngoogle.maps.geometry.spherical.computeDistanceBetween(): 900 km\n\ngeoDistance(50,5,-58,-3)\nHaversine: 12030 km\nMaymenn: 11135 km\nKeerthana: 10310 km\ngoogle.maps.geometry.spherical.computeDistanceBetween(): 12044 km\n\ngeoDistance(.05,.005,.058,.003)\nHaversine: 0.9169 km\nMaymenn: 0.851723 km\nKeerthana: 0.917964 km\ngoogle.maps.geometry.spherical.computeDistanceBetween(): 0.917964 km\n\ngeoDistance(.05,80,.058,80.3)\nHaversine: 33.37 km\nMaymenn: 33.34 km\nKeerthana: 33.40767 km\ngoogle.maps.geometry.spherical.computeDistanceBetween(): 33.40770 km\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Over small distances, Keerthana\u0026apos;s algorithm does seem to coincide with that of Google Maps. Google Maps does not seem to follow any simple algorithm, suggesting that it may be the most accurate method here.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Anyway, here is a Javascript implementation of Keerthana\u0026apos;s algorithm:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;function geoDistance(lat1, lng1, lat2, lng2){\n    const a = 6378.137; // equitorial radius in km\n    const b = 6356.752; // polar radius in km\n\n    var sq = x =\u0026amp;gt; (x*x);\n    var sqr = x =\u0026amp;gt; Math.sqrt(x);\n    var cos = x =\u0026amp;gt; Math.cos(x);\n    var sin = x =\u0026amp;gt; Math.sin(x);\n    var radius = lat =\u0026amp;gt; sqr((sq(a*a*cos(lat))+sq(b*b*sin(lat)))/(sq(a*cos(lat))+sq(b*sin(lat))));\n\n    lat1 = lat1 * Math.PI / 180;\n    lng1 = lng1 * Math.PI / 180;\n    lat2 = lat2 * Math.PI / 180;\n    lng2 = lng2 * Math.PI / 180;\n\n    var R1 = radius(lat1);\n    var x1 = R1*cos(lat1)*cos(lng1);\n    var y1 = R1*cos(lat1)*sin(lng1);\n    var z1 = R1*sin(lat1);\n\n    var R2 = radius(lat2);\n    var x2 = R2*cos(lat2)*cos(lng2);\n    var y2 = R2*cos(lat2)*sin(lng2);\n    var z2 = R2*sin(lat2);\n\n    return sqr(sq(x1-x2)+sq(y1-y2)+sq(z1-z2));\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is the SQL Implementation to calculate the distance in km,\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;SELECT UserId, ( 3959 * acos( cos( radians( your latitude here ) ) * cos( radians(latitude) ) * \ncos( radians(longitude) - radians( your longitude here ) ) + sin( radians( your latitude here ) ) * \nsin( radians(latitude) ) ) ) AS distance FROM user HAVING\ndistance \u0026amp;lt; 5  ORDER BY distance LIMIT 0 , 5;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;For further details in the implementation by programming langugage, you can just go through the php script given \u0026lt;a href=\u0026quot;https://www.geodatasource.com/developers/php\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This script [in PHP] calculates distances between the two points.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;public static function getDistanceOfTwoPoints($source, $dest, $unit=\u0026apos;K\u0026apos;) {\n        $lat1 = $source[0];\n        $lon1 = $source[1];\n        $lat2 = $dest[0];\n        $lon2 = $dest[1];\n\n        $theta = $lon1 - $lon2;\n        $dist = sin(deg2rad($lat1)) * sin(deg2rad($lat2)) +  cos(deg2rad($lat1)) * cos(deg2rad($lat2)) * cos(deg2rad($theta));\n        $dist = acos($dist);\n        $dist = rad2deg($dist);\n        $miles = $dist * 60 * 1.1515;\n        $unit = strtoupper($unit);\n\n        if ($unit == \u0026quot;K\u0026quot;) {\n            return ($miles * 1.609344);\n        }\n        else if ($unit == \u0026quot;M\u0026quot;)\n        {\n            return ($miles * 1.609344 * 1000);\n        }\n        else if ($unit == \u0026quot;N\u0026quot;) {\n            return ($miles * 0.8684);\n        } \n        else {\n            return $miles;\n        }\n    }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Java implementation in according \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Haversine_formula\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Haversine formula\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;calculateDistance\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; latPoint1, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; lngPoint1, \n                         \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; latPoint2, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; lngPoint2)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(latPoint1 == latPoint2 \u0026amp;amp;\u0026amp;amp; lngPoint1 == lngPoint2) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0d\u0026lt;/span\u0026gt;;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;EARTH_RADIUS\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6371.0\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//km value;\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//converting to radians\u0026lt;/span\u0026gt;\n    latPoint1 = Math.toRadians(latPoint1);\n    lngPoint1 = Math.toRadians(lngPoint1);\n    latPoint2 = Math.toRadians(latPoint2);\n    lngPoint2 = Math.toRadians(lngPoint2);\n\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;distance\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; Math.pow(Math.sin((latPoint2 - latPoint1) / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2.0\u0026lt;/span\u0026gt;), \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) \n            + Math.cos(latPoint1) * Math.cos(latPoint2)\n            * Math.pow(Math.sin((lngPoint2 - lngPoint1) / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2.0\u0026lt;/span\u0026gt;), \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;);\n    distance = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2.0\u0026lt;/span\u0026gt; * EARTH_RADIUS * Math.asin(Math.sqrt(distance));\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; distance; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//km value\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;To calculate the distance between two points on a sphere you need to do the \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Great-circle_distance\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Great Circle calculation\u0026lt;/a\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There are a number of C/C++ libraries to help with map projection at \u0026lt;a href=\u0026quot;http://www.maptools.org/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;MapTools\u0026lt;/a\u0026gt; if you need to reproject your distances to a flat surface.  To do this you will need the projection string of the various coordinate systems.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You may also find \u0026lt;a href=\u0026quot;http://www.mapwindow.org/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;MapWindow\u0026lt;/a\u0026gt; a useful tool to visualise the points.  Also as its open source its a useful guide to how to use the proj.dll library, which appears to be the core open source projection library.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is my java implementation for calculation distance via decimal degrees after some search. I used mean radius of world (from wikipedia) in km. İf you want result miles then use world radius in miles.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;public static double distanceLatLong2(double lat1, double lng1, double lat2, double lng2) \n{\n  double earthRadius = 6371.0d; // KM: use mile here if you want mile result\n\n  double dLat = toRadian(lat2 - lat1);\n  double dLng = toRadian(lng2 - lng1);\n\n  double a = Math.pow(Math.sin(dLat/2), 2)  + \n          Math.cos(toRadian(lat1)) * Math.cos(toRadian(lat2)) * \n          Math.pow(Math.sin(dLng/2), 2);\n\n  double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n\n  return earthRadius * c; // returns result kilometers\n}\n\npublic static double toRadian(double degrees) \n{\n  return (degrees * Math.PI) / 180.0d;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here\u0026apos;s the accepted answer implementation ported to Java in case anyone needs it.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;package com.project529.garage.util;\n\n\n/**\n * Mean radius.\n */\nprivate static double EARTH_RADIUS = 6371;\n\n/**\n * Returns the distance between two sets of latitudes and longitudes in meters.\n * \u0026amp;lt;p/\u0026amp;gt;\n * Based from the following JavaScript SO answer:\n * http://stackoverflow.com/questions/27928/calculate-distance-between-two-latitude-longitude-points-haversine-formula,\n * which is based on https://en.wikipedia.org/wiki/Haversine_formula (error rate: ~0.55%).\n */\npublic double getDistanceBetween(double lat1, double lon1, double lat2, double lon2) {\n    double dLat = toRadians(lat2 - lat1);\n    double dLon = toRadians(lon2 - lon1);\n\n    double a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n            Math.cos(toRadians(lat1)) * Math.cos(toRadians(lat2)) *\n                    Math.sin(dLon / 2) * Math.sin(dLon / 2);\n    double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    double d = EARTH_RADIUS * c;\n\n    return d;\n}\n\npublic double toRadians(double degrees) {\n    return degrees * (Math.PI / 180);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;here is an example in \u0026lt;strong\u0026gt;postgres\u0026lt;/strong\u0026gt; sql (in km, for miles version, replace 1.609344 by 0.8684 version)\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;CREATE OR REPLACE FUNCTION public.geodistance(alat float, alng float, blat  \n\nfloat, blng  float)\n  RETURNS float AS\n$BODY$\nDECLARE\n    v_distance float;\nBEGIN\n\n    v_distance = asin( sqrt(\n            sin(radians(blat-alat)/2)^2 \n                + (\n                    (sin(radians(blng-alng)/2)^2) *\n                    cos(radians(alat)) *\n                    cos(radians(blat))\n                )\n          )\n        ) * cast(\u0026apos;7926.3352\u0026apos; as float) * cast(\u0026apos;1.609344\u0026apos; as float) ;\n\n\n    RETURN v_distance;\nEND \n$BODY$\nlanguage plpgsql VOLATILE SECURITY DEFINER;\nalter function geodistance(alat float, alng float, blat float, blng float)\nowner to postgres;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;For those looking for an Excel formula based on WGS-84 \u0026amp;amp; GRS-80 standards:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;=ACOS(COS(RADIANS(90-Lat1))*COS(RADIANS(90-Lat2))+SIN(RADIANS(90-Lat1))*SIN(RADIANS(90-Lat2))*COS(RADIANS(Long1-Long2)))*6371\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://bluemm.blogspot.com/2007/01/excel-formula-to-calculate-distance.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Source\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I made a custom function in R to calculate haversine distance(km) between two spatial points using functions available in R base package.\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;custom_hav_dist \u0026amp;lt;- function(lat1, lon1, lat2, lon2) {\nR \u0026amp;lt;- 6371\nRadian_factor \u0026amp;lt;- 0.0174533\nlat_1 \u0026amp;lt;- (90-lat1)*Radian_factor\nlat_2 \u0026amp;lt;- (90-lat2)*Radian_factor\ndiff_long \u0026amp;lt;-(lon1-lon2)*Radian_factor\n\ndistance_in_km \u0026amp;lt;- 6371*acos((cos(lat_1)*cos(lat_2))+ \n                 (sin(lat_1)*sin(lat_2)*cos(diff_long)))\nrm(lat1, lon1, lat2, lon2)\nreturn(distance_in_km)\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Sample output\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;custom_hav_dist(50.31,19.08,54.14,19.39)\n[1] 426.3987\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;PS: To calculate distances in miles, substitute R in function (6371) with 3958.756 (and for nautical miles, use 3440.065).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;there is a good example in here to calculate distance with PHP \u0026lt;a href=\u0026quot;http://www.geodatasource.com/developers/php\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;http://www.geodatasource.com/developers/php\u0026lt;/a\u0026gt; :\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt; function distance($lat1, $lon1, $lat2, $lon2, $unit) {\n\n     $theta = $lon1 - $lon2;\n     $dist = sin(deg2rad($lat1)) * sin(deg2rad($lat2)) +  cos(deg2rad($lat1)) * cos(deg2rad($lat2)) * cos(deg2rad($theta));\n     $dist = acos($dist);\n     $dist = rad2deg($dist);\n     $miles = $dist * 60 * 1.1515;\n     $unit = strtoupper($unit);\n\n     if ($unit == \u0026quot;K\u0026quot;) {\n         return ($miles * 1.609344);\n     } else if ($unit == \u0026quot;N\u0026quot;) {\n          return ($miles * 0.8684);\n     } else {\n          return $miles;\n     }\n }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is the implementation VB.NET, this implementation will give you the result in KM or Miles based on an Enum value you pass.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;Public Enum DistanceType\n    Miles\n    KiloMeters\nEnd Enum\n\nPublic Structure Position\n    Public Latitude As Double\n    Public Longitude As Double\nEnd Structure\n\nPublic Class Haversine\n\n    Public Function Distance(Pos1 As Position,\n                             Pos2 As Position,\n                             DistType As DistanceType) As Double\n\n        Dim R As Double = If((DistType = DistanceType.Miles), 3960, 6371)\n\n        Dim dLat As Double = Me.toRadian(Pos2.Latitude - Pos1.Latitude)\n\n        Dim dLon As Double = Me.toRadian(Pos2.Longitude - Pos1.Longitude)\n\n        Dim a As Double = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) + Math.Cos(Me.toRadian(Pos1.Latitude)) * Math.Cos(Me.toRadian(Pos2.Latitude)) * Math.Sin(dLon / 2) * Math.Sin(dLon / 2)\n\n        Dim c As Double = 2 * Math.Asin(Math.Min(1, Math.Sqrt(a)))\n\n        Dim result As Double = R * c\n\n        Return result\n\n    End Function\n\n    Private Function toRadian(val As Double) As Double\n\n        Return (Math.PI / 180) * val\n\n    End Function\n\nEnd Class\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I condensed the computation down by simplifying the formula.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here it is in Ruby:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;include Math\nearth_radius_mi = 3959\nradians = lambda { |deg| deg * PI / 180 }\ncoord_radians = lambda { |c| { :lat =\u0026amp;gt; radians[c[:lat]], :lng =\u0026amp;gt; radians[c[:lng]] } }\n\n# from/to = { :lat =\u0026amp;gt; (latitude_in_degrees), :lng =\u0026amp;gt; (longitude_in_degrees) }\ndef haversine_distance(from, to)\n  from, to = coord_radians[from], coord_radians[to]\n  cosines_product = cos(to[:lat]) * cos(from[:lat]) * cos(from[:lng] - to[:lng])\n  sines_product = sin(to[:lat]) * sin(from[:lat])\n  return earth_radius_mi * acos(cosines_product + sines_product)\nend\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;function getDistanceFromLatLonInKm(lat1,lon1,lat2,lon2,units) {\n  var R = 6371; // Radius of the earth in km\n  var dLat = deg2rad(lat2-lat1);  // deg2rad below\n  var dLon = deg2rad(lon2-lon1); \n  var a = \n    Math.sin(dLat/2) * Math.sin(dLat/2) +\n    Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * \n    Math.sin(dLon/2) * Math.sin(dLon/2)\n    ; \n  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); \n  var d = R * c; \n  var miles = d / 1.609344; \n\nif ( units == \u0026apos;km\u0026apos; ) {  \nreturn d; \n } else {\nreturn miles;\n}}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Chuck\u0026apos;s solution, valid for miles also.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In Mysql use the following function pass the parameters as using  \u0026lt;code\u0026gt;POINT(LONG,LAT)\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;CREATE FUNCTION `distance`(a POINT, b POINT)\n RETURNS double\n    DETERMINISTIC\nBEGIN\n\nRETURN\n\nGLength( LineString(( PointFromWKB(a)), (PointFromWKB(b)))) * 100000; -- To Make the distance in meters\n\nEND;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    "],"comment":["\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;For better accuracy - see \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/1420045/how-to-find-distance-from-the-latitude-and-longitude-of-two-locations/1422562#1422562\u0026quot; title=\u0026quot;how to find distance from the latitude and longitude of two locations\u0026quot;\u0026gt;stackoverflow.com/questions/1420045/\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/171006/lior-kogan\u0026quot; title=\u0026quot;18,914 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Lior Kogan\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment77429769_27928\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-07-21 07:54:19Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 21, 2017 at 7:54\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Note that you cannot apply a Haversine formula on an ellipsoid of revolution like WGS 84. You can only apply this method on a sphere with a radius.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/327026/mike-t\u0026quot; title=\u0026quot;38,306 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Mike T\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment89909816_27928\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-07-23 02:05:23Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 23, 2018 at 2:05\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Most of the answers here are using simple spherical trigonometry, so the results are rather crude compared to the WGS84 ellipsoid distances used in the GPS system. Some of the answers do refer to Vincenty\u0026apos;s formula for ellipsoids, but that algorithm was designed for use on 1960s\u0026apos; era desk calculators and it has stability \u0026amp;amp; accuracy issues; we have better hardware and software now. Please see \u0026lt;a href=\u0026quot;https://geographiclib.sourceforge.io/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;GeographicLib\u0026lt;/a\u0026gt; for a high quality library with implementations in various languages.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/4014959/pm-2ring\u0026quot; title=\u0026quot;52,419 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;PM 2Ring\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment90310172_27928\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-08-03 13:26:32Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 3, 2018 at 13:26\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@MikeT - true though many of the answers here seem useful \u0026lt;i\u0026gt;over small distances\u0026lt;/i\u0026gt;: If you take lat/long from WGS 84, and apply Haversine \u0026lt;i\u0026gt;as if those were\u0026lt;/i\u0026gt; points on a sphere, don\u0026apos;t you get answers whose errors are only due to the earth\u0026apos;s flattening factor, so perhaps within 1% of a more accurate formula? With the caveat that these are small distances, say within a single town.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/199364/toolmakersteve\u0026quot; title=\u0026quot;11,966 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;ToolmakerSteve\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment93808440_27928\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-11-25 15:27:13Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 25, 2018 at 15:27\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;For these plateforms: Mono/.NET 4.5/.NET Core/Windows Phone 8.x/Universal Windows Platform/Xamarin iOS/Xamarin Android see \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/54296314/2736742\u0026quot;\u0026gt;stackoverflow.com/a/54296314/2736742\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2736742/a-morel\u0026quot; title=\u0026quot;7,615 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;A. Morel\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment95414363_27928\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-01-21 20:02:13Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 21, 2019 at 20:02\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Does this calculation/method account for the Earth being a spheroid (not a perfect sphere)? The original question asked for distance on between points on a WGS84 globe. Not sure how much error creeps in by using a perfect sphere, but I suspect it can be quite a lot depending on where the points are on the globe, thus the distinction is worth bearing in mind.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/15703/redcalx\u0026quot; title=\u0026quot;7,827 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;redcalx\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment9855599_27943\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-11-08 08:33:38Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 8, 2011 at 8:33\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;The Haversine formula doesn\u0026apos;t account for the Earth being a spheroid, so you\u0026apos;ll get some error introduced due to that fact.  It can\u0026apos;t be guaranteed correct to better than 0.5%.  That may or may not be an acceptable level of error though.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/85721/brandon\u0026quot; title=\u0026quot;483 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Brandon\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment10758317_27943\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-12-28 16:20:25Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 28, 2011 at 16:20\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Is there any reason to use \u0026lt;code\u0026gt;Math.atan2(Math.sqrt(a), Math.sqrt(1-a))\u0026lt;/code\u0026gt; instead of \u0026lt;code\u0026gt;Math.asin(Math.sqrt(h))\u0026lt;/code\u0026gt;, which would be the direct implementation of the formula that the Wikipedia article uses? Is it more efficient and/or more numerically stable?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/424632/musiphil\u0026quot; title=\u0026quot;3,687 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;musiphil\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment19264838_27943\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-12-20 03:47:08Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 20, 2012 at 3:47\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@UsmanMutawakil Well, the 38 miles you get is distance on the road. This algorithm calculates a straight line distance on the earth\u0026apos;s surface. Google Maps has a distance tool (bottom left, \u0026quot;Labs\u0026quot;) that does the same, use that to compare.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/148335/pascal\u0026quot; title=\u0026quot;16,659 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Pascal\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment25359822_27943\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-07-03 17:35:44Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 3, 2013 at 17:35\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Forte_201092: Because that is not necessary - as \u0026lt;code\u0026gt;(sin(x))²\u0026lt;/code\u0026gt; equals \u0026lt;code\u0026gt;(sin(-x))²\u0026lt;/code\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/113158/jean-hominal\u0026quot; title=\u0026quot;16,168 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Jean Hominal\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment36895098_27943\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-05-30 09:16:06Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 30, 2014 at 9:16\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@AngularM and there is highly likely that google calculates distance if you will be taking some roads and not a straight line.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1090562/salvador-dali\u0026quot; title=\u0026quot;201,043 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Salvador Dali\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment60933520_21623206\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-04-16 23:53:08Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 16, 2016 at 23:53\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Google calculates driving distance, this calculates \u0026quot;as the crow flies\u0026quot;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/4111710/hobbyist\u0026quot; title=\u0026quot;15,178 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Hobbyist\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment65086699_21623206\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-08-09 22:24:30Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 9, 2016 at 22:24\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Ouadie and will it improve speed? Most probably no, but I will end up with a lot of \u0026apos;your stuff doesn\u0026apos;t work\u0026apos; for people who copypaste it in old browsers\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1090562/salvador-dali\u0026quot; title=\u0026quot;201,043 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Salvador Dali\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment70986257_21623206\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-01-27 19:58:42Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 27, 2017 at 19:58\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;well yeah but what does \u0026lt;code\u0026gt;// 2 * R; R = 6371 km\u0026lt;/code\u0026gt; stands for? and the current method provides answer in km or miles? needs better documentation. Thanks\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/5890227/khalil-khalaf\u0026quot; title=\u0026quot;8,887 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Khalil Khalaf\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment78610852_21623206\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-08-22 20:25:37Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 22, 2017 at 20:25\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@KhalilKhalaf are you joking or trying to troll here? km stands for kilometers. What do you think R stands for (especially if we speak about a shpere)? Guess in what units the answer will be if you already see the km. What kind of documentation are you looking for here: there are literally 4 lines there.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1090562/salvador-dali\u0026quot; title=\u0026quot;201,043 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Salvador Dali\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment78612432_21623206\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-08-22 21:22:35Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 22, 2017 at 21:22\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;You are using the equatorial radius, but you should be using the mean radius, which is 6371 km\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/113570/philippe-leybaert\u0026quot; title=\u0026quot;163,459 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Philippe Leybaert\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment924262_215849\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-07-10 12:18:21Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 10, 2009 at 12:18\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Shouldn\u0026apos;t this be \u0026lt;code\u0026gt;double dlon = Radians(lon2 - lon1);\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;double dlat = Radians(lat2 - lat1);\u0026lt;/code\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/37055/chris-marisic\u0026quot; title=\u0026quot;31,703 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Chris Marisic\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment2002586_215849\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-01-15 15:40:33Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 15, 2010 at 15:40\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I agree with Chris Marisic. I used the original code and the calculations were wrong. I added the call to convert the deltas to radians and it works properly now. I submitted an edit and am waiting for it to be peer reviewed.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/213138/bryan-bedard\u0026quot; title=\u0026quot;2,589 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Bryan Bedard\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment10332836_215849\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-12-04 04:53:28Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 4, 2011 at 4:53\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I submitted another edit because lat1 \u0026amp;amp; lat2 also need to be converted to radians. I also revised the formula for the assignment to a to match the formula and code found here: \u0026lt;a href=\u0026quot;http://www.movable-type.co.uk/scripts/latlong.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;movable-type.co.uk/scripts/latlong.html\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/213138/bryan-bedard\u0026quot; title=\u0026quot;2,589 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Bryan Bedard\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment10333335_215849\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-12-04 06:48:13Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 4, 2011 at 6:48\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;does the \u0026lt;code\u0026gt;RADIUS\u0026lt;/code\u0026gt; value need to be 6371 as in the other answers?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/103897/chris-hayes\u0026quot; title=\u0026quot;3,786 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Chris Hayes\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment95483876_215849\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-01-23 18:02:16Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 23, 2019 at 18:02\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;If we wanted to calculate the distance between between two points in meters, what would be the more accurate way? To use \u0026lt;code\u0026gt;6371000\u0026lt;/code\u0026gt; as the radius of the earth? (avg. radius of earth is 6371000 meters) or convert kilometers to meters from your function?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3075340/micro\u0026quot; title=\u0026quot;9,823 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Micro\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment69418643_12600225\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-12-12 18:29:26Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 12, 2016 at 18:29\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;if you want miles, multiple the result by \u0026lt;code\u0026gt;0.621371\u0026lt;/code\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2445763/lasec0203\u0026quot; title=\u0026quot;2,147 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;lasec0203\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment102123287_12600225\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-09-09 05:20:34Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 9, 2019 at 5:20\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;iOS SDK has its own implementation: \u0026lt;a href=\u0026quot;https://developer.apple.com/library/ios/documentation/CoreLocation/Reference/CLLocation_Class/#//apple_ref/occ/instm/CLLocation/distanceFromLocation\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;developer.apple.com/library/ios/documentation/CoreLocation/\u0026lt;/a\u0026gt;:\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/54623/tuler\u0026quot; title=\u0026quot;3,259 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;tuler\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment60124007_4377364\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-03-27 12:15:26Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 27, 2016 at 12:15\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I think the parenthesis around \u0026lt;code\u0026gt;pow(sin(dlat / 2), 2) + cos(convertToRadians(place1.latitude))\u0026lt;/code\u0026gt; is incorrect. Remove those, and the result matches what I get when I use other implementations on this page, or implement the Haversine formula from \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Great-circle_distance\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Wikipedia\u0026lt;/a\u0026gt; from scratch.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/700883/zanedp\u0026quot; title=\u0026quot;409 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;zanedp\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment95310437_4377364\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-01-17 19:33:00Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 17, 2019 at 19:33\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Using the coordinates (40.7127837, -74.0059413) for NYC and (34.052234, -118.243685) for LA, with the \u0026lt;code\u0026gt;()\u0026lt;/code\u0026gt; around that sum, I get 3869.75. Without them, I get 3935.75, which is pretty much what a web search turns up.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/700883/zanedp\u0026quot; title=\u0026quot;409 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;zanedp\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment95310609_4377364\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-01-17 19:39:26Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 17, 2019 at 19:39\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;This works perfectly! I just added $distance_miles = $km * 0.621371; and that\u0026apos;s all I needed for approximate distance in miles! Thanks Tony.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;span class=\u0026quot;comment-user\u0026quot;\u0026gt;user321531\u0026lt;/span\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment39237671_11178145\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-08-08 05:17:57Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 8, 2014 at 5:17\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I think a good approach might be pre filtering the results using an aproximation, so the heavy formula is applied only for some cases. Specially usefull if you have other conditions. I\u0026apos;m using this for the initial aprox: \u0026lt;a href=\u0026quot;http://stackoverflow.com/questions/1253499/simple-calculations-for-working-with-lat-lon-km-distance\u0026quot; title=\u0026quot;simple calculations for working with lat lon km distance\u0026quot;\u0026gt;stackoverflow.com/questions/1253499/\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/483475/pato\u0026quot; title=\u0026quot;672 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Pato\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment75181741_9676337\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-05-19 20:57:36Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 19, 2017 at 20:57\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;To make sure I am clear on what you said: The code you give at end of post:  Is that an implementation of Vincenty formula? As far as you know, it should give same answer as calling Vincenty in geosphere? [I don\u0026apos;t have geosphere or other library; just looking for some code to include in a cross-platform app. I would of course verify some test cases against a known good calculator.]\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/199364/toolmakersteve\u0026quot; title=\u0026quot;11,966 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;ToolmakerSteve\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment93808236_23095329\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-11-25 15:16:24Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 25, 2018 at 15:16\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@ToolmakerSteve the function at the end of my answer is an implementation of the Haversine method\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2204410/jaap\u0026quot; title=\u0026quot;77,377 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Jaap\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment93808379_23095329\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-11-25 15:23:29Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 25, 2018 at 15:23\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Hi @Jaap could I ask what is the unit of measurement for the formula? Is it in metres?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/7635792/jackson\u0026quot; title=\u0026quot;63 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Jackson\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment104559112_23095329\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-12-04 01:53:01Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 4, 2019 at 1:53\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Jaap I liked the explanation of \u0026apos;Vincenty formula for ellipsoids\u0026apos; which I tested to be very accurate. @Jackson \u0026lt;code\u0026gt;distm(p1, p2, fun = distVincentyEllipsoid)\u0026lt;/code\u0026gt; gives output in metres which you have to divide with 1000 to get values in kilometres.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/6254041/tiny-hopper\u0026quot; title=\u0026quot;350 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Tiny_hopper\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment114914142_23095329\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2020-11-25 05:28:02Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 25, 2020 at 5:28\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;It\u0026apos;s a nice possibility. Just be aware that the recommended maximum distance in the discussion is \u0026lt;i\u0026gt;12\u0026lt;/i\u0026gt; miles, not \u0026lt;i\u0026gt;100\u0026lt;/i\u0026gt;, and that even so, errors might creep up to 30 meters (100 ft), depending on the globe\u0026apos;s position.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2713582/eric-wu\u0026quot; title=\u0026quot;871 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Eric Wu\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment101403987_19772119\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-08-12 17:00:59Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 12, 2019 at 17:00\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Is this function return distance in km?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/460966/wikki\u0026quot; title=\u0026quot;590 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Wikki\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment67398232_35309170\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-10-15 17:34:01Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 15, 2016 at 17:34\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;It is, just because the equator and the longitude cycles are in Km. For miles, just divide 40000 and 37000 by 1.6. Feeling geeky, you can convert it to Ris, multiplyung by about 7 or to parasang, dividing by 2.2 ;-)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/361169/meymann\u0026quot; title=\u0026quot;2,510 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Meymann\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment67430058_35309170\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-10-17 04:46:20Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 17, 2016 at 4:46\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;This seems to be the best answer offered here. I wish to use it but I just wonder whether there is a way to verify the correctness of this algorithm. I tested f(50,5,58,3). It gives 832km, whereas \u0026lt;a href=\u0026quot;https://www.movable-type.co.uk/scripts/latlong.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;movable-type.co.uk/scripts/latlong.html\u0026lt;/a\u0026gt; using the \u0026apos;haversine\u0026apos; formula gives 899km. Is there such a big difference?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2691226/chong-lip-phang\u0026quot; title=\u0026quot;7,835 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Chong Lip Phang\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment86846429_35309170\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-04-19 07:44:34Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 19, 2018 at 7:44\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Moreover, I think the value returned by the above code is in m, and not km.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2691226/chong-lip-phang\u0026quot; title=\u0026quot;7,835 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Chong Lip Phang\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment86846471_35309170\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-04-19 07:45:52Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 19, 2018 at 7:45\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;This formula has an inaccurate number in it. circumference through poles is 6356.752 NASA * 2 Pi = 39940.651 km. Not 37000. So gives low answers for changes in latitude, as Chong saw. Replace \u0026quot;37000000.0\u0026quot; with \u0026quot;39940651.0\u0026quot;. With this correction, my guess is accuracy to 1 part in 100, over distances up to one degree. (Not verified.)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/199364/toolmakersteve\u0026quot; title=\u0026quot;11,966 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;ToolmakerSteve\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment93808183_35309170\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-11-25 15:12:53Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 25, 2018 at 15:12\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Could you add sources to your formulae?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/8565438/zabop\u0026quot; title=\u0026quot;5,544 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;zabop\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment124277906_37870363\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2021-12-10 12:11:27Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 10, 2021 at 12:11\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;You\u0026apos;re importing a non-standard package that does all the work.  I don\u0026apos;t know if that\u0026apos;s all that useful.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2336725/teepeemm\u0026quot; title=\u0026quot;4,162 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Teepeemm\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment55777914_31398615\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-12-01 01:23:01Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 1, 2015 at 1:23\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;The package is in the PyPI, Python Package Index, as a python 3 package along with numpy and scikit-learn.  Not sure why one is apposed to packages.  They tend to be quite useful.  As open source, one could also examine the methods contained.  I think many would find this package useful so I will leave the post despite the downvote.  Cheers. :)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/4930264/invoketheshell\u0026quot; title=\u0026quot;3,651 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;invoketheshell\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment63689523_31398615\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-06-30 16:55:35Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 30, 2016 at 16:55\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;It looks useful,  but I would like to include the exact pip command to install this package.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1412564/uri\u0026quot; title=\u0026quot;2,413 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Uri\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment121264872_31398615\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2021-08-02 05:26:02Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 2, 2021 at 5:26\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;distance is in meters. alternatively one can use      computeLength()\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3006465/electrobabe\u0026quot; title=\u0026quot;1,371 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;electrobabe\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment58995786_24846150\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-02-26 17:08:25Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 26, 2016 at 17:08\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;how to calculate the speed?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/8814173/lemarque\u0026quot; title=\u0026quot;577 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;LeMarque\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment124627909_64214020\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2021-12-28 04:50:10Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 28, 2021 at 4:50\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;The code is about calculating the distance between two geostationary-spatial points. Didn\u0026apos;t get the idea why speed calculation is required here ??\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/5022656/sourav-karwa\u0026quot; title=\u0026quot;91 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;sourav karwa\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment124650084_64214020\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2021-12-29 05:38:43Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 29, 2021 at 5:38\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Actually, if the timestamps are given, we can calculate the speed, as distance is calculated using the formula. but if there are one minute interval time stamps and we wanted to learn about the speed of (any vehicle moving) at every 5 minute interval, I was wondering how to do that?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/8814173/lemarque\u0026quot; title=\u0026quot;577 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;LeMarque\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment124650742_64214020\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2021-12-29 06:41:23Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 29, 2021 at 6:41\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;You can further add in the code to calculate speed but in my use case, it wasn\u0026apos;t necessary hence didn\u0026apos;t calculate speed. Would love to hear what\u0026apos;s your approach with that\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/5022656/sourav-karwa\u0026quot; title=\u0026quot;91 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;sourav karwa\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment124688868_64214020\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2021-12-30 22:15:17Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 30, 2021 at 22:15\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Upon calculating \u0026quot;a\u0026quot;, did you wrote Math.Sin( \u0026lt;i\u0026gt;dLat\u0026lt;/i\u0026gt; ..) twice by mistake?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3961710/marco-ottina\u0026quot; title=\u0026quot;276 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Marco Ottina\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment100878849_15759519\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-07-24 13:32:08Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 24, 2019 at 13:32\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        "],"id":589,"title":"Calculate distance between two latitude-longitude points? (Haversine formula)","content":"\n                \n\u0026lt;p\u0026gt;How do I calculate the distance between two points specified by latitude and longitude?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For clarification, I\u0026apos;d like the distance in kilometers; the points use the WGS84 system and I\u0026apos;d like to understand the relative accuracies of the approaches available.\u0026lt;/p\u0026gt;\n    ","slug":"calculate-distance-between-two-latitude-longitude-points-(haversine-formula)-1657388500103","postType":"QUESTION","createdAt":"2022-07-09T17:41:40.000Z","updatedAt":"2022-07-09T17:41:40.000Z","tags":[{"id":2805,"name":"maps","slug":"maps","createdAt":"2022-07-09T17:41:40.000Z","updatedAt":"2022-07-09T17:41:40.000Z","Questions_Tags":{"questionId":589,"tagId":2805}},{"id":2806,"name":"latitude-longitude","slug":"latitude-longitude","createdAt":"2022-07-09T17:41:40.000Z","updatedAt":"2022-07-09T17:41:40.000Z","Questions_Tags":{"questionId":589,"tagId":2806}},{"id":2807,"name":"haversine","slug":"haversine","createdAt":"2022-07-09T17:41:40.000Z","updatedAt":"2022-07-09T17:41:40.000Z","Questions_Tags":{"questionId":589,"tagId":2807}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"calculate-distance-between-two-latitude-longitude-points-(haversine-formula)-1657388500103"},"buildId":"4Y8KGE-c2lolBeBmcum_I","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>