{"pageProps":{"data":{"answer":["\n&lt;p&gt;Your current data structure is great to look up the participants of a specific chat. It is however not a very good structure for looking up the inverse: the chats that a user participates in.&lt;/p&gt;\n&lt;p&gt;A few problems here:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;you&apos;re storing a &lt;em&gt;set&lt;/em&gt; as an array&lt;/li&gt;\n&lt;li&gt;you can only index on fixed paths&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1&gt;Set vs array&lt;/h1&gt;\n&lt;p&gt;A chat can have multiple participants, so you modelled this as an array. But this actually is not the ideal data structure. Likely each participant can only be in the chat once. But by using an array, I could have:&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;participants&lt;/span&gt;: [&lt;span class=&quot;hljs-string&quot;&gt;&quot;puf&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;puf&quot;&lt;/span&gt;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;That is clearly not what you have in mind, but the data structure allows it. You can try to secure this in code and security rules, but it would be easier if you start with a data structure that implicitly matches your model better.&lt;/p&gt;\n&lt;p&gt;My rule of thumb: &lt;strong&gt;if you find yourself writing &lt;code&gt;array.contains()&lt;/code&gt;, you should be using a set&lt;/strong&gt;.&lt;/p&gt;\n&lt;p&gt;A set is a structure where each child can be present at most once, so it naturally protects against duplicates. In Firebase you&apos;d model a set as:&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;participants&lt;/span&gt;: {\n  &lt;span class=&quot;hljs-string&quot;&gt;&quot;puf&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The &lt;code&gt;true&lt;/code&gt; here is really just a dummy value: the important thing is that we&apos;ve moved the name to the key. Now if I&apos;d try to join this chat again, it would be a noop:&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;participants&lt;/span&gt;: {\n  &lt;span class=&quot;hljs-string&quot;&gt;&quot;puf&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;And when you&apos;d join:&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;participants&lt;/span&gt;: {\n  &lt;span class=&quot;hljs-string&quot;&gt;&quot;john&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;,\n  &lt;span class=&quot;hljs-string&quot;&gt;&quot;puf&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This is the most direct representation of your requirement: a collection that can only contain each participant once.&lt;/p&gt;\n&lt;h1&gt;You can only index known properties&lt;/h1&gt;\n&lt;p&gt;With the above structure, you &lt;em&gt;could&lt;/em&gt; query for chats that you are in with:&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;ref.&lt;span class=&quot;hljs-title function_&quot;&gt;child&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;chats&quot;&lt;/span&gt;).&lt;span class=&quot;hljs-title function_&quot;&gt;orderByChild&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;participants/john&quot;&lt;/span&gt;).&lt;span class=&quot;hljs-title function_&quot;&gt;equalTo&lt;/span&gt;(&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The problem is that this requires you to define an index on `participants/john&quot;:&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;{\n  &lt;span class=&quot;hljs-string&quot;&gt;&quot;rules&quot;&lt;/span&gt;: {\n    &lt;span class=&quot;hljs-string&quot;&gt;&quot;chats&quot;&lt;/span&gt;: {\n      &lt;span class=&quot;hljs-string&quot;&gt;&quot;$chatid&quot;&lt;/span&gt;: {\n        &lt;span class=&quot;hljs-string&quot;&gt;&quot;participants&quot;&lt;/span&gt;: {\n          &lt;span class=&quot;hljs-string&quot;&gt;&quot;.indexOn&quot;&lt;/span&gt;: [&lt;span class=&quot;hljs-string&quot;&gt;&quot;john&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;puf&quot;&lt;/span&gt;]\n        }\n      }\n    }\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This will work and perform great. But now each time someone new joins the chat app, you&apos;ll need to add another index. That&apos;s clearly not a scaleable model. We&apos;ll need to change our data structure to allow the query you want.&lt;/p&gt;\n&lt;h1&gt;Invert the index - pull categories up, flattening the tree&lt;/h1&gt;\n&lt;p&gt;Second rule of thumb: &lt;strong&gt;model your data to reflect what you show in your app&lt;/strong&gt;.&lt;/p&gt;\n&lt;p&gt;Since you are looking to show a list of chat rooms for a user, store the chat rooms for each user:&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;userChatrooms&lt;/span&gt;: {\n  &lt;span class=&quot;hljs-attr&quot;&gt;john&lt;/span&gt;: {\n    &lt;span class=&quot;hljs-attr&quot;&gt;chatRoom1&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;,\n    &lt;span class=&quot;hljs-attr&quot;&gt;chatRoom2&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;\n  },\n  &lt;span class=&quot;hljs-attr&quot;&gt;puf&lt;/span&gt;: {\n    &lt;span class=&quot;hljs-attr&quot;&gt;chatRoom1&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;,\n    &lt;span class=&quot;hljs-attr&quot;&gt;chatRoom3&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Now you can simply determine your list of chat rooms with:&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;ref.&lt;span class=&quot;hljs-title function_&quot;&gt;child&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;userChatrooms&quot;&lt;/span&gt;).&lt;span class=&quot;hljs-title function_&quot;&gt;child&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;john&quot;&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;And then loop over the keys to get each room.&lt;/p&gt;\n&lt;p&gt;You&apos;ll like have two relevant lists in your app:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;the list of chat rooms for a specific user&lt;/li&gt;\n&lt;li&gt;the list of participants in a specific chat room&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;In that case you&apos;ll also have both lists in the database.&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;chatroomUsers\n  chatroom1\n    &lt;span class=&quot;hljs-attr&quot;&gt;user1&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;\n    &lt;span class=&quot;hljs-attr&quot;&gt;user2&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;\n  chatroom2\n    &lt;span class=&quot;hljs-attr&quot;&gt;user1&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;\n    &lt;span class=&quot;hljs-attr&quot;&gt;user3&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;\nuserChatrooms\n  &lt;span class=&quot;hljs-attr&quot;&gt;user1&lt;/span&gt;:\n    &lt;span class=&quot;hljs-attr&quot;&gt;chatroom1&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;\n    &lt;span class=&quot;hljs-attr&quot;&gt;chatroom2&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;\n  &lt;span class=&quot;hljs-attr&quot;&gt;user2&lt;/span&gt;:\n    &lt;span class=&quot;hljs-attr&quot;&gt;chatroom1&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;\n  &lt;span class=&quot;hljs-attr&quot;&gt;user2&lt;/span&gt;:\n    &lt;span class=&quot;hljs-attr&quot;&gt;chatroom2&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;I&apos;ve pulled both lists to the top-level of the tree, since Firebase recommends against nesting data.&lt;/p&gt;\n&lt;p&gt;Having both lists is completely normal in NoSQL solutions. In the example above we&apos;d refer to &lt;code&gt;userChatrooms&lt;/code&gt; as the inverted index of &lt;code&gt;chatroomsUsers&lt;/code&gt;.&lt;/p&gt;\n&lt;h1&gt;Cloud Firestore&lt;/h1&gt;\n&lt;p&gt;This is one of the cases where Cloud Firestore has better support for this type of query. Its &lt;code&gt;array-contains&lt;/code&gt; operator allows filter documents that have a certain value in an array, while &lt;code&gt;arrayRemove&lt;/code&gt; allows you to treat an array as a set. For more on this, see &lt;a href=&quot;https://firebase.googleblog.com/2018/08/better-arrays-in-cloud-firestore.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Better Arrays in Cloud Firestore&lt;/a&gt;.&lt;/p&gt;\n    "],"comment":["\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;This is an awesome explanation. I have my data stored like this, which allows me to grab a chatroom from a user&apos;s list, or grab a user from a chat room&apos;s members. But what it doesn&apos;t allow is to observe &lt;code&gt;.childChanged&lt;/code&gt; for the chatrooms of which I am a member. If I try to set up an observer for chats where &lt;code&gt;members/myId = true&lt;/code&gt;, then I get the unspecified index error. How would you go about this? I have a question posted here: &lt;a href=&quot;https://stackoverflow.com/questions/47769044/swift-firebase-using-an-unspecified-index&quot; title=&quot;swift firebase using an unspecified index&quot;&gt;stackoverflow.com/questions/47769044/&lt;/a&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1391672/mnearents&quot; title=&quot;616 reputation&quot; class=&quot;comment-user&quot;&gt;mnearents&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment82666014_40657455&quot;&gt;&lt;span title=&quot;2017-12-16 23:14:18Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Dec 16, 2017 at 23:14&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@frank-van-puffelen referencing your last code snippet, let&apos;s say I am &quot;user1&quot; and I fetch all keys of chatrooms I&apos;m a member of. Then for each chatroom key I fetch the full chatroom object, and display the list of chatrooms in a list. That&apos;s good, however, what if I also needed to access full user objects that are a part of a chatroom. It seems very strange that I would have to do another for-loop (2-level nested for-loop!) fetch for every single user in every single chatroom to get that data. Is there a better way?&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1677480/damirstuhec&quot; title=&quot;5,889 reputation&quot; class=&quot;comment-user&quot;&gt;damirstuhec&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment84280595_40657455&quot;&gt;&lt;span title=&quot;2018-02-06 11:34:42Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Feb 6, 2018 at 11:34&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Great explanation. This a brilliant example of how you need to model your data differently to take advantage of NoSQL (and the cheap platforms that use it).&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1034759/freethebees&quot; title=&quot;908 reputation&quot; class=&quot;comment-user&quot;&gt;freethebees&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment123177554_40657455&quot;&gt;&lt;span title=&quot;2021-10-23 10:35:01Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Oct 23, 2021 at 10:35&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        "],"id":393,"title":"Firebase query if child of child contains a value","content":"\n                \n&lt;p&gt;The structure of the table is:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;chats&lt;/li&gt;\n&lt;li&gt;--&amp;gt; randomId&lt;/li&gt;\n&lt;li&gt;--&amp;gt;--&amp;gt; participants&lt;/li&gt;\n&lt;li&gt;--&amp;gt;--&amp;gt;--&amp;gt; 0: &apos;name1&apos;&lt;/li&gt;\n&lt;li&gt;--&amp;gt;--&amp;gt;--&amp;gt; 1: &apos;name2&apos;&lt;/li&gt;\n&lt;li&gt;--&amp;gt;--&amp;gt; chatItems&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;etc&lt;/p&gt;\n\n&lt;p&gt;What I am trying to do is query the chats table to find all the chats that hold a participant by a passed in username string.&lt;/p&gt;\n\n&lt;p&gt;Here is what I have so far:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;subscribeChats&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;username: string&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-variable language_&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;hljs-property&quot;&gt;af&lt;/span&gt;.&lt;span class=&quot;hljs-property&quot;&gt;database&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;list&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;chats&apos;&lt;/span&gt;, {\n        &lt;span class=&quot;hljs-attr&quot;&gt;query&lt;/span&gt;: {\n            &lt;span class=&quot;hljs-attr&quot;&gt;orderByChild&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;participants&apos;&lt;/span&gt;,\n            &lt;span class=&quot;hljs-attr&quot;&gt;equalTo&lt;/span&gt;: username, &lt;span class=&quot;hljs-comment&quot;&gt;// How to check if participants contain username&lt;/span&gt;\n        }\n    });\n }\n&lt;/code&gt;&lt;/pre&gt;\n    ","slug":"firebase-query-if-child-of-child-contains-a-value-1657387841291","postType":"QUESTION","createdAt":"2022-07-09T17:30:41.000Z","updatedAt":"2022-07-09T17:30:41.000Z","tags":[{"id":2125,"name":"angularfire2","slug":"angularfire2","createdAt":"2022-07-09T17:30:41.000Z","updatedAt":"2022-07-09T17:30:41.000Z","Questions_Tags":{"questionId":393,"tagId":2125}}]}},"__N_SSG":true}