<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2eccd4d47c856f2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2eccd4d47c856f2b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/471-84c36aa98dd4107c.js" defer=""></script><script src="/_next/static/chunks/81-096e453de8a27667.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-e3d1b60e109d3ba1.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_buildManifest.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.hFcsiD code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-6e32c308-0"]{content:"hFcsiD,"}/*!sc*/
.ljvTUN .comment-item .comment-body .d-inline-flex.ai-center{text-align:right;}/*!sc*/
.ljvTUN .comment-item .comment-body .comment-date{float:right;}/*!sc*/
data-styled.g6[id="sc-6e32c308-1"]{content:"ljvTUN,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="https://flowbite.com/docs/images/logo.svg" class="mr-3 h-6 sm:h-9" alt="Flowbite Logo"/><span class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Hunter</span></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/what-is-the-difference-between-char-s-and-char-*s-1657387823570#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-6e32c308-0 hFcsiD flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-is-the-difference-between-char-s-and-char-*s-1657387823570">What is the difference between char s[] and char *s?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/char">char</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/constants">constants</a></div></div><div class="question-content mt-5">
                
<p>In C, one can use a string literal in a declaration like this:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> s[] = <span class="hljs-string">"hello"</span>;
</code></pre>

<p>or like this:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *s = <span class="hljs-string">"hello"</span>;
</code></pre>

<p>So what is the difference? I want to know what actually happens in terms of storage duration, both at compile and run time. </p>
    </div></div></div><div class="sc-6e32c308-1 ljvTUN flex text-xs pl-10 flex-col comment items-center justify-center"><h4 class="text-left mt-10 text-lg font-semibold">Comments</h4><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy"><a href="http://c-faq.com/aryptr/index.html" rel="nofollow noreferrer">c-faq.com/aryptr/index.html</a> <a href="http://c-faq.com/charstring/index.html" rel="nofollow noreferrer">c-faq.com/charstring/index.html</a></span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/100754/sinan-%c3%9cn%c3%bcr" title="115,331 reputation" class="comment-user">Sinan Ünür</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment1580808_1704407"><span title="2009-11-09 23:22:17Z, License: CC BY-SA 2.5" class="relativetime-clean">Nov 9, 2009 at 23:22</span></a></span>
            </div>
        </div><span class="divide-x-8 "></span><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy">char *s="hello", here s can point any another string at run time I mean it is not constant pointer you can assign another value at run time p = "Nishant", while s[] here s is constant pointer....it can't be reasign another string but we can assign another character value at s[index].</span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/430803/nishant-kumar" title="5,886 reputation" class="comment-user">Nishant Kumar</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment13764241_1704407"><span title="2012-05-16 14:49:19Z, License: CC BY-SA 3.0" class="relativetime-clean">May 16, 2012 at 14:49</span></a></span>
            </div>
        </div><span class="divide-x-8 "></span><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy">@NishantYou meant ..you can assign another value at run time <b>s</b> = "Nishant", while s[] ... Did you? Otherwise, it is a little bit confusing in the context.</span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/5650705/yifangt" title="97 reputation" class="comment-user">Yifangt</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment126110825_1704407"><span title="2022-03-04 04:26:10Z, License: CC BY-SA 4.0" class="relativetime-clean">Mar 4 at 4:26</span></a></span>
                        <span title="this comment was edited 1 time">
                            <svg aria-hidden="true" class="va-text-bottom o50 svg-icon iconPencilSm" width="14" height="14" viewBox="0 0 14 14"><path d="m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z"></path></svg>
                        </span>
            </div>
        </div><span class="divide-x-8 "></span><button class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">See more</button></div><div class="sc-6e32c308-2 bFXWFO"><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The difference here is that </p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *s = <span class="hljs-string">"Hello world"</span>;
</code></pre>

<p>will place <code>"Hello world"</code> in the <em>read-only parts of the memory</em>, and making <code>s</code> a pointer to that makes any writing operation on this memory illegal. </p>

<p>While doing:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> s[] = <span class="hljs-string">"Hello world"</span>;
</code></pre>

<p>puts the literal string in read-only memory and copies the string to newly allocated memory on the stack. Thus making</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">s[<span class="hljs-number">0</span>] = <span class="hljs-string">'J'</span>;
</code></pre>

<p>legal.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>First off, in function arguments, they are exactly equivalent:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(<span class="hljs-type">char</span> *x)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(<span class="hljs-type">char</span> x[])</span>; <span class="hljs-comment">// exactly the same in all respects</span>
</code></pre>

<p>In other contexts, <code>char *</code> allocates a pointer, while <code>char []</code> allocates an array. Where does the string go in the former case, you ask? The compiler secretly allocates a static anonymous array to hold the string literal. So:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *x = <span class="hljs-string">"Foo"</span>;
<span class="hljs-comment">// is approximately equivalent to:</span>
<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> __secret_anonymous_array[] = <span class="hljs-string">"Foo"</span>;
<span class="hljs-type">char</span> *x = (<span class="hljs-type">char</span> *) __secret_anonymous_array;
</code></pre>

<p>Note that you must not ever attempt to modify the contents of this anonymous array via this pointer; the effects are undefined (often meaning a crash):</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">x[<span class="hljs-number">1</span>] = <span class="hljs-string">'O'</span>; <span class="hljs-comment">// BAD. DON'T DO THIS.</span>
</code></pre>

<p>Using the array syntax directly allocates it into new memory. Thus modification is safe:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> x[] = <span class="hljs-string">"Foo"</span>;
x[<span class="hljs-number">1</span>] = <span class="hljs-string">'O'</span>; <span class="hljs-comment">// No problem.</span>
</code></pre>

<p>However the array only lives as long as its contaning scope, so if you do this in a function, don't return or leak a pointer to this array - make a copy instead with <code>strdup()</code> or similar. If the array is allocated in global scope, of course, no problem.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This declaration:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> s[] = <span class="hljs-string">"hello"</span>;
</code></pre>

<p>Creates <em>one</em> object - a <code>char</code> array of size 6, called <code>s</code>, initialised with the values <code>'h', 'e', 'l', 'l', 'o', '\0'</code>.  Where this array is allocated in memory, and how long it lives for, depends on where the declaration appears.  If the declaration is within a function, it will live until the end of the block that it is declared in, and almost certainly be allocated on the stack; if it's outside a function, it will <em>probably</em> be stored within an "initialised data segment" that is loaded from the executable file into writeable memory when the program is run.</p>

<p>On the other hand, this declaration:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *s =<span class="hljs-string">"hello"</span>;
</code></pre>

<p>Creates <em>two</em> objects:</p>

<ul>
<li>a <strong>read-only</strong> array of 6 <code>char</code>s containing the values <code>'h', 'e', 'l', 'l', 'o', '\0'</code>, which has no name and has <em>static storage duration</em> (meaning that it lives for the entire life of the program); and</li>
<li>a variable of type pointer-to-char, called <code>s</code>, which is initialised with the location of the first character in that unnamed, read-only array.</li>
</ul>

<p>The unnamed read-only array is typically located in the "text" segment of the program, which means it is loaded from disk into read-only memory, along with the code itself.  The location of the <code>s</code> pointer variable in memory depends on where the declaration appears (just like in the first example).</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Given the declarations</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *s0 = <span class="hljs-string">"hello world"</span>;
<span class="hljs-type">char</span> s1[] = <span class="hljs-string">"hello world"</span>;
</code></pre>
<p>assume the following hypothetical memory map (the columns represent characters at offsets 0 to 3 from the given row address, so e.g. the <code>0x00</code> in the bottom right corner is at address <code>0x0001000C + 3</code> = <code>0x0001000F</code>):</p>
<pre>                     +0    +1    +2    +3
        0x00008000: 'h'   'e'   'l'   'l'
        0x00008004: 'o'   ' '   'w'   'o'
        0x00008008: 'r'   'l'   'd'   0x00
        ...
s0:     0x00010000: 0x00  0x00  0x80  0x00
s1:     0x00010004: 'h'   'e'   'l'   'l'
        0x00010008: 'o'   ' '   'w'   'o'
        0x0001000C: 'r'   'l'   'd'   0x00
</pre>
<p>The string literal <code>"hello world"</code> is a 12-element array of <code>char</code> (<code>const char</code> in C++) with static storage duration, meaning that the memory for it is allocated when the program starts up and remains allocated until the program terminates.  Attempting to modify the contents of a string literal invokes undefined behavior.</p>
<p>The line</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *s0 = <span class="hljs-string">"hello world"</span>;
</code></pre>
<p>defines <code>s0</code> as a pointer to <code>char</code> with auto storage duration (meaning the variable <code>s0</code> only exists for the scope in which it is declared) and copies the <em>address</em> of the string literal (<code>0x00008000</code> in this example) to it. Note that since <code>s0</code> points to a string literal, it should not be used as an argument to any function that would try to modify it (e.g., <code>strtok()</code>, <code>strcat()</code>, <code>strcpy()</code>, etc.).</p>
<p>The line</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> s1[] = <span class="hljs-string">"hello world"</span>;
</code></pre>
<p>defines <code>s1</code> as a 12-element array of <code>char</code> (length is taken from the string literal) with auto storage duration and copies the <em>contents</em> of the literal to the array.  As you can see from the memory map, we have two copies of the string <code>"hello world"</code>; the difference is that you can modify the string contained in <code>s1</code>.</p>
<p><code>s0</code> and <code>s1</code> are interchangeable in most contexts; here are the exceptions:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-keyword">sizeof</span> s0 == <span class="hljs-keyword">sizeof</span> (<span class="hljs-type">char</span>*)
<span class="hljs-keyword">sizeof</span> s1 == <span class="hljs-number">12</span>

type of &amp;s0 == <span class="hljs-type">char</span> **
type of &amp;s1 == <span class="hljs-type">char</span> (*)[<span class="hljs-number">12</span>] <span class="hljs-comment">// pointer to a 12-element array of char</span>
</code></pre>
<p>You can reassign the variable <code>s0</code> to point to a different string literal or to another variable.  You cannot reassign the variable <code>s1</code> to point to a different array.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>C99 N1256 draft</strong></p>

<p>There are two different uses of character string literals:</p>

<ol>
<li><p>Initialize <code>char[]</code>:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> c[] = <span class="hljs-string">"abc"</span>;      
</code></pre>

<p>This is "more magic", and described at 6.7.8/14 "Initialization":</p>

<blockquote>
  <p>An array of character type may be initialized by a character string literal, optionally
  enclosed in braces. Successive characters of the character string literal (including the
  terminating null character if there is room or if the array is of unknown size) initialize the
  elements of the array.</p>
</blockquote>

<p>So this is just a shortcut for:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> c[] = {<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'\0'</span>};
</code></pre>

<p>Like any other regular array, <code>c</code> can be modified.</p></li>
<li><p>Everywhere else: it generates an:</p>

<ul>
<li>unnamed</li>
<li>array of char <a href="https://stackoverflow.com/questions/2245664/what-is-the-type-of-string-literals-in-c-c">What is the type of string literals in C and C++?</a></li>
<li>with static storage</li>
<li>that gives UB if modified</li>
</ul>

<p>So when you write:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *c = <span class="hljs-string">"abc"</span>;
</code></pre>

<p>This is similar to:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-comment">/* __unnamed is magic because modifying it gives UB. */</span>
<span class="hljs-type">static</span> <span class="hljs-type">char</span> __unnamed[] = <span class="hljs-string">"abc"</span>;
<span class="hljs-type">char</span> *c = __unnamed;
</code></pre>

<p>Note the implicit cast from <code>char[]</code> to <code>char *</code>, which is always legal.</p>

<p>Then if you modify <code>c[0]</code>, you also modify <code>__unnamed</code>, which is UB.</p>

<p>This is documented at 6.4.5 "String literals":</p>

<blockquote>
  <p>5 In translation phase 7, a byte or code of value zero is appended to each multibyte
  character sequence that results from a string literal or literals. The multibyte character
  sequence is then used to initialize an array of static storage duration and length just
  sufficient to contain the sequence. For character string literals, the array elements have
  type char, and are initialized with the individual bytes of the multibyte character
  sequence [...]</p>
  
  <p>6 It is unspecified whether these arrays are distinct provided their elements have the
  appropriate values. If the program attempts to modify such an array, the behavior is
  undefined.</p>
</blockquote></li>
</ol>

<p>6.7.8/32 "Initialization" gives a direct example:</p>

<blockquote>
  <p>EXAMPLE 8: The declaration</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> s[] = <span class="hljs-string">"abc"</span>, t[<span class="hljs-number">3</span>] = <span class="hljs-string">"abc"</span>;
</code></pre>
  
  <p>defines "plain" char array objects <code>s</code> and <code>t</code> whose elements are initialized with character string literals.</p>
  
  <p>This declaration is identical to</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> s[] = { <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'\0'</span> },
t[] = { <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span> };
</code></pre>
  
  <p>The contents of the arrays are modifiable. On the other hand, the declaration</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *p = <span class="hljs-string">"abc"</span>;
</code></pre>
  
  <p>defines <code>p</code> with type "pointer to char" and initializes it to point to an object with type "array of char" with length 4 whose elements are initialized with a character string literal. If an attempt is made to use <code>p</code> to modify the contents of the array, the behavior is undefined.</p>
</blockquote>

<p><strong>GCC 4.8 x86-64 ELF implementation</strong></p>

<p>Program:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> {
    <span class="hljs-type">char</span> *s = <span class="hljs-string">"abc"</span>;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, s);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>Compile and decompile:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">gcc -ggdb -<span class="hljs-built_in">std</span>=c99 -c main.c
objdump -Sr main.o
</code></pre>

<p>Output contains:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"> <span class="hljs-type">char</span> *s = <span class="hljs-string">"abc"</span>;
<span class="hljs-number">8</span>:  <span class="hljs-number">48</span> c7 <span class="hljs-number">45</span> f8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    movq   $<span class="hljs-number">0x0</span>,<span class="hljs-number">-0x8</span>(%rbp)
f:  <span class="hljs-number">00</span> 
        c: R_X86_64_32S .rodata
</code></pre>

<p>Conclusion: GCC stores <code>char*</code> it in <code>.rodata</code> section, not in <code>.text</code>.</p>

<p>Note however that the default linker script puts <code>.rodata</code> and <code>.text</code> in the same <a href="https://stackoverflow.com/questions/14361248/whats-the-difference-of-section-and-segment-in-elf-file-format/38117710#38117710">segment</a>, which has execute but no write permission. This can be observed with:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">readelf -l a.out
</code></pre>

<p>which contains:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"> Section to Segment mapping:
  Segment Sections...
   <span class="hljs-number">02</span>     .text .rodata
</code></pre>

<p>If we do the same for <code>char[]</code>:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"> <span class="hljs-type">char</span> s[] = <span class="hljs-string">"abc"</span>;
</code></pre>

<p>we obtain:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-number">17</span>:   c7 <span class="hljs-number">45</span> f0 <span class="hljs-number">61</span> <span class="hljs-number">62</span> <span class="hljs-number">63</span> <span class="hljs-number">00</span>    movl   $<span class="hljs-number">0x636261</span>,<span class="hljs-number">-0x10</span>(%rbp)
</code></pre>

<p>so it gets stored in the stack (relative to <code>%rbp</code>).</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> s[] = <span class="hljs-string">"hello"</span>;
</code></pre>

<p>declares <code>s</code> to be an array of <code>char</code> which is long enough to hold the initializer (5 + 1 <code>char</code>s) and initializes the array by copying the members of the given string literal into the array.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *s = <span class="hljs-string">"hello"</span>;
</code></pre>

<p>declares <code>s</code> to be a pointer to one or more (in this case more) <code>char</code>s and points it directly at a fixed (read-only) location containing the literal <code>"hello"</code>.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> s[] = <span class="hljs-string">"Hello world"</span>;
</code></pre>

<p>Here, <code>s</code> is an array of characters, which can be overwritten if we wish.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *s = <span class="hljs-string">"hello"</span>;
</code></pre>

<p>A string literal is used to create these character blocks somewhere in the memory which this pointer <code>s</code> is pointing to. We can here reassign the object it is pointing to by changing that, but as long as it points to a string literal the block of characters to which it points can't be changed.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As an addition, consider that, as for read-only purposes the use of both is identical, you can access a char by indexing either with <code>[]</code> or <code>*(&lt;var&gt; + &lt;index&gt;)</code>
format:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>, x[<span class="hljs-number">1</span>]);     <span class="hljs-comment">//Prints r</span>
</code></pre>

<p>And:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>, *(x + <span class="hljs-number">1</span>)); <span class="hljs-comment">//Prints r</span>
</code></pre>

<p>Obviously, if you attempt to do</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">*(x + <span class="hljs-number">1</span>) = <span class="hljs-string">'a'</span>;
</code></pre>

<p>You will probably get a Segmentation Fault, as you are trying to access read-only memory.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Just to add: you also get different values for their sizes.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"sizeof s[] = %zu\n"</span>, <span class="hljs-keyword">sizeof</span>(s));  <span class="hljs-comment">//6</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"sizeof *s  = %zu\n"</span>, <span class="hljs-keyword">sizeof</span>(s));  <span class="hljs-comment">//4 or 8</span>
</code></pre>

<p>As mentioned above, for an array <code>'\0'</code> will be allocated as the final element.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *str = <span class="hljs-string">"Hello"</span>;
</code></pre>

<p>The above sets str to point to the literal value "Hello" which is hard-coded in the program's binary image, which is flagged as read-only in memory, means any change in this String literal is illegal and that would throw segmentation faults.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> str[] = <span class="hljs-string">"Hello"</span>;
</code></pre>

<p>copies the string to newly allocated memory on the stack. Thus making any change in it is allowed and legal.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">means str[<span class="hljs-number">0</span>] = <span class="hljs-string">'M'</span>;
</code></pre>

<p>will change the str to "Mello".</p>

<p>For more details, please go through the similar question:</p>

<p><a href="https://stackoverflow.com/questions/164194/why-do-i-get-a-segmentation-fault-when-writing-to-a-string-initialized-with-cha">Why do I get a segmentation fault when writing to a string initialized with "char *s" but not "char s[]"?</a></p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>An example to the difference:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"hello"</span> + <span class="hljs-number">2</span>); <span class="hljs-comment">//llo</span>
<span class="hljs-type">char</span> a[] = <span class="hljs-string">"hello"</span> + <span class="hljs-number">2</span>; <span class="hljs-comment">//error</span>
</code></pre>
<p>In the first case pointer arithmetics are working (arrays passed to a function decay to pointers).</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *s1 = <span class="hljs-string">"Hello world"</span>; <span class="hljs-comment">// Points to fixed character string which is not allowed to modify</span>
<span class="hljs-type">char</span> s2[] = <span class="hljs-string">"Hello world"</span>; <span class="hljs-comment">// As good as fixed array of characters in string so allowed to modify</span>

<span class="hljs-comment">// s1[0] = 'J'; // Illegal</span>
s2[<span class="hljs-number">0</span>] = <span class="hljs-string">'J'</span>; <span class="hljs-comment">// Legal</span>
</code></pre>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In the case of:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *x = <span class="hljs-string">"fred"</span>;
</code></pre>

<p>x is an <a href="http://en.wikipedia.org/wiki/Lvalue" rel="nofollow noreferrer">lvalue</a> -- it can be assigned to. But in the case of:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> x[] = <span class="hljs-string">"fred"</span>;
</code></pre>

<p>x is not an lvalue, it is an rvalue -- you cannot assign to it.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In the light of comments here it should be obvious that : char * s = "hello" ;
Is a bad idea, and should be used in very narrow scope. </p>

<p>This might be a good opportunity to point out that "const correctness" is a "good thing". Whenever and wherever You can, use the "const" keyword to protect your code, from "relaxed" callers or programmers, which are usually most "relaxed" when pointers come into play.</p>

<p>Enough melodrama, here is what one can achieve when adorning pointers with "const".
(Note: One has to read pointer declarations right-to-left.)
Here are the 3 different ways to protect yourself when playing with pointers :</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">const</span> DBJ* p means <span class="hljs-string">"p points to a DBJ that is const"</span> 
</code></pre>

<p> that is, the DBJ object can't be changed via p.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">DBJ* <span class="hljs-type">const</span> p means <span class="hljs-string">"p is a const pointer to a DBJ"</span> 
</code></pre>

<p> that is, you can change the DBJ object via p, but you can't change the pointer p itself.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">const</span> DBJ* <span class="hljs-type">const</span> p means <span class="hljs-string">"p is a const pointer to a const DBJ"</span> 
</code></pre>

<p> that is, you can't change the pointer p itself, nor can you change the DBJ object via p.</p>

<p>The errors related to attempted const-ant mutations are caught at compile time. There is no runtime space or speed penalty for const.</p>

<p>(Assumption is you are using C++ compiler, of course ?)</p>

<p>--DBJ</p>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;The difference here is that \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello world\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;will place \u0026lt;code\u0026gt;\u0026quot;Hello world\u0026quot;\u0026lt;/code\u0026gt; in the \u0026lt;em\u0026gt;read-only parts of the memory\u0026lt;/em\u0026gt;, and making \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; a pointer to that makes any writing operation on this memory illegal. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;While doing:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello world\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;puts the literal string in read-only memory and copies the string to newly allocated memory on the stack. Thus making\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;J\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;legal.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;First off, in function arguments, they are exactly equivalent:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *x)\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; x[])\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// exactly the same in all respects\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In other contexts, \u0026lt;code\u0026gt;char *\u0026lt;/code\u0026gt; allocates a pointer, while \u0026lt;code\u0026gt;char []\u0026lt;/code\u0026gt; allocates an array. Where does the string go in the former case, you ask? The compiler secretly allocates a static anonymous array to hold the string literal. So:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *x = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Foo\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// is approximately equivalent to:\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; __secret_anonymous_array[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Foo\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *x = (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *) __secret_anonymous_array;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that you must not ever attempt to modify the contents of this anonymous array via this pointer; the effects are undefined (often meaning a crash):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;x[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;O\u0026apos;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// BAD. DON\u0026apos;T DO THIS.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Using the array syntax directly allocates it into new memory. Thus modification is safe:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; x[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Foo\u0026quot;\u0026lt;/span\u0026gt;;\nx[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;O\u0026apos;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// No problem.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;However the array only lives as long as its contaning scope, so if you do this in a function, don\u0026apos;t return or leak a pointer to this array - make a copy instead with \u0026lt;code\u0026gt;strdup()\u0026lt;/code\u0026gt; or similar. If the array is allocated in global scope, of course, no problem.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This declaration:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Creates \u0026lt;em\u0026gt;one\u0026lt;/em\u0026gt; object - a \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt; array of size 6, called \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt;, initialised with the values \u0026lt;code\u0026gt;\u0026apos;h\u0026apos;, \u0026apos;e\u0026apos;, \u0026apos;l\u0026apos;, \u0026apos;l\u0026apos;, \u0026apos;o\u0026apos;, \u0026apos;\\0\u0026apos;\u0026lt;/code\u0026gt;.  Where this array is allocated in memory, and how long it lives for, depends on where the declaration appears.  If the declaration is within a function, it will live until the end of the block that it is declared in, and almost certainly be allocated on the stack; if it\u0026apos;s outside a function, it will \u0026lt;em\u0026gt;probably\u0026lt;/em\u0026gt; be stored within an \u0026quot;initialised data segment\u0026quot; that is loaded from the executable file into writeable memory when the program is run.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;On the other hand, this declaration:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s =\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Creates \u0026lt;em\u0026gt;two\u0026lt;/em\u0026gt; objects:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;a \u0026lt;strong\u0026gt;read-only\u0026lt;/strong\u0026gt; array of 6 \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt;s containing the values \u0026lt;code\u0026gt;\u0026apos;h\u0026apos;, \u0026apos;e\u0026apos;, \u0026apos;l\u0026apos;, \u0026apos;l\u0026apos;, \u0026apos;o\u0026apos;, \u0026apos;\\0\u0026apos;\u0026lt;/code\u0026gt;, which has no name and has \u0026lt;em\u0026gt;static storage duration\u0026lt;/em\u0026gt; (meaning that it lives for the entire life of the program); and\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;a variable of type pointer-to-char, called \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt;, which is initialised with the location of the first character in that unnamed, read-only array.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;The unnamed read-only array is typically located in the \u0026quot;text\u0026quot; segment of the program, which means it is loaded from disk into read-only memory, along with the code itself.  The location of the \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; pointer variable in memory depends on where the declaration appears (just like in the first example).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Given the declarations\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s0 = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello world\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s1[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello world\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;assume the following hypothetical memory map (the columns represent characters at offsets 0 to 3 from the given row address, so e.g. the \u0026lt;code\u0026gt;0x00\u0026lt;/code\u0026gt; in the bottom right corner is at address \u0026lt;code\u0026gt;0x0001000C + 3\u0026lt;/code\u0026gt; = \u0026lt;code\u0026gt;0x0001000F\u0026lt;/code\u0026gt;):\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;                     +0    +1    +2    +3\n        0x00008000: \u0026apos;h\u0026apos;   \u0026apos;e\u0026apos;   \u0026apos;l\u0026apos;   \u0026apos;l\u0026apos;\n        0x00008004: \u0026apos;o\u0026apos;   \u0026apos; \u0026apos;   \u0026apos;w\u0026apos;   \u0026apos;o\u0026apos;\n        0x00008008: \u0026apos;r\u0026apos;   \u0026apos;l\u0026apos;   \u0026apos;d\u0026apos;   0x00\n        ...\ns0:     0x00010000: 0x00  0x00  0x80  0x00\ns1:     0x00010004: \u0026apos;h\u0026apos;   \u0026apos;e\u0026apos;   \u0026apos;l\u0026apos;   \u0026apos;l\u0026apos;\n        0x00010008: \u0026apos;o\u0026apos;   \u0026apos; \u0026apos;   \u0026apos;w\u0026apos;   \u0026apos;o\u0026apos;\n        0x0001000C: \u0026apos;r\u0026apos;   \u0026apos;l\u0026apos;   \u0026apos;d\u0026apos;   0x00\n\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The string literal \u0026lt;code\u0026gt;\u0026quot;hello world\u0026quot;\u0026lt;/code\u0026gt; is a 12-element array of \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt; (\u0026lt;code\u0026gt;const char\u0026lt;/code\u0026gt; in C++) with static storage duration, meaning that the memory for it is allocated when the program starts up and remains allocated until the program terminates.  Attempting to modify the contents of a string literal invokes undefined behavior.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The line\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s0 = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello world\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;defines \u0026lt;code\u0026gt;s0\u0026lt;/code\u0026gt; as a pointer to \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt; with auto storage duration (meaning the variable \u0026lt;code\u0026gt;s0\u0026lt;/code\u0026gt; only exists for the scope in which it is declared) and copies the \u0026lt;em\u0026gt;address\u0026lt;/em\u0026gt; of the string literal (\u0026lt;code\u0026gt;0x00008000\u0026lt;/code\u0026gt; in this example) to it. Note that since \u0026lt;code\u0026gt;s0\u0026lt;/code\u0026gt; points to a string literal, it should not be used as an argument to any function that would try to modify it (e.g., \u0026lt;code\u0026gt;strtok()\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;strcat()\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;strcpy()\u0026lt;/code\u0026gt;, etc.).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The line\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s1[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello world\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;defines \u0026lt;code\u0026gt;s1\u0026lt;/code\u0026gt; as a 12-element array of \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt; (length is taken from the string literal) with auto storage duration and copies the \u0026lt;em\u0026gt;contents\u0026lt;/em\u0026gt; of the literal to the array.  As you can see from the memory map, we have two copies of the string \u0026lt;code\u0026gt;\u0026quot;hello world\u0026quot;\u0026lt;/code\u0026gt;; the difference is that you can modify the string contained in \u0026lt;code\u0026gt;s1\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;s0\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;s1\u0026lt;/code\u0026gt; are interchangeable in most contexts; here are the exceptions:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; s0 == \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*)\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; s1 == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12\u0026lt;/span\u0026gt;\n\ntype of \u0026amp;amp;s0 == \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; **\ntype of \u0026amp;amp;s1 == \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; (*)[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12\u0026lt;/span\u0026gt;] \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// pointer to a 12-element array of char\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;You can reassign the variable \u0026lt;code\u0026gt;s0\u0026lt;/code\u0026gt; to point to a different string literal or to another variable.  You cannot reassign the variable \u0026lt;code\u0026gt;s1\u0026lt;/code\u0026gt; to point to a different array.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;C99 N1256 draft\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There are two different uses of character string literals:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Initialize \u0026lt;code\u0026gt;char[]\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; c[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;      \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This is \u0026quot;more magic\u0026quot;, and described at 6.7.8/14 \u0026quot;Initialization\u0026quot;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;An array of character type may be initialized by a character string literal, optionally\n  enclosed in braces. Successive characters of the character string literal (including the\n  terminating null character if there is room or if the array is of unknown size) initialize the\n  elements of the array.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;So this is just a shortcut for:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; c[] = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Like any other regular array, \u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt; can be modified.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Everywhere else: it generates an:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;unnamed\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;array of char \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/2245664/what-is-the-type-of-string-literals-in-c-c\u0026quot;\u0026gt;What is the type of string literals in C and C++?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;with static storage\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;that gives UB if modified\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;So when you write:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *c = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This is similar to:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* __unnamed is magic because modifying it gives UB. */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; __unnamed[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *c = __unnamed;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note the implicit cast from \u0026lt;code\u0026gt;char[]\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;char *\u0026lt;/code\u0026gt;, which is always legal.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Then if you modify \u0026lt;code\u0026gt;c[0]\u0026lt;/code\u0026gt;, you also modify \u0026lt;code\u0026gt;__unnamed\u0026lt;/code\u0026gt;, which is UB.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is documented at 6.4.5 \u0026quot;String literals\u0026quot;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;5 In translation phase 7, a byte or code of value zero is appended to each multibyte\n  character sequence that results from a string literal or literals. The multibyte character\n  sequence is then used to initialize an array of static storage duration and length just\n  sufficient to contain the sequence. For character string literals, the array elements have\n  type char, and are initialized with the individual bytes of the multibyte character\n  sequence [...]\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;6 It is unspecified whether these arrays are distinct provided their elements have the\n  appropriate values. If the program attempts to modify such an array, the behavior is\n  undefined.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;6.7.8/32 \u0026quot;Initialization\u0026quot; gives a direct example:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;EXAMPLE 8: The declaration\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;, t[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n  \n  \u0026lt;p\u0026gt;defines \u0026quot;plain\u0026quot; char array objects \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;t\u0026lt;/code\u0026gt; whose elements are initialized with character string literals.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;This declaration is identical to\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[] = { \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt; },\nt[] = { \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt; };\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n  \n  \u0026lt;p\u0026gt;The contents of the arrays are modifiable. On the other hand, the declaration\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *p = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n  \n  \u0026lt;p\u0026gt;defines \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt; with type \u0026quot;pointer to char\u0026quot; and initializes it to point to an object with type \u0026quot;array of char\u0026quot; with length 4 whose elements are initialized with a character string literal. If an attempt is made to use \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt; to modify the contents of the array, the behavior is undefined.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;GCC 4.8 x86-64 ELF implementation\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Program:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%s\\n\u0026quot;\u0026lt;/span\u0026gt;, s);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Compile and decompile:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;gcc -ggdb -\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;=c99 -c main.c\nobjdump -Sr main.o\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Output contains:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;:  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;48\u0026lt;/span\u0026gt; c7 \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;45\u0026lt;/span\u0026gt; f8 \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt;    movq   $\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-0x8\u0026lt;/span\u0026gt;(%rbp)\nf:  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt; \n        c: R_X86_64_32S .rodata\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Conclusion: GCC stores \u0026lt;code\u0026gt;char*\u0026lt;/code\u0026gt; it in \u0026lt;code\u0026gt;.rodata\u0026lt;/code\u0026gt; section, not in \u0026lt;code\u0026gt;.text\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note however that the default linker script puts \u0026lt;code\u0026gt;.rodata\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;.text\u0026lt;/code\u0026gt; in the same \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/14361248/whats-the-difference-of-section-and-segment-in-elf-file-format/38117710#38117710\u0026quot;\u0026gt;segment\u0026lt;/a\u0026gt;, which has execute but no write permission. This can be observed with:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;readelf -l a.out\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;which contains:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt; Section to Segment mapping:\n  Segment Sections...\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;02\u0026lt;/span\u0026gt;     .text .rodata\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If we do the same for \u0026lt;code\u0026gt;char[]\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;we obtain:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;17\u0026lt;/span\u0026gt;:   c7 \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;45\u0026lt;/span\u0026gt; f0 \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;61\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;62\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;63\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt;    movl   $\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x636261\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-0x10\u0026lt;/span\u0026gt;(%rbp)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;so it gets stored in the stack (relative to \u0026lt;code\u0026gt;%rbp\u0026lt;/code\u0026gt;).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;declares \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; to be an array of \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt; which is long enough to hold the initializer (5 + 1 \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt;s) and initializes the array by copying the members of the given string literal into the array.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;declares \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; to be a pointer to one or more (in this case more) \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt;s and points it directly at a fixed (read-only) location containing the literal \u0026lt;code\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello world\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here, \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; is an array of characters, which can be overwritten if we wish.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;A string literal is used to create these character blocks somewhere in the memory which this pointer \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; is pointing to. We can here reassign the object it is pointing to by changing that, but as long as it points to a string literal the block of characters to which it points can\u0026apos;t be changed.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As an addition, consider that, as for read-only purposes the use of both is identical, you can access a char by indexing either with \u0026lt;code\u0026gt;[]\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;*(\u0026amp;lt;var\u0026amp;gt; + \u0026amp;lt;index\u0026amp;gt;)\u0026lt;/code\u0026gt;\nformat:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%c\u0026quot;\u0026lt;/span\u0026gt;, x[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]);     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Prints r\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%c\u0026quot;\u0026lt;/span\u0026gt;, *(x + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Prints r\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Obviously, if you attempt to do\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;*(x + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You will probably get a Segmentation Fault, as you are trying to access read-only memory.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Just to add: you also get different values for their sizes.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;sizeof s[] = %zu\\n\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(s));  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//6\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;sizeof *s  = %zu\\n\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(s));  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//4 or 8\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;As mentioned above, for an array \u0026lt;code\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/code\u0026gt; will be allocated as the final element.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *str = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The above sets str to point to the literal value \u0026quot;Hello\u0026quot; which is hard-coded in the program\u0026apos;s binary image, which is flagged as read-only in memory, means any change in this String literal is illegal and that would throw segmentation faults.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; str[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;copies the string to newly allocated memory on the stack. Thus making any change in it is allowed and legal.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;means str[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;M\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;will change the str to \u0026quot;Mello\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For more details, please go through the similar question:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/164194/why-do-i-get-a-segmentation-fault-when-writing-to-a-string-initialized-with-cha\u0026quot;\u0026gt;Why do I get a segmentation fault when writing to a string initialized with \u0026quot;char *s\u0026quot; but not \u0026quot;char s[]\u0026quot;?\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;An example to the difference:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//llo\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; a[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//error\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In the first case pointer arithmetics are working (arrays passed to a function decay to pointers).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s1 = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello world\u0026quot;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Points to fixed character string which is not allowed to modify\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s2[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello world\u0026quot;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// As good as fixed array of characters in string so allowed to modify\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// s1[0] = \u0026apos;J\u0026apos;; // Illegal\u0026lt;/span\u0026gt;\ns2[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;J\u0026apos;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Legal\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In the case of:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *x = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;fred\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;x is an \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Lvalue\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;lvalue\u0026lt;/a\u0026gt; -- it can be assigned to. But in the case of:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; x[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;fred\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;x is not an lvalue, it is an rvalue -- you cannot assign to it.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In the light of comments here it should be obvious that : char * s = \u0026quot;hello\u0026quot; ;\nIs a bad idea, and should be used in very narrow scope. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This might be a good opportunity to point out that \u0026quot;const correctness\u0026quot; is a \u0026quot;good thing\u0026quot;. Whenever and wherever You can, use the \u0026quot;const\u0026quot; keyword to protect your code, from \u0026quot;relaxed\u0026quot; callers or programmers, which are usually most \u0026quot;relaxed\u0026quot; when pointers come into play.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Enough melodrama, here is what one can achieve when adorning pointers with \u0026quot;const\u0026quot;.\n(Note: One has to read pointer declarations right-to-left.)\nHere are the 3 different ways to protect yourself when playing with pointers :\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; DBJ* p means \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;p points to a DBJ that is const\u0026quot;\u0026lt;/span\u0026gt; \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt; that is, the DBJ object can\u0026apos;t be changed via p.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;DBJ* \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; p means \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;p is a const pointer to a DBJ\u0026quot;\u0026lt;/span\u0026gt; \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt; that is, you can change the DBJ object via p, but you can\u0026apos;t change the pointer p itself.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; DBJ* \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; p means \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;p is a const pointer to a const DBJ\u0026quot;\u0026lt;/span\u0026gt; \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt; that is, you can\u0026apos;t change the pointer p itself, nor can you change the DBJ object via p.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The errors related to attempted const-ant mutations are caught at compile time. There is no runtime space or speed penalty for const.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;(Assumption is you are using C++ compiler, of course ?)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;--DBJ\u0026lt;/p\u0026gt;\n    "],"comment":["\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026lt;a href=\u0026quot;http://c-faq.com/aryptr/index.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;c-faq.com/aryptr/index.html\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;http://c-faq.com/charstring/index.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;c-faq.com/charstring/index.html\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/100754/sinan-%c3%9cn%c3%bcr\u0026quot; title=\u0026quot;115,331 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Sinan Ünür\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment1580808_1704407\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-11-09 23:22:17Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 9, 2009 at 23:22\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;char *s=\u0026quot;hello\u0026quot;, here s can point any another string at run time I mean it is not constant pointer you can assign another value at run time p = \u0026quot;Nishant\u0026quot;, while s[] here s is constant pointer....it can\u0026apos;t be reasign another string but we can assign another character value at s[index].\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/430803/nishant-kumar\u0026quot; title=\u0026quot;5,886 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Nishant Kumar\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment13764241_1704407\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-05-16 14:49:19Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 16, 2012 at 14:49\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@NishantYou meant ..you can assign another value at run time \u0026lt;b\u0026gt;s\u0026lt;/b\u0026gt; = \u0026quot;Nishant\u0026quot;, while s[] ... Did you? Otherwise, it is a little bit confusing in the context.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/5650705/yifangt\u0026quot; title=\u0026quot;97 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Yifangt\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment126110825_1704407\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2022-03-04 04:26:10Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 4 at 4:26\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;The literal string \u0026lt;code\u0026gt;\u0026quot;Hello world\u0026quot;\u0026lt;/code\u0026gt; is in \u0026quot;read-only parts of the memory\u0026quot; in both examples. The example with the array \u0026lt;b\u0026gt;points\u0026lt;/b\u0026gt; there, the example with the array \u0026lt;b\u0026gt;copies\u0026lt;/b\u0026gt; the characters to the array elements.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/25324/pmg\u0026quot; title=\u0026quot;103,914 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;pmg\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment1580550_1704433\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-11-09 22:42:33Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 9, 2009 at 22:42\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;pmg: In the second case the literal string does not necessarily exist in memory as a single contiguous object at all - it\u0026apos;s just an initialiser, the compiler could quite resonably emit a series of \u0026quot;load immediate byte\u0026quot; instructions that contain the character values embedded within them.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/134633/caf\u0026quot; title=\u0026quot;225,929 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;caf\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment1580567_1704433\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-11-09 22:46:00Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 9, 2009 at 22:46\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;The char array example does \u0026lt;i\u0026gt;not\u0026lt;/i\u0026gt; necessarily place the string on the stack - if it appears at file level, it will probably be in some kind of initialised data segment instead.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/134633/caf\u0026quot; title=\u0026quot;225,929 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;caf\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment1580579_1704433\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-11-09 22:47:44Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 9, 2009 at 22:47\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I\u0026apos;d like to point out that char s = \u0026quot;xx\u0026quot; doesn\u0026apos;t \u0026lt;i\u0026gt;have\u0026lt;/i\u0026gt; to be in read-only memory (some implementations have no MMUs, for example). The n1362 c1x draft simply states that modifying such an array causes undefined behavior. But +1 anyway, since relying on that behavior is a silly thing to do.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/14860/paxdiablo\u0026quot; title=\u0026quot;818,480 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;paxdiablo\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment1584080_1704433\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-11-10 12:35:35Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 10, 2009 at 12:35\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I get a clean compile on a file containing just \u0026lt;code\u0026gt;char msg[] = \u0026quot;hello, world!\u0026quot;;\u0026lt;/code\u0026gt;  the string ends up in the initialized data section.  When declared \u0026lt;code\u0026gt;char * const\u0026lt;/code\u0026gt; to end up in the read-only data section.  gcc-4.5.3\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1157237/gcbenison\u0026quot; title=\u0026quot;11,351 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;gcbenison\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment13338945_1704433\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-04-27 15:44:14Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Apr 27, 2012 at 15:44\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;In both declaration for \u0026quot;hello\u0026quot; memory is allocated at comiple time ?.And another thing char *p = \u0026quot;hello\u0026quot; here \u0026quot;hello\u0026quot; is stored in text segment as you stated in your answer...and what about char s[] = \u0026quot;hello\u0026quot; will it also store first in text segment part and during run time it will copy in stack as Rickard has stated in there answer. please clarify this point.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/430803/nishant-kumar\u0026quot; title=\u0026quot;5,886 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Nishant Kumar\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment13764529_1704451\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-05-16 15:00:03Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 16, 2012 at 15:00\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Nishant: In the \u0026lt;code\u0026gt;char s[] = \u0026quot;hello\u0026quot;\u0026lt;/code\u0026gt; case, the \u0026lt;code\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/code\u0026gt; is just an initialiser telling the compiler how the array should be initialised.  It may or may not result in a corresponding string in the text segment - for example, if \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; has static storage duration then it is likely that the only instance of \u0026lt;code\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/code\u0026gt; will be in the initialised data segment - the object \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; itself.  Even if \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; has automatic storage duration, it can be initialised by a sequence of literal stores rather than a copy (eg. \u0026lt;code\u0026gt;movl $1819043176, -6(%ebp); movw $111, -2(%ebp)\u0026lt;/code\u0026gt;).\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/134633/caf\u0026quot; title=\u0026quot;225,929 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;caf\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment13776550_1704451\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-05-17 01:28:50Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 17, 2012 at 1:28\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;More precisely, GCC 4.8 puts it into \u0026lt;code\u0026gt;.rodata\u0026lt;/code\u0026gt;, which the linker script then dumps into the same segment as \u0026lt;code\u0026gt;.text\u0026lt;/code\u0026gt;. See \u0026lt;a href=\u0026quot;http://stackoverflow.com/a/30660839/895245\u0026quot;\u0026gt;my answer\u0026lt;/a\u0026gt;.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/895245/ciro-santilli-%d0%9f%d1%83%d1%82%d0%bb%d0%b5%d1%80-%d0%9a%d0%b0%d0%bf%d1%83%d1%82-%e5%85%ad%e5%9b%9b%e4%ba%8b\u0026quot; title=\u0026quot;306,035 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Ciro Santilli Путлер Капут \u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment49384042_1704451\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-06-05 07:33:27Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 5, 2015 at 7:33\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@caf In the first answer by Rickard, It\u0026apos;s written that \u0026lt;code\u0026gt;char s[] = \u0026quot;Hello world\u0026quot;;\u0026lt;/code\u0026gt; puts the literal string in read-only memory and copies the string to newly allocated memory on the stack. But, your answer only speaks about the literal string put in read-only memory and skips the second part of the sentence which says: \u0026lt;code\u0026gt;copies the string to newly allocated memory on the stack\u0026lt;/code\u0026gt;. So, is your answer incomplete for not specifying the second part?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/7547722/ajaysinghnegi\u0026quot; title=\u0026quot;2,101 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;ajaysinghnegi\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment94977349_1704451\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-01-07 10:11:21Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 7, 2019 at 10:11\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@AjaySinghNegi: As I\u0026apos;ve stated in other comments (to this answer, and Rickard\u0026apos;s answer), the string in \u0026lt;code\u0026gt;char s[] = \u0026quot;Hellow world\u0026quot;;\u0026lt;/code\u0026gt; is only an initializer and is not necessarily stored as a separate read-only copy at all.  If \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; has static storage duration then the only copy of the string is likely to be in a read-write segment at the location of \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt;, and even if not then the compiler may choose to initialize the array with load-immediate instructions or similar rather than copying from a read-only string.  The point is that in this case, the initializer string itself has no runtime presence.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/134633/caf\u0026quot; title=\u0026quot;225,929 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;caf\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment95010229_1704451\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-01-08 09:39:51Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 8, 2019 at 9:39\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;In your memory map, shouldn\u0026apos;t the 4 columns be \u0026lt;code\u0026gt;0x00  0x01  0x02  0x03\u0026lt;/code\u0026gt; instead of \u0026lt;code\u0026gt;0x01  0x02  0x03  0x04\u0026lt;/code\u0026gt;? Otherwise it looks like \u0026lt;code\u0026gt;s0\u0026lt;/code\u0026gt; points to 0x00008000 but the first letter is at 0x00008001. Likewise, it\u0026apos;s unclear whether 0x00008004 is the address of the second \u0026apos;l\u0026apos; or of the \u0026apos;o\u0026apos;.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3982001/fabio-says-reinstate-monica\u0026quot; title=\u0026quot;4,533 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Fabio says Reinstate Monica\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment114058974_1704556\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2020-10-23 17:36:09Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 23, 2020 at 17:36\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;What method is preferable to use in functions if s will not be changed, f(const char s[]) or f(const char *s) ?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/215571/psihodelia\u0026quot; title=\u0026quot;28,334 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;psihodelia\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment9860229_1704440\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-11-08 13:26:20Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 8, 2011 at 13:26\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@psihodelia: In a function declaration there is no difference. In both cases \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; is a pointer to \u0026lt;code\u0026gt;const char\u0026lt;/code\u0026gt;.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/19563/cb-bailey\u0026quot; title=\u0026quot;704,973 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;CB Bailey\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment9861293_1704440\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-11-08 14:20:30Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 8, 2011 at 14:20\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@bo Persson Why the block of characters can\u0026apos;t be changed in the second case?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3215343/pankaj-mahato\u0026quot; title=\u0026quot;1,043 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Pankaj Mahato\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment32348586_1704526\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-01-29 18:28:52Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 29, 2014 at 18:28\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;This is in no way different from \u0026lt;code\u0026gt;x[1] = \u0026apos;a\u0026apos;;\u0026lt;/code\u0026gt; which will segfault as well (depending on the platform, of course).\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/296974/glglgl\u0026quot; title=\u0026quot;85,738 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;glglgl\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment64195347_33996255\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-07-15 10:07:40Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 15, 2016 at 10:07\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;While this code may answer the question, providing additional context regarding why and/or how this code answers the question improves its long-term value.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/4284627/donald-duck\u0026quot; title=\u0026quot;7,706 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Donald Duck\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment114761779_64910447\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2020-11-19 11:47:21Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 19, 2020 at 11:47\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Technically, \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; is a non-modifiable lvalue.  In almost all contexts though, it will evaluate to a pointer to its first element, and \u0026lt;i\u0026gt;that\u0026lt;/i\u0026gt; value is an rvalue.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/134633/caf\u0026quot; title=\u0026quot;225,929 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;caf\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment1580694_1704536\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-11-09 23:02:40Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 9, 2009 at 23:02\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;This is all correct, but it has nothing to do with the question. And as far as your assumption about a C++ compiler, the question is tagged as C, not as C++.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3982001/fabio-says-reinstate-monica\u0026quot; title=\u0026quot;4,533 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Fabio says Reinstate Monica\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment54881644_1704642\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-11-05 17:29:52Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 5, 2015 at 17:29\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;There is nothing bad about char *s = \u0026quot;const string\u0026quot;;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1231935/paul-smith\u0026quot; title=\u0026quot;454 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Paul Smith\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment79152109_1704642\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-09-07 11:31:25Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 7, 2017 at 11:31\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        "],"id":386,"title":"What is the difference between char s[] and char *s?","content":"\n                \n\u0026lt;p\u0026gt;In C, one can use a string literal in a declaration like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;or like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So what is the difference? I want to know what actually happens in terms of storage duration, both at compile and run time. \u0026lt;/p\u0026gt;\n    ","slug":"what-is-the-difference-between-char-s-and-char-*s-1657387823570","postType":"QUESTION","createdAt":"2022-07-09T17:30:23.000Z","updatedAt":"2022-07-09T17:30:23.000Z","tags":[{"id":2098,"name":"char","slug":"char","createdAt":"2022-07-09T17:30:23.000Z","updatedAt":"2022-07-09T17:30:23.000Z","Questions_Tags":{"questionId":386,"tagId":2098}},{"id":2099,"name":"constants","slug":"constants","createdAt":"2022-07-09T17:30:23.000Z","updatedAt":"2022-07-09T17:30:23.000Z","Questions_Tags":{"questionId":386,"tagId":2099}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"what-is-the-difference-between-char-s-and-char-*s-1657387823570"},"buildId":"4Y8KGE-c2lolBeBmcum_I","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>