<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>What is the difference between char s[] and char *s? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="In C, one can use a string literal in a declaration like this:

char s[] = &quot;hello&quot;;


or like this:

char *s = &quot;hello&quot;;


So what is the difference? I want to know what actually happens in terms of storage duration, both at compile and run time. 
    "/><meta property="og:title" content="What is the difference between char s[] and char *s? | Solutions Checker"/><meta property="og:description" content="In C, one can use a string literal in a declaration like this:

char s[] = &quot;hello&quot;;


or like this:

char *s = &quot;hello&quot;;


So what is the difference? I want to know what actually happens in terms of storage duration, both at compile and run time. 
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"What is the difference between char s[] and char *s?","text":"In C, one can use a string literal in a declaration like this:\n\nchar s[] = &quot;hello&quot;;\n\n\nor like this:\n\nchar *s = &quot;hello&quot;;\n\n\nSo what is the difference? I want to know what actually happens in terms of storage duration, both at compile and run time. \n    ","answerCount":14,"upVoteCount":500,"suggestedAnswer":[{"text":"The difference here is that \n\nchar *s = &quot;Hello world&quot;;\n\n\nwill place &quot;Hello world&quot; in the read-only parts of the memory, and making s a pointer to that makes any writing operation on this memory illegal. \n\nWhile doing:\n\nchar s[] = &quot;Hello world&quot;;\n\n\nputs the literal string in read-only memory and copies the string to newly allocated memory on the stack. Thus making\n\ns[0] = &apos;J&apos;;\n\n\nlegal.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"First off, in function arguments, they are exactly equivalent:\n\nvoid foo(char *x);\nvoid foo(char x[]); // exactly the same in all respects\n\n\nIn other contexts, char * allocates a pointer, while char [] allocates an array. Where does the string go in the former case, you ask? The compiler secretly allocates a static anonymous array to hold the string literal. So:\n\nchar *x = &quot;Foo&quot;;\n// is approximately equivalent to:\nstatic const char __secret_anonymous_array[] = &quot;Foo&quot;;\nchar *x = (char *) __secret_anonymous_array;\n\n\nNote that you must not ever attempt to modify the contents of this anonymous array via this pointer; the effects are undefined (often meaning a crash):\n\nx[1] = &apos;O&apos;; // BAD. DON&apos;T DO THIS.\n\n\nUsing the array syntax directly allocates it into new memory. Thus modification is safe:\n\nchar x[] = &quot;Foo&quot;;\nx[1] = &apos;O&apos;; // No problem.\n\n\nHowever the array only lives as long as its contaning scope, so if you do this in a function, don&apos;t return or leak a pointer to this array - make a copy instead with strdup() or similar. If the array is allocated in global scope, of course, no problem.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"This declaration:\n\nchar s[] = &quot;hello&quot;;\n\n\nCreates one object - a char array of size 6, called s, initialised with the values &apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;, &apos;\\0&apos;.  Where this array is allocated in memory, and how long it lives for, depends on where the declaration appears.  If the declaration is within a function, it will live until the end of the block that it is declared in, and almost certainly be allocated on the stack; if it&apos;s outside a function, it will probably be stored within an &quot;initialised data segment&quot; that is loaded from the executable file into writeable memory when the program is run.\n\nOn the other hand, this declaration:\n\nchar *s =&quot;hello&quot;;\n\n\nCreates two objects:\n\n\na read-only array of 6 chars containing the values &apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;, &apos;\\0&apos;, which has no name and has static storage duration (meaning that it lives for the entire life of the program); and\na variable of type pointer-to-char, called s, which is initialised with the location of the first character in that unnamed, read-only array.\n\n\nThe unnamed read-only array is typically located in the &quot;text&quot; segment of the program, which means it is loaded from disk into read-only memory, along with the code itself.  The location of the s pointer variable in memory depends on where the declaration appears (just like in the first example).\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"Given the declarations\nchar *s0 = &quot;hello world&quot;;\nchar s1[] = &quot;hello world&quot;;\n\nassume the following hypothetical memory map (the columns represent characters at offsets 0 to 3 from the given row address, so e.g. the 0x00 in the bottom right corner is at address 0x0001000C + 3 = 0x0001000F):\n                     +0    +1    +2    +3\n        0x00008000: &apos;h&apos;   &apos;e&apos;   &apos;l&apos;   &apos;l&apos;\n        0x00008004: &apos;o&apos;   &apos; &apos;   &apos;w&apos;   &apos;o&apos;\n        0x00008008: &apos;r&apos;   &apos;l&apos;   &apos;d&apos;   0x00\n        ...\ns0:     0x00010000: 0x00  0x00  0x80  0x00\ns1:     0x00010004: &apos;h&apos;   &apos;e&apos;   &apos;l&apos;   &apos;l&apos;\n        0x00010008: &apos;o&apos;   &apos; &apos;   &apos;w&apos;   &apos;o&apos;\n        0x0001000C: &apos;r&apos;   &apos;l&apos;   &apos;d&apos;   0x00\n\nThe string literal &quot;hello world&quot; is a 12-element array of char (const char in C++) with static storage duration, meaning that the memory for it is allocated when the program starts up and remains allocated until the program terminates.  Attempting to modify the contents of a string literal invokes undefined behavior.\nThe line\nchar *s0 = &quot;hello world&quot;;\n\ndefines s0 as a pointer to char with auto storage duration (meaning the variable s0 only exists for the scope in which it is declared) and copies the address of the string literal (0x00008000 in this example) to it. Note that since s0 points to a string literal, it should not be used as an argument to any function that would try to modify it (e.g., strtok(), strcat(), strcpy(), etc.).\nThe line\nchar s1[] = &quot;hello world&quot;;\n\ndefines s1 as a 12-element array of char (length is taken from the string literal) with auto storage duration and copies the contents of the literal to the array.  As you can see from the memory map, we have two copies of the string &quot;hello world&quot;; the difference is that you can modify the string contained in s1.\ns0 and s1 are interchangeable in most contexts; here are the exceptions:\nsizeof s0 == sizeof (char*)\nsizeof s1 == 12\n\ntype of &amp;s0 == char **\ntype of &amp;s1 == char (*)[12] // pointer to a 12-element array of char\n\nYou can reassign the variable s0 to point to a different string literal or to another variable.  You cannot reassign the variable s1 to point to a different array.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"C99 N1256 draft\n\nThere are two different uses of character string literals:\n\n\nInitialize char[]:\n\nchar c[] = &quot;abc&quot;;      \n\n\nThis is &quot;more magic&quot;, and described at 6.7.8/14 &quot;Initialization&quot;:\n\n\n  An array of character type may be initialized by a character string literal, optionally\n  enclosed in braces. Successive characters of the character string literal (including the\n  terminating null character if there is room or if the array is of unknown size) initialize the\n  elements of the array.\n\n\nSo this is just a shortcut for:\n\nchar c[] = {&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;\\0&apos;};\n\n\nLike any other regular array, c can be modified.\nEverywhere else: it generates an:\n\n\nunnamed\narray of char What is the type of string literals in C and C++?\nwith static storage\nthat gives UB if modified\n\n\nSo when you write:\n\nchar *c = &quot;abc&quot;;\n\n\nThis is similar to:\n\n/* __unnamed is magic because modifying it gives UB. */\nstatic char __unnamed[] = &quot;abc&quot;;\nchar *c = __unnamed;\n\n\nNote the implicit cast from char[] to char *, which is always legal.\n\nThen if you modify c[0], you also modify __unnamed, which is UB.\n\nThis is documented at 6.4.5 &quot;String literals&quot;:\n\n\n  5 In translation phase 7, a byte or code of value zero is appended to each multibyte\n  character sequence that results from a string literal or literals. The multibyte character\n  sequence is then used to initialize an array of static storage duration and length just\n  sufficient to contain the sequence. For character string literals, the array elements have\n  type char, and are initialized with the individual bytes of the multibyte character\n  sequence [...]\n  \n  6 It is unspecified whether these arrays are distinct provided their elements have the\n  appropriate values. If the program attempts to modify such an array, the behavior is\n  undefined.\n\n\n\n6.7.8/32 &quot;Initialization&quot; gives a direct example:\n\n\n  EXAMPLE 8: The declaration\n\nchar s[] = &quot;abc&quot;, t[3] = &quot;abc&quot;;\n\n  \n  defines &quot;plain&quot; char array objects s and t whose elements are initialized with character string literals.\n  \n  This declaration is identical to\n\nchar s[] = { &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;\\0&apos; },\nt[] = { &apos;a&apos;, &apos;b&apos;, &apos;c&apos; };\n\n  \n  The contents of the arrays are modifiable. On the other hand, the declaration\n\nchar *p = &quot;abc&quot;;\n\n  \n  defines p with type &quot;pointer to char&quot; and initializes it to point to an object with type &quot;array of char&quot; with length 4 whose elements are initialized with a character string literal. If an attempt is made to use p to modify the contents of the array, the behavior is undefined.\n\n\nGCC 4.8 x86-64 ELF implementation\n\nProgram:\n\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char *s = &quot;abc&quot;;\n    printf(&quot;%s\\n&quot;, s);\n    return 0;\n}\n\n\nCompile and decompile:\n\ngcc -ggdb -std=c99 -c main.c\nobjdump -Sr main.o\n\n\nOutput contains:\n\n char *s = &quot;abc&quot;;\n8:  48 c7 45 f8 00 00 00    movq   $0x0,-0x8(%rbp)\nf:  00 \n        c: R_X86_64_32S .rodata\n\n\nConclusion: GCC stores char* it in .rodata section, not in .text.\n\nNote however that the default linker script puts .rodata and .text in the same segment, which has execute but no write permission. This can be observed with:\n\nreadelf -l a.out\n\n\nwhich contains:\n\n Section to Segment mapping:\n  Segment Sections...\n   02     .text .rodata\n\n\nIf we do the same for char[]:\n\n char s[] = &quot;abc&quot;;\n\n\nwe obtain:\n\n17:   c7 45 f0 61 62 63 00    movl   $0x636261,-0x10(%rbp)\n\n\nso it gets stored in the stack (relative to %rbp).\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"char s[] = &quot;hello&quot;;\n\n\ndeclares s to be an array of char which is long enough to hold the initializer (5 + 1 chars) and initializes the array by copying the members of the given string literal into the array.\n\nchar *s = &quot;hello&quot;;\n\n\ndeclares s to be a pointer to one or more (in this case more) chars and points it directly at a fixed (read-only) location containing the literal &quot;hello&quot;.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"char s[] = &quot;Hello world&quot;;\n\n\nHere, s is an array of characters, which can be overwritten if we wish.\n\nchar *s = &quot;hello&quot;;\n\n\nA string literal is used to create these character blocks somewhere in the memory which this pointer s is pointing to. We can here reassign the object it is pointing to by changing that, but as long as it points to a string literal the block of characters to which it points can&apos;t be changed.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"As an addition, consider that, as for read-only purposes the use of both is identical, you can access a char by indexing either with [] or *(&lt;var&gt; + &lt;index&gt;)\nformat:\n\nprintf(&quot;%c&quot;, x[1]);     //Prints r\n\n\nAnd:\n\nprintf(&quot;%c&quot;, *(x + 1)); //Prints r\n\n\nObviously, if you attempt to do\n\n*(x + 1) = &apos;a&apos;;\n\n\nYou will probably get a Segmentation Fault, as you are trying to access read-only memory.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"Just to add: you also get different values for their sizes.\n\nprintf(&quot;sizeof s[] = %zu\\n&quot;, sizeof(s));  //6\nprintf(&quot;sizeof *s  = %zu\\n&quot;, sizeof(s));  //4 or 8\n\n\nAs mentioned above, for an array &apos;\\0&apos; will be allocated as the final element.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"char *str = &quot;Hello&quot;;\n\n\nThe above sets str to point to the literal value &quot;Hello&quot; which is hard-coded in the program&apos;s binary image, which is flagged as read-only in memory, means any change in this String literal is illegal and that would throw segmentation faults.\n\nchar str[] = &quot;Hello&quot;;\n\n\ncopies the string to newly allocated memory on the stack. Thus making any change in it is allowed and legal.\n\nmeans str[0] = &apos;M&apos;;\n\n\nwill change the str to &quot;Mello&quot;.\n\nFor more details, please go through the similar question:\n\nWhy do I get a segmentation fault when writing to a string initialized with &quot;char *s&quot; but not &quot;char s[]&quot;?\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"An example to the difference:\nprintf(&quot;hello&quot; + 2); //llo\nchar a[] = &quot;hello&quot; + 2; //error\n\nIn the first case pointer arithmetics are working (arrays passed to a function decay to pointers).\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"char *s1 = &quot;Hello world&quot;; // Points to fixed character string which is not allowed to modify\nchar s2[] = &quot;Hello world&quot;; // As good as fixed array of characters in string so allowed to modify\n\n// s1[0] = &apos;J&apos;; // Illegal\ns2[0] = &apos;J&apos;; // Legal\n\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"In the case of:\n\nchar *x = &quot;fred&quot;;\n\n\nx is an lvalue -- it can be assigned to. But in the case of:\n\nchar x[] = &quot;fred&quot;;\n\n\nx is not an lvalue, it is an rvalue -- you cannot assign to it.\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"In the light of comments here it should be obvious that : char * s = &quot;hello&quot; ;\nIs a bad idea, and should be used in very narrow scope. \n\nThis might be a good opportunity to point out that &quot;const correctness&quot; is a &quot;good thing&quot;. Whenever and wherever You can, use the &quot;const&quot; keyword to protect your code, from &quot;relaxed&quot; callers or programmers, which are usually most &quot;relaxed&quot; when pointers come into play.\n\nEnough melodrama, here is what one can achieve when adorning pointers with &quot;const&quot;.\n(Note: One has to read pointer declarations right-to-left.)\nHere are the 3 different ways to protect yourself when playing with pointers :\n\nconst DBJ* p means &quot;p points to a DBJ that is const&quot; \n\n\n that is, the DBJ object can&apos;t be changed via p.\n\nDBJ* const p means &quot;p is a const pointer to a DBJ&quot; \n\n\n that is, you can change the DBJ object via p, but you can&apos;t change the pointer p itself.\n\nconst DBJ* const p means &quot;p is a const pointer to a const DBJ&quot; \n\n\n that is, you can&apos;t change the pointer p itself, nor can you change the DBJ object via p.\n\nThe errors related to attempted const-ant mutations are caught at compile time. There is no runtime space or speed penalty for const.\n\n(Assumption is you are using C++ compiler, of course ?)\n\n--DBJ\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-12e9794e898cd5f3.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-928c5d1eb8fb0bba.js" defer=""></script><script src="/_next/static/BnkbnjkWYxefPXjTJLVVv/_buildManifest.js" defer=""></script><script src="/_next/static/BnkbnjkWYxefPXjTJLVVv/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/what-is-the-difference-between-char-s-and-char-*s-1657387823570#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-is-the-difference-between-char-s-and-char-*s-1657387823570"><h1>What is the difference between char s[] and char *s?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/char">char</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/constants">constants</a></div></div><div class="question-content mt-5">
                
<p>In C, one can use a string literal in a declaration like this:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> s[] = <span class="hljs-string">"hello"</span>;
</code></pre>

<p>or like this:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *s = <span class="hljs-string">"hello"</span>;
</code></pre>

<p>So what is the difference? I want to know what actually happens in terms of storage duration, both at compile and run time. </p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/char">char</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/constants">constants</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The difference here is that </p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *s = <span class="hljs-string">"Hello world"</span>;
</code></pre>

<p>will place <code>"Hello world"</code> in the <em>read-only parts of the memory</em>, and making <code>s</code> a pointer to that makes any writing operation on this memory illegal. </p>

<p>While doing:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> s[] = <span class="hljs-string">"Hello world"</span>;
</code></pre>

<p>puts the literal string in read-only memory and copies the string to newly allocated memory on the stack. Thus making</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">s[<span class="hljs-number">0</span>] = <span class="hljs-string">'J'</span>;
</code></pre>

<p>legal.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/char">char</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/constants">constants</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>First off, in function arguments, they are exactly equivalent:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(<span class="hljs-type">char</span> *x)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(<span class="hljs-type">char</span> x[])</span>; <span class="hljs-comment">// exactly the same in all respects</span>
</code></pre>

<p>In other contexts, <code>char *</code> allocates a pointer, while <code>char []</code> allocates an array. Where does the string go in the former case, you ask? The compiler secretly allocates a static anonymous array to hold the string literal. So:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *x = <span class="hljs-string">"Foo"</span>;
<span class="hljs-comment">// is approximately equivalent to:</span>
<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> __secret_anonymous_array[] = <span class="hljs-string">"Foo"</span>;
<span class="hljs-type">char</span> *x = (<span class="hljs-type">char</span> *) __secret_anonymous_array;
</code></pre>

<p>Note that you must not ever attempt to modify the contents of this anonymous array via this pointer; the effects are undefined (often meaning a crash):</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">x[<span class="hljs-number">1</span>] = <span class="hljs-string">'O'</span>; <span class="hljs-comment">// BAD. DON'T DO THIS.</span>
</code></pre>

<p>Using the array syntax directly allocates it into new memory. Thus modification is safe:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> x[] = <span class="hljs-string">"Foo"</span>;
x[<span class="hljs-number">1</span>] = <span class="hljs-string">'O'</span>; <span class="hljs-comment">// No problem.</span>
</code></pre>

<p>However the array only lives as long as its contaning scope, so if you do this in a function, don't return or leak a pointer to this array - make a copy instead with <code>strdup()</code> or similar. If the array is allocated in global scope, of course, no problem.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/char">char</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/constants">constants</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This declaration:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> s[] = <span class="hljs-string">"hello"</span>;
</code></pre>

<p>Creates <em>one</em> object - a <code>char</code> array of size 6, called <code>s</code>, initialised with the values <code>'h', 'e', 'l', 'l', 'o', '\0'</code>.  Where this array is allocated in memory, and how long it lives for, depends on where the declaration appears.  If the declaration is within a function, it will live until the end of the block that it is declared in, and almost certainly be allocated on the stack; if it's outside a function, it will <em>probably</em> be stored within an "initialised data segment" that is loaded from the executable file into writeable memory when the program is run.</p>

<p>On the other hand, this declaration:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *s =<span class="hljs-string">"hello"</span>;
</code></pre>

<p>Creates <em>two</em> objects:</p>

<ul>
<li>a <strong>read-only</strong> array of 6 <code>char</code>s containing the values <code>'h', 'e', 'l', 'l', 'o', '\0'</code>, which has no name and has <em>static storage duration</em> (meaning that it lives for the entire life of the program); and</li>
<li>a variable of type pointer-to-char, called <code>s</code>, which is initialised with the location of the first character in that unnamed, read-only array.</li>
</ul>

<p>The unnamed read-only array is typically located in the "text" segment of the program, which means it is loaded from disk into read-only memory, along with the code itself.  The location of the <code>s</code> pointer variable in memory depends on where the declaration appears (just like in the first example).</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/char">char</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/constants">constants</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Given the declarations</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *s0 = <span class="hljs-string">"hello world"</span>;
<span class="hljs-type">char</span> s1[] = <span class="hljs-string">"hello world"</span>;
</code></pre>
<p>assume the following hypothetical memory map (the columns represent characters at offsets 0 to 3 from the given row address, so e.g. the <code>0x00</code> in the bottom right corner is at address <code>0x0001000C + 3</code> = <code>0x0001000F</code>):</p>
<pre>                     +0    +1    +2    +3
        0x00008000: 'h'   'e'   'l'   'l'
        0x00008004: 'o'   ' '   'w'   'o'
        0x00008008: 'r'   'l'   'd'   0x00
        ...
s0:     0x00010000: 0x00  0x00  0x80  0x00
s1:     0x00010004: 'h'   'e'   'l'   'l'
        0x00010008: 'o'   ' '   'w'   'o'
        0x0001000C: 'r'   'l'   'd'   0x00
</pre>
<p>The string literal <code>"hello world"</code> is a 12-element array of <code>char</code> (<code>const char</code> in C++) with static storage duration, meaning that the memory for it is allocated when the program starts up and remains allocated until the program terminates.  Attempting to modify the contents of a string literal invokes undefined behavior.</p>
<p>The line</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *s0 = <span class="hljs-string">"hello world"</span>;
</code></pre>
<p>defines <code>s0</code> as a pointer to <code>char</code> with auto storage duration (meaning the variable <code>s0</code> only exists for the scope in which it is declared) and copies the <em>address</em> of the string literal (<code>0x00008000</code> in this example) to it. Note that since <code>s0</code> points to a string literal, it should not be used as an argument to any function that would try to modify it (e.g., <code>strtok()</code>, <code>strcat()</code>, <code>strcpy()</code>, etc.).</p>
<p>The line</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> s1[] = <span class="hljs-string">"hello world"</span>;
</code></pre>
<p>defines <code>s1</code> as a 12-element array of <code>char</code> (length is taken from the string literal) with auto storage duration and copies the <em>contents</em> of the literal to the array.  As you can see from the memory map, we have two copies of the string <code>"hello world"</code>; the difference is that you can modify the string contained in <code>s1</code>.</p>
<p><code>s0</code> and <code>s1</code> are interchangeable in most contexts; here are the exceptions:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-keyword">sizeof</span> s0 == <span class="hljs-keyword">sizeof</span> (<span class="hljs-type">char</span>*)
<span class="hljs-keyword">sizeof</span> s1 == <span class="hljs-number">12</span>

type of &amp;s0 == <span class="hljs-type">char</span> **
type of &amp;s1 == <span class="hljs-type">char</span> (*)[<span class="hljs-number">12</span>] <span class="hljs-comment">// pointer to a 12-element array of char</span>
</code></pre>
<p>You can reassign the variable <code>s0</code> to point to a different string literal or to another variable.  You cannot reassign the variable <code>s1</code> to point to a different array.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/char">char</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/constants">constants</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>C99 N1256 draft</strong></p>

<p>There are two different uses of character string literals:</p>

<ol>
<li><p>Initialize <code>char[]</code>:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> c[] = <span class="hljs-string">"abc"</span>;      
</code></pre>

<p>This is "more magic", and described at 6.7.8/14 "Initialization":</p>

<blockquote>
  <p>An array of character type may be initialized by a character string literal, optionally
  enclosed in braces. Successive characters of the character string literal (including the
  terminating null character if there is room or if the array is of unknown size) initialize the
  elements of the array.</p>
</blockquote>

<p>So this is just a shortcut for:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> c[] = {<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'\0'</span>};
</code></pre>

<p>Like any other regular array, <code>c</code> can be modified.</p></li>
<li><p>Everywhere else: it generates an:</p>

<ul>
<li>unnamed</li>
<li>array of char <a href="https://stackoverflow.com/questions/2245664/what-is-the-type-of-string-literals-in-c-c">What is the type of string literals in C and C++?</a></li>
<li>with static storage</li>
<li>that gives UB if modified</li>
</ul>

<p>So when you write:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *c = <span class="hljs-string">"abc"</span>;
</code></pre>

<p>This is similar to:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-comment">/* __unnamed is magic because modifying it gives UB. */</span>
<span class="hljs-type">static</span> <span class="hljs-type">char</span> __unnamed[] = <span class="hljs-string">"abc"</span>;
<span class="hljs-type">char</span> *c = __unnamed;
</code></pre>

<p>Note the implicit cast from <code>char[]</code> to <code>char *</code>, which is always legal.</p>

<p>Then if you modify <code>c[0]</code>, you also modify <code>__unnamed</code>, which is UB.</p>

<p>This is documented at 6.4.5 "String literals":</p>

<blockquote>
  <p>5 In translation phase 7, a byte or code of value zero is appended to each multibyte
  character sequence that results from a string literal or literals. The multibyte character
  sequence is then used to initialize an array of static storage duration and length just
  sufficient to contain the sequence. For character string literals, the array elements have
  type char, and are initialized with the individual bytes of the multibyte character
  sequence [...]</p>
  
  <p>6 It is unspecified whether these arrays are distinct provided their elements have the
  appropriate values. If the program attempts to modify such an array, the behavior is
  undefined.</p>
</blockquote></li>
</ol>

<p>6.7.8/32 "Initialization" gives a direct example:</p>

<blockquote>
  <p>EXAMPLE 8: The declaration</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> s[] = <span class="hljs-string">"abc"</span>, t[<span class="hljs-number">3</span>] = <span class="hljs-string">"abc"</span>;
</code></pre>
  
  <p>defines "plain" char array objects <code>s</code> and <code>t</code> whose elements are initialized with character string literals.</p>
  
  <p>This declaration is identical to</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> s[] = { <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'\0'</span> },
t[] = { <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span> };
</code></pre>
  
  <p>The contents of the arrays are modifiable. On the other hand, the declaration</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *p = <span class="hljs-string">"abc"</span>;
</code></pre>
  
  <p>defines <code>p</code> with type "pointer to char" and initializes it to point to an object with type "array of char" with length 4 whose elements are initialized with a character string literal. If an attempt is made to use <code>p</code> to modify the contents of the array, the behavior is undefined.</p>
</blockquote>

<p><strong>GCC 4.8 x86-64 ELF implementation</strong></p>

<p>Program:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> {
    <span class="hljs-type">char</span> *s = <span class="hljs-string">"abc"</span>;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, s);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>Compile and decompile:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">gcc -ggdb -<span class="hljs-built_in">std</span>=c99 -c main.c
objdump -Sr main.o
</code></pre>

<p>Output contains:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"> <span class="hljs-type">char</span> *s = <span class="hljs-string">"abc"</span>;
<span class="hljs-number">8</span>:  <span class="hljs-number">48</span> c7 <span class="hljs-number">45</span> f8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    movq   $<span class="hljs-number">0x0</span>,<span class="hljs-number">-0x8</span>(%rbp)
f:  <span class="hljs-number">00</span> 
        c: R_X86_64_32S .rodata
</code></pre>

<p>Conclusion: GCC stores <code>char*</code> it in <code>.rodata</code> section, not in <code>.text</code>.</p>

<p>Note however that the default linker script puts <code>.rodata</code> and <code>.text</code> in the same <a href="https://stackoverflow.com/questions/14361248/whats-the-difference-of-section-and-segment-in-elf-file-format/38117710#38117710">segment</a>, which has execute but no write permission. This can be observed with:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">readelf -l a.out
</code></pre>

<p>which contains:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"> Section to Segment mapping:
  Segment Sections...
   <span class="hljs-number">02</span>     .text .rodata
</code></pre>

<p>If we do the same for <code>char[]</code>:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"> <span class="hljs-type">char</span> s[] = <span class="hljs-string">"abc"</span>;
</code></pre>

<p>we obtain:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-number">17</span>:   c7 <span class="hljs-number">45</span> f0 <span class="hljs-number">61</span> <span class="hljs-number">62</span> <span class="hljs-number">63</span> <span class="hljs-number">00</span>    movl   $<span class="hljs-number">0x636261</span>,<span class="hljs-number">-0x10</span>(%rbp)
</code></pre>

<p>so it gets stored in the stack (relative to <code>%rbp</code>).</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/char">char</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/constants">constants</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> s[] = <span class="hljs-string">"hello"</span>;
</code></pre>

<p>declares <code>s</code> to be an array of <code>char</code> which is long enough to hold the initializer (5 + 1 <code>char</code>s) and initializes the array by copying the members of the given string literal into the array.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *s = <span class="hljs-string">"hello"</span>;
</code></pre>

<p>declares <code>s</code> to be a pointer to one or more (in this case more) <code>char</code>s and points it directly at a fixed (read-only) location containing the literal <code>"hello"</code>.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/char">char</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/constants">constants</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> s[] = <span class="hljs-string">"Hello world"</span>;
</code></pre>

<p>Here, <code>s</code> is an array of characters, which can be overwritten if we wish.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *s = <span class="hljs-string">"hello"</span>;
</code></pre>

<p>A string literal is used to create these character blocks somewhere in the memory which this pointer <code>s</code> is pointing to. We can here reassign the object it is pointing to by changing that, but as long as it points to a string literal the block of characters to which it points can't be changed.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/char">char</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/constants">constants</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As an addition, consider that, as for read-only purposes the use of both is identical, you can access a char by indexing either with <code>[]</code> or <code>*(&lt;var&gt; + &lt;index&gt;)</code>
format:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>, x[<span class="hljs-number">1</span>]);     <span class="hljs-comment">//Prints r</span>
</code></pre>

<p>And:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>, *(x + <span class="hljs-number">1</span>)); <span class="hljs-comment">//Prints r</span>
</code></pre>

<p>Obviously, if you attempt to do</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">*(x + <span class="hljs-number">1</span>) = <span class="hljs-string">'a'</span>;
</code></pre>

<p>You will probably get a Segmentation Fault, as you are trying to access read-only memory.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/char">char</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/constants">constants</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Just to add: you also get different values for their sizes.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"sizeof s[] = %zu\n"</span>, <span class="hljs-keyword">sizeof</span>(s));  <span class="hljs-comment">//6</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"sizeof *s  = %zu\n"</span>, <span class="hljs-keyword">sizeof</span>(s));  <span class="hljs-comment">//4 or 8</span>
</code></pre>

<p>As mentioned above, for an array <code>'\0'</code> will be allocated as the final element.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/char">char</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/constants">constants</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *str = <span class="hljs-string">"Hello"</span>;
</code></pre>

<p>The above sets str to point to the literal value "Hello" which is hard-coded in the program's binary image, which is flagged as read-only in memory, means any change in this String literal is illegal and that would throw segmentation faults.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> str[] = <span class="hljs-string">"Hello"</span>;
</code></pre>

<p>copies the string to newly allocated memory on the stack. Thus making any change in it is allowed and legal.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">means str[<span class="hljs-number">0</span>] = <span class="hljs-string">'M'</span>;
</code></pre>

<p>will change the str to "Mello".</p>

<p>For more details, please go through the similar question:</p>

<p><a href="https://stackoverflow.com/questions/164194/why-do-i-get-a-segmentation-fault-when-writing-to-a-string-initialized-with-cha">Why do I get a segmentation fault when writing to a string initialized with "char *s" but not "char s[]"?</a></p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/char">char</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/constants">constants</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>An example to the difference:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"hello"</span> + <span class="hljs-number">2</span>); <span class="hljs-comment">//llo</span>
<span class="hljs-type">char</span> a[] = <span class="hljs-string">"hello"</span> + <span class="hljs-number">2</span>; <span class="hljs-comment">//error</span>
</code></pre>
<p>In the first case pointer arithmetics are working (arrays passed to a function decay to pointers).</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/char">char</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/constants">constants</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *s1 = <span class="hljs-string">"Hello world"</span>; <span class="hljs-comment">// Points to fixed character string which is not allowed to modify</span>
<span class="hljs-type">char</span> s2[] = <span class="hljs-string">"Hello world"</span>; <span class="hljs-comment">// As good as fixed array of characters in string so allowed to modify</span>

<span class="hljs-comment">// s1[0] = 'J'; // Illegal</span>
s2[<span class="hljs-number">0</span>] = <span class="hljs-string">'J'</span>; <span class="hljs-comment">// Legal</span>
</code></pre>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/char">char</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/constants">constants</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In the case of:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *x = <span class="hljs-string">"fred"</span>;
</code></pre>

<p>x is an <a href="http://en.wikipedia.org/wiki/Lvalue" rel="nofollow noreferrer">lvalue</a> -- it can be assigned to. But in the case of:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> x[] = <span class="hljs-string">"fred"</span>;
</code></pre>

<p>x is not an lvalue, it is an rvalue -- you cannot assign to it.</p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/char">char</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/constants">constants</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In the light of comments here it should be obvious that : char * s = "hello" ;
Is a bad idea, and should be used in very narrow scope. </p>

<p>This might be a good opportunity to point out that "const correctness" is a "good thing". Whenever and wherever You can, use the "const" keyword to protect your code, from "relaxed" callers or programmers, which are usually most "relaxed" when pointers come into play.</p>

<p>Enough melodrama, here is what one can achieve when adorning pointers with "const".
(Note: One has to read pointer declarations right-to-left.)
Here are the 3 different ways to protect yourself when playing with pointers :</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">const</span> DBJ* p means <span class="hljs-string">"p points to a DBJ that is const"</span> 
</code></pre>

<p> that is, the DBJ object can't be changed via p.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">DBJ* <span class="hljs-type">const</span> p means <span class="hljs-string">"p is a const pointer to a DBJ"</span> 
</code></pre>

<p> that is, you can change the DBJ object via p, but you can't change the pointer p itself.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">const</span> DBJ* <span class="hljs-type">const</span> p means <span class="hljs-string">"p is a const pointer to a const DBJ"</span> 
</code></pre>

<p> that is, you can't change the pointer p itself, nor can you change the DBJ object via p.</p>

<p>The errors related to attempted const-ant mutations are caught at compile time. There is no runtime space or speed penalty for const.</p>

<p>(Assumption is you are using C++ compiler, of course ?)</p>

<p>--DBJ</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/how-can-i-access-and-process-nested-objects-arrays-or-json-1657384332823">How can I access and process nested objects, arrays, or JSON?</a><a href="/questions/how-to-deal-with-floating-point-number-precision-in-javascript-1657387293762">How to deal with floating point number precision in JavaScript?</a><a href="/questions/my-attempt-at-value-initialization-is-interpreted-as-a-function-declaration-and-why-doesn&#x27;t-a-a(())-solve-it-1657388474057">My attempt at value initialization is interpreted as a function declaration, and why doesn&#x27;t A a(()); solve it?</a><a href="/questions/list-of-lists-changes-reflected-across-sublists-unexpectedly-1657384393720">List of lists changes reflected across sublists unexpectedly</a><a href="/questions/when-to-use-linkedlist-over-arraylist-in-java-1657388107480">When to use LinkedList over ArrayList in Java?</a><a href="/questions/when-to-use-single-quotes-double-quotes-and-backticks-in-mysql-1657384337981">When to use single quotes, double quotes, and backticks in MySQL</a><a href="/questions/how-do-i-match-any-character-across-multiple-lines-in-a-regular-expression-1657387839720">How do I match any character across multiple lines in a regular expression?</a><a href="/questions/accessing-nested-javascript-objects-and-arrays-by-string-path-1657387321754">Accessing nested JavaScript objects and arrays by string path</a><a href="/questions/what-is-the-canonical-way-to-check-for-errors-using-the-cuda-runtime-api-1657387302698">What is the canonical way to check for errors using the CUDA runtime API?</a><a href="/questions/mergeflatten-an-array-of-arrays-1657387827427">Merge/flatten an array of arrays</a><a href="/questions/how-to-remove-items-from-a-list-while-iterating-1657384496375">How to remove items from a list while iterating?</a><a href="/questions/php-parsesyntax-errors-and-how-to-solve-them-1657384264713">PHP parse/syntax errors; and how to solve them</a><a href="/questions/how-do-i-select-rows-from-a-dataframe-based-on-column-values-1657384901065">How do I select rows from a DataFrame based on column values?</a><a href="/questions/pandas-merging-101-1657384447080">Pandas Merging 101</a><a href="/questions/the-3-different-equals-1657385490242">The 3 different equals</a><a href="/questions/captured-variable-in-a-loop-in-c-1657387696779">Captured variable in a loop in C#</a><a href="/questions/why-can-templates-only-be-implemented-in-the-header-file-1657384341933">Why can templates only be implemented in the header file?</a><a href="/questions/use-dynamic-variable-names-in-javascript-1657388468075">Use dynamic variable names in JavaScript</a><a href="/questions/how-to-use-regular-expressions-(regex)-in-microsoft-excel-both-in-cell-and-loops-1657387487287">How to use Regular Expressions (Regex) in Microsoft Excel both in-cell and loops</a><a href="/questions/what-should-main()-return-in-c-and-c++-1657384745630">What should main() return in C and C++?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;The difference here is that \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello world\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;will place \u0026lt;code\u0026gt;\u0026quot;Hello world\u0026quot;\u0026lt;/code\u0026gt; in the \u0026lt;em\u0026gt;read-only parts of the memory\u0026lt;/em\u0026gt;, and making \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; a pointer to that makes any writing operation on this memory illegal. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;While doing:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello world\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;puts the literal string in read-only memory and copies the string to newly allocated memory on the stack. Thus making\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;J\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;legal.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;First off, in function arguments, they are exactly equivalent:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *x)\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; x[])\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// exactly the same in all respects\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In other contexts, \u0026lt;code\u0026gt;char *\u0026lt;/code\u0026gt; allocates a pointer, while \u0026lt;code\u0026gt;char []\u0026lt;/code\u0026gt; allocates an array. Where does the string go in the former case, you ask? The compiler secretly allocates a static anonymous array to hold the string literal. So:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *x = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Foo\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// is approximately equivalent to:\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; __secret_anonymous_array[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Foo\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *x = (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *) __secret_anonymous_array;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that you must not ever attempt to modify the contents of this anonymous array via this pointer; the effects are undefined (often meaning a crash):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;x[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;O\u0026apos;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// BAD. DON\u0026apos;T DO THIS.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Using the array syntax directly allocates it into new memory. Thus modification is safe:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; x[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Foo\u0026quot;\u0026lt;/span\u0026gt;;\nx[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;O\u0026apos;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// No problem.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;However the array only lives as long as its contaning scope, so if you do this in a function, don\u0026apos;t return or leak a pointer to this array - make a copy instead with \u0026lt;code\u0026gt;strdup()\u0026lt;/code\u0026gt; or similar. If the array is allocated in global scope, of course, no problem.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This declaration:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Creates \u0026lt;em\u0026gt;one\u0026lt;/em\u0026gt; object - a \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt; array of size 6, called \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt;, initialised with the values \u0026lt;code\u0026gt;\u0026apos;h\u0026apos;, \u0026apos;e\u0026apos;, \u0026apos;l\u0026apos;, \u0026apos;l\u0026apos;, \u0026apos;o\u0026apos;, \u0026apos;\\0\u0026apos;\u0026lt;/code\u0026gt;.  Where this array is allocated in memory, and how long it lives for, depends on where the declaration appears.  If the declaration is within a function, it will live until the end of the block that it is declared in, and almost certainly be allocated on the stack; if it\u0026apos;s outside a function, it will \u0026lt;em\u0026gt;probably\u0026lt;/em\u0026gt; be stored within an \u0026quot;initialised data segment\u0026quot; that is loaded from the executable file into writeable memory when the program is run.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;On the other hand, this declaration:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s =\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Creates \u0026lt;em\u0026gt;two\u0026lt;/em\u0026gt; objects:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;a \u0026lt;strong\u0026gt;read-only\u0026lt;/strong\u0026gt; array of 6 \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt;s containing the values \u0026lt;code\u0026gt;\u0026apos;h\u0026apos;, \u0026apos;e\u0026apos;, \u0026apos;l\u0026apos;, \u0026apos;l\u0026apos;, \u0026apos;o\u0026apos;, \u0026apos;\\0\u0026apos;\u0026lt;/code\u0026gt;, which has no name and has \u0026lt;em\u0026gt;static storage duration\u0026lt;/em\u0026gt; (meaning that it lives for the entire life of the program); and\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;a variable of type pointer-to-char, called \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt;, which is initialised with the location of the first character in that unnamed, read-only array.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;The unnamed read-only array is typically located in the \u0026quot;text\u0026quot; segment of the program, which means it is loaded from disk into read-only memory, along with the code itself.  The location of the \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; pointer variable in memory depends on where the declaration appears (just like in the first example).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Given the declarations\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s0 = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello world\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s1[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello world\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;assume the following hypothetical memory map (the columns represent characters at offsets 0 to 3 from the given row address, so e.g. the \u0026lt;code\u0026gt;0x00\u0026lt;/code\u0026gt; in the bottom right corner is at address \u0026lt;code\u0026gt;0x0001000C + 3\u0026lt;/code\u0026gt; = \u0026lt;code\u0026gt;0x0001000F\u0026lt;/code\u0026gt;):\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;                     +0    +1    +2    +3\n        0x00008000: \u0026apos;h\u0026apos;   \u0026apos;e\u0026apos;   \u0026apos;l\u0026apos;   \u0026apos;l\u0026apos;\n        0x00008004: \u0026apos;o\u0026apos;   \u0026apos; \u0026apos;   \u0026apos;w\u0026apos;   \u0026apos;o\u0026apos;\n        0x00008008: \u0026apos;r\u0026apos;   \u0026apos;l\u0026apos;   \u0026apos;d\u0026apos;   0x00\n        ...\ns0:     0x00010000: 0x00  0x00  0x80  0x00\ns1:     0x00010004: \u0026apos;h\u0026apos;   \u0026apos;e\u0026apos;   \u0026apos;l\u0026apos;   \u0026apos;l\u0026apos;\n        0x00010008: \u0026apos;o\u0026apos;   \u0026apos; \u0026apos;   \u0026apos;w\u0026apos;   \u0026apos;o\u0026apos;\n        0x0001000C: \u0026apos;r\u0026apos;   \u0026apos;l\u0026apos;   \u0026apos;d\u0026apos;   0x00\n\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The string literal \u0026lt;code\u0026gt;\u0026quot;hello world\u0026quot;\u0026lt;/code\u0026gt; is a 12-element array of \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt; (\u0026lt;code\u0026gt;const char\u0026lt;/code\u0026gt; in C++) with static storage duration, meaning that the memory for it is allocated when the program starts up and remains allocated until the program terminates.  Attempting to modify the contents of a string literal invokes undefined behavior.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The line\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s0 = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello world\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;defines \u0026lt;code\u0026gt;s0\u0026lt;/code\u0026gt; as a pointer to \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt; with auto storage duration (meaning the variable \u0026lt;code\u0026gt;s0\u0026lt;/code\u0026gt; only exists for the scope in which it is declared) and copies the \u0026lt;em\u0026gt;address\u0026lt;/em\u0026gt; of the string literal (\u0026lt;code\u0026gt;0x00008000\u0026lt;/code\u0026gt; in this example) to it. Note that since \u0026lt;code\u0026gt;s0\u0026lt;/code\u0026gt; points to a string literal, it should not be used as an argument to any function that would try to modify it (e.g., \u0026lt;code\u0026gt;strtok()\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;strcat()\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;strcpy()\u0026lt;/code\u0026gt;, etc.).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The line\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s1[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello world\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;defines \u0026lt;code\u0026gt;s1\u0026lt;/code\u0026gt; as a 12-element array of \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt; (length is taken from the string literal) with auto storage duration and copies the \u0026lt;em\u0026gt;contents\u0026lt;/em\u0026gt; of the literal to the array.  As you can see from the memory map, we have two copies of the string \u0026lt;code\u0026gt;\u0026quot;hello world\u0026quot;\u0026lt;/code\u0026gt;; the difference is that you can modify the string contained in \u0026lt;code\u0026gt;s1\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;s0\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;s1\u0026lt;/code\u0026gt; are interchangeable in most contexts; here are the exceptions:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; s0 == \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*)\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; s1 == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12\u0026lt;/span\u0026gt;\n\ntype of \u0026amp;amp;s0 == \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; **\ntype of \u0026amp;amp;s1 == \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; (*)[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12\u0026lt;/span\u0026gt;] \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// pointer to a 12-element array of char\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;You can reassign the variable \u0026lt;code\u0026gt;s0\u0026lt;/code\u0026gt; to point to a different string literal or to another variable.  You cannot reassign the variable \u0026lt;code\u0026gt;s1\u0026lt;/code\u0026gt; to point to a different array.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;C99 N1256 draft\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There are two different uses of character string literals:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Initialize \u0026lt;code\u0026gt;char[]\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; c[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;      \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This is \u0026quot;more magic\u0026quot;, and described at 6.7.8/14 \u0026quot;Initialization\u0026quot;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;An array of character type may be initialized by a character string literal, optionally\n  enclosed in braces. Successive characters of the character string literal (including the\n  terminating null character if there is room or if the array is of unknown size) initialize the\n  elements of the array.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;So this is just a shortcut for:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; c[] = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Like any other regular array, \u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt; can be modified.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Everywhere else: it generates an:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;unnamed\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;array of char \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/2245664/what-is-the-type-of-string-literals-in-c-c\u0026quot;\u0026gt;What is the type of string literals in C and C++?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;with static storage\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;that gives UB if modified\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;So when you write:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *c = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This is similar to:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* __unnamed is magic because modifying it gives UB. */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; __unnamed[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *c = __unnamed;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note the implicit cast from \u0026lt;code\u0026gt;char[]\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;char *\u0026lt;/code\u0026gt;, which is always legal.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Then if you modify \u0026lt;code\u0026gt;c[0]\u0026lt;/code\u0026gt;, you also modify \u0026lt;code\u0026gt;__unnamed\u0026lt;/code\u0026gt;, which is UB.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is documented at 6.4.5 \u0026quot;String literals\u0026quot;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;5 In translation phase 7, a byte or code of value zero is appended to each multibyte\n  character sequence that results from a string literal or literals. The multibyte character\n  sequence is then used to initialize an array of static storage duration and length just\n  sufficient to contain the sequence. For character string literals, the array elements have\n  type char, and are initialized with the individual bytes of the multibyte character\n  sequence [...]\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;6 It is unspecified whether these arrays are distinct provided their elements have the\n  appropriate values. If the program attempts to modify such an array, the behavior is\n  undefined.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;6.7.8/32 \u0026quot;Initialization\u0026quot; gives a direct example:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;EXAMPLE 8: The declaration\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;, t[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n  \n  \u0026lt;p\u0026gt;defines \u0026quot;plain\u0026quot; char array objects \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;t\u0026lt;/code\u0026gt; whose elements are initialized with character string literals.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;This declaration is identical to\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[] = { \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt; },\nt[] = { \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt; };\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n  \n  \u0026lt;p\u0026gt;The contents of the arrays are modifiable. On the other hand, the declaration\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *p = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n  \n  \u0026lt;p\u0026gt;defines \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt; with type \u0026quot;pointer to char\u0026quot; and initializes it to point to an object with type \u0026quot;array of char\u0026quot; with length 4 whose elements are initialized with a character string literal. If an attempt is made to use \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt; to modify the contents of the array, the behavior is undefined.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;GCC 4.8 x86-64 ELF implementation\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Program:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%s\\n\u0026quot;\u0026lt;/span\u0026gt;, s);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Compile and decompile:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;gcc -ggdb -\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;=c99 -c main.c\nobjdump -Sr main.o\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Output contains:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;:  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;48\u0026lt;/span\u0026gt; c7 \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;45\u0026lt;/span\u0026gt; f8 \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt;    movq   $\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-0x8\u0026lt;/span\u0026gt;(%rbp)\nf:  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt; \n        c: R_X86_64_32S .rodata\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Conclusion: GCC stores \u0026lt;code\u0026gt;char*\u0026lt;/code\u0026gt; it in \u0026lt;code\u0026gt;.rodata\u0026lt;/code\u0026gt; section, not in \u0026lt;code\u0026gt;.text\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note however that the default linker script puts \u0026lt;code\u0026gt;.rodata\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;.text\u0026lt;/code\u0026gt; in the same \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/14361248/whats-the-difference-of-section-and-segment-in-elf-file-format/38117710#38117710\u0026quot;\u0026gt;segment\u0026lt;/a\u0026gt;, which has execute but no write permission. This can be observed with:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;readelf -l a.out\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;which contains:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt; Section to Segment mapping:\n  Segment Sections...\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;02\u0026lt;/span\u0026gt;     .text .rodata\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If we do the same for \u0026lt;code\u0026gt;char[]\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;we obtain:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;17\u0026lt;/span\u0026gt;:   c7 \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;45\u0026lt;/span\u0026gt; f0 \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;61\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;62\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;63\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt;    movl   $\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x636261\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-0x10\u0026lt;/span\u0026gt;(%rbp)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;so it gets stored in the stack (relative to \u0026lt;code\u0026gt;%rbp\u0026lt;/code\u0026gt;).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;declares \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; to be an array of \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt; which is long enough to hold the initializer (5 + 1 \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt;s) and initializes the array by copying the members of the given string literal into the array.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;declares \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; to be a pointer to one or more (in this case more) \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt;s and points it directly at a fixed (read-only) location containing the literal \u0026lt;code\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello world\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here, \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; is an array of characters, which can be overwritten if we wish.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;A string literal is used to create these character blocks somewhere in the memory which this pointer \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; is pointing to. We can here reassign the object it is pointing to by changing that, but as long as it points to a string literal the block of characters to which it points can\u0026apos;t be changed.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As an addition, consider that, as for read-only purposes the use of both is identical, you can access a char by indexing either with \u0026lt;code\u0026gt;[]\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;*(\u0026amp;lt;var\u0026amp;gt; + \u0026amp;lt;index\u0026amp;gt;)\u0026lt;/code\u0026gt;\nformat:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%c\u0026quot;\u0026lt;/span\u0026gt;, x[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]);     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Prints r\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%c\u0026quot;\u0026lt;/span\u0026gt;, *(x + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Prints r\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Obviously, if you attempt to do\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;*(x + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You will probably get a Segmentation Fault, as you are trying to access read-only memory.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Just to add: you also get different values for their sizes.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;sizeof s[] = %zu\\n\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(s));  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//6\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;sizeof *s  = %zu\\n\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(s));  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//4 or 8\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;As mentioned above, for an array \u0026lt;code\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/code\u0026gt; will be allocated as the final element.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *str = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The above sets str to point to the literal value \u0026quot;Hello\u0026quot; which is hard-coded in the program\u0026apos;s binary image, which is flagged as read-only in memory, means any change in this String literal is illegal and that would throw segmentation faults.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; str[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;copies the string to newly allocated memory on the stack. Thus making any change in it is allowed and legal.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;means str[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;M\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;will change the str to \u0026quot;Mello\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For more details, please go through the similar question:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/164194/why-do-i-get-a-segmentation-fault-when-writing-to-a-string-initialized-with-cha\u0026quot;\u0026gt;Why do I get a segmentation fault when writing to a string initialized with \u0026quot;char *s\u0026quot; but not \u0026quot;char s[]\u0026quot;?\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;An example to the difference:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//llo\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; a[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//error\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In the first case pointer arithmetics are working (arrays passed to a function decay to pointers).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s1 = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello world\u0026quot;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Points to fixed character string which is not allowed to modify\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s2[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello world\u0026quot;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// As good as fixed array of characters in string so allowed to modify\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// s1[0] = \u0026apos;J\u0026apos;; // Illegal\u0026lt;/span\u0026gt;\ns2[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;J\u0026apos;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Legal\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In the case of:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *x = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;fred\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;x is an \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Lvalue\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;lvalue\u0026lt;/a\u0026gt; -- it can be assigned to. But in the case of:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; x[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;fred\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;x is not an lvalue, it is an rvalue -- you cannot assign to it.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In the light of comments here it should be obvious that : char * s = \u0026quot;hello\u0026quot; ;\nIs a bad idea, and should be used in very narrow scope. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This might be a good opportunity to point out that \u0026quot;const correctness\u0026quot; is a \u0026quot;good thing\u0026quot;. Whenever and wherever You can, use the \u0026quot;const\u0026quot; keyword to protect your code, from \u0026quot;relaxed\u0026quot; callers or programmers, which are usually most \u0026quot;relaxed\u0026quot; when pointers come into play.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Enough melodrama, here is what one can achieve when adorning pointers with \u0026quot;const\u0026quot;.\n(Note: One has to read pointer declarations right-to-left.)\nHere are the 3 different ways to protect yourself when playing with pointers :\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; DBJ* p means \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;p points to a DBJ that is const\u0026quot;\u0026lt;/span\u0026gt; \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt; that is, the DBJ object can\u0026apos;t be changed via p.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;DBJ* \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; p means \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;p is a const pointer to a DBJ\u0026quot;\u0026lt;/span\u0026gt; \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt; that is, you can change the DBJ object via p, but you can\u0026apos;t change the pointer p itself.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; DBJ* \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; p means \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;p is a const pointer to a const DBJ\u0026quot;\u0026lt;/span\u0026gt; \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt; that is, you can\u0026apos;t change the pointer p itself, nor can you change the DBJ object via p.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The errors related to attempted const-ant mutations are caught at compile time. There is no runtime space or speed penalty for const.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;(Assumption is you are using C++ compiler, of course ?)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;--DBJ\u0026lt;/p\u0026gt;\n    "],"id":386,"title":"What is the difference between char s[] and char *s?","content":"\n                \n\u0026lt;p\u0026gt;In C, one can use a string literal in a declaration like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;or like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So what is the difference? I want to know what actually happens in terms of storage duration, both at compile and run time. \u0026lt;/p\u0026gt;\n    ","slug":"what-is-the-difference-between-char-s-and-char-*s-1657387823570","postType":"QUESTION","createdAt":"2022-07-09T17:30:23.000Z","updatedAt":"2022-07-09T17:30:23.000Z","tags":[{"id":2098,"name":"char","slug":"char","createdAt":"2022-07-09T17:30:23.000Z","updatedAt":"2022-07-09T17:30:23.000Z","Questions_Tags":{"questionId":386,"tagId":2098}},{"id":2099,"name":"constants","slug":"constants","createdAt":"2022-07-09T17:30:23.000Z","updatedAt":"2022-07-09T17:30:23.000Z","Questions_Tags":{"questionId":386,"tagId":2099}}],"relatedQuestions":[{"title":"What is the difference between char s[] and char *s?","slug":"what-is-the-difference-between-char-s-and-char-*s-1657387823570","tags":[{"name":"char","Questions_Tags":{"questionId":386,"tagId":2098}},{"name":"constants","Questions_Tags":{"questionId":386,"tagId":2099}}]}]},"randomQuestions":[{"title":"How can I access and process nested objects, arrays, or JSON?","slug":"how-can-i-access-and-process-nested-objects-arrays-or-json-1657384332823"},{"title":"How to deal with floating point number precision in JavaScript?","slug":"how-to-deal-with-floating-point-number-precision-in-javascript-1657387293762"},{"title":"My attempt at value initialization is interpreted as a function declaration, and why doesn't A a(()); solve it?","slug":"my-attempt-at-value-initialization-is-interpreted-as-a-function-declaration-and-why-doesn't-a-a(())-solve-it-1657388474057"},{"title":"List of lists changes reflected across sublists unexpectedly","slug":"list-of-lists-changes-reflected-across-sublists-unexpectedly-1657384393720"},{"title":"When to use LinkedList over ArrayList in Java?","slug":"when-to-use-linkedlist-over-arraylist-in-java-1657388107480"},{"title":"When to use single quotes, double quotes, and backticks in MySQL","slug":"when-to-use-single-quotes-double-quotes-and-backticks-in-mysql-1657384337981"},{"title":"How do I match any character across multiple lines in a regular expression?","slug":"how-do-i-match-any-character-across-multiple-lines-in-a-regular-expression-1657387839720"},{"title":"Accessing nested JavaScript objects and arrays by string path","slug":"accessing-nested-javascript-objects-and-arrays-by-string-path-1657387321754"},{"title":"What is the canonical way to check for errors using the CUDA runtime API?","slug":"what-is-the-canonical-way-to-check-for-errors-using-the-cuda-runtime-api-1657387302698"},{"title":"Merge/flatten an array of arrays","slug":"mergeflatten-an-array-of-arrays-1657387827427"},{"title":"How to remove items from a list while iterating?","slug":"how-to-remove-items-from-a-list-while-iterating-1657384496375"},{"title":"PHP parse/syntax errors; and how to solve them","slug":"php-parsesyntax-errors-and-how-to-solve-them-1657384264713"},{"title":"How do I select rows from a DataFrame based on column values?","slug":"how-do-i-select-rows-from-a-dataframe-based-on-column-values-1657384901065"},{"title":"Pandas Merging 101","slug":"pandas-merging-101-1657384447080"},{"title":"The 3 different equals","slug":"the-3-different-equals-1657385490242"},{"title":"Captured variable in a loop in C#","slug":"captured-variable-in-a-loop-in-c-1657387696779"},{"title":"Why can templates only be implemented in the header file?","slug":"why-can-templates-only-be-implemented-in-the-header-file-1657384341933"},{"title":"Use dynamic variable names in JavaScript","slug":"use-dynamic-variable-names-in-javascript-1657388468075"},{"title":"How to use Regular Expressions (Regex) in Microsoft Excel both in-cell and loops","slug":"how-to-use-regular-expressions-(regex)-in-microsoft-excel-both-in-cell-and-loops-1657387487287"},{"title":"What should main() return in C and C++?","slug":"what-should-main()-return-in-c-and-c++-1657384745630"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"what-is-the-difference-between-char-s-and-char-*s-1657387823570"},"buildId":"BnkbnjkWYxefPXjTJLVVv","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>