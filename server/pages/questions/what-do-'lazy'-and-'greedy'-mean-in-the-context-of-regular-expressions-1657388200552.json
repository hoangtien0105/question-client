{"pageProps":{"data":{"answer":["\n&lt;p&gt;Greedy will consume as much as possible. From &lt;a href=&quot;http://www.regular-expressions.info/repeat.html&quot; rel=&quot;noreferrer&quot;&gt;http://www.regular-expressions.info/repeat.html&lt;/a&gt; we see the example of trying to match HTML tags with &lt;code&gt;&amp;lt;.+&amp;gt;&lt;/code&gt;. Suppose you have the following:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-css&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;em&lt;/span&gt;&amp;gt;Hello World&amp;lt;/&lt;span class=&quot;hljs-selector-tag&quot;&gt;em&lt;/span&gt;&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You may think that &lt;code&gt;&amp;lt;.+&amp;gt;&lt;/code&gt; (&lt;code&gt;.&lt;/code&gt; means &lt;em&gt;any non newline character&lt;/em&gt; and &lt;code&gt;+&lt;/code&gt; means &lt;em&gt;one or more&lt;/em&gt;) would only match the &lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt; and the &lt;code&gt;&amp;lt;/em&amp;gt;&lt;/code&gt;, when in reality it will be very greedy, and go from the first &lt;code&gt;&amp;lt;&lt;/code&gt; to the last &lt;code&gt;&amp;gt;&lt;/code&gt;. This means it will match &lt;code&gt;&amp;lt;em&amp;gt;Hello World&amp;lt;/em&amp;gt;&lt;/code&gt; instead of what you wanted.&lt;/p&gt;\n\n&lt;p&gt;Making it lazy (&lt;code&gt;&amp;lt;.+?&amp;gt;&lt;/code&gt;) will prevent this. By adding the &lt;code&gt;?&lt;/code&gt; after the &lt;code&gt;+&lt;/code&gt;, we tell it to repeat &lt;em&gt;as few times as possible&lt;/em&gt;, so the first &lt;code&gt;&amp;gt;&lt;/code&gt; it comes across, is where we want to stop the matching.&lt;/p&gt;\n\n&lt;p&gt;I&apos;d encourage you to download &lt;a href=&quot;http://www.gskinner.com/RegExr/&quot; rel=&quot;noreferrer&quot;&gt;RegExr&lt;/a&gt;, a great tool that will help you explore Regular Expressions - I use it all the time.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;&apos;Greedy&apos;&lt;/strong&gt; means match longest possible string.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;&apos;Lazy&apos;&lt;/strong&gt; means match shortest possible string.&lt;/p&gt;\n\n&lt;p&gt;For example, the greedy &lt;code&gt;h.+l&lt;/code&gt; matches &lt;code&gt;&apos;hell&apos;&lt;/code&gt; in &lt;code&gt;&apos;hello&apos;&lt;/code&gt; but the lazy &lt;code&gt;h.+?l&lt;/code&gt; matches &lt;code&gt;&apos;hel&apos;&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;div class=&quot;s-table-container&quot;&gt;\n&lt;table class=&quot;s-table&quot;&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;Greedy quantifier&lt;/th&gt;\n&lt;th&gt;Lazy quantifier&lt;/th&gt;\n&lt;th&gt;Description&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;&lt;code&gt;*?&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;Star Quantifier: 0 or more&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;code&gt;+&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;&lt;code&gt;+?&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;Plus Quantifier: 1 or more&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;code&gt;?&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;&lt;code&gt;??&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;Optional Quantifier: 0 or 1&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;code&gt;{n}&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;&lt;code&gt;{n}?&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;Quantifier: exactly n&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;code&gt;{n,}&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;&lt;code&gt;{n,}?&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;Quantifier: n or more&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;code&gt;{n,m}&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;&lt;code&gt;{n,m}?&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;Quantifier: between n and m&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;/div&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Add a ? to a quantifier to make it ungreedy i.e lazy.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;br&gt;\ntest string : &lt;em&gt;stackoverflow&lt;/em&gt;&lt;br&gt;\n&lt;em&gt;greedy reg expression&lt;/em&gt; : &lt;a href=&quot;http://regexr.com/3glo4&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;s.*o&lt;/code&gt;&lt;/a&gt; output: &lt;strong&gt;stackoverflo&lt;/strong&gt;w&lt;br&gt;\n&lt;em&gt;lazy reg expression&lt;/em&gt; : &lt;a href=&quot;http://regexr.com/3glo7&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;s.*?o&lt;/code&gt;&lt;/a&gt; output: &lt;strong&gt;stacko&lt;/strong&gt;verflow&lt;/p&gt;\n    ","\n&lt;p&gt;Greedy means your expression will match as large a group as possible, lazy means it will match the smallest group possible.  For this string:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-undefined&quot;&gt;abcdefghijklmc\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and this expression:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;a&lt;/span&gt;.*c\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;A greedy match will match the whole string, and a lazy match will match just the first &lt;code&gt;abc&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;As far as I know, most regex engine is greedy by default. Add a question mark at the end of quantifier will enable lazy match.&lt;/p&gt;\n&lt;p&gt;As @Andre S mentioned in comment.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Greedy: Keep searching until condition is not satisfied.&lt;/li&gt;\n&lt;li&gt;Lazy: Stop searching once condition is satisfied.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Refer to the example below for what is greedy and what is lazy.&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.util.regex.Matcher;\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.util.regex.Pattern;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Test&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String args[])&lt;/span&gt;{\n        &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;money&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;100000000999&quot;&lt;/span&gt;;\n        &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;greedyRegex&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;100(0*)&quot;&lt;/span&gt;;\n        &lt;span class=&quot;hljs-type&quot;&gt;Pattern&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;pattern&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; Pattern.compile(greedyRegex);\n        &lt;span class=&quot;hljs-type&quot;&gt;Matcher&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;matcher&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; pattern.matcher(money);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(matcher.find()){\n            System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;I&apos;m greedy and I want &quot;&lt;/span&gt; + matcher.group() + &lt;span class=&quot;hljs-string&quot;&gt;&quot; dollars. This is the most I can get.&quot;&lt;/span&gt;);\n        }\n        \n        &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;lazyRegex&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;100(0*?)&quot;&lt;/span&gt;;\n        pattern = Pattern.compile(lazyRegex);\n        matcher = pattern.matcher(money);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(matcher.find()){\n            System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;I&apos;m too lazy to get so much money, only &quot;&lt;/span&gt; + matcher.group() + &lt;span class=&quot;hljs-string&quot;&gt;&quot; dollars is enough for me&quot;&lt;/span&gt;);\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;hr&gt;\nThe result is:\n```\nI&apos;m greedy and I want 100000000 dollars. This is the most I can get.\n&lt;p&gt;I&apos;m too lazy to get so much money, only 100 dollars is enough for me&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-undefined&quot;&gt;\n\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Taken From &lt;a href=&quot;http://www.regular-expressions.info/possessive.html&quot; rel=&quot;noreferrer&quot;&gt;www.regular-expressions.info&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Greediness&lt;/strong&gt;: Greedy quantifiers first tries to repeat the token as many times\nas possible, and gradually gives up matches as the engine backtracks to find \nan overall match.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Laziness&lt;/strong&gt;: Lazy quantifier first repeats the token as few times as required, and\ngradually expands the match as the engine backtracks through the regex to\nfind an overall match.&lt;/p&gt;\n    ","\n&lt;p&gt;From &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot; rel=&quot;noreferrer&quot;&gt;Regular expression&lt;/a&gt;&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;The standard quantifiers in regular\n  expressions are greedy, meaning they\n  match as much as they can, only giving\n  back as necessary to match the\n  remainder of the regex. &lt;/p&gt;\n  \n  &lt;p&gt;By using a lazy quantifier, the\n  expression tries the minimal match\n  first.&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;h2&gt;Greedy Quantifiers are like the IRS&lt;/h2&gt;\n&lt;p&gt;Theyll take as much as they can. e.g. matches with this regex: &lt;code&gt;.*&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;$50,000&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;Bye-bye bank balance.&lt;/p&gt;\n&lt;p&gt;See here for an example: &lt;a href=&quot;https://regexr.com/4t27f&quot; rel=&quot;nofollow noreferrer&quot;&gt;Greedy-example&lt;/a&gt;&lt;/p&gt;\n&lt;h2&gt;Non-greedy quantifiers - they take as little as they can&lt;/h2&gt;\n&lt;p&gt;Ask for a tax refund: the IRS sudden becomes non-greedy - and return as little as possible: i.e. they use this quantifier:&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;(.{2,5}?)([0-9]*)&lt;/code&gt; against this input: &lt;code&gt;$50,000&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;The first group is non-needy and only matches &lt;code&gt;$5&lt;/code&gt;  so I get a &lt;code&gt;$5&lt;/code&gt; refund against the $50,000 input.&lt;/p&gt;\n&lt;p&gt;See here: &lt;a href=&quot;https://regexr.com/59qrk&quot; rel=&quot;nofollow noreferrer&quot;&gt;Non-greedy-example&lt;/a&gt;.&lt;/p&gt;\n&lt;h2&gt;Why do we need greedy vs non-greedy?&lt;/h2&gt;\n&lt;p&gt;It becomes important if you are trying to match certain parts of an expression. Sometimes you don&apos;t want to match everything - as little as possible. Sometimes you want to match as much as possible. Nothing more to it.&lt;/p&gt;\n&lt;p&gt;You can play around with the examples in the links posted above.&lt;/p&gt;\n&lt;p&gt;(Analogy used to help you remember).&lt;/p&gt;\n    ","\n&lt;p&gt;Best shown by example. String. &lt;code&gt;192.168.1.1&lt;/code&gt; and a greedy regex &lt;code&gt;\\b.+\\b&lt;/code&gt;\nYou might think this would give you the 1st octet but is actually matches against the whole string. Why? Because the.+ is greedy and a greedy match matches every character in &lt;code&gt;192.168.1.1&lt;/code&gt; until it reaches the end of the string. This is the important bit! Now it starts to backtrack one character at a time until it finds a match for the 3rd token (&lt;code&gt;\\b&lt;/code&gt;).&lt;/p&gt;\n\n&lt;p&gt;If the string a 4GB text file and 192.168.1.1 was at the start you could easily see how this backtracking would cause an issue.&lt;/p&gt;\n\n&lt;p&gt;To make a regex non greedy (lazy) put a question mark after your greedy search e.g&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-ruby&quot;&gt;*?\n&lt;span class=&quot;hljs-string&quot;&gt;??&lt;/span&gt;\n+?\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;What happens now is token 2 (&lt;code&gt;+?&lt;/code&gt;) finds a match, regex moves along a character and then tries the next token (&lt;code&gt;\\b&lt;/code&gt;) rather than token 2 (&lt;code&gt;+?&lt;/code&gt;). So it creeps along gingerly.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Greedy matching.&lt;/strong&gt; The default behavior of regular expressions is to be greedy. That means it tries to extract as much as possible until it conforms to a pattern even when a smaller part would have been syntactically sufficient.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-coffeescript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; re\ntext = &lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;body&amp;gt;Regex Greedy Matching Example &amp;lt;/body&amp;gt;&quot;&lt;/span&gt;\nre.findall(&lt;span class=&quot;hljs-string&quot;&gt;&apos;&amp;lt;.*&amp;gt;&apos;&lt;/span&gt;, text)\n&lt;span class=&quot;hljs-comment&quot;&gt;#&amp;gt; [&apos;&amp;lt;body&amp;gt;Regex Greedy Matching Example &amp;lt;/body&amp;gt;&apos;]&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Instead of matching till the first occurrence of &amp;gt;, it extracted the whole string. This is the default greedy or take it all behavior of regex.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Lazy matching&lt;/strong&gt;, on the other hand, takes as little as possible. This can be effected by adding a &lt;code&gt;?&lt;/code&gt; at the end of the pattern.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-less&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;re&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.findall&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;&amp;lt;.*?&amp;gt;&apos;&lt;/span&gt;, text)\n#&amp;gt; &lt;span class=&quot;hljs-selector-attr&quot;&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&apos;&amp;lt;body&amp;gt;&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;&amp;lt;/body&amp;gt;&apos;&lt;/span&gt;]&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;If you want only the first match to be retrieved, use the search method instead.&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;re.search(&lt;span class=&quot;hljs-string&quot;&gt;&apos;&amp;lt;.*?&amp;gt;&apos;&lt;/span&gt;, text).&lt;span class=&quot;hljs-keyword&quot;&gt;group&lt;/span&gt;()\n&lt;span class=&quot;hljs-meta&quot;&gt;#&amp;gt; &apos;&amp;lt;body&amp;gt;&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Source: &lt;a href=&quot;https://www.machinelearningplus.com/python-regex-tutorial-examples/#greedy_matching_in_regex&quot; rel=&quot;nofollow noreferrer&quot;&gt;Python Regex Examples&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Greedy means it will consume your pattern until there are none of them left and it can look no further.&lt;/p&gt;\n\n&lt;p&gt;Lazy will stop as soon as it will encounter the first pattern you requested.&lt;/p&gt;\n\n&lt;p&gt;One common example that I often encounter is &lt;code&gt;\\s*-\\s*?&lt;/code&gt; of a regex &lt;code&gt;([0-9]{2}\\s*-\\s*?[0-9]{7})&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;The first &lt;code&gt;\\s*&lt;/code&gt; is classified as greedy because of &lt;code&gt;*&lt;/code&gt; and will look as many white spaces as possible after the digits are encountered and then look for a dash character &quot;-&quot;. Where as the second &lt;code&gt;\\s*?&lt;/code&gt; is lazy because of the present of &lt;code&gt;*?&lt;/code&gt; which means that it will look the first white space character and stop right there.&lt;/p&gt;\n    ","\n&lt;p&gt;try to understand the following behavior:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-dart&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; input = &lt;span class=&quot;hljs-string&quot;&gt;&quot;0014.2&quot;&lt;/span&gt;;\n\nRegex r1 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Regex(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\\\\d+.{0,1}\\\\d+&quot;&lt;/span&gt;);\nRegex r2 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Regex(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\\\\d*.{0,1}\\\\d*&quot;&lt;/span&gt;);\n\nConsole.WriteLine(r1.&lt;span class=&quot;hljs-built_in&quot;&gt;Match&lt;/span&gt;(input).Value); &lt;span class=&quot;hljs-comment&quot;&gt;// &quot;0014.2&quot;&lt;/span&gt;\nConsole.WriteLine(r2.&lt;span class=&quot;hljs-built_in&quot;&gt;Match&lt;/span&gt;(input).Value); &lt;span class=&quot;hljs-comment&quot;&gt;// &quot;0014.2&quot;&lt;/span&gt;\n\ninput = &lt;span class=&quot;hljs-string&quot;&gt;&quot; 0014.2&quot;&lt;/span&gt;;\n\nConsole.WriteLine(r1.&lt;span class=&quot;hljs-built_in&quot;&gt;Match&lt;/span&gt;(input).Value); &lt;span class=&quot;hljs-comment&quot;&gt;// &quot;0014.2&quot;&lt;/span&gt;\nConsole.WriteLine(r2.&lt;span class=&quot;hljs-built_in&quot;&gt;Match&lt;/span&gt;(input).Value); &lt;span class=&quot;hljs-comment&quot;&gt;// &quot; 0014&quot;&lt;/span&gt;\n\ninput = &lt;span class=&quot;hljs-string&quot;&gt;&quot;  0014.2&quot;&lt;/span&gt;;\n\nConsole.WriteLine(r1.&lt;span class=&quot;hljs-built_in&quot;&gt;Match&lt;/span&gt;(input).Value); &lt;span class=&quot;hljs-comment&quot;&gt;// &quot;0014.2&quot;&lt;/span&gt;\nConsole.WriteLine(r2.&lt;span class=&quot;hljs-built_in&quot;&gt;Match&lt;/span&gt;(input).Value); &lt;span class=&quot;hljs-comment&quot;&gt;// &quot;&quot;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    "],"comment":["\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;See also &lt;a href=&quot;http://stackoverflow.com/questions/3075130/difference-between-and-for-regex/3075532#3075532&quot; title=&quot;difference between and for regex&quot;&gt;stackoverflow.com/questions/3075130/&lt;/a&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/276101/polygenelubricants&quot; title=&quot;365,131 reputation&quot; class=&quot;comment-user&quot;&gt;polygenelubricants&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment3726040_2301285&quot;&gt;&lt;span title=&quot;2010-08-24 11:43:25Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Aug 24, 2010 at 11:43&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;so if you use greedy will u have 3 (1 element + 2 tags) matches or just 1 match (1 element)?&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/206446/ajsie&quot; title=&quot;74,372 reputation&quot; class=&quot;comment-user owner&quot;&gt;ajsie&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment2266880_2301298&quot;&gt;&lt;span title=&quot;2010-02-20 06:27:12Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Feb 20, 2010 at 6:27&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;It would match only 1 time, starting from the first &lt;b&gt;&amp;lt;&lt;/b&gt; and ending with the last &lt;b&gt;&amp;gt;&lt;/b&gt;.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/54680/sampson&quot; title=&quot;259,800 reputation&quot; class=&quot;comment-user&quot;&gt;Sampson&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment2266883_2301298&quot;&gt;&lt;span title=&quot;2010-02-20 06:28:15Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Feb 20, 2010 at 6:28&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;But making it lazy would match twice, giving us both the opening and closing tag, ignoring the text in between (since it doesn&apos;t fit the expression).&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/54680/sampson&quot; title=&quot;259,800 reputation&quot; class=&quot;comment-user&quot;&gt;Sampson&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment2266886_2301298&quot;&gt;&lt;span title=&quot;2010-02-20 06:29:13Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Feb 20, 2010 at 6:29&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Just to add that there is a greedy way to go about it, too: &lt;code&gt;&amp;lt;[^&amp;gt;]+&amp;gt;&lt;/code&gt; &lt;a href=&quot;https://regex101.com/r/lW0cY6/1&quot; rel=&quot;nofollow noreferrer&quot;&gt;regex101.com/r/lW0cY6/1&lt;/a&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/4637110/alanbuchanan&quot; title=&quot;3,663 reputation&quot; class=&quot;comment-user&quot;&gt;alanbuchanan&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment49735048_2301298&quot;&gt;&lt;span title=&quot;2015-06-15 12:57:18Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 15, 2015 at 12:57&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;For the record, about using regex with HTML &lt;a href=&quot;https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags&quot; title=&quot;regex match open tags except xhtml self contained tags&quot;&gt;stackoverflow.com/questions/1732348/&lt;/a&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/3163618/qwr&quot; title=&quot;8,208 reputation&quot; class=&quot;comment-user&quot;&gt;qwr&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment120091521_2301298&quot;&gt;&lt;span title=&quot;2021-06-11 22:00:49Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 11, 2021 at 22:00&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Brilliant, so  lazy will stop as soon as the condition l is satisfied, but greedy means it will stop only once the condition l is not satisfied any more?&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/966656/andrew-s&quot; title=&quot;2,585 reputation&quot; class=&quot;comment-user&quot;&gt;Andrew S&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment33298507_2301291&quot;&gt;&lt;span title=&quot;2014-02-23 21:27:00Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Feb 23, 2014 at 21:27&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;For all people reading the post: greedy or lazy quantifiers by themselves won&apos;t match the longest/shortest possible substring. You would have to use either a &lt;a href=&quot;http://www.rexegg.com/regex-quantifiers.html#tempered_greed&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;b&gt;tempered greedy token&lt;/b&gt;&lt;/a&gt;, or use non-regex approaches.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/3832970/wiktor-stribi%c5%bcew&quot; title=&quot;567,443 reputation&quot; class=&quot;comment-user&quot;&gt;Wiktor Stribiżew&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment67402805_2301291&quot;&gt;&lt;span title=&quot;2016-10-15 21:29:59Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Oct 15, 2016 at 21:29&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@AndrewS Don&apos;t be confused by the double ll in the example. It&apos;s rather lazy will match the shortest possible substring while greedy will match the longest possible. Greedy &lt;code&gt;h.+l&lt;/code&gt; matches &lt;code&gt;&apos;helol&apos;&lt;/code&gt; in &lt;code&gt;&apos;helolo&apos;&lt;/code&gt; but the lazy &lt;code&gt;h.+?l&lt;/code&gt; matches &lt;code&gt;&apos;hel&apos;&lt;/code&gt;.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1894053/v-shashenko&quot; title=&quot;696 reputation&quot; class=&quot;comment-user&quot;&gt;v.shashenko&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment72963578_2301291&quot;&gt;&lt;span title=&quot;2017-03-21 16:38:58Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Mar 21, 2017 at 16:38&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 2 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@FloatingRock: No. &lt;code&gt;x?&lt;/code&gt; means &lt;code&gt;x&lt;/code&gt; is optional but &lt;code&gt;+?&lt;/code&gt; is a different syntax. It means stop looking after you find something that matches - lazy matching.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/167735/slebetman&quot; title=&quot;102,945 reputation&quot; class=&quot;comment-user&quot;&gt;slebetman&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment73882655_2301291&quot;&gt;&lt;span title=&quot;2017-04-14 12:56:34Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 14, 2017 at 12:56&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@FloatingRock: As for how you differentiate the different syntax, simple: &lt;code&gt;?&lt;/code&gt; means optional and &lt;code&gt;+?&lt;/code&gt; means lazy. Therefore &lt;code&gt;\\+?&lt;/code&gt; means &lt;code&gt;+&lt;/code&gt; is optional.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/167735/slebetman&quot; title=&quot;102,945 reputation&quot; class=&quot;comment-user&quot;&gt;slebetman&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment73882692_2301291&quot;&gt;&lt;span title=&quot;2017-04-14 12:57:45Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 14, 2017 at 12:57&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;is not ?? equivalent to ? . Similarly , isn&apos;t {n}? equivalen to {n}&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/2844702/number945&quot; title=&quot;4,291 reputation&quot; class=&quot;comment-user&quot;&gt;Number945&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment65908617_34806154&quot;&gt;&lt;span title=&quot;2016-09-02 08:07:04Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Sep 2, 2016 at 8:07&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 2 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@BreakingBenjamin: no ?? is not equivalent to ?, when it has a choice to either return 0 or 1 occurrence, it will pick the 0 (lazy) alternative. To see the difference, compare &lt;code&gt;re.match(&apos;(f)?(.*)&apos;, &apos;food&apos;).groups()&lt;/code&gt; to &lt;code&gt;re.match(&apos;(f)??(.*)&apos;, &apos;food&apos;).groups()&lt;/code&gt;. In the latter, &lt;code&gt;(f)??&lt;/code&gt; will not match the leading &apos;f&apos; even though it could. Hence the &apos;f&apos; will get matched by the second &apos;.*&apos; capture group. I&apos;m sure you can construct an example with &apos;{n}?&apos; too. Admittedly these two are very-rarely-used.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/202229/smci&quot; title=&quot;29,887 reputation&quot; class=&quot;comment-user&quot;&gt;smci&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment81590562_34806154&quot;&gt;&lt;span title=&quot;2017-11-16 00:42:24Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Nov 16, 2017 at 0:42&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 3 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Number945 Yes, &lt;code&gt;{n}?&lt;/code&gt; is equivalent to &lt;code&gt;{n}&lt;/code&gt;. See &lt;a href=&quot;https://stackoverflow.com/questions/18006093/how-do-an-and-an-differ&quot; title=&quot;how do an and an differ&quot;&gt;stackoverflow.com/questions/18006093/how-do-an-and-an-differ&lt;/a&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/4885772/th%c3%a9ophile&quot; title=&quot;986 reputation&quot; class=&quot;comment-user&quot;&gt;Théophile&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment118268697_34806154&quot;&gt;&lt;span title=&quot;2021-04-01 15:13:24Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Apr 1, 2021 at 15:13&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;This seems to be the most correct definition of &quot;Laziness&quot; compared with the higher-voted answers.  The other answers seem to omit the concept that under laziness the engine &quot;gradually expands the match...to find an overall match&quot;.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1404637/alx9r&quot; title=&quot;3,378 reputation&quot; class=&quot;comment-user&quot;&gt;alx9r&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment115818140_26448792&quot;&gt;&lt;span title=&quot;2020-12-30 15:35:27Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Dec 30, 2020 at 15:35&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;I don&apos;t understand how that regex is any different from not using a lazy quantifier. &lt;code&gt;\\s&lt;/code&gt; can only match a white space and there&apos;s a requirement for 7 digits after it.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/12695027/scratte&quot; title=&quot;2,877 reputation&quot; class=&quot;comment-user&quot;&gt;Scratte&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment116751060_48646735&quot;&gt;&lt;span title=&quot;2021-02-03 18:45:53Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Feb 3, 2021 at 18:45&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;What language is this?&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/12695027/scratte&quot; title=&quot;2,877 reputation&quot; class=&quot;comment-user&quot;&gt;Scratte&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment116751047_40326584&quot;&gt;&lt;span title=&quot;2021-02-03 18:45:19Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Feb 3, 2021 at 18:45&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;The language he used is C#&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/2946773/andrefeijo&quot; title=&quot;9,246 reputation&quot; class=&quot;comment-user&quot;&gt;AndreFeijo&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment117351159_40326584&quot;&gt;&lt;span title=&quot;2021-02-26 01:06:56Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Feb 26, 2021 at 1:06&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        "],"id":500,"title":"What do 'lazy' and 'greedy' mean in the context of regular expressions?","content":"\n                \n&lt;p&gt;What are these two terms in an understandable way?&lt;/p&gt;\n    ","slug":"what-do-'lazy'-and-'greedy'-mean-in-the-context-of-regular-expressions-1657388200552","postType":"QUESTION","createdAt":"2022-07-09T17:36:40.000Z","updatedAt":"2022-07-09T17:36:40.000Z","tags":[{"id":2495,"name":"regex-greedy","slug":"regex-greedy","createdAt":"2022-07-09T17:36:40.000Z","updatedAt":"2022-07-09T17:36:40.000Z","Questions_Tags":{"questionId":500,"tagId":2495}},{"id":2497,"name":"non-greedy","slug":"non-greedy","createdAt":"2022-07-09T17:36:40.000Z","updatedAt":"2022-07-09T17:36:40.000Z","Questions_Tags":{"questionId":500,"tagId":2497}}]}},"__N_SSG":true}