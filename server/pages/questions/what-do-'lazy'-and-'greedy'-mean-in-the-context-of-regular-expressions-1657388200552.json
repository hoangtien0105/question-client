{"pageProps":{"data":{"answer":["\n&lt;p&gt;Greedy will consume as much as possible. From &lt;a href=&quot;http://www.regular-expressions.info/repeat.html&quot; rel=&quot;noreferrer&quot;&gt;http://www.regular-expressions.info/repeat.html&lt;/a&gt; we see the example of trying to match HTML tags with &lt;code&gt;&amp;lt;.+&amp;gt;&lt;/code&gt;. Suppose you have the following:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-css&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;em&lt;/span&gt;&amp;gt;Hello World&amp;lt;/&lt;span class=&quot;hljs-selector-tag&quot;&gt;em&lt;/span&gt;&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You may think that &lt;code&gt;&amp;lt;.+&amp;gt;&lt;/code&gt; (&lt;code&gt;.&lt;/code&gt; means &lt;em&gt;any non newline character&lt;/em&gt; and &lt;code&gt;+&lt;/code&gt; means &lt;em&gt;one or more&lt;/em&gt;) would only match the &lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt; and the &lt;code&gt;&amp;lt;/em&amp;gt;&lt;/code&gt;, when in reality it will be very greedy, and go from the first &lt;code&gt;&amp;lt;&lt;/code&gt; to the last &lt;code&gt;&amp;gt;&lt;/code&gt;. This means it will match &lt;code&gt;&amp;lt;em&amp;gt;Hello World&amp;lt;/em&amp;gt;&lt;/code&gt; instead of what you wanted.&lt;/p&gt;\n\n&lt;p&gt;Making it lazy (&lt;code&gt;&amp;lt;.+?&amp;gt;&lt;/code&gt;) will prevent this. By adding the &lt;code&gt;?&lt;/code&gt; after the &lt;code&gt;+&lt;/code&gt;, we tell it to repeat &lt;em&gt;as few times as possible&lt;/em&gt;, so the first &lt;code&gt;&amp;gt;&lt;/code&gt; it comes across, is where we want to stop the matching.&lt;/p&gt;\n\n&lt;p&gt;I&apos;d encourage you to download &lt;a href=&quot;http://www.gskinner.com/RegExr/&quot; rel=&quot;noreferrer&quot;&gt;RegExr&lt;/a&gt;, a great tool that will help you explore Regular Expressions - I use it all the time.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;&apos;Greedy&apos;&lt;/strong&gt; means match longest possible string.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;&apos;Lazy&apos;&lt;/strong&gt; means match shortest possible string.&lt;/p&gt;\n\n&lt;p&gt;For example, the greedy &lt;code&gt;h.+l&lt;/code&gt; matches &lt;code&gt;&apos;hell&apos;&lt;/code&gt; in &lt;code&gt;&apos;hello&apos;&lt;/code&gt; but the lazy &lt;code&gt;h.+?l&lt;/code&gt; matches &lt;code&gt;&apos;hel&apos;&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;div class=&quot;s-table-container&quot;&gt;\n&lt;table class=&quot;s-table&quot;&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;Greedy quantifier&lt;/th&gt;\n&lt;th&gt;Lazy quantifier&lt;/th&gt;\n&lt;th&gt;Description&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;&lt;code&gt;*?&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;Star Quantifier: 0 or more&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;code&gt;+&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;&lt;code&gt;+?&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;Plus Quantifier: 1 or more&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;code&gt;?&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;&lt;code&gt;??&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;Optional Quantifier: 0 or 1&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;code&gt;{n}&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;&lt;code&gt;{n}?&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;Quantifier: exactly n&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;code&gt;{n,}&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;&lt;code&gt;{n,}?&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;Quantifier: n or more&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;code&gt;{n,m}&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;&lt;code&gt;{n,m}?&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;Quantifier: between n and m&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;/div&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Add a ? to a quantifier to make it ungreedy i.e lazy.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;br&gt;\ntest string : &lt;em&gt;stackoverflow&lt;/em&gt;&lt;br&gt;\n&lt;em&gt;greedy reg expression&lt;/em&gt; : &lt;a href=&quot;http://regexr.com/3glo4&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;s.*o&lt;/code&gt;&lt;/a&gt; output: &lt;strong&gt;stackoverflo&lt;/strong&gt;w&lt;br&gt;\n&lt;em&gt;lazy reg expression&lt;/em&gt; : &lt;a href=&quot;http://regexr.com/3glo7&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;s.*?o&lt;/code&gt;&lt;/a&gt; output: &lt;strong&gt;stacko&lt;/strong&gt;verflow&lt;/p&gt;\n    ","\n&lt;p&gt;Greedy means your expression will match as large a group as possible, lazy means it will match the smallest group possible.  For this string:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-undefined&quot;&gt;abcdefghijklmc\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and this expression:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;a&lt;/span&gt;.*c\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;A greedy match will match the whole string, and a lazy match will match just the first &lt;code&gt;abc&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;As far as I know, most regex engine is greedy by default. Add a question mark at the end of quantifier will enable lazy match.&lt;/p&gt;\n&lt;p&gt;As @Andre S mentioned in comment.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Greedy: Keep searching until condition is not satisfied.&lt;/li&gt;\n&lt;li&gt;Lazy: Stop searching once condition is satisfied.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Refer to the example below for what is greedy and what is lazy.&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.util.regex.Matcher;\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.util.regex.Pattern;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Test&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String args[])&lt;/span&gt;{\n        &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;money&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;100000000999&quot;&lt;/span&gt;;\n        &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;greedyRegex&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;100(0*)&quot;&lt;/span&gt;;\n        &lt;span class=&quot;hljs-type&quot;&gt;Pattern&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;pattern&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; Pattern.compile(greedyRegex);\n        &lt;span class=&quot;hljs-type&quot;&gt;Matcher&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;matcher&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; pattern.matcher(money);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(matcher.find()){\n            System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;I&apos;m greedy and I want &quot;&lt;/span&gt; + matcher.group() + &lt;span class=&quot;hljs-string&quot;&gt;&quot; dollars. This is the most I can get.&quot;&lt;/span&gt;);\n        }\n        \n        &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;lazyRegex&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;100(0*?)&quot;&lt;/span&gt;;\n        pattern = Pattern.compile(lazyRegex);\n        matcher = pattern.matcher(money);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(matcher.find()){\n            System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;I&apos;m too lazy to get so much money, only &quot;&lt;/span&gt; + matcher.group() + &lt;span class=&quot;hljs-string&quot;&gt;&quot; dollars is enough for me&quot;&lt;/span&gt;);\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;hr&gt;\nThe result is:\n```\nI&apos;m greedy and I want 100000000 dollars. This is the most I can get.\n&lt;p&gt;I&apos;m too lazy to get so much money, only 100 dollars is enough for me&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-undefined&quot;&gt;\n\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Taken From &lt;a href=&quot;http://www.regular-expressions.info/possessive.html&quot; rel=&quot;noreferrer&quot;&gt;www.regular-expressions.info&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Greediness&lt;/strong&gt;: Greedy quantifiers first tries to repeat the token as many times\nas possible, and gradually gives up matches as the engine backtracks to find \nan overall match.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Laziness&lt;/strong&gt;: Lazy quantifier first repeats the token as few times as required, and\ngradually expands the match as the engine backtracks through the regex to\nfind an overall match.&lt;/p&gt;\n    ","\n&lt;p&gt;From &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot; rel=&quot;noreferrer&quot;&gt;Regular expression&lt;/a&gt;&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;The standard quantifiers in regular\n  expressions are greedy, meaning they\n  match as much as they can, only giving\n  back as necessary to match the\n  remainder of the regex. &lt;/p&gt;\n  \n  &lt;p&gt;By using a lazy quantifier, the\n  expression tries the minimal match\n  first.&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;h2&gt;Greedy Quantifiers are like the IRS&lt;/h2&gt;\n&lt;p&gt;Theyll take as much as they can. e.g. matches with this regex: &lt;code&gt;.*&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;$50,000&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;Bye-bye bank balance.&lt;/p&gt;\n&lt;p&gt;See here for an example: &lt;a href=&quot;https://regexr.com/4t27f&quot; rel=&quot;nofollow noreferrer&quot;&gt;Greedy-example&lt;/a&gt;&lt;/p&gt;\n&lt;h2&gt;Non-greedy quantifiers - they take as little as they can&lt;/h2&gt;\n&lt;p&gt;Ask for a tax refund: the IRS sudden becomes non-greedy - and return as little as possible: i.e. they use this quantifier:&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;(.{2,5}?)([0-9]*)&lt;/code&gt; against this input: &lt;code&gt;$50,000&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;The first group is non-needy and only matches &lt;code&gt;$5&lt;/code&gt;  so I get a &lt;code&gt;$5&lt;/code&gt; refund against the $50,000 input.&lt;/p&gt;\n&lt;p&gt;See here: &lt;a href=&quot;https://regexr.com/59qrk&quot; rel=&quot;nofollow noreferrer&quot;&gt;Non-greedy-example&lt;/a&gt;.&lt;/p&gt;\n&lt;h2&gt;Why do we need greedy vs non-greedy?&lt;/h2&gt;\n&lt;p&gt;It becomes important if you are trying to match certain parts of an expression. Sometimes you don&apos;t want to match everything - as little as possible. Sometimes you want to match as much as possible. Nothing more to it.&lt;/p&gt;\n&lt;p&gt;You can play around with the examples in the links posted above.&lt;/p&gt;\n&lt;p&gt;(Analogy used to help you remember).&lt;/p&gt;\n    ","\n&lt;p&gt;Best shown by example. String. &lt;code&gt;192.168.1.1&lt;/code&gt; and a greedy regex &lt;code&gt;\\b.+\\b&lt;/code&gt;\nYou might think this would give you the 1st octet but is actually matches against the whole string. Why? Because the.+ is greedy and a greedy match matches every character in &lt;code&gt;192.168.1.1&lt;/code&gt; until it reaches the end of the string. This is the important bit! Now it starts to backtrack one character at a time until it finds a match for the 3rd token (&lt;code&gt;\\b&lt;/code&gt;).&lt;/p&gt;\n\n&lt;p&gt;If the string a 4GB text file and 192.168.1.1 was at the start you could easily see how this backtracking would cause an issue.&lt;/p&gt;\n\n&lt;p&gt;To make a regex non greedy (lazy) put a question mark after your greedy search e.g&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-ruby&quot;&gt;*?\n&lt;span class=&quot;hljs-string&quot;&gt;??&lt;/span&gt;\n+?\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;What happens now is token 2 (&lt;code&gt;+?&lt;/code&gt;) finds a match, regex moves along a character and then tries the next token (&lt;code&gt;\\b&lt;/code&gt;) rather than token 2 (&lt;code&gt;+?&lt;/code&gt;). So it creeps along gingerly.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Greedy matching.&lt;/strong&gt; The default behavior of regular expressions is to be greedy. That means it tries to extract as much as possible until it conforms to a pattern even when a smaller part would have been syntactically sufficient.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-coffeescript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; re\ntext = &lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;body&amp;gt;Regex Greedy Matching Example &amp;lt;/body&amp;gt;&quot;&lt;/span&gt;\nre.findall(&lt;span class=&quot;hljs-string&quot;&gt;&apos;&amp;lt;.*&amp;gt;&apos;&lt;/span&gt;, text)\n&lt;span class=&quot;hljs-comment&quot;&gt;#&amp;gt; [&apos;&amp;lt;body&amp;gt;Regex Greedy Matching Example &amp;lt;/body&amp;gt;&apos;]&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Instead of matching till the first occurrence of &amp;gt;, it extracted the whole string. This is the default greedy or take it all behavior of regex.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Lazy matching&lt;/strong&gt;, on the other hand, takes as little as possible. This can be effected by adding a &lt;code&gt;?&lt;/code&gt; at the end of the pattern.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-less&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;re&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.findall&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;&amp;lt;.*?&amp;gt;&apos;&lt;/span&gt;, text)\n#&amp;gt; &lt;span class=&quot;hljs-selector-attr&quot;&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&apos;&amp;lt;body&amp;gt;&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;&amp;lt;/body&amp;gt;&apos;&lt;/span&gt;]&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;If you want only the first match to be retrieved, use the search method instead.&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;re.search(&lt;span class=&quot;hljs-string&quot;&gt;&apos;&amp;lt;.*?&amp;gt;&apos;&lt;/span&gt;, text).&lt;span class=&quot;hljs-keyword&quot;&gt;group&lt;/span&gt;()\n&lt;span class=&quot;hljs-meta&quot;&gt;#&amp;gt; &apos;&amp;lt;body&amp;gt;&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Source: &lt;a href=&quot;https://www.machinelearningplus.com/python-regex-tutorial-examples/#greedy_matching_in_regex&quot; rel=&quot;nofollow noreferrer&quot;&gt;Python Regex Examples&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Greedy means it will consume your pattern until there are none of them left and it can look no further.&lt;/p&gt;\n\n&lt;p&gt;Lazy will stop as soon as it will encounter the first pattern you requested.&lt;/p&gt;\n\n&lt;p&gt;One common example that I often encounter is &lt;code&gt;\\s*-\\s*?&lt;/code&gt; of a regex &lt;code&gt;([0-9]{2}\\s*-\\s*?[0-9]{7})&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;The first &lt;code&gt;\\s*&lt;/code&gt; is classified as greedy because of &lt;code&gt;*&lt;/code&gt; and will look as many white spaces as possible after the digits are encountered and then look for a dash character &quot;-&quot;. Where as the second &lt;code&gt;\\s*?&lt;/code&gt; is lazy because of the present of &lt;code&gt;*?&lt;/code&gt; which means that it will look the first white space character and stop right there.&lt;/p&gt;\n    ","\n&lt;p&gt;try to understand the following behavior:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-dart&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; input = &lt;span class=&quot;hljs-string&quot;&gt;&quot;0014.2&quot;&lt;/span&gt;;\n\nRegex r1 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Regex(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\\\\d+.{0,1}\\\\d+&quot;&lt;/span&gt;);\nRegex r2 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Regex(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\\\\d*.{0,1}\\\\d*&quot;&lt;/span&gt;);\n\nConsole.WriteLine(r1.&lt;span class=&quot;hljs-built_in&quot;&gt;Match&lt;/span&gt;(input).Value); &lt;span class=&quot;hljs-comment&quot;&gt;// &quot;0014.2&quot;&lt;/span&gt;\nConsole.WriteLine(r2.&lt;span class=&quot;hljs-built_in&quot;&gt;Match&lt;/span&gt;(input).Value); &lt;span class=&quot;hljs-comment&quot;&gt;// &quot;0014.2&quot;&lt;/span&gt;\n\ninput = &lt;span class=&quot;hljs-string&quot;&gt;&quot; 0014.2&quot;&lt;/span&gt;;\n\nConsole.WriteLine(r1.&lt;span class=&quot;hljs-built_in&quot;&gt;Match&lt;/span&gt;(input).Value); &lt;span class=&quot;hljs-comment&quot;&gt;// &quot;0014.2&quot;&lt;/span&gt;\nConsole.WriteLine(r2.&lt;span class=&quot;hljs-built_in&quot;&gt;Match&lt;/span&gt;(input).Value); &lt;span class=&quot;hljs-comment&quot;&gt;// &quot; 0014&quot;&lt;/span&gt;\n\ninput = &lt;span class=&quot;hljs-string&quot;&gt;&quot;  0014.2&quot;&lt;/span&gt;;\n\nConsole.WriteLine(r1.&lt;span class=&quot;hljs-built_in&quot;&gt;Match&lt;/span&gt;(input).Value); &lt;span class=&quot;hljs-comment&quot;&gt;// &quot;0014.2&quot;&lt;/span&gt;\nConsole.WriteLine(r2.&lt;span class=&quot;hljs-built_in&quot;&gt;Match&lt;/span&gt;(input).Value); &lt;span class=&quot;hljs-comment&quot;&gt;// &quot;&quot;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    "],"id":500,"title":"What do 'lazy' and 'greedy' mean in the context of regular expressions?","content":"\n                \n&lt;p&gt;What are these two terms in an understandable way?&lt;/p&gt;\n    ","slug":"what-do-'lazy'-and-'greedy'-mean-in-the-context-of-regular-expressions-1657388200552","postType":"QUESTION","createdAt":"2022-07-09T17:36:40.000Z","updatedAt":"2022-07-09T17:36:40.000Z","tags":[{"id":2495,"name":"regex-greedy","slug":"regex-greedy","createdAt":"2022-07-09T17:36:40.000Z","updatedAt":"2022-07-09T17:36:40.000Z","Questions_Tags":{"questionId":500,"tagId":2495}},{"id":2497,"name":"non-greedy","slug":"non-greedy","createdAt":"2022-07-09T17:36:40.000Z","updatedAt":"2022-07-09T17:36:40.000Z","Questions_Tags":{"questionId":500,"tagId":2497}}],"relatedQuestions":[{"title":"What do 'lazy' and 'greedy' mean in the context of regular expressions?","slug":"what-do-'lazy'-and-'greedy'-mean-in-the-context-of-regular-expressions-1657388200552","tags":[{"name":"regex-greedy","Questions_Tags":{"questionId":500,"tagId":2495}},{"name":"non-greedy","Questions_Tags":{"questionId":500,"tagId":2497}}]}]},"randomQuestions":[{"title":"How do I undo the most recent local commits in Git?","slug":"how-do-i-undo-the-most-recent-local-commits-in-git-1657388262945"},{"title":"Short description of the scoping rules?","slug":"short-description-of-the-scoping-rules-1657384853121"},{"title":"Importing files from different folder","slug":"importing-files-from-different-folder-1657388203798"},{"title":"\"Thinking in AngularJS\" if I have a jQuery background? [closed]","slug":"\"thinking-in-angularjs\"-if-i-have-a-jquery-background-closed-1657384761159"},{"title":"Passing data between view controllers","slug":"passing-data-between-view-controllers-1657384540021"},{"title":"Why is \"using namespace std;\" considered bad practice?","slug":"why-is-\"using-namespace-std\"-considered-bad-practice-1657384296377"},{"title":"Is an array name a pointer?","slug":"is-an-array-name-a-pointer-1657387874827"},{"title":"How do you access the matched groups in a JavaScript regular expression?","slug":"how-do-you-access-the-matched-groups-in-a-javascript-regular-expression-1657388233817"},{"title":"What methods of ‘clearfix’ can I use?","slug":"what-methods-of-'clearfix'-can-i-use-1657387672727"},{"title":"Why can't I store a value and a reference to that value in the same struct?","slug":"why-can't-i-store-a-value-and-a-reference-to-that-value-in-the-same-struct-1657387506828"},{"title":"Accessing an array out of bounds gives no error, why?","slug":"accessing-an-array-out-of-bounds-gives-no-error-why-1657387979932"},{"title":"What is the meaning of single and double underscore before an object name?","slug":"what-is-the-meaning-of-single-and-double-underscore-before-an-object-name-1657387926929"},{"title":"How should a model be structured in MVC? [closed]","slug":"how-should-a-model-be-structured-in-mvc-closed-1657388394807"},{"title":"How do I correctly clone a JavaScript object?","slug":"how-do-i-correctly-clone-a-javascript-object-1657387325850"},{"title":"When does SQLiteOpenHelper onCreate() / onUpgrade() run?","slug":"when-does-sqliteopenhelper-oncreate()-onupgrade()-run-1657384883864"},{"title":"The 3 different equals","slug":"the-3-different-equals-1657385490242"},{"title":"The Use of Multiple JFrames: Good or Bad Practice? [closed]","slug":"the-use-of-multiple-jframes:-good-or-bad-practice-closed-1657384478184"},{"title":"Selecting and manipulating CSS pseudo-elements such as ::before and ::after using javascript (or jQuery)","slug":"selecting-and-manipulating-css-pseudo-elements-such-as-::before-and-::after-using-javascript-(or-jquery)-1657387406132"},{"title":"How do I determine the correct path for FXML files, CSS files, Images, and other resources needed by my JavaFX Application?","slug":"how-do-i-determine-the-correct-path-for-fxml-files-css-files-images-and-other-resources-needed-by-my-javafx-application-1657388143988"},{"title":"What does ** (double star/asterisk) and * (star/asterisk) do for parameters?","slug":"what-does-**-(double-starasterisk)-and-*-(starasterisk)-do-for-parameters-1657384800967"}]},"__N_SSG":true}