<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2eccd4d47c856f2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2eccd4d47c856f2b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20edbe0b078add93.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/613-1e0aa2b2023820bb.js" defer=""></script><script src="/_next/static/chunks/495-bb1d5b202c02d7f2.js" defer=""></script><script src="/_next/static/chunks/471-84c36aa98dd4107c.js" defer=""></script><script src="/_next/static/chunks/81-096e453de8a27667.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-e3d1b60e109d3ba1.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_buildManifest.js" defer=""></script><script src="/_next/static/4Y8KGE-c2lolBeBmcum_I/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">.hFcsiD code{padding:5px;color:hsl(210deg 8% 15%);background-color:hsl(210deg 8% 90%);border-radius:3px;}/*!sc*/
data-styled.g5[id="sc-6e32c308-0"]{content:"hFcsiD,"}/*!sc*/
.ljvTUN .comment-item .comment-body .d-inline-flex.ai-center{text-align:right;}/*!sc*/
.ljvTUN .comment-item .comment-body .comment-date{float:right;}/*!sc*/
data-styled.g6[id="sc-6e32c308-1"]{content:"ljvTUN,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9099c029-0 cIPEih"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="https://flowbite.com/docs/images/logo.svg" class="mr-3 h-6 sm:h-9" alt="Flowbite Logo"/><span class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Hunter</span></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/why-are-these-constructs-using-pre-and-post-increment-undefined-behavior-1657384520109#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="sc-c5440139-0 figLul question my-5"><div class="sc-6e32c308-0 hFcsiD flex question-header items-center justify-center"><div class="rounded-xl border p-5 shadow-md w-9/12 bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/why-are-these-constructs-using-pre-and-post-increment-undefined-behavior-1657384520109">Why are these constructs using pre and post-increment undefined behavior?</a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/increment">increment</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/operator-precedence">operator-precedence</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/sequence-points">sequence-points</a></div></div><div class="question-content mt-5">
                
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
   <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
   i = i++ + ++i;
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, i); <span class="hljs-comment">// 3</span>

   i = <span class="hljs-number">1</span>;
   i = (i++);
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, i); <span class="hljs-comment">// 2 Should be 1, no ?</span>

   <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;
   u = u++ + ++u;
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, u); <span class="hljs-comment">// 1</span>

   u = <span class="hljs-number">1</span>;
   u = (u++);
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, u); <span class="hljs-comment">// 2 Should also be one, no ?</span>

   <span class="hljs-keyword">register</span> <span class="hljs-type">int</span> v = <span class="hljs-number">0</span>;
   v = v++ + ++v;
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, v); <span class="hljs-comment">// 3 (Should be the same as u ?)</span>

   <span class="hljs-type">int</span> w = <span class="hljs-number">0</span>;
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, ++w, w); <span class="hljs-comment">// shouldn't this print 1 1</span>

   <span class="hljs-type">int</span> x[<span class="hljs-number">2</span>] = { <span class="hljs-number">5</span>, <span class="hljs-number">8</span> }, y = <span class="hljs-number">0</span>;
   x[y] = y ++;
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, x[<span class="hljs-number">0</span>], x[<span class="hljs-number">1</span>]); <span class="hljs-comment">// shouldn't this print 0 8? or 5 0?</span>
}
</code></pre>
    </div></div></div><div class="sc-6e32c308-1 ljvTUN flex text-xs pl-10 flex-col comment items-center justify-center"><h4 class="text-left mt-10 text-lg font-semibold">Comments</h4><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy">@Jarett, nope, just needed some pointers to "sequence points". While working I found a piece of code with i = i++, I thougth "This isn't modifying the value of i". I tested and I wondered why.  Since, i've removed this statment and replaced it by i++;</span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/44988/pix" title="9,465 reputation" class="comment-user owner">PiX</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment760510_949433"><span title="2009-06-04 18:24:46Z, License: CC BY-SA 2.5" class="relativetime-clean">Jun 4, 2009 at 18:24</span></a></span>
            </div>
        </div><span class="divide-x-8 "></span><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy">I think it's interesting that everyone ALWAYS assumes that questions like this are asked because the asker wants to USE the construct in question. My first assumption was that PiX knows that these are bad, but is curious why the behave they way the do on whataver compiler s/he was using...  And yeah, what unWind said... it's undefined, it could do anything... including JCF (Jump and Catch Fire)</span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/53491/brian-postow" title="10,925 reputation" class="comment-user">Brian Postow</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment2946540_949433"><span title="2010-05-24 13:41:10Z, License: CC BY-SA 2.5" class="relativetime-clean">May 24, 2010 at 13:41</span></a></span>
            </div>
        </div><span class="divide-x-8 "></span><div class="comment-item w-9/12 border-t divide-y-8">
            <div class="comment-body js-comment-edit-hide">
                
                <span class="comment-copy">I'm curious: Why don't compilers seem to warn on constructs such as "u = u++ + ++u;" if the result is undefined?</span>
                
              <div class="d-inline-flex ai-center">
&nbsp;<a href="/users/1317564/learn-opengl-es" title="4,537 reputation" class="comment-user">Learn OpenGL ES</a>
                </div>
                <span class="comment-date" dir="ltr"><a class="comment-link" href="#comment16848338_949433"><span title="2012-09-20 16:23:44Z, License: CC BY-SA 3.0" class="relativetime-clean">Sep 20, 2012 at 16:23</span></a></span>
            </div>
        </div><span class="divide-x-8 "></span><button class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">See more</button></div><div class="sc-6e32c308-2 bFXWFO"><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>C has the concept of undefined behavior, i.e. some language constructs are syntactically valid but you can't predict the behavior when the code is run.</p>

<p>As far as I know, the standard doesn't explicitly say <em>why</em> the concept of undefined behavior exists. In my mind, it's simply because the language designers wanted there to be some leeway in the semantics, instead of i.e. requiring that all implementations handle integer overflow in the exact same way, which would very likely impose serious performance costs, they just left the behavior undefined so that if you write code that causes integer overflow, anything can happen.</p>

<p>So, with that in mind, why are these "issues"? The language clearly says that certain things lead to <a href="http://en.wikipedia.org/wiki/Undefined_behavior" rel="noreferrer">undefined behavior</a>. There is no problem, there is no "should" involved. If the undefined behavior changes when one of the involved variables is declared <code>volatile</code>, that doesn't prove or change anything. It is <em>undefined</em>; you cannot reason about the behavior.</p>

<p>Your most interesting-looking example, the one with</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">u = (u++);
</code></pre>

<p>is a text-book example of undefined behavior (see Wikipedia's entry on <a href="http://en.wikipedia.org/wiki/Sequence_point" rel="noreferrer">sequence points</a>).</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Most of the answers here quoted from C standard emphasizing that the behavior of these constructs are undefined. To understand <strong>why the behavior of these constructs are undefined</strong>, let's understand these terms first in the light of C11 standard:</p>
<p><strong>Sequenced:</strong> (5.1.2.3)</p>
<blockquote>
<p>Given any two evaluations <code>A</code> and <code>B</code>, if <code>A</code> is sequenced before <code>B</code>, then the execution of <code>A</code> shall precede the execution of <code>B</code>.</p>
</blockquote>
<p><strong>Unsequenced:</strong></p>
<blockquote>
<p>If <code>A</code> is not sequenced before or after <code>B</code>, then <code>A</code> and <code>B</code> are unsequenced.</p>
</blockquote>
<p>Evaluations can be one of two things:</p>
<ul>
<li><strong>value computations</strong>, which work out the result of an expression; and</li>
<li><strong>side effects</strong>, which are modifications of objects.</li>
</ul>
<p><strong>Sequence Point:</strong></p>
<blockquote>
<p>The presence of a sequence point between the evaluation of expressions <code>A</code> and <code>B</code> implies that every <em>value computation</em> and <em>side effect</em> associated with <code>A</code> is sequenced before every <em>value computation</em> and <em>side effect</em> associated with <code>B</code>.</p>
</blockquote>
<p>Now coming to the question, for the expressions like</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;
i = i++;
</code></pre>
<p>standard says that:</p>
<h3>6.5 Expressions:</h3>
<blockquote>
<p><strong>If a side effect on a scalar object is unsequenced relative to</strong> either <strong>a different side effect on the same scalar object</strong> or a value computation using the value of the same scalar object, <strong>the behavior is undefined</strong>. [...]</p>
</blockquote>
<p>Therefore, the above expression invokes UB because two side effects on the same object <code>i</code> is unsequenced relative to each other. That means it is not sequenced whether the side effect by assignment to <code>i</code> will be done before or after the side effect by <code>++</code>.<br>
Depending on whether assignment occurs before or after the increment, different results will be produced and that's the one of the case of <strong>undefined behavior</strong>.</p>
<p>Lets rename the <code>i</code> at left of assignment be <code>il</code> and at the right of assignment (in the expression <code>i++</code>) be <code>ir</code>, then the expression be like</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">il = ir++     <span class="hljs-comment">// Note that suffix l and r are used for the sake of clarity.</span>
              <span class="hljs-comment">// Both il and ir represents the same object.  </span>
</code></pre>
<p><a href="https://stackoverflow.com/a/17935062/2455888">An important point</a> regarding Postfix <code>++</code> operator is that:</p>
<blockquote>
<p><strong>just because the <code>++</code> comes after the variable does not mean that the increment happens late</strong>. The increment can happen as early as the compiler likes <em>as long as the compiler ensures that the original value is used</em>.</p>
</blockquote>
<p>It means the expression <code>il = ir++</code> could be evaluated either as</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">temp = ir;      <span class="hljs-comment">// i = 1</span>
ir = ir + <span class="hljs-number">1</span>;    <span class="hljs-comment">// i = 2   side effect by ++ before assignment</span>
il = temp;      <span class="hljs-comment">// i = 1   result is 1  </span>
</code></pre>
<p>or</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">temp = ir;      <span class="hljs-comment">// i = 1</span>
il = temp;      <span class="hljs-comment">// i = 1   side effect by assignment before ++</span>
ir = ir + <span class="hljs-number">1</span>;    <span class="hljs-comment">// i = 2   result is 2  </span>
</code></pre>
<p>resulting in two different results <code>1</code> and <code>2</code> which depends on the sequence of side effects by assignment and <code>++</code> and hence invokes UB.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I think the relevant parts of the C99 standard are 6.5 Expressions, §2</p>

<blockquote>
  <p>Between the previous and next sequence point an object shall have its stored value
  modified at most once by the evaluation of an expression. Furthermore, the prior value
  shall be read only to determine the value to be stored.</p>
</blockquote>

<p>and 6.5.16 Assignment operators, §4:</p>

<blockquote>
  <p>The order of evaluation of the operands is unspecified. If an attempt is made to modify
  the result of an assignment operator or to access it after the next sequence point, the
  behavior is undefined. </p>
</blockquote>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Just compile and disassemble your line of code, if you are so inclined to know how exactly it is you get what you are getting.</p>

<p>This is what I get on my machine, together with what I think is going on:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">$ cat evil.c
<span class="hljs-type">void</span> <span class="hljs-title function_">evil</span><span class="hljs-params">()</span>{
  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
  i+= i++ + ++i;
}
$ gcc evil.c -c -o evil.bin
$ gdb evil.bin
(gdb) disassemble evil
Dump of assembler code <span class="hljs-keyword">for</span> function evil:
   <span class="hljs-number">0x00000000</span> &lt;+<span class="hljs-number">0</span>&gt;:   push   %ebp
   <span class="hljs-number">0x00000001</span> &lt;+<span class="hljs-number">1</span>&gt;:   mov    %esp,%ebp
   <span class="hljs-number">0x00000003</span> &lt;+<span class="hljs-number">3</span>&gt;:   sub    $<span class="hljs-number">0x10</span>,%esp
   <span class="hljs-number">0x00000006</span> &lt;+<span class="hljs-number">6</span>&gt;:   movl   $<span class="hljs-number">0x0</span>,<span class="hljs-number">-0x4</span>(%ebp)  <span class="hljs-comment">// i = 0   i = 0</span>
   <span class="hljs-number">0x0000000d</span> &lt;+<span class="hljs-number">13</span>&gt;:  addl   $<span class="hljs-number">0x1</span>,<span class="hljs-number">-0x4</span>(%ebp)  <span class="hljs-comment">// i++     i = 1</span>
   <span class="hljs-number">0x00000011</span> &lt;+<span class="hljs-number">17</span>&gt;:  mov    <span class="hljs-number">-0x4</span>(%ebp),%eax  <span class="hljs-comment">// j = i   i = 1  j = 1</span>
   <span class="hljs-number">0x00000014</span> &lt;+<span class="hljs-number">20</span>&gt;:  add    %eax,%eax        <span class="hljs-comment">// j += j  i = 1  j = 2</span>
   <span class="hljs-number">0x00000016</span> &lt;+<span class="hljs-number">22</span>&gt;:  add    %eax,<span class="hljs-number">-0x4</span>(%ebp)  <span class="hljs-comment">// i += j  i = 3</span>
   <span class="hljs-number">0x00000019</span> &lt;+<span class="hljs-number">25</span>&gt;:  addl   $<span class="hljs-number">0x1</span>,<span class="hljs-number">-0x4</span>(%ebp)  <span class="hljs-comment">// i++     i = 4</span>
   <span class="hljs-number">0x0000001d</span> &lt;+<span class="hljs-number">29</span>&gt;:  leave  
   <span class="hljs-number">0x0000001e</span> &lt;+<span class="hljs-number">30</span>&gt;:  ret
End of assembler dump.
</code></pre>

<p>(I... suppose that the 0x00000014 instruction was some kind of compiler optimization?)</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The behavior can't really be explained because it invokes both <a href="http://en.wikipedia.org/wiki/Unspecified_behavior" rel="noreferrer">unspecified behavior</a> and <a href="http://en.wikipedia.org/wiki/Undefined_behavior" rel="noreferrer">undefined behavior</a>, so we can not make any general predictions about this code, although if you read <em>Olve Maudal's</em> work such as <a href="http://www.slideshare.net/olvemaudal/deep-c" rel="noreferrer">Deep C</a> and <a href="http://www.pvv.org/~oma/UnspecifiedAndUndefined_ACCU_Apr2013.pdf" rel="noreferrer">Unspecified and Undefined</a> sometimes you can make good guesses in very specific cases with a specific compiler and environment but please don't do that anywhere near production.</p>

<p>So moving on to <em>unspecified behavior</em>, in <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf" rel="noreferrer">draft c99 standard</a> section<code>6.5</code> paragraph <em>3</em> says(<em>emphasis mine</em>):</p>

<blockquote>
  <p>The grouping of operators and operands is indicated by the syntax.74) Except as specified
  later (for the function-call (), &amp;&amp;, ||, ?:, and comma operators), <strong>the order of evaluation of subexpressions and the order in which side effects take place are both unspecified.</strong></p>
</blockquote>

<p>So when we have a line like this:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">i = i++ + ++i;
</code></pre>

<p>we do not know whether <code>i++</code> or <code>++i</code> will be evaluated first. This is mainly to give the compiler <a href="https://stackoverflow.com/a/12540468/1708801">better options for optimization</a>.</p>

<p>We also have <em>undefined behavior</em> here as well since the program is modifying variables(<code>i</code>, <code>u</code>, etc..) more than once between <a href="http://en.wikipedia.org/wiki/Sequence_point" rel="noreferrer">sequence points</a>. From draft standard section <code>6.5</code> paragraph <em>2</em>(<em>emphasis mine</em>):</p>

<blockquote>
  <p><strong>Between the previous and next sequence point an object shall have its stored value
  modified at most once</strong> by the evaluation of an expression. Furthermore, <strong>the prior value
  shall be read only to determine the value to be stored</strong>.</p>
</blockquote>

<p>it cites the following code examples as being undefined:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">i = ++i + <span class="hljs-number">1</span>;
a[i++] = i; 
</code></pre>

<p>In all these examples the code is attempting to modify an object more than once in the same sequence point, which will end with the <code>;</code> in each one of these cases:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">i = i++ + ++i;
^   ^       ^

i = (i++);
^    ^

u = u++ + ++u;
^   ^       ^

u = (u++);
^    ^

v = v++ + ++v;
^   ^       ^
</code></pre>

<p><em>Unspecified behavior</em> is defined in the <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf" rel="noreferrer">draft c99 standard</a> in section <code>3.4.4</code> as:</p>

<blockquote>
  <p>use of an unspecified value, or other behavior where this International Standard provides
  two or more possibilities and imposes no further requirements on which is chosen in any
  instance</p>
</blockquote>

<p>and <em>undefined behavior</em> is defined in section <code>3.4.3</code> as:</p>

<blockquote>
  <p>behavior, upon use of a nonportable or erroneous program construct or of erroneous data,
  for which this International Standard imposes no requirements</p>
</blockquote>

<p>and notes that:</p>

<blockquote>
  <p>Possible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).</p>
</blockquote>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Another way of answering this, rather than getting bogged down in arcane details of sequence points and undefined behavior, is simply to ask, <em>what are they supposed to mean?</em> <em>What was the programmer trying to do?</em></p>

<p>The first fragment asked about, <code>i = i++ + ++i</code>, is pretty clearly insane in my book.  No one would ever write it in a real program, it's not obvious what it does, there's no conceivable algorithm someone could have been trying to code that would have resulted in this particular contrived sequence of operations.  And since it's not obvious to you and me what it's supposed to do, it's fine in my book if the compiler can't figure out what it's supposed to do, either.</p>

<p>The second fragment, <code>i = i++</code>, is a little easier to understand.  Someone is clearly trying to increment i, and assign the result back to i.  But there are a couple ways of doing this in C.  The most basic way to add 1 to i, and assign the result back to i, is the same in almost any programming language:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">i = i + <span class="hljs-number">1</span>
</code></pre>

<p>C, of course, has a handy shortcut:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">i++
</code></pre>

<p>This means, "add 1 to i, and assign the result back to i".  So if we construct a hodgepodge of the two, by writing</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">i = i++
</code></pre>

<p>what we're really saying is "add 1 to i, and assign the result back to i, and assign the result back to i".  We're confused, so it doesn't bother me too much if the compiler gets confused, too.</p>

<p>Realistically, the only time these crazy expressions get written is when people are using them as artificial examples of how ++ is supposed to work.  And of course it is important to understand how ++ works.  But one practical rule for using ++ is, "If it's not obvious what an expression using ++ means, don't write it."</p>

<p>We used to spend countless hours on comp.lang.c discussing expressions like these and <em>why</em> they're undefined.  Two of my longer answers, that try to really explain why, are archived on the web:</p>

<ul>
<li><a href="http://www.eskimo.com/~scs/readings/undef.950321.html" rel="noreferrer">Why doesn't the Standard define what these do?</a></li>
<li><a href="http://www.eskimo.com/~scs/readings/precvsooe.960725.html" rel="noreferrer">Doesn't operator precedence determine the order of evaluation?</a></li>
</ul>

<p>See also <a href="http://c-faq.com/expr/seqpoints.html" rel="noreferrer">question 3.8</a> and the rest of the questions in <a href="http://c-faq.com/expr/index.html" rel="noreferrer">section 3</a> of the <a href="http://c-faq.com/" rel="noreferrer">C FAQ list</a>.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Often this question is linked as a duplicate of questions related to code like</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, i, i++);
</code></pre>

<p>or </p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, ++i, i++);
</code></pre>

<p>or similar variants.</p>

<p>While this is also <a href="https://en.wikipedia.org/wiki/Undefined_behavior" rel="noreferrer"><em>undefined behaviour</em></a> as stated already, there are subtle differences when <code>printf()</code> is involved when comparing to a statement such as:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">x = i++ + i++;
</code></pre>

<hr>

<p>In the following statement:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, ++i, i++);
</code></pre>

<p>the <a href="http://en.cppreference.com/w/c/language/eval_order" rel="noreferrer"><em>order of evaluation</em></a> of arguments in <code>printf()</code> is <a href="https://en.wikipedia.org/wiki/Unspecified_behavior" rel="noreferrer"><em>unspecified</em></a>. That means, expressions <code>i++</code> and <code>++i</code> could be evaluated in any order. <a href="http://port70.net/~nsz/c/c11/n1570.html" rel="noreferrer">C11 standard</a> has some relevant descriptions on this:</p>

<p><strong>Annex J, unspecified behaviours</strong></p>

<blockquote>
  <p>The order in which the function designator, arguments, and
  subexpressions within the arguments are evaluated in a function call
  (6.5.2.2).</p>
</blockquote>

<p><strong>3.4.4, unspecified behavior</strong></p>

<blockquote>
  <p>Use of an unspecified value, or other behavior where this
  International Standard provides two or more possibilities and imposes
  no further requirements on which is chosen in any instance.</p>
  
  <p>EXAMPLE An example of unspecified behavior is the order in which the
  arguments to a function are evaluated.</p>
</blockquote>

<p>The <em>unspecified behaviour</em> itself is NOT an issue. Consider this example:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, ++x, y++);
</code></pre>

<p>This too has <em>unspecified behaviour</em> because the order of evaluation of <code>++x</code> and <code>y++</code> is unspecified. But it's perfectly legal and valid statement. There's <em>no</em> undefined behaviour in this statement. Because the modifications (<code>++x</code> and <code>y++</code>) are done to <em>distinct</em> objects.</p>

<p>What renders the following statement </p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, ++i, i++);
</code></pre>

<p>as <em>undefined behaviour</em> is the fact that these two expressions modify the <em>same</em> object <code>i</code> without an intervening <a href="https://en.wikipedia.org/wiki/Sequence_point" rel="noreferrer"><em>sequence point</em></a>.</p>

<hr>

<p>Another detail is that the <em>comma</em> involved in the printf() call is a <em>separator</em>, not the <a href="https://en.wikipedia.org/wiki/Comma_operator" rel="noreferrer"><em>comma operator</em></a>.</p>

<p>This is an important distinction because the <em>comma operator</em> does introduce a <em>sequence point</em> between the evaluation of their operands, which makes the following legal:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> i = <span class="hljs-number">5</span>;
<span class="hljs-type">int</span> j;

j = (++i, i++);  <span class="hljs-comment">// No undefined behaviour here because the comma operator </span>
                 <span class="hljs-comment">// introduces a sequence point between '++i' and 'i++'</span>

<span class="hljs-built_in">printf</span>(<span class="hljs-string">"i=%d j=%d\n"</span>,i, j); <span class="hljs-comment">// prints: i=7 j=6</span>
</code></pre>

<p>The comma operator evaluates its operands left-to-right and yields only the value of the last operand. So in <code>j = (++i, i++);</code>, <code>++i</code> increments <code>i</code> to <code>6</code> and <code>i++</code> yields old value of <code>i</code> (<code>6</code>) which is assigned to <code>j</code>. Then <code>i</code> becomes <code>7</code> due to post-increment.</p>

<p>So if the <em>comma</em> in the function call were to be a comma operator then </p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, ++i, i++);
</code></pre>

<p>will not be a problem. But it invokes <em>undefined behaviour</em> because the <em>comma</em> here is a <em>separator</em>.</p>

<hr>

<p>For those who are new to <em>undefined behaviour</em> would benefit from reading <a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html" rel="noreferrer">What Every C Programmer Should Know About Undefined Behavior</a>  to understand the concept and many other variants of undefined behaviour in C.</p>

<p>This post: <a href="https://stackoverflow.com/a/4105123/1275169">Undefined, unspecified and implementation-defined behavior</a> is also relevant.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>While it is unlikely that any compilers and processors would actually do so, it would be legal, under the C standard, for the compiler to implement "i++" with the sequence:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">In a single operation, read `i` and lock it to prevent access until further notice
<span class="hljs-title function_">Compute</span> <span class="hljs-params">(<span class="hljs-number">1</span>+read_value)</span>
In a single operation, unlock `i` and store the computed value
</code></pre>

<p>While I don't think any processors support the hardware to allow such a thing to be done efficiently, one can easily imagine situations where such behavior would make multi-threaded code easier (e.g. it would guarantee that if two threads try to perform the above sequence simultaneously, <code>i</code> would get incremented by two) and it's not totally inconceivable that some future processor might provide a feature something like that.</p>

<p>If the compiler were to write <code>i++</code> as indicated above (legal under the standard) and were to intersperse the above instructions throughout the evaluation of the overall expression (also legal), and if it didn't happen to notice that one of the other instructions happened to access <code>i</code>, it would be possible (and legal) for the compiler to generate a sequence of instructions that would deadlock.  To be sure, a compiler would almost certainly detect the problem in the case where the same variable <code>i</code> is used in both places, but if a routine accepts references to two pointers <code>p</code> and <code>q</code>, and uses <code>(*p)</code> and <code>(*q)</code> in the above expression (rather than using <code>i</code> twice) the compiler would not be required to recognize or avoid the deadlock that would occur if the same object's address were passed for both <code>p</code> and <code>q</code>.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>While the <strong>syntax</strong> of the expressions like <code>a = a++</code> or <code>a++ + a++</code> is legal, the <strong>behaviour</strong> of these constructs is <strong>undefined</strong> because a <strong><em>shall</em></strong> in C standard is not obeyed. <a href="http://port70.net/~nsz/c/c99/n1256.html#6.5p2" rel="noreferrer">C99 6.5p2</a>:</p>

<blockquote>
  <ol start="2">
  <li>Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression. [72] Furthermore, the prior value shall be read only to determine the value to be stored [73]</li>
  </ol>
</blockquote>

<p>With <a href="http://port70.net/~nsz/c/c99/n1256.html#note73" rel="noreferrer">footnote 73</a> further clarifying that</p>

<blockquote>
  <ol start="73">
  <li><p>This paragraph renders undefined statement expressions such as</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">i = ++i + <span class="hljs-number">1</span>;
a[i++] = i;
</code></pre>
  
  <p>while allowing</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">i = i + <span class="hljs-number">1</span>;
a[i] = i;
</code></pre></li>
  </ol>
</blockquote>

<p>The various sequence points are listed in Annex C of <a href="http://port70.net/~nsz/c/c11/n1570.html#C" rel="noreferrer">C11</a> (and <a href="http://port70.net/~nsz/c/c99/n1256.html#C" rel="noreferrer">C99</a>):</p>

<blockquote>
  <ol>
  <li><p>The following are the sequence points described in 5.1.2.3:</p>
  
  <ul>
  <li>Between the evaluations of the function designator and actual arguments in a function call and the actual call. (6.5.2.2).</li>
  <li>Between the evaluations of the first and second operands of the following operators: logical AND &amp;&amp; (6.5.13); logical OR || (6.5.14); comma , (6.5.17).</li>
  <li>Between the evaluations of the first operand of the conditional ? : operator and whichever of the second and third operands is evaluated (6.5.15).</li>
  <li>The end of a full declarator: declarators (6.7.6);</li>
  <li>Between the evaluation of a full expression and the next full expression to be evaluated. The following are full expressions: an initializer that is not part of a compound literal (6.7.9); the expression in an expression statement (6.8.3); the controlling expression of a selection statement (if or switch) (6.8.4); the controlling expression of a while or do statement (6.8.5); each of the (optional) expressions of a for statement (6.8.5.3); the (optional) expression in a return statement (6.8.6.4).</li>
  <li>Immediately before a library function returns (7.1.4).</li>
  <li>After the actions associated with each formatted input/output function conversion specifier (7.21.6, 7.29.2).</li>
  <li>Immediately before and immediately after each call to a comparison function, and also between any call to a comparison function and any movement of the objects passed as arguments to that call (7.22.5). </li>
  </ul></li>
  </ol>
</blockquote>

<p>The wording of the same <a href="http://port70.net/~nsz/c/c11/n1570.html#6.5p2" rel="noreferrer">paragraph in C11</a> is:</p>

<blockquote>
  <ol start="2">
  <li>If a side effect on a scalar object is unsequenced relative to either a different side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined. If there are multiple allowable orderings of the subexpressions of an expression, the behavior is undefined if such an unsequenced side effect occurs in any of the orderings.84) </li>
  </ol>
</blockquote>

<hr>

<p>You can detect such errors in a program by for example using a recent version of GCC with <code>-Wall</code> and <code>-Werror</code>, and then GCC will outright refuse to compile your program. The following is the output of gcc (Ubuntu 6.2.0-5ubuntu12) 6.2.0 20161005:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">% gcc plusplus.c -Wall -Werror -pedantic
plusplus.c: In function main:
plusplus.c:<span class="hljs-number">6</span>:<span class="hljs-number">6</span>: error: operation on i may be undefined [-Werror=sequence-point]
    i = i++ + ++i;
    ~~^~~~~~~~~~~
plusplus.c:<span class="hljs-number">6</span>:<span class="hljs-number">6</span>: error: operation on i may be undefined [-Werror=sequence-point]
plusplus.c:<span class="hljs-number">10</span>:<span class="hljs-number">6</span>: error: operation on i may be undefined [-Werror=sequence-point]
    i = (i++);
    ~~^~~~~~~
plusplus.c:<span class="hljs-number">14</span>:<span class="hljs-number">6</span>: error: operation on u may be undefined [-Werror=sequence-point]
    u = u++ + ++u;
    ~~^~~~~~~~~~~
plusplus.c:<span class="hljs-number">14</span>:<span class="hljs-number">6</span>: error: operation on u may be undefined [-Werror=sequence-point]
plusplus.c:<span class="hljs-number">18</span>:<span class="hljs-number">6</span>: error: operation on u may be undefined [-Werror=sequence-point]
    u = (u++);
    ~~^~~~~~~
plusplus.c:<span class="hljs-number">22</span>:<span class="hljs-number">6</span>: error: operation on v may be undefined [-Werror=sequence-point]
    v = v++ + ++v;
    ~~^~~~~~~~~~~
plusplus.c:<span class="hljs-number">22</span>:<span class="hljs-number">6</span>: error: operation on v may be undefined [-Werror=sequence-point]
cc1: all warnings being treated as errors
</code></pre>

<p>The important part is to know <a href="https://stackoverflow.com/questions/3575350/sequence-points-in-c">what a sequence point is -- and <em>what is</em> a sequence point and what <em>isn't</em></a>. For example the <em>comma operator</em> is a sequence point, so</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">j = (i ++, ++ i);
</code></pre>

<p>is well-defined, and will increment <code>i</code> by one, yielding the old value, discard that value; then at comma operator, settle the side effects; and then increment <code>i</code> by one, and the resulting value becomes the value of the expression - i.e. this is just a contrived way to write <code>j = (i += 2)</code> which is yet again a "clever" way to write</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">i += <span class="hljs-number">2</span>;
j = i;
</code></pre>

<p>However, the <code>,</code> in function argument lists is <em>not</em> a comma operator, and there is no sequence point between evaluations of distinct arguments; instead their evaluations are unsequenced with regard to each other; so the function call </p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, i++, ++i, i);
</code></pre>

<p>has <em>undefined behaviour</em> because <strong>there is no sequence point between the evaluations of <code>i++</code> and <code>++i</code> in function arguments</strong>, and the value of <code>i</code> is therefore modified twice, by both <code>i++</code> and <code>++i</code>, between the previous and the next sequence point.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The C standard says that a variable should only be assigned at most once between two sequence points. A semi-colon for instance is a sequence point. <br>
So every statement of the form:<br></p>

<pre class="lang-c s-code-block"><code class="hljs language-c">i = i++;
i = i++ + ++i;
</code></pre>

<p>and so on violate that rule. The standard also says that behavior is undefined and not unspecified. Some compilers do detect these and produce some result but this is not per standard.<br></p>

<p>However, two different variables can be incremented between two sequence points.<br></p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-keyword">while</span>(*src++ = *dst++);
</code></pre>

<p>The above is a common coding practice while copying/analysing strings.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In <a href="https://stackoverflow.com/questions/29505280/incrementing-array-index-in-c">https://stackoverflow.com/questions/29505280/incrementing-array-index-in-c</a> someone asked about a statement like:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> k[] = {<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>};
<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
<span class="hljs-type">int</span> num;
num = k[++i+k[++i]] + k[++i];
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, num);
</code></pre>

<p>which prints 7... the OP expected it to print 6.</p>

<p>The <code>++i</code> increments aren't guaranteed to all complete before the rest of the calculations. In fact, different compilers will get different results here.  In the example you provided, the first 2 <code>++i</code> executed, then the values of <code>k[]</code> were read, then the last <code>++i</code> then <code>k[]</code>.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">num = k[i+<span class="hljs-number">1</span>]+k[i+<span class="hljs-number">2</span>] + k[i+<span class="hljs-number">3</span>];
i += <span class="hljs-number">3</span>
</code></pre>

<p>Modern compilers will optimize this very well. In fact, possibly better than the code you originally wrote (assuming it had worked the way you had hoped).</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Your question was probably not, "Why are these constructs undefined behavior in C?".  Your question was probably, "Why did this code (using <code>++</code>) not give me the value I expected?", and someone marked your question as a duplicate, and sent you here.</p>
<p><em>This</em> answer tries to answer that question: why did your code not give you the answer you expected, and how can you learn to recognize (and avoid) expressions that will not work as expected.</p>
<p>I assume you've heard the basic definition of C's <code>++</code> and <code>--</code> operators by now, and how the prefix form <code>++x</code> differs from the postfix form <code>x++</code>.  But these operators are hard to think about, so to make sure you understood, perhaps you wrote a tiny little test program involving something like</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d %d\n"</span>, x, ++x, x++);
</code></pre>
<p>But, to your surprise, this program did <em>not</em> help you understand  it printed some strange, inexplicable output, suggesting that maybe <code>++</code> does something completely different, not at all what you thought it did.</p>
<p>Or, perhaps you're looking at a hard-to-understand expression like</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;
x = x++ + ++x;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, x);
</code></pre>
<p>Perhaps someone gave you that code as a puzzle.  This code also makes no sense, especially if you run it  and if you compile and run it under two different compilers, you're likely to get two different answers!  What's up with that?  Which answer is correct?  (And the answer is that both of them are, or neither of them are.)</p>
<p>As you've heard by now, these expressions are <em>undefined</em>, which means that the C language makes no guarantee about what they'll do.  This is a strange and unsettling result, because you probably thought that any program you could write, as long as it compiled and ran, would generate a unique, well-defined output.  But in the case of undefined behavior, that's not so.</p>
<p>What makes an expression undefined?  Are expressions involving <code>++</code> and <code>--</code> always undefined?  Of course not: these are useful operators, and if you use them properly, they're perfectly well-defined.</p>
<p>For the expressions we're talking about, what makes them undefined is when there's too much going on at once, when we can't tell what order things will happen in, but when the order matters to the result we'll get.</p>
<p>Let's go back to the two examples I've used in this answer.  When I wrote</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d %d\n"</span>, x, ++x, x++);
</code></pre>
<p>the question is, before actually calling <code>printf</code>, does the compiler compute the value of <code>x</code> first, or <code>x++</code>, or maybe <code>++x</code>?  But it turns out <em>we don't know</em>.  There's no rule in C which says that the arguments to a function get evaluated left-to-right, or right-to-left, or in some other order.  So we can't say whether the compiler will do <code>x</code> first, then <code>++x</code>, then <code>x++</code>, or <code>x++</code> then <code>++x</code> then <code>x</code>, or some other order.  But the order clearly matters, because depending on which order the compiler uses, we'll clearly get a different series of numbers printed out.</p>
<p>What about this crazy expression?</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">x = x++ + ++x;
</code></pre>
<p>The problem with this expression is that it contains three different attempts to modify the value of <code>x</code>: (1) the <code>x++</code> part tries to take <code>x</code>'s value, add 1, store the new value in <code>x</code>, and return the old value; (2) the <code>++x</code> part tries to take <code>x</code>'s value, add 1, store the new value in <code>x</code>, and return the new value; and (3) the <code>x =</code> part tries to assign the sum of the other two back to <code>x</code>.  Which of those three attempted assignments will "win"?  Which of the three values will actually determine the final value of <code>x</code>?  Again, and perhaps surprisingly, there's no rule in C to tell us.</p>
<p>You might imagine that precedence or associativity or left-to-right evaluation tells you what order things happen in, but they do not.  You may not believe me, but please take my word for it, and I'll say it again: precedence and associativity do not determine every aspect of the evaluation order of an expression in C.  In particular, if within one expression there are multiple different spots where we try to assign a new value to something like <code>x</code>, precedence and associativity do <em>not</em> tell us which of those attempts happens first, or last, or anything.</p>
<hr>
<p>So with all that background and introduction out of the way, if you want to make sure that all your programs are well-defined, which expressions can you write, and which ones can you not write?</p>
<p>These expressions are all fine:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">y = x++;
z = x++ + y++;
x = x + <span class="hljs-number">1</span>;
x = a[i++];
x = a[i++] + b[j++];
x[i++] = a[j++] + b[k++];
x = *p++;
x = *p++ + *q++;
</code></pre>
<p>These expressions are all undefined:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">x = x++;
x = x++ + ++x;
y = x + x++;
a[i] = i++;
a[i++] = i;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d %d\n"</span>, x, ++x, x++);
</code></pre>
<p>And the last question is, how can you tell which expressions are well-defined, and which expressions are undefined?</p>
<p>As I said earlier, the undefined expressions are the ones where there's too much going at once, where you can't be sure what order things happen in, and where the order matters:</p>
<ol>
<li>If there's one variable that's getting modified (assigned to) in two or more different places, how do you know which modification happens first?</li>
<li>If there's a variable that's getting modified in one place, and having its value used in another place, how do you know whether it uses the old value or the new value?</li>
</ol>
<p>As an example of #1, in the expression</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">x = x++ + ++x;
</code></pre>
<p>there are three attempts to modify <code>x</code>.</p>
<p>As an example of #2, in the expression</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">y = x + x++;
</code></pre>
<p>we both use the value of <code>x</code>, and modify it.</p>
<p>So that's the answer: make sure that in any expression you write, each variable is modified at most once, and if a variable is modified, you don't also attempt to use the value of that variable somewhere else.</p>
<hr>
<p>One more thing.  You might be wondering how to "fix" the undefined expressions I started this answer by presenting.</p>
<p>In the case of <code>printf("%d %d %d\n", x, ++x, x++);</code>, it's easy  just write it as three separate <code>printf</code> calls:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, x);
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, ++x);
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, x++);
</code></pre>
<p>Now the behavior is perfectly well defined, and you'll get sensible results.</p>
<p>In the case of <code>x = x++ + ++x</code>, on the other hand, there's no way to fix it.  There's no way to write it so that it has guaranteed behavior matching your expectations  but that's okay, because you would never write an expression like <code>x = x++ + ++x</code> in a real program anyway.</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A good explanation about what happens in this kind of computation is provided in the document <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1188.pdf" rel="noreferrer">n1188</a> from <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/" rel="noreferrer">the ISO W14 site</a>.</p>

<p>I explain the ideas.</p>

<p>The main rule from the standard ISO 9899 that applies in this situation is  6.5p2.</p>

<blockquote>
  <p>Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression.   Furthermore, the prior value shall be read only to determine the value to be stored.</p>
</blockquote>

<p>The sequence points in an expression like <code>i=i++</code> are before <code>i=</code> and after <code>i++</code>.  </p>

<p>In the paper that I quoted above it is explained that you can figure out the program as being formed by small boxes, each box containing the instructions between 2 consecutive sequence points.  The sequence points are defined in annex C of the standard, in the case of <code>i=i++</code> there are 2 sequence points that delimit a full-expression.  Such an expression is syntactically equivalent with an entry of <code>expression-statement</code> in the Backus-Naur form of the grammar (a grammar is provided in annex A of the Standard).</p>

<p>So the order of instructions inside a box has no clear order.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">i=i++
</code></pre>

<p>can be interpreted as</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">tmp = i
i=i+<span class="hljs-number">1</span>
i = tmp
</code></pre>

<p>or as</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">tmp = i
i = tmp
i=i+<span class="hljs-number">1</span>
</code></pre>

<p>because both all these forms to interpret the code <code>i=i++</code> are valid and because both generate different answers, the behavior is undefined.</p>

<p>So a sequence point can be seen by the beginning and the end of each box that composes the program [the boxes are atomic units in C] and inside a box the order of instructions is not defined in all cases.  Changing that order one can change the result sometimes.</p>

<p>EDIT:</p>

<p>Other good source for explaining such ambiguities are the entries from <a href="http://c-faq.com/" rel="noreferrer">c-faq</a> site (also published <a href="https://rads.stackoverflow.com/amzn/click/com/0201845199" rel="noreferrer">as a book</a>) , namely <a href="http://c-faq.com/expr/seqpoints.html" rel="noreferrer">here</a> and <a href="http://c-faq.com/expr/evalorder4.html" rel="noreferrer">here</a> and <a href="http://c-faq.com/expr/confused.html" rel="noreferrer">here</a> .</p>
    </div></div></div></div><div class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl border p-10 shadow-md w-9/12 bg-white"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The reason is that the program is running undefined behavior. The problem lies in the evaluation order, because there is no sequence points required according to C++98 standard ( no operations is sequenced before or after another according to C++11 terminology).</p>
<p>However if you stick to one compiler, you will find the behavior persistent, as long as you don't add function calls or pointers, which would make the behavior more messy.</p>
<p>Using <a href="https://nuwen.net/mingw.html" rel="nofollow noreferrer">Nuwen MinGW</a> 15 GCC 7.1 you will get:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"> <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span>
 <span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> ** argv)</span>
 {
    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
    i = i++ + ++i;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, i); <span class="hljs-comment">// 2</span>

    i = <span class="hljs-number">1</span>;
    i = (i++);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, i); <span class="hljs-comment">//1</span>

    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;
    u = u++ + ++u;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, u); <span class="hljs-comment">// 2</span>

    u = <span class="hljs-number">1</span>;
    u = (u++);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, u); <span class="hljs-comment">//1</span>

    <span class="hljs-keyword">register</span> <span class="hljs-type">int</span> v = <span class="hljs-number">0</span>;
    v = v++ + ++v;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, v); <span class="hljs-comment">//2</span>
 }
</code></pre>
<p>How does GCC work? it evaluates sub expressions at a left to right order for the right hand side (RHS) , then assigns the value to the left hand side (LHS) . This is exactly how Java and C# behave and define their standards. (Yes, the equivalent software in Java and C# has defined behaviors). It evaluate each sub expression one by one in the RHS Statement in a left to right order; for each sub expression: the ++c (pre-increment)  is evaluated first then the value c is used for the operation, then the post increment c++).</p>
<p>according to <a href="http://helpcentreonline.com/article/operator_console_gcc.pdf" rel="nofollow noreferrer">GCC C++: Operators</a></p>
<blockquote>
<p>In GCC C++,  the precedence of the operators controls the order in
which the individual operators are evaluated</p>
</blockquote>
<p>the equivalent code in defined behavior C++ as   GCC understands:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> ** argv)</span>
{
    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-comment">//i = i++ + ++i;</span>
    <span class="hljs-type">int</span> r;
    r=i;
    i++;
    ++i;
    r+=i;
    i=r;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, i); <span class="hljs-comment">// 2</span>

    i = <span class="hljs-number">1</span>;
    <span class="hljs-comment">//i = (i++);</span>
    r=i;
    i++;
    i=r;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, i); <span class="hljs-comment">// 1</span>

    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;
    <span class="hljs-comment">//u = u++ + ++u;</span>
    r=u;
    u++;
    ++u;
    r+=u;
    u=r;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, u); <span class="hljs-comment">// 2</span>

    u = <span class="hljs-number">1</span>;
    <span class="hljs-comment">//u = (u++);</span>
    r=u;
    u++;
    u=r;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, u); <span class="hljs-comment">// 1</span>

    <span class="hljs-keyword">register</span> <span class="hljs-type">int</span> v = <span class="hljs-number">0</span>;
    <span class="hljs-comment">//v = v++ + ++v;</span>
    r=v;
    v++;
    ++v;
    r+=v;
    v=r;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, v); <span class="hljs-comment">//2</span>
}
</code></pre>
<p>Then we go to <a href="https://www.visualstudio.com/" rel="nofollow noreferrer">Visual Studio</a>. Visual Studio 2015, you get:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> ** argv)</span>
{
    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
    i = i++ + ++i;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, i); <span class="hljs-comment">// 3</span>

    i = <span class="hljs-number">1</span>;
    i = (i++);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, i); <span class="hljs-comment">// 2 </span>

    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;
    u = u++ + ++u;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, u); <span class="hljs-comment">// 3</span>

    u = <span class="hljs-number">1</span>;
    u = (u++);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, u); <span class="hljs-comment">// 2 </span>

    <span class="hljs-keyword">register</span> <span class="hljs-type">int</span> v = <span class="hljs-number">0</span>;
    v = v++ + ++v;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, v); <span class="hljs-comment">// 3 </span>
}
</code></pre>
<p>How does Visual Studio work, it takes another approach, it evaluates all pre-increments expressions in first pass, then uses variables values in the operations in second pass,  assign from RHS to LHS in third pass, then at last pass it evaluates all the post-increment expressions in one pass.</p>
<p>So the equivalent in defined behavior C++ as Visual C++ understands:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> ** argv)</span>
{
    <span class="hljs-type">int</span> r;
    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-comment">//i = i++ + ++i;</span>
    ++i;
    r = i + i;
    i = r;
    i++;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, i); <span class="hljs-comment">// 3</span>

    i = <span class="hljs-number">1</span>;
    <span class="hljs-comment">//i = (i++);</span>
    r = i;
    i = r;
    i++;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, i); <span class="hljs-comment">// 2 </span>

    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;
    <span class="hljs-comment">//u = u++ + ++u;</span>
    ++u;
    r = u + u;
    u = r;
    u++;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, u); <span class="hljs-comment">// 3</span>

    u = <span class="hljs-number">1</span>;
    <span class="hljs-comment">//u = (u++);</span>
    r = u;
    u = r;
    u++;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, u); <span class="hljs-comment">// 2 </span>

    <span class="hljs-keyword">register</span> <span class="hljs-type">int</span> v = <span class="hljs-number">0</span>;
    <span class="hljs-comment">//v = v++ + ++v;</span>
    ++v;
    r = v + v;
    v = r;
    v++;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, v); <span class="hljs-comment">// 3 </span>
}
</code></pre>
<p>as Visual Studio documentation states at <a href="https://msdn.microsoft.com/en-us/library/2bxt6kc4.aspx" rel="nofollow noreferrer">Precedence and Order of Evaluation</a>:</p>
<blockquote>
<p>Where several operators appear together, they have equal precedence and are evaluated according to their associativity. The operators in the table are described in the sections beginning with Postfix Operators.</p>
</blockquote>
    </div></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;C has the concept of undefined behavior, i.e. some language constructs are syntactically valid but you can\u0026apos;t predict the behavior when the code is run.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As far as I know, the standard doesn\u0026apos;t explicitly say \u0026lt;em\u0026gt;why\u0026lt;/em\u0026gt; the concept of undefined behavior exists. In my mind, it\u0026apos;s simply because the language designers wanted there to be some leeway in the semantics, instead of i.e. requiring that all implementations handle integer overflow in the exact same way, which would very likely impose serious performance costs, they just left the behavior undefined so that if you write code that causes integer overflow, anything can happen.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So, with that in mind, why are these \u0026quot;issues\u0026quot;? The language clearly says that certain things lead to \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Undefined_behavior\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;undefined behavior\u0026lt;/a\u0026gt;. There is no problem, there is no \u0026quot;should\u0026quot; involved. If the undefined behavior changes when one of the involved variables is declared \u0026lt;code\u0026gt;volatile\u0026lt;/code\u0026gt;, that doesn\u0026apos;t prove or change anything. It is \u0026lt;em\u0026gt;undefined\u0026lt;/em\u0026gt;; you cannot reason about the behavior.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Your most interesting-looking example, the one with\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;u = (u++);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;is a text-book example of undefined behavior (see Wikipedia\u0026apos;s entry on \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Sequence_point\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;sequence points\u0026lt;/a\u0026gt;).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Most of the answers here quoted from C standard emphasizing that the behavior of these constructs are undefined. To understand \u0026lt;strong\u0026gt;why the behavior of these constructs are undefined\u0026lt;/strong\u0026gt;, let\u0026apos;s understand these terms first in the light of C11 standard:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Sequenced:\u0026lt;/strong\u0026gt; (5.1.2.3)\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Given any two evaluations \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;, if \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; is sequenced before \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;, then the execution of \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; shall precede the execution of \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Unsequenced:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;If \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; is not sequenced before or after \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;, then \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; are unsequenced.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Evaluations can be one of two things:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;value computations\u0026lt;/strong\u0026gt;, which work out the result of an expression; and\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;side effects\u0026lt;/strong\u0026gt;, which are modifications of objects.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Sequence Point:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;The presence of a sequence point between the evaluation of expressions \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; implies that every \u0026lt;em\u0026gt;value computation\u0026lt;/em\u0026gt; and \u0026lt;em\u0026gt;side effect\u0026lt;/em\u0026gt; associated with \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; is sequenced before every \u0026lt;em\u0026gt;value computation\u0026lt;/em\u0026gt; and \u0026lt;em\u0026gt;side effect\u0026lt;/em\u0026gt; associated with \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Now coming to the question, for the expressions like\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\ni = i++;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;standard says that:\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;6.5 Expressions:\u0026lt;/h3\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;If a side effect on a scalar object is unsequenced relative to\u0026lt;/strong\u0026gt; either \u0026lt;strong\u0026gt;a different side effect on the same scalar object\u0026lt;/strong\u0026gt; or a value computation using the value of the same scalar object, \u0026lt;strong\u0026gt;the behavior is undefined\u0026lt;/strong\u0026gt;. [...]\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Therefore, the above expression invokes UB because two side effects on the same object \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; is unsequenced relative to each other. That means it is not sequenced whether the side effect by assignment to \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; will be done before or after the side effect by \u0026lt;code\u0026gt;++\u0026lt;/code\u0026gt;.\u0026lt;br\u0026gt;\nDepending on whether assignment occurs before or after the increment, different results will be produced and that\u0026apos;s the one of the case of \u0026lt;strong\u0026gt;undefined behavior\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Lets rename the \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; at left of assignment be \u0026lt;code\u0026gt;il\u0026lt;/code\u0026gt; and at the right of assignment (in the expression \u0026lt;code\u0026gt;i++\u0026lt;/code\u0026gt;) be \u0026lt;code\u0026gt;ir\u0026lt;/code\u0026gt;, then the expression be like\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;il = ir++     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Note that suffix l and r are used for the sake of clarity.\u0026lt;/span\u0026gt;\n              \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Both il and ir represents the same object.  \u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/a/17935062/2455888\u0026quot;\u0026gt;An important point\u0026lt;/a\u0026gt; regarding Postfix \u0026lt;code\u0026gt;++\u0026lt;/code\u0026gt; operator is that:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;just because the \u0026lt;code\u0026gt;++\u0026lt;/code\u0026gt; comes after the variable does not mean that the increment happens late\u0026lt;/strong\u0026gt;. The increment can happen as early as the compiler likes \u0026lt;em\u0026gt;as long as the compiler ensures that the original value is used\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;It means the expression \u0026lt;code\u0026gt;il = ir++\u0026lt;/code\u0026gt; could be evaluated either as\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;temp = ir;      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// i = 1\u0026lt;/span\u0026gt;\nir = ir + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// i = 2   side effect by ++ before assignment\u0026lt;/span\u0026gt;\nil = temp;      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// i = 1   result is 1  \u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;or\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;temp = ir;      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// i = 1\u0026lt;/span\u0026gt;\nil = temp;      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// i = 1   side effect by assignment before ++\u0026lt;/span\u0026gt;\nir = ir + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// i = 2   result is 2  \u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;resulting in two different results \u0026lt;code\u0026gt;1\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;2\u0026lt;/code\u0026gt; which depends on the sequence of side effects by assignment and \u0026lt;code\u0026gt;++\u0026lt;/code\u0026gt; and hence invokes UB.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I think the relevant parts of the C99 standard are 6.5 Expressions, §2\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Between the previous and next sequence point an object shall have its stored value\n  modified at most once by the evaluation of an expression. Furthermore, the prior value\n  shall be read only to determine the value to be stored.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;and 6.5.16 Assignment operators, §4:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The order of evaluation of the operands is unspecified. If an attempt is made to modify\n  the result of an assignment operator or to access it after the next sequence point, the\n  behavior is undefined. \u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Just compile and disassemble your line of code, if you are so inclined to know how exactly it is you get what you are getting.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is what I get on my machine, together with what I think is going on:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;$ cat evil.c\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;evil\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n  i+= i++ + ++i;\n}\n$ gcc evil.c -c -o evil.bin\n$ gdb evil.bin\n(gdb) disassemble evil\nDump of assembler code \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; function evil:\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x00000000\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\u0026amp;gt;:   push   %ebp\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x00000001\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\u0026amp;gt;:   mov    %esp,%ebp\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x00000003\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\u0026amp;gt;:   sub    $\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x10\u0026lt;/span\u0026gt;,%esp\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x00000006\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;\u0026amp;gt;:   movl   $\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-0x4\u0026lt;/span\u0026gt;(%ebp)  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// i = 0   i = 0\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x0000000d\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;13\u0026lt;/span\u0026gt;\u0026amp;gt;:  addl   $\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-0x4\u0026lt;/span\u0026gt;(%ebp)  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// i++     i = 1\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x00000011\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;17\u0026lt;/span\u0026gt;\u0026amp;gt;:  mov    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-0x4\u0026lt;/span\u0026gt;(%ebp),%eax  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// j = i   i = 1  j = 1\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x00000014\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt;\u0026amp;gt;:  add    %eax,%eax        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// j += j  i = 1  j = 2\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x00000016\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;22\u0026lt;/span\u0026gt;\u0026amp;gt;:  add    %eax,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-0x4\u0026lt;/span\u0026gt;(%ebp)  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// i += j  i = 3\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x00000019\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;25\u0026lt;/span\u0026gt;\u0026amp;gt;:  addl   $\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-0x4\u0026lt;/span\u0026gt;(%ebp)  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// i++     i = 4\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x0000001d\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;29\u0026lt;/span\u0026gt;\u0026amp;gt;:  leave  \n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x0000001e\u0026lt;/span\u0026gt; \u0026amp;lt;+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;30\u0026lt;/span\u0026gt;\u0026amp;gt;:  ret\nEnd of assembler dump.\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;(I... suppose that the 0x00000014 instruction was some kind of compiler optimization?)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The behavior can\u0026apos;t really be explained because it invokes both \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Unspecified_behavior\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;unspecified behavior\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Undefined_behavior\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;undefined behavior\u0026lt;/a\u0026gt;, so we can not make any general predictions about this code, although if you read \u0026lt;em\u0026gt;Olve Maudal\u0026apos;s\u0026lt;/em\u0026gt; work such as \u0026lt;a href=\u0026quot;http://www.slideshare.net/olvemaudal/deep-c\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Deep C\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;http://www.pvv.org/~oma/UnspecifiedAndUndefined_ACCU_Apr2013.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Unspecified and Undefined\u0026lt;/a\u0026gt; sometimes you can make good guesses in very specific cases with a specific compiler and environment but please don\u0026apos;t do that anywhere near production.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So moving on to \u0026lt;em\u0026gt;unspecified behavior\u0026lt;/em\u0026gt;, in \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;draft c99 standard\u0026lt;/a\u0026gt; section\u0026lt;code\u0026gt;6.5\u0026lt;/code\u0026gt; paragraph \u0026lt;em\u0026gt;3\u0026lt;/em\u0026gt; says(\u0026lt;em\u0026gt;emphasis mine\u0026lt;/em\u0026gt;):\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The grouping of operators and operands is indicated by the syntax.74) Except as specified\n  later (for the function-call (), \u0026amp;amp;\u0026amp;amp;, ||, ?:, and comma operators), \u0026lt;strong\u0026gt;the order of evaluation of subexpressions and the order in which side effects take place are both unspecified.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;So when we have a line like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;i = i++ + ++i;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;we do not know whether \u0026lt;code\u0026gt;i++\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;++i\u0026lt;/code\u0026gt; will be evaluated first. This is mainly to give the compiler \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/12540468/1708801\u0026quot;\u0026gt;better options for optimization\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;We also have \u0026lt;em\u0026gt;undefined behavior\u0026lt;/em\u0026gt; here as well since the program is modifying variables(\u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;u\u0026lt;/code\u0026gt;, etc..) more than once between \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Sequence_point\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;sequence points\u0026lt;/a\u0026gt;. From draft standard section \u0026lt;code\u0026gt;6.5\u0026lt;/code\u0026gt; paragraph \u0026lt;em\u0026gt;2\u0026lt;/em\u0026gt;(\u0026lt;em\u0026gt;emphasis mine\u0026lt;/em\u0026gt;):\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Between the previous and next sequence point an object shall have its stored value\n  modified at most once\u0026lt;/strong\u0026gt; by the evaluation of an expression. Furthermore, \u0026lt;strong\u0026gt;the prior value\n  shall be read only to determine the value to be stored\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;it cites the following code examples as being undefined:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;i = ++i + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\na[i++] = i; \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In all these examples the code is attempting to modify an object more than once in the same sequence point, which will end with the \u0026lt;code\u0026gt;;\u0026lt;/code\u0026gt; in each one of these cases:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;i = i++ + ++i;\n^   ^       ^\n\ni = (i++);\n^    ^\n\nu = u++ + ++u;\n^   ^       ^\n\nu = (u++);\n^    ^\n\nv = v++ + ++v;\n^   ^       ^\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Unspecified behavior\u0026lt;/em\u0026gt; is defined in the \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;draft c99 standard\u0026lt;/a\u0026gt; in section \u0026lt;code\u0026gt;3.4.4\u0026lt;/code\u0026gt; as:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;use of an unspecified value, or other behavior where this International Standard provides\n  two or more possibilities and imposes no further requirements on which is chosen in any\n  instance\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;and \u0026lt;em\u0026gt;undefined behavior\u0026lt;/em\u0026gt; is defined in section \u0026lt;code\u0026gt;3.4.3\u0026lt;/code\u0026gt; as:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;behavior, upon use of a nonportable or erroneous program construct or of erroneous data,\n  for which this International Standard imposes no requirements\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;and notes that:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Possible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Another way of answering this, rather than getting bogged down in arcane details of sequence points and undefined behavior, is simply to ask, \u0026lt;em\u0026gt;what are they supposed to mean?\u0026lt;/em\u0026gt; \u0026lt;em\u0026gt;What was the programmer trying to do?\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The first fragment asked about, \u0026lt;code\u0026gt;i = i++ + ++i\u0026lt;/code\u0026gt;, is pretty clearly insane in my book.  No one would ever write it in a real program, it\u0026apos;s not obvious what it does, there\u0026apos;s no conceivable algorithm someone could have been trying to code that would have resulted in this particular contrived sequence of operations.  And since it\u0026apos;s not obvious to you and me what it\u0026apos;s supposed to do, it\u0026apos;s fine in my book if the compiler can\u0026apos;t figure out what it\u0026apos;s supposed to do, either.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The second fragment, \u0026lt;code\u0026gt;i = i++\u0026lt;/code\u0026gt;, is a little easier to understand.  Someone is clearly trying to increment i, and assign the result back to i.  But there are a couple ways of doing this in C.  The most basic way to add 1 to i, and assign the result back to i, is the same in almost any programming language:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;i = i + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;C, of course, has a handy shortcut:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;i++\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This means, \u0026quot;add 1 to i, and assign the result back to i\u0026quot;.  So if we construct a hodgepodge of the two, by writing\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;i = i++\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;what we\u0026apos;re really saying is \u0026quot;add 1 to i, and assign the result back to i, and assign the result back to i\u0026quot;.  We\u0026apos;re confused, so it doesn\u0026apos;t bother me too much if the compiler gets confused, too.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Realistically, the only time these crazy expressions get written is when people are using them as artificial examples of how ++ is supposed to work.  And of course it is important to understand how ++ works.  But one practical rule for using ++ is, \u0026quot;If it\u0026apos;s not obvious what an expression using ++ means, don\u0026apos;t write it.\u0026quot;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;We used to spend countless hours on comp.lang.c discussing expressions like these and \u0026lt;em\u0026gt;why\u0026lt;/em\u0026gt; they\u0026apos;re undefined.  Two of my longer answers, that try to really explain why, are archived on the web:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://www.eskimo.com/~scs/readings/undef.950321.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Why doesn\u0026apos;t the Standard define what these do?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://www.eskimo.com/~scs/readings/precvsooe.960725.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Doesn\u0026apos;t operator precedence determine the order of evaluation?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;See also \u0026lt;a href=\u0026quot;http://c-faq.com/expr/seqpoints.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;question 3.8\u0026lt;/a\u0026gt; and the rest of the questions in \u0026lt;a href=\u0026quot;http://c-faq.com/expr/index.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;section 3\u0026lt;/a\u0026gt; of the \u0026lt;a href=\u0026quot;http://c-faq.com/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;C FAQ list\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Often this question is linked as a duplicate of questions related to code like\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d %d\\n\u0026quot;\u0026lt;/span\u0026gt;, i, i++);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;or \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d %d\\n\u0026quot;\u0026lt;/span\u0026gt;, ++i, i++);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;or similar variants.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;While this is also \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Undefined_behavior\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;em\u0026gt;undefined behaviour\u0026lt;/em\u0026gt;\u0026lt;/a\u0026gt; as stated already, there are subtle differences when \u0026lt;code\u0026gt;printf()\u0026lt;/code\u0026gt; is involved when comparing to a statement such as:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;x = i++ + i++;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;In the following statement:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d %d\\n\u0026quot;\u0026lt;/span\u0026gt;, ++i, i++);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;the \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/c/language/eval_order\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;em\u0026gt;order of evaluation\u0026lt;/em\u0026gt;\u0026lt;/a\u0026gt; of arguments in \u0026lt;code\u0026gt;printf()\u0026lt;/code\u0026gt; is \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Unspecified_behavior\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;em\u0026gt;unspecified\u0026lt;/em\u0026gt;\u0026lt;/a\u0026gt;. That means, expressions \u0026lt;code\u0026gt;i++\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;++i\u0026lt;/code\u0026gt; could be evaluated in any order. \u0026lt;a href=\u0026quot;http://port70.net/~nsz/c/c11/n1570.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;C11 standard\u0026lt;/a\u0026gt; has some relevant descriptions on this:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Annex J, unspecified behaviours\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The order in which the function designator, arguments, and\n  subexpressions within the arguments are evaluated in a function call\n  (6.5.2.2).\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;3.4.4, unspecified behavior\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Use of an unspecified value, or other behavior where this\n  International Standard provides two or more possibilities and imposes\n  no further requirements on which is chosen in any instance.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;EXAMPLE An example of unspecified behavior is the order in which the\n  arguments to a function are evaluated.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;em\u0026gt;unspecified behaviour\u0026lt;/em\u0026gt; itself is NOT an issue. Consider this example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d %d\\n\u0026quot;\u0026lt;/span\u0026gt;, ++x, y++);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This too has \u0026lt;em\u0026gt;unspecified behaviour\u0026lt;/em\u0026gt; because the order of evaluation of \u0026lt;code\u0026gt;++x\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;y++\u0026lt;/code\u0026gt; is unspecified. But it\u0026apos;s perfectly legal and valid statement. There\u0026apos;s \u0026lt;em\u0026gt;no\u0026lt;/em\u0026gt; undefined behaviour in this statement. Because the modifications (\u0026lt;code\u0026gt;++x\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;y++\u0026lt;/code\u0026gt;) are done to \u0026lt;em\u0026gt;distinct\u0026lt;/em\u0026gt; objects.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;What renders the following statement \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d %d\\n\u0026quot;\u0026lt;/span\u0026gt;, ++i, i++);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;as \u0026lt;em\u0026gt;undefined behaviour\u0026lt;/em\u0026gt; is the fact that these two expressions modify the \u0026lt;em\u0026gt;same\u0026lt;/em\u0026gt; object \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; without an intervening \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Sequence_point\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;em\u0026gt;sequence point\u0026lt;/em\u0026gt;\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Another detail is that the \u0026lt;em\u0026gt;comma\u0026lt;/em\u0026gt; involved in the printf() call is a \u0026lt;em\u0026gt;separator\u0026lt;/em\u0026gt;, not the \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Comma_operator\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;em\u0026gt;comma operator\u0026lt;/em\u0026gt;\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is an important distinction because the \u0026lt;em\u0026gt;comma operator\u0026lt;/em\u0026gt; does introduce a \u0026lt;em\u0026gt;sequence point\u0026lt;/em\u0026gt; between the evaluation of their operands, which makes the following legal:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; j;\n\nj = (++i, i++);  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// No undefined behaviour here because the comma operator \u0026lt;/span\u0026gt;\n                 \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// introduces a sequence point between \u0026apos;++i\u0026apos; and \u0026apos;i++\u0026apos;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;i=%d j=%d\\n\u0026quot;\u0026lt;/span\u0026gt;,i, j); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// prints: i=7 j=6\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The comma operator evaluates its operands left-to-right and yields only the value of the last operand. So in \u0026lt;code\u0026gt;j = (++i, i++);\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;++i\u0026lt;/code\u0026gt; increments \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;6\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;i++\u0026lt;/code\u0026gt; yields old value of \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; (\u0026lt;code\u0026gt;6\u0026lt;/code\u0026gt;) which is assigned to \u0026lt;code\u0026gt;j\u0026lt;/code\u0026gt;. Then \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; becomes \u0026lt;code\u0026gt;7\u0026lt;/code\u0026gt; due to post-increment.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So if the \u0026lt;em\u0026gt;comma\u0026lt;/em\u0026gt; in the function call were to be a comma operator then \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d %d\\n\u0026quot;\u0026lt;/span\u0026gt;, ++i, i++);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;will not be a problem. But it invokes \u0026lt;em\u0026gt;undefined behaviour\u0026lt;/em\u0026gt; because the \u0026lt;em\u0026gt;comma\u0026lt;/em\u0026gt; here is a \u0026lt;em\u0026gt;separator\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;For those who are new to \u0026lt;em\u0026gt;undefined behaviour\u0026lt;/em\u0026gt; would benefit from reading \u0026lt;a href=\u0026quot;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;What Every C Programmer Should Know About Undefined Behavior\u0026lt;/a\u0026gt;  to understand the concept and many other variants of undefined behaviour in C.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This post: \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/4105123/1275169\u0026quot;\u0026gt;Undefined, unspecified and implementation-defined behavior\u0026lt;/a\u0026gt; is also relevant.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;While it is unlikely that any compilers and processors would actually do so, it would be legal, under the C standard, for the compiler to implement \u0026quot;i++\u0026quot; with the sequence:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;In a single operation, read `i` and lock it to prevent access until further notice\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Compute\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;+read_value)\u0026lt;/span\u0026gt;\nIn a single operation, unlock `i` and store the computed value\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;While I don\u0026apos;t think any processors support the hardware to allow such a thing to be done efficiently, one can easily imagine situations where such behavior would make multi-threaded code easier (e.g. it would guarantee that if two threads try to perform the above sequence simultaneously, \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; would get incremented by two) and it\u0026apos;s not totally inconceivable that some future processor might provide a feature something like that.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If the compiler were to write \u0026lt;code\u0026gt;i++\u0026lt;/code\u0026gt; as indicated above (legal under the standard) and were to intersperse the above instructions throughout the evaluation of the overall expression (also legal), and if it didn\u0026apos;t happen to notice that one of the other instructions happened to access \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt;, it would be possible (and legal) for the compiler to generate a sequence of instructions that would deadlock.  To be sure, a compiler would almost certainly detect the problem in the case where the same variable \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; is used in both places, but if a routine accepts references to two pointers \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;q\u0026lt;/code\u0026gt;, and uses \u0026lt;code\u0026gt;(*p)\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;(*q)\u0026lt;/code\u0026gt; in the above expression (rather than using \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; twice) the compiler would not be required to recognize or avoid the deadlock that would occur if the same object\u0026apos;s address were passed for both \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;q\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;While the \u0026lt;strong\u0026gt;syntax\u0026lt;/strong\u0026gt; of the expressions like \u0026lt;code\u0026gt;a = a++\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;a++ + a++\u0026lt;/code\u0026gt; is legal, the \u0026lt;strong\u0026gt;behaviour\u0026lt;/strong\u0026gt; of these constructs is \u0026lt;strong\u0026gt;undefined\u0026lt;/strong\u0026gt; because a \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;shall\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt; in C standard is not obeyed. \u0026lt;a href=\u0026quot;http://port70.net/~nsz/c/c99/n1256.html#6.5p2\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;C99 6.5p2\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;ol start=\u0026quot;2\u0026quot;\u0026gt;\n  \u0026lt;li\u0026gt;Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression. [72] Furthermore, the prior value shall be read only to determine the value to be stored [73]\u0026lt;/li\u0026gt;\n  \u0026lt;/ol\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;With \u0026lt;a href=\u0026quot;http://port70.net/~nsz/c/c99/n1256.html#note73\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;footnote 73\u0026lt;/a\u0026gt; further clarifying that\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;ol start=\u0026quot;73\u0026quot;\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;p\u0026gt;This paragraph renders undefined statement expressions such as\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;i = ++i + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\na[i++] = i;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n  \n  \u0026lt;p\u0026gt;while allowing\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;i = i + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\na[i] = i;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n  \u0026lt;/ol\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;The various sequence points are listed in Annex C of \u0026lt;a href=\u0026quot;http://port70.net/~nsz/c/c11/n1570.html#C\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;C11\u0026lt;/a\u0026gt; (and \u0026lt;a href=\u0026quot;http://port70.net/~nsz/c/c99/n1256.html#C\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;C99\u0026lt;/a\u0026gt;):\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;ol\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;p\u0026gt;The following are the sequence points described in 5.1.2.3:\u0026lt;/p\u0026gt;\n  \n  \u0026lt;ul\u0026gt;\n  \u0026lt;li\u0026gt;Between the evaluations of the function designator and actual arguments in a function call and the actual call. (6.5.2.2).\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;Between the evaluations of the first and second operands of the following operators: logical AND \u0026amp;amp;\u0026amp;amp; (6.5.13); logical OR || (6.5.14); comma , (6.5.17).\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;Between the evaluations of the first operand of the conditional ? : operator and whichever of the second and third operands is evaluated (6.5.15).\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;The end of a full declarator: declarators (6.7.6);\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;Between the evaluation of a full expression and the next full expression to be evaluated. The following are full expressions: an initializer that is not part of a compound literal (6.7.9); the expression in an expression statement (6.8.3); the controlling expression of a selection statement (if or switch) (6.8.4); the controlling expression of a while or do statement (6.8.5); each of the (optional) expressions of a for statement (6.8.5.3); the (optional) expression in a return statement (6.8.6.4).\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;Immediately before a library function returns (7.1.4).\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;After the actions associated with each formatted input/output function conversion specifier (7.21.6, 7.29.2).\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;Immediately before and immediately after each call to a comparison function, and also between any call to a comparison function and any movement of the objects passed as arguments to that call (7.22.5). \u0026lt;/li\u0026gt;\n  \u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n  \u0026lt;/ol\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;The wording of the same \u0026lt;a href=\u0026quot;http://port70.net/~nsz/c/c11/n1570.html#6.5p2\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;paragraph in C11\u0026lt;/a\u0026gt; is:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;ol start=\u0026quot;2\u0026quot;\u0026gt;\n  \u0026lt;li\u0026gt;If a side effect on a scalar object is unsequenced relative to either a different side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined. If there are multiple allowable orderings of the subexpressions of an expression, the behavior is undefined if such an unsequenced side effect occurs in any of the orderings.84) \u0026lt;/li\u0026gt;\n  \u0026lt;/ol\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;You can detect such errors in a program by for example using a recent version of GCC with \u0026lt;code\u0026gt;-Wall\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;-Werror\u0026lt;/code\u0026gt;, and then GCC will outright refuse to compile your program. The following is the output of gcc (Ubuntu 6.2.0-5ubuntu12) 6.2.0 20161005:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;% gcc plusplus.c -Wall -Werror -pedantic\nplusplus.c: In function main:\nplusplus.c:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;: error: operation on i may be undefined [-Werror=sequence-point]\n    i = i++ + ++i;\n    ~~^~~~~~~~~~~\nplusplus.c:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;: error: operation on i may be undefined [-Werror=sequence-point]\nplusplus.c:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;: error: operation on i may be undefined [-Werror=sequence-point]\n    i = (i++);\n    ~~^~~~~~~\nplusplus.c:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;14\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;: error: operation on u may be undefined [-Werror=sequence-point]\n    u = u++ + ++u;\n    ~~^~~~~~~~~~~\nplusplus.c:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;14\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;: error: operation on u may be undefined [-Werror=sequence-point]\nplusplus.c:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;18\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;: error: operation on u may be undefined [-Werror=sequence-point]\n    u = (u++);\n    ~~^~~~~~~\nplusplus.c:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;22\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;: error: operation on v may be undefined [-Werror=sequence-point]\n    v = v++ + ++v;\n    ~~^~~~~~~~~~~\nplusplus.c:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;22\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;: error: operation on v may be undefined [-Werror=sequence-point]\ncc1: all warnings being treated as errors\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The important part is to know \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/3575350/sequence-points-in-c\u0026quot;\u0026gt;what a sequence point is -- and \u0026lt;em\u0026gt;what is\u0026lt;/em\u0026gt; a sequence point and what \u0026lt;em\u0026gt;isn\u0026apos;t\u0026lt;/em\u0026gt;\u0026lt;/a\u0026gt;. For example the \u0026lt;em\u0026gt;comma operator\u0026lt;/em\u0026gt; is a sequence point, so\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;j = (i ++, ++ i);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;is well-defined, and will increment \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; by one, yielding the old value, discard that value; then at comma operator, settle the side effects; and then increment \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; by one, and the resulting value becomes the value of the expression - i.e. this is just a contrived way to write \u0026lt;code\u0026gt;j = (i += 2)\u0026lt;/code\u0026gt; which is yet again a \u0026quot;clever\u0026quot; way to write\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;i += \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\nj = i;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;However, the \u0026lt;code\u0026gt;,\u0026lt;/code\u0026gt; in function argument lists is \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; a comma operator, and there is no sequence point between evaluations of distinct arguments; instead their evaluations are unsequenced with regard to each other; so the function call \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d %d\\n\u0026quot;\u0026lt;/span\u0026gt;, i++, ++i, i);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;has \u0026lt;em\u0026gt;undefined behaviour\u0026lt;/em\u0026gt; because \u0026lt;strong\u0026gt;there is no sequence point between the evaluations of \u0026lt;code\u0026gt;i++\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;++i\u0026lt;/code\u0026gt; in function arguments\u0026lt;/strong\u0026gt;, and the value of \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; is therefore modified twice, by both \u0026lt;code\u0026gt;i++\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;++i\u0026lt;/code\u0026gt;, between the previous and the next sequence point.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The C standard says that a variable should only be assigned at most once between two sequence points. A semi-colon for instance is a sequence point. \u0026lt;br\u0026gt;\nSo every statement of the form:\u0026lt;br\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;i = i++;\ni = i++ + ++i;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and so on violate that rule. The standard also says that behavior is undefined and not unspecified. Some compilers do detect these and produce some result but this is not per standard.\u0026lt;br\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However, two different variables can be incremented between two sequence points.\u0026lt;br\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(*src++ = *dst++);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The above is a common coding practice while copying/analysing strings.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/29505280/incrementing-array-index-in-c\u0026quot;\u0026gt;https://stackoverflow.com/questions/29505280/incrementing-array-index-in-c\u0026lt;/a\u0026gt; someone asked about a statement like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; k[] = {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;};\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; num;\nnum = k[++i+k[++i]] + k[++i];\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\u0026quot;\u0026lt;/span\u0026gt;, num);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;which prints 7... the OP expected it to print 6.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;++i\u0026lt;/code\u0026gt; increments aren\u0026apos;t guaranteed to all complete before the rest of the calculations. In fact, different compilers will get different results here.  In the example you provided, the first 2 \u0026lt;code\u0026gt;++i\u0026lt;/code\u0026gt; executed, then the values of \u0026lt;code\u0026gt;k[]\u0026lt;/code\u0026gt; were read, then the last \u0026lt;code\u0026gt;++i\u0026lt;/code\u0026gt; then \u0026lt;code\u0026gt;k[]\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;num = k[i+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]+k[i+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;] + k[i+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;];\ni += \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Modern compilers will optimize this very well. In fact, possibly better than the code you originally wrote (assuming it had worked the way you had hoped).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Your question was probably not, \u0026quot;Why are these constructs undefined behavior in C?\u0026quot;.  Your question was probably, \u0026quot;Why did this code (using \u0026lt;code\u0026gt;++\u0026lt;/code\u0026gt;) not give me the value I expected?\u0026quot;, and someone marked your question as a duplicate, and sent you here.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;This\u0026lt;/em\u0026gt; answer tries to answer that question: why did your code not give you the answer you expected, and how can you learn to recognize (and avoid) expressions that will not work as expected.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I assume you\u0026apos;ve heard the basic definition of C\u0026apos;s \u0026lt;code\u0026gt;++\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;--\u0026lt;/code\u0026gt; operators by now, and how the prefix form \u0026lt;code\u0026gt;++x\u0026lt;/code\u0026gt; differs from the postfix form \u0026lt;code\u0026gt;x++\u0026lt;/code\u0026gt;.  But these operators are hard to think about, so to make sure you understood, perhaps you wrote a tiny little test program involving something like\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d %d %d\\n\u0026quot;\u0026lt;/span\u0026gt;, x, ++x, x++);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;But, to your surprise, this program did \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; help you understand  it printed some strange, inexplicable output, suggesting that maybe \u0026lt;code\u0026gt;++\u0026lt;/code\u0026gt; does something completely different, not at all what you thought it did.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Or, perhaps you\u0026apos;re looking at a hard-to-understand expression like\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;;\nx = x++ + ++x;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, x);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Perhaps someone gave you that code as a puzzle.  This code also makes no sense, especially if you run it  and if you compile and run it under two different compilers, you\u0026apos;re likely to get two different answers!  What\u0026apos;s up with that?  Which answer is correct?  (And the answer is that both of them are, or neither of them are.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;As you\u0026apos;ve heard by now, these expressions are \u0026lt;em\u0026gt;undefined\u0026lt;/em\u0026gt;, which means that the C language makes no guarantee about what they\u0026apos;ll do.  This is a strange and unsettling result, because you probably thought that any program you could write, as long as it compiled and ran, would generate a unique, well-defined output.  But in the case of undefined behavior, that\u0026apos;s not so.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;What makes an expression undefined?  Are expressions involving \u0026lt;code\u0026gt;++\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;--\u0026lt;/code\u0026gt; always undefined?  Of course not: these are useful operators, and if you use them properly, they\u0026apos;re perfectly well-defined.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For the expressions we\u0026apos;re talking about, what makes them undefined is when there\u0026apos;s too much going on at once, when we can\u0026apos;t tell what order things will happen in, but when the order matters to the result we\u0026apos;ll get.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Let\u0026apos;s go back to the two examples I\u0026apos;ve used in this answer.  When I wrote\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d %d %d\\n\u0026quot;\u0026lt;/span\u0026gt;, x, ++x, x++);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;the question is, before actually calling \u0026lt;code\u0026gt;printf\u0026lt;/code\u0026gt;, does the compiler compute the value of \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; first, or \u0026lt;code\u0026gt;x++\u0026lt;/code\u0026gt;, or maybe \u0026lt;code\u0026gt;++x\u0026lt;/code\u0026gt;?  But it turns out \u0026lt;em\u0026gt;we don\u0026apos;t know\u0026lt;/em\u0026gt;.  There\u0026apos;s no rule in C which says that the arguments to a function get evaluated left-to-right, or right-to-left, or in some other order.  So we can\u0026apos;t say whether the compiler will do \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; first, then \u0026lt;code\u0026gt;++x\u0026lt;/code\u0026gt;, then \u0026lt;code\u0026gt;x++\u0026lt;/code\u0026gt;, or \u0026lt;code\u0026gt;x++\u0026lt;/code\u0026gt; then \u0026lt;code\u0026gt;++x\u0026lt;/code\u0026gt; then \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;, or some other order.  But the order clearly matters, because depending on which order the compiler uses, we\u0026apos;ll clearly get a different series of numbers printed out.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;What about this crazy expression?\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;x = x++ + ++x;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The problem with this expression is that it contains three different attempts to modify the value of \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;: (1) the \u0026lt;code\u0026gt;x++\u0026lt;/code\u0026gt; part tries to take \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;\u0026apos;s value, add 1, store the new value in \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;, and return the old value; (2) the \u0026lt;code\u0026gt;++x\u0026lt;/code\u0026gt; part tries to take \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;\u0026apos;s value, add 1, store the new value in \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;, and return the new value; and (3) the \u0026lt;code\u0026gt;x =\u0026lt;/code\u0026gt; part tries to assign the sum of the other two back to \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;.  Which of those three attempted assignments will \u0026quot;win\u0026quot;?  Which of the three values will actually determine the final value of \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;?  Again, and perhaps surprisingly, there\u0026apos;s no rule in C to tell us.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;You might imagine that precedence or associativity or left-to-right evaluation tells you what order things happen in, but they do not.  You may not believe me, but please take my word for it, and I\u0026apos;ll say it again: precedence and associativity do not determine every aspect of the evaluation order of an expression in C.  In particular, if within one expression there are multiple different spots where we try to assign a new value to something like \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;, precedence and associativity do \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; tell us which of those attempts happens first, or last, or anything.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;So with all that background and introduction out of the way, if you want to make sure that all your programs are well-defined, which expressions can you write, and which ones can you not write?\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;These expressions are all fine:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;y = x++;\nz = x++ + y++;\nx = x + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\nx = a[i++];\nx = a[i++] + b[j++];\nx[i++] = a[j++] + b[k++];\nx = *p++;\nx = *p++ + *q++;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;These expressions are all undefined:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;x = x++;\nx = x++ + ++x;\ny = x + x++;\na[i] = i++;\na[i++] = i;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d %d %d\\n\u0026quot;\u0026lt;/span\u0026gt;, x, ++x, x++);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;And the last question is, how can you tell which expressions are well-defined, and which expressions are undefined?\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;As I said earlier, the undefined expressions are the ones where there\u0026apos;s too much going at once, where you can\u0026apos;t be sure what order things happen in, and where the order matters:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;If there\u0026apos;s one variable that\u0026apos;s getting modified (assigned to) in two or more different places, how do you know which modification happens first?\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If there\u0026apos;s a variable that\u0026apos;s getting modified in one place, and having its value used in another place, how do you know whether it uses the old value or the new value?\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;As an example of #1, in the expression\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;x = x++ + ++x;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;there are three attempts to modify \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;As an example of #2, in the expression\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;y = x + x++;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;we both use the value of \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;, and modify it.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So that\u0026apos;s the answer: make sure that in any expression you write, each variable is modified at most once, and if a variable is modified, you don\u0026apos;t also attempt to use the value of that variable somewhere else.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;One more thing.  You might be wondering how to \u0026quot;fix\u0026quot; the undefined expressions I started this answer by presenting.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In the case of \u0026lt;code\u0026gt;printf(\u0026quot;%d %d %d\\n\u0026quot;, x, ++x, x++);\u0026lt;/code\u0026gt;, it\u0026apos;s easy  just write it as three separate \u0026lt;code\u0026gt;printf\u0026lt;/code\u0026gt; calls:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d \u0026quot;\u0026lt;/span\u0026gt;, x);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d \u0026quot;\u0026lt;/span\u0026gt;, ++x);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, x++);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now the behavior is perfectly well defined, and you\u0026apos;ll get sensible results.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In the case of \u0026lt;code\u0026gt;x = x++ + ++x\u0026lt;/code\u0026gt;, on the other hand, there\u0026apos;s no way to fix it.  There\u0026apos;s no way to write it so that it has guaranteed behavior matching your expectations  but that\u0026apos;s okay, because you would never write an expression like \u0026lt;code\u0026gt;x = x++ + ++x\u0026lt;/code\u0026gt; in a real program anyway.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A good explanation about what happens in this kind of computation is provided in the document \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1188.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;n1188\u0026lt;/a\u0026gt; from \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;the ISO W14 site\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I explain the ideas.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The main rule from the standard ISO 9899 that applies in this situation is  6.5p2.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression.   Furthermore, the prior value shall be read only to determine the value to be stored.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;The sequence points in an expression like \u0026lt;code\u0026gt;i=i++\u0026lt;/code\u0026gt; are before \u0026lt;code\u0026gt;i=\u0026lt;/code\u0026gt; and after \u0026lt;code\u0026gt;i++\u0026lt;/code\u0026gt;.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In the paper that I quoted above it is explained that you can figure out the program as being formed by small boxes, each box containing the instructions between 2 consecutive sequence points.  The sequence points are defined in annex C of the standard, in the case of \u0026lt;code\u0026gt;i=i++\u0026lt;/code\u0026gt; there are 2 sequence points that delimit a full-expression.  Such an expression is syntactically equivalent with an entry of \u0026lt;code\u0026gt;expression-statement\u0026lt;/code\u0026gt; in the Backus-Naur form of the grammar (a grammar is provided in annex A of the Standard).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So the order of instructions inside a box has no clear order.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;i=i++\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;can be interpreted as\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;tmp = i\ni=i+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\ni = tmp\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;or as\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;tmp = i\ni = tmp\ni=i+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;because both all these forms to interpret the code \u0026lt;code\u0026gt;i=i++\u0026lt;/code\u0026gt; are valid and because both generate different answers, the behavior is undefined.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So a sequence point can be seen by the beginning and the end of each box that composes the program [the boxes are atomic units in C] and inside a box the order of instructions is not defined in all cases.  Changing that order one can change the result sometimes.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;EDIT:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Other good source for explaining such ambiguities are the entries from \u0026lt;a href=\u0026quot;http://c-faq.com/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;c-faq\u0026lt;/a\u0026gt; site (also published \u0026lt;a href=\u0026quot;https://rads.stackoverflow.com/amzn/click/com/0201845199\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;as a book\u0026lt;/a\u0026gt;) , namely \u0026lt;a href=\u0026quot;http://c-faq.com/expr/seqpoints.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;http://c-faq.com/expr/evalorder4.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;http://c-faq.com/expr/confused.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt; .\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The reason is that the program is running undefined behavior. The problem lies in the evaluation order, because there is no sequence points required according to C++98 standard ( no operations is sequenced before or after another according to C++11 terminology).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;However if you stick to one compiler, you will find the behavior persistent, as long as you don\u0026apos;t add function calls or pointers, which would make the behavior more messy.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Using \u0026lt;a href=\u0026quot;https://nuwen.net/mingw.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Nuwen MinGW\u0026lt;/a\u0026gt; 15 GCC 7.1 you will get:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; ** argv)\u0026lt;/span\u0026gt;\n {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    i = i++ + ++i;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, i); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 2\u0026lt;/span\u0026gt;\n\n    i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    i = (i++);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, i); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//1\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;volatile\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; u = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    u = u++ + ++u;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, u); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 2\u0026lt;/span\u0026gt;\n\n    u = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    u = (u++);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, u); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//1\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;register\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; v = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    v = v++ + ++v;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, v); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//2\u0026lt;/span\u0026gt;\n }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;How does GCC work? it evaluates sub expressions at a left to right order for the right hand side (RHS) , then assigns the value to the left hand side (LHS) . This is exactly how Java and C# behave and define their standards. (Yes, the equivalent software in Java and C# has defined behaviors). It evaluate each sub expression one by one in the RHS Statement in a left to right order; for each sub expression: the ++c (pre-increment)  is evaluated first then the value c is used for the operation, then the post increment c++).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;according to \u0026lt;a href=\u0026quot;http://helpcentreonline.com/article/operator_console_gcc.pdf\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;GCC C++: Operators\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;In GCC C++,  the precedence of the operators controls the order in\nwhich the individual operators are evaluated\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;the equivalent code in defined behavior C++ as   GCC understands:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; ** argv)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//i = i++ + ++i;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; r;\n    r=i;\n    i++;\n    ++i;\n    r+=i;\n    i=r;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, i); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 2\u0026lt;/span\u0026gt;\n\n    i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//i = (i++);\u0026lt;/span\u0026gt;\n    r=i;\n    i++;\n    i=r;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, i); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 1\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;volatile\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; u = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//u = u++ + ++u;\u0026lt;/span\u0026gt;\n    r=u;\n    u++;\n    ++u;\n    r+=u;\n    u=r;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, u); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 2\u0026lt;/span\u0026gt;\n\n    u = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//u = (u++);\u0026lt;/span\u0026gt;\n    r=u;\n    u++;\n    u=r;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, u); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 1\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;register\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; v = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//v = v++ + ++v;\u0026lt;/span\u0026gt;\n    r=v;\n    v++;\n    ++v;\n    r+=v;\n    v=r;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, v); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//2\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Then we go to \u0026lt;a href=\u0026quot;https://www.visualstudio.com/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Visual Studio\u0026lt;/a\u0026gt;. Visual Studio 2015, you get:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; ** argv)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    i = i++ + ++i;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, i); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 3\u0026lt;/span\u0026gt;\n\n    i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    i = (i++);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, i); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 2 \u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;volatile\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; u = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    u = u++ + ++u;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, u); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 3\u0026lt;/span\u0026gt;\n\n    u = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    u = (u++);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, u); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 2 \u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;register\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; v = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    v = v++ + ++v;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, v); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 3 \u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;How does Visual Studio work, it takes another approach, it evaluates all pre-increments expressions in first pass, then uses variables values in the operations in second pass,  assign from RHS to LHS in third pass, then at last pass it evaluates all the post-increment expressions in one pass.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So the equivalent in defined behavior C++ as Visual C++ understands:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; ** argv)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; r;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//i = i++ + ++i;\u0026lt;/span\u0026gt;\n    ++i;\n    r = i + i;\n    i = r;\n    i++;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, i); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 3\u0026lt;/span\u0026gt;\n\n    i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//i = (i++);\u0026lt;/span\u0026gt;\n    r = i;\n    i = r;\n    i++;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, i); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 2 \u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;volatile\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; u = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//u = u++ + ++u;\u0026lt;/span\u0026gt;\n    ++u;\n    r = u + u;\n    u = r;\n    u++;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, u); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 3\u0026lt;/span\u0026gt;\n\n    u = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//u = (u++);\u0026lt;/span\u0026gt;\n    r = u;\n    u = r;\n    u++;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, u); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 2 \u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;register\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; v = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//v = v++ + ++v;\u0026lt;/span\u0026gt;\n    ++v;\n    r = v + v;\n    v = r;\n    v++;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, v); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 3 \u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;as Visual Studio documentation states at \u0026lt;a href=\u0026quot;https://msdn.microsoft.com/en-us/library/2bxt6kc4.aspx\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Precedence and Order of Evaluation\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Where several operators appear together, they have equal precedence and are evaluated according to their associativity. The operators in the table are described in the sections beginning with Postfix Operators.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    "],"comment":["\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Jarett, nope, just needed some pointers to \u0026quot;sequence points\u0026quot;. While working I found a piece of code with i = i++, I thougth \u0026quot;This isn\u0026apos;t modifying the value of i\u0026quot;. I tested and I wondered why.  Since, i\u0026apos;ve removed this statment and replaced it by i++;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/44988/pix\u0026quot; title=\u0026quot;9,465 reputation\u0026quot; class=\u0026quot;comment-user owner\u0026quot;\u0026gt;PiX\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment760510_949433\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-06-04 18:24:46Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 4, 2009 at 18:24\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I think it\u0026apos;s interesting that everyone ALWAYS assumes that questions like this are asked because the asker wants to USE the construct in question. My first assumption was that PiX knows that these are bad, but is curious why the behave they way the do on whataver compiler s/he was using...  And yeah, what unWind said... it\u0026apos;s undefined, it could do anything... including JCF (Jump and Catch Fire)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/53491/brian-postow\u0026quot; title=\u0026quot;10,925 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Brian Postow\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment2946540_949433\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2010-05-24 13:41:10Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;May 24, 2010 at 13:41\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I\u0026apos;m curious: Why don\u0026apos;t compilers seem to warn on constructs such as \u0026quot;u = u++ + ++u;\u0026quot; if the result is undefined?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1317564/learn-opengl-es\u0026quot; title=\u0026quot;4,537 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Learn OpenGL ES\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment16848338_949433\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-09-20 16:23:44Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 20, 2012 at 16:23\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026lt;code\u0026gt;(i++)\u0026lt;/code\u0026gt; still evaluates to 1, regardless of parentheses\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2478565/drew-mcgowen\u0026quot; title=\u0026quot;11,186 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Drew McGowen\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment25879073_949433\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-07-19 14:55:42Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 19, 2013 at 14:55\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Whatever \u0026lt;code\u0026gt;i = (i++);\u0026lt;/code\u0026gt; was intended to do, there is certainly a clearer way to write it. That would be true even if it were well defined. Even in Java, which defines the behavior of \u0026lt;code\u0026gt;i = (i++);\u0026lt;/code\u0026gt;, it\u0026apos;s still bad code. Just write \u0026lt;code\u0026gt;i++;\u0026lt;/code\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/827263/keith-thompson\u0026quot; title=\u0026quot;243,248 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Keith Thompson\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment26783132_949433\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-08-15 21:07:17Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Aug 15, 2013 at 21:07\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@PiX: Things are undefined for a number of possible reasons. These include: there is no clear \u0026quot;right result\u0026quot;, different machine architectures would strongly favour different results, existing practice is not consistent, or beyond the scope of the standard (e.g. what filenames are valid).\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/67392/richard\u0026quot; title=\u0026quot;103,825 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Richard\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment757871_949443\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2009-06-04 10:57:18Z, License: CC BY-SA 2.5\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 4, 2009 at 10:57\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Just to confuse everyone, some such examples are now well-defined in C11, e.g. \u0026lt;code\u0026gt;i = ++i + 1;\u0026lt;/code\u0026gt; .\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1505939/m-m\u0026quot; title=\u0026quot;135,063 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;M.M\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment38245387_949443\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-07-10 05:51:00Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 10, 2014 at 5:51\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Reading the Standard and the published rationale, It\u0026apos;s clear why the concept of UB exists.  The Standard was never intended to fully describe everything a C implementation must do to be suitable for any particular purpose (see the discussion of the \u0026quot;One Program\u0026quot; rule), but instead relies upon implementors\u0026apos; judgment and desire to produce useful quality implementations.  A quality implementation suitable for low-level systems programming will need to define the behavior of actions that wouldn\u0026apos;t be needed in high-end number crunching.applications.  Rather than try to complicate the Standard...\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/363751/supercat\u0026quot; title=\u0026quot;73,697 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;supercat\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment82685464_949443\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-12-17 23:12:29Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 17, 2017 at 23:12\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;...by getting into extreme detail about which corner cases are or are not defined, the authors of the Standard recognized that implementors should be better paced to judge which kinds of behaviors will be needed by the kinds of programs they\u0026apos;re expected to support.  Hyper-modernist compilers pretend that making certain actions UB was intended to imply that no quality program should need them, but the Standard and rationale are inconsistent with such a supposed intent.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/363751/supercat\u0026quot; title=\u0026quot;73,697 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;supercat\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment82685504_949443\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-12-17 23:15:59Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 17, 2017 at 23:15\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@jrh: I wrote that answer before I\u0026apos;d realized how out of hand the hyper-modernist philosophy had gotten.  What irks me is the progression from \u0026quot;We don\u0026apos;t need to officially recognize this behavior because the platforms where it\u0026apos;s needed can support it anyway\u0026quot; to \u0026quot;We can remove this behavior without providing a usable replacement because it was never recognized and thus any code needing it was broken\u0026quot;.  Many behaviors should have been deprecated long ago \u0026lt;i\u0026gt;in favor of replacements that were in every way better\u0026lt;/i\u0026gt;, but that would have required acknowledging their legitimacy.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/363751/supercat\u0026quot; title=\u0026quot;73,697 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;supercat\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment83140123_949443\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-01-03 18:08:20Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 3, 2018 at 18:08\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Would the above imply that \u0026apos;i=i=5;\u0026quot; would be Undefined Behavior?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/363751/supercat\u0026quot; title=\u0026quot;73,697 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;supercat\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment10084875_949508\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2011-11-20 21:41:25Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 20, 2011 at 21:41\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@supercat as far as I know \u0026lt;code\u0026gt;i=i=5\u0026lt;/code\u0026gt; is also undefined behavior\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2003898/dhein\u0026quot; title=\u0026quot;6,163 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;dhein\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment28007333_949508\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-09-23 15:39:50Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 23, 2013 at 15:39\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@Zaibis: The rationale I like to use for most places rule applies that in theory a mutli-processor platform could implement something like \u0026lt;code\u0026gt;A=B=5;\u0026lt;/code\u0026gt; as \u0026quot;Write-lock A; Write-Lock B; Store 5 to A; store 5 to B; Unlock B; Unock A;\u0026quot;, and a statement like \u0026lt;code\u0026gt;C=A+B;\u0026lt;/code\u0026gt; as \u0026quot;Read-lock A; Read-lock B; Compute A+B; Unlock A and B; Write-lock C; Store result; Unlock C;\u0026quot;.  That would ensure that if one thread did \u0026lt;code\u0026gt;A=B=5;\u0026lt;/code\u0026gt; while another did \u0026lt;code\u0026gt;C=A+B;\u0026lt;/code\u0026gt; the latter thread would either see both writes as having taken place or neither.  Potentially a useful guarantee.  If one thread did \u0026lt;code\u0026gt;I=I=5;\u0026lt;/code\u0026gt;, however, ...\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/363751/supercat\u0026quot; title=\u0026quot;73,697 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;supercat\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment28008691_949508\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-09-23 16:18:26Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 23, 2013 at 16:18\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;... and the compiler didn\u0026apos;t notice that both writes were to the same location (if one or both lvalues involve pointers, that may be hard to determine), the generated code could deadlock. I don\u0026apos;t think any real-world implementations implement such locking as part of their normal behavior, but it would be permissible under the standard, and if hardware could implement such behaviors cheaply it might be useful.  On today\u0026apos;s hardware such behavior would be way too expensive to implement as a default, but that doesn\u0026apos;t mean it would always be thus.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/363751/supercat\u0026quot; title=\u0026quot;73,697 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;supercat\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment28008738_949508\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-09-23 16:19:57Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 23, 2013 at 16:19\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@supercat but wouldn\u0026apos;t the sequence point access rule of c99 alone be enough to declare it as undefined behavior? So it doesn\u0026apos;t matter what technically the hardware could implement?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2003898/dhein\u0026quot; title=\u0026quot;6,163 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;dhein\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment28009424_949508\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2013-09-23 16:40:45Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 23, 2013 at 16:40\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;how do i get the machine code? I use Dev C++, and i played around with \u0026apos;Code Generation\u0026apos; option in compiler settings, but go no extra file output or any console output\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1114457/bad-keypoints\u0026quot; title=\u0026quot;1,362 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;bad_keypoints\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment16928689_2897275\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-09-24 14:11:42Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 24, 2012 at 14:11\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@ronnieaka \u0026lt;code\u0026gt;gcc evil.c -c -o evil.bin\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;gdb evil.bin\u0026lt;/code\u0026gt;  \u0026lt;code\u0026gt;disassemble evil\u0026lt;/code\u0026gt;, or whatever the Windows equivalents of those are :)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/13992/badp\u0026quot; title=\u0026quot;11,286 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;badp\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment16934976_2897275\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2012-09-24 18:20:05Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 24, 2012 at 18:20\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;This answer does not really address the question of \u0026lt;code\u0026gt;Why are these constructs undefined behavior?\u0026lt;/code\u0026gt;.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1708801/shafik-yaghmour\u0026quot; title=\u0026quot;148,993 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Shafik Yaghmour\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment37949768_2897275\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2014-07-01 14:00:21Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 1, 2014 at 14:00\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;As an aside, it\u0026apos;ll be easier to compile to assembly (with \u0026lt;code\u0026gt;gcc -S evil.c\u0026lt;/code\u0026gt;), which is all that\u0026apos;s needed here. Assembling then disassembling it is just a roundabout way of doing it.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1968462/kat\u0026quot; title=\u0026quot;4,605 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Kat\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment51270000_2897275\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-07-27 20:32:11Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 27, 2015 at 20:32\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;For the record, if for whatever reason you\u0026apos;re wondering what a given construct does -- and \u0026lt;i\u0026gt;especially\u0026lt;/i\u0026gt; if there\u0026apos;s any suspicion that it might be undefined behavior -- the age-old advice of \u0026quot;just try it with your compiler and see\u0026quot; is potentially quite perilous.  You will learn, at best, what it does \u0026lt;i\u0026gt;under this version of your compiler, under these circumstances, today\u0026lt;/i\u0026gt;.  You will \u0026lt;i\u0026gt;not\u0026lt;/i\u0026gt; learn much if anything about what it\u0026apos;s guaranteed to do.  In general, \u0026quot;just try it with your compiler\u0026quot; leads to nonportable programs that work only with your compiler.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3923896/steve-summit\u0026quot; title=\u0026quot;38,556 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Steve Summit\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment58584601_2897275\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-02-16 21:26:07Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Feb 16, 2016 at 21:26\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;A rather nasty gotcha with regard to Undefined Behavior is that while it \u0026lt;i\u0026gt;used\u0026lt;/i\u0026gt; to be safe on 99.9% of compilers to use \u0026lt;code\u0026gt;*p=(*q)++;\u0026lt;/code\u0026gt; to mean \u0026lt;code\u0026gt;if (p!=q) *p=(*q)++; else *p= __ARBITRARY_VALUE;\u0026lt;/code\u0026gt; that is no longer the case.  Hyper-modern C would require writing something like the latter formulation (though there\u0026apos;s no standard way of indicating code doesn\u0026apos;t care what\u0026apos;s in \u0026lt;code\u0026gt;*p\u0026lt;/code\u0026gt;) to achieve the level of efficiency compilers used to provide with the former (the \u0026lt;code\u0026gt;else\u0026lt;/code\u0026gt; clause is necessary in order to let the compiler optimize out the \u0026lt;code\u0026gt;if\u0026lt;/code\u0026gt; which some newer compilers would require).\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/363751/supercat\u0026quot; title=\u0026quot;73,697 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;supercat\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment50297290_30914692\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2015-06-30 16:14:39Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jun 30, 2015 at 16:14\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@supercat I now believe that any compiler that\u0026apos;s \u0026quot;smart\u0026quot; enough to perform that sort of optimization must also be smart enough to peek at \u0026lt;code\u0026gt;assert\u0026lt;/code\u0026gt; statements, so that the programmer can precede the line in question with a simple \u0026lt;code\u0026gt;assert(p != q)\u0026lt;/code\u0026gt;.  (Of course, taking that course would also require rewriting \u0026lt;code\u0026gt;\u0026amp;lt;assert.h\u0026amp;gt;\u0026lt;/code\u0026gt; to not delete assertions outright in non-debug versions, but rather, turn them into something like \u0026lt;code\u0026gt;__builtin_assert_disabled()\u0026lt;/code\u0026gt; that the compiler proper can see, and then not emit code for.)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3923896/steve-summit\u0026quot; title=\u0026quot;38,556 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Steve Summit\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment102532158_30914692\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2019-09-23 18:26:18Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Sep 23, 2019 at 18:26\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 5 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026lt;i\u0026gt;what we\u0026apos;re really saying is \u0026quot;add 1 to i, and assign the result back to i, and assign the result back to i\u0026quot;.\u0026lt;/i\u0026gt; --- I think there is one \u0026quot;\u0026lt;i\u0026gt;and assign the result back to i\u0026lt;/i\u0026gt;\u0026quot; too much.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/12139179/roberts-supports-monica-cellio\u0026quot; title=\u0026quot;13,801 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;RobertS supports Monica Cellio\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment110951551_30914692\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2020-07-05 13:42:19Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 5, 2020 at 13:42\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@RobertSsupportsMonicaCellio It\u0026apos;s admittedly a bit confusing the way it\u0026apos;s written.  Read it as \u0026quot;Add 1 to the value fetched from \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt;, assign the result back to \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt;, and assign the result back to \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt;\u0026quot;.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3923896/steve-summit\u0026quot; title=\u0026quot;38,556 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Steve Summit\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment110984228_30914692\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2020-07-06 15:55:54Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 6, 2020 at 15:55\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026quot;C, of course, has a handy shortcut: i++\u0026quot;   Haha, nice. Or worst case, i += 1.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/618649/craig-tullis\u0026quot; title=\u0026quot;9,179 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Craig Tullis\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment115775832_30914692\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2020-12-28 23:44:03Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Dec 28, 2020 at 23:44\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;This sequence \u0026lt;code\u0026gt;int a = 10, b = 20, c = 30; printf(\u0026quot;a=%d b=%d c=%d\\n\u0026quot;, (a = a + b + c), (b = b + b), (c = c + c));\u0026lt;/code\u0026gt; appears to give stable behavior (right-to-left argument evaluation in gcc v7.3.0; result \u0026quot;a=110 b=40 c=60\u0026quot;). Is it because the assignments are considered as \u0026apos;full-statements\u0026apos; and thus introduce a sequence point? Shouldn\u0026apos;t that result in left-to-right argument/statement evaluation? Or, is it just manifestation of undefined behavior?\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2258526/kavadias\u0026quot; title=\u0026quot;1,017 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;kavadias\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment92640336_34536741\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-10-17 20:20:57Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 17, 2018 at 20:20\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@kavadias That printf statement involves undefined behaviour, for the same reason explained above. You are writing \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt; in 3rd \u0026amp;amp; 4th arguments respectively and reading in 2nd argument. But there\u0026apos;s no sequence between these expressions (2nd, 3rd, \u0026amp;amp; 4th args). gcc/clang has an option \u0026lt;code\u0026gt;-Wsequence-point\u0026lt;/code\u0026gt; which can help find these, too.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1275169/p-p\u0026quot; title=\u0026quot;112,815 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;P.P\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment92653844_34536741\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2018-10-18 08:40:02Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 18, 2018 at 8:40\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Of course it doesn\u0026apos;t apply to different variables within one expression. It would be a total design failure if it did! All you need in the 2nd example is for both to be incremented between the statement ending and the next one beginning, and that\u0026apos;s guaranteed, precisely because of the concept of sequence points at the centre of all this.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2757035/underscore-d\u0026quot; title=\u0026quot;5,910 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;underscore_d\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment64336861_25787635\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2016-07-19 18:55:58Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jul 19, 2016 at 18:55\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 3 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;How this answer added new to the existing answers? Also the explanations for \u0026lt;code\u0026gt;i=i++\u0026lt;/code\u0026gt; is very similar to \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/31083924/2455888\u0026quot;\u0026gt;this answer\u0026lt;/a\u0026gt;.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2455888/haccks\u0026quot; title=\u0026quot;101,189 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;haccks\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment81890064_46731645\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-11-24 07:00:15Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 24, 2017 at 7:00\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 2 times\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@haccks I did not read the other answers.  I wanted to explain in my own language what I learned from the mentioned document from the official site of ISO 9899 \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1188.pdf\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;open-std.org/jtc1/sc22/wg14/www/docs/n1188.pdf\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1419272/alinsoar\u0026quot; title=\u0026quot;14,814 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;alinsoar\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment81900615_46731645\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-11-24 12:14:44Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Nov 24, 2017 at 12:14\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@haccks this answer is ok besides the fact it\u0026apos;s a copy of your answer, but I would ask instead, what all other answers are doing here and why they have so much rep while missing the main point of question, that\u0026apos;s explaining the details of the UB in examples.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/2170898/soup-endless\u0026quot; title=\u0026quot;308 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Soup  Endless\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment117429010_46731645\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2021-03-01 14:16:06Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 1, 2021 at 14:16\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;@SoupEndless There are many answers because this is a canonical question for a number of similar (but not direct) duplicates. Without the overhead of creating different canonical posts for minor variants of the same question, often others post answers \u0026lt;i\u0026gt;much later\u0026lt;/i\u0026gt; (often years later!) to make a question an ideal candidate for dup hammers. That\u0026apos;s what happened here. It\u0026apos;s pointless to repeat the same answer (especially after a few years, it\u0026apos;s been answered!). So the latter answerers didn\u0026apos;t really \u0026quot;miss the point\u0026quot;. This is just how SO works.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/1275169/p-p\u0026quot; title=\u0026quot;112,815 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;P.P\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment117844544_46731645\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2021-03-16 21:46:45Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Mar 16, 2021 at 21:46\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;I\u0026apos;ve edited the question to add the UB in evaluation of function arguments, as this question is often used as a duplicate for that. (The last example)\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/918959/antti-haapala-%d0%a1%d0%bb%d0%b0%d0%b2%d0%b0-%d0%a3%d0%ba%d1%80%d0%b0%d1%97%d0%bd%d1%96\u0026quot; title=\u0026quot;124,211 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Antti Haapala -- Слава Україні\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment80672249_44478826\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-10-21 10:46:50Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 21, 2017 at 10:46\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;Also the question is about \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/tagged/c\u0026quot;\u0026gt;c\u0026lt;/a\u0026gt; now, not C++\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/918959/antti-haapala-%d0%a1%d0%bb%d0%b0%d0%b2%d0%b0-%d0%a3%d0%ba%d1%80%d0%b0%d1%97%d0%bd%d1%96\u0026quot; title=\u0026quot;124,211 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Antti Haapala -- Слава Україні\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment80672263_44478826\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2017-10-21 10:47:24Z, License: CC BY-SA 3.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Oct 21, 2017 at 10:47\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        ","\n            \u0026lt;div class=\u0026quot;comment-body js-comment-edit-hide\u0026quot;\u0026gt;\n                \n                \u0026lt;span class=\u0026quot;comment-copy\u0026quot;\u0026gt;\u0026lt;i\u0026gt;However if you stick to one compiler, you will find the behavior persistent.\u0026lt;/i\u0026gt; Well, no, not necessarily.  If you, for example, change optimization flags, the compiler may quite easily end up emitting code which makes the undefined behavior behave differently.  Also if you make seemingly-unrelated changes to nearby code.\u0026lt;/span\u0026gt;\n                \n              \u0026lt;div class=\u0026quot;d-inline-flex ai-center\u0026quot;\u0026gt;\n\u0026amp;nbsp;\u0026lt;a href=\u0026quot;/users/3923896/steve-summit\u0026quot; title=\u0026quot;38,556 reputation\u0026quot; class=\u0026quot;comment-user\u0026quot;\u0026gt;Steve Summit\u0026lt;/a\u0026gt;\n                \u0026lt;/div\u0026gt;\n                \u0026lt;span class=\u0026quot;comment-date\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;comment-link\u0026quot; href=\u0026quot;#comment116438201_44478826\u0026quot;\u0026gt;\u0026lt;span title=\u0026quot;2021-01-23 05:07:58Z, License: CC BY-SA 4.0\u0026quot; class=\u0026quot;relativetime-clean\u0026quot;\u0026gt;Jan 23, 2021 at 5:07\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\n                        \u0026lt;span title=\u0026quot;this comment was edited 1 time\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;va-text-bottom o50 svg-icon iconPencilSm\u0026quot; width=\u0026quot;14\u0026quot; height=\u0026quot;14\u0026quot; viewBox=\u0026quot;0 0 14 14\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/span\u0026gt;\n            \u0026lt;/div\u0026gt;\n        "],"id":81,"title":"Why are these constructs using pre and post-increment undefined behavior?","content":"\n                \n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n   i = i++ + ++i;\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, i); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 3\u0026lt;/span\u0026gt;\n\n   i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n   i = (i++);\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, i); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 2 Should be 1, no ?\u0026lt;/span\u0026gt;\n\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;volatile\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; u = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n   u = u++ + ++u;\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, u); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 1\u0026lt;/span\u0026gt;\n\n   u = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n   u = (u++);\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, u); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 2 Should also be one, no ?\u0026lt;/span\u0026gt;\n\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;register\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; v = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n   v = v++ + ++v;\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, v); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 3 (Should be the same as u ?)\u0026lt;/span\u0026gt;\n\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; w = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d %d\\n\u0026quot;\u0026lt;/span\u0026gt;, ++w, w); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// shouldn\u0026apos;t this print 1 1\u0026lt;/span\u0026gt;\n\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;] = { \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt; }, y = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n   x[y] = y ++;\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d %d\\n\u0026quot;\u0026lt;/span\u0026gt;, x[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;], x[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// shouldn\u0026apos;t this print 0 8? or 5 0?\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","slug":"why-are-these-constructs-using-pre-and-post-increment-undefined-behavior-1657384520109","postType":"QUESTION","createdAt":"2022-07-09T16:35:20.000Z","updatedAt":"2022-07-09T16:35:20.000Z","tags":[{"id":298,"name":"increment","slug":"increment","createdAt":"2022-07-09T16:35:20.000Z","updatedAt":"2022-07-09T16:35:20.000Z","Questions_Tags":{"questionId":81,"tagId":298}},{"id":299,"name":"operator-precedence","slug":"operator-precedence","createdAt":"2022-07-09T16:35:20.000Z","updatedAt":"2022-07-09T16:35:20.000Z","Questions_Tags":{"questionId":81,"tagId":299}},{"id":301,"name":"sequence-points","slug":"sequence-points","createdAt":"2022-07-09T16:35:20.000Z","updatedAt":"2022-07-09T16:35:20.000Z","Questions_Tags":{"questionId":81,"tagId":301}}]}},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"why-are-these-constructs-using-pre-and-post-increment-undefined-behavior-1657384520109"},"buildId":"4Y8KGE-c2lolBeBmcum_I","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>