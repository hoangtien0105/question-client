<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>Undefined, unspecified and implementation-defined behavior | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="What is undefined behavior (UB) in C and C++?  What about unspecified behavior and implementation-defined behavior?  What is the difference between them?
    "/><meta property="og:title" content="Undefined, unspecified and implementation-defined behavior | Solutions Checker"/><meta property="og:description" content="What is undefined behavior (UB) in C and C++?  What about unspecified behavior and implementation-defined behavior?  What is the difference between them?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Undefined, unspecified and implementation-defined behavior","text":"What is undefined behavior (UB) in C and C++?  What about unspecified behavior and implementation-defined behavior?  What is the difference between them?\n    ","answerCount":9,"upVoteCount":500,"suggestedAnswer":[{"text":"Undefined behavior is one of those aspects of the C and C++ language that can be surprising to programmers coming from other languages (other languages try to hide it better). Basically,  it is possible to write C++ programs that do not behave in a predictable way, even though many C++ compilers will not report any errors in the program!\nLet&apos;s look at a classic example:\n#include &lt;iostream&gt;\n\nint main()\n{\n    char* p = &quot;hello!\\n&quot;;   // yes I know, deprecated conversion\n    p[0] = &apos;y&apos;;\n    p[5] = &apos;w&apos;;\n    std::cout &lt;&lt; p;\n}\n\nThe variable p points to the string literal &quot;hello!\\n&quot;, and the two assignments below try to modify that string literal. What does this program do? According to section 2.14.5 paragraph 11 of the C++ standard, it invokes undefined behavior:\n\nThe effect of attempting to modify a string literal is undefined.\n\nI can hear people screaming &quot;But wait, I can compile this no problem and get the output yellow&quot; or &quot;What do you mean undefined, string literals are stored in read-only memory, so the first assignment attempt results in a core dump&quot;. This is exactly the problem with undefined behavior. Basically, the standard allows anything to happen once you invoke undefined behavior (even nasal demons). If there is a &quot;correct&quot; behavior according to your mental model of the language, that model is simply wrong; The C++ standard has the only vote, period.\nOther examples of undefined behavior include accessing an array beyond its bounds, dereferencing the null pointer, accessing objects after their lifetime ended or writing allegedly clever expressions like i++ + ++i.\nSection 1.9 of the C++ standard also mentions undefined behavior&apos;s two less dangerous brothers, unspecified behavior and implementation-defined behavior:\n\nThe semantic descriptions in this International Standard define a parameterized nondeterministic abstract machine.\nCertain aspects and operations of the abstract machine are described in this International Standard as implementation-defined (for example, sizeof(int)). These constitute the parameters of the abstract machine. Each implementation shall include documentation describing its characteristics and behavior in these respects.\nCertain other aspects and operations of the abstract machine are described in this International Standard as unspecified (for example, order of evaluation of arguments to a function). Where possible, this International Standard defines a set of allowable behaviors. These define the nondeterministic aspects of the abstract machine.\nCertain other operations are described in this International Standard as undefined (for example, the  effect of dereferencing the null pointer). [ Note: this International Standard imposes no requirements on the behavior of programs that contain undefined behavior. end note ]\n\nSpecifically, section 1.3.24 states:\n\nPermissible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).\n\nWhat can you do to avoid running into undefined behavior? Basically, you have to read good C++ books by authors who know what they&apos;re talking about. Avoid internet tutorials. Avoid bullschildt.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"Well, this is basically a straight copy-paste from the standard\n\n3.4.1 1 implementation-defined behavior unspecified behavior where\neach implementation documents how the\nchoice is made\n2 EXAMPLE An example of\nimplementation-defined behavior is the\npropagation of the high-order bit when\na signed integer is shifted right.\n3.4.3 1 undefined behavior behavior, upon use of a nonportable or erroneous\nprogram construct or of erroneous\ndata, for which this International\nStandard imposes no requirements\n2\nNOTE Possible undefined behavior\nranges from ignoring the situation\ncompletely with unpredictable results,\nto behaving during translation or\nprogram execution in a documented\nmanner characteristic of the\nenvironment (with or without the\nissuance of a diagnostic message), to\nterminating a translation or execution\n(with the issuance of a diagnostic\nmessage).\n3 EXAMPLE An example of\nundefined behavior is the behavior on\ninteger overflow.\n3.4.4 1 unspecified behavior use of an unspecified value, or other behavior\nwhere this International Standard\nprovides two or more possibilities and\nimposes no further requirements on\nwhich is chosen in any instance\n2\nEXAMPLE An example of unspecified\nbehavior is the order in which the\narguments to a function are evaluated.\n\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"Maybe easy wording could be easier for understanding than the rigorous definition of the standards.\nimplementation-defined behavior\nThe language says that we have data-types. The compiler vendors specify what sizes shall they use, and provide a documentation of what they did.\nundefined behavior\nYou are doing something wrong. For example, you have a very large value in an int that doesn&apos;t fit in char. How do you put that value in char? actually there is no way! Anything could happen, but the most sensible thing would be to take the first byte of that int and put it in char. It is just wrong to do that to assign the first byte, but thats what happens under the hood.\nunspecified behavior\nWhich function of these two is executed first?\nvoid fun(int n, int m);\n\nint fun1() {\n    std::cout &lt;&lt; &quot;fun1&quot;;\n    return 1;\n}\nint fun2() {\n    std::cout &lt;&lt; &quot;fun2&quot;;\n    return 2;\n}\n...\nfun(fun1(), fun2()); // which one is executed first?\n\nThe language doesn&apos;t specify the evaluation, left to right or right to left! So an unspecified behavior may or mayn&apos;t result in an undefined behavior, but certainly your program should not produce an unspecified behavior.\n\n@eSKay I think your question is worth editing the answer to clarify more :)\n\nfor fun(fun1(), fun2()); isn&apos;t the behaviour &quot;implementation defined&quot;? The compiler has to choose one or the other course, after all?\n\nThe difference between implementation-defined and unspecified, is that the compiler is supposed to pick a behavior in the first case but it doesn&apos;t have to in the second case. For example, an implementation must have one and only one definition of sizeof(int). So, it can&apos;t say that sizeof(int) is 4 for some portion of the program and 8 for others. Unlike unspecified behavior, where the compiler can say OK I am gonna evaluate these arguments left-to-right and the next function&apos;s arguments are evaluated right-to-left. It can happen in the same program, that&apos;s why it is called unspecified. In fact, C++ could have been made easier if some of the unspecified behaviors were specified. Take a look here at Dr. Stroustrup&apos;s answer for that:\n\nIt is claimed that the difference between what can be produced giving the compiler this freedom and requiring &quot;ordinary left-to-right evaluation&quot; can be significant. I&apos;m unconvinced, but with innumerable compilers &quot;out there&quot; taking advantage of the freedom and some people passionately defending that freedom, a change would be difficult and could take decades to penetrate to the distant corners of the C and C++ worlds. I am disappointed that not all compilers warn against code such as ++i+i++. Similarly, the order of evaluation of arguments is unspecified.\nIMO far too many &quot;things&quot; are left undefined, unspecified, that&apos;s easy to say and even to give examples of, but hard to fix. It should also be noted that it is not all that difficult to avoid most of the problems and produce portable code.\n\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"From the official C Rationale Document\n\n\n  The terms unspecified behavior, undefined behavior, and implementation-defined behavior are used to categorize the result of writing programs whose properties the Standard does not, or cannot, completely describe.  The goal of adopting this categorization is to allow a certain variety among implementations which permits quality of implementation to be an active force in the marketplace as well as to allow certain popular extensions, without removing the cachet of conformance to the Standard.  Appendix F to the Standard catalogs those behaviors which fall into one of these three categories. \n  \n  Unspecified behavior gives the implementor some latitude in translating programs.  This latitude does not extend as far as failing to translate the program. \n  \n  Undefined behavior gives the implementor license not to catch certain program errors that are difficult to diagnose.  It also identifies areas of possible conforming language extension: the implementor may augment the language by providing a definition of the officially undefined behavior. \n  \n  Implementation-defined behavior gives an implementor the freedom to choose the appropriate approach, but requires that this choice be explained to the user.  Behaviors designated as implementation-defined are generally those in which a user could make meaningful coding decisions based on the implementation definition.  Implementors should bear in mind this criterion when deciding how extensive an implementation definition ought to be.  As with unspecified behavior, simply failing to translate the source containing the implementation-defined behavior is not an adequate response. \n\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"Undefined Behavior vs. Unspecified Behavior has a short description of it.\n\nTheir final summary:\n\n\n  To sum up, unspecified behavior is usually something you shouldn&apos;t\n  worry about, unless your software is required to be portable.\n  Conversely, undefined behavior is always undesirable and should never\n  occur.\n\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"Implementation defined- \n\n\n  Implementors wish,should be well documented,standard gives choices but sure to compile\n\n\nUnspecified -\n\n\n  Same as implementation-defined but not documented\n\n\nUndefined-\n\n\n  Anything might happen,take care of it.\n\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"Historically, both Implementation-Defined Behavior and Undefined Behavior represented situations in which the authors of the Standard expected that people writing quality implementations would use judgment to decide what behavioral guarantees, if any, would be useful for programs in the intended application field running on the intended targets.  The needs of high-end number-crunching code are quite different from those of low-level systems code, and both UB and IDB give compiler writers flexibility to meet those different needs.  Neither category mandates that implementations behave in a way that&apos;s useful for any particular purpose, or even for any purpose whatsoever.  Quality implementations that claim to be suitable for a particular purpose, however, should behave in a manner befitting such purpose whether the Standard requires it or not.\n\nThe only difference between Implementation-Defined Behavior and Undefined Behavior is that the former requires that implementations define and document a consistent behavior even in cases where nothing the implementation could possibly do would be useful.  The dividing line between them is not whether it would generally be useful for implementations to define behaviors (compiler writers should define useful behaviors when practical whether the Standard requires them to or not) but whether there might be implementations where defining a behavior would be simultaneously costly and useless.  A judgment that such implementations might exist does not in any way, shape, or form, imply any judgment about the usefulness of supporting a defined behavior on other platforms.\n\nUnfortunately, since the mid 1990s compiler writers have started to interpret the lack of behavioral mandates as an judgment that behavioral guarantees aren&apos;t worth the cost even in application fields where they&apos;re vital, and even on systems where they cost practically nothing.  Instead of treating UB as an invitation to exercise reasonable judgment, compiler writers have started treating it as an excuse not to do so.\n\nFor example, given the following code:\n\nint scaled_velocity(int v, unsigned char pow)\n{\n  if (v &gt; 250)\n    v = 250;\n  if (v &lt; -250)\n    v = -250;\n  return v &lt;&lt; pow;\n}\n\n\na two&apos;s-complement implementation would not have to expend any effort\nwhatsoever to treat the expression v &lt;&lt; pow as a two&apos;s-complement shift\nwithout regard for whether v was positive or negative.\n\nThe preferred philosophy among some of today&apos;s compiler writers, however, would suggest that because v can only be negative if the program is going to engage in Undefined Behavior, there&apos;s no reason to have the program clip the negative range of v.  Even though left-shifting of negative values used to be supported on every single compiler of significance, and a large amount of existing code relies upon that behavior, modern philosophy would interpret the fact that the Standard says that left-shifting negative values is UB as implying that compiler writers should feel free to ignore that.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"C++ standard n3337  ยง 1.3.10\nimplementation-defined behavior\n\n\n  behavior, for a well-formed program construct and correct data, that\n  depends on the implementation and that each implementation documents\n\n\nSometimes C++ Standard doesn&apos;t impose particular behavior on some constructs but says instead that a particular, well defined behavior has to be chosen and described by particular implementation (version of library). So user can still know exactly how will program behave even though Standard doesn&apos;t describe this. \n\n\n\nC++ standard n3337  ยง 1.3.24\nundefined behavior\n\n\n  behavior for which this International Standard imposes no requirements\n  [ Note: Undefined behavior may be expected when this International\n  Standard omits any explicit definition of behavior or when a program\n  uses an erroneous construct or erroneous data. Permissible undefined\n  behavior ranges from ignoring the situation completely with\n  unpredictable results, to behaving during translation or program\n  execution in a documented manner characteristic of the environment\n  (with or without the issuance of a diagnostic message), to terminating\n  a translation or execution (with the issuance of a diagnostic\n  message). Many erroneous program constructs do not engender undefined\n  behavior; they are required to be diagnosed.  end note ]\n\n\nWhen the program encounters construct that is not defined according to C++ Standard it is allowed to do whatever it wants to do ( maybe send an email to me or maybe send an email to you or maybe ignore the code completely). \n\n\n\nC++ standard n3337  ยง 1.3.25\nunspecified behavior\n\n\n  behavior, for a well-formed program construct and correct data, that\n  depends on the implementation [ Note: The implementation is not\n  required to document which behavior occurs. The range of possible\n  behaviors is usually delineated by this International Standard.  end\n  note ]\n\n\nC++ Standard doesn&apos;t impose particular behavior on some constructs but says instead that a particular, well defined behavior has to be chosen ( bot not necessary described) by particular implementation (version of library). So in the case when no description has been provided it can be difficult to the user to know exactly how will program behave.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"Undefined behavior is ugly -- as in, &quot;The good, the bad, and the ugly&quot;.\nGood: a program that compiles and works, for the right reasons.\nBad: a program that has an error, of a kind that the compiler can detect and complain about.\nUgly: a program that has an error, that the compiler cannot detect and warn about, meaning that the program compiles, and may seem to work correctly some of the time, but also fails bizarrely some of the time.  That&apos;s what undefined behavior is.\nSome program languages and other formal systems try hard to limit the &quot;gulf of undefinedness&quot; -- that is, they try to arrange things so that most or all programs are either &quot;good&quot; or &quot;bad&quot;, and that very few are &quot;ugly&quot;.  It&apos;s a characteristic feature of C, however, that its &quot;gulf of undefinedness&quot; is quite wide.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-25e5079ab4bd6ecd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-12e9794e898cd5f3.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-928c5d1eb8fb0bba.js" defer=""></script><script src="/_next/static/BnkbnjkWYxefPXjTJLVVv/_buildManifest.js" defer=""></script><script src="/_next/static/BnkbnjkWYxefPXjTJLVVv/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/undefined-unspecified-and-implementation-defined-behavior-1657384516085#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/undefined-unspecified-and-implementation-defined-behavior-1657384516085"><h1>Undefined, unspecified and implementation-defined behavior</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/undefined-behavior">undefined-behavior</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/unspecified-behavior">unspecified-behavior</a></div></div><div class="question-content mt-5">
                
<p>What is <em>undefined behavior</em> (UB) in C and C++?  What about <em>unspecified behavior</em> and <em>implementation-defined</em> behavior?  What is the difference between them?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/undefined-behavior">undefined-behavior</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/unspecified-behavior">unspecified-behavior</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><em><strong>Undefined behavior</strong></em> is one of those aspects of the C and C++ language that can be surprising to programmers coming from other languages (other languages try to hide it better). Basically,  it is possible to write C++ programs that do not behave in a predictable way, even though many C++ compilers will not report any errors in the program!</p>
<p>Let's look at a classic example:</p>
<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">char</span>* p = <span class="hljs-string">"hello!\n"</span>;   <span class="hljs-comment">// yes I know, deprecated conversion</span>
    p[<span class="hljs-number">0</span>] = <span class="hljs-string">'y'</span>;
    p[<span class="hljs-number">5</span>] = <span class="hljs-string">'w'</span>;
    std::cout &lt;&lt; p;
}
</code></pre>
<p>The variable <code>p</code> points to the string literal <code>"hello!\n"</code>, and the two assignments below try to modify that string literal. What does this program do? According to section 2.14.5 paragraph 11 of the C++ standard, it invokes <em>undefined behavior</em>:</p>
<blockquote>
<p>The effect of attempting to modify a string literal is undefined.</p>
</blockquote>
<p>I can hear people screaming "But wait, I can compile this no problem and get the output <code>yellow</code>" or "What do you mean undefined, string literals are stored in read-only memory, so the first assignment attempt results in a core dump". This is exactly the problem with undefined behavior. Basically, the standard allows anything to happen once you invoke undefined behavior (even nasal demons). If there is a "correct" behavior according to your mental model of the language, that model is simply wrong; The C++ standard has the only vote, period.</p>
<p>Other examples of undefined behavior include accessing an array beyond its bounds, <a href="https://stackoverflow.com/q/2894891">dereferencing the null pointer</a>, <a href="https://stackoverflow.com/q/6441218">accessing objects after their lifetime ended</a> or writing <a href="https://stackoverflow.com/q/949433">allegedly clever expressions</a> like <code>i++ + ++i</code>.</p>
<p>Section 1.9 of the C++ standard also mentions undefined behavior's two less dangerous brothers, <strong>unspecified behavior</strong> and <strong>implementation-defined behavior</strong>:</p>
<blockquote>
<p>The semantic descriptions in this International Standard define a parameterized nondeterministic abstract machine.</p>
<p>Certain aspects and operations of the abstract machine are described in this International Standard as <strong>implementation-defined</strong> (for example, <code>sizeof(int)</code>). These constitute the parameters of the abstract machine. Each implementation shall include documentation describing its characteristics and behavior in these respects.</p>
<p>Certain other aspects and operations of the abstract machine are described in this International Standard as <strong>unspecified</strong> (for example, order of evaluation of arguments to a function). Where possible, this International Standard defines a set of allowable behaviors. These define the nondeterministic aspects of the abstract machine.</p>
<p>Certain other operations are described in this International Standard as <strong>undefined</strong> (for example, the  effect of dereferencing the null pointer). [ <em>Note</em>: <strong>this International Standard imposes no requirements on the behavior of programs that contain undefined behavior.</strong> <em>end note</em> ]</p>
</blockquote>
<p>Specifically, section 1.3.24 states:</p>
<blockquote>
<p>Permissible undefined behavior ranges from <strong>ignoring the situation completely with unpredictable results</strong>, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).</p>
</blockquote>
<p>What can you do to avoid running into undefined behavior? Basically, you have to read <a href="https://stackoverflow.com/questions/388242/">good C++ books</a> by authors who know what they're talking about. Avoid internet tutorials. Avoid bullschildt.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/undefined-behavior">undefined-behavior</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/unspecified-behavior">unspecified-behavior</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Well, this is basically a straight copy-paste from the standard</p>
<blockquote>
<p><strong>3.4.1</strong> 1 <strong>implementation-defined behavior</strong> unspecified behavior where
each implementation documents how the
choice is made</p>
<p>2 EXAMPLE An example of
implementation-defined behavior is the
propagation of the high-order bit when
a signed integer is shifted right.</p>
<p><strong>3.4.3</strong> 1 <strong>undefined behavior</strong> behavior, upon use of a nonportable or erroneous
program construct or of erroneous
data, for which this International
Standard imposes no requirements</p>
<p>2
NOTE Possible undefined behavior
ranges from ignoring the situation
completely with unpredictable results,
to behaving during translation or
program execution in a documented
manner characteristic of the
environment (with or without the
issuance of a diagnostic message), to
terminating a translation or execution
(with the issuance of a diagnostic
message).</p>
<p>3 EXAMPLE An example of
undefined behavior is the behavior on
integer overflow.</p>
<p><strong>3.4.4</strong> 1 <strong>unspecified behavior</strong> use of an unspecified value, or other behavior
where this International Standard
provides two or more possibilities and
imposes no further requirements on
which is chosen in any instance</p>
<p>2
EXAMPLE An example of unspecified
behavior is the order in which the
arguments to a function are evaluated.</p>
</blockquote>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/undefined-behavior">undefined-behavior</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/unspecified-behavior">unspecified-behavior</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Maybe easy wording could be easier for understanding than the rigorous definition of the standards.</p>
<p><strong>implementation-defined behavior</strong><br>
The language says that we have data-types. The compiler vendors specify what sizes shall they use, and provide a documentation of what they did.</p>
<p><strong>undefined behavior</strong><br>
You are doing something wrong. For example, you have a very large value in an <code>int</code> that doesn't fit in <code>char</code>. How do you put that value in <code>char</code>? actually there is no way! Anything could happen, but the most sensible thing would be to take the first byte of that int and put it in <code>char</code>. It is just wrong to do that to assign the first byte, but thats what happens under the hood.</p>
<p><strong>unspecified behavior</strong><br>
Which function of these two is executed first?</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span></span>;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"fun1"</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun2</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"fun2"</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
}
...
<span class="hljs-built_in">fun</span>(<span class="hljs-built_in">fun1</span>(), <span class="hljs-built_in">fun2</span>()); <span class="hljs-comment">// which one is executed first?</span>
</code></pre>
<p>The language doesn't specify the evaluation, left to right or right to left! So an unspecified behavior may or mayn't result in an undefined behavior, but certainly your program should not produce an unspecified behavior.</p>
<hr>
<p>@eSKay I think your question is worth editing the answer to clarify more :)</p>
<blockquote>
<p>for <code>fun(fun1(), fun2());</code> isn't the behaviour "implementation defined"? The compiler has to choose one or the other course, after all?</p>
</blockquote>
<p>The difference between implementation-defined and unspecified, is that the compiler is supposed to pick a behavior in the first case but it doesn't have to in the second case. For example, an implementation must have one and only one definition of <code>sizeof(int)</code>. So, it can't say that <code>sizeof(int)</code> is 4 for some portion of the program and 8 for others. Unlike unspecified behavior, where the compiler can say OK I am gonna evaluate these arguments left-to-right and the next function's arguments are evaluated right-to-left. It can happen in the same program, that's why it is called <em><strong>unspecified</strong></em>. In fact, C++ could have been made easier if some of the unspecified behaviors were specified. Take a look here at <a href="//www.stroustrup.com/bs_faq2.html#undefined" rel="nofollow noreferrer">Dr. Stroustrup's answer for that</a>:</p>
<blockquote>
<p>It is claimed that the difference between what can be produced giving the compiler this freedom and requiring "ordinary left-to-right evaluation" can be significant. I'm unconvinced, but with innumerable compilers "out there" taking advantage of the freedom and some people passionately defending that freedom, a change would be difficult and could take decades to penetrate to the distant corners of the C and C++ worlds. I am disappointed that not all compilers warn against code such as <code>++i+i++</code>. Similarly, the order of evaluation of arguments is unspecified.</p>
<p>IMO far too many "things" are left undefined, unspecified, that's easy to say and even to give examples of, but hard to fix. It should also be noted that it is not all that difficult to avoid most of the problems and produce portable code.</p>
</blockquote>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/undefined-behavior">undefined-behavior</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/unspecified-behavior">unspecified-behavior</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>From the official C Rationale Document</p>

<blockquote>
  <p>The terms <em>unspecified</em> behavior, <em>undefined</em> behavior, and <em>implementation-defined</em> behavior are used to categorize the result of writing programs whose properties the Standard does not, or cannot, completely describe.  The goal of adopting this categorization is to allow a certain variety among implementations which permits quality of implementation to be an active force in the marketplace as well as to allow certain popular extensions, without removing the cachet of conformance to the Standard.  Appendix F to the Standard catalogs those behaviors which fall into one of these three categories. </p>
  
  <p><em>Unspecified behavior</em> gives the implementor some latitude in translating programs.  This latitude does not extend as far as failing to translate the program. </p>
  
  <p><em>Undefined behavior</em> gives the implementor license not to catch certain program errors that are difficult to diagnose.  It also identifies areas of possible conforming language extension: the implementor may augment the language by providing a definition of the officially undefined behavior. </p>
  
  <p><em>Implementation-defined</em> behavior gives an implementor the freedom to choose the appropriate approach, but requires that this choice be explained to the user.  Behaviors designated as implementation-defined are generally those in which a user could make meaningful coding decisions based on the implementation definition.  Implementors should bear in mind this criterion when deciding how extensive an implementation definition ought to be.  As with unspecified behavior, simply failing to translate the source containing the implementation-defined behavior is not an adequate response. </p>
</blockquote>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/undefined-behavior">undefined-behavior</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/unspecified-behavior">unspecified-behavior</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><a href="http://www.devx.com/tips/Tip/12684" rel="noreferrer">Undefined Behavior vs. Unspecified Behavior</a> has a short description of it.</p>

<p>Their final summary:</p>

<blockquote>
  <p>To sum up, unspecified behavior is usually something you shouldn't
  worry about, unless your software is required to be portable.
  Conversely, undefined behavior is always undesirable and should never
  occur.</p>
</blockquote>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/undefined-behavior">undefined-behavior</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/unspecified-behavior">unspecified-behavior</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Implementation defined- </p>

<blockquote>
  <p>Implementors wish,should be well documented,standard gives choices but sure to compile</p>
</blockquote>

<p>Unspecified -</p>

<blockquote>
  <p>Same as implementation-defined but not documented</p>
</blockquote>

<p>Undefined-</p>

<blockquote>
  <p>Anything might happen,take care of it.</p>
</blockquote>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/undefined-behavior">undefined-behavior</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/unspecified-behavior">unspecified-behavior</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Historically, both Implementation-Defined Behavior and Undefined Behavior represented situations in which the authors of the Standard expected that people writing quality implementations would use judgment to decide what behavioral guarantees, if any, would be useful for programs in the intended application field running on the intended targets.  The needs of high-end number-crunching code are quite different from those of low-level systems code, and both UB and IDB give compiler writers flexibility to meet those different needs.  Neither category mandates that implementations behave in a way that's useful for any particular purpose, or even for any purpose whatsoever.  Quality implementations that claim to be suitable for a particular purpose, however, should behave in a manner befitting such purpose <em>whether the Standard requires it or not</em>.</p>

<p>The only difference between Implementation-Defined Behavior and Undefined Behavior is that the former requires that implementations define and document a consistent behavior <em>even in cases where nothing the implementation could possibly do would be useful</em>.  The dividing line between them is not whether it would generally be useful for implementations to define behaviors (compiler writers should define useful behaviors when practical whether the Standard requires them to or not) but <em>whether there might be implementations where defining a behavior would be simultaneously costly and useless</em>.  A judgment that such implementations might exist does not in any way, shape, or form, imply any judgment about the usefulness of supporting a defined behavior on other platforms.</p>

<p>Unfortunately, since the mid 1990s compiler writers have started to interpret the lack of behavioral mandates as an judgment that behavioral guarantees aren't worth the cost even in application fields where they're vital, and even on systems where they cost practically nothing.  Instead of treating UB as an invitation to exercise reasonable judgment, compiler writers have started treating it as an excuse <em>not</em> to do so.</p>

<p>For example, given the following code:</p>

<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">scaled_velocity</span><span class="hljs-params">(<span class="hljs-type">int</span> v, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> pow)</span>
</span>{
  <span class="hljs-keyword">if</span> (v &gt; <span class="hljs-number">250</span>)
    v = <span class="hljs-number">250</span>;
  <span class="hljs-keyword">if</span> (v &lt; <span class="hljs-number">-250</span>)
    v = <span class="hljs-number">-250</span>;
  <span class="hljs-keyword">return</span> v &lt;&lt; pow;
}
</code></pre>

<p>a two's-complement implementation would not have to expend any effort
whatsoever to treat the expression <code>v &lt;&lt; pow</code> as a two's-complement shift
without regard for whether <code>v</code> was positive or negative.</p>

<p>The preferred philosophy among some of today's compiler writers, however, would suggest that because <code>v</code> can only be negative if the program is going to engage in Undefined Behavior, there's no reason to have the program clip the negative range of <code>v</code>.  Even though left-shifting of negative values used to be supported on every single compiler of significance, and a large amount of existing code relies upon that behavior, modern philosophy would interpret the fact that the Standard says that left-shifting negative values is UB as implying that compiler writers should feel free to ignore that.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/undefined-behavior">undefined-behavior</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/unspecified-behavior">unspecified-behavior</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>C++ standard n3337  <strong>ยง</strong> 1.3.10
<strong>implementation-defined behavior</strong></p>

<blockquote>
  <p>behavior, for a well-formed program construct and correct data, that
  depends on the implementation and that each implementation documents</p>
</blockquote>

<p>Sometimes C++ Standard doesn't impose particular behavior on some constructs but says instead that a particular, well defined behavior has to be chosen and <strong>described</strong> by particular implementation (version of library). So user can still know exactly how will program behave even though Standard doesn't describe this. </p>

<hr>

<p>C++ standard n3337  <strong>ยง</strong> 1.3.24
<strong>undefined behavior</strong></p>

<blockquote>
  <p>behavior for which this International Standard imposes no requirements
  [ Note: Undefined behavior may be expected when this International
  Standard omits any explicit definition of behavior or when a program
  uses an erroneous construct or erroneous data. Permissible undefined
  behavior ranges from ignoring the situation completely with
  unpredictable results, to behaving during translation or program
  execution in a documented manner characteristic of the environment
  (with or without the issuance of a diagnostic message), to terminating
  a translation or execution (with the issuance of a diagnostic
  message). Many erroneous program constructs do not engender undefined
  behavior; they are required to be diagnosed.  end note ]</p>
</blockquote>

<p>When the program encounters construct that is not defined according to C++ Standard it is allowed to do whatever it wants to do ( maybe send an email to me or maybe send an email to you or maybe ignore the code completely). </p>

<hr>

<p>C++ standard n3337  <strong>ยง</strong> 1.3.25
<strong>unspecified behavior</strong></p>

<blockquote>
  <p>behavior, for a well-formed program construct and correct data, that
  depends on the implementation [ Note: The implementation is not
  required to document which behavior occurs. The range of possible
  behaviors is usually delineated by this International Standard.  end
  note ]</p>
</blockquote>

<p>C++ Standard doesn't impose particular behavior on some constructs but says instead that a particular, well defined behavior has to be chosen ( <strong>bot not necessary described</strong>) by particular implementation (version of library). So in the case when no description has been provided it can be difficult to the user to know exactly how will program behave.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/undefined-behavior">undefined-behavior</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/unspecified-behavior">unspecified-behavior</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Undefined behavior is <em>ugly</em> -- as in, "The good, the bad, and the ugly".</p>
<p>Good: a program that compiles and works, for the right reasons.</p>
<p>Bad: a program that has an error, of a kind that the compiler can detect and complain about.</p>
<p>Ugly: a program that has an error, that the compiler <em>cannot</em> detect and warn about, meaning that the program compiles, and may seem to work correctly some of the time, but also fails bizarrely some of the time.  That's what undefined behavior is.</p>
<p>Some program languages and other formal systems try hard to limit the "gulf of undefinedness" -- that is, they try to arrange things so that most or all programs are either "good" or "bad", and that very few are "ugly".  It's a characteristic feature of C, however, that its "gulf of undefinedness" is quite wide.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/why-can&#x27;t-an-element-with-a-z-index-value-cover-its-child-1657387707187">Why can&#x27;t an element with a z-index value cover its child?</a><a href="/questions/get-selected-value-in-dropdown-list-using-javascript-1657387631638">Get selected value in dropdown list using JavaScript</a><a href="/questions/what-does-it-mean-to-%22program-to-an-interface%22-1657384671665">What does it mean to &quot;program to an interface&quot;?</a><a href="/questions/make-container-shrink-to-fit-child-elements-as-they-wrap-1657388134549">Make container shrink-to-fit child elements as they wrap</a><a href="/questions/why-does-a-regexp-with-global-flag-give-wrong-results-1657387788550">Why does a RegExp with global flag give wrong results?</a><a href="/questions/how-do-i-profile-a-python-script-1657388346692">How do I profile a Python script?</a><a href="/questions/how-do-i-make-git-forget-about-a-file-that-was-tracked-but-is-now-in-.gitignore-1657387328843">How do I make Git forget about a file that was tracked, but is now in .gitignore?</a><a href="/questions/how-to-use-java.util.scanner-to-correctly-read-user-input-from-system.in-and-act-on-it-1657388546306">How to use java.util.Scanner to correctly read user input from System.in and act on it?</a><a href="/questions/difference-between-single-and-double-quotes-in-bash-1657385460827">Difference between single and double quotes in Bash</a><a href="/questions/php-code-is-not-being-executed-but-the-code-shows-in-the-browser-source-code-1657384553581">PHP code is not being executed, but the code shows in the browser source code</a><a href="/questions/pandas-conditional-creation-of-a-seriesdataframe-column-1657387461003">Pandas conditional creation of a series/dataframe column</a><a href="/questions/what-is-a-lambda-expression-in-c++11-1657387999252">What is a lambda expression in C++11?</a><a href="/questions/how-to-deal-with-mysqli-problems-mysqli_fetch_array():-argument-1-must-be-of-type-mysqli_result-1657384360922">How to deal with mysqli problems? mysqli_fetch_array(): Argument #1 must be of type mysqli_result</a><a href="/questions/how-to-format-numbers-as-currency-strings-1657388399166">How to format numbers as currency strings</a><a href="/questions/javascript-closure-inside-loops-simple-practical-example-1657384278449">JavaScript closure inside loops โ simple practical example</a><a href="/questions/getcontactsfromfirebase()-method-return-an-empty-list-1657388433928">getContactsFromFirebase() method return an empty list</a><a href="/questions/accessing-an-array-out-of-bounds-gives-no-error-why-1657387979932">Accessing an array out of bounds gives no error, why?</a><a href="/questions/are-global-variables-thread-safe-in-flask-how-do-i-share-data-between-requests-1657387949951">Are global variables thread-safe in Flask? How do I share data between requests?</a><a href="/questions/non-static-variable-cannot-be-referenced-from-a-static-context-1657387386240">Non-static variable cannot be referenced from a static context</a><a href="/questions/using-limit-within-group-by-to-get-n-results-per-group-1657388324167">Using LIMIT within GROUP BY to get N results per group?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;Undefined behavior\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; is one of those aspects of the C and C++ language that can be surprising to programmers coming from other languages (other languages try to hide it better). Basically,  it is possible to write C++ programs that do not behave in a predictable way, even though many C++ compilers will not report any errors in the program!\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Let\u0026apos;s look at a classic example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* p = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello!\\n\u0026quot;\u0026lt;/span\u0026gt;;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// yes I know, deprecated conversion\u0026lt;/span\u0026gt;\n    p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;y\u0026apos;\u0026lt;/span\u0026gt;;\n    p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;w\u0026apos;\u0026lt;/span\u0026gt;;\n    std::cout \u0026amp;lt;\u0026amp;lt; p;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The variable \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt; points to the string literal \u0026lt;code\u0026gt;\u0026quot;hello!\\n\u0026quot;\u0026lt;/code\u0026gt;, and the two assignments below try to modify that string literal. What does this program do? According to section 2.14.5 paragraph 11 of the C++ standard, it invokes \u0026lt;em\u0026gt;undefined behavior\u0026lt;/em\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;The effect of attempting to modify a string literal is undefined.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;I can hear people screaming \u0026quot;But wait, I can compile this no problem and get the output \u0026lt;code\u0026gt;yellow\u0026lt;/code\u0026gt;\u0026quot; or \u0026quot;What do you mean undefined, string literals are stored in read-only memory, so the first assignment attempt results in a core dump\u0026quot;. This is exactly the problem with undefined behavior. Basically, the standard allows anything to happen once you invoke undefined behavior (even nasal demons). If there is a \u0026quot;correct\u0026quot; behavior according to your mental model of the language, that model is simply wrong; The C++ standard has the only vote, period.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Other examples of undefined behavior include accessing an array beyond its bounds, \u0026lt;a href=\u0026quot;https://stackoverflow.com/q/2894891\u0026quot;\u0026gt;dereferencing the null pointer\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;https://stackoverflow.com/q/6441218\u0026quot;\u0026gt;accessing objects after their lifetime ended\u0026lt;/a\u0026gt; or writing \u0026lt;a href=\u0026quot;https://stackoverflow.com/q/949433\u0026quot;\u0026gt;allegedly clever expressions\u0026lt;/a\u0026gt; like \u0026lt;code\u0026gt;i++ + ++i\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Section 1.9 of the C++ standard also mentions undefined behavior\u0026apos;s two less dangerous brothers, \u0026lt;strong\u0026gt;unspecified behavior\u0026lt;/strong\u0026gt; and \u0026lt;strong\u0026gt;implementation-defined behavior\u0026lt;/strong\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;The semantic descriptions in this International Standard define a parameterized nondeterministic abstract machine.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Certain aspects and operations of the abstract machine are described in this International Standard as \u0026lt;strong\u0026gt;implementation-defined\u0026lt;/strong\u0026gt; (for example, \u0026lt;code\u0026gt;sizeof(int)\u0026lt;/code\u0026gt;). These constitute the parameters of the abstract machine. Each implementation shall include documentation describing its characteristics and behavior in these respects.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Certain other aspects and operations of the abstract machine are described in this International Standard as \u0026lt;strong\u0026gt;unspecified\u0026lt;/strong\u0026gt; (for example, order of evaluation of arguments to a function). Where possible, this International Standard defines a set of allowable behaviors. These define the nondeterministic aspects of the abstract machine.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Certain other operations are described in this International Standard as \u0026lt;strong\u0026gt;undefined\u0026lt;/strong\u0026gt; (for example, the  effect of dereferencing the null pointer). [ \u0026lt;em\u0026gt;Note\u0026lt;/em\u0026gt;: \u0026lt;strong\u0026gt;this International Standard imposes no requirements on the behavior of programs that contain undefined behavior.\u0026lt;/strong\u0026gt; \u0026lt;em\u0026gt;end note\u0026lt;/em\u0026gt; ]\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Specifically, section 1.3.24 states:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Permissible undefined behavior ranges from \u0026lt;strong\u0026gt;ignoring the situation completely with unpredictable results\u0026lt;/strong\u0026gt;, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;What can you do to avoid running into undefined behavior? Basically, you have to read \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/388242/\u0026quot;\u0026gt;good C++ books\u0026lt;/a\u0026gt; by authors who know what they\u0026apos;re talking about. Avoid internet tutorials. Avoid bullschildt.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Well, this is basically a straight copy-paste from the standard\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;3.4.1\u0026lt;/strong\u0026gt; 1 \u0026lt;strong\u0026gt;implementation-defined behavior\u0026lt;/strong\u0026gt; unspecified behavior where\neach implementation documents how the\nchoice is made\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;2 EXAMPLE An example of\nimplementation-defined behavior is the\npropagation of the high-order bit when\na signed integer is shifted right.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;3.4.3\u0026lt;/strong\u0026gt; 1 \u0026lt;strong\u0026gt;undefined behavior\u0026lt;/strong\u0026gt; behavior, upon use of a nonportable or erroneous\nprogram construct or of erroneous\ndata, for which this International\nStandard imposes no requirements\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;2\nNOTE Possible undefined behavior\nranges from ignoring the situation\ncompletely with unpredictable results,\nto behaving during translation or\nprogram execution in a documented\nmanner characteristic of the\nenvironment (with or without the\nissuance of a diagnostic message), to\nterminating a translation or execution\n(with the issuance of a diagnostic\nmessage).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;3 EXAMPLE An example of\nundefined behavior is the behavior on\ninteger overflow.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;3.4.4\u0026lt;/strong\u0026gt; 1 \u0026lt;strong\u0026gt;unspecified behavior\u0026lt;/strong\u0026gt; use of an unspecified value, or other behavior\nwhere this International Standard\nprovides two or more possibilities and\nimposes no further requirements on\nwhich is chosen in any instance\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;2\nEXAMPLE An example of unspecified\nbehavior is the order in which the\narguments to a function are evaluated.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Maybe easy wording could be easier for understanding than the rigorous definition of the standards.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;implementation-defined behavior\u0026lt;/strong\u0026gt;\u0026lt;br\u0026gt;\nThe language says that we have data-types. The compiler vendors specify what sizes shall they use, and provide a documentation of what they did.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;undefined behavior\u0026lt;/strong\u0026gt;\u0026lt;br\u0026gt;\nYou are doing something wrong. For example, you have a very large value in an \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; that doesn\u0026apos;t fit in \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt;. How do you put that value in \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt;? actually there is no way! Anything could happen, but the most sensible thing would be to take the first byte of that int and put it in \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt;. It is just wrong to do that to assign the first byte, but thats what happens under the hood.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;unspecified behavior\u0026lt;/strong\u0026gt;\u0026lt;br\u0026gt;\nWhich function of these two is executed first?\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; m)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;fun1\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;fun1\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n}\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;fun2\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;fun2\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n}\n...\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fun1\u0026lt;/span\u0026gt;(), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fun2\u0026lt;/span\u0026gt;()); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// which one is executed first?\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The language doesn\u0026apos;t specify the evaluation, left to right or right to left! So an unspecified behavior may or mayn\u0026apos;t result in an undefined behavior, but certainly your program should not produce an unspecified behavior.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;@eSKay I think your question is worth editing the answer to clarify more :)\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;for \u0026lt;code\u0026gt;fun(fun1(), fun2());\u0026lt;/code\u0026gt; isn\u0026apos;t the behaviour \u0026quot;implementation defined\u0026quot;? The compiler has to choose one or the other course, after all?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;The difference between implementation-defined and unspecified, is that the compiler is supposed to pick a behavior in the first case but it doesn\u0026apos;t have to in the second case. For example, an implementation must have one and only one definition of \u0026lt;code\u0026gt;sizeof(int)\u0026lt;/code\u0026gt;. So, it can\u0026apos;t say that \u0026lt;code\u0026gt;sizeof(int)\u0026lt;/code\u0026gt; is 4 for some portion of the program and 8 for others. Unlike unspecified behavior, where the compiler can say OK I am gonna evaluate these arguments left-to-right and the next function\u0026apos;s arguments are evaluated right-to-left. It can happen in the same program, that\u0026apos;s why it is called \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;unspecified\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;. In fact, C++ could have been made easier if some of the unspecified behaviors were specified. Take a look here at \u0026lt;a href=\u0026quot;//www.stroustrup.com/bs_faq2.html#undefined\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Dr. Stroustrup\u0026apos;s answer for that\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;It is claimed that the difference between what can be produced giving the compiler this freedom and requiring \u0026quot;ordinary left-to-right evaluation\u0026quot; can be significant. I\u0026apos;m unconvinced, but with innumerable compilers \u0026quot;out there\u0026quot; taking advantage of the freedom and some people passionately defending that freedom, a change would be difficult and could take decades to penetrate to the distant corners of the C and C++ worlds. I am disappointed that not all compilers warn against code such as \u0026lt;code\u0026gt;++i+i++\u0026lt;/code\u0026gt;. Similarly, the order of evaluation of arguments is unspecified.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;IMO far too many \u0026quot;things\u0026quot; are left undefined, unspecified, that\u0026apos;s easy to say and even to give examples of, but hard to fix. It should also be noted that it is not all that difficult to avoid most of the problems and produce portable code.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;From the official C Rationale Document\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The terms \u0026lt;em\u0026gt;unspecified\u0026lt;/em\u0026gt; behavior, \u0026lt;em\u0026gt;undefined\u0026lt;/em\u0026gt; behavior, and \u0026lt;em\u0026gt;implementation-defined\u0026lt;/em\u0026gt; behavior are used to categorize the result of writing programs whose properties the Standard does not, or cannot, completely describe.  The goal of adopting this categorization is to allow a certain variety among implementations which permits quality of implementation to be an active force in the marketplace as well as to allow certain popular extensions, without removing the cachet of conformance to the Standard.  Appendix F to the Standard catalogs those behaviors which fall into one of these three categories. \u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Unspecified behavior\u0026lt;/em\u0026gt; gives the implementor some latitude in translating programs.  This latitude does not extend as far as failing to translate the program. \u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Undefined behavior\u0026lt;/em\u0026gt; gives the implementor license not to catch certain program errors that are difficult to diagnose.  It also identifies areas of possible conforming language extension: the implementor may augment the language by providing a definition of the officially undefined behavior. \u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Implementation-defined\u0026lt;/em\u0026gt; behavior gives an implementor the freedom to choose the appropriate approach, but requires that this choice be explained to the user.  Behaviors designated as implementation-defined are generally those in which a user could make meaningful coding decisions based on the implementation definition.  Implementors should bear in mind this criterion when deciding how extensive an implementation definition ought to be.  As with unspecified behavior, simply failing to translate the source containing the implementation-defined behavior is not an adequate response. \u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://www.devx.com/tips/Tip/12684\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Undefined Behavior vs. Unspecified Behavior\u0026lt;/a\u0026gt; has a short description of it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Their final summary:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;To sum up, unspecified behavior is usually something you shouldn\u0026apos;t\n  worry about, unless your software is required to be portable.\n  Conversely, undefined behavior is always undesirable and should never\n  occur.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Implementation defined- \u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Implementors wish,should be well documented,standard gives choices but sure to compile\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Unspecified -\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Same as implementation-defined but not documented\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Undefined-\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Anything might happen,take care of it.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Historically, both Implementation-Defined Behavior and Undefined Behavior represented situations in which the authors of the Standard expected that people writing quality implementations would use judgment to decide what behavioral guarantees, if any, would be useful for programs in the intended application field running on the intended targets.  The needs of high-end number-crunching code are quite different from those of low-level systems code, and both UB and IDB give compiler writers flexibility to meet those different needs.  Neither category mandates that implementations behave in a way that\u0026apos;s useful for any particular purpose, or even for any purpose whatsoever.  Quality implementations that claim to be suitable for a particular purpose, however, should behave in a manner befitting such purpose \u0026lt;em\u0026gt;whether the Standard requires it or not\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The only difference between Implementation-Defined Behavior and Undefined Behavior is that the former requires that implementations define and document a consistent behavior \u0026lt;em\u0026gt;even in cases where nothing the implementation could possibly do would be useful\u0026lt;/em\u0026gt;.  The dividing line between them is not whether it would generally be useful for implementations to define behaviors (compiler writers should define useful behaviors when practical whether the Standard requires them to or not) but \u0026lt;em\u0026gt;whether there might be implementations where defining a behavior would be simultaneously costly and useless\u0026lt;/em\u0026gt;.  A judgment that such implementations might exist does not in any way, shape, or form, imply any judgment about the usefulness of supporting a defined behavior on other platforms.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Unfortunately, since the mid 1990s compiler writers have started to interpret the lack of behavioral mandates as an judgment that behavioral guarantees aren\u0026apos;t worth the cost even in application fields where they\u0026apos;re vital, and even on systems where they cost practically nothing.  Instead of treating UB as an invitation to exercise reasonable judgment, compiler writers have started treating it as an excuse \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; to do so.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example, given the following code:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;scaled_velocity\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; v, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; pow)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (v \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;250\u0026lt;/span\u0026gt;)\n    v = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;250\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (v \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-250\u0026lt;/span\u0026gt;)\n    v = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-250\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; v \u0026amp;lt;\u0026amp;lt; pow;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;a two\u0026apos;s-complement implementation would not have to expend any effort\nwhatsoever to treat the expression \u0026lt;code\u0026gt;v \u0026amp;lt;\u0026amp;lt; pow\u0026lt;/code\u0026gt; as a two\u0026apos;s-complement shift\nwithout regard for whether \u0026lt;code\u0026gt;v\u0026lt;/code\u0026gt; was positive or negative.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The preferred philosophy among some of today\u0026apos;s compiler writers, however, would suggest that because \u0026lt;code\u0026gt;v\u0026lt;/code\u0026gt; can only be negative if the program is going to engage in Undefined Behavior, there\u0026apos;s no reason to have the program clip the negative range of \u0026lt;code\u0026gt;v\u0026lt;/code\u0026gt;.  Even though left-shifting of negative values used to be supported on every single compiler of significance, and a large amount of existing code relies upon that behavior, modern philosophy would interpret the fact that the Standard says that left-shifting negative values is UB as implying that compiler writers should feel free to ignore that.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;C++ standard n3337  \u0026lt;strong\u0026gt;ยง\u0026lt;/strong\u0026gt; 1.3.10\n\u0026lt;strong\u0026gt;implementation-defined behavior\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;behavior, for a well-formed program construct and correct data, that\n  depends on the implementation and that each implementation documents\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Sometimes C++ Standard doesn\u0026apos;t impose particular behavior on some constructs but says instead that a particular, well defined behavior has to be chosen and \u0026lt;strong\u0026gt;described\u0026lt;/strong\u0026gt; by particular implementation (version of library). So user can still know exactly how will program behave even though Standard doesn\u0026apos;t describe this. \u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;C++ standard n3337  \u0026lt;strong\u0026gt;ยง\u0026lt;/strong\u0026gt; 1.3.24\n\u0026lt;strong\u0026gt;undefined behavior\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;behavior for which this International Standard imposes no requirements\n  [ Note: Undefined behavior may be expected when this International\n  Standard omits any explicit definition of behavior or when a program\n  uses an erroneous construct or erroneous data. Permissible undefined\n  behavior ranges from ignoring the situation completely with\n  unpredictable results, to behaving during translation or program\n  execution in a documented manner characteristic of the environment\n  (with or without the issuance of a diagnostic message), to terminating\n  a translation or execution (with the issuance of a diagnostic\n  message). Many erroneous program constructs do not engender undefined\n  behavior; they are required to be diagnosed.  end note ]\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;When the program encounters construct that is not defined according to C++ Standard it is allowed to do whatever it wants to do ( maybe send an email to me or maybe send an email to you or maybe ignore the code completely). \u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;C++ standard n3337  \u0026lt;strong\u0026gt;ยง\u0026lt;/strong\u0026gt; 1.3.25\n\u0026lt;strong\u0026gt;unspecified behavior\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;behavior, for a well-formed program construct and correct data, that\n  depends on the implementation [ Note: The implementation is not\n  required to document which behavior occurs. The range of possible\n  behaviors is usually delineated by this International Standard.  end\n  note ]\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;C++ Standard doesn\u0026apos;t impose particular behavior on some constructs but says instead that a particular, well defined behavior has to be chosen ( \u0026lt;strong\u0026gt;bot not necessary described\u0026lt;/strong\u0026gt;) by particular implementation (version of library). So in the case when no description has been provided it can be difficult to the user to know exactly how will program behave.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Undefined behavior is \u0026lt;em\u0026gt;ugly\u0026lt;/em\u0026gt; -- as in, \u0026quot;The good, the bad, and the ugly\u0026quot;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Good: a program that compiles and works, for the right reasons.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Bad: a program that has an error, of a kind that the compiler can detect and complain about.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Ugly: a program that has an error, that the compiler \u0026lt;em\u0026gt;cannot\u0026lt;/em\u0026gt; detect and warn about, meaning that the program compiles, and may seem to work correctly some of the time, but also fails bizarrely some of the time.  That\u0026apos;s what undefined behavior is.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Some program languages and other formal systems try hard to limit the \u0026quot;gulf of undefinedness\u0026quot; -- that is, they try to arrange things so that most or all programs are either \u0026quot;good\u0026quot; or \u0026quot;bad\u0026quot;, and that very few are \u0026quot;ugly\u0026quot;.  It\u0026apos;s a characteristic feature of C, however, that its \u0026quot;gulf of undefinedness\u0026quot; is quite wide.\u0026lt;/p\u0026gt;\n    "],"id":80,"title":"Undefined, unspecified and implementation-defined behavior","content":"\n                \n\u0026lt;p\u0026gt;What is \u0026lt;em\u0026gt;undefined behavior\u0026lt;/em\u0026gt; (UB) in C and C++?  What about \u0026lt;em\u0026gt;unspecified behavior\u0026lt;/em\u0026gt; and \u0026lt;em\u0026gt;implementation-defined\u0026lt;/em\u0026gt; behavior?  What is the difference between them?\u0026lt;/p\u0026gt;\n    ","slug":"undefined-unspecified-and-implementation-defined-behavior-1657384516085","postType":"QUESTION","createdAt":"2022-07-09T16:35:16.000Z","updatedAt":"2022-07-09T16:35:16.000Z","tags":[{"id":294,"name":"undefined-behavior","slug":"undefined-behavior","createdAt":"2022-07-09T16:35:16.000Z","updatedAt":"2022-07-09T16:35:16.000Z","Questions_Tags":{"questionId":80,"tagId":294}},{"id":295,"name":"unspecified-behavior","slug":"unspecified-behavior","createdAt":"2022-07-09T16:35:16.000Z","updatedAt":"2022-07-09T16:35:16.000Z","Questions_Tags":{"questionId":80,"tagId":295}}],"relatedQuestions":[{"title":"Undefined, unspecified and implementation-defined behavior","slug":"undefined-unspecified-and-implementation-defined-behavior-1657384516085","tags":[{"name":"undefined-behavior","Questions_Tags":{"questionId":80,"tagId":294}},{"name":"unspecified-behavior","Questions_Tags":{"questionId":80,"tagId":295}}]}]},"randomQuestions":[{"title":"Why can't an element with a z-index value cover its child?","slug":"why-can't-an-element-with-a-z-index-value-cover-its-child-1657387707187"},{"title":"Get selected value in dropdown list using JavaScript","slug":"get-selected-value-in-dropdown-list-using-javascript-1657387631638"},{"title":"What does it mean to \"program to an interface\"?","slug":"what-does-it-mean-to-\"program-to-an-interface\"-1657384671665"},{"title":"Make container shrink-to-fit child elements as they wrap","slug":"make-container-shrink-to-fit-child-elements-as-they-wrap-1657388134549"},{"title":"Why does a RegExp with global flag give wrong results?","slug":"why-does-a-regexp-with-global-flag-give-wrong-results-1657387788550"},{"title":"How do I profile a Python script?","slug":"how-do-i-profile-a-python-script-1657388346692"},{"title":"How do I make Git forget about a file that was tracked, but is now in .gitignore?","slug":"how-do-i-make-git-forget-about-a-file-that-was-tracked-but-is-now-in-.gitignore-1657387328843"},{"title":"How to use java.util.Scanner to correctly read user input from System.in and act on it?","slug":"how-to-use-java.util.scanner-to-correctly-read-user-input-from-system.in-and-act-on-it-1657388546306"},{"title":"Difference between single and double quotes in Bash","slug":"difference-between-single-and-double-quotes-in-bash-1657385460827"},{"title":"PHP code is not being executed, but the code shows in the browser source code","slug":"php-code-is-not-being-executed-but-the-code-shows-in-the-browser-source-code-1657384553581"},{"title":"Pandas conditional creation of a series/dataframe column","slug":"pandas-conditional-creation-of-a-seriesdataframe-column-1657387461003"},{"title":"What is a lambda expression in C++11?","slug":"what-is-a-lambda-expression-in-c++11-1657387999252"},{"title":"How to deal with mysqli problems? mysqli_fetch_array(): Argument #1 must be of type mysqli_result","slug":"how-to-deal-with-mysqli-problems-mysqli_fetch_array():-argument-1-must-be-of-type-mysqli_result-1657384360922"},{"title":"How to format numbers as currency strings","slug":"how-to-format-numbers-as-currency-strings-1657388399166"},{"title":"JavaScript closure inside loops โ simple practical example","slug":"javascript-closure-inside-loops-simple-practical-example-1657384278449"},{"title":"getContactsFromFirebase() method return an empty list","slug":"getcontactsfromfirebase()-method-return-an-empty-list-1657388433928"},{"title":"Accessing an array out of bounds gives no error, why?","slug":"accessing-an-array-out-of-bounds-gives-no-error-why-1657387979932"},{"title":"Are global variables thread-safe in Flask? How do I share data between requests?","slug":"are-global-variables-thread-safe-in-flask-how-do-i-share-data-between-requests-1657387949951"},{"title":"Non-static variable cannot be referenced from a static context","slug":"non-static-variable-cannot-be-referenced-from-a-static-context-1657387386240"},{"title":"Using LIMIT within GROUP BY to get N results per group?","slug":"using-limit-within-group-by-to-get-n-results-per-group-1657388324167"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"undefined-unspecified-and-implementation-defined-behavior-1657384516085"},"buildId":"BnkbnjkWYxefPXjTJLVVv","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>