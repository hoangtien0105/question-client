{"pageProps":{"data":{"answer":["\n&lt;p&gt;Simple: this is undefined behavior, since &lt;code&gt;fflush&lt;/code&gt; is meant to be called on an output stream. This is an excerpt from the C standard:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;int fflush(FILE *ostream);&lt;/p&gt;\n&lt;p&gt;ostream points to an output stream or\nan update stream in which the most\nrecent operation was not input, the\nfflush function causes any unwritten\ndata for that stream to be delivered\nto the host environment to be written\nto the file; otherwise, the behavior\nis undefined.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;So it&apos;s not a question of &quot;how bad&quot; this is. &lt;code&gt;fflush(stdin)&lt;/code&gt; is simply not portable, so you should not use it if you want your code to be portable between compilers.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;sup&gt;&lt;em&gt;Converting comments into an answer.&lt;/em&gt;&lt;/sup&gt;&lt;/p&gt;\n&lt;h1&gt;TL;DR  &lt;em&gt;&lt;strong&gt;Portable code doesn&apos;t use &lt;code&gt;fflush(stdin)&lt;/code&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/h1&gt;\n&lt;p&gt;The rest of this answer explains why portable code does not use &lt;code&gt;fflush(stdin)&lt;/code&gt;.  It is tempting to add &quot;reliable code doesn&apos;t use &lt;code&gt;fflush(stdin)&lt;/code&gt;&quot;, which is also generally true.&lt;/p&gt;\n&lt;h2&gt;Standard C and POSIX leave &lt;code&gt;fflush(stdin)&lt;/code&gt; as undefined behaviour&lt;/h2&gt;\n&lt;p&gt;The &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fflush.html&quot; rel=&quot;noreferrer&quot;&gt;POSIX&lt;/a&gt;, C and C++ standards for &lt;code&gt;fflush()&lt;/code&gt; explicitly state that the behaviour is undefined (because &lt;code&gt;stdin&lt;/code&gt; is an input stream), but none of them prevent a system from defining it.&lt;/p&gt;\n&lt;p&gt;ISO/IEC 9899:2011 &amp;nbsp;the C11 Standard  says:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;h3&gt;&lt;a href=&quot;http://port70.net/%7Ensz/c/c11/n1570.html#7.21.5.2&quot; rel=&quot;noreferrer&quot;&gt;§7.21.5.2 The fflush function&lt;/a&gt;&lt;/h3&gt;\n&lt;p&gt;¶2 If &lt;code&gt;stream&lt;/code&gt; points to an output stream or an update stream in which the most recent operation was not input, the &lt;code&gt;fflush&lt;/code&gt; function causes any unwritten data for that stream to be delivered to the host environment to be written to the file; otherwise, the behavior is undefined.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;POSIX mostly defers to the C standard but it does mark this text as a C extension.&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;[CX]  For a stream open for reading, if the file is not already at EOF, and the file is one capable of seeking, the file offset of the underlying open file description shall be set to the file position of the stream, and any characters pushed back onto the stream by &lt;code&gt;ungetc()&lt;/code&gt; or &lt;code&gt;ungetwc()&lt;/code&gt; that have not subsequently been read from the stream shall be discarded (without further changing the file offset). &lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Note that terminals are not capable of seeking; neither are pipes or sockets.&lt;/p&gt;\n&lt;h2&gt;Microsoft defines the behaviour of &lt;code&gt;fflush(stdin)&lt;/code&gt;&lt;/h2&gt;\n&lt;p&gt;In 2015, &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/9yky46tz.aspx&quot; rel=&quot;noreferrer&quot;&gt;Microsoft&lt;/a&gt; and the Visual Studio runtime used to define the behaviour of &lt;code&gt;fflush()&lt;/code&gt; on an input stream like this (but the link leads to different text in 2021):&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;If the stream is open for input, &lt;code&gt;fflush&lt;/code&gt; clears the contents of the buffer.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/users/1505939/m-m&quot;&gt;M.M&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/questions/2979209/using-fflushstdin#comment40866432_2979209&quot;&gt;notes&lt;/a&gt;:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Cygwin is an example of a fairly common platform on which &lt;code&gt;fflush(stdin)&lt;/code&gt; does not clear the input.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;This is why this answer version of my &lt;a href=&quot;https://stackoverflow.com/questions/2979209/using-fflushstdin#comment31066899_2979209&quot;&gt;comment&lt;/a&gt; notes &apos;Microsoft and the Visual Studio runtime&apos;  if you use a non-Microsoft C runtime library, the behaviour you see depends on that library.&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/users/4142924/weather-vane&quot;&gt;Weather Vane&lt;/a&gt; pointed out to me in a comment to another question that, at some time before June 2021, Microsoft changed its description of &lt;a href=&quot;https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fflush?view=msvc-160&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;fflush()&lt;/code&gt;&lt;/a&gt; compared with what was originally specified when this answer was written in 2015.  It now says:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;If the stream was opened in read mode, or if the stream has no buffer, the call to &lt;code&gt;fflush&lt;/code&gt; has no effect, and any buffer is retained. A call to &lt;code&gt;fflush&lt;/code&gt; negates the effect of any prior call to &lt;code&gt;ungetc&lt;/code&gt; for the stream.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;a href=&quot;https://en.wiktionary.org/wiki/caveat_lector&quot; rel=&quot;noreferrer&quot;&gt;&lt;em&gt;Caveat Lector:&lt;/em&gt;&lt;/a&gt; it is probably best not to rely on &lt;code&gt;fflush(stdin)&lt;/code&gt; on any platform.&lt;/p&gt;\n&lt;h2&gt;Linux documentation and practice seem to contradict each other&lt;/h2&gt;\n&lt;p&gt;Surprisingly, &lt;a href=&quot;http://linux.die.net/man/3/fflush&quot; rel=&quot;noreferrer&quot;&gt;Linux&lt;/a&gt; nominally documents the behaviour of &lt;code&gt;fflush(stdin)&lt;/code&gt; too, and even defines it the same way (miracle of miracles).  This quote is from 2015.&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;For input streams, &lt;code&gt;fflush()&lt;/code&gt; discards any buffered data that has been fetched from the underlying file, but has not been consumed by the application.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;In 2021, the quote changes to:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;For input streams, &lt;code&gt;fflush()&lt;/code&gt; discards any buffered data that has been fetched from the underlying file, but has not been consumed by the application. The open status of the stream is unaffected.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;And another source for &lt;a href=&quot;http://man7.org/linux/man-pages/man3/fflush.3.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;fflush(3)&lt;/code&gt;&lt;/a&gt; on Linux agrees (give or take paragraph breaks):&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;For input streams associated with seekable files (e.g., disk files, but not pipes or terminals), &lt;code&gt;fflush()&lt;/code&gt; discards any buffered data that has been fetched from the underlying file, but has not been consumed by the application.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Neither of these explicitly addresses the points made by the POSIX specification about &lt;code&gt;ungetc()&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;In 2021, &lt;a href=&quot;https://stackoverflow.com/users/388520/zwol&quot;&gt;zwol&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/questions/2979209/using-fflushstdin/34247021?noredirect=1#comment120026978_34247021&quot;&gt;commented&lt;/a&gt; that the Linux documentation has been improved.\nIt seems to me that there is still room for improvement.&lt;/p&gt;\n&lt;p&gt;In 2015, I was a bit puzzled and surprised at the Linux documentation saying that &lt;code&gt;fflush(stdin)&lt;/code&gt; will work.\nDespite that suggestion, it most usually does not work on Linux.  I just checked the documentation on Ubuntu 14.04 LTS; it says what is quoted above, but empirically, it does not work &amp;nbsp;at least when the input stream is a non-seekable device such as a terminal.&lt;/p&gt;\n&lt;h3&gt;&lt;code&gt;demo-fflush.c&lt;/code&gt;&lt;/h3&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; c;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ((c = getchar()) != EOF)\n    {\n        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Got %c; enter some new data\\n&quot;&lt;/span&gt;, c);\n        fflush(&lt;span class=&quot;hljs-built_in&quot;&gt;stdin&lt;/span&gt;);\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ((c = getchar()) != EOF)\n        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Got %c\\n&quot;&lt;/span&gt;, c);\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;Example output&lt;/h3&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;$ ./demo-fflush\nAlliteration\nGot A; enter some new data\nGot l\n$\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This output was obtained on both Ubuntu 14.04 LTS and Mac OS X 10.11.2.  To my understanding, it contradicts what the Linux manual says.  If the &lt;code&gt;fflush(stdin)&lt;/code&gt; operation worked, I would have to type a new line of text to get information for the second &lt;code&gt;getchar()&lt;/code&gt; to read.&lt;/p&gt;\n&lt;p&gt;Given what the POSIX standard says, maybe a better demonstration is needed, and the Linux documentation should be clarified.&lt;/p&gt;\n&lt;h3&gt;&lt;code&gt;demo-fflush2.c&lt;/code&gt;&lt;/h3&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; c;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ((c = getchar()) != EOF)\n    {\n        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Got %c\\n&quot;&lt;/span&gt;, c);\n        ungetc(&lt;span class=&quot;hljs-string&quot;&gt;&apos;B&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-built_in&quot;&gt;stdin&lt;/span&gt;);\n        ungetc(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Z&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-built_in&quot;&gt;stdin&lt;/span&gt;);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ((c = getchar()) == EOF)\n        {\n            &lt;span class=&quot;hljs-built_in&quot;&gt;fprintf&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;stderr&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Huh?!\\n&quot;&lt;/span&gt;);\n            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n        }\n        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Got %c after ungetc()\\n&quot;&lt;/span&gt;, c);\n        fflush(&lt;span class=&quot;hljs-built_in&quot;&gt;stdin&lt;/span&gt;);\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ((c = getchar()) != EOF)\n        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Got %c\\n&quot;&lt;/span&gt;, c);\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;Example output&lt;/h3&gt;\n&lt;p&gt;Note that &lt;code&gt;/etc/passwd&lt;/code&gt; is a seekable file.  On Ubuntu, the first line looks like:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;root:x:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;:root:/root:/bin/bash\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;On Mac OS X, the first 4 lines look like:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;##\n# User Database\n# \n# Note that this file is consulted directly only when the system is running\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In other words, there is commentary at the top of the Mac OS X &lt;code&gt;/etc/passwd&lt;/code&gt; file.  The non-comment lines conform to the normal layout, so the &lt;code&gt;root&lt;/code&gt; entry is:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;root:*:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;:System Administrator:/var/root:/bin/sh\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Ubuntu 14.04 LTS:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;$ ./demo-fflush2 &amp;lt; /etc/passwd\nGot r\nGot Z after &lt;span class=&quot;hljs-title function_&quot;&gt;ungetc&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\nGot o\n$ ./demo-fflush2\nAllotrope\nGot A\nGot Z after &lt;span class=&quot;hljs-title function_&quot;&gt;ungetc&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\nGot B\n$\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Mac OS X 10.11.2:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;$ ./demo-fflush2 &amp;lt; /etc/passwd\nGot #\nGot Z after &lt;span class=&quot;hljs-title function_&quot;&gt;ungetc&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\nGot B\n$\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The Mac OS X behaviour ignores (or at least seems to ignore) the &lt;code&gt;fflush(stdin)&lt;/code&gt; (thus not following POSIX on this issue).  The Linux behaviour corresponds to the documented POSIX behaviour, but the POSIX specification is far more careful in what it says  it specifies a file capable of seeking, but terminals, of course, do not support seeking.  It is also much less useful than the Microsoft specification.&lt;/p&gt;\n&lt;h2&gt;Summary&lt;/h2&gt;\n&lt;p&gt;Microsoft documents the behaviour of &lt;code&gt;fflush(stdin)&lt;/code&gt;, but that behaviour has changed between 2015 and 2021.  Apparently, it works as documented on the Windows platform, using the native Windows compiler and C runtime support libraries.&lt;/p&gt;\n&lt;p&gt;Despite documentation to the contrary, it does not work on Linux when the standard input is a terminal, but it seems to follow the POSIX specification which is far more carefully worded.  According to the C standard, the behaviour of &lt;code&gt;fflush(stdin)&lt;/code&gt; is undefined.  POSIX adds the qualifier &apos;unless the input file is seekable&apos;, which a terminal is not.  The behaviour is not the same as Microsoft&apos;s.&lt;/p&gt;\n&lt;p&gt;Consequently, &lt;em&gt;&lt;strong&gt;portable code does not use &lt;code&gt;fflush(stdin)&lt;/code&gt;&lt;/strong&gt;&lt;/em&gt;.  Code that is tied to Microsoft&apos;s platform may use it and it may work as expected, but beware of the portability issues.&lt;/p&gt;\n&lt;h3&gt;POSIX way to discard unread terminal input from a file descriptor&lt;/h3&gt;\n&lt;p&gt;The POSIX standard way to discard unread information from a terminal file descriptor (as opposed to a file stream like &lt;code&gt;stdin&lt;/code&gt;) is illustrated at &lt;a href=&quot;https://stackoverflow.com/questions/10938882/how-can-i-flush-unread-data-from-a-tty-input-queue-on-a-unix-system&quot;&gt;How can I flush unread data from a tty input queue on a Unix system&lt;/a&gt;.  However, that is operating below the standard I/O library level.&lt;/p&gt;\n    ","\n&lt;p&gt;According to the standard, &lt;code&gt;fflush&lt;/code&gt; can only be used with output buffers, and obviously &lt;code&gt;stdin&lt;/code&gt; isn&apos;t one. However, &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/9yky46tz.aspx&quot; rel=&quot;nofollow noreferrer&quot;&gt;some&lt;/a&gt; standard C libraries provide the use of &lt;code&gt;fflush(stdin)&lt;/code&gt; as an extension. In that case you can use it, but it will affect portability, so you will no longer be able to use any standards-compliant standard C library on earth and expect the same results.&lt;/p&gt;\n    ","\n&lt;p&gt;I believe that you should never call &lt;code&gt;fflush(stdin)&lt;/code&gt;, and for the simple reason that you should never even find it necessary to try to flush input in the first place.  Realistically, there is only one reason you might think you had to flush input, and that is: to get past some bad input that &lt;code&gt;scanf&lt;/code&gt; is stuck on.&lt;/p&gt;\n&lt;p&gt;For example, you might have a program that is sitting in a loop reading integers using &lt;code&gt;scanf(&quot;%d&quot;, &amp;amp;n)&lt;/code&gt;.  Soon enough you&apos;ll discover that the first time the user types a non-digit character like &lt;code&gt;&apos;x&apos;&lt;/code&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/1716013/why-is-scanf-causing-infinite-loop-in-this-code&quot;&gt;the program goes into an infinite loop&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;When faced with this situation, I believe you basically have three choices:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Flush the input somehow (if not by using &lt;code&gt;fflush(stdin)&lt;/code&gt;, then by calling &lt;code&gt;getchar&lt;/code&gt; in a loop to read characters until &lt;code&gt;\\n&lt;/code&gt;, as is often recommended).&lt;/li&gt;\n&lt;li&gt;Tell the user not to type non-digit characters when digits are expected.&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/58403537/what-can-i-use-to-parse-input-instead-of-scanf&quot;&gt;Use something other than &lt;code&gt;scanf&lt;/code&gt; to read input&lt;/a&gt;.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;Now, if you&apos;re a beginner, &lt;code&gt;scanf&lt;/code&gt; &lt;em&gt;seems&lt;/em&gt; like the easiest way to read input, and so choice #3 looks scary and difficult.  But #2 seems like a real cop-out, because everyone knows that user-unfriendly computer programs are a problem, so it&apos;d be nice to do better.  So all too many beginning programmers get painted into a corner, feeling that they have no choice but to do #1.  They more or less have to do input using &lt;code&gt;scanf&lt;/code&gt;, meaning that it will get stuck on bad input, meaning that they have to figure out a way to flush the bad input, meaning that they&apos;re sorely tempted to use &lt;code&gt;fflush(stdin)&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;I would like to encourage all beginning C programmers out there to make a different set of tradeoffs:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;During the earliest stages of your C programming career, before you&apos;re comfortable using anything other than &lt;code&gt;scanf&lt;/code&gt;, just &lt;em&gt;don&apos;t worry about bad input&lt;/em&gt;.  Really.  Go ahead and use cop-out #2 above.  Think about it like this: You&apos;re a beginner, there are lots of things you don&apos;t know how to do yet, and one of the things you don&apos;t know how to do yet is: deal gracefully with unexpected input.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;As soon as you can, &lt;a href=&quot;https://stackoverflow.com/questions/58403537/what-can-i-use-to-parse-input-instead-of-scanf&quot;&gt;learn how to do input using functions other than &lt;code&gt;scanf&lt;/code&gt;&lt;/a&gt;.  At that point, you can start dealing gracefully with bad input, and you&apos;ll have many more, much better techniques available to you, that won&apos;t require trying to &quot;flush the bad input&quot; at all.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;Or, in other words, beginners who are still stuck using &lt;code&gt;scanf&lt;/code&gt; should feel free to use cop-out #2, and when they&apos;re ready they should graduate from there to technique #3, and nobody should be using technique #1 to try to flush input at all -- and certainly not with &lt;code&gt;fflush(stdin)&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;Using &lt;code&gt;fflush(stdin)&lt;/code&gt; to flush input is kind of like &lt;a href=&quot;https://en.wikipedia.org/wiki/Dowsing&quot; rel=&quot;nofollow noreferrer&quot;&gt;dowsing for water&lt;/a&gt; using a stick shaped like the letter &quot;S&quot;.&lt;/p&gt;\n&lt;p&gt;And helping people to flush input in some &quot;better&quot; way is kind of like rushing up to an S-stick dowser and saying &quot;No, no, you&apos;re doing it wrong,\nyou need to use a Y-shaped stick!&quot;.&lt;/p&gt;\n&lt;p&gt;In other words, the real problem isn&apos;t that &lt;code&gt;fflush(stdin)&lt;/code&gt; doesn&apos;t work.  Calling &lt;code&gt;fflush(stdin)&lt;/code&gt; is a symptom of an underlying problem.  Why are you having to &quot;flush&quot; input at all?  &lt;em&gt;That&apos;s&lt;/em&gt; your problem.&lt;/p&gt;\n&lt;p&gt;And, usually, that underlying problem is that you&apos;re using &lt;code&gt;scanf&lt;/code&gt;, in one of its many unhelpful modes that unexpectedly leaves newlines or other &quot;unwanted&quot; text on the input.  The best long-term solution, therefore, is to &lt;a href=&quot;https://stackoverflow.com/questions/58403537/what-can-i-use-for-input-conversion-instead-of-scanf&quot;&gt;learn how to do input using better techniques than &lt;code&gt;scanf&lt;/code&gt;&lt;/a&gt;, so that you don&apos;t have to deal with its unhandled input and other idiosyncrasies at all.&lt;/p&gt;\n    ","\n&lt;p&gt;None of the existing answers point out a key aspect of the issue.&lt;/p&gt;\n&lt;p&gt;If you find yourself &lt;em&gt;wanting&lt;/em&gt; to &quot;clear the input buffer&quot;, you&apos;re probably writing a command-line interactive program, and it would be more accurate to say that what you want is to &lt;em&gt;discard characters from the current &lt;strong&gt;line&lt;/strong&gt; of input that you haven&apos;t already read.&lt;/em&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;This is not what &lt;code&gt;fflush(stdin)&lt;/code&gt; does.&lt;/strong&gt;  The C libraries that support using &lt;code&gt;fflush&lt;/code&gt; on an input stream, document it as either doing &lt;em&gt;nothing,&lt;/em&gt; or as discarding &lt;em&gt;buffered data that has been read from the underlying file but not passed to the application&lt;/em&gt;.  That can easily be either &lt;em&gt;more&lt;/em&gt; or &lt;em&gt;less&lt;/em&gt; input than the rest of the current line.  It probably does work by accident in a lot of cases, because the terminal driver (in its default mode) supplies input to a command-line interactive program one line at a time.  However, the moment you try to feed input to your program from an actual file on disk (perhaps for automated testing), the kernel and C library will switch over to buffering data in large &quot;blocks&quot; (often 4 to 8 kB) with no relationship to line boundaries, and you&apos;ll be wondering why your program is processing the first line of the file and then skipping several dozen lines and picking up in the &lt;em&gt;middle&lt;/em&gt; of some apparently random line below.  Or, if you decide to test your program on a very &lt;em&gt;long&lt;/em&gt; line typed by hand, then the terminal driver won&apos;t be able to give the program the whole line at once and &lt;code&gt;fflush(stdin)&lt;/code&gt; won&apos;t skip all of it.&lt;/p&gt;\n&lt;p&gt;So what should you do instead?  The approach that I prefer is, if you&apos;re processing input one line at a time, then &lt;em&gt;read an entire line all at once&lt;/em&gt;.  The C library has functions specifically for this: &lt;code&gt;fgets&lt;/code&gt; (in C90, so fully portable, but does still make you process very long lines in chunks) and &lt;code&gt;getline&lt;/code&gt; (POSIX-specific, but will manage a &lt;code&gt;malloc&lt;/code&gt;ed buffer for you so you can process long lines all at once no matter how long they get).  There&apos;s usually a direct translation from code that processes &quot;the current line&quot; directly from stdin to code that processes a string containing &quot;the current line&quot;.&lt;/p&gt;\n    ","\n&lt;p&gt;Quote from &lt;a href=&quot;https://www.unix.com/man-page/posix/3P/fflush/&quot; rel=&quot;nofollow noreferrer&quot; title=&quot;POSIX&quot;&gt;POSIX&lt;/a&gt;:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;For  a  stream  open  for  reading, if the file is not already at EOF, and the file is one\ncapable of seeking, the file offset of the underlying open file description shall  be  set\nto  the   file  position  of  the stream, and any characters pushed back onto the stream by\nungetc() or ungetwc() that have not subsequently been read from the stream shall  be  dis-\ncarded (without further changing the file offset).&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Note that terminal is not capable of seeking.&lt;/p&gt;\n    "],"comment":["\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;&lt;a href=&quot;http://www.codinghorror.com/blog/2007/03/the-works-on-my-machine-certification-program.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;codinghorror.com/blog/2007/03/&lt;/a&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/238419/blueraja-danny-pflughoeft&quot; title=&quot;80,453 reputation&quot; class=&quot;comment-user&quot;&gt;BlueRaja - Danny Pflughoeft&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment3040087_2979209&quot;&gt;&lt;span title=&quot;2010-06-05 04:51:54Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Jun 5, 2010 at 4:51&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Both &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/9yky46tz.aspx&quot; rel=&quot;nofollow noreferrer&quot;&gt;Windows&lt;/a&gt; and &lt;a href=&quot;http://linux.die.net/man/3/fflush&quot; rel=&quot;nofollow noreferrer&quot;&gt;Linux&lt;/a&gt; define the behaviour of &lt;code&gt;fflush()&lt;/code&gt; on an input stream, and even define it the same way (miracle of miracles). The POSIX, C and C++ standards for &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fflush.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;fflush()&lt;/code&gt;&lt;/a&gt; do not define the behaviour, but none of them prevent a system from defining it. If you&apos;re coding for maximum portability, avoid &lt;code&gt;fflush(stdin)&lt;/code&gt;; if you&apos;re coding for platforms that define the behaviour, use it  but be aware that it is not portable.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/15168/jonathan-leffler&quot; title=&quot;700,786 reputation&quot; class=&quot;comment-user&quot;&gt;Jonathan Leffler&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment31066899_2979209&quot;&gt;&lt;span title=&quot;2013-12-22 22:13:15Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Dec 22, 2013 at 22:13&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Cygwin is an example of a fairly common platform on which &lt;code&gt;fflush(stdin);&lt;/code&gt; does not clear the input.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1505939/m-m&quot; title=&quot;135,063 reputation&quot; class=&quot;comment-user&quot;&gt;M.M&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment40866432_2979209&quot;&gt;&lt;span title=&quot;2014-09-28 02:41:23Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Sep 28, 2014 at 2:41&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;It also depends on exactly what you expect &lt;code&gt;fflush(stdin)&lt;/code&gt; to do.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/827263/keith-thompson&quot; title=&quot;243,248 reputation&quot; class=&quot;comment-user&quot;&gt;Keith Thompson&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment56237353_2979209&quot;&gt;&lt;span title=&quot;2015-12-13 03:54:15Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Dec 13, 2015 at 3:54&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@JonathanLeffler The windows doc says&lt;code&gt;If the stream was opened in read mode, or if the stream has no buffer, the call to fflush has no effect, and any buffer is retained&lt;/code&gt;, and the linux doc says &lt;code&gt;For input streams, fflush() discards any buffered data that has been fetched from the underlying file, but has not been consumed by the application.&lt;/code&gt; That&apos;s not exactly the same way, windows retains the buffer, and linux discards the buffer.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1983398/ssbssa&quot; title=&quot;1,171 reputation&quot; class=&quot;comment-user&quot;&gt;ssbssa&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment112195671_2979209&quot;&gt;&lt;span title=&quot;2020-08-17 10:26:18Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Aug 17, 2020 at 10:26&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@BlueRaja: there&apos;s defense for a newbie mistake here, but &lt;b&gt;no defense for a teacher&lt;/b&gt; propagating wrong knowledge! Any reference of &lt;code&gt;fflush&lt;/code&gt; makes clear it&apos;s meant for output streams right in the first paragraph, you don&apos;t have to memorize the C standard for that!&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/8206/eli-bendersky&quot; title=&quot;249,157 reputation&quot; class=&quot;comment-user&quot;&gt;Eli Bendersky&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment3040131_2979217&quot;&gt;&lt;span title=&quot;2010-06-05 05:04:14Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Jun 5, 2010 at 5:04&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@Eli: No one can know everything.  The processor will never know his mistake until someone tells him...  I used &lt;code&gt;fflush(stdin)&lt;/code&gt; for years until I discovered it&apos;s UB (by accident)&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/238419/blueraja-danny-pflughoeft&quot; title=&quot;80,453 reputation&quot; class=&quot;comment-user&quot;&gt;BlueRaja - Danny Pflughoeft&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment3040135_2979217&quot;&gt;&lt;span title=&quot;2010-06-05 05:06:17Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Jun 5, 2010 at 5:06&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Err, shouldn&apos;t one normally consult the documentation for a function before they use it? Especially a professor?&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/112950/alex-budovski&quot; title=&quot;17,308 reputation&quot; class=&quot;comment-user&quot;&gt;Alex Budovski&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment3040190_2979217&quot;&gt;&lt;span title=&quot;2010-06-05 05:28:50Z, License: CC BY-SA 2.5&quot; class=&quot;relativetime-clean&quot;&gt;Jun 5, 2010 at 5:28&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Another point of defense would be the following part of the man page (various glibc versions on Linux): &quot;For input streams, &lt;code&gt;fflush()&lt;/code&gt; discards any buffered data that has been fetched from the underlying file, but has not  been  consumed by the application.  The open status of the stream is unaffected.&quot; Although it&apos;s UB, some implementations seem to make guarantees without mentioning its status with respect to the standard.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/1011995/daniel-fischer&quot; title=&quot;178,868 reputation&quot; class=&quot;comment-user&quot;&gt;Daniel Fischer&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment17854093_2979217&quot;&gt;&lt;span title=&quot;2012-10-29 20:23:39Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Oct 29, 2012 at 20:23&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;There&apos;s another aspect that I seldom see mentioned: &lt;code&gt;fflush(stdin)&lt;/code&gt; is much worse than just implementation-defined behavior. &lt;b&gt;Even if it did work as most people intend to, it would terrible.&lt;/b&gt; Imagine if stdin is not someone dumbly typing input, but came from another program or shell redirection: it would read the beginning of the file and then just erase the rest. It is really dumb to think that stdin is always something so slow as a human operator.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/340862/rafael-lerm&quot; title=&quot;1,210 reputation&quot; class=&quot;comment-user&quot;&gt;Rafael Lerm&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment44399135_2979217&quot;&gt;&lt;span title=&quot;2015-01-17 23:14:23Z, License: CC BY-SA 3.0&quot; class=&quot;relativetime-clean&quot;&gt;Jan 17, 2015 at 23:14&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;That is probably the better answer in the context of what the OP asked for, although the accepted one is not wrong. To show clearly that it isn´t standard-compliant on one side, but showing that it might be right used on a specific implementation on the other. +1&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/12139179/roberts-supports-monica-cellio&quot; title=&quot;13,801 reputation&quot; class=&quot;comment-user&quot;&gt;RobertS supports Monica Cellio&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment109152967_34247021&quot;&gt;&lt;span title=&quot;2020-05-10 08:02:33Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;May 10, 2020 at 8:02&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;The Linux manpage has been corrected since this answer was written.  It now reads &quot;For input streams &lt;i&gt;associated with seekable files (e.g., disk files, but not pipes or terminals)&lt;/i&gt;, fflush() discards any buffered data ...&quot;  (added text in italics) I can also personally attest that glibc never intended to extend the behavior of fflush beyond what is specified by POSIX.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/388520/zwol&quot; title=&quot;129,617 reputation&quot; class=&quot;comment-user&quot;&gt;zwol&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment120026978_34247021&quot;&gt;&lt;span title=&quot;2021-06-09 15:04:39Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 9, 2021 at 15:04&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 1 time&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@zwol  I&apos;ve updated the answer once more with revised quotes from the Linux manuals (as found on man7.org and die.net).  Those manual pages are better, but still don&apos;t specify what the POSIX standard specifies about discarding characters pushed back by &lt;code&gt;ungetc()&lt;/code&gt;.  IMO, they still concentrate a bit too much on absolute minimality to the detriment of clarity of intent.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/15168/jonathan-leffler&quot; title=&quot;700,786 reputation&quot; class=&quot;comment-user&quot;&gt;Jonathan Leffler&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment120061972_34247021&quot;&gt;&lt;span title=&quot;2021-06-10 18:47:46Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 10, 2021 at 18:47&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@JonathanLeffler You might want to raise the issue with &amp;lt;linux-man@vger.kernel.org&amp;gt;.  They&apos;ve been very responsive to suggested corrections in my experience.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/388520/zwol&quot; title=&quot;129,617 reputation&quot; class=&quot;comment-user&quot;&gt;zwol&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment120063772_34247021&quot;&gt;&lt;span title=&quot;2021-06-10 20:09:45Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 10, 2021 at 20:09&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;One point to nitpick because it is a little ambiguous I think and someone might get you wrong: &quot;&lt;i&gt;Flush the input somehow (if not by using &lt;code&gt;fflush(stdin)&lt;/code&gt;, then by calling &lt;code&gt;getchar&lt;/code&gt; to read characters until &lt;code&gt;\\n&lt;/code&gt;, as is often recommended).&lt;/i&gt;&quot; - One call to &lt;code&gt;getchar()&lt;/code&gt; doesn´t read character&lt;b&gt;s&lt;/b&gt; until it finds &lt;code&gt;\\n&lt;/code&gt;. If there are several characters, one call to &lt;code&gt;getchar()&lt;/code&gt; will only fetch the last character entered, not all up to and also not including the newline. Furthermore, &lt;code&gt;getchar()&lt;/code&gt; also can consume a newline.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/12139179/roberts-supports-monica-cellio&quot; title=&quot;13,801 reputation&quot; class=&quot;comment-user&quot;&gt;RobertS supports Monica Cellio&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment109154076_58884121&quot;&gt;&lt;span title=&quot;2020-05-10 09:05:43Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;May 10, 2020 at 9:05&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@RobertSsupportsMonicaCellio Good point, and I don&apos;t know why it took so long for me to address it.  Wording adjusted to &quot;calling &lt;code&gt;getchar&lt;/code&gt; in a loop&quot;.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/3923896/steve-summit&quot; title=&quot;38,556 reputation&quot; class=&quot;comment-user&quot;&gt;Steve Summit&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment117116636_58884121&quot;&gt;&lt;span title=&quot;2021-02-17 14:51:18Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Feb 17, 2021 at 14:51&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n                        &lt;span title=&quot;this comment was edited 2 times&quot;&gt;\n                            &lt;svg aria-hidden=&quot;true&quot; class=&quot;va-text-bottom o50 svg-icon iconPencilSm&quot; width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot;&gt;&lt;path d=&quot;m11.1 1.71 1.13 1.12c.2.2.2.51 0 .71L11.1 4.7 9.21 2.86l1.17-1.15c.2-.2.51-.2.71 0ZM2 10.12l6.37-6.43 1.88 1.88L3.88 12H2v-1.88Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n                        &lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Though I guess you forgot about this answer &lt;a href=&quot;https://stackoverflow.com/a/58884121/918959&quot;&gt;stackoverflow.com/a/58884121/918959&lt;/a&gt;&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/918959/antti-haapala-%d0%a1%d0%bb%d0%b0%d0%b2%d0%b0-%d0%a3%d0%ba%d1%80%d0%b0%d1%97%d0%bd%d1%96&quot; title=&quot;124,211 reputation&quot; class=&quot;comment-user&quot;&gt;Antti Haapala -- Слава Україні&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment113367968_61408683&quot;&gt;&lt;span title=&quot;2020-09-28 21:20:17Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Sep 28, 2020 at 21:20&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@AnttiHaapala Thanks for the pointer, but, no, I didn&apos;t forget; both answers are linked in my notes on this topic. There are yet more good, canonical answers at &lt;a href=&quot;https://stackoverflow.com/questions/34219549/&quot;&gt;stackoverflow.com/questions/34219549&lt;/a&gt; .&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/3923896/steve-summit&quot; title=&quot;38,556 reputation&quot; class=&quot;comment-user&quot;&gt;Steve Summit&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment113381798_61408683&quot;&gt;&lt;span title=&quot;2020-09-29 10:23:16Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Sep 29, 2020 at 10:23&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;What I mean is they&apos;re on the same question :D&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/918959/antti-haapala-%d0%a1%d0%bb%d0%b0%d0%b2%d0%b0-%d0%a3%d0%ba%d1%80%d0%b0%d1%97%d0%bd%d1%96&quot; title=&quot;124,211 reputation&quot; class=&quot;comment-user&quot;&gt;Antti Haapala -- Слава Україні&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment113384389_61408683&quot;&gt;&lt;span title=&quot;2020-09-29 11:58:16Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Sep 29, 2020 at 11:58&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@AnttiHaapala Yes, I get that.  When I posted the second one, SO asked me &quot;You already have an answer to this question, are you sure you want to answer again?&quot;, and I answered, &quot;Yes.&quot;  For these eternal questions, I&apos;m always trying to find different/better/alternative ways of answering them.  (Another example is &lt;a href=&quot;https://stackoverflow.com/questions/949433/&quot;&gt;stackoverflow.com/questions/949433&lt;/a&gt; .)&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/3923896/steve-summit&quot; title=&quot;38,556 reputation&quot; class=&quot;comment-user&quot;&gt;Steve Summit&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment113385178_61408683&quot;&gt;&lt;span title=&quot;2020-09-29 12:24:04Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Sep 29, 2020 at 12:24&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;but as &lt;code&gt;Eli Bendersky&lt;/code&gt; Mentioned fflush is meant to be used on output stream. so if we use on &lt;code&gt;stdin&lt;/code&gt; causes &lt;code&gt;UB&lt;/code&gt; .&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/11862989/abhishek-mane&quot; title=&quot;583 reputation&quot; class=&quot;comment-user&quot;&gt;Abhishek Mane&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment120155350_67906660&quot;&gt;&lt;span title=&quot;2021-06-15 05:37:34Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 15, 2021 at 5:37&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;@AbhishekMane C implementations are allowed to define behavior left undefined by the standard, and C programs are free to rely on such definitions; it just makes them less than perfectly portable. The point of this answer is that &lt;i&gt;even if you are OK with relying on implementation extensions&lt;/i&gt;, using &lt;code&gt;fflush(stdin)&lt;/code&gt; is still a mistake, because the common implementation extensions for &lt;code&gt;fflush(stdin)&lt;/code&gt; don&apos;t do what you actually want.&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/388520/zwol&quot; title=&quot;129,617 reputation&quot; class=&quot;comment-user&quot;&gt;zwol&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment120166311_67906660&quot;&gt;&lt;span title=&quot;2021-06-15 13:08:46Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 15, 2021 at 13:08&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        ","\n            &lt;div class=&quot;comment-body js-comment-edit-hide&quot;&gt;\n                \n                &lt;span class=&quot;comment-copy&quot;&gt;Now got it. Thanks&lt;/span&gt;\n                \n              &lt;div class=&quot;d-inline-flex ai-center&quot;&gt;\n&amp;nbsp;&lt;a href=&quot;/users/11862989/abhishek-mane&quot; title=&quot;583 reputation&quot; class=&quot;comment-user&quot;&gt;Abhishek Mane&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;span class=&quot;comment-date&quot; dir=&quot;ltr&quot;&gt;&lt;a class=&quot;comment-link&quot; href=&quot;#comment120169117_67906660&quot;&gt;&lt;span title=&quot;2021-06-15 14:40:40Z, License: CC BY-SA 4.0&quot; class=&quot;relativetime-clean&quot;&gt;Jun 15, 2021 at 14:40&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;\n            &lt;/div&gt;\n        "],"id":314,"title":"Using fflush(stdin)","content":"\n                \n&lt;p&gt;So a quick Google search for &lt;code&gt;fflush(stdin)&lt;/code&gt; for clearing the input buffer reveals numerous websites warning against using it. And yet that&apos;s exactly how my CS professor taught the class to do it.&lt;/p&gt;\n\n&lt;p&gt;How bad is using &lt;code&gt;fflush(stdin)&lt;/code&gt;? Should I really abstain from using it, even though my professor is using it and it seems to work flawlessly?&lt;/p&gt;\n    ","slug":"using-fflush(stdin)-1657387602771","postType":"QUESTION","createdAt":"2022-07-09T17:26:42.000Z","updatedAt":"2022-07-09T17:26:42.000Z","tags":[{"id":1849,"name":"stdin","slug":"stdin","createdAt":"2022-07-09T17:26:42.000Z","updatedAt":"2022-07-09T17:26:42.000Z","Questions_Tags":{"questionId":314,"tagId":1849}},{"id":1850,"name":"fflush","slug":"fflush","createdAt":"2022-07-09T17:26:42.000Z","updatedAt":"2022-07-09T17:26:42.000Z","Questions_Tags":{"questionId":314,"tagId":1850}}]}},"__N_SSG":true}