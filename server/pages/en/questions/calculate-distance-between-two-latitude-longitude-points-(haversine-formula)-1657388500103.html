<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>Calculate distance between two latitude-longitude points? (Haversine formula) | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="How do I calculate the distance between two points specified by latitude and longitude?

For clarification, I&#x27;d like the distance in kilometers; the points use the WGS84 system and I&#x27;d like to understand the relative accuracies of the approaches available.
    "/><meta property="og:title" content="Calculate distance between two latitude-longitude points? (Haversine formula) | Solutions Checker"/><meta property="og:description" content="How do I calculate the distance between two points specified by latitude and longitude?

For clarification, I&#x27;d like the distance in kilometers; the points use the WGS84 system and I&#x27;d like to understand the relative accuracies of the approaches available.
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Calculate distance between two latitude-longitude points? (Haversine formula)","text":"How do I calculate the distance between two points specified by latitude and longitude?\n\nFor clarification, I&apos;d like the distance in kilometers; the points use the WGS84 system and I&apos;d like to understand the relative accuracies of the approaches available.\n    ","answerCount":30,"upVoteCount":500,"suggestedAnswer":[{"text":"This link might be helpful to you, as it details the use of the Haversine formula to calculate the distance.\n\nExcerpt:\n\n\n\n\n  This script [in Javascript] calculates great-circle distances between the two points \n  that is, the shortest distance over the earths surface  using the\n  Haversine formula.\n\n\nfunction getDistanceFromLatLonInKm(lat1,lon1,lat2,lon2) {\n  var R = 6371; // Radius of the earth in km\n  var dLat = deg2rad(lat2-lat1);  // deg2rad below\n  var dLon = deg2rad(lon2-lon1); \n  var a = \n    Math.sin(dLat/2) * Math.sin(dLat/2) +\n    Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * \n    Math.sin(dLon/2) * Math.sin(dLon/2)\n    ; \n  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); \n  var d = R * c; // Distance in km\n  return d;\n}\n\nfunction deg2rad(deg) {\n  return deg * (Math.PI/180)\n}\n\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"I needed to calculate a lot of distances between the points for my project, so I went ahead and tried to optimize the code, I have found here. On average in different browsers my new implementation runs 2 times faster than the most upvoted answer.\nfunction distance(lat1, lon1, lat2, lon2) {\n  var p = 0.017453292519943295;    // Math.PI / 180\n  var c = Math.cos;\n  var a = 0.5 - c((lat2 - lat1) * p)/2 + \n          c(lat1 * p) * c(lat2 * p) * \n          (1 - c((lon2 - lon1) * p))/2;\n\n  return 12742 * Math.asin(Math.sqrt(a)); // 2 * R; R = 6371 km\n}\n\nYou can play with my jsPerf and see the results here.\nRecently I needed to do the same in python, so here is a python implementation:\nfrom math import cos, asin, sqrt, pi\n\ndef distance(lat1, lon1, lat2, lon2):\n    p = pi/180\n    a = 0.5 - cos((lat2-lat1)*p)/2 + cos(lat1*p) * cos(lat2*p) * (1-cos((lon2-lon1)*p))/2\n    return 12742 * asin(sqrt(a)) #2*R*asin...\n\nAnd for the sake of completeness: Haversine on Wikipedia.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"Here is a C# Implementation:\n\nstatic class DistanceAlgorithm\n{\n    const double PIx = 3.141592653589793;\n    const double RADIUS = 6378.16;\n\n    /// &lt;summary&gt;\n    /// Convert degrees to Radians\n    /// &lt;/summary&gt;\n    /// &lt;param name=&quot;x&quot;&gt;Degrees&lt;/param&gt;\n    /// &lt;returns&gt;The equivalent in radians&lt;/returns&gt;\n    public static double Radians(double x)\n    {\n        return x * PIx / 180;\n    }\n\n    /// &lt;summary&gt;\n    /// Calculate the distance between two places.\n    /// &lt;/summary&gt;\n    /// &lt;param name=&quot;lon1&quot;&gt;&lt;/param&gt;\n    /// &lt;param name=&quot;lat1&quot;&gt;&lt;/param&gt;\n    /// &lt;param name=&quot;lon2&quot;&gt;&lt;/param&gt;\n    /// &lt;param name=&quot;lat2&quot;&gt;&lt;/param&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    public static double DistanceBetweenPlaces(\n        double lon1,\n        double lat1,\n        double lon2,\n        double lat2)\n    {\n        double dlon = Radians(lon2 - lon1);\n        double dlat = Radians(lat2 - lat1);\n\n        double a = (Math.Sin(dlat / 2) * Math.Sin(dlat / 2)) + Math.Cos(Radians(lat1)) * Math.Cos(Radians(lat2)) * (Math.Sin(dlon / 2) * Math.Sin(dlon / 2));\n        double angle = 2 * Math.Atan2(Math.Sqrt(a), Math.Sqrt(1 - a));\n        return angle * RADIUS;\n    }\n\n}\n\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"Here is a java implementation of the Haversine formula.\n\npublic final static double AVERAGE_RADIUS_OF_EARTH_KM = 6371;\npublic int calculateDistanceInKilometer(double userLat, double userLng,\n  double venueLat, double venueLng) {\n\n    double latDistance = Math.toRadians(userLat - venueLat);\n    double lngDistance = Math.toRadians(userLng - venueLng);\n\n    double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)\n      + Math.cos(Math.toRadians(userLat)) * Math.cos(Math.toRadians(venueLat))\n      * Math.sin(lngDistance / 2) * Math.sin(lngDistance / 2);\n\n    double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n    return (int) (Math.round(AVERAGE_RADIUS_OF_EARTH_KM * c));\n}\n\n\nNote that here we are rounding the answer to the nearest km.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"Thanks very much for all this. I used the following code in my Objective-C iPhone app:\n\n\n\nconst double PIx = 3.141592653589793;\nconst double RADIO = 6371; // Mean radius of Earth in Km\n\ndouble convertToRadians(double val) {\n\n   return val * PIx / 180;\n}\n\n-(double)kilometresBetweenPlace1:(CLLocationCoordinate2D) place1 andPlace2:(CLLocationCoordinate2D) place2 {\n\n        double dlon = convertToRadians(place2.longitude - place1.longitude);\n        double dlat = convertToRadians(place2.latitude - place1.latitude);\n\n        double a = ( pow(sin(dlat / 2), 2) + cos(convertToRadians(place1.latitude))) * cos(convertToRadians(place2.latitude)) * pow(sin(dlon / 2), 2);\n        double angle = 2 * asin(sqrt(a));\n\n        return angle * RADIO;\n}\n\n\nLatitude and Longitude are in decimal. I didn&apos;t use min() for the asin() call as the distances that I&apos;m using are so small that they don&apos;t require it.\n\nIt gave incorrect answers until I passed in the values in Radians - now it&apos;s pretty much the same as the values obtained from Apple&apos;s Map app :-)\n\nExtra update:\n\nIf you are using iOS4 or later then Apple provide some methods to do this so the same functionality would be achieved with:\n\n-(double)kilometresBetweenPlace1:(CLLocationCoordinate2D) place1 andPlace2:(CLLocationCoordinate2D) place2 {\n\n    MKMapPoint  start, finish;\n\n\n    start = MKMapPointForCoordinate(place1);\n    finish = MKMapPointForCoordinate(place2);\n\n    return MKMetersBetweenMapPoints(start, finish) / 1000;\n}\n\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"This is a simple PHP function that will give a very reasonable approximation (under +/-1% error margin).  \n\n&lt;?php\nfunction distance($lat1, $lon1, $lat2, $lon2) {\n\n    $pi80 = M_PI / 180;\n    $lat1 *= $pi80;\n    $lon1 *= $pi80;\n    $lat2 *= $pi80;\n    $lon2 *= $pi80;\n\n    $r = 6372.797; // mean radius of Earth in km\n    $dlat = $lat2 - $lat1;\n    $dlon = $lon2 - $lon1;\n    $a = sin($dlat / 2) * sin($dlat / 2) + cos($lat1) * cos($lat2) * sin($dlon / 2) * sin($dlon / 2);\n    $c = 2 * atan2(sqrt($a), sqrt(1 - $a));\n    $km = $r * $c;\n\n    //echo &apos;&lt;br/&gt;&apos;.$km;\n    return $km;\n}\n?&gt;\n\n\nAs said before; the earth is NOT a sphere.  It is like an old, old baseball that Mark McGwire decided to practice with - it is full of dents and bumps.  The simpler calculations (like this) treat it like a sphere.\n\nDifferent methods may be more or less precise according to where you are on this irregular ovoid AND how far apart your points are (the closer they are the smaller the absolute error margin).  The more precise your expectation, the more complex the math.\n\nFor more info: wikipedia geographic distance\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"I post here my working example.\n\nList all points in table having distance between a designated point (we use a random point - lat:45.20327, long:23.7806) less than 50 KM, with latitude &amp; longitude, in MySQL (the table fields are coord_lat and coord_long):\n\nList all having DISTANCE&lt;50, in Kilometres (considered Earth radius 6371 KM):\n\nSELECT denumire, (6371 * acos( cos( radians(45.20327) ) * cos( radians( coord_lat ) ) * cos( radians( 23.7806 ) - radians(coord_long) ) + sin( radians(45.20327) ) * sin( radians(coord_lat) ) )) AS distanta \nFROM obiective \nWHERE coord_lat&lt;&gt;&apos;&apos; \n    AND coord_long&lt;&gt;&apos;&apos; \nHAVING distanta&lt;50 \nORDER BY distanta desc\n\n\nThe above example was tested in MySQL 5.0.95 and 5.5.16 (Linux). \n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"In the other answers an implementation in r is missing.\n\nCalculating the distance between two point is quite straightforward with the distm function from the geosphere package:\n\ndistm(p1, p2, fun = distHaversine)\n\n\nwhere:\n\np1 = longitude/latitude for point(s)\np2 = longitude/latitude for point(s)\n# type of distance calculation\nfun = distCosine / distHaversine / distVincentySphere / distVincentyEllipsoid \n\n\nAs the earth is not perfectly spherical, the Vincenty formula for ellipsoids is probably the best way to calculate distances. Thus in the geosphere package you use then:\n\ndistm(p1, p2, fun = distVincentyEllipsoid)\n\n\n\n\nOff course you don&apos;t necessarily have to use geosphere package, you can also calculate the distance in base R with a function:\n\nhav.dist &lt;- function(long1, lat1, long2, lat2) {\n  R &lt;- 6371\n  diff.long &lt;- (long2 - long1)\n  diff.lat &lt;- (lat2 - lat1)\n  a &lt;- sin(diff.lat/2)^2 + cos(lat1) * cos(lat2) * sin(diff.long/2)^2\n  b &lt;- 2 * asin(pmin(1, sqrt(a))) \n  d = R * b\n  return(d)\n}\n\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"The haversine is definitely a good formula for probably most cases, other answers already include it so I am not going to take the space. But it is important to note that no matter what formula is used (yes not just one). Because of the huge range of accuracy possible as well as the computation time required. The choice of formula requires a bit more thought than a simple no brainer answer. \n\nThis posting from a person at nasa, is the best one I found at discussing the options\n\nhttp://www.cs.nyu.edu/visual/home/proj/tiger/gisfaq.html\n\nFor example, if you are just sorting rows by distance in a 100 miles radius. The flat earth formula will be much faster than the haversine.\n\nHalfPi = 1.5707963;\nR = 3956; /* the radius gives you the measurement unit*/\n\na = HalfPi - latoriginrad;\nb = HalfPi - latdestrad;\nu = a * a + b * b;\nv = - 2 * a * b * cos(longdestrad - longoriginrad);\nc = sqrt(abs(u + v));\nreturn R * c;\n\n\nNotice there is just one cosine and one square root. Vs 9 of them on the Haversine formula.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"There could be a simpler solution, and more correct: The perimeter of earth is 40,000Km at the equator, about 37,000 on Greenwich (or any longitude) cycle. Thus:\n\npythagoras = function (lat1, lon1, lat2, lon2) {\n   function sqr(x) {return x * x;}\n   function cosDeg(x) {return Math.cos(x * Math.PI / 180.0);}\n\n   var earthCyclePerimeter = 40000000.0 * cosDeg((lat1 + lat2) / 2.0);\n   var dx = (lon1 - lon2) * earthCyclePerimeter / 360.0;\n   var dy = 37000000.0 * (lat1 - lat2) / 360.0;\n\n   return Math.sqrt(sqr(dx) + sqr(dy));\n};\n\n\nI agree that it should be fine-tuned as, I myself said that it&apos;s an ellipsoid, so the radius to be multiplied by the cosine varies. But it&apos;s a bit more accurate. Compared with Google Maps and it did reduce the error significantly.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"All the above answers assumes the earth is a sphere. However, a more accurate approximation would be that of an oblate spheroid.\n\na= 6378.137#equitorial radius in km\nb= 6356.752#polar radius in km\n\ndef Distance(lat1, lons1, lat2, lons2):\n    lat1=math.radians(lat1)\n    lons1=math.radians(lons1)\n    R1=(((((a**2)*math.cos(lat1))**2)+(((b**2)*math.sin(lat1))**2))/((a*math.cos(lat1))**2+(b*math.sin(lat1))**2))**0.5 #radius of earth at lat1\n    x1=R*math.cos(lat1)*math.cos(lons1)\n    y1=R*math.cos(lat1)*math.sin(lons1)\n    z1=R*math.sin(lat1)\n\n    lat2=math.radians(lat2)\n    lons2=math.radians(lons2)\n    R1=(((((a**2)*math.cos(lat2))**2)+(((b**2)*math.sin(lat2))**2))/((a*math.cos(lat2))**2+(b*math.sin(lat2))**2))**0.5 #radius of earth at lat2\n    x2=R*math.cos(lat2)*math.cos(lons2)\n    y2=R*math.cos(lat2)*math.sin(lons2)\n    z2=R*math.sin(lat2)\n\n    return ((x1-x2)**2+(y1-y2)**2+(z1-z2)**2)**0.5\n\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"pip install haversine\nPython implementation\nOrigin is the center of the contiguous United States.\nfrom haversine import haversine, Unit\norigin = (39.50, 98.35)\nparis = (48.8567, 2.3508)\nhaversine(origin, paris, unit=Unit.MILES)\n\nTo get the answer in kilometers simply set unit=Unit.KILOMETERS (that&apos;s the default).\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"I don&apos;t like adding yet another answer, but the Google maps API v.3 has spherical geometry (and more). After converting your WGS84 to decimal degrees you can do this:\n\n&lt;script src=&quot;http://maps.google.com/maps/api/js?sensor=false&amp;libraries=geometry&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;  \n\ndistance = google.maps.geometry.spherical.computeDistanceBetween(\n    new google.maps.LatLng(fromLat, fromLng), \n    new google.maps.LatLng(toLat, toLng));\n\n\nNo word about how accurate Google&apos;s calculations are or even what model is used (though it does say &quot;spherical&quot; rather than &quot;geoid&quot;.  By the way, the &quot;straight line&quot; distance will obviously be different from the distance if one travels on the surface of the earth which is what everyone seems to be presuming.\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"You can use the build in CLLocationDistance to calculate this:\n\nCLLocation *location1 = [[CLLocation alloc] initWithLatitude:latitude1 longitude:longitude1];\nCLLocation *location2 = [[CLLocation alloc] initWithLatitude:latitude2 longitude:longitude2];\n[self distanceInMetersFromLocation:location1 toLocation:location2]\n\n- (int)distanceInMetersFromLocation:(CLLocation*)location1 toLocation:(CLLocation*)location2 {\n    CLLocationDistance distanceInMeters = [location1 distanceFromLocation:location2];\n    return distanceInMeters;\n}\n\n\nIn your case if you want kilometers just divide by 1000.\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"Here is a typescript implementation of the Haversine formula\n\nstatic getDistanceFromLatLonInKm(lat1: number, lon1: number, lat2: number, lon2: number): number {\n    var deg2Rad = deg =&gt; {\n        return deg * Math.PI / 180;\n    }\n\n    var r = 6371; // Radius of the earth in km\n    var dLat = deg2Rad(lat2 - lat1);   \n    var dLon = deg2Rad(lon2 - lon1);\n    var a =\n        Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n        Math.cos(deg2Rad(lat1)) * Math.cos(deg2Rad(lat2)) *\n        Math.sin(dLon / 2) * Math.sin(dLon / 2);\n    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    var d = r * c; // Distance in km\n    return d;\n}\n\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"As pointed out, an accurate calculation should take into account that the earth is not a perfect sphere. Here are some comparisons of the various algorithms offered here:\n\ngeoDistance(50,5,58,3)\nHaversine: 899 km\nMaymenn: 833 km\nKeerthana: 897 km\ngoogle.maps.geometry.spherical.computeDistanceBetween(): 900 km\n\ngeoDistance(50,5,-58,-3)\nHaversine: 12030 km\nMaymenn: 11135 km\nKeerthana: 10310 km\ngoogle.maps.geometry.spherical.computeDistanceBetween(): 12044 km\n\ngeoDistance(.05,.005,.058,.003)\nHaversine: 0.9169 km\nMaymenn: 0.851723 km\nKeerthana: 0.917964 km\ngoogle.maps.geometry.spherical.computeDistanceBetween(): 0.917964 km\n\ngeoDistance(.05,80,.058,80.3)\nHaversine: 33.37 km\nMaymenn: 33.34 km\nKeerthana: 33.40767 km\ngoogle.maps.geometry.spherical.computeDistanceBetween(): 33.40770 km\n\n\nOver small distances, Keerthana&apos;s algorithm does seem to coincide with that of Google Maps. Google Maps does not seem to follow any simple algorithm, suggesting that it may be the most accurate method here.\n\nAnyway, here is a Javascript implementation of Keerthana&apos;s algorithm:\n\nfunction geoDistance(lat1, lng1, lat2, lng2){\n    const a = 6378.137; // equitorial radius in km\n    const b = 6356.752; // polar radius in km\n\n    var sq = x =&gt; (x*x);\n    var sqr = x =&gt; Math.sqrt(x);\n    var cos = x =&gt; Math.cos(x);\n    var sin = x =&gt; Math.sin(x);\n    var radius = lat =&gt; sqr((sq(a*a*cos(lat))+sq(b*b*sin(lat)))/(sq(a*cos(lat))+sq(b*sin(lat))));\n\n    lat1 = lat1 * Math.PI / 180;\n    lng1 = lng1 * Math.PI / 180;\n    lat2 = lat2 * Math.PI / 180;\n    lng2 = lng2 * Math.PI / 180;\n\n    var R1 = radius(lat1);\n    var x1 = R1*cos(lat1)*cos(lng1);\n    var y1 = R1*cos(lat1)*sin(lng1);\n    var z1 = R1*sin(lat1);\n\n    var R2 = radius(lat2);\n    var x2 = R2*cos(lat2)*cos(lng2);\n    var y2 = R2*cos(lat2)*sin(lng2);\n    var z2 = R2*sin(lat2);\n\n    return sqr(sq(x1-x2)+sq(y1-y2)+sq(z1-z2));\n}\n\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"Here is the SQL Implementation to calculate the distance in km,\n\nSELECT UserId, ( 3959 * acos( cos( radians( your latitude here ) ) * cos( radians(latitude) ) * \ncos( radians(longitude) - radians( your longitude here ) ) + sin( radians( your latitude here ) ) * \nsin( radians(latitude) ) ) ) AS distance FROM user HAVING\ndistance &lt; 5  ORDER BY distance LIMIT 0 , 5;\n\n\nFor further details in the implementation by programming langugage, you can just go through the php script given here\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"This script [in PHP] calculates distances between the two points.\n\npublic static function getDistanceOfTwoPoints($source, $dest, $unit=&apos;K&apos;) {\n        $lat1 = $source[0];\n        $lon1 = $source[1];\n        $lat2 = $dest[0];\n        $lon2 = $dest[1];\n\n        $theta = $lon1 - $lon2;\n        $dist = sin(deg2rad($lat1)) * sin(deg2rad($lat2)) +  cos(deg2rad($lat1)) * cos(deg2rad($lat2)) * cos(deg2rad($theta));\n        $dist = acos($dist);\n        $dist = rad2deg($dist);\n        $miles = $dist * 60 * 1.1515;\n        $unit = strtoupper($unit);\n\n        if ($unit == &quot;K&quot;) {\n            return ($miles * 1.609344);\n        }\n        else if ($unit == &quot;M&quot;)\n        {\n            return ($miles * 1.609344 * 1000);\n        }\n        else if ($unit == &quot;N&quot;) {\n            return ($miles * 0.8684);\n        } \n        else {\n            return $miles;\n        }\n    }\n\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0},{"text":"\n  Java implementation in according Haversine formula\n\n\ndouble calculateDistance(double latPoint1, double lngPoint1, \n                         double latPoint2, double lngPoint2) {\n    if(latPoint1 == latPoint2 &amp;&amp; lngPoint1 == lngPoint2) {\n        return 0d;\n    }\n\n    final double EARTH_RADIUS = 6371.0; //km value;\n\n    //converting to radians\n    latPoint1 = Math.toRadians(latPoint1);\n    lngPoint1 = Math.toRadians(lngPoint1);\n    latPoint2 = Math.toRadians(latPoint2);\n    lngPoint2 = Math.toRadians(lngPoint2);\n\n    double distance = Math.pow(Math.sin((latPoint2 - latPoint1) / 2.0), 2) \n            + Math.cos(latPoint1) * Math.cos(latPoint2)\n            * Math.pow(Math.sin((lngPoint2 - lngPoint1) / 2.0), 2);\n    distance = 2.0 * EARTH_RADIUS * Math.asin(Math.sqrt(distance));\n\n    return distance; //km value\n}\n\n    ","url":"/questions/[slug]#solution19","@type":"Answer","upvoteCount":0},{"text":"To calculate the distance between two points on a sphere you need to do the Great Circle calculation. \n\nThere are a number of C/C++ libraries to help with map projection at MapTools if you need to reproject your distances to a flat surface.  To do this you will need the projection string of the various coordinate systems.\n\nYou may also find MapWindow a useful tool to visualise the points.  Also as its open source its a useful guide to how to use the proj.dll library, which appears to be the core open source projection library.\n    ","url":"/questions/[slug]#solution20","@type":"Answer","upvoteCount":0},{"text":"Here is my java implementation for calculation distance via decimal degrees after some search. I used mean radius of world (from wikipedia) in km. İf you want result miles then use world radius in miles.\n\npublic static double distanceLatLong2(double lat1, double lng1, double lat2, double lng2) \n{\n  double earthRadius = 6371.0d; // KM: use mile here if you want mile result\n\n  double dLat = toRadian(lat2 - lat1);\n  double dLng = toRadian(lng2 - lng1);\n\n  double a = Math.pow(Math.sin(dLat/2), 2)  + \n          Math.cos(toRadian(lat1)) * Math.cos(toRadian(lat2)) * \n          Math.pow(Math.sin(dLng/2), 2);\n\n  double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n\n  return earthRadius * c; // returns result kilometers\n}\n\npublic static double toRadian(double degrees) \n{\n  return (degrees * Math.PI) / 180.0d;\n}\n\n    ","url":"/questions/[slug]#solution21","@type":"Answer","upvoteCount":0},{"text":"Here&apos;s the accepted answer implementation ported to Java in case anyone needs it.\n\npackage com.project529.garage.util;\n\n\n/**\n * Mean radius.\n */\nprivate static double EARTH_RADIUS = 6371;\n\n/**\n * Returns the distance between two sets of latitudes and longitudes in meters.\n * &lt;p/&gt;\n * Based from the following JavaScript SO answer:\n * http://stackoverflow.com/questions/27928/calculate-distance-between-two-latitude-longitude-points-haversine-formula,\n * which is based on https://en.wikipedia.org/wiki/Haversine_formula (error rate: ~0.55%).\n */\npublic double getDistanceBetween(double lat1, double lon1, double lat2, double lon2) {\n    double dLat = toRadians(lat2 - lat1);\n    double dLon = toRadians(lon2 - lon1);\n\n    double a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n            Math.cos(toRadians(lat1)) * Math.cos(toRadians(lat2)) *\n                    Math.sin(dLon / 2) * Math.sin(dLon / 2);\n    double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    double d = EARTH_RADIUS * c;\n\n    return d;\n}\n\npublic double toRadians(double degrees) {\n    return degrees * (Math.PI / 180);\n}\n\n    ","url":"/questions/[slug]#solution22","@type":"Answer","upvoteCount":0},{"text":"here is an example in postgres sql (in km, for miles version, replace 1.609344 by 0.8684 version)\n\nCREATE OR REPLACE FUNCTION public.geodistance(alat float, alng float, blat  \n\nfloat, blng  float)\n  RETURNS float AS\n$BODY$\nDECLARE\n    v_distance float;\nBEGIN\n\n    v_distance = asin( sqrt(\n            sin(radians(blat-alat)/2)^2 \n                + (\n                    (sin(radians(blng-alng)/2)^2) *\n                    cos(radians(alat)) *\n                    cos(radians(blat))\n                )\n          )\n        ) * cast(&apos;7926.3352&apos; as float) * cast(&apos;1.609344&apos; as float) ;\n\n\n    RETURN v_distance;\nEND \n$BODY$\nlanguage plpgsql VOLATILE SECURITY DEFINER;\nalter function geodistance(alat float, alng float, blat float, blng float)\nowner to postgres;\n\n    ","url":"/questions/[slug]#solution23","@type":"Answer","upvoteCount":0},{"text":"For those looking for an Excel formula based on WGS-84 &amp; GRS-80 standards:\n\n=ACOS(COS(RADIANS(90-Lat1))*COS(RADIANS(90-Lat2))+SIN(RADIANS(90-Lat1))*SIN(RADIANS(90-Lat2))*COS(RADIANS(Long1-Long2)))*6371\n\n\nSource\n    ","url":"/questions/[slug]#solution24","@type":"Answer","upvoteCount":0},{"text":"I made a custom function in R to calculate haversine distance(km) between two spatial points using functions available in R base package.\ncustom_hav_dist &lt;- function(lat1, lon1, lat2, lon2) {\nR &lt;- 6371\nRadian_factor &lt;- 0.0174533\nlat_1 &lt;- (90-lat1)*Radian_factor\nlat_2 &lt;- (90-lat2)*Radian_factor\ndiff_long &lt;-(lon1-lon2)*Radian_factor\n\ndistance_in_km &lt;- 6371*acos((cos(lat_1)*cos(lat_2))+ \n                 (sin(lat_1)*sin(lat_2)*cos(diff_long)))\nrm(lat1, lon1, lat2, lon2)\nreturn(distance_in_km)\n}\n\nSample output\ncustom_hav_dist(50.31,19.08,54.14,19.39)\n[1] 426.3987\n\nPS: To calculate distances in miles, substitute R in function (6371) with 3958.756 (and for nautical miles, use 3440.065).\n    ","url":"/questions/[slug]#solution25","@type":"Answer","upvoteCount":0},{"text":"there is a good example in here to calculate distance with PHP http://www.geodatasource.com/developers/php :\n\n function distance($lat1, $lon1, $lat2, $lon2, $unit) {\n\n     $theta = $lon1 - $lon2;\n     $dist = sin(deg2rad($lat1)) * sin(deg2rad($lat2)) +  cos(deg2rad($lat1)) * cos(deg2rad($lat2)) * cos(deg2rad($theta));\n     $dist = acos($dist);\n     $dist = rad2deg($dist);\n     $miles = $dist * 60 * 1.1515;\n     $unit = strtoupper($unit);\n\n     if ($unit == &quot;K&quot;) {\n         return ($miles * 1.609344);\n     } else if ($unit == &quot;N&quot;) {\n          return ($miles * 0.8684);\n     } else {\n          return $miles;\n     }\n }\n\n    ","url":"/questions/[slug]#solution26","@type":"Answer","upvoteCount":0},{"text":"Here is the implementation VB.NET, this implementation will give you the result in KM or Miles based on an Enum value you pass.\n\nPublic Enum DistanceType\n    Miles\n    KiloMeters\nEnd Enum\n\nPublic Structure Position\n    Public Latitude As Double\n    Public Longitude As Double\nEnd Structure\n\nPublic Class Haversine\n\n    Public Function Distance(Pos1 As Position,\n                             Pos2 As Position,\n                             DistType As DistanceType) As Double\n\n        Dim R As Double = If((DistType = DistanceType.Miles), 3960, 6371)\n\n        Dim dLat As Double = Me.toRadian(Pos2.Latitude - Pos1.Latitude)\n\n        Dim dLon As Double = Me.toRadian(Pos2.Longitude - Pos1.Longitude)\n\n        Dim a As Double = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) + Math.Cos(Me.toRadian(Pos1.Latitude)) * Math.Cos(Me.toRadian(Pos2.Latitude)) * Math.Sin(dLon / 2) * Math.Sin(dLon / 2)\n\n        Dim c As Double = 2 * Math.Asin(Math.Min(1, Math.Sqrt(a)))\n\n        Dim result As Double = R * c\n\n        Return result\n\n    End Function\n\n    Private Function toRadian(val As Double) As Double\n\n        Return (Math.PI / 180) * val\n\n    End Function\n\nEnd Class\n\n    ","url":"/questions/[slug]#solution27","@type":"Answer","upvoteCount":0},{"text":"I condensed the computation down by simplifying the formula.\n\nHere it is in Ruby:\n\ninclude Math\nearth_radius_mi = 3959\nradians = lambda { |deg| deg * PI / 180 }\ncoord_radians = lambda { |c| { :lat =&gt; radians[c[:lat]], :lng =&gt; radians[c[:lng]] } }\n\n# from/to = { :lat =&gt; (latitude_in_degrees), :lng =&gt; (longitude_in_degrees) }\ndef haversine_distance(from, to)\n  from, to = coord_radians[from], coord_radians[to]\n  cosines_product = cos(to[:lat]) * cos(from[:lat]) * cos(from[:lng] - to[:lng])\n  sines_product = sin(to[:lat]) * sin(from[:lat])\n  return earth_radius_mi * acos(cosines_product + sines_product)\nend\n\n    ","url":"/questions/[slug]#solution28","@type":"Answer","upvoteCount":0},{"text":"function getDistanceFromLatLonInKm(lat1,lon1,lat2,lon2,units) {\n  var R = 6371; // Radius of the earth in km\n  var dLat = deg2rad(lat2-lat1);  // deg2rad below\n  var dLon = deg2rad(lon2-lon1); \n  var a = \n    Math.sin(dLat/2) * Math.sin(dLat/2) +\n    Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * \n    Math.sin(dLon/2) * Math.sin(dLon/2)\n    ; \n  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); \n  var d = R * c; \n  var miles = d / 1.609344; \n\nif ( units == &apos;km&apos; ) {  \nreturn d; \n } else {\nreturn miles;\n}}\n\n\nChuck&apos;s solution, valid for miles also.\n    ","url":"/questions/[slug]#solution29","@type":"Answer","upvoteCount":0},{"text":"In Mysql use the following function pass the parameters as using  POINT(LONG,LAT)\n\nCREATE FUNCTION `distance`(a POINT, b POINT)\n RETURNS double\n    DETERMINISTIC\nBEGIN\n\nRETURN\n\nGLength( LineString(( PointFromWKB(a)), (PointFromWKB(b)))) * 100000; -- To Make the distance in meters\n\nEND;\n\n    ","url":"/questions/[slug]#solution30","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-b06815e21c943e0d.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-79a1437acf654019.js" defer=""></script><script src="/_next/static/6ctJfCympFH_chh5mjicD/_buildManifest.js" defer=""></script><script src="/_next/static/6ctJfCympFH_chh5mjicD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/calculate-distance-between-two-latitude-longitude-points-(haversine-formula)-1657388500103#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/calculate-distance-between-two-latitude-longitude-points-(haversine-formula)-1657388500103"><h1>Calculate distance between two latitude-longitude points? (Haversine formula)</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/haversine">haversine</a></div></div><div class="question-content mt-5">
                
<p>How do I calculate the distance between two points specified by latitude and longitude?</p>

<p>For clarification, I'd like the distance in kilometers; the points use the WGS84 system and I'd like to understand the relative accuracies of the approaches available.</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li><li class="pagination-solution-item"><span data-id="#solution19" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">19</span></li><li class="pagination-solution-item"><span data-id="#solution20" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">20</span></li><li class="pagination-solution-item"><span data-id="#solution21" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">21</span></li><li class="pagination-solution-item"><span data-id="#solution22" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">22</span></li><li class="pagination-solution-item"><span data-id="#solution23" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">23</span></li><li class="pagination-solution-item"><span data-id="#solution24" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">24</span></li><li class="pagination-solution-item"><span data-id="#solution25" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">25</span></li><li class="pagination-solution-item"><span data-id="#solution26" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">26</span></li><li class="pagination-solution-item"><span data-id="#solution27" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">27</span></li><li class="pagination-solution-item"><span data-id="#solution28" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">28</span></li><li class="pagination-solution-item"><span data-id="#solution29" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">29</span></li><li class="pagination-solution-item"><span data-id="#solution30" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">30</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/haversine">haversine</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This <a href="http://www.movable-type.co.uk/scripts/latlong.html" rel="noreferrer">link</a> might be helpful to you, as it details the use of the <a href="http://en.wikipedia.org/wiki/Haversine_formula" rel="noreferrer">Haversine formula</a> to calculate the distance.</p>

<p>Excerpt:</p>



<blockquote>
  <p>This script [in Javascript] calculates great-circle distances between the two points 
  that is, the shortest distance over the earths surface  using the
  Haversine formula.</p>
</blockquote>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDistanceFromLatLonInKm</span>(<span class="hljs-params">lat1,lon1,lat2,lon2</span>) {
  <span class="hljs-keyword">var</span> R = <span class="hljs-number">6371</span>; <span class="hljs-comment">// Radius of the earth in km</span>
  <span class="hljs-keyword">var</span> dLat = <span class="hljs-title function_">deg2rad</span>(lat2-lat1);  <span class="hljs-comment">// deg2rad below</span>
  <span class="hljs-keyword">var</span> dLon = <span class="hljs-title function_">deg2rad</span>(lon2-lon1); 
  <span class="hljs-keyword">var</span> a = 
    <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(dLat/<span class="hljs-number">2</span>) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(dLat/<span class="hljs-number">2</span>) +
    <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(<span class="hljs-title function_">deg2rad</span>(lat1)) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(<span class="hljs-title function_">deg2rad</span>(lat2)) * 
    <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(dLon/<span class="hljs-number">2</span>) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(dLon/<span class="hljs-number">2</span>)
    ; 
  <span class="hljs-keyword">var</span> c = <span class="hljs-number">2</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">atan2</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(a), <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(<span class="hljs-number">1</span>-a)); 
  <span class="hljs-keyword">var</span> d = R * c; <span class="hljs-comment">// Distance in km</span>
  <span class="hljs-keyword">return</span> d;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">deg2rad</span>(<span class="hljs-params">deg</span>) {
  <span class="hljs-keyword">return</span> deg * (<span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>/<span class="hljs-number">180</span>)
}
</code></pre>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/haversine">haversine</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I needed to calculate a lot of distances between the points for my project, so I went ahead and tried to optimize the code, I have found here. On average in different browsers my new implementation <strong>runs 2 times faster</strong> than the most upvoted answer.</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">distance</span>(<span class="hljs-params">lat1, lon1, lat2, lon2</span>) {
  <span class="hljs-keyword">var</span> p = <span class="hljs-number">0.017453292519943295</span>;    <span class="hljs-comment">// Math.PI / 180</span>
  <span class="hljs-keyword">var</span> c = <span class="hljs-title class_">Math</span>.<span class="hljs-property">cos</span>;
  <span class="hljs-keyword">var</span> a = <span class="hljs-number">0.5</span> - <span class="hljs-title function_">c</span>((lat2 - lat1) * p)/<span class="hljs-number">2</span> + 
          <span class="hljs-title function_">c</span>(lat1 * p) * <span class="hljs-title function_">c</span>(lat2 * p) * 
          (<span class="hljs-number">1</span> - <span class="hljs-title function_">c</span>((lon2 - lon1) * p))/<span class="hljs-number">2</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-number">12742</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">asin</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(a)); <span class="hljs-comment">// 2 * R; R = 6371 km</span>
}
</code></pre>
<p>You can play with my jsPerf and see the <a href="http://jsperf.com/haversine-salvador/8" rel="noreferrer">results here</a>.</p>
<p>Recently I needed to do the same in python, so here is a <strong>python implementation</strong>:</p>
<pre class="lang-python s-code-block"><code class="hljs language-python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> cos, asin, sqrt, pi

<span class="hljs-keyword">def</span> <span class="hljs-title function_">distance</span>(<span class="hljs-params">lat1, lon1, lat2, lon2</span>):
    p = pi/<span class="hljs-number">180</span>
    a = <span class="hljs-number">0.5</span> - cos((lat2-lat1)*p)/<span class="hljs-number">2</span> + cos(lat1*p) * cos(lat2*p) * (<span class="hljs-number">1</span>-cos((lon2-lon1)*p))/<span class="hljs-number">2</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">12742</span> * asin(sqrt(a)) <span class="hljs-comment">#2*R*asin...</span>
</code></pre>
<p>And for the sake of completeness: <a href="https://en.wikipedia.org/wiki/Haversine_formula" rel="noreferrer">Haversine</a> on Wikipedia.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/haversine">haversine</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is a C# Implementation:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DistanceAlgorithm</span>
{
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> PIx = <span class="hljs-number">3.141592653589793</span>;
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> RADIUS = <span class="hljs-number">6378.16</span>;

    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> Convert degrees to Radians</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="x"&gt;</span>Degrees<span class="hljs-doctag">&lt;/param&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>The equivalent in radians<span class="hljs-doctag">&lt;/returns&gt;</span></span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Radians</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> x</span>)</span>
    {
        <span class="hljs-keyword">return</span> x * PIx / <span class="hljs-number">180</span>;
    }

    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> Calculate the distance between two places.</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="lon1"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="lat1"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="lon2"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="lat2"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> <span class="hljs-title">DistanceBetweenPlaces</span>(<span class="hljs-params">
        <span class="hljs-built_in">double</span> lon1,
        <span class="hljs-built_in">double</span> lat1,
        <span class="hljs-built_in">double</span> lon2,
        <span class="hljs-built_in">double</span> lat2</span>)</span>
    {
        <span class="hljs-built_in">double</span> dlon = Radians(lon2 - lon1);
        <span class="hljs-built_in">double</span> dlat = Radians(lat2 - lat1);

        <span class="hljs-built_in">double</span> a = (Math.Sin(dlat / <span class="hljs-number">2</span>) * Math.Sin(dlat / <span class="hljs-number">2</span>)) + Math.Cos(Radians(lat1)) * Math.Cos(Radians(lat2)) * (Math.Sin(dlon / <span class="hljs-number">2</span>) * Math.Sin(dlon / <span class="hljs-number">2</span>));
        <span class="hljs-built_in">double</span> angle = <span class="hljs-number">2</span> * Math.Atan2(Math.Sqrt(a), Math.Sqrt(<span class="hljs-number">1</span> - a));
        <span class="hljs-keyword">return</span> angle * RADIUS;
    }

}
</code></pre>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/haversine">haversine</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is a java implementation of the Haversine formula.</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-variable">AVERAGE_RADIUS_OF_EARTH_KM</span> <span class="hljs-operator">=</span> <span class="hljs-number">6371</span>;
<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateDistanceInKilometer</span><span class="hljs-params">(<span class="hljs-type">double</span> userLat, <span class="hljs-type">double</span> userLng,
  <span class="hljs-type">double</span> venueLat, <span class="hljs-type">double</span> venueLng)</span> {

    <span class="hljs-type">double</span> <span class="hljs-variable">latDistance</span> <span class="hljs-operator">=</span> Math.toRadians(userLat - venueLat);
    <span class="hljs-type">double</span> <span class="hljs-variable">lngDistance</span> <span class="hljs-operator">=</span> Math.toRadians(userLng - venueLng);

    <span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Math.sin(latDistance / <span class="hljs-number">2</span>) * Math.sin(latDistance / <span class="hljs-number">2</span>)
      + Math.cos(Math.toRadians(userLat)) * Math.cos(Math.toRadians(venueLat))
      * Math.sin(lngDistance / <span class="hljs-number">2</span>) * Math.sin(lngDistance / <span class="hljs-number">2</span>);

    <span class="hljs-type">double</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * Math.atan2(Math.sqrt(a), Math.sqrt(<span class="hljs-number">1</span> - a));

    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (Math.round(AVERAGE_RADIUS_OF_EARTH_KM * c));
}
</code></pre>

<p>Note that here we are rounding the answer to the nearest km.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/haversine">haversine</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Thanks very much for all this. I used the following code in my Objective-C iPhone app:</p>



<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">const</span> <span class="hljs-type">double</span> PIx = <span class="hljs-number">3.141592653589793</span>;
<span class="hljs-type">const</span> <span class="hljs-type">double</span> RADIO = <span class="hljs-number">6371</span>; <span class="hljs-comment">// Mean radius of Earth in Km</span>

<span class="hljs-type">double</span> <span class="hljs-title function_">convertToRadians</span><span class="hljs-params">(<span class="hljs-type">double</span> val)</span> {

   <span class="hljs-keyword">return</span> val * PIx / <span class="hljs-number">180</span>;
}

-(<span class="hljs-type">double</span>)kilometresBetweenPlace1:(CLLocationCoordinate2D) place1 andPlace2:(CLLocationCoordinate2D) place2 {

        <span class="hljs-type">double</span> dlon = convertToRadians(place2.longitude - place1.longitude);
        <span class="hljs-type">double</span> dlat = convertToRadians(place2.latitude - place1.latitude);

        <span class="hljs-type">double</span> a = ( <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">sin</span>(dlat / <span class="hljs-number">2</span>), <span class="hljs-number">2</span>) + <span class="hljs-built_in">cos</span>(convertToRadians(place1.latitude))) * <span class="hljs-built_in">cos</span>(convertToRadians(place2.latitude)) * <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">sin</span>(dlon / <span class="hljs-number">2</span>), <span class="hljs-number">2</span>);
        <span class="hljs-type">double</span> angle = <span class="hljs-number">2</span> * <span class="hljs-built_in">asin</span>(<span class="hljs-built_in">sqrt</span>(a));

        <span class="hljs-keyword">return</span> angle * RADIO;
}
</code></pre>

<p>Latitude and Longitude are in decimal. I didn't use min() for the asin() call as the distances that I'm using are so small that they don't require it.</p>

<p>It gave incorrect answers until I passed in the values in Radians - now it's pretty much the same as the values obtained from Apple's Map app :-)</p>

<p>Extra update:</p>

<p>If you are using iOS4 or later then Apple provide some methods to do this so the same functionality would be achieved with:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">-(<span class="hljs-type">double</span>)kilometresBetweenPlace1:(CLLocationCoordinate2D) place1 andPlace2:(CLLocationCoordinate2D) place2 {

    MKMapPoint  start, finish;


    start = MKMapPointForCoordinate(place1);
    finish = MKMapPointForCoordinate(place2);

    <span class="hljs-keyword">return</span> MKMetersBetweenMapPoints(start, finish) / <span class="hljs-number">1000</span>;
}
</code></pre>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/haversine">haversine</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This is a simple PHP function that will give a very reasonable approximation (under +/-1% error margin).  </p>

<pre class="lang-php s-code-block"><code class="hljs language-php"><span class="hljs-meta">&lt;?php</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">distance</span>(<span class="hljs-params"><span class="hljs-variable">$lat1</span>, <span class="hljs-variable">$lon1</span>, <span class="hljs-variable">$lat2</span>, <span class="hljs-variable">$lon2</span></span>) </span>{

    <span class="hljs-variable">$pi80</span> = M_PI / <span class="hljs-number">180</span>;
    <span class="hljs-variable">$lat1</span> *= <span class="hljs-variable">$pi80</span>;
    <span class="hljs-variable">$lon1</span> *= <span class="hljs-variable">$pi80</span>;
    <span class="hljs-variable">$lat2</span> *= <span class="hljs-variable">$pi80</span>;
    <span class="hljs-variable">$lon2</span> *= <span class="hljs-variable">$pi80</span>;

    <span class="hljs-variable">$r</span> = <span class="hljs-number">6372.797</span>; <span class="hljs-comment">// mean radius of Earth in km</span>
    <span class="hljs-variable">$dlat</span> = <span class="hljs-variable">$lat2</span> - <span class="hljs-variable">$lat1</span>;
    <span class="hljs-variable">$dlon</span> = <span class="hljs-variable">$lon2</span> - <span class="hljs-variable">$lon1</span>;
    <span class="hljs-variable">$a</span> = <span class="hljs-title function_ invoke__">sin</span>(<span class="hljs-variable">$dlat</span> / <span class="hljs-number">2</span>) * <span class="hljs-title function_ invoke__">sin</span>(<span class="hljs-variable">$dlat</span> / <span class="hljs-number">2</span>) + <span class="hljs-title function_ invoke__">cos</span>(<span class="hljs-variable">$lat1</span>) * <span class="hljs-title function_ invoke__">cos</span>(<span class="hljs-variable">$lat2</span>) * <span class="hljs-title function_ invoke__">sin</span>(<span class="hljs-variable">$dlon</span> / <span class="hljs-number">2</span>) * <span class="hljs-title function_ invoke__">sin</span>(<span class="hljs-variable">$dlon</span> / <span class="hljs-number">2</span>);
    <span class="hljs-variable">$c</span> = <span class="hljs-number">2</span> * <span class="hljs-title function_ invoke__">atan2</span>(<span class="hljs-title function_ invoke__">sqrt</span>(<span class="hljs-variable">$a</span>), <span class="hljs-title function_ invoke__">sqrt</span>(<span class="hljs-number">1</span> - <span class="hljs-variable">$a</span>));
    <span class="hljs-variable">$km</span> = <span class="hljs-variable">$r</span> * <span class="hljs-variable">$c</span>;

    <span class="hljs-comment">//echo '&lt;br/&gt;'.$km;</span>
    <span class="hljs-keyword">return</span> <span class="hljs-variable">$km</span>;
}
<span class="hljs-meta">?&gt;</span>
</code></pre>

<p>As said before; the earth is NOT a sphere.  It is like an old, old baseball that Mark McGwire decided to practice with - it is full of dents and bumps.  The simpler calculations (like this) treat it like a sphere.</p>

<p>Different methods may be more or less precise according to where you are on this irregular ovoid AND how far apart your points are (the closer they are the smaller the absolute error margin).  The more precise your expectation, the more complex the math.</p>

<p>For more info: <a href="http://en.wikipedia.org/wiki/Geographical_distance" rel="noreferrer">wikipedia geographic distance</a></p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/haversine">haversine</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I post here my working example.</p>

<p>List all points in table having distance between a designated point (we use a random point - lat:45.20327, long:23.7806) less than 50 KM, with latitude &amp; longitude, in MySQL (the table fields are coord_lat and coord_long):</p>

<p><strong>List all having DISTANCE&lt;50, in Kilometres (considered Earth radius 6371 KM):</strong></p>

<pre class="lang-sql s-code-block"><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> denumire, (<span class="hljs-number">6371</span> <span class="hljs-operator">*</span> <span class="hljs-built_in">acos</span>( <span class="hljs-built_in">cos</span>( radians(<span class="hljs-number">45.20327</span>) ) <span class="hljs-operator">*</span> <span class="hljs-built_in">cos</span>( radians( coord_lat ) ) <span class="hljs-operator">*</span> <span class="hljs-built_in">cos</span>( radians( <span class="hljs-number">23.7806</span> ) <span class="hljs-operator">-</span> radians(coord_long) ) <span class="hljs-operator">+</span> <span class="hljs-built_in">sin</span>( radians(<span class="hljs-number">45.20327</span>) ) <span class="hljs-operator">*</span> <span class="hljs-built_in">sin</span>( radians(coord_lat) ) )) <span class="hljs-keyword">AS</span> distanta 
<span class="hljs-keyword">FROM</span> obiective 
<span class="hljs-keyword">WHERE</span> coord_lat<span class="hljs-operator">&lt;&gt;</span><span class="hljs-string">''</span> 
    <span class="hljs-keyword">AND</span> coord_long<span class="hljs-operator">&lt;&gt;</span><span class="hljs-string">''</span> 
<span class="hljs-keyword">HAVING</span> distanta<span class="hljs-operator">&lt;</span><span class="hljs-number">50</span> 
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> distanta <span class="hljs-keyword">desc</span>
</code></pre>

<p>The above example was tested in MySQL 5.0.95 and 5.5.16 (Linux). </p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/haversine">haversine</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In the other answers an implementation in <a href="/questions/tagged/r" class="post-tag" title="show questions tagged 'r'" rel="tag">r</a> is missing.</p>

<p>Calculating the distance between two point is quite straightforward with the <code>distm</code> function from the <code>geosphere</code> package:</p>

<pre><code>distm(p1, p2, fun = distHaversine)
</code></pre>

<p>where:</p>

<pre><code>p1 = longitude/latitude for point(s)
p2 = longitude/latitude for point(s)
# type of distance calculation
fun = distCosine / distHaversine / distVincentySphere / distVincentyEllipsoid 
</code></pre>

<p>As the earth is not perfectly spherical, the <a href="http://en.wikipedia.org/wiki/Vincenty%27s_formulae" rel="noreferrer">Vincenty formula for ellipsoids</a> is probably the best way to calculate distances. Thus in the <code>geosphere</code> package you use then:</p>

<pre><code>distm(p1, p2, fun = distVincentyEllipsoid)
</code></pre>

<hr>

<p>Off course you don't necessarily have to use <code>geosphere</code> package, you can also calculate the distance in base <code>R</code> with a function:</p>

<pre><code>hav.dist &lt;- function(long1, lat1, long2, lat2) {
  R &lt;- 6371
  diff.long &lt;- (long2 - long1)
  diff.lat &lt;- (lat2 - lat1)
  a &lt;- sin(diff.lat/2)^2 + cos(lat1) * cos(lat2) * sin(diff.long/2)^2
  b &lt;- 2 * asin(pmin(1, sqrt(a))) 
  d = R * b
  return(d)
}
</code></pre>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/haversine">haversine</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The haversine is definitely a good formula for probably most cases, other answers already include it so I am not going to take the space. But it is important to note that no matter what formula is used (yes not just one). Because of the huge range of accuracy possible as well as the computation time required. The choice of formula requires a bit more thought than a simple no brainer answer. </p>

<p>This posting from a person at nasa, is the best one I found at discussing the options</p>

<p><a href="http://www.cs.nyu.edu/visual/home/proj/tiger/gisfaq.html" rel="noreferrer">http://www.cs.nyu.edu/visual/home/proj/tiger/gisfaq.html</a></p>

<p>For example, if you are just sorting rows by distance in a 100 miles radius. The flat earth formula will be much faster than the haversine.</p>

<pre><code>HalfPi = 1.5707963;
R = 3956; /* the radius gives you the measurement unit*/

a = HalfPi - latoriginrad;
b = HalfPi - latdestrad;
u = a * a + b * b;
v = - 2 * a * b * cos(longdestrad - longoriginrad);
c = sqrt(abs(u + v));
return R * c;
</code></pre>

<p>Notice there is just one cosine and one square root. Vs 9 of them on the Haversine formula.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/haversine">haversine</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There could be a simpler solution, and more correct: The perimeter of earth is 40,000Km at the equator, about 37,000 on Greenwich (or any longitude) cycle. Thus:</p>

<pre><code>pythagoras = function (lat1, lon1, lat2, lon2) {
   function sqr(x) {return x * x;}
   function cosDeg(x) {return Math.cos(x * Math.PI / 180.0);}

   var earthCyclePerimeter = 40000000.0 * cosDeg((lat1 + lat2) / 2.0);
   var dx = (lon1 - lon2) * earthCyclePerimeter / 360.0;
   var dy = 37000000.0 * (lat1 - lat2) / 360.0;

   return Math.sqrt(sqr(dx) + sqr(dy));
};
</code></pre>

<p>I agree that it should be fine-tuned as, I myself said that it's an ellipsoid, so the radius to be multiplied by the cosine varies. But it's a bit more accurate. Compared with Google Maps and it did reduce the error significantly.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/haversine">haversine</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>All the above answers assumes the earth is a sphere. However, a more accurate approximation would be that of an oblate spheroid.</p>

<pre><code>a= 6378.137#equitorial radius in km
b= 6356.752#polar radius in km

def Distance(lat1, lons1, lat2, lons2):
    lat1=math.radians(lat1)
    lons1=math.radians(lons1)
    R1=(((((a**2)*math.cos(lat1))**2)+(((b**2)*math.sin(lat1))**2))/((a*math.cos(lat1))**2+(b*math.sin(lat1))**2))**0.5 #radius of earth at lat1
    x1=R*math.cos(lat1)*math.cos(lons1)
    y1=R*math.cos(lat1)*math.sin(lons1)
    z1=R*math.sin(lat1)

    lat2=math.radians(lat2)
    lons2=math.radians(lons2)
    R1=(((((a**2)*math.cos(lat2))**2)+(((b**2)*math.sin(lat2))**2))/((a*math.cos(lat2))**2+(b*math.sin(lat2))**2))**0.5 #radius of earth at lat2
    x2=R*math.cos(lat2)*math.cos(lons2)
    y2=R*math.cos(lat2)*math.sin(lons2)
    z2=R*math.sin(lat2)

    return ((x1-x2)**2+(y1-y2)**2+(z1-z2)**2)**0.5
</code></pre>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/haversine">haversine</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><code>pip install haversine</code></p>
<p>Python implementation</p>
<p>Origin is the center of the contiguous United States.</p>
<pre><code>from haversine import haversine, Unit
origin = (39.50, 98.35)
paris = (48.8567, 2.3508)
haversine(origin, paris, unit=Unit.MILES)
</code></pre>
<p>To get the answer in kilometers simply set <code>unit=Unit.KILOMETERS</code> (that's the default).</p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/haversine">haversine</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I don't like adding yet another answer, but the Google maps API v.3 has spherical geometry (and more). After converting your WGS84 to decimal degrees you can do this:</p>

<pre><code>&lt;script src="http://maps.google.com/maps/api/js?sensor=false&amp;libraries=geometry" type="text/javascript"&gt;&lt;/script&gt;  

distance = google.maps.geometry.spherical.computeDistanceBetween(
    new google.maps.LatLng(fromLat, fromLng), 
    new google.maps.LatLng(toLat, toLng));
</code></pre>

<p>No word about how accurate Google's calculations are or even what model is used (though it does say "spherical" rather than "geoid".  By the way, the "straight line" distance will obviously be different from the distance if one travels on the surface of the earth which is what everyone seems to be presuming.</p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/haversine">haversine</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You can use the build in CLLocationDistance to calculate this:</p>

<pre><code>CLLocation *location1 = [[CLLocation alloc] initWithLatitude:latitude1 longitude:longitude1];
CLLocation *location2 = [[CLLocation alloc] initWithLatitude:latitude2 longitude:longitude2];
[self distanceInMetersFromLocation:location1 toLocation:location2]

- (int)distanceInMetersFromLocation:(CLLocation*)location1 toLocation:(CLLocation*)location2 {
    CLLocationDistance distanceInMeters = [location1 distanceFromLocation:location2];
    return distanceInMeters;
}
</code></pre>

<p>In your case if you want kilometers just divide by 1000.</p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/haversine">haversine</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is a <strong>typescript</strong> implementation of the Haversine formula</p>

<pre><code>static getDistanceFromLatLonInKm(lat1: number, lon1: number, lat2: number, lon2: number): number {
    var deg2Rad = deg =&gt; {
        return deg * Math.PI / 180;
    }

    var r = 6371; // Radius of the earth in km
    var dLat = deg2Rad(lat2 - lat1);   
    var dLon = deg2Rad(lon2 - lon1);
    var a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(deg2Rad(lat1)) * Math.cos(deg2Rad(lat2)) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2);
    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    var d = r * c; // Distance in km
    return d;
}
</code></pre>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/haversine">haversine</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As pointed out, an accurate calculation should take into account that the earth is not a perfect sphere. Here are some comparisons of the various algorithms offered here:</p>

<pre><code>geoDistance(50,5,58,3)
Haversine: 899 km
Maymenn: 833 km
Keerthana: 897 km
google.maps.geometry.spherical.computeDistanceBetween(): 900 km

geoDistance(50,5,-58,-3)
Haversine: 12030 km
Maymenn: 11135 km
Keerthana: 10310 km
google.maps.geometry.spherical.computeDistanceBetween(): 12044 km

geoDistance(.05,.005,.058,.003)
Haversine: 0.9169 km
Maymenn: 0.851723 km
Keerthana: 0.917964 km
google.maps.geometry.spherical.computeDistanceBetween(): 0.917964 km

geoDistance(.05,80,.058,80.3)
Haversine: 33.37 km
Maymenn: 33.34 km
Keerthana: 33.40767 km
google.maps.geometry.spherical.computeDistanceBetween(): 33.40770 km
</code></pre>

<p>Over small distances, Keerthana's algorithm does seem to coincide with that of Google Maps. Google Maps does not seem to follow any simple algorithm, suggesting that it may be the most accurate method here.</p>

<p>Anyway, here is a Javascript implementation of Keerthana's algorithm:</p>

<pre><code>function geoDistance(lat1, lng1, lat2, lng2){
    const a = 6378.137; // equitorial radius in km
    const b = 6356.752; // polar radius in km

    var sq = x =&gt; (x*x);
    var sqr = x =&gt; Math.sqrt(x);
    var cos = x =&gt; Math.cos(x);
    var sin = x =&gt; Math.sin(x);
    var radius = lat =&gt; sqr((sq(a*a*cos(lat))+sq(b*b*sin(lat)))/(sq(a*cos(lat))+sq(b*sin(lat))));

    lat1 = lat1 * Math.PI / 180;
    lng1 = lng1 * Math.PI / 180;
    lat2 = lat2 * Math.PI / 180;
    lng2 = lng2 * Math.PI / 180;

    var R1 = radius(lat1);
    var x1 = R1*cos(lat1)*cos(lng1);
    var y1 = R1*cos(lat1)*sin(lng1);
    var z1 = R1*sin(lat1);

    var R2 = radius(lat2);
    var x2 = R2*cos(lat2)*cos(lng2);
    var y2 = R2*cos(lat2)*sin(lng2);
    var z2 = R2*sin(lat2);

    return sqr(sq(x1-x2)+sq(y1-y2)+sq(z1-z2));
}
</code></pre>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/haversine">haversine</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is the SQL Implementation to calculate the distance in km,</p>

<pre><code>SELECT UserId, ( 3959 * acos( cos( radians( your latitude here ) ) * cos( radians(latitude) ) * 
cos( radians(longitude) - radians( your longitude here ) ) + sin( radians( your latitude here ) ) * 
sin( radians(latitude) ) ) ) AS distance FROM user HAVING
distance &lt; 5  ORDER BY distance LIMIT 0 , 5;
</code></pre>

<p>For further details in the implementation by programming langugage, you can just go through the php script given <a href="https://www.geodatasource.com/developers/php" rel="nofollow noreferrer">here</a></p>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 18</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/haversine">haversine</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This script [in PHP] calculates distances between the two points.</p>

<pre><code>public static function getDistanceOfTwoPoints($source, $dest, $unit='K') {
        $lat1 = $source[0];
        $lon1 = $source[1];
        $lat2 = $dest[0];
        $lon2 = $dest[1];

        $theta = $lon1 - $lon2;
        $dist = sin(deg2rad($lat1)) * sin(deg2rad($lat2)) +  cos(deg2rad($lat1)) * cos(deg2rad($lat2)) * cos(deg2rad($theta));
        $dist = acos($dist);
        $dist = rad2deg($dist);
        $miles = $dist * 60 * 1.1515;
        $unit = strtoupper($unit);

        if ($unit == "K") {
            return ($miles * 1.609344);
        }
        else if ($unit == "M")
        {
            return ($miles * 1.609344 * 1000);
        }
        else if ($unit == "N") {
            return ($miles * 0.8684);
        } 
        else {
            return $miles;
        }
    }
</code></pre>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 19</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/haversine">haversine</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<blockquote>
  <p>Java implementation in according <a href="https://en.wikipedia.org/wiki/Haversine_formula" rel="nofollow noreferrer">Haversine formula</a></p>
</blockquote>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">double</span> <span class="hljs-title function_">calculateDistance</span><span class="hljs-params">(<span class="hljs-type">double</span> latPoint1, <span class="hljs-type">double</span> lngPoint1, 
                         <span class="hljs-type">double</span> latPoint2, <span class="hljs-type">double</span> lngPoint2)</span> {
    <span class="hljs-keyword">if</span>(latPoint1 == latPoint2 &amp;&amp; lngPoint1 == lngPoint2) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0d</span>;
    }

    <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">EARTH_RADIUS</span> <span class="hljs-operator">=</span> <span class="hljs-number">6371.0</span>; <span class="hljs-comment">//km value;</span>

    <span class="hljs-comment">//converting to radians</span>
    latPoint1 = Math.toRadians(latPoint1);
    lngPoint1 = Math.toRadians(lngPoint1);
    latPoint2 = Math.toRadians(latPoint2);
    lngPoint2 = Math.toRadians(lngPoint2);

    <span class="hljs-type">double</span> <span class="hljs-variable">distance</span> <span class="hljs-operator">=</span> Math.pow(Math.sin((latPoint2 - latPoint1) / <span class="hljs-number">2.0</span>), <span class="hljs-number">2</span>) 
            + Math.cos(latPoint1) * Math.cos(latPoint2)
            * Math.pow(Math.sin((lngPoint2 - lngPoint1) / <span class="hljs-number">2.0</span>), <span class="hljs-number">2</span>);
    distance = <span class="hljs-number">2.0</span> * EARTH_RADIUS * Math.asin(Math.sqrt(distance));

    <span class="hljs-keyword">return</span> distance; <span class="hljs-comment">//km value</span>
}
</code></pre>
    </div></div></div></div><div id="solution20" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 20</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/haversine">haversine</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>To calculate the distance between two points on a sphere you need to do the <a href="http://en.wikipedia.org/wiki/Great-circle_distance" rel="nofollow noreferrer">Great Circle calculation</a>. </p>

<p>There are a number of C/C++ libraries to help with map projection at <a href="http://www.maptools.org/" rel="nofollow noreferrer">MapTools</a> if you need to reproject your distances to a flat surface.  To do this you will need the projection string of the various coordinate systems.</p>

<p>You may also find <a href="http://www.mapwindow.org/" rel="nofollow noreferrer">MapWindow</a> a useful tool to visualise the points.  Also as its open source its a useful guide to how to use the proj.dll library, which appears to be the core open source projection library.</p>
    </div></div></div></div><div id="solution21" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 21</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/haversine">haversine</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is my java implementation for calculation distance via decimal degrees after some search. I used mean radius of world (from wikipedia) in km. İf you want result miles then use world radius in miles.</p>

<pre><code>public static double distanceLatLong2(double lat1, double lng1, double lat2, double lng2) 
{
  double earthRadius = 6371.0d; // KM: use mile here if you want mile result

  double dLat = toRadian(lat2 - lat1);
  double dLng = toRadian(lng2 - lng1);

  double a = Math.pow(Math.sin(dLat/2), 2)  + 
          Math.cos(toRadian(lat1)) * Math.cos(toRadian(lat2)) * 
          Math.pow(Math.sin(dLng/2), 2);

  double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

  return earthRadius * c; // returns result kilometers
}

public static double toRadian(double degrees) 
{
  return (degrees * Math.PI) / 180.0d;
}
</code></pre>
    </div></div></div></div><div id="solution22" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 22</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/haversine">haversine</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here's the accepted answer implementation ported to Java in case anyone needs it.</p>

<pre><code>package com.project529.garage.util;


/**
 * Mean radius.
 */
private static double EARTH_RADIUS = 6371;

/**
 * Returns the distance between two sets of latitudes and longitudes in meters.
 * &lt;p/&gt;
 * Based from the following JavaScript SO answer:
 * http://stackoverflow.com/questions/27928/calculate-distance-between-two-latitude-longitude-points-haversine-formula,
 * which is based on https://en.wikipedia.org/wiki/Haversine_formula (error rate: ~0.55%).
 */
public double getDistanceBetween(double lat1, double lon1, double lat2, double lon2) {
    double dLat = toRadians(lat2 - lat1);
    double dLon = toRadians(lon2 - lon1);

    double a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(toRadians(lat1)) * Math.cos(toRadians(lat2)) *
                    Math.sin(dLon / 2) * Math.sin(dLon / 2);
    double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    double d = EARTH_RADIUS * c;

    return d;
}

public double toRadians(double degrees) {
    return degrees * (Math.PI / 180);
}
</code></pre>
    </div></div></div></div><div id="solution23" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 23</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/haversine">haversine</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>here is an example in <strong>postgres</strong> sql (in km, for miles version, replace 1.609344 by 0.8684 version)</p>

<pre><code>CREATE OR REPLACE FUNCTION public.geodistance(alat float, alng float, blat  

float, blng  float)
  RETURNS float AS
$BODY$
DECLARE
    v_distance float;
BEGIN

    v_distance = asin( sqrt(
            sin(radians(blat-alat)/2)^2 
                + (
                    (sin(radians(blng-alng)/2)^2) *
                    cos(radians(alat)) *
                    cos(radians(blat))
                )
          )
        ) * cast('7926.3352' as float) * cast('1.609344' as float) ;


    RETURN v_distance;
END 
$BODY$
language plpgsql VOLATILE SECURITY DEFINER;
alter function geodistance(alat float, alng float, blat float, blng float)
owner to postgres;
</code></pre>
    </div></div></div></div><div id="solution24" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 24</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/haversine">haversine</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>For those looking for an Excel formula based on WGS-84 &amp; GRS-80 standards:</p>

<pre><code>=ACOS(COS(RADIANS(90-Lat1))*COS(RADIANS(90-Lat2))+SIN(RADIANS(90-Lat1))*SIN(RADIANS(90-Lat2))*COS(RADIANS(Long1-Long2)))*6371
</code></pre>

<p><a href="https://bluemm.blogspot.com/2007/01/excel-formula-to-calculate-distance.html" rel="nofollow noreferrer">Source</a></p>
    </div></div></div></div><div id="solution25" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 25</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/haversine">haversine</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I made a custom function in R to calculate haversine distance(km) between two spatial points using functions available in R base package.</p>
<pre><code>custom_hav_dist &lt;- function(lat1, lon1, lat2, lon2) {
R &lt;- 6371
Radian_factor &lt;- 0.0174533
lat_1 &lt;- (90-lat1)*Radian_factor
lat_2 &lt;- (90-lat2)*Radian_factor
diff_long &lt;-(lon1-lon2)*Radian_factor

distance_in_km &lt;- 6371*acos((cos(lat_1)*cos(lat_2))+ 
                 (sin(lat_1)*sin(lat_2)*cos(diff_long)))
rm(lat1, lon1, lat2, lon2)
return(distance_in_km)
}
</code></pre>
<p>Sample output</p>
<pre><code>custom_hav_dist(50.31,19.08,54.14,19.39)
[1] 426.3987
</code></pre>
<p>PS: To calculate distances in miles, substitute R in function (6371) with 3958.756 (and for nautical miles, use 3440.065).</p>
    </div></div></div></div><div id="solution26" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 26</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/haversine">haversine</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>there is a good example in here to calculate distance with PHP <a href="http://www.geodatasource.com/developers/php" rel="nofollow">http://www.geodatasource.com/developers/php</a> :</p>

<pre><code> function distance($lat1, $lon1, $lat2, $lon2, $unit) {

     $theta = $lon1 - $lon2;
     $dist = sin(deg2rad($lat1)) * sin(deg2rad($lat2)) +  cos(deg2rad($lat1)) * cos(deg2rad($lat2)) * cos(deg2rad($theta));
     $dist = acos($dist);
     $dist = rad2deg($dist);
     $miles = $dist * 60 * 1.1515;
     $unit = strtoupper($unit);

     if ($unit == "K") {
         return ($miles * 1.609344);
     } else if ($unit == "N") {
          return ($miles * 0.8684);
     } else {
          return $miles;
     }
 }
</code></pre>
    </div></div></div></div><div id="solution27" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 27</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/haversine">haversine</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is the implementation VB.NET, this implementation will give you the result in KM or Miles based on an Enum value you pass.</p>

<pre><code>Public Enum DistanceType
    Miles
    KiloMeters
End Enum

Public Structure Position
    Public Latitude As Double
    Public Longitude As Double
End Structure

Public Class Haversine

    Public Function Distance(Pos1 As Position,
                             Pos2 As Position,
                             DistType As DistanceType) As Double

        Dim R As Double = If((DistType = DistanceType.Miles), 3960, 6371)

        Dim dLat As Double = Me.toRadian(Pos2.Latitude - Pos1.Latitude)

        Dim dLon As Double = Me.toRadian(Pos2.Longitude - Pos1.Longitude)

        Dim a As Double = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) + Math.Cos(Me.toRadian(Pos1.Latitude)) * Math.Cos(Me.toRadian(Pos2.Latitude)) * Math.Sin(dLon / 2) * Math.Sin(dLon / 2)

        Dim c As Double = 2 * Math.Asin(Math.Min(1, Math.Sqrt(a)))

        Dim result As Double = R * c

        Return result

    End Function

    Private Function toRadian(val As Double) As Double

        Return (Math.PI / 180) * val

    End Function

End Class
</code></pre>
    </div></div></div></div><div id="solution28" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 28</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/haversine">haversine</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I condensed the computation down by simplifying the formula.</p>

<p>Here it is in Ruby:</p>

<pre><code>include Math
earth_radius_mi = 3959
radians = lambda { |deg| deg * PI / 180 }
coord_radians = lambda { |c| { :lat =&gt; radians[c[:lat]], :lng =&gt; radians[c[:lng]] } }

# from/to = { :lat =&gt; (latitude_in_degrees), :lng =&gt; (longitude_in_degrees) }
def haversine_distance(from, to)
  from, to = coord_radians[from], coord_radians[to]
  cosines_product = cos(to[:lat]) * cos(from[:lat]) * cos(from[:lng] - to[:lng])
  sines_product = sin(to[:lat]) * sin(from[:lat])
  return earth_radius_mi * acos(cosines_product + sines_product)
end
</code></pre>
    </div></div></div></div><div id="solution29" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 29</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/haversine">haversine</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre><code>function getDistanceFromLatLonInKm(lat1,lon1,lat2,lon2,units) {
  var R = 6371; // Radius of the earth in km
  var dLat = deg2rad(lat2-lat1);  // deg2rad below
  var dLon = deg2rad(lon2-lon1); 
  var a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * 
    Math.sin(dLon/2) * Math.sin(dLon/2)
    ; 
  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
  var d = R * c; 
  var miles = d / 1.609344; 

if ( units == 'km' ) {  
return d; 
 } else {
return miles;
}}
</code></pre>

<p>Chuck's solution, valid for miles also.</p>
    </div></div></div></div><div id="solution30" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 30</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/maps">maps</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/latitude-longitude">latitude-longitude</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/haversine">haversine</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In Mysql use the following function pass the parameters as using  <code>POINT(LONG,LAT)</code></p>

<pre><code>CREATE FUNCTION `distance`(a POINT, b POINT)
 RETURNS double
    DETERMINISTIC
BEGIN

RETURN

GLength( LineString(( PointFromWKB(a)), (PointFromWKB(b)))) * 100000; -- To Make the distance in meters

END;
</code></pre>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/when-can-i-use-a-forward-declaration-1657388251827">When can I use a forward declaration?</a><a href="/questions/javascript-function-doesn&#x27;t-work-when-link-is-clicked-1657387767488">javascript function doesn&#x27;t work when link is clicked</a><a href="/questions/how-to-use-threetenabp-in-android-project-1657384345704">How to use ThreeTenABP in Android Project</a><a href="/questions/how-do-i-revert-a-git-repository-to-a-previous-commit-1657387714717">How do I revert a Git repository to a previous commit?</a><a href="/questions/transitions-on-the-css-display-property-1657387761601">Transitions on the CSS display property</a><a href="/questions/how-do-i-split-a-delimited-string-so-i-can-access-individual-items-1657388042385">How do I split a delimited string so I can access individual items?</a><a href="/questions/how-does-the-windows-command-interpreter-(cmd.exe)-parse-scripts-1657387731560">How does the Windows Command Interpreter (CMD.EXE) parse scripts?</a><a href="/questions/what-does-**-(double-starasterisk)-and-*-(starasterisk)-do-for-parameters-1657384800967">What does ** (double star/asterisk) and * (star/asterisk) do for parameters?</a><a href="/questions/what-are-the-nuances-of-scope-prototypal-prototypical-inheritance-in-angularjs-1657387340067">What are the nuances of scope prototypal / prototypical inheritance in AngularJS?</a><a href="/questions/how-do-i-detect-collision-in-pygame-1657387496338">How do I detect collision in pygame?</a><a href="/questions/prefer-composition-over-inheritance-1657387399409">Prefer composition over inheritance?</a><a href="/questions/safely-turning-a-json-string-into-an-object-1657388194824">Safely turning a JSON string into an object</a><a href="/questions/what&#x27;s-the-meaning-of-%22greater%22-(an-arrow-formed-from-equals-and-greater-than)-in-javascript-1657387977118">What&#x27;s the meaning of &quot;=&gt;&quot; (an arrow formed from equals &amp; greater than) in JavaScript?</a><a href="/questions/commandbuttoncommandlinkajax-actionlistener-method-not-invoked-or-input-value-not-setupdated-1657384667519">commandButton/commandLink/ajax action/listener method not invoked or input value not set/updated</a><a href="/questions/how-to-store-objects-in-html5-localstorage-1657387568907">How to store objects in HTML5 localStorage</a><a href="/questions/what-is-the-difference-between-const-int*-const-int-*-const-and-int-const-*-1657388184604">What is the difference between const int*, const int * const, and int const *?</a><a href="/questions/%22thinking-in-angularjs%22-if-i-have-a-jquery-background-closed-1657384761159">&quot;Thinking in AngularJS&quot; if I have a jQuery background? [closed]</a><a href="/questions/get-the-values-from-the-%22get%22-parameters-(javascript)-duplicate-1657387656693">Get the values from the &quot;GET&quot; parameters (JavaScript) [duplicate]</a><a href="/questions/how-can-i-remove-a-specific-item-from-an-array-1657387552077">How can I remove a specific item from an array?</a><a href="/questions/how-to-replace-all-occurrences-of-a-string-in-javascript-1657384895467">How to replace all occurrences of a string in JavaScript</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;This \u0026lt;a href=\u0026quot;http://www.movable-type.co.uk/scripts/latlong.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;link\u0026lt;/a\u0026gt; might be helpful to you, as it details the use of the \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Haversine_formula\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Haversine formula\u0026lt;/a\u0026gt; to calculate the distance.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Excerpt:\u0026lt;/p\u0026gt;\n\n\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;This script [in Javascript] calculates great-circle distances between the two points \n  that is, the shortest distance over the earths surface  using the\n  Haversine formula.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getDistanceFromLatLonInKm\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;lat1,lon1,lat2,lon2\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; R = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6371\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Radius of the earth in km\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; dLat = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;deg2rad\u0026lt;/span\u0026gt;(lat2-lat1);  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// deg2rad below\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; dLon = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;deg2rad\u0026lt;/span\u0026gt;(lon2-lon1); \n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = \n    \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sin\u0026lt;/span\u0026gt;(dLat/\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) * \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sin\u0026lt;/span\u0026gt;(dLat/\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) +\n    \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;cos\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;deg2rad\u0026lt;/span\u0026gt;(lat1)) * \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;cos\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;deg2rad\u0026lt;/span\u0026gt;(lat2)) * \n    \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sin\u0026lt;/span\u0026gt;(dLon/\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) * \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sin\u0026lt;/span\u0026gt;(dLon/\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)\n    ; \n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; c = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; * \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;atan2\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sqrt\u0026lt;/span\u0026gt;(a), \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sqrt\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;-a)); \n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; d = R * c; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Distance in km\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; d;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;deg2rad\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;deg\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; deg * (\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;PI\u0026lt;/span\u0026gt;/\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;180\u0026lt;/span\u0026gt;)\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I needed to calculate a lot of distances between the points for my project, so I went ahead and tried to optimize the code, I have found here. On average in different browsers my new implementation \u0026lt;strong\u0026gt;runs 2 times faster\u0026lt;/strong\u0026gt; than the most upvoted answer.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;distance\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;lat1, lon1, lat2, lon2\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; p = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.017453292519943295\u0026lt;/span\u0026gt;;    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Math.PI / 180\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; c = \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;cos\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.5\u0026lt;/span\u0026gt; - \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt;((lat2 - lat1) * p)/\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; + \n          \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt;(lat1 * p) * \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt;(lat2 * p) * \n          (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; - \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt;((lon2 - lon1) * p))/\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12742\u0026lt;/span\u0026gt; * \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;asin\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sqrt\u0026lt;/span\u0026gt;(a)); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 2 * R; R = 6371 km\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;You can play with my jsPerf and see the \u0026lt;a href=\u0026quot;http://jsperf.com/haversine-salvador/8\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;results here\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Recently I needed to do the same in python, so here is a \u0026lt;strong\u0026gt;python implementation\u0026lt;/strong\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-python s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; math \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; cos, asin, sqrt, pi\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;distance\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;lat1, lon1, lat2, lon2\u0026lt;/span\u0026gt;):\n    p = pi/\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;180\u0026lt;/span\u0026gt;\n    a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.5\u0026lt;/span\u0026gt; - cos((lat2-lat1)*p)/\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; + cos(lat1*p) * cos(lat2*p) * (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;-cos((lon2-lon1)*p))/\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12742\u0026lt;/span\u0026gt; * asin(sqrt(a)) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#2*R*asin...\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;And for the sake of completeness: \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Haversine_formula\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Haversine\u0026lt;/a\u0026gt; on Wikipedia.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is a C# Implementation:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;DistanceAlgorithm\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; PIx = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3.141592653589793\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; RADIUS = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6378.16\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;summary\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; Convert degrees to Radians\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/summary\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;param name=\u0026quot;x\u0026quot;\u0026amp;gt;\u0026lt;/span\u0026gt;Degrees\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/param\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;returns\u0026amp;gt;\u0026lt;/span\u0026gt;The equivalent in radians\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/returns\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Radians\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; x\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; x * PIx / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;180\u0026lt;/span\u0026gt;;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;summary\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; Calculate the distance between two places.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/summary\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;param name=\u0026quot;lon1\u0026quot;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/param\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;param name=\u0026quot;lat1\u0026quot;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/param\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;param name=\u0026quot;lon2\u0026quot;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/param\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;param name=\u0026quot;lat2\u0026quot;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/param\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;returns\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/returns\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;DistanceBetweenPlaces\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; lon1,\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; lat1,\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; lon2,\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; lat2\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; dlon = Radians(lon2 - lon1);\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; dlat = Radians(lat2 - lat1);\n\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; a = (Math.Sin(dlat / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) * Math.Sin(dlat / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)) + Math.Cos(Radians(lat1)) * Math.Cos(Radians(lat2)) * (Math.Sin(dlon / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) * Math.Sin(dlon / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;));\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; angle = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; * Math.Atan2(Math.Sqrt(a), Math.Sqrt(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; - a));\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; angle * RADIUS;\n    }\n\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is a java implementation of the Haversine formula.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;AVERAGE_RADIUS_OF_EARTH_KM\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6371\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;calculateDistanceInKilometer\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; userLat, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; userLng,\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; venueLat, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; venueLng)\u0026lt;/span\u0026gt; {\n\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;latDistance\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; Math.toRadians(userLat - venueLat);\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;lngDistance\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; Math.toRadians(userLng - venueLng);\n\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; Math.sin(latDistance / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) * Math.sin(latDistance / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)\n      + Math.cos(Math.toRadians(userLat)) * Math.cos(Math.toRadians(venueLat))\n      * Math.sin(lngDistance / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) * Math.sin(lngDistance / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;);\n\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; * Math.atan2(Math.sqrt(a), Math.sqrt(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; - a));\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;) (Math.round(AVERAGE_RADIUS_OF_EARTH_KM * c));\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that here we are rounding the answer to the nearest km.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Thanks very much for all this. I used the following code in my Objective-C iPhone app:\u0026lt;/p\u0026gt;\n\n\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; PIx = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3.141592653589793\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; RADIO = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6371\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Mean radius of Earth in Km\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;convertToRadians\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; val)\u0026lt;/span\u0026gt; {\n\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; val * PIx / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;180\u0026lt;/span\u0026gt;;\n}\n\n-(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;)kilometresBetweenPlace1:(CLLocationCoordinate2D) place1 andPlace2:(CLLocationCoordinate2D) place2 {\n\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; dlon = convertToRadians(place2.longitude - place1.longitude);\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; dlat = convertToRadians(place2.latitude - place1.latitude);\n\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; a = ( \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;pow\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sin\u0026lt;/span\u0026gt;(dlat / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;), \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) + \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cos\u0026lt;/span\u0026gt;(convertToRadians(place1.latitude))) * \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cos\u0026lt;/span\u0026gt;(convertToRadians(place2.latitude)) * \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;pow\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sin\u0026lt;/span\u0026gt;(dlon / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;), \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; angle = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; * \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;asin\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sqrt\u0026lt;/span\u0026gt;(a));\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; angle * RADIO;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Latitude and Longitude are in decimal. I didn\u0026apos;t use min() for the asin() call as the distances that I\u0026apos;m using are so small that they don\u0026apos;t require it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It gave incorrect answers until I passed in the values in Radians - now it\u0026apos;s pretty much the same as the values obtained from Apple\u0026apos;s Map app :-)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Extra update:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you are using iOS4 or later then Apple provide some methods to do this so the same functionality would be achieved with:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;-(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;)kilometresBetweenPlace1:(CLLocationCoordinate2D) place1 andPlace2:(CLLocationCoordinate2D) place2 {\n\n    MKMapPoint  start, finish;\n\n\n    start = MKMapPointForCoordinate(place1);\n    finish = MKMapPointForCoordinate(place2);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; MKMetersBetweenMapPoints(start, finish) / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is a simple PHP function that will give a very reasonable approximation (under +/-1% error margin).  \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-php s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;lt;?php\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;distance\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$lat1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$lon1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$lat2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$lon2\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;) \u0026lt;/span\u0026gt;{\n\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$pi80\u0026lt;/span\u0026gt; = M_PI / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;180\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$lat1\u0026lt;/span\u0026gt; *= \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$pi80\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$lon1\u0026lt;/span\u0026gt; *= \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$pi80\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$lat2\u0026lt;/span\u0026gt; *= \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$pi80\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$lon2\u0026lt;/span\u0026gt; *= \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$pi80\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$r\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6372.797\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// mean radius of Earth in km\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$dlat\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$lat2\u0026lt;/span\u0026gt; - \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$lat1\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$dlon\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$lon2\u0026lt;/span\u0026gt; - \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$lon1\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$a\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;sin\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$dlat\u0026lt;/span\u0026gt; / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) * \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;sin\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$dlat\u0026lt;/span\u0026gt; / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) + \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;cos\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$lat1\u0026lt;/span\u0026gt;) * \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;cos\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$lat2\u0026lt;/span\u0026gt;) * \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;sin\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$dlon\u0026lt;/span\u0026gt; / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) * \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;sin\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$dlon\u0026lt;/span\u0026gt; / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$c\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; * \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;atan2\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;sqrt\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$a\u0026lt;/span\u0026gt;), \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;sqrt\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; - \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$a\u0026lt;/span\u0026gt;));\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$km\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$r\u0026lt;/span\u0026gt; * \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$c\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//echo \u0026apos;\u0026amp;lt;br/\u0026amp;gt;\u0026apos;.$km;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$km\u0026lt;/span\u0026gt;;\n}\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;?\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;As said before; the earth is NOT a sphere.  It is like an old, old baseball that Mark McGwire decided to practice with - it is full of dents and bumps.  The simpler calculations (like this) treat it like a sphere.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Different methods may be more or less precise according to where you are on this irregular ovoid AND how far apart your points are (the closer they are the smaller the absolute error margin).  The more precise your expectation, the more complex the math.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For more info: \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Geographical_distance\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;wikipedia geographic distance\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I post here my working example.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;List all points in table having distance between a designated point (we use a random point - lat:45.20327, long:23.7806) less than 50 KM, with latitude \u0026amp;amp; longitude, in MySQL (the table fields are coord_lat and coord_long):\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;List all having DISTANCE\u0026amp;lt;50, in Kilometres (considered Earth radius 6371 KM):\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-sql s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-sql\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;SELECT\u0026lt;/span\u0026gt; denumire, (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6371\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;acos\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cos\u0026lt;/span\u0026gt;( radians(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;45.20327\u0026lt;/span\u0026gt;) ) \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cos\u0026lt;/span\u0026gt;( radians( coord_lat ) ) \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cos\u0026lt;/span\u0026gt;( radians( \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;23.7806\u0026lt;/span\u0026gt; ) \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;-\u0026lt;/span\u0026gt; radians(coord_long) ) \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;+\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sin\u0026lt;/span\u0026gt;( radians(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;45.20327\u0026lt;/span\u0026gt;) ) \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sin\u0026lt;/span\u0026gt;( radians(coord_lat) ) )) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;AS\u0026lt;/span\u0026gt; distanta \n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;FROM\u0026lt;/span\u0026gt; obiective \n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;WHERE\u0026lt;/span\u0026gt; coord_lat\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;\u0026amp;lt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026apos;\u0026lt;/span\u0026gt; \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;AND\u0026lt;/span\u0026gt; coord_long\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;\u0026amp;lt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026apos;\u0026lt;/span\u0026gt; \n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;HAVING\u0026lt;/span\u0026gt; distanta\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;50\u0026lt;/span\u0026gt; \n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ORDER\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;BY\u0026lt;/span\u0026gt; distanta \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;desc\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The above example was tested in MySQL 5.0.95 and 5.5.16 (Linux). \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In the other answers an implementation in \u0026lt;a href=\u0026quot;/questions/tagged/r\u0026quot; class=\u0026quot;post-tag\u0026quot; title=\u0026quot;show questions tagged \u0026apos;r\u0026apos;\u0026quot; rel=\u0026quot;tag\u0026quot;\u0026gt;r\u0026lt;/a\u0026gt; is missing.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Calculating the distance between two point is quite straightforward with the \u0026lt;code\u0026gt;distm\u0026lt;/code\u0026gt; function from the \u0026lt;code\u0026gt;geosphere\u0026lt;/code\u0026gt; package:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;distm(p1, p2, fun = distHaversine)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;where:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;p1 = longitude/latitude for point(s)\np2 = longitude/latitude for point(s)\n# type of distance calculation\nfun = distCosine / distHaversine / distVincentySphere / distVincentyEllipsoid \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;As the earth is not perfectly spherical, the \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Vincenty%27s_formulae\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Vincenty formula for ellipsoids\u0026lt;/a\u0026gt; is probably the best way to calculate distances. Thus in the \u0026lt;code\u0026gt;geosphere\u0026lt;/code\u0026gt; package you use then:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;distm(p1, p2, fun = distVincentyEllipsoid)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Off course you don\u0026apos;t necessarily have to use \u0026lt;code\u0026gt;geosphere\u0026lt;/code\u0026gt; package, you can also calculate the distance in base \u0026lt;code\u0026gt;R\u0026lt;/code\u0026gt; with a function:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;hav.dist \u0026amp;lt;- function(long1, lat1, long2, lat2) {\n  R \u0026amp;lt;- 6371\n  diff.long \u0026amp;lt;- (long2 - long1)\n  diff.lat \u0026amp;lt;- (lat2 - lat1)\n  a \u0026amp;lt;- sin(diff.lat/2)^2 + cos(lat1) * cos(lat2) * sin(diff.long/2)^2\n  b \u0026amp;lt;- 2 * asin(pmin(1, sqrt(a))) \n  d = R * b\n  return(d)\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The haversine is definitely a good formula for probably most cases, other answers already include it so I am not going to take the space. But it is important to note that no matter what formula is used (yes not just one). Because of the huge range of accuracy possible as well as the computation time required. The choice of formula requires a bit more thought than a simple no brainer answer. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This posting from a person at nasa, is the best one I found at discussing the options\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://www.cs.nyu.edu/visual/home/proj/tiger/gisfaq.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://www.cs.nyu.edu/visual/home/proj/tiger/gisfaq.html\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example, if you are just sorting rows by distance in a 100 miles radius. The flat earth formula will be much faster than the haversine.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;HalfPi = 1.5707963;\nR = 3956; /* the radius gives you the measurement unit*/\n\na = HalfPi - latoriginrad;\nb = HalfPi - latdestrad;\nu = a * a + b * b;\nv = - 2 * a * b * cos(longdestrad - longoriginrad);\nc = sqrt(abs(u + v));\nreturn R * c;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Notice there is just one cosine and one square root. Vs 9 of them on the Haversine formula.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There could be a simpler solution, and more correct: The perimeter of earth is 40,000Km at the equator, about 37,000 on Greenwich (or any longitude) cycle. Thus:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;pythagoras = function (lat1, lon1, lat2, lon2) {\n   function sqr(x) {return x * x;}\n   function cosDeg(x) {return Math.cos(x * Math.PI / 180.0);}\n\n   var earthCyclePerimeter = 40000000.0 * cosDeg((lat1 + lat2) / 2.0);\n   var dx = (lon1 - lon2) * earthCyclePerimeter / 360.0;\n   var dy = 37000000.0 * (lat1 - lat2) / 360.0;\n\n   return Math.sqrt(sqr(dx) + sqr(dy));\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I agree that it should be fine-tuned as, I myself said that it\u0026apos;s an ellipsoid, so the radius to be multiplied by the cosine varies. But it\u0026apos;s a bit more accurate. Compared with Google Maps and it did reduce the error significantly.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;All the above answers assumes the earth is a sphere. However, a more accurate approximation would be that of an oblate spheroid.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;a= 6378.137#equitorial radius in km\nb= 6356.752#polar radius in km\n\ndef Distance(lat1, lons1, lat2, lons2):\n    lat1=math.radians(lat1)\n    lons1=math.radians(lons1)\n    R1=(((((a**2)*math.cos(lat1))**2)+(((b**2)*math.sin(lat1))**2))/((a*math.cos(lat1))**2+(b*math.sin(lat1))**2))**0.5 #radius of earth at lat1\n    x1=R*math.cos(lat1)*math.cos(lons1)\n    y1=R*math.cos(lat1)*math.sin(lons1)\n    z1=R*math.sin(lat1)\n\n    lat2=math.radians(lat2)\n    lons2=math.radians(lons2)\n    R1=(((((a**2)*math.cos(lat2))**2)+(((b**2)*math.sin(lat2))**2))/((a*math.cos(lat2))**2+(b*math.sin(lat2))**2))**0.5 #radius of earth at lat2\n    x2=R*math.cos(lat2)*math.cos(lons2)\n    y2=R*math.cos(lat2)*math.sin(lons2)\n    z2=R*math.sin(lat2)\n\n    return ((x1-x2)**2+(y1-y2)**2+(z1-z2)**2)**0.5\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;pip install haversine\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Python implementation\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Origin is the center of the contiguous United States.\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;from haversine import haversine, Unit\norigin = (39.50, 98.35)\nparis = (48.8567, 2.3508)\nhaversine(origin, paris, unit=Unit.MILES)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;To get the answer in kilometers simply set \u0026lt;code\u0026gt;unit=Unit.KILOMETERS\u0026lt;/code\u0026gt; (that\u0026apos;s the default).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I don\u0026apos;t like adding yet another answer, but the Google maps API v.3 has spherical geometry (and more). After converting your WGS84 to decimal degrees you can do this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;\u0026amp;lt;script src=\u0026quot;http://maps.google.com/maps/api/js?sensor=false\u0026amp;amp;libraries=geometry\u0026quot; type=\u0026quot;text/javascript\u0026quot;\u0026amp;gt;\u0026amp;lt;/script\u0026amp;gt;  \n\ndistance = google.maps.geometry.spherical.computeDistanceBetween(\n    new google.maps.LatLng(fromLat, fromLng), \n    new google.maps.LatLng(toLat, toLng));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;No word about how accurate Google\u0026apos;s calculations are or even what model is used (though it does say \u0026quot;spherical\u0026quot; rather than \u0026quot;geoid\u0026quot;.  By the way, the \u0026quot;straight line\u0026quot; distance will obviously be different from the distance if one travels on the surface of the earth which is what everyone seems to be presuming.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You can use the build in CLLocationDistance to calculate this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;CLLocation *location1 = [[CLLocation alloc] initWithLatitude:latitude1 longitude:longitude1];\nCLLocation *location2 = [[CLLocation alloc] initWithLatitude:latitude2 longitude:longitude2];\n[self distanceInMetersFromLocation:location1 toLocation:location2]\n\n- (int)distanceInMetersFromLocation:(CLLocation*)location1 toLocation:(CLLocation*)location2 {\n    CLLocationDistance distanceInMeters = [location1 distanceFromLocation:location2];\n    return distanceInMeters;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In your case if you want kilometers just divide by 1000.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is a \u0026lt;strong\u0026gt;typescript\u0026lt;/strong\u0026gt; implementation of the Haversine formula\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;static getDistanceFromLatLonInKm(lat1: number, lon1: number, lat2: number, lon2: number): number {\n    var deg2Rad = deg =\u0026amp;gt; {\n        return deg * Math.PI / 180;\n    }\n\n    var r = 6371; // Radius of the earth in km\n    var dLat = deg2Rad(lat2 - lat1);   \n    var dLon = deg2Rad(lon2 - lon1);\n    var a =\n        Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n        Math.cos(deg2Rad(lat1)) * Math.cos(deg2Rad(lat2)) *\n        Math.sin(dLon / 2) * Math.sin(dLon / 2);\n    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    var d = r * c; // Distance in km\n    return d;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As pointed out, an accurate calculation should take into account that the earth is not a perfect sphere. Here are some comparisons of the various algorithms offered here:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;geoDistance(50,5,58,3)\nHaversine: 899 km\nMaymenn: 833 km\nKeerthana: 897 km\ngoogle.maps.geometry.spherical.computeDistanceBetween(): 900 km\n\ngeoDistance(50,5,-58,-3)\nHaversine: 12030 km\nMaymenn: 11135 km\nKeerthana: 10310 km\ngoogle.maps.geometry.spherical.computeDistanceBetween(): 12044 km\n\ngeoDistance(.05,.005,.058,.003)\nHaversine: 0.9169 km\nMaymenn: 0.851723 km\nKeerthana: 0.917964 km\ngoogle.maps.geometry.spherical.computeDistanceBetween(): 0.917964 km\n\ngeoDistance(.05,80,.058,80.3)\nHaversine: 33.37 km\nMaymenn: 33.34 km\nKeerthana: 33.40767 km\ngoogle.maps.geometry.spherical.computeDistanceBetween(): 33.40770 km\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Over small distances, Keerthana\u0026apos;s algorithm does seem to coincide with that of Google Maps. Google Maps does not seem to follow any simple algorithm, suggesting that it may be the most accurate method here.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Anyway, here is a Javascript implementation of Keerthana\u0026apos;s algorithm:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;function geoDistance(lat1, lng1, lat2, lng2){\n    const a = 6378.137; // equitorial radius in km\n    const b = 6356.752; // polar radius in km\n\n    var sq = x =\u0026amp;gt; (x*x);\n    var sqr = x =\u0026amp;gt; Math.sqrt(x);\n    var cos = x =\u0026amp;gt; Math.cos(x);\n    var sin = x =\u0026amp;gt; Math.sin(x);\n    var radius = lat =\u0026amp;gt; sqr((sq(a*a*cos(lat))+sq(b*b*sin(lat)))/(sq(a*cos(lat))+sq(b*sin(lat))));\n\n    lat1 = lat1 * Math.PI / 180;\n    lng1 = lng1 * Math.PI / 180;\n    lat2 = lat2 * Math.PI / 180;\n    lng2 = lng2 * Math.PI / 180;\n\n    var R1 = radius(lat1);\n    var x1 = R1*cos(lat1)*cos(lng1);\n    var y1 = R1*cos(lat1)*sin(lng1);\n    var z1 = R1*sin(lat1);\n\n    var R2 = radius(lat2);\n    var x2 = R2*cos(lat2)*cos(lng2);\n    var y2 = R2*cos(lat2)*sin(lng2);\n    var z2 = R2*sin(lat2);\n\n    return sqr(sq(x1-x2)+sq(y1-y2)+sq(z1-z2));\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is the SQL Implementation to calculate the distance in km,\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;SELECT UserId, ( 3959 * acos( cos( radians( your latitude here ) ) * cos( radians(latitude) ) * \ncos( radians(longitude) - radians( your longitude here ) ) + sin( radians( your latitude here ) ) * \nsin( radians(latitude) ) ) ) AS distance FROM user HAVING\ndistance \u0026amp;lt; 5  ORDER BY distance LIMIT 0 , 5;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;For further details in the implementation by programming langugage, you can just go through the php script given \u0026lt;a href=\u0026quot;https://www.geodatasource.com/developers/php\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This script [in PHP] calculates distances between the two points.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;public static function getDistanceOfTwoPoints($source, $dest, $unit=\u0026apos;K\u0026apos;) {\n        $lat1 = $source[0];\n        $lon1 = $source[1];\n        $lat2 = $dest[0];\n        $lon2 = $dest[1];\n\n        $theta = $lon1 - $lon2;\n        $dist = sin(deg2rad($lat1)) * sin(deg2rad($lat2)) +  cos(deg2rad($lat1)) * cos(deg2rad($lat2)) * cos(deg2rad($theta));\n        $dist = acos($dist);\n        $dist = rad2deg($dist);\n        $miles = $dist * 60 * 1.1515;\n        $unit = strtoupper($unit);\n\n        if ($unit == \u0026quot;K\u0026quot;) {\n            return ($miles * 1.609344);\n        }\n        else if ($unit == \u0026quot;M\u0026quot;)\n        {\n            return ($miles * 1.609344 * 1000);\n        }\n        else if ($unit == \u0026quot;N\u0026quot;) {\n            return ($miles * 0.8684);\n        } \n        else {\n            return $miles;\n        }\n    }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Java implementation in according \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Haversine_formula\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Haversine formula\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;calculateDistance\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; latPoint1, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; lngPoint1, \n                         \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; latPoint2, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; lngPoint2)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(latPoint1 == latPoint2 \u0026amp;amp;\u0026amp;amp; lngPoint1 == lngPoint2) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0d\u0026lt;/span\u0026gt;;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;EARTH_RADIUS\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6371.0\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//km value;\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//converting to radians\u0026lt;/span\u0026gt;\n    latPoint1 = Math.toRadians(latPoint1);\n    lngPoint1 = Math.toRadians(lngPoint1);\n    latPoint2 = Math.toRadians(latPoint2);\n    lngPoint2 = Math.toRadians(lngPoint2);\n\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;distance\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; Math.pow(Math.sin((latPoint2 - latPoint1) / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2.0\u0026lt;/span\u0026gt;), \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) \n            + Math.cos(latPoint1) * Math.cos(latPoint2)\n            * Math.pow(Math.sin((lngPoint2 - lngPoint1) / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2.0\u0026lt;/span\u0026gt;), \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;);\n    distance = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2.0\u0026lt;/span\u0026gt; * EARTH_RADIUS * Math.asin(Math.sqrt(distance));\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; distance; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//km value\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;To calculate the distance between two points on a sphere you need to do the \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Great-circle_distance\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Great Circle calculation\u0026lt;/a\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There are a number of C/C++ libraries to help with map projection at \u0026lt;a href=\u0026quot;http://www.maptools.org/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;MapTools\u0026lt;/a\u0026gt; if you need to reproject your distances to a flat surface.  To do this you will need the projection string of the various coordinate systems.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You may also find \u0026lt;a href=\u0026quot;http://www.mapwindow.org/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;MapWindow\u0026lt;/a\u0026gt; a useful tool to visualise the points.  Also as its open source its a useful guide to how to use the proj.dll library, which appears to be the core open source projection library.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is my java implementation for calculation distance via decimal degrees after some search. I used mean radius of world (from wikipedia) in km. İf you want result miles then use world radius in miles.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;public static double distanceLatLong2(double lat1, double lng1, double lat2, double lng2) \n{\n  double earthRadius = 6371.0d; // KM: use mile here if you want mile result\n\n  double dLat = toRadian(lat2 - lat1);\n  double dLng = toRadian(lng2 - lng1);\n\n  double a = Math.pow(Math.sin(dLat/2), 2)  + \n          Math.cos(toRadian(lat1)) * Math.cos(toRadian(lat2)) * \n          Math.pow(Math.sin(dLng/2), 2);\n\n  double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n\n  return earthRadius * c; // returns result kilometers\n}\n\npublic static double toRadian(double degrees) \n{\n  return (degrees * Math.PI) / 180.0d;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here\u0026apos;s the accepted answer implementation ported to Java in case anyone needs it.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;package com.project529.garage.util;\n\n\n/**\n * Mean radius.\n */\nprivate static double EARTH_RADIUS = 6371;\n\n/**\n * Returns the distance between two sets of latitudes and longitudes in meters.\n * \u0026amp;lt;p/\u0026amp;gt;\n * Based from the following JavaScript SO answer:\n * http://stackoverflow.com/questions/27928/calculate-distance-between-two-latitude-longitude-points-haversine-formula,\n * which is based on https://en.wikipedia.org/wiki/Haversine_formula (error rate: ~0.55%).\n */\npublic double getDistanceBetween(double lat1, double lon1, double lat2, double lon2) {\n    double dLat = toRadians(lat2 - lat1);\n    double dLon = toRadians(lon2 - lon1);\n\n    double a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n            Math.cos(toRadians(lat1)) * Math.cos(toRadians(lat2)) *\n                    Math.sin(dLon / 2) * Math.sin(dLon / 2);\n    double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    double d = EARTH_RADIUS * c;\n\n    return d;\n}\n\npublic double toRadians(double degrees) {\n    return degrees * (Math.PI / 180);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;here is an example in \u0026lt;strong\u0026gt;postgres\u0026lt;/strong\u0026gt; sql (in km, for miles version, replace 1.609344 by 0.8684 version)\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;CREATE OR REPLACE FUNCTION public.geodistance(alat float, alng float, blat  \n\nfloat, blng  float)\n  RETURNS float AS\n$BODY$\nDECLARE\n    v_distance float;\nBEGIN\n\n    v_distance = asin( sqrt(\n            sin(radians(blat-alat)/2)^2 \n                + (\n                    (sin(radians(blng-alng)/2)^2) *\n                    cos(radians(alat)) *\n                    cos(radians(blat))\n                )\n          )\n        ) * cast(\u0026apos;7926.3352\u0026apos; as float) * cast(\u0026apos;1.609344\u0026apos; as float) ;\n\n\n    RETURN v_distance;\nEND \n$BODY$\nlanguage plpgsql VOLATILE SECURITY DEFINER;\nalter function geodistance(alat float, alng float, blat float, blng float)\nowner to postgres;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;For those looking for an Excel formula based on WGS-84 \u0026amp;amp; GRS-80 standards:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;=ACOS(COS(RADIANS(90-Lat1))*COS(RADIANS(90-Lat2))+SIN(RADIANS(90-Lat1))*SIN(RADIANS(90-Lat2))*COS(RADIANS(Long1-Long2)))*6371\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://bluemm.blogspot.com/2007/01/excel-formula-to-calculate-distance.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Source\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I made a custom function in R to calculate haversine distance(km) between two spatial points using functions available in R base package.\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;custom_hav_dist \u0026amp;lt;- function(lat1, lon1, lat2, lon2) {\nR \u0026amp;lt;- 6371\nRadian_factor \u0026amp;lt;- 0.0174533\nlat_1 \u0026amp;lt;- (90-lat1)*Radian_factor\nlat_2 \u0026amp;lt;- (90-lat2)*Radian_factor\ndiff_long \u0026amp;lt;-(lon1-lon2)*Radian_factor\n\ndistance_in_km \u0026amp;lt;- 6371*acos((cos(lat_1)*cos(lat_2))+ \n                 (sin(lat_1)*sin(lat_2)*cos(diff_long)))\nrm(lat1, lon1, lat2, lon2)\nreturn(distance_in_km)\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Sample output\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;custom_hav_dist(50.31,19.08,54.14,19.39)\n[1] 426.3987\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;PS: To calculate distances in miles, substitute R in function (6371) with 3958.756 (and for nautical miles, use 3440.065).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;there is a good example in here to calculate distance with PHP \u0026lt;a href=\u0026quot;http://www.geodatasource.com/developers/php\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;http://www.geodatasource.com/developers/php\u0026lt;/a\u0026gt; :\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt; function distance($lat1, $lon1, $lat2, $lon2, $unit) {\n\n     $theta = $lon1 - $lon2;\n     $dist = sin(deg2rad($lat1)) * sin(deg2rad($lat2)) +  cos(deg2rad($lat1)) * cos(deg2rad($lat2)) * cos(deg2rad($theta));\n     $dist = acos($dist);\n     $dist = rad2deg($dist);\n     $miles = $dist * 60 * 1.1515;\n     $unit = strtoupper($unit);\n\n     if ($unit == \u0026quot;K\u0026quot;) {\n         return ($miles * 1.609344);\n     } else if ($unit == \u0026quot;N\u0026quot;) {\n          return ($miles * 0.8684);\n     } else {\n          return $miles;\n     }\n }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is the implementation VB.NET, this implementation will give you the result in KM or Miles based on an Enum value you pass.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;Public Enum DistanceType\n    Miles\n    KiloMeters\nEnd Enum\n\nPublic Structure Position\n    Public Latitude As Double\n    Public Longitude As Double\nEnd Structure\n\nPublic Class Haversine\n\n    Public Function Distance(Pos1 As Position,\n                             Pos2 As Position,\n                             DistType As DistanceType) As Double\n\n        Dim R As Double = If((DistType = DistanceType.Miles), 3960, 6371)\n\n        Dim dLat As Double = Me.toRadian(Pos2.Latitude - Pos1.Latitude)\n\n        Dim dLon As Double = Me.toRadian(Pos2.Longitude - Pos1.Longitude)\n\n        Dim a As Double = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) + Math.Cos(Me.toRadian(Pos1.Latitude)) * Math.Cos(Me.toRadian(Pos2.Latitude)) * Math.Sin(dLon / 2) * Math.Sin(dLon / 2)\n\n        Dim c As Double = 2 * Math.Asin(Math.Min(1, Math.Sqrt(a)))\n\n        Dim result As Double = R * c\n\n        Return result\n\n    End Function\n\n    Private Function toRadian(val As Double) As Double\n\n        Return (Math.PI / 180) * val\n\n    End Function\n\nEnd Class\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I condensed the computation down by simplifying the formula.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here it is in Ruby:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;include Math\nearth_radius_mi = 3959\nradians = lambda { |deg| deg * PI / 180 }\ncoord_radians = lambda { |c| { :lat =\u0026amp;gt; radians[c[:lat]], :lng =\u0026amp;gt; radians[c[:lng]] } }\n\n# from/to = { :lat =\u0026amp;gt; (latitude_in_degrees), :lng =\u0026amp;gt; (longitude_in_degrees) }\ndef haversine_distance(from, to)\n  from, to = coord_radians[from], coord_radians[to]\n  cosines_product = cos(to[:lat]) * cos(from[:lat]) * cos(from[:lng] - to[:lng])\n  sines_product = sin(to[:lat]) * sin(from[:lat])\n  return earth_radius_mi * acos(cosines_product + sines_product)\nend\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;function getDistanceFromLatLonInKm(lat1,lon1,lat2,lon2,units) {\n  var R = 6371; // Radius of the earth in km\n  var dLat = deg2rad(lat2-lat1);  // deg2rad below\n  var dLon = deg2rad(lon2-lon1); \n  var a = \n    Math.sin(dLat/2) * Math.sin(dLat/2) +\n    Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * \n    Math.sin(dLon/2) * Math.sin(dLon/2)\n    ; \n  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); \n  var d = R * c; \n  var miles = d / 1.609344; \n\nif ( units == \u0026apos;km\u0026apos; ) {  \nreturn d; \n } else {\nreturn miles;\n}}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Chuck\u0026apos;s solution, valid for miles also.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In Mysql use the following function pass the parameters as using  \u0026lt;code\u0026gt;POINT(LONG,LAT)\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;CREATE FUNCTION `distance`(a POINT, b POINT)\n RETURNS double\n    DETERMINISTIC\nBEGIN\n\nRETURN\n\nGLength( LineString(( PointFromWKB(a)), (PointFromWKB(b)))) * 100000; -- To Make the distance in meters\n\nEND;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    "],"id":589,"title":"Calculate distance between two latitude-longitude points? (Haversine formula)","content":"\n                \n\u0026lt;p\u0026gt;How do I calculate the distance between two points specified by latitude and longitude?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For clarification, I\u0026apos;d like the distance in kilometers; the points use the WGS84 system and I\u0026apos;d like to understand the relative accuracies of the approaches available.\u0026lt;/p\u0026gt;\n    ","slug":"calculate-distance-between-two-latitude-longitude-points-(haversine-formula)-1657388500103","postType":"QUESTION","createdAt":"2022-07-09T17:41:40.000Z","updatedAt":"2022-07-09T17:41:40.000Z","tags":[{"id":2805,"name":"maps","slug":"maps","createdAt":"2022-07-09T17:41:40.000Z","updatedAt":"2022-07-09T17:41:40.000Z","Questions_Tags":{"questionId":589,"tagId":2805}},{"id":2806,"name":"latitude-longitude","slug":"latitude-longitude","createdAt":"2022-07-09T17:41:40.000Z","updatedAt":"2022-07-09T17:41:40.000Z","Questions_Tags":{"questionId":589,"tagId":2806}},{"id":2807,"name":"haversine","slug":"haversine","createdAt":"2022-07-09T17:41:40.000Z","updatedAt":"2022-07-09T17:41:40.000Z","Questions_Tags":{"questionId":589,"tagId":2807}}],"relatedQuestions":[{"title":"Calculate distance between two latitude-longitude points? (Haversine formula)","slug":"calculate-distance-between-two-latitude-longitude-points-(haversine-formula)-1657388500103","tags":[{"name":"maps","Questions_Tags":{"questionId":589,"tagId":2805}},{"name":"latitude-longitude","Questions_Tags":{"questionId":589,"tagId":2806}},{"name":"haversine","Questions_Tags":{"questionId":589,"tagId":2807}}]}]},"randomQuestions":[{"title":"When can I use a forward declaration?","slug":"when-can-i-use-a-forward-declaration-1657388251827"},{"title":"javascript function doesn't work when link is clicked","slug":"javascript-function-doesn't-work-when-link-is-clicked-1657387767488"},{"title":"How to use ThreeTenABP in Android Project","slug":"how-to-use-threetenabp-in-android-project-1657384345704"},{"title":"How do I revert a Git repository to a previous commit?","slug":"how-do-i-revert-a-git-repository-to-a-previous-commit-1657387714717"},{"title":"Transitions on the CSS display property","slug":"transitions-on-the-css-display-property-1657387761601"},{"title":"How do I split a delimited string so I can access individual items?","slug":"how-do-i-split-a-delimited-string-so-i-can-access-individual-items-1657388042385"},{"title":"How does the Windows Command Interpreter (CMD.EXE) parse scripts?","slug":"how-does-the-windows-command-interpreter-(cmd.exe)-parse-scripts-1657387731560"},{"title":"What does ** (double star/asterisk) and * (star/asterisk) do for parameters?","slug":"what-does-**-(double-starasterisk)-and-*-(starasterisk)-do-for-parameters-1657384800967"},{"title":"What are the nuances of scope prototypal / prototypical inheritance in AngularJS?","slug":"what-are-the-nuances-of-scope-prototypal-prototypical-inheritance-in-angularjs-1657387340067"},{"title":"How do I detect collision in pygame?","slug":"how-do-i-detect-collision-in-pygame-1657387496338"},{"title":"Prefer composition over inheritance?","slug":"prefer-composition-over-inheritance-1657387399409"},{"title":"Safely turning a JSON string into an object","slug":"safely-turning-a-json-string-into-an-object-1657388194824"},{"title":"What's the meaning of \"=\u003e\" (an arrow formed from equals \u0026 greater than) in JavaScript?","slug":"what's-the-meaning-of-\"greater\"-(an-arrow-formed-from-equals-and-greater-than)-in-javascript-1657387977118"},{"title":"commandButton/commandLink/ajax action/listener method not invoked or input value not set/updated","slug":"commandbuttoncommandlinkajax-actionlistener-method-not-invoked-or-input-value-not-setupdated-1657384667519"},{"title":"How to store objects in HTML5 localStorage","slug":"how-to-store-objects-in-html5-localstorage-1657387568907"},{"title":"What is the difference between const int*, const int * const, and int const *?","slug":"what-is-the-difference-between-const-int*-const-int-*-const-and-int-const-*-1657388184604"},{"title":"\"Thinking in AngularJS\" if I have a jQuery background? [closed]","slug":"\"thinking-in-angularjs\"-if-i-have-a-jquery-background-closed-1657384761159"},{"title":"Get the values from the \"GET\" parameters (JavaScript) [duplicate]","slug":"get-the-values-from-the-\"get\"-parameters-(javascript)-duplicate-1657387656693"},{"title":"How can I remove a specific item from an array?","slug":"how-can-i-remove-a-specific-item-from-an-array-1657387552077"},{"title":"How to replace all occurrences of a string in JavaScript","slug":"how-to-replace-all-occurrences-of-a-string-in-javascript-1657384895467"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"calculate-distance-between-two-latitude-longitude-points-(haversine-formula)-1657388500103"},"buildId":"6ctJfCympFH_chh5mjicD","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>