<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/what-are-the-nuances-of-scope-prototypal-prototypical-inheritance-in-angularjs-1657387340067","name":"Questions"}}]}</script><title>What are the nuances of scope prototypal / prototypical inheritance in AngularJS? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="The API Reference Scope page says:


  A scope can inherit from a parent scope.


The Developer Guide Scope page says:


  A scope (prototypically) inherits properties from its parent scope.



So, does a child scope always prototypically inherit from its parent scope?  
Are there exceptions?   
When it does inherit, is it always normal JavaScript prototypal inheritance?

    "/><meta property="og:title" content="What are the nuances of scope prototypal / prototypical inheritance in AngularJS? | Solutions Checker"/><meta property="og:description" content="The API Reference Scope page says:


  A scope can inherit from a parent scope.


The Developer Guide Scope page says:


  A scope (prototypically) inherits properties from its parent scope.



So, does a child scope always prototypically inherit from its parent scope?  
Are there exceptions?   
When it does inherit, is it always normal JavaScript prototypal inheritance?

    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"What are the nuances of scope prototypal / prototypical inheritance in AngularJS?","text":"The API Reference Scope page says:\n\n\n  A scope can inherit from a parent scope.\n\n\nThe Developer Guide Scope page says:\n\n\n  A scope (prototypically) inherits properties from its parent scope.\n\n\n\nSo, does a child scope always prototypically inherit from its parent scope?  \nAre there exceptions?   \nWhen it does inherit, is it always normal JavaScript prototypal inheritance?\n\n    ","answerCount":3,"upVoteCount":500,"suggestedAnswer":[{"text":"Quick answer: \nA child scope normally prototypically inherits from its parent scope, but not always.  One exception to this rule is a directive with scope: { ... } -- this creates an &quot;isolate&quot; scope that does not prototypically inherit.  This construct is often used when creating a &quot;reusable component&quot; directive.\n\nAs for the nuances, scope inheritance is normally straightfoward... until you need 2-way data binding (i.e., form elements, ng-model) in the child scope.  Ng-repeat, ng-switch, and ng-include can trip you up if you try to bind to a primitive (e.g., number, string, boolean) in the parent scope from inside the child scope.  It doesn&apos;t work the way most people expect it should work.  The child scope gets its own property that hides/shadows the parent property of the same name.  Your workarounds are\n\n\ndefine objects in the parent for your model, then reference a property of that object  in the child:  parentObj.someProp\nuse $parent.parentScopeProperty (not always possible, but easier than 1. where possible)\ndefine a function on the parent scope, and call it from the child (not always possible)\n\n\nNew AngularJS developers often do not realize that ng-repeat, ng-switch, ng-view, ng-include and ng-if all create new child scopes, so the problem often shows up when these directives are involved. (See this example for a quick illustration of the problem.)\n\nThis issue with primitives can be easily avoided by following the &quot;best practice&quot; of always have a &apos;.&apos; in your ng-models  watch 3 minutes worth. Misko demonstrates the primitive binding issue with ng-switch.\n\nHaving a &apos;.&apos; in your models will ensure that prototypal inheritance is in play. So, use\n\n&lt;input type=&quot;text&quot; ng-model=&quot;someObj.prop1&quot;&gt;\n\n&lt;!--rather than\n&lt;input type=&quot;text&quot; ng-model=&quot;prop1&quot;&gt;`\n--&gt;\n\n\n\nL-o-n-g answer:\n\nJavaScript Prototypal Inheritance\n\nAlso placed on the AngularJS wiki: https://github.com/angular/angular.js/wiki/Understanding-Scopes\n\nIt is important to first have a solid understanding of prototypal inheritance, especially if you are coming from a server-side background and you are more familiar with class-ical inheritance.  So let&apos;s review that first.\n\nSuppose parentScope has properties aString, aNumber, anArray, anObject, and aFunction.  If childScope prototypically inherits from parentScope, we have:\n\n\n\n(Note that to save space, I show the anArray object as a single blue object with its three values, rather than an single blue object with three separate gray literals.)\n\nIf we try to access a property defined on the parentScope from the child scope, JavaScript will first look in the child scope, not find the property, then look in the inherited scope, and find the property.  (If it didn&apos;t find the property in the parentScope, it would continue up the prototype chain... all the way up to the root scope). So, these are all true:\n\nchildScope.aString === &apos;parent string&apos;\nchildScope.anArray[1] === 20\nchildScope.anObject.property1 === &apos;parent prop1&apos;\nchildScope.aFunction() === &apos;parent output&apos;\n\n\nSuppose we then do this:\n\nchildScope.aString = &apos;child string&apos;\n\n\nThe prototype chain is not consulted, and a new aString property is added to the childScope.  This new property hides/shadows the parentScope property with the same name.  This will become very important when we discuss ng-repeat and ng-include below.\n\n\n\nSuppose we then do this:\n\nchildScope.anArray[1] = &apos;22&apos;\nchildScope.anObject.property1 = &apos;child prop1&apos;\n\n\nThe prototype chain is consulted because the objects (anArray and anObject) are not found in the childScope.  The objects are found in the parentScope, and the property values are updated on the original objects.  No new properties are added to the childScope;  no new objects are created.  (Note that in JavaScript arrays and functions are also objects.)\n\n\n\nSuppose we then do this:\n\nchildScope.anArray = [100, 555]\nchildScope.anObject = { name: &apos;Mark&apos;, country: &apos;USA&apos; }\n\n\nThe prototype chain is not consulted, and child scope gets two new object properties that hide/shadow the parentScope object properties with the same names.\n\n\n\nTakeaways:\n\n\nIf we read childScope.propertyX, and childScope has propertyX, then the prototype chain is not consulted.\nIf we set childScope.propertyX, the prototype chain is not consulted.\n\n\nOne last scenario:\n\ndelete childScope.anArray\nchildScope.anArray[1] === 22  // true\n\n\nWe deleted the childScope property first, then when we try to access the property again, the prototype chain is consulted.\n\n\n\n\n\nAngular Scope Inheritance\n\nThe contenders:\n\n\nThe following create new scopes, and inherit prototypically: ng-repeat, ng-include, ng-switch, ng-controller, directive with scope: true, directive with transclude: true.\nThe following creates a new scope which does not inherit prototypically: directive with scope: { ... }.  This creates an &quot;isolate&quot; scope instead.\n\n\nNote, by default, directives do not create new scope -- i.e., the default is scope: false.\n\nng-include\n\nSuppose we have in our controller:\n\n$scope.myPrimitive = 50;\n$scope.myObject    = {aNumber: 11};\n\n\nAnd in our HTML:\n\n&lt;script type=&quot;text/ng-template&quot; id=&quot;/tpl1.html&quot;&gt;\n&lt;input ng-model=&quot;myPrimitive&quot;&gt;\n&lt;/script&gt;\n&lt;div ng-include src=&quot;&apos;/tpl1.html&apos;&quot;&gt;&lt;/div&gt;\n\n&lt;script type=&quot;text/ng-template&quot; id=&quot;/tpl2.html&quot;&gt;\n&lt;input ng-model=&quot;myObject.aNumber&quot;&gt;\n&lt;/script&gt;\n&lt;div ng-include src=&quot;&apos;/tpl2.html&apos;&quot;&gt;&lt;/div&gt;\n\n\nEach ng-include generates a new child scope, which prototypically inherits from the parent scope.\n\n\n\nTyping (say, &quot;77&quot;) into the first input textbox causes the child scope to get a new myPrimitive scope property that hides/shadows the parent scope property of the same name.  This is probably not what you want/expect.\n\n\n\nTyping (say, &quot;99&quot;) into the second input textbox does not result in a new child property.  Because tpl2.html binds the model to an object property, prototypal inheritance kicks in when the ngModel looks for object myObject -- it finds it in the parent scope.\n\n\n\nWe can rewrite the first template to use $parent, if we don&apos;t want to change our model from a primitive to an object:\n\n&lt;input ng-model=&quot;$parent.myPrimitive&quot;&gt;\n\n\nTyping (say, &quot;22&quot;) into this input textbox does not result in a new child property.  The model is now bound to a property of the parent scope (because $parent is a child scope property that references the parent scope).\n\n\n\nFor all scopes (prototypal or not), Angular always tracks a parent-child relationship (i.e., a hierarchy), via scope properties $parent, $$childHead and $$childTail.  I normally don&apos;t show these scope properties in the diagrams.\n\nFor scenarios where form elements are not involved, another solution is to define a function on the parent scope to modify the primitive.  Then ensure the child always calls this function, which will be available to the child scope due to prototypal inheritance. E.g.,\n\n// in the parent scope\n$scope.setMyPrimitive = function(value) {\n     $scope.myPrimitive = value;\n}\n\n\nHere is a sample fiddle that uses this &quot;parent function&quot; approach.  (The fiddle was written as part of this answer: https://stackoverflow.com/a/14104318/215945.)\n\nSee also https://stackoverflow.com/a/13782671/215945 and https://github.com/angular/angular.js/issues/1267.\n\nng-switch\n\nng-switch scope inheritance works just like ng-include.  So if you need 2-way data binding to a primitive in the parent scope, use $parent, or change the model to be an object and then bind to a property of that object.  This will avoid child scope hiding/shadowing of parent scope properties.\n\nSee also AngularJS, bind scope of a switch-case?\n\nng-repeat\n\nNg-repeat works a little differently.  Suppose we have in our controller:\n\n$scope.myArrayOfPrimitives = [ 11, 22 ];\n$scope.myArrayOfObjects    = [{num: 101}, {num: 202}]\n\n\nAnd in our HTML:\n\n&lt;ul&gt;&lt;li ng-repeat=&quot;num in myArrayOfPrimitives&quot;&gt;\n       &lt;input ng-model=&quot;num&quot;&gt;\n    &lt;/li&gt;\n&lt;ul&gt;\n&lt;ul&gt;&lt;li ng-repeat=&quot;obj in myArrayOfObjects&quot;&gt;\n       &lt;input ng-model=&quot;obj.num&quot;&gt;\n    &lt;/li&gt;\n&lt;ul&gt;\n\n\nFor each item/iteration, ng-repeat creates a new scope, which prototypically inherits from the parent scope, but it also assigns the item&apos;s value to a new property on the new child scope.  (The name of the new property is the loop variable&apos;s name.)  Here&apos;s what the Angular source code for ng-repeat actually is:\n\nchildScope = scope.$new();  // child scope prototypically inherits from parent scope\n...\nchildScope[valueIdent] = value;  // creates a new childScope property\n\n\nIf item is a primitive (as in myArrayOfPrimitives), essentially a copy of the value is assigned to the new child scope property.  Changing the child scope property&apos;s value (i.e., using ng-model, hence child scope num) does not change the array the parent scope references.  So in the first ng-repeat above, each child scope gets a num property that is independent of the myArrayOfPrimitives array:\n\n\n\nThis ng-repeat will not work (like you want/expect it to).  Typing into the textboxes changes the values in the gray boxes, which are only visible in the child scopes.  What we want is for the inputs to affect the myArrayOfPrimitives array, not a child scope primitive property.  To accomplish this, we need to change the model to be an array of objects.\n\nSo, if item is an object, a reference to the original object (not a copy) is assigned to the new child scope property.  Changing the child scope property&apos;s value (i.e., using ng-model, hence obj.num) does change the object the parent scope references.  So in the second ng-repeat above, we have:\n\n\n\n(I colored one line gray just so that it is clear where it is going.)\n\nThis works as expected.  Typing into the textboxes changes the values in the gray boxes, which are visible to both the child and parent scopes.\n\nSee also Difficulty with ng-model, ng-repeat, and inputs and \nhttps://stackoverflow.com/a/13782671/215945\n\nng-controller\n\nNesting controllers using ng-controller results in normal prototypal inheritance, just like ng-include and ng-switch, so the same techniques apply.\nHowever, &quot;it is considered bad form for two controllers to share information via $scope inheritance&quot; -- http://onehungrymind.com/angularjs-sticky-notes-pt-1-architecture/\nA service should be used to share data between controllers instead.\n\n(If you really want to share data via controllers scope inheritance, there is nothing you need to do.  The child scope will have access to all of the parent scope properties.\nSee also Controller load order differs when loading or navigating)\n\ndirectives\n\n\ndefault (scope: false) - the directive does not create a new scope, so there is no inheritance here.  This is easy, but also dangerous because, e.g., a directive might think it is creating a new property on the scope, when in fact it is clobbering an existing property.  This is not a good choice for writing directives that are intended as reusable components.\nscope: true - the directive creates a new child scope that prototypically inherits from the parent scope.  If more than one directive (on the same DOM element) requests a new scope, only one new child scope is created.  Since we have &quot;normal&quot; prototypal inheritance, this is like ng-include and ng-switch, so be wary of 2-way data binding to parent scope primitives, and child scope hiding/shadowing of parent scope properties.\nscope: { ... } - the directive creates a new isolate/isolated scope.  It does not prototypically inherit.  This is usually your best choice when creating reusable components, since the directive cannot accidentally read or modify the parent scope.  However, such directives often need access to a few parent scope properties.  The object hash is used to set up two-way binding (using &apos;=&apos;) or one-way binding (using &apos;@&apos;) between the parent scope and the isolate scope.  There is also &apos;&amp;&apos; to bind to parent scope expressions.  So, these all create local scope properties that are derived from the parent scope.\nNote that attributes are used to help set up the binding -- you can&apos;t just reference parent scope property names in the object hash, you have to use an attribute.  E.g., this won&apos;t work if you want to bind to parent property parentProp in the isolated scope: &lt;div my-directive&gt; and scope: { localProp: &apos;@parentProp&apos; }.  An attribute must be used to specify each parent property that the directive wants to bind to: &lt;div my-directive the-Parent-Prop=parentProp&gt; and scope: { localProp: &apos;@theParentProp&apos; }.\nIsolate scope&apos;s __proto__ references Object.\nIsolate scope&apos;s $parent references the parent scope, so although it is isolated and doesn&apos;t inherit prototypically from the parent scope, it is still a child scope.\nFor the picture below we have\n  &lt;my-directive interpolated=&quot;{{parentProp1}}&quot; twowayBinding=&quot;parentProp2&quot;&gt; and\n  scope: { interpolatedProp: &apos;@interpolated&apos;, twowayBindingProp: &apos;=twowayBinding&apos; }\nAlso, assume the directive does this in its linking function: scope.someIsolateProp = &quot;I&apos;m isolated&quot;\n \nFor more information on isolate scopes see http://onehungrymind.com/angularjs-sticky-notes-pt-2-isolated-scope/\ntransclude: true - the directive creates a new &quot;transcluded&quot; child scope, which prototypically inherits from the parent scope.  The transcluded and the isolated scope (if any) are siblings -- the $parent property of each scope references the same parent scope.  When a transcluded and an isolate scope both exist, isolate scope property $$nextSibling will reference the transcluded scope.  I&apos;m not aware of any nuances with the transcluded scope.\nFor the picture below, assume the same directive as above with this addition: transclude: true\n\n\n\nThis fiddle has a showScope() function that can be used to examine an isolate and transcluded scope.  See the instructions in the comments in the fiddle.\n\n\n\nSummary\n\nThere are four types of scopes:\n\n\nnormal prototypal scope inheritance -- ng-include, ng-switch, ng-controller, directive with scope: true\nnormal prototypal scope inheritance with a copy/assignment -- ng-repeat.  Each iteration of ng-repeat creates a new child scope, and that new child scope always gets a new property.\nisolate scope -- directive with scope: {...}.  This one is not prototypal, but &apos;=&apos;, &apos;@&apos;, and &apos;&amp;&apos; provide a mechanism to access parent scope properties, via attributes.\ntranscluded scope -- directive with transclude: true.  This one is also normal prototypal scope inheritance, but it is also a sibling of any isolate scope.\n\n\nFor all scopes (prototypal or not), Angular always tracks a parent-child relationship (i.e., a hierarchy), via properties $parent and $$childHead and $$childTail.\n\nDiagrams were generated with graphviz &quot;*.dot&quot; files, which are on github. Tim Caswell&apos;s &quot;Learning JavaScript with Object Graphs&quot; was the inspiration for using GraphViz for the diagrams. \n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"I in no way want to compete with Mark&apos;s answer, but just wanted to highlight the piece that finally made everything click as someone new to Javascript inheritance and its prototype chain.\n\nOnly property reads search the prototype chain, not writes. So when you set\n\nmyObject.prop = &apos;123&apos;;\n\n\nIt doesn&apos;t look up the chain, but when you set \n\nmyObject.myThing.prop = &apos;123&apos;;\n\n\nthere&apos;s a subtle read going on within that write operation that tries to look up myThing before writing to its prop. So that&apos;s why writing to object.properties from the child gets at the parent&apos;s objects.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"I would like to add an example of prototypical inheritance with javascript to @Scott Driscoll answer. We&apos;ll be using classical inheritance pattern with Object.create() which is a part of  EcmaScript 5 specification.\n\nFirst we create &quot;Parent&quot; object function\n\nfunction Parent(){\n\n}\n\n\nThen add a prototype to &quot;Parent&quot; object function\n\n Parent.prototype = {\n primitive : 1,\n object : {\n    one : 1\n   }\n}\n\n\nCreate &quot;Child&quot; object function\n\nfunction Child(){\n\n}\n\n\nAssign child prototype (Make child prototype inherit from parent prototype)\n\nChild.prototype = Object.create(Parent.prototype);\n\n\nAssign proper &quot;Child&quot; prototype constructor\n\nChild.prototype.constructor = Child;\n\n\nAdd method &quot;changeProps&quot; to a child prototype, which will rewrite &quot;primitive&quot; property value in Child object and change &quot;object.one&quot; value  both in Child and Parent objects\n\nChild.prototype.changeProps = function(){\n    this.primitive = 2;\n    this.object.one = 2;\n};\n\n\nInitiate Parent (dad) and Child (son) objects.\n\nvar dad = new Parent();\nvar son = new Child();\n\n\nCall Child (son) changeProps method\n\nson.changeProps();\n\n\nCheck the results.\n\nParent primitive property did not change\n\nconsole.log(dad.primitive); /* 1 */\n\n\nChild primitive property changed (rewritten)\n\nconsole.log(son.primitive); /* 2 */\n\n\nParent and Child object.one properties changed\n\nconsole.log(dad.object.one); /* 2 */\nconsole.log(son.object.one); /* 2 */\n\n\nWorking example here http://jsbin.com/xexurukiso/1/edit/\n\nMore info on Object.create here https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/create\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="17"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-7e79b78ef884195a.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-c1a73f3e758d48b9.js" defer=""></script><script src="/_next/static/XDXakEY6gSPdgAODPxtjg/_buildManifest.js" defer=""></script><script src="/_next/static/XDXakEY6gSPdgAODPxtjg/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/what-are-the-nuances-of-scope-prototypal-prototypical-inheritance-in-angularjs-1657387340067#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-are-the-nuances-of-scope-prototypal-prototypical-inheritance-in-angularjs-1657387340067"><h1>What are the nuances of scope prototypal / prototypical inheritance in AngularJS?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/prototypal-inheritance">prototypal-inheritance</a></div></div><div class="question-content mt-5">
                
<p>The <a href="http://docs.angularjs.org/api/ng.$rootScope.Scope" rel="noreferrer">API Reference Scope page</a> says:</p>

<blockquote>
  <p>A scope <em>can</em> inherit from a parent scope.</p>
</blockquote>

<p>The <a href="http://docs.angularjs.org/guide/scope" rel="noreferrer">Developer Guide Scope page</a> says:</p>

<blockquote>
  <p>A scope (prototypically) inherits properties from its parent scope.</p>
</blockquote>

<ul>
<li>So, does a child scope always prototypically inherit from its parent scope?  </li>
<li>Are there exceptions?   </li>
<li>When it does inherit, is it always normal JavaScript prototypal inheritance?</li>
</ul>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/prototypal-inheritance">prototypal-inheritance</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Quick answer</strong>: <br>
A child scope normally prototypically inherits from its parent scope, but not always.  One exception to this rule is a directive with <code>scope: { ... }</code> -- this creates an "isolate" scope that does not prototypically inherit.  This construct is often used when creating a "reusable component" directive.</p>

<p>As for the nuances, scope inheritance is normally straightfoward... until you need <strong>2-way data binding</strong> (i.e., form elements, ng-model) in the child scope.  Ng-repeat, ng-switch, and ng-include can trip you up if you try to bind to a <strong>primitive</strong> (e.g., number, string, boolean) in the parent scope from inside the child scope.  It doesn't work the way most people expect it should work.  The child scope gets its own property that hides/shadows the parent property of the same name.  Your workarounds are</p>

<ol>
<li>define objects in the parent for your model, then reference a property of that object  in the child:  parentObj.someProp</li>
<li>use $parent.parentScopeProperty (not always possible, but easier than 1. where possible)</li>
<li>define a function on the parent scope, and call it from the child (not always possible)</li>
</ol>

<p>New AngularJS developers often do not realize that <code>ng-repeat</code>, <code>ng-switch</code>, <code>ng-view</code>, <code>ng-include</code> and <code>ng-if</code> all create new child scopes, so the problem often shows up when these directives are involved. (See <a href="http://plnkr.co/edit/zZfUQN?p=preview" rel="noreferrer">this example</a> for a quick illustration of the problem.)</p>

<p>This issue with primitives can be easily avoided by following the "best practice" of <a href="http://www.youtube.com/watch?v=ZhfUv0spHCY&amp;feature=youtu.be&amp;t=30m" rel="noreferrer">always have a '.' in your ng-models</a>  watch 3 minutes worth. Misko demonstrates the primitive binding issue with <code>ng-switch</code>.</p>

<p>Having a '.' in your models will ensure that prototypal inheritance is in play. So, use</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">&lt;input type=<span class="hljs-string">"text"</span> ng-model=<span class="hljs-string">"someObj.prop1"</span>&gt;

&lt;!--rather than
&lt;input type=<span class="hljs-string">"text"</span> ng-model=<span class="hljs-string">"prop1"</span>&gt;<span class="hljs-string">`
--&gt;
</span></code></pre>

<p></p><hr>
<strong>L-o-n-g answer</strong>:<p></p>

<h2>JavaScript Prototypal Inheritance</h2>

<p><strong>Also placed on the AngularJS wiki:</strong> <a href="https://github.com/angular/angular.js/wiki/Understanding-Scopes" rel="noreferrer">https://github.com/angular/angular.js/wiki/Understanding-Scopes</a></p>

<p>It is important to first have a solid understanding of prototypal inheritance, especially if you are coming from a server-side background and you are more familiar with class-ical inheritance.  So let's review that first.</p>

<p>Suppose parentScope has properties aString, aNumber, anArray, anObject, and aFunction.  If childScope prototypically inherits from parentScope, we have:</p>

<p><img src="https://i.stack.imgur.com/aTAGg.png" alt="prototypal inheritance"></p>

<p>(Note that to save space, I show the <code>anArray</code> object as a single blue object with its three values, rather than an single blue object with three separate gray literals.)</p>

<p>If we try to access a property defined on the parentScope from the child scope, JavaScript will first look in the child scope, not find the property, then look in the inherited scope, and find the property.  (If it didn't find the property in the parentScope, it would continue up the prototype chain... all the way up to the root scope). So, these are all true:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">childScope.<span class="hljs-property">aString</span> === <span class="hljs-string">'parent string'</span>
childScope.<span class="hljs-property">anArray</span>[<span class="hljs-number">1</span>] === <span class="hljs-number">20</span>
childScope.<span class="hljs-property">anObject</span>.<span class="hljs-property">property1</span> === <span class="hljs-string">'parent prop1'</span>
childScope.<span class="hljs-title function_">aFunction</span>() === <span class="hljs-string">'parent output'</span>
</code></pre>

<p>Suppose we then do this:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">childScope.<span class="hljs-property">aString</span> = <span class="hljs-string">'child string'</span>
</code></pre>

<p>The prototype chain is not consulted, and a new aString property is added to the childScope.  <strong>This new property hides/shadows the parentScope property with the same name.</strong>  This will become very important when we discuss ng-repeat and ng-include below.</p>

<p><img src="https://i.stack.imgur.com/OyVPW.png" alt="property hiding"></p>

<p>Suppose we then do this:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">childScope.<span class="hljs-property">anArray</span>[<span class="hljs-number">1</span>] = <span class="hljs-string">'22'</span>
childScope.<span class="hljs-property">anObject</span>.<span class="hljs-property">property1</span> = <span class="hljs-string">'child prop1'</span>
</code></pre>

<p>The prototype chain is consulted because the objects (anArray and anObject) are not found in the childScope.  The objects are found in the parentScope, and the property values are updated on the original objects.  No new properties are added to the childScope;  no new objects are created.  (Note that in JavaScript arrays and functions are also objects.)</p>

<p><img src="https://i.stack.imgur.com/2QceU.png" alt="follow the prototype chain"></p>

<p>Suppose we then do this:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">childScope.<span class="hljs-property">anArray</span> = [<span class="hljs-number">100</span>, <span class="hljs-number">555</span>]
childScope.<span class="hljs-property">anObject</span> = { <span class="hljs-attr">name</span>: <span class="hljs-string">'Mark'</span>, <span class="hljs-attr">country</span>: <span class="hljs-string">'USA'</span> }
</code></pre>

<p>The prototype chain is not consulted, and child scope gets two new object properties that hide/shadow the parentScope object properties with the same names.</p>

<p><img src="https://i.stack.imgur.com/hKetH.png" alt="more property hiding"></p>

<p>Takeaways:</p>

<ul>
<li>If we read childScope.propertyX, and childScope has propertyX, then the prototype chain is not consulted.</li>
<li>If we set childScope.propertyX, the prototype chain is not consulted.</li>
</ul>

<p>One last scenario:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">delete</span> childScope.<span class="hljs-property">anArray</span>
childScope.<span class="hljs-property">anArray</span>[<span class="hljs-number">1</span>] === <span class="hljs-number">22</span>  <span class="hljs-comment">// true</span>
</code></pre>

<p>We deleted the childScope property first, then when we try to access the property again, the prototype chain is consulted.</p>

<p><img src="https://i.stack.imgur.com/56uoe.png" alt="after removing a child property"></p>

<hr>

<h2>Angular Scope Inheritance</h2>

<p>The contenders:</p>

<ul>
<li>The following create new scopes, and inherit prototypically: ng-repeat, ng-include, ng-switch, ng-controller, directive with <code>scope: true</code>, directive with <code>transclude: true</code>.</li>
<li>The following creates a new scope which does not inherit prototypically: directive with <code>scope: { ... }</code>.  This creates an "isolate" scope instead.</li>
</ul>

<p>Note, by default, directives do not create new scope -- i.e., the default is <code>scope: false</code>.</p>

<h3>ng-include</h3>

<p>Suppose we have in our controller:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">$scope.<span class="hljs-property">myPrimitive</span> = <span class="hljs-number">50</span>;
$scope.<span class="hljs-property">myObject</span>    = {<span class="hljs-attr">aNumber</span>: <span class="hljs-number">11</span>};
</code></pre>

<p>And in our HTML:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">&lt;script type=<span class="hljs-string">"text/ng-template"</span> id=<span class="hljs-string">"/tpl1.html"</span>&gt;
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ng-model</span>=<span class="hljs-string">"myPrimitive"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ng-include</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"'/tpl1.html'"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>

<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/ng-template"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"/tpl2.html"</span>&gt;</span><span class="language-xml">
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ng-model</span>=<span class="hljs-string">"myObject.aNumber"</span>&gt;</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ng-include</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"'/tpl2.html'"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</span></code></pre>

<p>Each ng-include generates a new child scope, which prototypically inherits from the parent scope.</p>

<p><img src="https://i.stack.imgur.com/ziDfx.png" alt="ng-include child scopes"></p>

<p>Typing (say, "77") into the first input textbox causes the child scope to get a new <code>myPrimitive</code> scope property that hides/shadows the parent scope property of the same name.  This is probably not what you want/expect.</p>

<p><img src="https://i.stack.imgur.com/7l8dg.png" alt="ng-include with a primitive"></p>

<p>Typing (say, "99") into the second input textbox does not result in a new child property.  Because tpl2.html binds the model to an object property, prototypal inheritance kicks in when the ngModel looks for object myObject -- it finds it in the parent scope.</p>

<p><img src="https://i.imgur.com/ZqqloMS.png" alt="ng-include with an object"></p>

<p>We can rewrite the first template to use $parent, if we don't want to change our model from a primitive to an object:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">&lt;input ng-model=<span class="hljs-string">"$parent.myPrimitive"</span>&gt;
</code></pre>

<p>Typing (say, "22") into this input textbox does not result in a new child property.  The model is now bound to a property of the parent scope (because $parent is a child scope property that references the parent scope).</p>

<p><img src="https://i.stack.imgur.com/kd8pj.png" alt="ng-include with $parent"></p>

<p>For all scopes (prototypal or not), Angular always tracks a parent-child relationship (i.e., a hierarchy), via scope properties $parent, $$childHead and $$childTail.  I normally don't show these scope properties in the diagrams.</p>

<p>For scenarios where form elements are not involved, another solution is to define a function on the parent scope to modify the primitive.  Then ensure the child always calls this function, which will be available to the child scope due to prototypal inheritance. E.g.,</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">// in the parent scope</span>
$scope.<span class="hljs-property">setMyPrimitive</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) {
     $scope.<span class="hljs-property">myPrimitive</span> = value;
}
</code></pre>

<p>Here is a <a href="http://jsfiddle.net/mrajcok/jNxyE/" rel="noreferrer">sample fiddle</a> that uses this "parent function" approach.  (The fiddle was written as part of this answer: <a href="https://stackoverflow.com/a/14104318/215945">https://stackoverflow.com/a/14104318/215945</a>.)</p>

<p>See also <a href="https://stackoverflow.com/a/13782671/215945">https://stackoverflow.com/a/13782671/215945</a> and <a href="https://github.com/angular/angular.js/issues/1267" rel="noreferrer">https://github.com/angular/angular.js/issues/1267</a>.</p>

<h3>ng-switch</h3>

<p>ng-switch scope inheritance works just like ng-include.  So if you need 2-way data binding to a primitive in the parent scope, use $parent, or change the model to be an object and then bind to a property of that object.  This will avoid child scope hiding/shadowing of parent scope properties.</p>

<p>See also <a href="https://stackoverflow.com/questions/12405005/angularjs-bind-scope-of-a-switch-case/12414410">AngularJS, bind scope of a switch-case?</a></p>

<h3>ng-repeat</h3>

<p>Ng-repeat works a little differently.  Suppose we have in our controller:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">$scope.<span class="hljs-property">myArrayOfPrimitives</span> = [ <span class="hljs-number">11</span>, <span class="hljs-number">22</span> ];
$scope.<span class="hljs-property">myArrayOfObjects</span>    = [{<span class="hljs-attr">num</span>: <span class="hljs-number">101</span>}, {<span class="hljs-attr">num</span>: <span class="hljs-number">202</span>}]
</code></pre>

<p>And in our HTML:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">&lt;ul&gt;&lt;li ng-repeat="num in myArrayOfPrimitives"&gt;
       &lt;input ng-model="num"&gt;
    &lt;/li&gt;
&lt;ul&gt;
&lt;ul&gt;&lt;li ng-repeat="obj in myArrayOfObjects"&gt;
       &lt;input ng-model="obj.num"&gt;
    &lt;/li&gt;
&lt;ul&gt;
</code></pre>

<p>For each item/iteration, ng-repeat creates a new scope, which prototypically inherits from the parent scope, <strong>but it also assigns the item's value to a new property on the new child scope</strong>.  (The name of the new property is the loop variable's name.)  Here's what the Angular source code for ng-repeat actually is:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">childScope = scope.$new();  <span class="hljs-comment">// child scope prototypically inherits from parent scope</span>
...
childScope[valueIdent] = value;  <span class="hljs-comment">// creates a new childScope property</span>
</code></pre>

<p>If item is a primitive (as in myArrayOfPrimitives), essentially a copy of the value is assigned to the new child scope property.  Changing the child scope property's value (i.e., using ng-model, hence child scope <code>num</code>) does <strong>not</strong> change the array the parent scope references.  So in the first ng-repeat above, each child scope gets a <code>num</code> property that is independent of the myArrayOfPrimitives array:</p>

<p><img src="https://i.stack.imgur.com/nLoiW.png" alt="ng-repeat with primitives"></p>

<p>This ng-repeat will not work (like you want/expect it to).  Typing into the textboxes changes the values in the gray boxes, which are only visible in the child scopes.  What we want is for the inputs to affect the myArrayOfPrimitives array, not a child scope primitive property.  To accomplish this, we need to change the model to be an array of objects.</p>

<p>So, if item is an object, a reference to the original object (not a copy) is assigned to the new child scope property.  Changing the child scope property's value (i.e., using ng-model, hence <code>obj.num</code>) <strong>does</strong> change the object the parent scope references.  So in the second ng-repeat above, we have:</p>

<p><img src="https://i.stack.imgur.com/QSjTJ.png" alt="ng-repeat with objects"></p>

<p>(I colored one line gray just so that it is clear where it is going.)</p>

<p>This works as expected.  Typing into the textboxes changes the values in the gray boxes, which are visible to both the child and parent scopes.</p>

<p>See also <a href="https://stackoverflow.com/questions/13714884/difficulty-with-ng-model-ng-repeat-and-inputs">Difficulty with ng-model, ng-repeat, and inputs</a> and 
<a href="https://stackoverflow.com/a/13782671/215945">https://stackoverflow.com/a/13782671/215945</a></p>

<h3>ng-controller</h3>

<p>Nesting controllers using ng-controller results in normal prototypal inheritance, just like ng-include and ng-switch, so the same techniques apply.
However, "it is considered bad form for two controllers to share information via $scope inheritance" -- <a href="http://onehungrymind.com/angularjs-sticky-notes-pt-1-architecture/" rel="noreferrer">http://onehungrymind.com/angularjs-sticky-notes-pt-1-architecture/</a>
A service should be used to share data between controllers instead.</p>

<p>(If you really want to share data via controllers scope inheritance, there is nothing you need to do.  The child scope will have access to all of the parent scope properties.
See also <a href="https://stackoverflow.com/questions/13825419/controller-load-order-differs-when-loading-or-navigating/13843771#13843771">Controller load order differs when loading or navigating</a>)</p>

<h3>directives</h3>

<ol>
<li>default (<code>scope: false</code>) - the directive does not create a new scope, so there is no inheritance here.  This is easy, but also dangerous because, e.g., a directive might think it is creating a new property on the scope, when in fact it is clobbering an existing property.  This is not a good choice for writing directives that are intended as reusable components.</li>
<li><code>scope: true</code> - the directive creates a new child scope that prototypically inherits from the parent scope.  If more than one directive (on the same DOM element) requests a new scope, only one new child scope is created.  Since we have "normal" prototypal inheritance, this is like ng-include and ng-switch, so be wary of 2-way data binding to parent scope primitives, and child scope hiding/shadowing of parent scope properties.</li>
<li><code>scope: { ... }</code> - the directive creates a new isolate/isolated scope.  It does not prototypically inherit.  This is usually your best choice when creating reusable components, since the directive cannot accidentally read or modify the parent scope.  However, such directives often need access to a few parent scope properties.  The object hash is used to set up two-way binding (using '=') or one-way binding (using '@') between the parent scope and the isolate scope.  There is also '&amp;' to bind to parent scope expressions.  So, these all create local scope properties that are derived from the parent scope.
Note that attributes are used to help set up the binding -- you can't just reference parent scope property names in the object hash, you have to use an attribute.  E.g., this won't work if you want to bind to parent property <code>parentProp</code> in the isolated scope: <code>&lt;div my-directive&gt;</code> and <code>scope: { localProp: '@parentProp' }</code>.  An attribute must be used to specify each parent property that the directive wants to bind to: <code>&lt;div my-directive the-Parent-Prop=parentProp&gt;</code> and <code>scope: { localProp: '@theParentProp' }</code>.
<br>Isolate scope's <code>__proto__</code> references Object.
Isolate scope's $parent references the parent scope, so although it is isolated and doesn't inherit prototypically from the parent scope, it is still a child scope.
<br>For the picture below we have
<br>  <code>&lt;my-directive interpolated="{{parentProp1}}" twowayBinding="parentProp2"&gt;</code> and
<br>  <code>scope: { interpolatedProp: '@interpolated', twowayBindingProp: '=twowayBinding' }</code>
<br>Also, assume the directive does this in its linking function: <code>scope.someIsolateProp = "I'm isolated"</code>
<br> <img src="https://i.stack.imgur.com/MUxS4.png" alt="isolated scope">
<br>For more information on isolate scopes see <a href="http://onehungrymind.com/angularjs-sticky-notes-pt-2-isolated-scope/" rel="noreferrer">http://onehungrymind.com/angularjs-sticky-notes-pt-2-isolated-scope/</a></li>
<li><code>transclude: true</code> - the directive creates a new "transcluded" child scope, which prototypically inherits from the parent scope.  The transcluded and the isolated scope (if any) are siblings -- the $parent property of each scope references the same parent scope.  When a transcluded and an isolate scope both exist, isolate scope property $$nextSibling will reference the transcluded scope.  I'm not aware of any nuances with the transcluded scope.
<br>For the picture below, assume the same directive as above with this addition: <code>transclude: true</code>
<br><img src="https://i.stack.imgur.com/fkWHA.png" alt="transcluded scope"></li>
</ol>

<p>This <a href="http://jsfiddle.net/mrajcok/7g3QM/" rel="noreferrer">fiddle</a> has a <code>showScope()</code> function that can be used to examine an isolate and transcluded scope.  See the instructions in the comments in the fiddle.</p>

<hr>

<h2>Summary</h2>

<p>There are four types of scopes:</p>

<ol>
<li>normal prototypal scope inheritance -- ng-include, ng-switch, ng-controller, directive with <code>scope: true</code></li>
<li>normal prototypal scope inheritance with a copy/assignment -- ng-repeat.  Each iteration of ng-repeat creates a new child scope, and that new child scope always gets a new property.</li>
<li>isolate scope -- directive with <code>scope: {...}</code>.  This one is not prototypal, but '=', '@', and '&amp;' provide a mechanism to access parent scope properties, via attributes.</li>
<li>transcluded scope -- directive with <code>transclude: true</code>.  This one is also normal prototypal scope inheritance, but it is also a sibling of any isolate scope.</li>
</ol>

<p>For all scopes (prototypal or not), Angular always tracks a parent-child relationship (i.e., a hierarchy), via properties $parent and $$childHead and $$childTail.</p>

<p>Diagrams were generated with <a href="/questions/tagged/graphviz" class="post-tag" title="show questions tagged 'graphviz'" rel="tag">graphviz</a> "*.dot" files, which are on <a href="https://github.com/mrajcok/angularjs-prototypal-inheritance-diagrams" rel="noreferrer">github</a>. Tim Caswell's "<a href="http://howtonode.org/object-graphs" rel="noreferrer">Learning JavaScript with Object Graphs</a>" was the inspiration for using GraphViz for the diagrams. </p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/prototypal-inheritance">prototypal-inheritance</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I in no way want to compete with Mark's answer, but just wanted to highlight the piece that finally made everything click as someone new to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain">Javascript inheritance and its prototype chain</a>.</p>

<p><strong>Only property reads search the prototype chain, not writes.</strong> So when you set</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">myObject.<span class="hljs-property">prop</span> = <span class="hljs-string">'123'</span>;
</code></pre>

<p>It doesn't look up the chain, but when you set </p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">myObject.<span class="hljs-property">myThing</span>.<span class="hljs-property">prop</span> = <span class="hljs-string">'123'</span>;
</code></pre>

<p><strong>there's a subtle read going on within that write operation</strong> that tries to look up myThing before writing to its prop. So that's why writing to object.properties from the child gets at the parent's objects.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/prototypal-inheritance">prototypal-inheritance</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I would like to add an example of prototypical inheritance with javascript to @Scott Driscoll answer. We'll be using classical inheritance pattern with Object.create() which is a part of  EcmaScript 5 specification.</p>

<p>First we create "Parent" object function</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>){

}
</code></pre>

<p>Then add a prototype to "Parent" object function</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"> <span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = {
 primitive : <span class="hljs-number">1</span>,
 object : {
    one : <span class="hljs-number">1</span>
   }
}
</code></pre>

<p>Create "Child" object function</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>){

}
</code></pre>

<p>Assign child prototype (Make child prototype inherit from parent prototype)</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
</code></pre>

<p>Assign proper "Child" prototype constructor</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span>;
</code></pre>

<p>Add method "changeProps" to a child prototype, which will rewrite "primitive" property value in Child object and change "object.one" value  both in Child and Parent objects</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">changeProps</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">primitive</span> = <span class="hljs-number">2</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">object</span>.<span class="hljs-property">one</span> = <span class="hljs-number">2</span>;
};
</code></pre>

<p>Initiate Parent (dad) and Child (son) objects.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> dad = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();
<span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();
</code></pre>

<p>Call Child (son) changeProps method</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">son.<span class="hljs-title function_">changeProps</span>();
</code></pre>

<p><em>Check the results.</em></p>

<p>Parent primitive property did not change</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dad.<span class="hljs-property">primitive</span>); <span class="hljs-comment">/* 1 */</span>
</code></pre>

<p>Child primitive property changed (rewritten)</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(son.<span class="hljs-property">primitive</span>); <span class="hljs-comment">/* 2 */</span>
</code></pre>

<p>Parent and Child object.one properties changed</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dad.<span class="hljs-property">object</span>.<span class="hljs-property">one</span>); <span class="hljs-comment">/* 2 */</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(son.<span class="hljs-property">object</span>.<span class="hljs-property">one</span>); <span class="hljs-comment">/* 2 */</span>
</code></pre>

<p>Working example here <a href="http://jsbin.com/xexurukiso/1/edit/" rel="noreferrer">http://jsbin.com/xexurukiso/1/edit/</a></p>

<p>More info on Object.create here <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/create" rel="noreferrer">https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/create</a></p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/get-top-1-row-of-each-group-1657387438304">Get top 1 row of each group</a><a href="/questions/when-to-use-linkedlist-over-arraylist-in-java-1657388107480">When to use LinkedList over ArrayList in Java?</a><a href="/questions/what-is-a-clearfix-1657387337825">What is a clearfix?</a><a href="/questions/how-do-i-detect-a-click-outside-an-element-1657387505351">How do I detect a click outside an element?</a><a href="/questions/how-to-fix-java.lang.unsupportedclassversionerror:-unsupported-major.minor-version-1657384863422">How to fix java.lang.UnsupportedClassVersionError: Unsupported major.minor version</a><a href="/questions/using-regular-expressions-to-parse-html:-why-not-1657387543969">Using regular expressions to parse HTML: why not?</a><a href="/questions/asking-the-user-for-input-until-they-give-a-valid-response-1657384376162">Asking the user for input until they give a valid response</a><a href="/questions/what-is-the-difference-between-and-equals()-in-java-1657387729654">What is the difference between == and equals() in Java?</a><a href="/questions/what-is-dom-event-delegation-1657387625599">What is DOM Event delegation?</a><a href="/questions/how-do-i-split-a-list-into-equally-sized-chunks-1657384580399">How do I split a list into equally-sized chunks?</a><a href="/questions/how-to-make-good-reproducible-pandas-examples-1657384310402">How to make good reproducible pandas examples</a><a href="/questions/learning-regular-expressions-closed-1657384719460">Learning Regular Expressions [closed]</a><a href="/questions/how-can-i-access-and-process-nested-objects-arrays-or-json-1657384332823">How can I access and process nested objects, arrays, or JSON?</a><a href="/questions/align-inline-block-divs-to-top-of-container-element-1657387489610">Align inline-block DIVs to top of container element</a><a href="/questions/event.preventdefault()-vs.-return-false-1657387458377">event.preventDefault() vs. return false</a><a href="/questions/how-do-i-revert-a-git-repository-to-a-previous-commit-1657387714717">How do I revert a Git repository to a previous commit?</a><a href="/questions/css-selector-for-first-element-with-class-1657388028765">CSS selector for first element with class</a><a href="/questions/utf-8-all-the-way-through-1657384323434">UTF-8 all the way through</a><a href="/questions/the-usestate-set-method-is-not-reflecting-a-change-immediately-1657384524775">The useState set method is not reflecting a change immediately</a><a href="/questions/disable-same-origin-policy-in-chrome-1657387743804">Disable same origin policy in Chrome</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Quick answer\u0026lt;/strong\u0026gt;: \u0026lt;br\u0026gt;\nA child scope normally prototypically inherits from its parent scope, but not always.  One exception to this rule is a directive with \u0026lt;code\u0026gt;scope: { ... }\u0026lt;/code\u0026gt; -- this creates an \u0026quot;isolate\u0026quot; scope that does not prototypically inherit.  This construct is often used when creating a \u0026quot;reusable component\u0026quot; directive.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As for the nuances, scope inheritance is normally straightfoward... until you need \u0026lt;strong\u0026gt;2-way data binding\u0026lt;/strong\u0026gt; (i.e., form elements, ng-model) in the child scope.  Ng-repeat, ng-switch, and ng-include can trip you up if you try to bind to a \u0026lt;strong\u0026gt;primitive\u0026lt;/strong\u0026gt; (e.g., number, string, boolean) in the parent scope from inside the child scope.  It doesn\u0026apos;t work the way most people expect it should work.  The child scope gets its own property that hides/shadows the parent property of the same name.  Your workarounds are\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;define objects in the parent for your model, then reference a property of that object  in the child:  parentObj.someProp\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;use $parent.parentScopeProperty (not always possible, but easier than 1. where possible)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;define a function on the parent scope, and call it from the child (not always possible)\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;New AngularJS developers often do not realize that \u0026lt;code\u0026gt;ng-repeat\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;ng-switch\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;ng-view\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;ng-include\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;ng-if\u0026lt;/code\u0026gt; all create new child scopes, so the problem often shows up when these directives are involved. (See \u0026lt;a href=\u0026quot;http://plnkr.co/edit/zZfUQN?p=preview\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;this example\u0026lt;/a\u0026gt; for a quick illustration of the problem.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This issue with primitives can be easily avoided by following the \u0026quot;best practice\u0026quot; of \u0026lt;a href=\u0026quot;http://www.youtube.com/watch?v=ZhfUv0spHCY\u0026amp;amp;feature=youtu.be\u0026amp;amp;t=30m\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;always have a \u0026apos;.\u0026apos; in your ng-models\u0026lt;/a\u0026gt;  watch 3 minutes worth. Misko demonstrates the primitive binding issue with \u0026lt;code\u0026gt;ng-switch\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Having a \u0026apos;.\u0026apos; in your models will ensure that prototypal inheritance is in play. So, use\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026amp;lt;input type=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;text\u0026quot;\u0026lt;/span\u0026gt; ng-model=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;someObj.prop1\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\n\n\u0026amp;lt;!--rather than\n\u0026amp;lt;input type=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;text\u0026quot;\u0026lt;/span\u0026gt; ng-model=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;prop1\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;`\n--\u0026amp;gt;\n\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;hr\u0026gt;\n\u0026lt;strong\u0026gt;L-o-n-g answer\u0026lt;/strong\u0026gt;:\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;JavaScript Prototypal Inheritance\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Also placed on the AngularJS wiki:\u0026lt;/strong\u0026gt; \u0026lt;a href=\u0026quot;https://github.com/angular/angular.js/wiki/Understanding-Scopes\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://github.com/angular/angular.js/wiki/Understanding-Scopes\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It is important to first have a solid understanding of prototypal inheritance, especially if you are coming from a server-side background and you are more familiar with class-ical inheritance.  So let\u0026apos;s review that first.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Suppose parentScope has properties aString, aNumber, anArray, anObject, and aFunction.  If childScope prototypically inherits from parentScope, we have:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/aTAGg.png\u0026quot; alt=\u0026quot;prototypal inheritance\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;(Note that to save space, I show the \u0026lt;code\u0026gt;anArray\u0026lt;/code\u0026gt; object as a single blue object with its three values, rather than an single blue object with three separate gray literals.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If we try to access a property defined on the parentScope from the child scope, JavaScript will first look in the child scope, not find the property, then look in the inherited scope, and find the property.  (If it didn\u0026apos;t find the property in the parentScope, it would continue up the prototype chain... all the way up to the root scope). So, these are all true:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;childScope.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;aString\u0026lt;/span\u0026gt; === \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;parent string\u0026apos;\u0026lt;/span\u0026gt;\nchildScope.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;anArray\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] === \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt;\nchildScope.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;anObject\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;property1\u0026lt;/span\u0026gt; === \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;parent prop1\u0026apos;\u0026lt;/span\u0026gt;\nchildScope.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;aFunction\u0026lt;/span\u0026gt;() === \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;parent output\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Suppose we then do this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;childScope.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;aString\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;child string\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The prototype chain is not consulted, and a new aString property is added to the childScope.  \u0026lt;strong\u0026gt;This new property hides/shadows the parentScope property with the same name.\u0026lt;/strong\u0026gt;  This will become very important when we discuss ng-repeat and ng-include below.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/OyVPW.png\u0026quot; alt=\u0026quot;property hiding\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Suppose we then do this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;childScope.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;anArray\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;22\u0026apos;\u0026lt;/span\u0026gt;\nchildScope.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;anObject\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;property1\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;child prop1\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The prototype chain is consulted because the objects (anArray and anObject) are not found in the childScope.  The objects are found in the parentScope, and the property values are updated on the original objects.  No new properties are added to the childScope;  no new objects are created.  (Note that in JavaScript arrays and functions are also objects.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/2QceU.png\u0026quot; alt=\u0026quot;follow the prototype chain\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Suppose we then do this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;childScope.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;anArray\u0026lt;/span\u0026gt; = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;555\u0026lt;/span\u0026gt;]\nchildScope.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;anObject\u0026lt;/span\u0026gt; = { \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Mark\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;country\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;USA\u0026apos;\u0026lt;/span\u0026gt; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The prototype chain is not consulted, and child scope gets two new object properties that hide/shadow the parentScope object properties with the same names.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/hKetH.png\u0026quot; alt=\u0026quot;more property hiding\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Takeaways:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If we read childScope.propertyX, and childScope has propertyX, then the prototype chain is not consulted.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If we set childScope.propertyX, the prototype chain is not consulted.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;One last scenario:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; childScope.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;anArray\u0026lt;/span\u0026gt;\nchildScope.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;anArray\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] === \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;22\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;We deleted the childScope property first, then when we try to access the property again, the prototype chain is consulted.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/56uoe.png\u0026quot; alt=\u0026quot;after removing a child property\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h2\u0026gt;Angular Scope Inheritance\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The contenders:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;The following create new scopes, and inherit prototypically: ng-repeat, ng-include, ng-switch, ng-controller, directive with \u0026lt;code\u0026gt;scope: true\u0026lt;/code\u0026gt;, directive with \u0026lt;code\u0026gt;transclude: true\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The following creates a new scope which does not inherit prototypically: directive with \u0026lt;code\u0026gt;scope: { ... }\u0026lt;/code\u0026gt;.  This creates an \u0026quot;isolate\u0026quot; scope instead.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Note, by default, directives do not create new scope -- i.e., the default is \u0026lt;code\u0026gt;scope: false\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;ng-include\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;Suppose we have in our controller:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;$scope.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;myPrimitive\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;50\u0026lt;/span\u0026gt;;\n$scope.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;myObject\u0026lt;/span\u0026gt;    = {\u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;aNumber\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And in our HTML:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026amp;lt;script type=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;text/ng-template\u0026quot;\u0026lt;/span\u0026gt; id=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/tpl1.html\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;input\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;ng-model\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;myPrimitive\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;script\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;ng-include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;src\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026apos;/tpl1.html\u0026apos;\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;script\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;text/ng-template\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/tpl2.html\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;language-xml\u0026quot;\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;input\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;ng-model\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;myObject.aNumber\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;script\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;ng-include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;src\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026apos;/tpl2.html\u0026apos;\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Each ng-include generates a new child scope, which prototypically inherits from the parent scope.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/ziDfx.png\u0026quot; alt=\u0026quot;ng-include child scopes\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Typing (say, \u0026quot;77\u0026quot;) into the first input textbox causes the child scope to get a new \u0026lt;code\u0026gt;myPrimitive\u0026lt;/code\u0026gt; scope property that hides/shadows the parent scope property of the same name.  This is probably not what you want/expect.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/7l8dg.png\u0026quot; alt=\u0026quot;ng-include with a primitive\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Typing (say, \u0026quot;99\u0026quot;) into the second input textbox does not result in a new child property.  Because tpl2.html binds the model to an object property, prototypal inheritance kicks in when the ngModel looks for object myObject -- it finds it in the parent scope.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.imgur.com/ZqqloMS.png\u0026quot; alt=\u0026quot;ng-include with an object\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;We can rewrite the first template to use $parent, if we don\u0026apos;t want to change our model from a primitive to an object:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026amp;lt;input ng-model=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;$parent.myPrimitive\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Typing (say, \u0026quot;22\u0026quot;) into this input textbox does not result in a new child property.  The model is now bound to a property of the parent scope (because $parent is a child scope property that references the parent scope).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/kd8pj.png\u0026quot; alt=\u0026quot;ng-include with $parent\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For all scopes (prototypal or not), Angular always tracks a parent-child relationship (i.e., a hierarchy), via scope properties $parent, $$childHead and $$childTail.  I normally don\u0026apos;t show these scope properties in the diagrams.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For scenarios where form elements are not involved, another solution is to define a function on the parent scope to modify the primitive.  Then ensure the child always calls this function, which will be available to the child scope due to prototypal inheritance. E.g.,\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// in the parent scope\u0026lt;/span\u0026gt;\n$scope.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;setMyPrimitive\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;) {\n     $scope.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;myPrimitive\u0026lt;/span\u0026gt; = value;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here is a \u0026lt;a href=\u0026quot;http://jsfiddle.net/mrajcok/jNxyE/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;sample fiddle\u0026lt;/a\u0026gt; that uses this \u0026quot;parent function\u0026quot; approach.  (The fiddle was written as part of this answer: \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/14104318/215945\u0026quot;\u0026gt;https://stackoverflow.com/a/14104318/215945\u0026lt;/a\u0026gt;.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;See also \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/13782671/215945\u0026quot;\u0026gt;https://stackoverflow.com/a/13782671/215945\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;https://github.com/angular/angular.js/issues/1267\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://github.com/angular/angular.js/issues/1267\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;ng-switch\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;ng-switch scope inheritance works just like ng-include.  So if you need 2-way data binding to a primitive in the parent scope, use $parent, or change the model to be an object and then bind to a property of that object.  This will avoid child scope hiding/shadowing of parent scope properties.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;See also \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/12405005/angularjs-bind-scope-of-a-switch-case/12414410\u0026quot;\u0026gt;AngularJS, bind scope of a switch-case?\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;ng-repeat\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;Ng-repeat works a little differently.  Suppose we have in our controller:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;$scope.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;myArrayOfPrimitives\u0026lt;/span\u0026gt; = [ \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;22\u0026lt;/span\u0026gt; ];\n$scope.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;myArrayOfObjects\u0026lt;/span\u0026gt;    = [{\u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;num\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;101\u0026lt;/span\u0026gt;}, {\u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;num\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;202\u0026lt;/span\u0026gt;}]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And in our HTML:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026amp;lt;ul\u0026amp;gt;\u0026amp;lt;li ng-repeat=\u0026quot;num in myArrayOfPrimitives\u0026quot;\u0026amp;gt;\n       \u0026amp;lt;input ng-model=\u0026quot;num\u0026quot;\u0026amp;gt;\n    \u0026amp;lt;/li\u0026amp;gt;\n\u0026amp;lt;ul\u0026amp;gt;\n\u0026amp;lt;ul\u0026amp;gt;\u0026amp;lt;li ng-repeat=\u0026quot;obj in myArrayOfObjects\u0026quot;\u0026amp;gt;\n       \u0026amp;lt;input ng-model=\u0026quot;obj.num\u0026quot;\u0026amp;gt;\n    \u0026amp;lt;/li\u0026amp;gt;\n\u0026amp;lt;ul\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;For each item/iteration, ng-repeat creates a new scope, which prototypically inherits from the parent scope, \u0026lt;strong\u0026gt;but it also assigns the item\u0026apos;s value to a new property on the new child scope\u0026lt;/strong\u0026gt;.  (The name of the new property is the loop variable\u0026apos;s name.)  Here\u0026apos;s what the Angular source code for ng-repeat actually is:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;childScope = scope.$new();  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// child scope prototypically inherits from parent scope\u0026lt;/span\u0026gt;\n...\nchildScope[valueIdent] = value;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// creates a new childScope property\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If item is a primitive (as in myArrayOfPrimitives), essentially a copy of the value is assigned to the new child scope property.  Changing the child scope property\u0026apos;s value (i.e., using ng-model, hence child scope \u0026lt;code\u0026gt;num\u0026lt;/code\u0026gt;) does \u0026lt;strong\u0026gt;not\u0026lt;/strong\u0026gt; change the array the parent scope references.  So in the first ng-repeat above, each child scope gets a \u0026lt;code\u0026gt;num\u0026lt;/code\u0026gt; property that is independent of the myArrayOfPrimitives array:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/nLoiW.png\u0026quot; alt=\u0026quot;ng-repeat with primitives\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This ng-repeat will not work (like you want/expect it to).  Typing into the textboxes changes the values in the gray boxes, which are only visible in the child scopes.  What we want is for the inputs to affect the myArrayOfPrimitives array, not a child scope primitive property.  To accomplish this, we need to change the model to be an array of objects.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So, if item is an object, a reference to the original object (not a copy) is assigned to the new child scope property.  Changing the child scope property\u0026apos;s value (i.e., using ng-model, hence \u0026lt;code\u0026gt;obj.num\u0026lt;/code\u0026gt;) \u0026lt;strong\u0026gt;does\u0026lt;/strong\u0026gt; change the object the parent scope references.  So in the second ng-repeat above, we have:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/QSjTJ.png\u0026quot; alt=\u0026quot;ng-repeat with objects\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;(I colored one line gray just so that it is clear where it is going.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This works as expected.  Typing into the textboxes changes the values in the gray boxes, which are visible to both the child and parent scopes.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;See also \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/13714884/difficulty-with-ng-model-ng-repeat-and-inputs\u0026quot;\u0026gt;Difficulty with ng-model, ng-repeat, and inputs\u0026lt;/a\u0026gt; and \n\u0026lt;a href=\u0026quot;https://stackoverflow.com/a/13782671/215945\u0026quot;\u0026gt;https://stackoverflow.com/a/13782671/215945\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;ng-controller\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;Nesting controllers using ng-controller results in normal prototypal inheritance, just like ng-include and ng-switch, so the same techniques apply.\nHowever, \u0026quot;it is considered bad form for two controllers to share information via $scope inheritance\u0026quot; -- \u0026lt;a href=\u0026quot;http://onehungrymind.com/angularjs-sticky-notes-pt-1-architecture/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://onehungrymind.com/angularjs-sticky-notes-pt-1-architecture/\u0026lt;/a\u0026gt;\nA service should be used to share data between controllers instead.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;(If you really want to share data via controllers scope inheritance, there is nothing you need to do.  The child scope will have access to all of the parent scope properties.\nSee also \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/13825419/controller-load-order-differs-when-loading-or-navigating/13843771#13843771\u0026quot;\u0026gt;Controller load order differs when loading or navigating\u0026lt;/a\u0026gt;)\u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;directives\u0026lt;/h3\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;default (\u0026lt;code\u0026gt;scope: false\u0026lt;/code\u0026gt;) - the directive does not create a new scope, so there is no inheritance here.  This is easy, but also dangerous because, e.g., a directive might think it is creating a new property on the scope, when in fact it is clobbering an existing property.  This is not a good choice for writing directives that are intended as reusable components.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;scope: true\u0026lt;/code\u0026gt; - the directive creates a new child scope that prototypically inherits from the parent scope.  If more than one directive (on the same DOM element) requests a new scope, only one new child scope is created.  Since we have \u0026quot;normal\u0026quot; prototypal inheritance, this is like ng-include and ng-switch, so be wary of 2-way data binding to parent scope primitives, and child scope hiding/shadowing of parent scope properties.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;scope: { ... }\u0026lt;/code\u0026gt; - the directive creates a new isolate/isolated scope.  It does not prototypically inherit.  This is usually your best choice when creating reusable components, since the directive cannot accidentally read or modify the parent scope.  However, such directives often need access to a few parent scope properties.  The object hash is used to set up two-way binding (using \u0026apos;=\u0026apos;) or one-way binding (using \u0026apos;@\u0026apos;) between the parent scope and the isolate scope.  There is also \u0026apos;\u0026amp;amp;\u0026apos; to bind to parent scope expressions.  So, these all create local scope properties that are derived from the parent scope.\nNote that attributes are used to help set up the binding -- you can\u0026apos;t just reference parent scope property names in the object hash, you have to use an attribute.  E.g., this won\u0026apos;t work if you want to bind to parent property \u0026lt;code\u0026gt;parentProp\u0026lt;/code\u0026gt; in the isolated scope: \u0026lt;code\u0026gt;\u0026amp;lt;div my-directive\u0026amp;gt;\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;scope: { localProp: \u0026apos;@parentProp\u0026apos; }\u0026lt;/code\u0026gt;.  An attribute must be used to specify each parent property that the directive wants to bind to: \u0026lt;code\u0026gt;\u0026amp;lt;div my-directive the-Parent-Prop=parentProp\u0026amp;gt;\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;scope: { localProp: \u0026apos;@theParentProp\u0026apos; }\u0026lt;/code\u0026gt;.\n\u0026lt;br\u0026gt;Isolate scope\u0026apos;s \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; references Object.\nIsolate scope\u0026apos;s $parent references the parent scope, so although it is isolated and doesn\u0026apos;t inherit prototypically from the parent scope, it is still a child scope.\n\u0026lt;br\u0026gt;For the picture below we have\n\u0026lt;br\u0026gt;  \u0026lt;code\u0026gt;\u0026amp;lt;my-directive interpolated=\u0026quot;{{parentProp1}}\u0026quot; twowayBinding=\u0026quot;parentProp2\u0026quot;\u0026amp;gt;\u0026lt;/code\u0026gt; and\n\u0026lt;br\u0026gt;  \u0026lt;code\u0026gt;scope: { interpolatedProp: \u0026apos;@interpolated\u0026apos;, twowayBindingProp: \u0026apos;=twowayBinding\u0026apos; }\u0026lt;/code\u0026gt;\n\u0026lt;br\u0026gt;Also, assume the directive does this in its linking function: \u0026lt;code\u0026gt;scope.someIsolateProp = \u0026quot;I\u0026apos;m isolated\u0026quot;\u0026lt;/code\u0026gt;\n\u0026lt;br\u0026gt; \u0026lt;img src=\u0026quot;https://i.stack.imgur.com/MUxS4.png\u0026quot; alt=\u0026quot;isolated scope\u0026quot;\u0026gt;\n\u0026lt;br\u0026gt;For more information on isolate scopes see \u0026lt;a href=\u0026quot;http://onehungrymind.com/angularjs-sticky-notes-pt-2-isolated-scope/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://onehungrymind.com/angularjs-sticky-notes-pt-2-isolated-scope/\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;transclude: true\u0026lt;/code\u0026gt; - the directive creates a new \u0026quot;transcluded\u0026quot; child scope, which prototypically inherits from the parent scope.  The transcluded and the isolated scope (if any) are siblings -- the $parent property of each scope references the same parent scope.  When a transcluded and an isolate scope both exist, isolate scope property $$nextSibling will reference the transcluded scope.  I\u0026apos;m not aware of any nuances with the transcluded scope.\n\u0026lt;br\u0026gt;For the picture below, assume the same directive as above with this addition: \u0026lt;code\u0026gt;transclude: true\u0026lt;/code\u0026gt;\n\u0026lt;br\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/fkWHA.png\u0026quot; alt=\u0026quot;transcluded scope\u0026quot;\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;This \u0026lt;a href=\u0026quot;http://jsfiddle.net/mrajcok/7g3QM/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;fiddle\u0026lt;/a\u0026gt; has a \u0026lt;code\u0026gt;showScope()\u0026lt;/code\u0026gt; function that can be used to examine an isolate and transcluded scope.  See the instructions in the comments in the fiddle.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h2\u0026gt;Summary\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;There are four types of scopes:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;normal prototypal scope inheritance -- ng-include, ng-switch, ng-controller, directive with \u0026lt;code\u0026gt;scope: true\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;normal prototypal scope inheritance with a copy/assignment -- ng-repeat.  Each iteration of ng-repeat creates a new child scope, and that new child scope always gets a new property.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;isolate scope -- directive with \u0026lt;code\u0026gt;scope: {...}\u0026lt;/code\u0026gt;.  This one is not prototypal, but \u0026apos;=\u0026apos;, \u0026apos;@\u0026apos;, and \u0026apos;\u0026amp;amp;\u0026apos; provide a mechanism to access parent scope properties, via attributes.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;transcluded scope -- directive with \u0026lt;code\u0026gt;transclude: true\u0026lt;/code\u0026gt;.  This one is also normal prototypal scope inheritance, but it is also a sibling of any isolate scope.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;For all scopes (prototypal or not), Angular always tracks a parent-child relationship (i.e., a hierarchy), via properties $parent and $$childHead and $$childTail.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Diagrams were generated with \u0026lt;a href=\u0026quot;/questions/tagged/graphviz\u0026quot; class=\u0026quot;post-tag\u0026quot; title=\u0026quot;show questions tagged \u0026apos;graphviz\u0026apos;\u0026quot; rel=\u0026quot;tag\u0026quot;\u0026gt;graphviz\u0026lt;/a\u0026gt; \u0026quot;*.dot\u0026quot; files, which are on \u0026lt;a href=\u0026quot;https://github.com/mrajcok/angularjs-prototypal-inheritance-diagrams\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;github\u0026lt;/a\u0026gt;. Tim Caswell\u0026apos;s \u0026quot;\u0026lt;a href=\u0026quot;http://howtonode.org/object-graphs\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Learning JavaScript with Object Graphs\u0026lt;/a\u0026gt;\u0026quot; was the inspiration for using GraphViz for the diagrams. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I in no way want to compete with Mark\u0026apos;s answer, but just wanted to highlight the piece that finally made everything click as someone new to \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain\u0026quot;\u0026gt;Javascript inheritance and its prototype chain\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Only property reads search the prototype chain, not writes.\u0026lt;/strong\u0026gt; So when you set\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;myObject.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;prop\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;123\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It doesn\u0026apos;t look up the chain, but when you set \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;myObject.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;myThing\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;prop\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;123\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;there\u0026apos;s a subtle read going on within that write operation\u0026lt;/strong\u0026gt; that tries to look up myThing before writing to its prop. So that\u0026apos;s why writing to object.properties from the child gets at the parent\u0026apos;s objects.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I would like to add an example of prototypical inheritance with javascript to @Scott Driscoll answer. We\u0026apos;ll be using classical inheritance pattern with Object.create() which is a part of  EcmaScript 5 specification.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;First we create \u0026quot;Parent\u0026quot; object function\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Parent\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;){\n\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Then add a prototype to \u0026quot;Parent\u0026quot; object function\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Parent\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; = {\n primitive : \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\n object : {\n    one : \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n   }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Create \u0026quot;Child\u0026quot; object function\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Child\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;){\n\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Assign child prototype (Make child prototype inherit from parent prototype)\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Child\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;create\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Parent\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Assign proper \u0026quot;Child\u0026quot; prototype constructor\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Child\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;constructor\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Child\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Add method \u0026quot;changeProps\u0026quot; to a child prototype, which will rewrite \u0026quot;primitive\u0026quot; property value in Child object and change \u0026quot;object.one\u0026quot; value  both in Child and Parent objects\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Child\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;changeProps\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;){\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;primitive\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;one\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Initiate Parent (dad) and Child (son) objects.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; dad = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Parent\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; son = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Child\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Call Child (son) changeProps method\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;son.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;changeProps\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Check the results.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Parent primitive property did not change\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(dad.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;primitive\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* 1 */\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Child primitive property changed (rewritten)\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(son.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;primitive\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* 2 */\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Parent and Child object.one properties changed\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(dad.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;one\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* 2 */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(son.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;one\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* 2 */\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Working example here \u0026lt;a href=\u0026quot;http://jsbin.com/xexurukiso/1/edit/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://jsbin.com/xexurukiso/1/edit/\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;More info on Object.create here \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/create\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/create\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    "],"id":228,"title":"What are the nuances of scope prototypal / prototypical inheritance in AngularJS?","content":"\n                \n\u0026lt;p\u0026gt;The \u0026lt;a href=\u0026quot;http://docs.angularjs.org/api/ng.$rootScope.Scope\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;API Reference Scope page\u0026lt;/a\u0026gt; says:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;A scope \u0026lt;em\u0026gt;can\u0026lt;/em\u0026gt; inherit from a parent scope.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;a href=\u0026quot;http://docs.angularjs.org/guide/scope\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Developer Guide Scope page\u0026lt;/a\u0026gt; says:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;A scope (prototypically) inherits properties from its parent scope.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;So, does a child scope always prototypically inherit from its parent scope?  \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Are there exceptions?   \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;When it does inherit, is it always normal JavaScript prototypal inheritance?\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","slug":"what-are-the-nuances-of-scope-prototypal-prototypical-inheritance-in-angularjs-1657387340067","postType":"QUESTION","createdAt":"2022-07-09T17:22:20.000Z","updatedAt":"2022-07-09T17:22:20.000Z","tags":[{"id":1544,"name":"prototypal-inheritance","slug":"prototypal-inheritance","createdAt":"2022-07-09T17:22:20.000Z","updatedAt":"2022-07-09T17:22:20.000Z","Questions_Tags":{"questionId":228,"tagId":1544}}],"relatedQuestions":[{"title":"What are the nuances of scope prototypal / prototypical inheritance in AngularJS?","slug":"what-are-the-nuances-of-scope-prototypal-prototypical-inheritance-in-angularjs-1657387340067","tags":[{"name":"prototypal-inheritance","Questions_Tags":{"questionId":228,"tagId":1544}}]}]},"randomQuestions":[{"title":"Get top 1 row of each group","slug":"get-top-1-row-of-each-group-1657387438304"},{"title":"When to use LinkedList over ArrayList in Java?","slug":"when-to-use-linkedlist-over-arraylist-in-java-1657388107480"},{"title":"What is a clearfix?","slug":"what-is-a-clearfix-1657387337825"},{"title":"How do I detect a click outside an element?","slug":"how-do-i-detect-a-click-outside-an-element-1657387505351"},{"title":"How to fix java.lang.UnsupportedClassVersionError: Unsupported major.minor version","slug":"how-to-fix-java.lang.unsupportedclassversionerror:-unsupported-major.minor-version-1657384863422"},{"title":"Using regular expressions to parse HTML: why not?","slug":"using-regular-expressions-to-parse-html:-why-not-1657387543969"},{"title":"Asking the user for input until they give a valid response","slug":"asking-the-user-for-input-until-they-give-a-valid-response-1657384376162"},{"title":"What is the difference between == and equals() in Java?","slug":"what-is-the-difference-between-and-equals()-in-java-1657387729654"},{"title":"What is DOM Event delegation?","slug":"what-is-dom-event-delegation-1657387625599"},{"title":"How do I split a list into equally-sized chunks?","slug":"how-do-i-split-a-list-into-equally-sized-chunks-1657384580399"},{"title":"How to make good reproducible pandas examples","slug":"how-to-make-good-reproducible-pandas-examples-1657384310402"},{"title":"Learning Regular Expressions [closed]","slug":"learning-regular-expressions-closed-1657384719460"},{"title":"How can I access and process nested objects, arrays, or JSON?","slug":"how-can-i-access-and-process-nested-objects-arrays-or-json-1657384332823"},{"title":"Align inline-block DIVs to top of container element","slug":"align-inline-block-divs-to-top-of-container-element-1657387489610"},{"title":"event.preventDefault() vs. return false","slug":"event.preventdefault()-vs.-return-false-1657387458377"},{"title":"How do I revert a Git repository to a previous commit?","slug":"how-do-i-revert-a-git-repository-to-a-previous-commit-1657387714717"},{"title":"CSS selector for first element with class","slug":"css-selector-for-first-element-with-class-1657388028765"},{"title":"UTF-8 all the way through","slug":"utf-8-all-the-way-through-1657384323434"},{"title":"The useState set method is not reflecting a change immediately","slug":"the-usestate-set-method-is-not-reflecting-a-change-immediately-1657384524775"},{"title":"Disable same origin policy in Chrome","slug":"disable-same-origin-policy-in-chrome-1657387743804"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"what-are-the-nuances-of-scope-prototypal-prototypical-inheritance-in-angularjs-1657387340067"},"buildId":"XDXakEY6gSPdgAODPxtjg","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>