<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>Why do I get a segmentation fault when writing to a &quot;char *s&quot; initialized with a string literal, but not &quot;char s[]&quot;? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="The following code receives seg fault on line 2:

char *str = &quot;string&quot;;
str[0] = &#x27;z&#x27;;  // could be also written as *str = &#x27;z&#x27;
printf(&quot;%s\n&quot;, str);


While this works perfectly well:

char str[] = &quot;string&quot;;
str[0] = &#x27;z&#x27;;
printf(&quot;%s\n&quot;, str);


Tested with MSVC and GCC.
    "/><meta property="og:title" content="Why do I get a segmentation fault when writing to a &quot;char *s&quot; initialized with a string literal, but not &quot;char s[]&quot;? | Solutions Checker"/><meta property="og:description" content="The following code receives seg fault on line 2:

char *str = &quot;string&quot;;
str[0] = &#x27;z&#x27;;  // could be also written as *str = &#x27;z&#x27;
printf(&quot;%s\n&quot;, str);


While this works perfectly well:

char str[] = &quot;string&quot;;
str[0] = &#x27;z&#x27;;
printf(&quot;%s\n&quot;, str);


Tested with MSVC and GCC.
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Why do I get a segmentation fault when writing to a &quot;char *s&quot; initialized with a string literal, but not &quot;char s[]&quot;?","text":"The following code receives seg fault on line 2:\n\nchar *str = &quot;string&quot;;\nstr[0] = &apos;z&apos;;  // could be also written as *str = &apos;z&apos;\nprintf(&quot;%s\\n&quot;, str);\n\n\nWhile this works perfectly well:\n\nchar str[] = &quot;string&quot;;\nstr[0] = &apos;z&apos;;\nprintf(&quot;%s\\n&quot;, str);\n\n\nTested with MSVC and GCC.\n    ","answerCount":19,"upVoteCount":500,"suggestedAnswer":[{"text":"See the C FAQ, Question 1.32\n\n\n  Q: What is the difference between these initializations?\n  char a[] = &quot;string literal&quot;;\n  char *p  = &quot;string literal&quot;;\n  My program crashes if I try to assign a new value to p[i].\n  \n  A: A string literal (the formal term\n  for a double-quoted string in C\n  source) can be used in two slightly\n  different ways:\n  \n  \n  As the initializer for an array of char, as in the declaration of char a[] , it specifies the initial values\n  of the characters in that array (and,\n  if necessary, its size).\n  Anywhere else, it turns into an unnamed, static array of characters,\n  and this unnamed array may be stored\n  in read-only memory, and which\n  therefore cannot necessarily be\n  modified. In an expression context,\n  the array is converted at once to a\n  pointer, as usual (see section 6), so\n  the second declaration initializes p\n  to point to the unnamed array&apos;s first\n  element. \n  \n  \n  Some compilers have a switch\n  controlling whether string literals\n  are writable or not (for compiling old\n  code), and some may have options to\n  cause string literals to be formally\n  treated as arrays of const char (for\n  better error catching).\n\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"Normally, string literals are stored in read-only memory when the program is run. This is to prevent you from accidentally changing a string constant. In your first example, &quot;string&quot; is stored in read-only memory and *str points to the first character. The segfault happens when you try to change the first character to &apos;z&apos;.\n\nIn the second example, the string &quot;string&quot; is copied by the compiler from its read-only home to the str[] array. Then changing the first character is permitted. You can check this by printing the address of each:\n\nprintf(&quot;%p&quot;, str);\n\n\nAlso, printing the size of str in the second example will show you that the compiler has allocated 7 bytes for it:\n\nprintf(&quot;%d&quot;, sizeof(str));\n\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"Most of these answers are correct, but just to add a little more clarity...\n\nThe &quot;read only memory&quot; that people are referring to is the text segment in ASM terms. It&apos;s the same place in memory where the instructions are loaded. This is read-only for obvious reasons like security. When you create a char* initialized to a string, the string data is compiled into the text segment and the program initializes the pointer to point into the text segment. So if you try to change it, kaboom. Segfault.\n\nWhen written as an array, the compiler places the initialized string data in the data segment instead, which is the same place that your global variables and such live. This memory is mutable, since there are no instructions in the data segment. This time when the compiler initializes the character array (which is still just a char*) it&apos;s pointing into the data segment rather than the text segment, which you can safely alter at run-time.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"\n  Why do I get a segmentation fault when writing to a string?\n\n\nC99 N1256 draft\n\nThere are two different uses of character string literals:\n\n\nInitialize char[]:\n\nchar c[] = &quot;abc&quot;;      \n\n\nThis is &quot;more magic&quot;, and described at 6.7.8/14 &quot;Initialization&quot;:\n\n\n  An array of character type may be initialized by a character string literal, optionally\n  enclosed in braces. Successive characters of the character string literal (including the\n  terminating null character if there is room or if the array is of unknown size) initialize the\n  elements of the array.\n\n\nSo this is just a shortcut for:\n\nchar c[] = {&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;\\0&apos;};\n\n\nLike any other regular array, c can be modified.\nEverywhere else: it generates an:\n\n\nunnamed\narray of char What is the type of string literals in C and C++?\nwith static storage\nthat gives UB if modified\n\n\nSo when you write:\n\nchar *c = &quot;abc&quot;;\n\n\nThis is similar to:\n\n/* __unnamed is magic because modifying it gives UB. */\nstatic char __unnamed[] = &quot;abc&quot;;\nchar *c = __unnamed;\n\n\nNote the implicit cast from char[] to char *, which is always legal.\n\nThen if you modify c[0], you also modify __unnamed, which is UB.\n\nThis is documented at 6.4.5 &quot;String literals&quot;:\n\n\n  5 In translation phase 7, a byte or code of value zero is appended to each multibyte\n  character sequence that results from a string literal or literals. The multibyte character\n  sequence is then used to initialize an array of static storage duration and length just\n  sufficient to contain the sequence. For character string literals, the array elements have\n  type char, and are initialized with the individual bytes of the multibyte character\n  sequence [...]\n  \n  6 It is unspecified whether these arrays are distinct provided their elements have the\n  appropriate values. If the program attempts to modify such an array, the behavior is\n  undefined.\n\n\n\n6.7.8/32 &quot;Initialization&quot; gives a direct example:\n\n\n  EXAMPLE 8: The declaration\n\nchar s[] = &quot;abc&quot;, t[3] = &quot;abc&quot;;\n\n  \n  defines &quot;plain&quot; char array objects s and t whose elements are initialized with character string literals.\n  \n  This declaration is identical to\n\nchar s[] = { &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;\\0&apos; },\nt[] = { &apos;a&apos;, &apos;b&apos;, &apos;c&apos; };\n\n  \n  The contents of the arrays are modifiable. On the other hand, the declaration\n\nchar *p = &quot;abc&quot;;\n\n  \n  defines p with type &quot;pointer to char&quot; and initializes it to point to an object with type &quot;array of char&quot; with length 4 whose elements are initialized with a character string literal. If an attempt is made to use p to modify the contents of the array, the behavior is undefined.\n\n\nGCC 4.8 x86-64 ELF implementation\n\nProgram:\n\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char *s = &quot;abc&quot;;\n    printf(&quot;%s\\n&quot;, s);\n    return 0;\n}\n\n\nCompile and decompile:\n\ngcc -ggdb -std=c99 -c main.c\nobjdump -Sr main.o\n\n\nOutput contains:\n\n char *s = &quot;abc&quot;;\n8:  48 c7 45 f8 00 00 00    movq   $0x0,-0x8(%rbp)\nf:  00 \n        c: R_X86_64_32S .rodata\n\n\nConclusion: GCC stores char* it in .rodata section, not in .text.\n\nIf we do the same for char[]:\n\n char s[] = &quot;abc&quot;;\n\n\nwe obtain:\n\n17:   c7 45 f0 61 62 63 00    movl   $0x636261,-0x10(%rbp)\n\n\nso it gets stored in the stack (relative to %rbp).\n\nNote however that the default linker script puts .rodata and .text in the same segment, which has execute but no write permission. This can be observed with:\n\nreadelf -l a.out\n\n\nwhich contains:\n\n Section to Segment mapping:\n  Segment Sections...\n   02     .text .rodata\n\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"In the first code, &quot;string&quot; is a string constant, and string constants should never be modified because they are often placed into read only memory.  &quot;str&quot; is a pointer being used to modify the constant.\n\nIn the second code, &quot;string&quot; is an array initializer, sort of short hand for\n\nchar str[7] =  { &apos;s&apos;, &apos;t&apos;, &apos;r&apos;, &apos;i&apos;, &apos;n&apos;, &apos;g&apos;, &apos;\\0&apos; };\n\n\n&quot;str&quot; is an array allocated on the stack and can be modified freely.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"Because the type of &quot;whatever&quot; in the context of the 1st example is const char * (even if you assign it to a non-const char*), which means you shouldn&apos;t try and write to it.\n\nThe compiler has enforced this by putting the string in a read-only part of memory, hence writing to it generates a segfault.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"char *str = &quot;string&quot;;  \n\n\nThe above sets str to point to the literal value &quot;string&quot; which is hard-coded in the program&apos;s binary image, which is probably flagged as read-only in memory.  \n\nSo str[0]= is attempting to write to the read-only code of the application.  I would guess this is probably compiler dependent though.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"To understand this error or problem you should first know difference b/w the pointer and array\nso here firstly i have explain you differences b/w them\nstring array\n char strarray[] = &quot;hello&quot;;\n\nIn memory array is stored in continuous memory cells, stored as [h][e][l][l][o][\\0] =&gt;[] is 1 char byte size memory cell ,and this continuous memory cells can be access by name named strarray here.so here string array strarray itself containing all characters of string initialized to it.in this case here &quot;hello&quot;\nso we can easily change its memory content by accessing each character by its index value\n`strarray[0]=&apos;m&apos;` it access character at index 0 which is &apos;h&apos;in strarray\n\nand its value changed to &apos;m&apos; so strarray value changed to &quot;mello&quot;;\none point to note here that we can change the content of string array by changing character by character but can not initialized other string directly to it like strarray=&quot;new string&quot; is invalid\nPointer\nAs we all know  pointer points to memory location in memory ,\nuninitialized pointer points to random memory location so and after initialization points to particular memory location\nchar *ptr = &quot;hello&quot;;\n\nhere pointer ptr is initialized to string &quot;hello&quot; which is  constant string stored in read only memory (ROM) so &quot;hello&quot; can not be changed as it is stored in ROM\nand ptr is stored in stack section and pointing to constant string &quot;hello&quot;\nso ptr[0]=&apos;m&apos; is invalid since you can not access read only memory\nBut ptr can be initialised to other string value directly since it is just pointer so it can be point to any memory address of variable of its data type\nptr=&quot;new string&quot;; is valid\n\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"char *str = &quot;string&quot;;\n\n\nallocates a pointer to a string literal, which the compiler is putting in a non-modifiable part of your executable;\n\nchar str[] = &quot;string&quot;;\n\n\nallocates and initializes a local array which is modifiable\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"The C FAQ that @matli linked to mentions it, but no one else here has yet, so for clarification: if a string literal (double-quoted string in your source) is used anywhere other than to initialize a character array (ie: @Mark&apos;s second example, which works correctly), that string is stored by the compiler in a special static string table, which is akin to creating a global static variable (read-only, of course) that is essentially anonymous (has no variable &quot;name&quot;). The read-only part is the important part, and is why the @Mark&apos;s first code example segfaults.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"The \n\n char *str = &quot;string&quot;;\n\n\nline defines a pointer and points it to a literal string.  The literal string is not writable so when you do:\n\n  str[0] = &apos;z&apos;;\n\n\nyou get a seg fault.  On some platforms, the literal might be in writable memory so you won&apos;t see a segfault, but it&apos;s invalid code (resulting in undefined behavior) regardless.\n\nThe line:\n\nchar str[] = &quot;string&quot;;\n\n\nallocates an array of characters and copies the literal string into that array, which is fully writable, so the subsequent update is no problem.\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"String literals like &quot;string&quot; are probably allocated in your executable&apos;s address space as read-only data (give or take your compiler).  When you go to touch it, it freaks out that you&apos;re in its bathing suit area and lets you know with a seg fault.\n\nIn your first example, you&apos;re getting a pointer to that const data.  In your second example, you&apos;re initializing an array of 7 characters with a copy of the const data.\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"// create a string constant like this - will be read only\nchar *str_p;\nstr_p = &quot;String constant&quot;;\n\n// create an array of characters like this \nchar *arr_p;\nchar arr[] = &quot;String in an array&quot;;\narr_p = &amp;arr[0];\n\n// now we try to change a character in the array first, this will work\n*arr_p = &apos;E&apos;;\n\n// lets try to change the first character of the string contant\n*str_p = &apos;G&apos;; // this will result in a segmentation fault. Comment it out to work.\n\n\n/*-----------------------------------------------------------------------------\n *  String constants can&apos;t be modified. A segmentation fault is the result,\n *  because most operating systems will not allow a write\n *  operation on read only memory.\n *-----------------------------------------------------------------------------*/\n\n//print both strings to see if they have changed\nprintf(&quot;%s\\n&quot;, str_p); //print the string without a variable\nprintf(&quot;%s\\n&quot;, arr_p); //print the string, which is in an array. \n\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"In the first place, str is a pointer that points at &quot;string&quot;.  The compiler is allowed to put string literals in places in memory that you cannot write to, but can only read.  (This really should have triggered a warning, since you&apos;re assigning a const char * to a char *.  Did you have warnings disabled, or did you just ignore them?)\n\nIn the second place, you&apos;re creating an array, which is memory that you&apos;ve got full access to, and initializing it with &quot;string&quot;.  You&apos;re creating a char[7] (six for the letters, one for the terminating &apos;\\0&apos;), and you do whatever you like with it.\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"Assume the strings are,\n\nchar a[] = &quot;string literal copied to stack&quot;;\nchar *p  = &quot;string literal referenced by p&quot;;\n\n\nIn the first case, the literal is to be copied when &apos;a&apos; comes into scope. Here &apos;a&apos; is an array defined on stack. It means the string will be created on the stack and its data is copied from code (text) memory, which is typically read-only (this is implementation specific, a compiler can place this read-only program data in read-writable memory also).\n\nIn the second case, p is a pointer defined on stack (local scope) and referring a string literal (program data or text) stored else where. Usually modifying such memory is not good practice nor encouraged.\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"Constant memory\nSince string literals are read-only by design, they are stored in the Constant part of memory. Data stored there is immutable, i.e., cannot be changed. Thus, all string literals defined in C code get a read-only memory address here.\nStack memory\nThe Stack part of memory is where the addresses of local variables live, e.g., variables defined in functions.\n\nAs @matli&apos;s answer suggests, there are two ways of working with string these constant strings.\n1. Pointer to string literal\nWhen we define a pointer to a string literal, we are creating a pointer variable living in Stack memory. It points to the read-only address where the underlying string literal resides.\n#include &lt;stdio.h&gt;\n\nint main(void) {\n  char *s = &quot;hello&quot;;\n  printf(&quot;%p\\n&quot;, &amp;s);  // Prints a read-only address, e.g. 0x7ffc8e224620\n  return 0;\n}\n\nIf we try to modify s by inserting\ns[0] = &apos;H&apos;;\n\nwe get a Segmentation fault (core dumped). We are trying to access memory that we shouldn&apos;t access. We are attempting to modify the value of a read-only address, 0x7ffc8e224620.\n2. Array of chars\nFor the sake of the example, suppose the string literal &quot;Hello&quot; stored in constant memory has a read-only memory address identical to the one above, 0x7ffc8e224620.\n#include &lt;stdio.h&gt;\n\nint main(void) {\n  // We create an array from a string literal with address 0x7ffc8e224620.\n  // C initializes an array variable in the stack, let&apos;s give it address\n  // 0x7ffc7a9a9db2.\n  // C then copies the read-only value from 0x7ffc8e224620 into \n  // 0x7ffc7a9a9db2 to give us a local copy we can mutate.\n  char a[] = &quot;hello&quot;;\n\n  // We can now mutate the local copy\n  a[0] = &apos;H&apos;;\n\n  printf(&quot;%p\\n&quot;, &amp;a);  // Prints the Stack address, e.g. 0x7ffc7a9a9db2\n  printf(&quot;%s\\n&quot;, a);   // Prints &quot;Hello&quot;\n\n  return 0;\n}\n\n\n\nNote: When using pointers to string literals as in 1., best practice is to use the const keyword, like const *s = &quot;hello&quot;. This is more readable and the compiler will provide better help when it&apos;s violated. It will then throw an error like error: assignment of read-only location *s instead of the seg fault. Linters in editors will also likely pick up the error before you manually compile the code.\n\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"First is one constant string which can&apos;t be modified. Second is an array with initialized value, so it can be modified. \n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"Section 5.5 Character Pointers and Functions of K&amp;R also discusses about this topic:\n\nThere is an important difference between these definitions:\nchar amessage[] = &quot;now is the time&quot;; /* an array */\nchar *pmessage = &quot;now is the time&quot;; /* a pointer */\namessage is an array, just big enough to hold the sequence of characters and &apos;\\0&apos; that initializes it. Individual characters within the array may be changed but amessage will always refer to the same storage. On the other hand, pmessage is a pointer, initialized to point to a string constant; the pointer may subsequently be modified to point elsewhere, but the result is undefined if you try to modify the string contents.\n\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0},{"text":"Segmentation fault is caused when you try to access the memory which is inaccessible. \n\nchar *str is a pointer to a string that is nonmodifiable(the reason for getting segfault).\n\nwhereas char str[] is an array and can be modifiable..\n    ","url":"/questions/[slug]#solution19","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-b06815e21c943e0d.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-79a1437acf654019.js" defer=""></script><script src="/_next/static/6ctJfCympFH_chh5mjicD/_buildManifest.js" defer=""></script><script src="/_next/static/6ctJfCympFH_chh5mjicD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/why-do-i-get-a-segmentation-fault-when-writing-to-a-%22char-*s%22-initialized-with-a-string-literal-but-not-%22char-s%22-1657385511046#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/why-do-i-get-a-segmentation-fault-when-writing-to-a-%22char-*s%22-initialized-with-a-string-literal-but-not-%22char-s%22-1657385511046"><h1>Why do I get a segmentation fault when writing to a &quot;char *s&quot; initialized with a string literal, but not &quot;char s[]&quot;?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/segmentation-fault">segmentation-fault</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/c-strings">c-strings</a></div></div><div class="question-content mt-5">
                
<p>The following code receives seg fault on line 2:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *str = <span class="hljs-string">"string"</span>;
str[<span class="hljs-number">0</span>] = <span class="hljs-string">'z'</span>;  <span class="hljs-comment">// could be also written as *str = 'z'</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, str);
</code></pre>

<p>While this works perfectly well:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> str[] = <span class="hljs-string">"string"</span>;
str[<span class="hljs-number">0</span>] = <span class="hljs-string">'z'</span>;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, str);
</code></pre>

<p>Tested with MSVC and GCC.</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li><li class="pagination-solution-item"><span data-id="#solution19" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">19</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/segmentation-fault">segmentation-fault</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/c-strings">c-strings</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>See the C FAQ, <a href="http://c-faq.com/decl/strlitinit.html" rel="noreferrer">Question 1.32</a></p>

<blockquote>
  <p><strong>Q</strong>: What is the difference between these initializations?<br>
  <code>char a[] = "string literal";</code><br>
  <code>char *p  = "string literal";</code><br>
  My program crashes if I try to assign a new value to <code>p[i]</code>.</p>
  
  <p><strong>A</strong>: A string literal (the formal term
  for a double-quoted string in C
  source) can be used in two slightly
  different ways:</p>
  
  <ol>
  <li>As the initializer for an array of char, as in the declaration of <code>char a[]</code> , it specifies the initial values
  of the characters in that array (and,
  if necessary, its size).</li>
  <li>Anywhere else, it turns into an unnamed, static array of characters,
  and this unnamed array may be stored
  in read-only memory, and which
  therefore cannot necessarily be
  modified. In an expression context,
  the array is converted at once to a
  pointer, as usual (see section 6), so
  the second declaration initializes p
  to point to the unnamed array's first
  element. </li>
  </ol>
  
  <p>Some compilers have a switch
  controlling whether string literals
  are writable or not (for compiling old
  code), and some may have options to
  cause string literals to be formally
  treated as arrays of const char (for
  better error catching).</p>
</blockquote>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/segmentation-fault">segmentation-fault</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/c-strings">c-strings</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Normally, string literals are stored in read-only memory when the program is run. This is to prevent you from accidentally changing a string constant. In your first example, <code>"string"</code> is stored in read-only memory and <code>*str</code> points to the first character. The segfault happens when you try to change the first character to <code>'z'</code>.</p>

<p>In the second example, the string <code>"string"</code> is <em>copied</em> by the compiler from its read-only home to the <code>str[]</code> array. Then changing the first character is permitted. You can check this by printing the address of each:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%p"</span>, str);
</code></pre>

<p>Also, printing the size of <code>str</code> in the second example will show you that the compiler has allocated 7 bytes for it:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, <span class="hljs-keyword">sizeof</span>(str));
</code></pre>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/segmentation-fault">segmentation-fault</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/c-strings">c-strings</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Most of these answers are correct, but just to add a little more clarity...</p>

<p>The "read only memory" that people are referring to is the text segment in ASM terms. It's the same place in memory where the instructions are loaded. This is read-only for obvious reasons like security. When you create a char* initialized to a string, the string data is compiled into the text segment and the program initializes the pointer to point into the text segment. So if you try to change it, kaboom. Segfault.</p>

<p>When written as an array, the compiler places the initialized string data in the data segment instead, which is the same place that your global variables and such live. This memory is mutable, since there are no instructions in the data segment. This time when the compiler initializes the character array (which is still just a char*) it's pointing into the data segment rather than the text segment, which you can safely alter at run-time.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/segmentation-fault">segmentation-fault</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/c-strings">c-strings</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<blockquote>
  <p>Why do I get a segmentation fault when writing to a string?</p>
</blockquote>

<p><strong>C99 N1256 draft</strong></p>

<p>There are two different uses of character string literals:</p>

<ol>
<li><p>Initialize <code>char[]</code>:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> c[] = <span class="hljs-string">"abc"</span>;      
</code></pre>

<p>This is "more magic", and described at 6.7.8/14 "Initialization":</p>

<blockquote>
  <p>An array of character type may be initialized by a character string literal, optionally
  enclosed in braces. Successive characters of the character string literal (including the
  terminating null character if there is room or if the array is of unknown size) initialize the
  elements of the array.</p>
</blockquote>

<p>So this is just a shortcut for:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> c[] = {<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'\0'</span>};
</code></pre>

<p>Like any other regular array, <code>c</code> can be modified.</p></li>
<li><p>Everywhere else: it generates an:</p>

<ul>
<li>unnamed</li>
<li>array of char <a href="https://stackoverflow.com/questions/2245664/what-is-the-type-of-string-literals-in-c-c">What is the type of string literals in C and C++?</a></li>
<li>with static storage</li>
<li>that gives UB if modified</li>
</ul>

<p>So when you write:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *c = <span class="hljs-string">"abc"</span>;
</code></pre>

<p>This is similar to:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-comment">/* __unnamed is magic because modifying it gives UB. */</span>
<span class="hljs-type">static</span> <span class="hljs-type">char</span> __unnamed[] = <span class="hljs-string">"abc"</span>;
<span class="hljs-type">char</span> *c = __unnamed;
</code></pre>

<p>Note the implicit cast from <code>char[]</code> to <code>char *</code>, which is always legal.</p>

<p>Then if you modify <code>c[0]</code>, you also modify <code>__unnamed</code>, which is UB.</p>

<p>This is documented at 6.4.5 "String literals":</p>

<blockquote>
  <p>5 In translation phase 7, a byte or code of value zero is appended to each multibyte
  character sequence that results from a string literal or literals. The multibyte character
  sequence is then used to initialize an array of static storage duration and length just
  sufficient to contain the sequence. For character string literals, the array elements have
  type char, and are initialized with the individual bytes of the multibyte character
  sequence [...]</p>
  
  <p>6 It is unspecified whether these arrays are distinct provided their elements have the
  appropriate values. If the program attempts to modify such an array, the behavior is
  undefined.</p>
</blockquote></li>
</ol>

<p>6.7.8/32 "Initialization" gives a direct example:</p>

<blockquote>
  <p>EXAMPLE 8: The declaration</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> s[] = <span class="hljs-string">"abc"</span>, t[<span class="hljs-number">3</span>] = <span class="hljs-string">"abc"</span>;
</code></pre>
  
  <p>defines "plain" char array objects <code>s</code> and <code>t</code> whose elements are initialized with character string literals.</p>
  
  <p>This declaration is identical to</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> s[] = { <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'\0'</span> },
t[] = { <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span> };
</code></pre>
  
  <p>The contents of the arrays are modifiable. On the other hand, the declaration</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *p = <span class="hljs-string">"abc"</span>;
</code></pre>
  
  <p>defines <code>p</code> with type "pointer to char" and initializes it to point to an object with type "array of char" with length 4 whose elements are initialized with a character string literal. If an attempt is made to use <code>p</code> to modify the contents of the array, the behavior is undefined.</p>
</blockquote>

<p><strong>GCC 4.8 x86-64 ELF implementation</strong></p>

<p>Program:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> {
    <span class="hljs-type">char</span> *s = <span class="hljs-string">"abc"</span>;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, s);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>Compile and decompile:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">gcc -ggdb -<span class="hljs-built_in">std</span>=c99 -c main.c
objdump -Sr main.o
</code></pre>

<p>Output contains:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"> <span class="hljs-type">char</span> *s = <span class="hljs-string">"abc"</span>;
<span class="hljs-number">8</span>:  <span class="hljs-number">48</span> c7 <span class="hljs-number">45</span> f8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    movq   $<span class="hljs-number">0x0</span>,<span class="hljs-number">-0x8</span>(%rbp)
f:  <span class="hljs-number">00</span> 
        c: R_X86_64_32S .rodata
</code></pre>

<p>Conclusion: GCC stores <code>char*</code> it in <code>.rodata</code> section, not in <code>.text</code>.</p>

<p>If we do the same for <code>char[]</code>:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"> <span class="hljs-type">char</span> s[] = <span class="hljs-string">"abc"</span>;
</code></pre>

<p>we obtain:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-number">17</span>:   c7 <span class="hljs-number">45</span> f0 <span class="hljs-number">61</span> <span class="hljs-number">62</span> <span class="hljs-number">63</span> <span class="hljs-number">00</span>    movl   $<span class="hljs-number">0x636261</span>,<span class="hljs-number">-0x10</span>(%rbp)
</code></pre>

<p>so it gets stored in the stack (relative to <code>%rbp</code>).</p>

<p>Note however that the default linker script puts <code>.rodata</code> and <code>.text</code> in the same segment, which has execute but no write permission. This can be observed with:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">readelf -l a.out
</code></pre>

<p>which contains:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"> Section to Segment mapping:
  Segment Sections...
   <span class="hljs-number">02</span>     .text .rodata
</code></pre>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/segmentation-fault">segmentation-fault</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/c-strings">c-strings</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In the first code, "string" is a string constant, and string constants should never be modified because they are often placed into read only memory.  "str" is a pointer being used to modify the constant.</p>

<p>In the second code, "string" is an array initializer, sort of short hand for</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> str[<span class="hljs-number">7</span>] =  { <span class="hljs-string">'s'</span>, <span class="hljs-string">'t'</span>, <span class="hljs-string">'r'</span>, <span class="hljs-string">'i'</span>, <span class="hljs-string">'n'</span>, <span class="hljs-string">'g'</span>, <span class="hljs-string">'\0'</span> };
</code></pre>

<p>"str" is an array allocated on the stack and can be modified freely.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/segmentation-fault">segmentation-fault</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/c-strings">c-strings</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Because the type of <code>"whatever"</code> in the context of the 1st example is <code>const char *</code> (even if you assign it to a non-const char*), which means you shouldn't try and write to it.</p>

<p>The compiler has enforced this by putting the string in a read-only part of memory, hence writing to it generates a segfault.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/segmentation-fault">segmentation-fault</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/c-strings">c-strings</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *str = <span class="hljs-string">"string"</span>;  
</code></pre>

<p>The above sets <code>str</code> to point to the literal value <code>"string"</code> which is hard-coded in the program's binary image, which is probably flagged as read-only in memory.  </p>

<p>So <code>str[0]=</code> is attempting to write to the read-only code of the application.  I would guess this is probably compiler dependent though.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/segmentation-fault">segmentation-fault</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/c-strings">c-strings</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>To understand this error or problem you should first know difference b/w the pointer and array
so here firstly i have explain you differences b/w them</p>
<h3>string array</h3>
<pre class="lang-c s-code-block"><code class="hljs language-c"> <span class="hljs-type">char</span> strarray[] = <span class="hljs-string">"hello"</span>;
</code></pre>
<p>In memory array is stored in continuous memory cells, stored as <code>[h][e][l][l][o][\0] =&gt;[]</code> is 1 char byte size memory cell ,and this continuous memory cells can be access by name named strarray here.so here string array <code>strarray</code> itself containing all characters of string initialized to it.in this case here <code>"hello"</code>
so we can easily change its memory content by accessing each character by its index value</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">`strarray[<span class="hljs-number">0</span>]=<span class="hljs-string">'m'</span>` it access character at index <span class="hljs-number">0</span> which is <span class="hljs-string">'h'</span>in strarray
</code></pre>
<p>and its value changed to <code>'m'</code> so strarray value changed to <code>"mello"</code>;</p>
<p>one point to note here that we can change the content of string array by changing character by character but can not initialized other string directly to it like <code>strarray="new string"</code> is invalid</p>
<h3>Pointer</h3>
<p>As we all know  pointer points to memory location in memory ,
uninitialized pointer points to random memory location so and after initialization points to particular memory location</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *ptr = <span class="hljs-string">"hello"</span>;
</code></pre>
<p>here pointer ptr is initialized to string <code>"hello"</code> which is  constant string stored in read only memory (ROM) so <code>"hello"</code> can not be changed as it is stored in ROM</p>
<p>and ptr is stored in stack section and pointing to constant string <code>"hello"</code></p>
<p>so ptr[0]='m' is invalid since you can not access read only memory</p>
<p>But ptr can be initialised to other string value directly since it is just pointer so it can be point to any memory address of variable of its data type</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">ptr=<span class="hljs-string">"new string"</span>; is valid
</code></pre>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/segmentation-fault">segmentation-fault</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/c-strings">c-strings</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *str = <span class="hljs-string">"string"</span>;
</code></pre>

<p>allocates a pointer to a string literal, which the compiler is putting in a non-modifiable part of your executable;</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> str[] = <span class="hljs-string">"string"</span>;
</code></pre>

<p>allocates and initializes a local array which is modifiable</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/segmentation-fault">segmentation-fault</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/c-strings">c-strings</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The C FAQ that @matli linked to mentions it, but no one else here has yet, so for clarification: if a string literal (double-quoted string in your source) is used anywhere <em>other than</em> to initialize a character array (ie: @Mark's second example, which works correctly), that string is stored by the compiler in a special <em>static string table</em>, which is akin to creating a global static variable (read-only, of course) that is essentially anonymous (has no variable "name"). The <em>read-only</em> part is the important part, and is why the @Mark's first code example segfaults.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/segmentation-fault">segmentation-fault</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/c-strings">c-strings</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The </p>

<pre class="lang-c s-code-block"><code class="hljs language-c"> <span class="hljs-type">char</span> *str = <span class="hljs-string">"string"</span>;
</code></pre>

<p>line defines a pointer and points it to a literal string.  The literal string is not writable so when you do:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">  str[<span class="hljs-number">0</span>] = <span class="hljs-string">'z'</span>;
</code></pre>

<p>you get a seg fault.  On some platforms, the literal might be in writable memory so you won't see a segfault, but it's invalid code (resulting in undefined behavior) regardless.</p>

<p>The line:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> str[] = <span class="hljs-string">"string"</span>;
</code></pre>

<p>allocates an array of characters and <strong>copies</strong> the literal string into that array, which is fully writable, so the subsequent update is no problem.</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/segmentation-fault">segmentation-fault</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/c-strings">c-strings</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>String literals like "string" are probably allocated in your executable's address space as read-only data (give or take your compiler).  When you go to touch it, it freaks out that you're in its bathing suit area and lets you know with a seg fault.</p>

<p>In your first example, you're getting a pointer to that const data.  In your second example, you're initializing an array of 7 characters with a copy of the const data.</p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/segmentation-fault">segmentation-fault</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/c-strings">c-strings</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-comment">// create a string constant like this - will be read only</span>
<span class="hljs-type">char</span> *str_p;
str_p = <span class="hljs-string">"String constant"</span>;

<span class="hljs-comment">// create an array of characters like this </span>
<span class="hljs-type">char</span> *arr_p;
<span class="hljs-type">char</span> arr[] = <span class="hljs-string">"String in an array"</span>;
arr_p = &amp;arr[<span class="hljs-number">0</span>];

<span class="hljs-comment">// now we try to change a character in the array first, this will work</span>
*arr_p = <span class="hljs-string">'E'</span>;

<span class="hljs-comment">// lets try to change the first character of the string contant</span>
*str_p = <span class="hljs-string">'G'</span>; <span class="hljs-comment">// this will result in a segmentation fault. Comment it out to work.</span>


<span class="hljs-comment">/*-----------------------------------------------------------------------------
 *  String constants can't be modified. A segmentation fault is the result,
 *  because most operating systems will not allow a write
 *  operation on read only memory.
 *-----------------------------------------------------------------------------*/</span>

<span class="hljs-comment">//print both strings to see if they have changed</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, str_p); <span class="hljs-comment">//print the string without a variable</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, arr_p); <span class="hljs-comment">//print the string, which is in an array. </span>
</code></pre>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/segmentation-fault">segmentation-fault</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/c-strings">c-strings</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In the first place, <code>str</code> is a pointer that points at <code>"string"</code>.  The compiler is allowed to put string literals in places in memory that you cannot write to, but can only read.  (This really should have triggered a warning, since you're assigning a <code>const char *</code> to a <code>char *</code>.  Did you have warnings disabled, or did you just ignore them?)</p>

<p>In the second place, you're creating an array, which is memory that you've got full access to, and initializing it with <code>"string"</code>.  You're creating a <code>char[7]</code> (six for the letters, one for the terminating '\0'), and you do whatever you like with it.</p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/segmentation-fault">segmentation-fault</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/c-strings">c-strings</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Assume the strings are,</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> a[] = <span class="hljs-string">"string literal copied to stack"</span>;
<span class="hljs-type">char</span> *p  = <span class="hljs-string">"string literal referenced by p"</span>;
</code></pre>

<p>In the first case, the literal is to be copied when 'a' comes into scope. Here 'a' is an array defined on stack. It means the string will be created on the stack and its data is copied from code (text) memory, which is typically read-only (this is implementation specific, a compiler can place this read-only program data in read-writable memory also).</p>

<p>In the second case, p is a pointer defined on stack (local scope) and referring a string literal (program data or text) stored else where. Usually modifying such memory is not good practice nor encouraged.</p>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/segmentation-fault">segmentation-fault</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/c-strings">c-strings</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h3>Constant memory</h3>
<p>Since string literals are read-only by design, they are stored in the <strong>Constant part</strong> of memory. Data stored there is immutable, i.e., cannot be changed. Thus, all string literals defined in C code get a read-only memory address here.</p>
<h3>Stack memory</h3>
<p>The <strong>Stack part</strong> of memory is where the addresses of local variables live, e.g., variables defined in functions.</p>
<hr>
<p>As @matli's answer suggests, there are two ways of working with string these constant strings.</p>
<h3>1. Pointer to string literal</h3>
<p>When we define a pointer to a string literal, we are creating a pointer variable living in <strong>Stack memory</strong>. It points to the read-only address where the underlying string literal resides.</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> {
  <span class="hljs-type">char</span> *s = <span class="hljs-string">"hello"</span>;
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%p\n"</span>, &amp;s);  <span class="hljs-comment">// Prints a read-only address, e.g. 0x7ffc8e224620</span>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>If we try to modify <code>s</code> by inserting</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">s[<span class="hljs-number">0</span>] = <span class="hljs-string">'H'</span>;
</code></pre>
<p>we get a <code>Segmentation fault (core dumped)</code>. We are trying to access memory that we shouldn't access. We are attempting to modify the value of a read-only address, <code>0x7ffc8e224620</code>.</p>
<h3>2. Array of chars</h3>
<p>For the sake of the example, suppose the string literal <code>"Hello"</code> stored in constant memory has a read-only memory address identical to the one above, <code>0x7ffc8e224620</code>.</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> {
  <span class="hljs-comment">// We create an array from a string literal with address 0x7ffc8e224620.</span>
  <span class="hljs-comment">// C initializes an array variable in the stack, let's give it address</span>
  <span class="hljs-comment">// 0x7ffc7a9a9db2.</span>
  <span class="hljs-comment">// C then copies the read-only value from 0x7ffc8e224620 into </span>
  <span class="hljs-comment">// 0x7ffc7a9a9db2 to give us a local copy we can mutate.</span>
  <span class="hljs-type">char</span> a[] = <span class="hljs-string">"hello"</span>;

  <span class="hljs-comment">// We can now mutate the local copy</span>
  a[<span class="hljs-number">0</span>] = <span class="hljs-string">'H'</span>;

  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%p\n"</span>, &amp;a);  <span class="hljs-comment">// Prints the Stack address, e.g. 0x7ffc7a9a9db2</span>
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, a);   <span class="hljs-comment">// Prints "Hello"</span>

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<hr>
<blockquote>
<p><strong>Note:</strong> When using pointers to string literals as in 1., best practice is to use the <code>const</code> keyword, like <code>const *s = "hello"</code>. This is more readable and the compiler will provide better help when it's violated. It will then throw an error like <code>error: assignment of read-only location *s</code> instead of the seg fault. Linters in editors will also likely pick up the error before you manually compile the code.</p>
</blockquote>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/segmentation-fault">segmentation-fault</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/c-strings">c-strings</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>First is one constant string which can't be modified. Second is an array with initialized value, so it can be modified. </p>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 18</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/segmentation-fault">segmentation-fault</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/c-strings">c-strings</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><code>Section 5.5 Character Pointers and Functions</code> of <code>K&amp;R</code> also discusses about this topic:</p>
<blockquote>
<p>There is an important difference between these definitions:</p>
<p><code>char amessage[] = "now is the time"; /* an array */</code><br>
<code>char *pmessage = "now is the time"; /* a pointer */</code></p>
<p><code>amessage</code> is an array, just big enough to hold the sequence of characters and <code>'\0'</code> that initializes it. Individual characters within the array may be changed but <code>amessage</code> will always refer to the same storage. On the other hand, <code>pmessage</code> is a pointer, initialized to point to a string constant; the pointer may subsequently be modified to point elsewhere, but the result is undefined if you try to modify the string contents.</p>
</blockquote>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 19</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/segmentation-fault">segmentation-fault</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/c-strings">c-strings</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Segmentation fault is caused when you try to access the memory which is inaccessible. </p>

<p><code>char *str</code> is a pointer to a string that is nonmodifiable(the reason for getting segfault).</p>

<p>whereas <code>char str[]</code> is an array and can be modifiable..</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/can-you-provide-some-examples-of-why-it-is-hard-to-parse-xml-and-html-with-a-regex-closed-1657388410824">Can you provide some examples of why it is hard to parse XML and HTML with a regex? [closed]</a><a href="/questions/creating-multiline-strings-in-javascript-1657388025414">Creating multiline strings in JavaScript</a><a href="/questions/asking-the-user-for-input-until-they-give-a-valid-response-1657384376162">Asking the user for input until they give a valid response</a><a href="/questions/find-object-by-id-in-an-array-of-javascript-objects-1657387572087">Find object by id in an array of JavaScript objects</a><a href="/questions/addeventlistener-vs-onclick-1657388191429">addEventListener vs onclick</a><a href="/questions/what-is-the-difference-between-include-lessfilenamegreater-and-include-%22filename%22-1657388489547">What is the difference between #include &lt;filename&gt; and #include &quot;filename&quot;?</a><a href="/questions/reshaping-data.frame-from-wide-to-long-format-1657384678522">Reshaping data.frame from wide to long format</a><a href="/questions/random-number-generator-only-generating-one-random-number-1657385468315">Random number generator only generating one random number</a><a href="/questions/removing-duplicates-in-lists-1657388207448">Removing duplicates in lists</a><a href="/questions/what-does-**-(double-starasterisk)-and-*-(starasterisk)-do-for-parameters-1657384800967">What does ** (double star/asterisk) and * (star/asterisk) do for parameters?</a><a href="/questions/how-to-find-the-&#x27;sizeof&#x27;-(a-pointer-pointing-to-an-array)-1657387354284">How to find the &#x27;sizeof&#x27; (a pointer pointing to an array)?</a><a href="/questions/storing-images-in-db-yea-or-nay-1657387248067">Storing Images in DB - Yea or Nay?</a><a href="/questions/how-can-i-do-a-full-outer-join-in-mysql-1657388175444">How can I do a FULL OUTER JOIN in MySQL?</a><a href="/questions/error-in-finding-last-used-cell-in-excel-with-vba-1657384584748">Error in finding last used cell in Excel with VBA</a><a href="/questions/sending-email-in-android-using-javamail-api-without-using-the-defaultbuilt-in-app-1657387883400">Sending Email in Android using JavaMail API without using the default/built-in app</a><a href="/questions/dynamically-select-data-frame-columns-using-dollar-and-a-character-value-1657387836662">Dynamically select data frame columns using $ and a character value</a><a href="/questions/what-is-the-difference-between-client-side-and-server-side-programming-1657384372926">What is the difference between client-side and server-side programming?</a><a href="/questions/get-top-1-row-of-each-group-1657387438304">Get top 1 row of each group</a><a href="/questions/convert-columns-into-rows-with-pandas-1657388374964">Convert columns into rows with Pandas</a><a href="/questions/why-don&#x27;t-flex-items-shrink-past-content-size-1657384687282">Why don&#x27;t flex items shrink past content size?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;See the C FAQ, \u0026lt;a href=\u0026quot;http://c-faq.com/decl/strlitinit.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Question 1.32\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Q\u0026lt;/strong\u0026gt;: What is the difference between these initializations?\u0026lt;br\u0026gt;\n  \u0026lt;code\u0026gt;char a[] = \u0026quot;string literal\u0026quot;;\u0026lt;/code\u0026gt;\u0026lt;br\u0026gt;\n  \u0026lt;code\u0026gt;char *p  = \u0026quot;string literal\u0026quot;;\u0026lt;/code\u0026gt;\u0026lt;br\u0026gt;\n  My program crashes if I try to assign a new value to \u0026lt;code\u0026gt;p[i]\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;A\u0026lt;/strong\u0026gt;: A string literal (the formal term\n  for a double-quoted string in C\n  source) can be used in two slightly\n  different ways:\u0026lt;/p\u0026gt;\n  \n  \u0026lt;ol\u0026gt;\n  \u0026lt;li\u0026gt;As the initializer for an array of char, as in the declaration of \u0026lt;code\u0026gt;char a[]\u0026lt;/code\u0026gt; , it specifies the initial values\n  of the characters in that array (and,\n  if necessary, its size).\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;Anywhere else, it turns into an unnamed, static array of characters,\n  and this unnamed array may be stored\n  in read-only memory, and which\n  therefore cannot necessarily be\n  modified. In an expression context,\n  the array is converted at once to a\n  pointer, as usual (see section 6), so\n  the second declaration initializes p\n  to point to the unnamed array\u0026apos;s first\n  element. \u0026lt;/li\u0026gt;\n  \u0026lt;/ol\u0026gt;\n  \n  \u0026lt;p\u0026gt;Some compilers have a switch\n  controlling whether string literals\n  are writable or not (for compiling old\n  code), and some may have options to\n  cause string literals to be formally\n  treated as arrays of const char (for\n  better error catching).\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Normally, string literals are stored in read-only memory when the program is run. This is to prevent you from accidentally changing a string constant. In your first example, \u0026lt;code\u0026gt;\u0026quot;string\u0026quot;\u0026lt;/code\u0026gt; is stored in read-only memory and \u0026lt;code\u0026gt;*str\u0026lt;/code\u0026gt; points to the first character. The segfault happens when you try to change the first character to \u0026lt;code\u0026gt;\u0026apos;z\u0026apos;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In the second example, the string \u0026lt;code\u0026gt;\u0026quot;string\u0026quot;\u0026lt;/code\u0026gt; is \u0026lt;em\u0026gt;copied\u0026lt;/em\u0026gt; by the compiler from its read-only home to the \u0026lt;code\u0026gt;str[]\u0026lt;/code\u0026gt; array. Then changing the first character is permitted. You can check this by printing the address of each:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%p\u0026quot;\u0026lt;/span\u0026gt;, str);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Also, printing the size of \u0026lt;code\u0026gt;str\u0026lt;/code\u0026gt; in the second example will show you that the compiler has allocated 7 bytes for it:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(str));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Most of these answers are correct, but just to add a little more clarity...\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026quot;read only memory\u0026quot; that people are referring to is the text segment in ASM terms. It\u0026apos;s the same place in memory where the instructions are loaded. This is read-only for obvious reasons like security. When you create a char* initialized to a string, the string data is compiled into the text segment and the program initializes the pointer to point into the text segment. So if you try to change it, kaboom. Segfault.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When written as an array, the compiler places the initialized string data in the data segment instead, which is the same place that your global variables and such live. This memory is mutable, since there are no instructions in the data segment. This time when the compiler initializes the character array (which is still just a char*) it\u0026apos;s pointing into the data segment rather than the text segment, which you can safely alter at run-time.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Why do I get a segmentation fault when writing to a string?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;C99 N1256 draft\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There are two different uses of character string literals:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Initialize \u0026lt;code\u0026gt;char[]\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; c[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;      \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This is \u0026quot;more magic\u0026quot;, and described at 6.7.8/14 \u0026quot;Initialization\u0026quot;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;An array of character type may be initialized by a character string literal, optionally\n  enclosed in braces. Successive characters of the character string literal (including the\n  terminating null character if there is room or if the array is of unknown size) initialize the\n  elements of the array.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;So this is just a shortcut for:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; c[] = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Like any other regular array, \u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt; can be modified.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Everywhere else: it generates an:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;unnamed\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;array of char \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/2245664/what-is-the-type-of-string-literals-in-c-c\u0026quot;\u0026gt;What is the type of string literals in C and C++?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;with static storage\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;that gives UB if modified\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;So when you write:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *c = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This is similar to:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* __unnamed is magic because modifying it gives UB. */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; __unnamed[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *c = __unnamed;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note the implicit cast from \u0026lt;code\u0026gt;char[]\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;char *\u0026lt;/code\u0026gt;, which is always legal.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Then if you modify \u0026lt;code\u0026gt;c[0]\u0026lt;/code\u0026gt;, you also modify \u0026lt;code\u0026gt;__unnamed\u0026lt;/code\u0026gt;, which is UB.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is documented at 6.4.5 \u0026quot;String literals\u0026quot;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;5 In translation phase 7, a byte or code of value zero is appended to each multibyte\n  character sequence that results from a string literal or literals. The multibyte character\n  sequence is then used to initialize an array of static storage duration and length just\n  sufficient to contain the sequence. For character string literals, the array elements have\n  type char, and are initialized with the individual bytes of the multibyte character\n  sequence [...]\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;6 It is unspecified whether these arrays are distinct provided their elements have the\n  appropriate values. If the program attempts to modify such an array, the behavior is\n  undefined.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;6.7.8/32 \u0026quot;Initialization\u0026quot; gives a direct example:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;EXAMPLE 8: The declaration\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;, t[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n  \n  \u0026lt;p\u0026gt;defines \u0026quot;plain\u0026quot; char array objects \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;t\u0026lt;/code\u0026gt; whose elements are initialized with character string literals.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;This declaration is identical to\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[] = { \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt; },\nt[] = { \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt; };\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n  \n  \u0026lt;p\u0026gt;The contents of the arrays are modifiable. On the other hand, the declaration\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *p = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n  \n  \u0026lt;p\u0026gt;defines \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt; with type \u0026quot;pointer to char\u0026quot; and initializes it to point to an object with type \u0026quot;array of char\u0026quot; with length 4 whose elements are initialized with a character string literal. If an attempt is made to use \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt; to modify the contents of the array, the behavior is undefined.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;GCC 4.8 x86-64 ELF implementation\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Program:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%s\\n\u0026quot;\u0026lt;/span\u0026gt;, s);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Compile and decompile:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;gcc -ggdb -\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;=c99 -c main.c\nobjdump -Sr main.o\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Output contains:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;:  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;48\u0026lt;/span\u0026gt; c7 \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;45\u0026lt;/span\u0026gt; f8 \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt;    movq   $\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-0x8\u0026lt;/span\u0026gt;(%rbp)\nf:  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt; \n        c: R_X86_64_32S .rodata\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Conclusion: GCC stores \u0026lt;code\u0026gt;char*\u0026lt;/code\u0026gt; it in \u0026lt;code\u0026gt;.rodata\u0026lt;/code\u0026gt; section, not in \u0026lt;code\u0026gt;.text\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If we do the same for \u0026lt;code\u0026gt;char[]\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; s[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;we obtain:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;17\u0026lt;/span\u0026gt;:   c7 \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;45\u0026lt;/span\u0026gt; f0 \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;61\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;62\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;63\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt;    movl   $\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x636261\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-0x10\u0026lt;/span\u0026gt;(%rbp)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;so it gets stored in the stack (relative to \u0026lt;code\u0026gt;%rbp\u0026lt;/code\u0026gt;).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note however that the default linker script puts \u0026lt;code\u0026gt;.rodata\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;.text\u0026lt;/code\u0026gt; in the same segment, which has execute but no write permission. This can be observed with:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;readelf -l a.out\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;which contains:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt; Section to Segment mapping:\n  Segment Sections...\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;02\u0026lt;/span\u0026gt;     .text .rodata\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In the first code, \u0026quot;string\u0026quot; is a string constant, and string constants should never be modified because they are often placed into read only memory.  \u0026quot;str\u0026quot; is a pointer being used to modify the constant.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In the second code, \u0026quot;string\u0026quot; is an array initializer, sort of short hand for\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; str[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;] =  { \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;s\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;t\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;r\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;i\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;n\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;g\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt; };\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026quot;str\u0026quot; is an array allocated on the stack and can be modified freely.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Because the type of \u0026lt;code\u0026gt;\u0026quot;whatever\u0026quot;\u0026lt;/code\u0026gt; in the context of the 1st example is \u0026lt;code\u0026gt;const char *\u0026lt;/code\u0026gt; (even if you assign it to a non-const char*), which means you shouldn\u0026apos;t try and write to it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The compiler has enforced this by putting the string in a read-only part of memory, hence writing to it generates a segfault.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *str = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;string\u0026quot;\u0026lt;/span\u0026gt;;  \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The above sets \u0026lt;code\u0026gt;str\u0026lt;/code\u0026gt; to point to the literal value \u0026lt;code\u0026gt;\u0026quot;string\u0026quot;\u0026lt;/code\u0026gt; which is hard-coded in the program\u0026apos;s binary image, which is probably flagged as read-only in memory.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So \u0026lt;code\u0026gt;str[0]=\u0026lt;/code\u0026gt; is attempting to write to the read-only code of the application.  I would guess this is probably compiler dependent though.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;To understand this error or problem you should first know difference b/w the pointer and array\nso here firstly i have explain you differences b/w them\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;string array\u0026lt;/h3\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; strarray[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In memory array is stored in continuous memory cells, stored as \u0026lt;code\u0026gt;[h][e][l][l][o][\\0] =\u0026amp;gt;[]\u0026lt;/code\u0026gt; is 1 char byte size memory cell ,and this continuous memory cells can be access by name named strarray here.so here string array \u0026lt;code\u0026gt;strarray\u0026lt;/code\u0026gt; itself containing all characters of string initialized to it.in this case here \u0026lt;code\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/code\u0026gt;\nso we can easily change its memory content by accessing each character by its index value\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;`strarray[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;m\u0026apos;\u0026lt;/span\u0026gt;` it access character at index \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; which is \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;h\u0026apos;\u0026lt;/span\u0026gt;in strarray\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;and its value changed to \u0026lt;code\u0026gt;\u0026apos;m\u0026apos;\u0026lt;/code\u0026gt; so strarray value changed to \u0026lt;code\u0026gt;\u0026quot;mello\u0026quot;\u0026lt;/code\u0026gt;;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;one point to note here that we can change the content of string array by changing character by character but can not initialized other string directly to it like \u0026lt;code\u0026gt;strarray=\u0026quot;new string\u0026quot;\u0026lt;/code\u0026gt; is invalid\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Pointer\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;As we all know  pointer points to memory location in memory ,\nuninitialized pointer points to random memory location so and after initialization points to particular memory location\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *ptr = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;here pointer ptr is initialized to string \u0026lt;code\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/code\u0026gt; which is  constant string stored in read only memory (ROM) so \u0026lt;code\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/code\u0026gt; can not be changed as it is stored in ROM\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;and ptr is stored in stack section and pointing to constant string \u0026lt;code\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;so ptr[0]=\u0026apos;m\u0026apos; is invalid since you can not access read only memory\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;But ptr can be initialised to other string value directly since it is just pointer so it can be point to any memory address of variable of its data type\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;ptr=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;new string\u0026quot;\u0026lt;/span\u0026gt;; is valid\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *str = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;string\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;allocates a pointer to a string literal, which the compiler is putting in a non-modifiable part of your executable;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; str[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;string\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;allocates and initializes a local array which is modifiable\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The C FAQ that @matli linked to mentions it, but no one else here has yet, so for clarification: if a string literal (double-quoted string in your source) is used anywhere \u0026lt;em\u0026gt;other than\u0026lt;/em\u0026gt; to initialize a character array (ie: @Mark\u0026apos;s second example, which works correctly), that string is stored by the compiler in a special \u0026lt;em\u0026gt;static string table\u0026lt;/em\u0026gt;, which is akin to creating a global static variable (read-only, of course) that is essentially anonymous (has no variable \u0026quot;name\u0026quot;). The \u0026lt;em\u0026gt;read-only\u0026lt;/em\u0026gt; part is the important part, and is why the @Mark\u0026apos;s first code example segfaults.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *str = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;string\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;line defines a pointer and points it to a literal string.  The literal string is not writable so when you do:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;  str[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;z\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;you get a seg fault.  On some platforms, the literal might be in writable memory so you won\u0026apos;t see a segfault, but it\u0026apos;s invalid code (resulting in undefined behavior) regardless.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The line:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; str[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;string\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;allocates an array of characters and \u0026lt;strong\u0026gt;copies\u0026lt;/strong\u0026gt; the literal string into that array, which is fully writable, so the subsequent update is no problem.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;String literals like \u0026quot;string\u0026quot; are probably allocated in your executable\u0026apos;s address space as read-only data (give or take your compiler).  When you go to touch it, it freaks out that you\u0026apos;re in its bathing suit area and lets you know with a seg fault.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In your first example, you\u0026apos;re getting a pointer to that const data.  In your second example, you\u0026apos;re initializing an array of 7 characters with a copy of the const data.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// create a string constant like this - will be read only\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *str_p;\nstr_p = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;String constant\u0026quot;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// create an array of characters like this \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *arr_p;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; arr[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;String in an array\u0026quot;\u0026lt;/span\u0026gt;;\narr_p = \u0026amp;amp;arr[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;];\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// now we try to change a character in the array first, this will work\u0026lt;/span\u0026gt;\n*arr_p = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;E\u0026apos;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// lets try to change the first character of the string contant\u0026lt;/span\u0026gt;\n*str_p = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;G\u0026apos;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// this will result in a segmentation fault. Comment it out to work.\u0026lt;/span\u0026gt;\n\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*-----------------------------------------------------------------------------\n *  String constants can\u0026apos;t be modified. A segmentation fault is the result,\n *  because most operating systems will not allow a write\n *  operation on read only memory.\n *-----------------------------------------------------------------------------*/\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//print both strings to see if they have changed\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%s\\n\u0026quot;\u0026lt;/span\u0026gt;, str_p); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//print the string without a variable\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%s\\n\u0026quot;\u0026lt;/span\u0026gt;, arr_p); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//print the string, which is in an array. \u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In the first place, \u0026lt;code\u0026gt;str\u0026lt;/code\u0026gt; is a pointer that points at \u0026lt;code\u0026gt;\u0026quot;string\u0026quot;\u0026lt;/code\u0026gt;.  The compiler is allowed to put string literals in places in memory that you cannot write to, but can only read.  (This really should have triggered a warning, since you\u0026apos;re assigning a \u0026lt;code\u0026gt;const char *\u0026lt;/code\u0026gt; to a \u0026lt;code\u0026gt;char *\u0026lt;/code\u0026gt;.  Did you have warnings disabled, or did you just ignore them?)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In the second place, you\u0026apos;re creating an array, which is memory that you\u0026apos;ve got full access to, and initializing it with \u0026lt;code\u0026gt;\u0026quot;string\u0026quot;\u0026lt;/code\u0026gt;.  You\u0026apos;re creating a \u0026lt;code\u0026gt;char[7]\u0026lt;/code\u0026gt; (six for the letters, one for the terminating \u0026apos;\\0\u0026apos;), and you do whatever you like with it.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Assume the strings are,\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; a[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;string literal copied to stack\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *p  = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;string literal referenced by p\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In the first case, the literal is to be copied when \u0026apos;a\u0026apos; comes into scope. Here \u0026apos;a\u0026apos; is an array defined on stack. It means the string will be created on the stack and its data is copied from code (text) memory, which is typically read-only (this is implementation specific, a compiler can place this read-only program data in read-writable memory also).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In the second case, p is a pointer defined on stack (local scope) and referring a string literal (program data or text) stored else where. Usually modifying such memory is not good practice nor encouraged.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h3\u0026gt;Constant memory\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Since string literals are read-only by design, they are stored in the \u0026lt;strong\u0026gt;Constant part\u0026lt;/strong\u0026gt; of memory. Data stored there is immutable, i.e., cannot be changed. Thus, all string literals defined in C code get a read-only memory address here.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Stack memory\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;The \u0026lt;strong\u0026gt;Stack part\u0026lt;/strong\u0026gt; of memory is where the addresses of local variables live, e.g., variables defined in functions.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;As @matli\u0026apos;s answer suggests, there are two ways of working with string these constant strings.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;1. Pointer to string literal\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;When we define a pointer to a string literal, we are creating a pointer variable living in \u0026lt;strong\u0026gt;Stack memory\u0026lt;/strong\u0026gt;. It points to the read-only address where the underlying string literal resides.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; {\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%p\\n\u0026quot;\u0026lt;/span\u0026gt;, \u0026amp;amp;s);  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Prints a read-only address, e.g. 0x7ffc8e224620\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;If we try to modify \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; by inserting\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;s[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;H\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;we get a \u0026lt;code\u0026gt;Segmentation fault (core dumped)\u0026lt;/code\u0026gt;. We are trying to access memory that we shouldn\u0026apos;t access. We are attempting to modify the value of a read-only address, \u0026lt;code\u0026gt;0x7ffc8e224620\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;2. Array of chars\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;For the sake of the example, suppose the string literal \u0026lt;code\u0026gt;\u0026quot;Hello\u0026quot;\u0026lt;/code\u0026gt; stored in constant memory has a read-only memory address identical to the one above, \u0026lt;code\u0026gt;0x7ffc8e224620\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; {\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// We create an array from a string literal with address 0x7ffc8e224620.\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// C initializes an array variable in the stack, let\u0026apos;s give it address\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 0x7ffc7a9a9db2.\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// C then copies the read-only value from 0x7ffc8e224620 into \u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 0x7ffc7a9a9db2 to give us a local copy we can mutate.\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; a[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;;\n\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// We can now mutate the local copy\u0026lt;/span\u0026gt;\n  a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;H\u0026apos;\u0026lt;/span\u0026gt;;\n\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%p\\n\u0026quot;\u0026lt;/span\u0026gt;, \u0026amp;amp;a);  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Prints the Stack address, e.g. 0x7ffc7a9a9db2\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%s\\n\u0026quot;\u0026lt;/span\u0026gt;, a);   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Prints \u0026quot;Hello\u0026quot;\u0026lt;/span\u0026gt;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Note:\u0026lt;/strong\u0026gt; When using pointers to string literals as in 1., best practice is to use the \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt; keyword, like \u0026lt;code\u0026gt;const *s = \u0026quot;hello\u0026quot;\u0026lt;/code\u0026gt;. This is more readable and the compiler will provide better help when it\u0026apos;s violated. It will then throw an error like \u0026lt;code\u0026gt;error: assignment of read-only location *s\u0026lt;/code\u0026gt; instead of the seg fault. Linters in editors will also likely pick up the error before you manually compile the code.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;First is one constant string which can\u0026apos;t be modified. Second is an array with initialized value, so it can be modified. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;Section 5.5 Character Pointers and Functions\u0026lt;/code\u0026gt; of \u0026lt;code\u0026gt;K\u0026amp;amp;R\u0026lt;/code\u0026gt; also discusses about this topic:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;There is an important difference between these definitions:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;char amessage[] = \u0026quot;now is the time\u0026quot;; /* an array */\u0026lt;/code\u0026gt;\u0026lt;br\u0026gt;\n\u0026lt;code\u0026gt;char *pmessage = \u0026quot;now is the time\u0026quot;; /* a pointer */\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;amessage\u0026lt;/code\u0026gt; is an array, just big enough to hold the sequence of characters and \u0026lt;code\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/code\u0026gt; that initializes it. Individual characters within the array may be changed but \u0026lt;code\u0026gt;amessage\u0026lt;/code\u0026gt; will always refer to the same storage. On the other hand, \u0026lt;code\u0026gt;pmessage\u0026lt;/code\u0026gt; is a pointer, initialized to point to a string constant; the pointer may subsequently be modified to point elsewhere, but the result is undefined if you try to modify the string contents.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Segmentation fault is caused when you try to access the memory which is inaccessible. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;char *str\u0026lt;/code\u0026gt; is a pointer to a string that is nonmodifiable(the reason for getting segfault).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;whereas \u0026lt;code\u0026gt;char str[]\u0026lt;/code\u0026gt; is an array and can be modifiable..\u0026lt;/p\u0026gt;\n    "],"id":209,"title":"Why do I get a segmentation fault when writing to a \"char *s\" initialized with a string literal, but not \"char s[]\"?","content":"\n                \n\u0026lt;p\u0026gt;The following code receives seg fault on line 2:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *str = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;string\u0026quot;\u0026lt;/span\u0026gt;;\nstr[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;z\u0026apos;\u0026lt;/span\u0026gt;;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// could be also written as *str = \u0026apos;z\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%s\\n\u0026quot;\u0026lt;/span\u0026gt;, str);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;While this works perfectly well:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; str[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;string\u0026quot;\u0026lt;/span\u0026gt;;\nstr[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;z\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%s\\n\u0026quot;\u0026lt;/span\u0026gt;, str);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Tested with MSVC and GCC.\u0026lt;/p\u0026gt;\n    ","slug":"why-do-i-get-a-segmentation-fault-when-writing-to-a-\"char-*s\"-initialized-with-a-string-literal-but-not-\"char-s\"-1657385511046","postType":"QUESTION","createdAt":"2022-07-09T16:51:51.000Z","updatedAt":"2022-07-09T16:51:51.000Z","tags":[{"id":1466,"name":"segmentation-fault","slug":"segmentation-fault","createdAt":"2022-07-09T16:51:51.000Z","updatedAt":"2022-07-09T16:51:51.000Z","Questions_Tags":{"questionId":209,"tagId":1466}},{"id":1467,"name":"c-strings","slug":"c-strings","createdAt":"2022-07-09T16:51:51.000Z","updatedAt":"2022-07-09T16:51:51.000Z","Questions_Tags":{"questionId":209,"tagId":1467}}],"relatedQuestions":[{"title":"Why do I get a segmentation fault when writing to a \"char *s\" initialized with a string literal, but not \"char s[]\"?","slug":"why-do-i-get-a-segmentation-fault-when-writing-to-a-\"char-*s\"-initialized-with-a-string-literal-but-not-\"char-s\"-1657385511046","tags":[{"name":"segmentation-fault","Questions_Tags":{"questionId":209,"tagId":1466}},{"name":"c-strings","Questions_Tags":{"questionId":209,"tagId":1467}}]}]},"randomQuestions":[{"title":"Can you provide some examples of why it is hard to parse XML and HTML with a regex? [closed]","slug":"can-you-provide-some-examples-of-why-it-is-hard-to-parse-xml-and-html-with-a-regex-closed-1657388410824"},{"title":"Creating multiline strings in JavaScript","slug":"creating-multiline-strings-in-javascript-1657388025414"},{"title":"Asking the user for input until they give a valid response","slug":"asking-the-user-for-input-until-they-give-a-valid-response-1657384376162"},{"title":"Find object by id in an array of JavaScript objects","slug":"find-object-by-id-in-an-array-of-javascript-objects-1657387572087"},{"title":"addEventListener vs onclick","slug":"addeventlistener-vs-onclick-1657388191429"},{"title":"What is the difference between #include \u003cfilename\u003e and #include \"filename\"?","slug":"what-is-the-difference-between-include-lessfilenamegreater-and-include-\"filename\"-1657388489547"},{"title":"Reshaping data.frame from wide to long format","slug":"reshaping-data.frame-from-wide-to-long-format-1657384678522"},{"title":"Random number generator only generating one random number","slug":"random-number-generator-only-generating-one-random-number-1657385468315"},{"title":"Removing duplicates in lists","slug":"removing-duplicates-in-lists-1657388207448"},{"title":"What does ** (double star/asterisk) and * (star/asterisk) do for parameters?","slug":"what-does-**-(double-starasterisk)-and-*-(starasterisk)-do-for-parameters-1657384800967"},{"title":"How to find the 'sizeof' (a pointer pointing to an array)?","slug":"how-to-find-the-'sizeof'-(a-pointer-pointing-to-an-array)-1657387354284"},{"title":"Storing Images in DB - Yea or Nay?","slug":"storing-images-in-db-yea-or-nay-1657387248067"},{"title":"How can I do a FULL OUTER JOIN in MySQL?","slug":"how-can-i-do-a-full-outer-join-in-mysql-1657388175444"},{"title":"Error in finding last used cell in Excel with VBA","slug":"error-in-finding-last-used-cell-in-excel-with-vba-1657384584748"},{"title":"Sending Email in Android using JavaMail API without using the default/built-in app","slug":"sending-email-in-android-using-javamail-api-without-using-the-defaultbuilt-in-app-1657387883400"},{"title":"Dynamically select data frame columns using $ and a character value","slug":"dynamically-select-data-frame-columns-using-dollar-and-a-character-value-1657387836662"},{"title":"What is the difference between client-side and server-side programming?","slug":"what-is-the-difference-between-client-side-and-server-side-programming-1657384372926"},{"title":"Get top 1 row of each group","slug":"get-top-1-row-of-each-group-1657387438304"},{"title":"Convert columns into rows with Pandas","slug":"convert-columns-into-rows-with-pandas-1657388374964"},{"title":"Why don't flex items shrink past content size?","slug":"why-don't-flex-items-shrink-past-content-size-1657384687282"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"why-do-i-get-a-segmentation-fault-when-writing-to-a-\"char-*s\"-initialized-with-a-string-literal-but-not-\"char-s\"-1657385511046"},"buildId":"6ctJfCympFH_chh5mjicD","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>