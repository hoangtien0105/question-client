<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/is-there-a-difference-between-&quot;&quot;-and-&quot;is&quot;-1657387902231","name":"Questions"}}]}</script><title>Is there a difference between &quot;==&quot; and &quot;is&quot;? | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="
            
        
            
                    
                        
                    
                
                    
                        This question&#x27;s answers are a community effort. Edit existing answers to improve this post. It is not currently accepting new answers or interactions.
                        
                    
                
            
        


    

My Google-fu has failed me.

In Python, are the following two tests for equality equivalent?

n = 5
# Test one.
if n == 5:
    print &#x27;Yay!&#x27;

# Test two.
if n is 5:
    print &#x27;Yay!&#x27;


Does this hold true for objects where you would be comparing instances (a list say)?

Okay, so this kind of answers my question:

L = []
L.append(1)
if L == [1]:
    print &#x27;Yay!&#x27;
# Holds true, but...

if L is [1]:
    print &#x27;Yay!&#x27;
# Doesn&#x27;t.


So == tests value where is tests to see if they are the same object?
    "/><meta property="og:title" content="Is there a difference between &quot;==&quot; and &quot;is&quot;? | Solution Checker"/><meta property="og:description" content="
            
        
            
                    
                        
                    
                
                    
                        This question&#x27;s answers are a community effort. Edit existing answers to improve this post. It is not currently accepting new answers or interactions.
                        
                    
                
            
        


    

My Google-fu has failed me.

In Python, are the following two tests for equality equivalent?

n = 5
# Test one.
if n == 5:
    print &#x27;Yay!&#x27;

# Test two.
if n is 5:
    print &#x27;Yay!&#x27;


Does this hold true for objects where you would be comparing instances (a list say)?

Okay, so this kind of answers my question:

L = []
L.append(1)
if L == [1]:
    print &#x27;Yay!&#x27;
# Holds true, but...

if L is [1]:
    print &#x27;Yay!&#x27;
# Doesn&#x27;t.


So == tests value where is tests to see if they are the same object?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Is there a difference between &quot;==&quot; and &quot;is&quot;?","text":"\n            \n        \n            \n                    \n                        \n                    \n                \n                    \n                        This question&apos;s answers are a community effort. Edit existing answers to improve this post. It is not currently accepting new answers or interactions.\n                        \n                    \n                \n            \n        \n\n\n    \n\nMy Google-fu has failed me.\n\nIn Python, are the following two tests for equality equivalent?\n\nn = 5\n# Test one.\nif n == 5:\n    print &apos;Yay!&apos;\n\n# Test two.\nif n is 5:\n    print &apos;Yay!&apos;\n\n\nDoes this hold true for objects where you would be comparing instances (a list say)?\n\nOkay, so this kind of answers my question:\n\nL = []\nL.append(1)\nif L == [1]:\n    print &apos;Yay!&apos;\n# Holds true, but...\n\nif L is [1]:\n    print &apos;Yay!&apos;\n# Doesn&apos;t.\n\n\nSo == tests value where is tests to see if they are the same object?\n    ","answerCount":14,"upVoteCount":500,"suggestedAnswer":[{"text":"is will return True if two variables point to the same object (in memory), == if the objects referred to by the variables are equal.\n&gt;&gt;&gt; a = [1, 2, 3]\n&gt;&gt;&gt; b = a\n&gt;&gt;&gt; b is a \nTrue\n&gt;&gt;&gt; b == a\nTrue\n\n# Make a new copy of list `a` via the slice operator, \n# and assign it to variable `b`\n&gt;&gt;&gt; b = a[:] \n&gt;&gt;&gt; b is a\nFalse\n&gt;&gt;&gt; b == a\nTrue\n\nIn your case, the second test only works because Python caches small integer objects, which is an implementation detail. For larger integers, this does not work:\n&gt;&gt;&gt; 1000 is 10**3\nFalse\n&gt;&gt;&gt; 1000 == 10**3\nTrue\n\nThe same holds true for string literals:\n&gt;&gt;&gt; &quot;a&quot; is &quot;a&quot;\nTrue\n&gt;&gt;&gt; &quot;aa&quot; is &quot;a&quot; * 2\nTrue\n&gt;&gt;&gt; x = &quot;a&quot;\n&gt;&gt;&gt; &quot;aa&quot; is x * 2\nFalse\n&gt;&gt;&gt; &quot;aa&quot; is intern(x*2)\nTrue\n\nPlease see this question as well.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"There is a simple rule of thumb to tell you when to use == or is.\n\n\n== is for value equality. Use it when you would like to know if two objects have the same value.\nis is for reference equality. Use it when you would like to know if two references refer to the same object.\n\n\nIn general, when you are comparing something to a simple type, you are usually checking for value equality, so you should use ==. For example, the intention of your example is probably to check whether x has a value equal to 2 (==), not whether x is literally referring to the same object as 2.\n\n\n\nSomething else to note: because of the way the CPython reference implementation works, you&apos;ll get unexpected and inconsistent results if you mistakenly use is to compare for reference equality on integers:\n\n&gt;&gt;&gt; a = 500\n&gt;&gt;&gt; b = 500\n&gt;&gt;&gt; a == b\nTrue\n&gt;&gt;&gt; a is b\nFalse\n\n\nThat&apos;s pretty much what we expected: a and b have the same value, but are distinct entities. But what about this?\n\n&gt;&gt;&gt; c = 200\n&gt;&gt;&gt; d = 200\n&gt;&gt;&gt; c == d\nTrue\n&gt;&gt;&gt; c is d\nTrue\n\n\nThis is inconsistent with the earlier result. What&apos;s going on here? It turns out the reference implementation of Python caches integer objects in the range -5..256 as singleton instances for performance reasons. Here&apos;s an example demonstrating this:\n\n&gt;&gt;&gt; for i in range(250, 260): a = i; print &quot;%i: %s&quot; % (i, a is int(str(i)));\n... \n250: True\n251: True\n252: True\n253: True\n254: True\n255: True\n256: True\n257: False\n258: False\n259: False\n\n\nThis is another obvious reason not to use is: the behavior is left up to implementations when you&apos;re erroneously using it for value equality.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"\n  Is there a difference between == and is in Python?\n\n\nYes, they have a very important difference.\n\n==: check for equality - the semantics are that equivalent objects (that aren&apos;t necessarily the same object) will test as equal. As the documentation says:\n\n\n  The operators &lt;, &gt;, ==, &gt;=, &lt;=, and != compare the values of two objects.\n\n\nis: check for identity - the semantics are that the object (as held in memory) is the object. Again, the documentation says:\n\n\n  The operators is and is not test for object identity: x is y is true\n  if and only if x and y are the same object. Object identity is\n  determined using the id() function. x is not y yields the inverse\n  truth value.\n\n\nThus, the check for identity is the same as checking for the equality of the IDs of the objects. That is,\n\na is b\n\n\nis the same as:\n\nid(a) == id(b)\n\n\nwhere id is the builtin function that returns an integer that &quot;is guaranteed to be unique among simultaneously existing objects&quot; (see help(id)) and where a and b are any arbitrary objects.\n\nOther Usage Directions\n\nYou should use these comparisons for their semantics. Use is to check identity and == to check equality.\n\nSo in general, we use is to check for identity. This is usually useful when we are checking for an object that should only exist once in memory, referred to as a &quot;singleton&quot; in the documentation.\n\nUse cases for is include:\n\n\nNone\nenum values (when using Enums from the enum module)\nusually modules\nusually class objects resulting from class definitions\nusually function objects resulting from function definitions\nanything else that should only exist once in memory (all singletons, generally)\na specific object that you want by identity\n\n\nUsual use cases for == include:\n\n\nnumbers, including integers\nstrings\nlists\nsets\ndictionaries\ncustom mutable objects\nother builtin immutable objects, in most cases\n\n\nThe general use case, again, for ==, is the object you want may not be the same object, instead it may be an equivalent one\n\nPEP 8 directions\n\nPEP 8, the official Python style guide for the standard library also mentions two use-cases for is:\n\n\n  Comparisons to singletons like None should always be done with is or\n  is not, never the equality operators.\n  \n  Also, beware of writing if x when you really mean if x is not None --\n  e.g. when testing whether a variable or argument that defaults to None\n  was set to some other value. The other value might have a type (such\n  as a container) that could be false in a boolean context!\n\n\nInferring equality from identity\n\nIf is is true, equality can usually be inferred - logically, if an object is itself, then it should test as equivalent to itself. \n\nIn most cases this logic is true, but it relies on the implementation of the __eq__ special method. As the docs say, \n\n\n  The default behavior for equality comparison (== and !=) is based on\n  the identity of the objects. Hence, equality comparison of instances\n  with the same identity results in equality, and equality comparison of\n  instances with different identities results in inequality. A\n  motivation for this default behavior is the desire that all objects\n  should be reflexive (i.e. x is y implies x == y).\n\n\nand in the interests of consistency, recommends:\n\n\n  Equality comparison should be reflexive. In other words, identical\n  objects should compare equal:\n  \n  x is y implies x == y\n\n\nWe can see that this is the default behavior for custom objects:\n\n&gt;&gt;&gt; class Object(object): pass\n&gt;&gt;&gt; obj = Object()\n&gt;&gt;&gt; obj2 = Object()\n&gt;&gt;&gt; obj == obj, obj is obj\n(True, True)\n&gt;&gt;&gt; obj == obj2, obj is obj2\n(False, False)\n\n\nThe contrapositive is also usually true - if somethings test as not equal, you can usually infer that they are not the same object. \n\nSince tests for equality can be customized, this inference does not always hold true for all types.\n\nAn exception\n\nA notable exception is nan - it always tests as not equal to itself:\n\n&gt;&gt;&gt; nan = float(&apos;nan&apos;)\n&gt;&gt;&gt; nan\nnan\n&gt;&gt;&gt; nan is nan\nTrue\n&gt;&gt;&gt; nan == nan           # !!!!!\nFalse\n\n\nChecking for identity can be much a much quicker check than checking for equality (which might require recursively checking members). \n\nBut it cannot be substituted for equality where you may find more than one object as equivalent.\n\nNote that comparing equality of lists and tuples will assume that identity of objects are equal (because this is a fast check). This can create contradictions if the logic is inconsistent - as it is for nan:\n\n&gt;&gt;&gt; [nan] == [nan]\nTrue\n&gt;&gt;&gt; (nan,) == (nan,)\nTrue\n\n\nA Cautionary Tale:\n\nThe question is attempting to use is to compare integers. You shouldn&apos;t assume that an instance of an integer is the same instance as one obtained by another reference. This story explains why.\n\nA commenter had code that relied on the fact that small integers (-5 to 256 inclusive) are singletons in Python, instead of checking for equality.\n\n\n  Wow, this can lead to some insidious bugs. I had some code that checked if a is b, which worked as I wanted because a and b are typically small numbers. The bug only happened today, after six months in production, because a and b were finally large enough to not be cached.  gwg\n\n\nIt worked in development. It may have passed some unittests. \n\nAnd it worked in production - until the code checked for an integer larger than 256, at which point it failed in production. \n\nThis is a production failure that could have been caught in code review or possibly with a style-checker.\n\nLet me emphasize: do not use is to compare integers.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"== determines if the values are equal, while is determines if they are the exact same object.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"What&apos;s the difference between is and ==?\n== and is are different comparison! As others already said:\n\n== compares the values of the objects.\nis compares the references of the objects.\n\nIn Python names refer to objects, for example in this case value1 and value2 refer to an int instance storing the value 1000:\nvalue1 = 1000\nvalue2 = value1\n\n\nBecause value2 refers to the same object is and == will give True:\n&gt;&gt;&gt; value1 == value2\nTrue\n&gt;&gt;&gt; value1 is value2\nTrue\n\nIn the following example the names value1 and value2 refer to different int instances, even if both store the same integer:\n&gt;&gt;&gt; value1 = 1000\n&gt;&gt;&gt; value2 = 1000\n\n\nBecause the same value (integer) is stored == will be True, that&apos;s why it&apos;s often called &quot;value comparison&quot;. However is will return False because these are different objects:\n&gt;&gt;&gt; value1 == value2\nTrue\n&gt;&gt;&gt; value1 is value2\nFalse\n\nWhen to use which?\nGenerally is is a much faster comparison. That&apos;s why CPython caches (or maybe reuses would be the better term) certain objects like small integers, some strings, etc. But this should be treated as implementation detail that could (even if unlikely) change at any point without warning.\nYou should only use is if you:\n\nwant to check if two objects are really the same object (not just the same &quot;value&quot;). One example can be if you use a singleton object as constant.\n\nwant to compare a value to a Python constant. The constants in Python are:\n\nNone\nTrue1\nFalse1\nNotImplemented\nEllipsis\n__debug__\nclasses (for example int is int or int is float)\nthere could be additional constants in built-in modules or 3rd party modules. For example np.ma.masked from the NumPy module)\n\n\n\nIn every other case you should use == to check for equality.\nCan I customize the behavior?\nThere is some aspect to == that hasn&apos;t been mentioned already in the other answers: It&apos;s part of Pythons &quot;Data model&quot;. That means its behavior can be customized using the __eq__ method. For example:\nclass MyClass(object):\n    def __init__(self, val):\n        self._value = val\n\n    def __eq__(self, other):\n        print(&apos;__eq__ method called&apos;)\n        try:\n            return self._value == other._value\n        except AttributeError:\n            raise TypeError(&apos;Cannot compare {0} to objects of type {1}&apos;\n                            .format(type(self), type(other)))\n\nThis is just an artificial example to illustrate that the method is really called:\n&gt;&gt;&gt; MyClass(10) == MyClass(10)\n__eq__ method called\nTrue\n\nNote that by default (if no other implementation of __eq__ can be found in the class or the superclasses) __eq__ uses is:\nclass AClass(object):\n    def __init__(self, value):\n        self._value = value\n\n&gt;&gt;&gt; a = AClass(10)\n&gt;&gt;&gt; b = AClass(10)\n&gt;&gt;&gt; a == b\nFalse\n&gt;&gt;&gt; a == a\n\nSo it&apos;s actually important to implement __eq__ if you want &quot;more&quot; than just reference-comparison for custom classes!\nOn the other hand you cannot customize is checks. It will always compare just if you have the same reference.\nWill these comparisons always return a boolean?\nBecause __eq__ can be re-implemented or overridden, it&apos;s not limited to return True or False. It could return anything (but in most cases it should return a boolean!).\nFor example with NumPy arrays the == will return an array:\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; np.arange(10) == 2\narray([False, False,  True, False, False, False, False, False, False, False], dtype=bool)\n\nBut is checks will always return True or False!\n\n1 As Aaron Hall mentioned in the comments:\nGenerally you shouldn&apos;t do any is True or is False checks because one normally uses these &quot;checks&quot; in a context that implicitly converts the condition to a boolean (for example in an if statement). So doing the is True comparison and the implicit boolean cast is doing more work than just doing the boolean cast - and you limit yourself to booleans (which isn&apos;t considered pythonic).\nLike PEP8 mentions:\n\nDon&apos;t compare boolean values to True or False using ==.\nYes:   if greeting:\nNo:    if greeting == True:\nWorse: if greeting is True:\n\n\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"They are completely different.  is checks for object identity, while == checks for equality (a notion that depends on the two operands&apos; types).\n\nIt is only a lucky coincidence that &quot;is&quot; seems to work correctly with small integers (e.g. 5 == 4+1).  That is because CPython optimizes the storage of integers in the range (-5 to 256) by making them singletons. This behavior is totally implementation-dependent and not guaranteed to be preserved under all manner of minor transformative operations.\n\nFor example, Python 3.5 also makes short strings singletons, but slicing them disrupts this behavior:\n\n&gt;&gt;&gt; &quot;foo&quot; + &quot;bar&quot; == &quot;foobar&quot;\nTrue\n&gt;&gt;&gt; &quot;foo&quot; + &quot;bar&quot; is &quot;foobar&quot;\nTrue\n&gt;&gt;&gt; &quot;foo&quot;[:] + &quot;bar&quot; == &quot;foobar&quot;\nTrue\n&gt;&gt;&gt; &quot;foo&quot;[:] + &quot;bar&quot; is &quot;foobar&quot;\nFalse\n\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"https://docs.python.org/library/stdtypes.html#comparisons\n\nis tests for identity\n== tests for equality\n\nEach (small) integer value is mapped to a single value, so every 3 is identical and equal. This is an implementation detail, not part of the language spec though\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"Your answer is correct. The is operator compares the identity of two objects.  The == operator compares the values of two objects.\n\nAn object&apos;s identity never changes once it has been created; you may think of it as the object&apos;s address in memory.\n\nYou can control comparison behaviour of object values by defining a __cmp__ method or a rich comparison method like __eq__.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"Have a look at Stack Overflow question Python&apos;s is operator behaves unexpectedly with integers.\n\nWhat it mostly boils down to is that &quot;is&quot; checks to see if they are the same object, not just equal to each other (the numbers below 256 are a special case).\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"In a nutshell, is checks whether two references point to the same object or not.== checks whether two objects have the same value or not.\n\na=[1,2,3]\nb=a        #a and b point to the same object\nc=list(a)  #c points to different object \n\nif a==b:\n    print(&apos;#&apos;)   #output:#\nif a is b:\n    print(&apos;##&apos;)  #output:## \nif a==c:\n    print(&apos;###&apos;) #output:## \nif a is c:\n    print(&apos;####&apos;) #no output as c and a point to different object \n\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"As the other people in this post answer the question in details the difference between == and is for comparing Objects or variables, I would emphasize mainly the comparison between is and == for strings which can give different results and I would urge programmers to carefully use them.\nFor string comparison, make sure to use == instead of is:\nstr = &apos;hello&apos;\nif (str is &apos;hello&apos;):\n    print (&apos;str is hello&apos;)\nif (str == &apos;hello&apos;):\n    print (&apos;str == hello&apos;)\n\nOut:\nstr is hello\nstr == hello\n\nBut in the below example == and is will get different results:\nstr2 = &apos;hello sam&apos;\n    if (str2 is &apos;hello sam&apos;):\n        print (&apos;str2 is hello sam&apos;)\n    if (str2 == &apos;hello sam&apos;):\n        print (&apos;str2 == hello sam&apos;)\n\nOut:\nstr2 == hello sam\n\nConclusion and Analysis:\nUse is carefully to compare between strings.\nSince is for comparing objects and since in Python 3+ every variable such as string interpret as an object, let&apos;s see what happened in above paragraphs.\nIn python there is id function that shows a unique constant of an object during its lifetime. This id is using in back-end of Python interpreter to compare two objects using is keyword.\nstr = &apos;hello&apos;\nid(&apos;hello&apos;)\n&gt; 140039832615152\nid(str)\n&gt; 140039832615152\n\nBut\nstr2 = &apos;hello sam&apos;\nid(&apos;hello sam&apos;)\n&gt; 140039832615536\nid(str2)\n&gt; 140039832615792\n\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"As John Feminella said, most of the time you will use == and != because your objective is to  compare values. I&apos;d just like to categorise what you would do the rest of the time:\n\nThere is one and only one instance of NoneType i.e. None is a singleton. Consequently foo == None and foo is None mean the same. However the is test is faster and the Pythonic convention is to use foo is None.\n\nIf you are doing some introspection or mucking about with garbage collection or checking whether your custom-built string interning gadget is working or suchlike, then you probably have a use-case for foo is bar.\n\nTrue and False are also (now) singletons, but there is no use-case for foo == True and no use case for foo is True. \n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"Most of them already answered to the point. Just as an additional note (based on my understanding and experimenting but not from a documented source), the statement \n\n\n  == if the objects referred to by the variables are equal\n\n\nfrom above answers should be read as \n\n\n  == if the objects referred to by the variables are equal and objects belonging to the same type/class\n\n\n. I arrived at this conclusion based on the below test:\n\nlist1 = [1,2,3,4]\ntuple1 = (1,2,3,4)\n\nprint(list1)\nprint(tuple1)\nprint(id(list1))\nprint(id(tuple1))\n\nprint(list1 == tuple1)\nprint(list1 is tuple1)\n\n\nHere the contents of the list and tuple are same but the type/class are different. \n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"Python difference between is and equals(==)\n\n\n  The is operator may seem like the same as the equality operator but\n  they are not same.\n  \n  The is checks if both the variables point to the same object whereas\n  the == sign checks if the values for the two variables are the same.\n  \n  So if the is operator returns True then the equality is definitely\n  True, but the opposite may or may not be True.\n\n\nHere is an example to demonstrate the similarity and the difference.\n\n&gt;&gt;&gt; a = b = [1,2,3]\n&gt;&gt;&gt; c = [1,2,3]\n&gt;&gt;&gt; a == b\nTrue\n&gt;&gt;&gt; a == c\nTrue\n&gt;&gt;&gt; a is b\nTrue\n&gt;&gt;&gt; a is c\nFalse\n&gt;&gt;&gt; a = [1,2,3]\n&gt;&gt;&gt; b = [1,2]\n&gt;&gt;&gt; a == b\nFalse\n&gt;&gt;&gt; a is b\nFalse\n&gt;&gt;&gt; del a[2]\n&gt;&gt;&gt; a == b\nTrue\n&gt;&gt;&gt; a is b\nFalse\n\n\n\nTip: Avoid using is operator for immutable types such as strings and numbers, the result is unpredictable.\n\n\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><link rel="preload" href="/_next/static/css/c116652e2d6f4ad0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c116652e2d6f4ad0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c0d2dcb5e85faf18.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-50e201fdaa1e0fd1.js" defer=""></script><script src="/_next/static/DSpI0pSdXueTMCIVyw0q4/_buildManifest.js" defer=""></script><script src="/_next/static/DSpI0pSdXueTMCIVyw0q4/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/is-there-a-difference-between-%22%22-and-%22is%22-1657387902231#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/is-there-a-difference-between-%22%22-and-%22is%22-1657387902231"><h1>Is there a difference between &quot;==&quot; and &quot;is&quot;?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"></div></div><div class="question-content mt-5">
                    <div>
            <aside class="s-notice s-notice__info post-notice js-post-notice mb16" role="status">
        <div class="d-flex fd-column fw-nowrap">
            <div class="d-flex fw-nowrap">
                    <div class="flex--item mr8">
                        <svg aria-hidden="true" class="svg-icon iconLock" width="18" height="18" viewBox="0 0 18 18"><path d="M16 9a2 2 0 0 0-2-2V6A5 5 0 0 0 4 6v1a2 2 0 0 0-2 2v6c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V9Zm-7 5a2 2 0 1 1 0-4 2 2 0 0 1 0 4Zm3.1-7H5.9V6a3.1 3.1 0 0 1 6.2 0v1Z"></path></svg>
                    </div>
                <div class="flex--item wmn0 fl1 lh-lg">
                    <div class="flex--item fl1 lh-lg">
                        <b>This question's answers are a <a href="/help/privileges/edit-community-wiki">community effort</a></b>. Edit existing answers to improve this post. It is not currently accepting new answers or interactions.
                        
                    </div>
                </div>
            </div>
        </div>
</aside>

    </div>

<p>My <a href="https://english.stackexchange.com/questions/19967/what-does-google-fu-mean">Google-fu</a> has failed me.</p>

<p>In Python, are the following two tests for equality equivalent?</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">n = <span class="hljs-number">5</span>
<span class="hljs-comment"># Test one.</span>
<span class="hljs-keyword">if</span> n == <span class="hljs-number">5</span>:
    <span class="hljs-built_in">print</span> <span class="hljs-string">'Yay!'</span>

<span class="hljs-comment"># Test two.</span>
<span class="hljs-keyword">if</span> n <span class="hljs-keyword">is</span> <span class="hljs-number">5</span>:
    <span class="hljs-built_in">print</span> <span class="hljs-string">'Yay!'</span>
</code></pre>

<p>Does this hold true for objects where you would be comparing instances (a <code>list</code> say)?</p>

<p>Okay, so this kind of answers my question:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">L = []
L.append(<span class="hljs-number">1</span>)
<span class="hljs-keyword">if</span> L == [<span class="hljs-number">1</span>]:
    <span class="hljs-built_in">print</span> <span class="hljs-string">'Yay!'</span>
<span class="hljs-comment"># Holds true, but...</span>

<span class="hljs-keyword">if</span> L <span class="hljs-keyword">is</span> [<span class="hljs-number">1</span>]:
    <span class="hljs-built_in">print</span> <span class="hljs-string">'Yay!'</span>
<span class="hljs-comment"># Doesn't.</span>
</code></pre>

<p>So <code>==</code> tests value where <code>is</code> tests to see if they are the same object?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><code>is</code> will return <code>True</code> if two variables point to the same object (in memory), <code>==</code> if the objects referred to by the variables are equal.</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>b = a
<span class="hljs-meta">&gt;&gt;&gt; </span>b <span class="hljs-keyword">is</span> a 
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>b == a
<span class="hljs-literal">True</span>

<span class="hljs-comment"># Make a new copy of list `a` via the slice operator, </span>
<span class="hljs-comment"># and assign it to variable `b`</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>b = a[:] 
<span class="hljs-meta">&gt;&gt;&gt; </span>b <span class="hljs-keyword">is</span> a
<span class="hljs-literal">False</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>b == a
<span class="hljs-literal">True</span>
</code></pre>
<p>In your case, the second test only works because Python caches small integer objects, which is an implementation detail. For larger integers, this does not work:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">1000</span> <span class="hljs-keyword">is</span> <span class="hljs-number">10</span>**<span class="hljs-number">3</span>
<span class="hljs-literal">False</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">1000</span> == <span class="hljs-number">10</span>**<span class="hljs-number">3</span>
<span class="hljs-literal">True</span>
</code></pre>
<p>The same holds true for string literals:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">"a"</span> <span class="hljs-keyword">is</span> <span class="hljs-string">"a"</span>
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">"aa"</span> <span class="hljs-keyword">is</span> <span class="hljs-string">"a"</span> * <span class="hljs-number">2</span>
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>x = <span class="hljs-string">"a"</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">"aa"</span> <span class="hljs-keyword">is</span> x * <span class="hljs-number">2</span>
<span class="hljs-literal">False</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">"aa"</span> <span class="hljs-keyword">is</span> intern(x*<span class="hljs-number">2</span>)
<span class="hljs-literal">True</span>
</code></pre>
<p>Please see <a href="https://stackoverflow.com/questions/26595/is-there-any-difference-between-foo-is-none-and-foo-none">this question</a> as well.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There is a simple rule of thumb to tell you when to use <code>==</code> or <code>is</code>.</p>

<ul>
<li><code>==</code> is for <em>value equality</em>. Use it when you would like to know if two objects have the same value.</li>
<li><code>is</code> is for <em>reference equality</em>. Use it when you would like to know if two references refer to the same object.</li>
</ul>

<p>In general, when you are comparing something to a simple type, you are usually checking for <em>value equality</em>, so you should use <code>==</code>. For example, the intention of your example is probably to check whether x has a value equal to 2 (<code>==</code>), not whether <code>x</code> is literally referring to the same object as 2.</p>

<hr>

<p>Something else to note: because of the way the CPython reference implementation works, you'll get unexpected and inconsistent results if you mistakenly use <code>is</code> to compare for reference equality on integers:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">500</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-number">500</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a == b
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> b
<span class="hljs-literal">False</span>
</code></pre>

<p>That's pretty much what we expected: <code>a</code> and <code>b</code> have the same value, but are distinct entities. But what about this?</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>c = <span class="hljs-number">200</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>d = <span class="hljs-number">200</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>c == d
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>c <span class="hljs-keyword">is</span> d
<span class="hljs-literal">True</span>
</code></pre>

<p>This is inconsistent with the earlier result. What's going on here? It turns out the reference implementation of Python caches integer objects in the range -5..256 as singleton instances for performance reasons. Here's an example demonstrating this:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">250</span>, <span class="hljs-number">260</span>): a = i; <span class="hljs-built_in">print</span> <span class="hljs-string">"%i: %s"</span> % (i, a <span class="hljs-keyword">is</span> <span class="hljs-built_in">int</span>(<span class="hljs-built_in">str</span>(i)));
<span class="hljs-meta">... </span>
<span class="hljs-number">250</span>: <span class="hljs-literal">True</span>
<span class="hljs-number">251</span>: <span class="hljs-literal">True</span>
<span class="hljs-number">252</span>: <span class="hljs-literal">True</span>
<span class="hljs-number">253</span>: <span class="hljs-literal">True</span>
<span class="hljs-number">254</span>: <span class="hljs-literal">True</span>
<span class="hljs-number">255</span>: <span class="hljs-literal">True</span>
<span class="hljs-number">256</span>: <span class="hljs-literal">True</span>
<span class="hljs-number">257</span>: <span class="hljs-literal">False</span>
<span class="hljs-number">258</span>: <span class="hljs-literal">False</span>
<span class="hljs-number">259</span>: <span class="hljs-literal">False</span>
</code></pre>

<p>This is another obvious reason not to use <code>is</code>: the behavior is left up to implementations when you're erroneously using it for value equality.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<blockquote>
  <h2>Is there a difference between <code>==</code> and <code>is</code> in Python?</h2>
</blockquote>

<p>Yes, they have a very important difference.</p>

<p><strong><code>==</code></strong>: check for equality - the semantics are that equivalent objects (that aren't necessarily the same object) will test as equal. As the <a href="https://docs.python.org/3/reference/expressions.html#value-comparisons" rel="noreferrer">documentation says</a>:</p>

<blockquote>
  <p>The operators &lt;, &gt;, ==, &gt;=, &lt;=, and != compare the values of two objects.</p>
</blockquote>

<p><strong><code>is</code></strong>: check for identity - the semantics are that the object (as held in memory) <em>is</em> the object. Again, the <a href="https://docs.python.org/3/reference/expressions.html#is-not" rel="noreferrer">documentation says</a>:</p>

<blockquote>
  <p>The operators <code>is</code> and <code>is not</code> test for object identity: <code>x is y</code> is true
  if and only if <code>x</code> and <code>y</code> are the same object. Object identity is
  determined using the <code>id()</code> function. <code>x is not y</code> yields the inverse
  truth value.</p>
</blockquote>

<p>Thus, the check for identity is the same as checking for the equality of the IDs of the objects. That is,</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">a <span class="hljs-keyword">is</span> b
</code></pre>

<p>is the same as:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-built_in">id</span>(a) == <span class="hljs-built_in">id</span>(b)
</code></pre>

<p>where <code>id</code> is the builtin function that returns an integer that "is guaranteed to be unique among simultaneously existing objects" (see <code>help(id)</code>) and where <code>a</code> and <code>b</code> are any arbitrary objects.</p>

<h2>Other Usage Directions</h2>

<p>You should use these comparisons for their semantics. Use <code>is</code> to check identity and <code>==</code> to check equality.</p>

<p>So in general, we use <code>is</code> to check for identity. This is usually useful when we are checking for an object that should only exist once in memory, referred to as a "singleton" in the documentation.</p>

<p>Use cases for <code>is</code> include:</p>

<ul>
<li><code>None</code></li>
<li>enum values (when using Enums from the enum module)</li>
<li>usually modules</li>
<li>usually class objects resulting from class definitions</li>
<li>usually function objects resulting from function definitions</li>
<li>anything else that should only exist once in memory (all singletons, generally)</li>
<li>a specific object that you want by identity</li>
</ul>

<p>Usual use cases for <code>==</code> include:</p>

<ul>
<li>numbers, including integers</li>
<li>strings</li>
<li>lists</li>
<li>sets</li>
<li>dictionaries</li>
<li>custom mutable objects</li>
<li>other builtin immutable objects, in most cases</li>
</ul>

<p>The general use case, again, for <code>==</code>, is the object you want may not be the <em>same</em> object, instead it may be an <em>equivalent</em> one</p>

<h3>PEP 8 directions</h3>

<p>PEP 8, the official Python style guide for the standard library also mentions <a href="https://www.python.org/dev/peps/pep-0008/#programming-recommendations" rel="noreferrer">two use-cases for <code>is</code></a>:</p>

<blockquote>
  <p>Comparisons to singletons like <code>None</code> should always be done with <code>is</code> or
  <code>is not</code>, never the equality operators.</p>
  
  <p>Also, beware of writing <code>if x</code> when you really mean <code>if x is not None</code> --
  e.g. when testing whether a variable or argument that defaults to <code>None</code>
  was set to some other value. The other value might have a type (such
  as a container) that could be false in a boolean context!</p>
</blockquote>

<h2>Inferring equality from identity</h2>

<p>If <code>is</code> is true, equality can <em>usually</em> be inferred - logically, if an object is itself, then it should test as equivalent to itself. </p>

<p>In most cases this logic is true, but it relies on the implementation of the <code>__eq__</code> special method. As the <a href="https://docs.python.org/3/reference/expressions.html#value-comparisons" rel="noreferrer">docs</a> say, </p>

<blockquote>
  <p>The default behavior for equality comparison (<code>==</code> and <code>!=</code>) is based on
  the identity of the objects. Hence, equality comparison of instances
  with the same identity results in equality, and equality comparison of
  instances with different identities results in inequality. A
  motivation for this default behavior is the desire that all objects
  should be reflexive (i.e. x is y implies x == y).</p>
</blockquote>

<p>and in the interests of consistency, recommends:</p>

<blockquote>
  <p>Equality comparison should be reflexive. In other words, identical
  objects should compare equal:</p>
  
  <p><code>x is y</code> implies <code>x == y</code></p>
</blockquote>

<p>We can see that this is the default behavior for custom objects:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span>(<span class="hljs-title class_ inherited__">object</span>): <span class="hljs-keyword">pass</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>obj = Object()
<span class="hljs-meta">&gt;&gt;&gt; </span>obj2 = Object()
<span class="hljs-meta">&gt;&gt;&gt; </span>obj == obj, obj <span class="hljs-keyword">is</span> obj
(<span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>obj == obj2, obj <span class="hljs-keyword">is</span> obj2
(<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>)
</code></pre>

<p>The contrapositive is also usually true - if somethings test as not equal, you can usually infer that they are not the same object. </p>

<p>Since tests for equality can be customized, this inference does not always hold true for all types.</p>

<h3>An exception</h3>

<p>A notable exception is <code>nan</code> - it always tests as not equal to itself:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>nan = <span class="hljs-built_in">float</span>(<span class="hljs-string">'nan'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>nan
nan
<span class="hljs-meta">&gt;&gt;&gt; </span>nan <span class="hljs-keyword">is</span> nan
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>nan == nan           <span class="hljs-comment"># !!!!!</span>
<span class="hljs-literal">False</span>
</code></pre>

<p>Checking for identity can be much a much quicker check than checking for equality (which might require recursively checking members). </p>

<p>But it cannot be substituted for equality where you may find more than one object as equivalent.</p>

<p>Note that comparing equality of lists and tuples will assume that identity of objects are equal (because this is a fast check). This can create contradictions if the logic is inconsistent - as it is for <code>nan</code>:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>[nan] == [nan]
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>(nan,) == (nan,)
<span class="hljs-literal">True</span>
</code></pre>

<h2>A Cautionary Tale:</h2>

<p>The question is attempting to use <code>is</code> to compare integers. You shouldn't assume that an instance of an integer is the same instance as one obtained by another reference. This story explains why.</p>

<p>A commenter had code that relied on the fact that small integers (-5 to 256 inclusive) are singletons in Python, instead of checking for equality.</p>

<blockquote>
  <p>Wow, this can lead to some insidious bugs. I had some code that checked if a is b, which worked as I wanted because a and b are typically small numbers. The bug only happened today, after six months in production, because a and b were finally large enough to not be cached.  gwg</p>
</blockquote>

<p>It worked in development. It may have passed some unittests. </p>

<p>And it worked in production - until the code checked for an integer larger than 256, at which point it failed in production. </p>

<p>This is a production failure that could have been caught in code review or possibly with a style-checker.</p>

<p>Let me emphasize: <em><a href="https://stackoverflow.com/a/28864111/541136">do not use <code>is</code> to compare integers.</a></em></p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><code>==</code> determines if the values are equal, while <code>is</code> determines if they are the exact same object.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>What's the difference between <code>is</code> and <code>==</code>?</h1>
<p><code>==</code> and <code>is</code> are different comparison! As others already said:</p>
<ul>
<li><code>==</code> compares the values of the objects.</li>
<li><code>is</code> compares the references of the objects.</li>
</ul>
<p>In Python names refer to objects, for example in this case <code>value1</code> and <code>value2</code> refer to an <code>int</code> instance storing the value <code>1000</code>:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">value1 = <span class="hljs-number">1000</span>
value2 = value1
</code></pre>
<p><a href="https://i.stack.imgur.com/WLzXy.png" rel="noreferrer"><img src="https://i.stack.imgur.com/WLzXy.png" alt="enter image description here"></a></p>
<p>Because <code>value2</code> refers to the same object <code>is</code> and <code>==</code> will give <code>True</code>:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>value1 == value2
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>value1 <span class="hljs-keyword">is</span> value2
<span class="hljs-literal">True</span>
</code></pre>
<p>In the following example the names <code>value1</code> and <code>value2</code> refer to different <code>int</code> instances, even if both store the same integer:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>value1 = <span class="hljs-number">1000</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>value2 = <span class="hljs-number">1000</span>
</code></pre>
<p><a href="https://i.stack.imgur.com/IJgBI.png" rel="noreferrer"><img src="https://i.stack.imgur.com/IJgBI.png" alt="enter image description here"></a></p>
<p>Because the same value (integer) is stored <code>==</code> will be <code>True</code>, that's why it's often called "value comparison". However <code>is</code> will return <code>False</code> because these are different objects:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>value1 == value2
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>value1 <span class="hljs-keyword">is</span> value2
<span class="hljs-literal">False</span>
</code></pre>
<h2>When to use which?</h2>
<p>Generally <code>is</code> is a much faster comparison. That's why CPython caches (or maybe <em>reuses</em> would be the better term) certain objects like small integers, some strings, etc. But this should be treated as <em>implementation detail</em> that could (even if unlikely) change at any point without warning.</p>
<p>You should <strong>only use <code>is</code></strong> if you:</p>
<ul>
<li><p>want to check if two objects are really the same object (not just the same "value"). One example can be if <em>you</em> use a singleton object as constant.</p>
</li>
<li><p>want to compare a value to a <a href="https://docs.python.org/library/constants.html" rel="noreferrer">Python <em>constant</em></a>. The constants in Python are:</p>
<ul>
<li><code>None</code></li>
<li><code>True</code><sup>1</sup></li>
<li><code>False</code><sup>1</sup></li>
<li><code>NotImplemented</code></li>
<li><code>Ellipsis</code></li>
<li><code>__debug__</code></li>
<li>classes (for example <code>int is int</code> or <code>int is float</code>)</li>
<li>there could be additional constants in built-in modules or 3rd party modules. For example <a href="https://docs.scipy.org/doc/numpy/reference/maskedarray.baseclass.html#numpy.ma.masked" rel="noreferrer"><code>np.ma.masked</code></a> from the NumPy module)</li>
</ul>
</li>
</ul>
<p>In <strong>every other case you should use <code>==</code></strong> to check for equality.</p>
<h2>Can I customize the behavior?</h2>
<p>There is some aspect to <code>==</code> that hasn't been mentioned already in the other answers: It's part of <a href="https://docs.python.org/3/reference/datamodel.html#data-model" rel="noreferrer">Pythons "Data model"</a>. That means its behavior can be customized using the <a href="https://docs.python.org/reference/datamodel.html#object.__eq__" rel="noreferrer"><code>__eq__</code></a> method. For example:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>(<span class="hljs-title class_ inherited__">object</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val</span>):
        self._value = val

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'__eq__ method called'</span>)
        <span class="hljs-keyword">try</span>:
            <span class="hljs-keyword">return</span> self._value == other._value
        <span class="hljs-keyword">except</span> AttributeError:
            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'Cannot compare {0} to objects of type {1}'</span>
                            .<span class="hljs-built_in">format</span>(<span class="hljs-built_in">type</span>(self), <span class="hljs-built_in">type</span>(other)))
</code></pre>
<p>This is just an artificial example to illustrate that the method is really called:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>MyClass(<span class="hljs-number">10</span>) == MyClass(<span class="hljs-number">10</span>)
__eq__ method called
<span class="hljs-literal">True</span>
</code></pre>
<p>Note that by default (if no other implementation of <code>__eq__</code> can be found in the class or the superclasses) <code>__eq__</code> uses <code>is</code>:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AClass</span>(<span class="hljs-title class_ inherited__">object</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):
        self._value = value

<span class="hljs-meta">&gt;&gt;&gt; </span>a = AClass(<span class="hljs-number">10</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>b = AClass(<span class="hljs-number">10</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>a == b
<span class="hljs-literal">False</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a == a
</code></pre>
<p>So it's actually important to implement <code>__eq__</code> if you want "more" than just reference-comparison for custom classes!</p>
<p>On the other hand you cannot customize <code>is</code> checks. It will always compare <em>just</em> if you have the same reference.</p>
<h2>Will these comparisons always return a boolean?</h2>
<p>Because <code>__eq__</code> can be re-implemented or overridden, it's not limited to return <code>True</code> or <code>False</code>. It <em>could</em> return anything (but in most cases it should return a boolean!).</p>
<p>For example with NumPy arrays the <code>==</code> will return an array:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-meta">&gt;&gt;&gt; </span>np.arange(<span class="hljs-number">10</span>) == <span class="hljs-number">2</span>
array([<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>], dtype=<span class="hljs-built_in">bool</span>)
</code></pre>
<p>But <code>is</code> checks will always return <code>True</code> or <code>False</code>!</p>
<hr>
<p><sup>1</sup> As Aaron Hall mentioned in the comments:</p>
<p>Generally you shouldn't do any <code>is True</code> or <code>is False</code> checks because one normally uses these "checks" in a context that implicitly converts the <em>condition</em> to a boolean (for example in an <code>if</code> statement). So doing the <code>is True</code> comparison <strong>and</strong> the implicit boolean cast is doing more work than just doing the boolean cast - and you limit yourself to booleans (which isn't considered pythonic).</p>
<p>Like PEP8 mentions:</p>
<blockquote>
<p>Don't compare boolean values to <code>True</code> or <code>False</code> using <code>==</code>.</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">Yes:   <span class="hljs-keyword">if</span> greeting:
No:    <span class="hljs-keyword">if</span> greeting == <span class="hljs-literal">True</span>:
Worse: <span class="hljs-keyword">if</span> greeting <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>:
</code></pre>
</blockquote>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 6</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>They are <b>completely different</b>.  <code>is</code> checks for object identity, while <code>==</code> checks for equality (a notion that depends on the two operands' types).</p>

<p>It is only a lucky coincidence that "<code>is</code>" seems to work correctly with small integers (e.g. 5 == 4+1).  That is because <a href="https://docs.python.org/2/c-api/int.html#c.PyInt_FromLong" rel="noreferrer">CPython optimizes the storage of integers in the range (-5 to 256) by making them singletons</a>. This behavior is totally implementation-dependent and not guaranteed to be preserved under all manner of minor transformative operations.</p>

<p>For example, Python 3.5 also makes short strings singletons, but slicing them disrupts this behavior:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">"foo"</span> + <span class="hljs-string">"bar"</span> == <span class="hljs-string">"foobar"</span>
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">"foo"</span> + <span class="hljs-string">"bar"</span> <span class="hljs-keyword">is</span> <span class="hljs-string">"foobar"</span>
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">"foo"</span>[:] + <span class="hljs-string">"bar"</span> == <span class="hljs-string">"foobar"</span>
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">"foo"</span>[:] + <span class="hljs-string">"bar"</span> <span class="hljs-keyword">is</span> <span class="hljs-string">"foobar"</span>
<span class="hljs-literal">False</span>
</code></pre>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 7</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><a href="https://docs.python.org/library/stdtypes.html#comparisons" rel="noreferrer">https://docs.python.org/library/stdtypes.html#comparisons</a></p>

<p><code>is</code> tests for identity
<code>==</code> tests for equality</p>

<p>Each (small) integer value is mapped to a single value, so every 3 is identical and equal. This is an implementation detail, not part of the language spec though</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 8</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Your answer is correct. The <code>is</code> operator compares the identity of two objects.  The <code>==</code> operator compares the values of two objects.</p>

<p>An object's identity never changes once it has been created; you may think of it as the object's address in memory.</p>

<p>You can control comparison behaviour of object values by defining a <code>__cmp__</code> method or a <a href="https://docs.python.org/reference/datamodel.html#basic-customization" rel="nofollow noreferrer">rich comparison</a> method like <code>__eq__</code>.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 9</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Have a look at Stack Overflow question <em><a href="https://stackoverflow.com/questions/306313">Python's is operator behaves unexpectedly with integers</a></em>.</p>

<p>What it mostly boils down to is that "<code>is</code>" checks to see if they are the same object, not just equal to each other (the numbers below 256 are a special case).</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 10</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In a nutshell, <code>is</code> checks whether two references point to the same object or not.<code>==</code> checks whether two objects have the same value or not.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
b=a        <span class="hljs-comment">#a and b point to the same object</span>
c=<span class="hljs-built_in">list</span>(a)  <span class="hljs-comment">#c points to different object </span>

<span class="hljs-keyword">if</span> a==b:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'#'</span>)   <span class="hljs-comment">#output:#</span>
<span class="hljs-keyword">if</span> a <span class="hljs-keyword">is</span> b:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'##'</span>)  <span class="hljs-comment">#output:## </span>
<span class="hljs-keyword">if</span> a==c:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'###'</span>) <span class="hljs-comment">#output:## </span>
<span class="hljs-keyword">if</span> a <span class="hljs-keyword">is</span> c:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'####'</span>) <span class="hljs-comment">#no output as c and a point to different object </span>
</code></pre>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 11</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As the other people in this post answer the question in details the difference between <code>==</code> and <code>is</code> for comparing Objects or variables, I would <strong>emphasize</strong> mainly the comparison between <code>is</code> and <code>==</code> <strong>for strings</strong> which can give different results and I would urge programmers to carefully use them.</p>
<p>For string comparison, make sure to use <code>==</code> instead of <code>is</code>:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-built_in">str</span> = <span class="hljs-string">'hello'</span>
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">str</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'hello'</span>):
    <span class="hljs-built_in">print</span> (<span class="hljs-string">'str is hello'</span>)
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">str</span> == <span class="hljs-string">'hello'</span>):
    <span class="hljs-built_in">print</span> (<span class="hljs-string">'str == hello'</span>)
</code></pre>
<p>Out:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-built_in">str</span> <span class="hljs-keyword">is</span> hello
<span class="hljs-built_in">str</span> == hello
</code></pre>
<p><strong>But</strong> in the below example <code>==</code> and <code>is</code> will get different results:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">str2 = <span class="hljs-string">'hello sam'</span>
    <span class="hljs-keyword">if</span> (str2 <span class="hljs-keyword">is</span> <span class="hljs-string">'hello sam'</span>):
        <span class="hljs-built_in">print</span> (<span class="hljs-string">'str2 is hello sam'</span>)
    <span class="hljs-keyword">if</span> (str2 == <span class="hljs-string">'hello sam'</span>):
        <span class="hljs-built_in">print</span> (<span class="hljs-string">'str2 == hello sam'</span>)
</code></pre>
<p>Out:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">str2 == hello sam
</code></pre>
<p><strong>Conclusion and Analysis:</strong></p>
<p>Use <code>is</code> carefully to compare between strings.
Since <code>is</code> for comparing objects and since in Python 3+ every variable such as string interpret as an object, let's see what happened in above paragraphs.</p>
<p>In python there is <a href="https://www.geeksforgeeks.org/id-function-python/#:%7E:text=id()%20is%20an%20inbuilt,the%20same%20id()%20value." rel="nofollow noreferrer"><code>id</code></a> function that shows a unique constant of an object during its lifetime. This id is using in back-end of Python interpreter to compare two objects using <code>is</code> keyword.</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-built_in">str</span> = <span class="hljs-string">'hello'</span>
<span class="hljs-built_in">id</span>(<span class="hljs-string">'hello'</span>)
&gt; <span class="hljs-number">140039832615152</span>
<span class="hljs-built_in">id</span>(<span class="hljs-built_in">str</span>)
&gt; <span class="hljs-number">140039832615152</span>
</code></pre>
<p>But</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">str2 = <span class="hljs-string">'hello sam'</span>
<span class="hljs-built_in">id</span>(<span class="hljs-string">'hello sam'</span>)
&gt; <span class="hljs-number">140039832615536</span>
<span class="hljs-built_in">id</span>(str2)
&gt; <span class="hljs-number">140039832615792</span>
</code></pre>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 12</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As John Feminella said, most of the time you will use == and != because your objective is to  compare values. I'd just like to categorise what you would do the rest of the time:</p>

<p>There is one and only one instance of NoneType i.e. None is a singleton. Consequently <code>foo == None</code> and <code>foo is None</code> mean the same. However the <code>is</code> test is faster and the Pythonic convention is to use <code>foo is None</code>.</p>

<p>If you are doing some introspection or mucking about with garbage collection or checking whether your custom-built string interning gadget is working or suchlike, then you probably have a use-case for <code>foo</code> is <code>bar</code>.</p>

<p>True and False are also (now) singletons, but there is no use-case for <code>foo == True</code> and no use case for <code>foo is True</code>. </p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 13</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Most of them already answered to the point. Just as an additional note (based on my understanding and experimenting but not from a documented source), the statement </p>

<blockquote>
  <p>== if the objects referred to by the variables are equal</p>
</blockquote>

<p>from above answers should be read as </p>

<blockquote>
  <p>== if the objects referred to by the variables are equal and objects belonging to the same type/class</p>
</blockquote>

<p>. I arrived at this conclusion based on the below test:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">list1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
tuple1 = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)

<span class="hljs-built_in">print</span>(list1)
<span class="hljs-built_in">print</span>(tuple1)
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(list1))
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(tuple1))

<span class="hljs-built_in">print</span>(list1 == tuple1)
<span class="hljs-built_in">print</span>(list1 <span class="hljs-keyword">is</span> tuple1)
</code></pre>

<p>Here the contents of the list and tuple are same but the type/class are different. </p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 14</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Python difference between is and equals(==)</p>

<blockquote>
  <p>The is operator may seem like the same as the equality operator but
  they are not same.</p>
  
  <p>The is checks if both the variables point to the same object whereas
  the == sign checks if the values for the two variables are the same.</p>
  
  <p>So if the is operator returns True then the equality is definitely
  True, but the opposite may or may not be True.</p>
</blockquote>

<p>Here is an example to demonstrate the similarity and the difference.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = b = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>c = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>a == b
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a == c
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> b
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> c
<span class="hljs-literal">False</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>b = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>a == b
<span class="hljs-literal">False</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> b
<span class="hljs-literal">False</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> a[<span class="hljs-number">2</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>a == b
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> b
<span class="hljs-literal">False</span>
</code></pre>

<blockquote>
<pre class="lang-py s-code-block"><code class="hljs language-python">Tip: Avoid using <span class="hljs-keyword">is</span> operator <span class="hljs-keyword">for</span> immutable types such <span class="hljs-keyword">as</span> strings <span class="hljs-keyword">and</span> numbers, the result <span class="hljs-keyword">is</span> unpredictable.
</code></pre>
</blockquote>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/why-can&#x27;t-i-store-a-value-and-a-reference-to-that-value-in-the-same-struct-1657387506828">Why can&#x27;t I store a value and a reference to that value in the same struct?</a><a href="/questions/sort-array-of-objects-by-string-property-value-1657384860090">Sort array of objects by string property value</a><a href="/questions/how-do-i-convert-an-existing-callback-api-to-promises-1657384694006">How do I convert an existing callback API to promises?</a><a href="/questions/is-it-safe-to-expose-firebase-apikey-to-the-public-1657388268111">Is it safe to expose Firebase apiKey to the public?</a><a href="/questions/what-does-enctype&#x27;multipartform-data&#x27;-mean-1657388229352">What does enctype=&#x27;multipart/form-data&#x27; mean?</a><a href="/questions/mysql-pivot-row-into-dynamic-number-of-columns-1657387981930">MySQL pivot row into dynamic number of columns</a><a href="/questions/what-is-move-semantics-1657387702625">What is move semantics?</a><a href="/questions/unboundlocalerror-on-local-variable-when-reassigned-after-first-use-1657387685248">UnboundLocalError on local variable when reassigned after first use</a><a href="/questions/how-to-include-a-php-variable-inside-a-mysql-statement-1657387669365">How to include a PHP variable inside a MySQL statement</a><a href="/questions/how-do-i-split-a-list-into-equally-sized-chunks-1657384580399">How do I split a list into equally-sized chunks?</a><a href="/questions/how-do-i-generate-random-integers-within-a-specific-range-in-java-1657385458888">How do I generate random integers within a specific range in Java?</a><a href="/questions/when-to-use-virtual-destructors-1657388152135">When to use virtual destructors?</a><a href="/questions/what-is-the-difference-between-a-deep-copy-and-a-shallow-copy-1657388445063">What is the difference between a deep copy and a shallow copy?</a><a href="/questions/css-selector-for-first-element-with-class-1657388028765">CSS selector for first element with class</a><a href="/questions/why-are-mutable-structs-%22evil%22-1657388508974">Why are mutable structs “evil”?</a><a href="/questions/why-should-there-be-spaces-around-&#x27;&#x27;-and-&#x27;&#x27;-in-bash-1657387984122">Why should there be spaces around &#x27;[&#x27; and &#x27;]&#x27; in Bash?</a><a href="/questions/why-is-using-the-javascript-eval-function-a-bad-idea-1657387485165">Why is using the JavaScript eval function a bad idea?</a><a href="/questions/sorting-an-array-of-objects-by-property-values-1657387447490">Sorting an array of objects by property values</a><a href="/questions/what-happens-if-you-use-the-32-bit-int-0x80-linux-abi-in-64-bit-code-1657388560485">What happens if you use the 32-bit int 0x80 Linux ABI in 64-bit code?</a><a href="/questions/is-there-a-regexp.escape-function-in-javascript-1657387606651">Is there a RegExp.escape function in JavaScript?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; will return \u0026lt;code\u0026gt;True\u0026lt;/code\u0026gt; if two variables point to the same object (in memory), \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; if the objects referred to by the variables are equal.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;b = a\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;b \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; a \n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;b == a\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Make a new copy of list `a` via the slice operator, \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# and assign it to variable `b`\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;b = a[:] \n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;b \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; a\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;b == a\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In your case, the second test only works because Python caches small integer objects, which is an implementation detail. For larger integers, this does not work:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;**\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;**\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The same holds true for string literals:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;aa\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a\u0026quot;\u0026lt;/span\u0026gt; * \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;x = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;aa\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; x * \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;aa\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; intern(x*\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Please see \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/26595/is-there-any-difference-between-foo-is-none-and-foo-none\u0026quot;\u0026gt;this question\u0026lt;/a\u0026gt; as well.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There is a simple rule of thumb to tell you when to use \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; is for \u0026lt;em\u0026gt;value equality\u0026lt;/em\u0026gt;. Use it when you would like to know if two objects have the same value.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; is for \u0026lt;em\u0026gt;reference equality\u0026lt;/em\u0026gt;. Use it when you would like to know if two references refer to the same object.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;In general, when you are comparing something to a simple type, you are usually checking for \u0026lt;em\u0026gt;value equality\u0026lt;/em\u0026gt;, so you should use \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt;. For example, the intention of your example is probably to check whether x has a value equal to 2 (\u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt;), not whether \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; is literally referring to the same object as 2.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Something else to note: because of the way the CPython reference implementation works, you\u0026apos;ll get unexpected and inconsistent results if you mistakenly use \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; to compare for reference equality on integers:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;500\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;b = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;500\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a == b\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; b\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;That\u0026apos;s pretty much what we expected: \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; have the same value, but are distinct entities. But what about this?\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;c = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;200\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;d = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;200\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;c == d\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;c \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; d\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This is inconsistent with the earlier result. What\u0026apos;s going on here? It turns out the reference implementation of Python caches integer objects in the range -5..256 as singleton instances for performance reasons. Here\u0026apos;s an example demonstrating this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; i \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;range\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;250\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;260\u0026lt;/span\u0026gt;): a = i; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%i: %s\u0026quot;\u0026lt;/span\u0026gt; % (i, a \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt;(i)));\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;250\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;251\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;252\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;253\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;254\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;255\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;256\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;257\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;258\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;259\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This is another obvious reason not to use \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt;: the behavior is left up to implementations when you\u0026apos;re erroneously using it for value equality.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;h2\u0026gt;Is there a difference between \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; in Python?\u0026lt;/h2\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Yes, they have a very important difference.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;: check for equality - the semantics are that equivalent objects (that aren\u0026apos;t necessarily the same object) will test as equal. As the \u0026lt;a href=\u0026quot;https://docs.python.org/3/reference/expressions.html#value-comparisons\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;documentation says\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The operators \u0026amp;lt;, \u0026amp;gt;, ==, \u0026amp;gt;=, \u0026amp;lt;=, and != compare the values of two objects.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;: check for identity - the semantics are that the object (as held in memory) \u0026lt;em\u0026gt;is\u0026lt;/em\u0026gt; the object. Again, the \u0026lt;a href=\u0026quot;https://docs.python.org/3/reference/expressions.html#is-not\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;documentation says\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The operators \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;is not\u0026lt;/code\u0026gt; test for object identity: \u0026lt;code\u0026gt;x is y\u0026lt;/code\u0026gt; is true\n  if and only if \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;y\u0026lt;/code\u0026gt; are the same object. Object identity is\n  determined using the \u0026lt;code\u0026gt;id()\u0026lt;/code\u0026gt; function. \u0026lt;code\u0026gt;x is not y\u0026lt;/code\u0026gt; yields the inverse\n  truth value.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Thus, the check for identity is the same as checking for the equality of the IDs of the objects. That is,\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;a \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; b\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;is the same as:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(a) == \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(b)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;where \u0026lt;code\u0026gt;id\u0026lt;/code\u0026gt; is the builtin function that returns an integer that \u0026quot;is guaranteed to be unique among simultaneously existing objects\u0026quot; (see \u0026lt;code\u0026gt;help(id)\u0026lt;/code\u0026gt;) and where \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; are any arbitrary objects.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Other Usage Directions\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;You should use these comparisons for their semantics. Use \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; to check identity and \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; to check equality.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So in general, we use \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; to check for identity. This is usually useful when we are checking for an object that should only exist once in memory, referred to as a \u0026quot;singleton\u0026quot; in the documentation.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Use cases for \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; include:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;None\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;enum values (when using Enums from the enum module)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;usually modules\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;usually class objects resulting from class definitions\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;usually function objects resulting from function definitions\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;anything else that should only exist once in memory (all singletons, generally)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;a specific object that you want by identity\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Usual use cases for \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; include:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;numbers, including integers\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;strings\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;lists\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;sets\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;dictionaries\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;custom mutable objects\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;other builtin immutable objects, in most cases\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;The general use case, again, for \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt;, is the object you want may not be the \u0026lt;em\u0026gt;same\u0026lt;/em\u0026gt; object, instead it may be an \u0026lt;em\u0026gt;equivalent\u0026lt;/em\u0026gt; one\u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;PEP 8 directions\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;PEP 8, the official Python style guide for the standard library also mentions \u0026lt;a href=\u0026quot;https://www.python.org/dev/peps/pep-0008/#programming-recommendations\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;two use-cases for \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Comparisons to singletons like \u0026lt;code\u0026gt;None\u0026lt;/code\u0026gt; should always be done with \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; or\n  \u0026lt;code\u0026gt;is not\u0026lt;/code\u0026gt;, never the equality operators.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;Also, beware of writing \u0026lt;code\u0026gt;if x\u0026lt;/code\u0026gt; when you really mean \u0026lt;code\u0026gt;if x is not None\u0026lt;/code\u0026gt; --\n  e.g. when testing whether a variable or argument that defaults to \u0026lt;code\u0026gt;None\u0026lt;/code\u0026gt;\n  was set to some other value. The other value might have a type (such\n  as a container) that could be false in a boolean context!\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;h2\u0026gt;Inferring equality from identity\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;If \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; is true, equality can \u0026lt;em\u0026gt;usually\u0026lt;/em\u0026gt; be inferred - logically, if an object is itself, then it should test as equivalent to itself. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In most cases this logic is true, but it relies on the implementation of the \u0026lt;code\u0026gt;__eq__\u0026lt;/code\u0026gt; special method. As the \u0026lt;a href=\u0026quot;https://docs.python.org/3/reference/expressions.html#value-comparisons\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;docs\u0026lt;/a\u0026gt; say, \u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The default behavior for equality comparison (\u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;!=\u0026lt;/code\u0026gt;) is based on\n  the identity of the objects. Hence, equality comparison of instances\n  with the same identity results in equality, and equality comparison of\n  instances with different identities results in inequality. A\n  motivation for this default behavior is the desire that all objects\n  should be reflexive (i.e. x is y implies x == y).\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;and in the interests of consistency, recommends:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Equality comparison should be reflexive. In other words, identical\n  objects should compare equal:\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;\u0026lt;code\u0026gt;x is y\u0026lt;/code\u0026gt; implies \u0026lt;code\u0026gt;x == y\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;We can see that this is the default behavior for custom objects:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_ inherited__\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt;): \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;pass\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;obj = Object()\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;obj2 = Object()\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;obj == obj, obj \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; obj\n(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;obj == obj2, obj \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; obj2\n(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The contrapositive is also usually true - if somethings test as not equal, you can usually infer that they are not the same object. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Since tests for equality can be customized, this inference does not always hold true for all types.\u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;An exception\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;A notable exception is \u0026lt;code\u0026gt;nan\u0026lt;/code\u0026gt; - it always tests as not equal to itself:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;nan = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;nan\u0026apos;\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;nan\nnan\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;nan \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; nan\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;nan == nan           \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# !!!!!\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Checking for identity can be much a much quicker check than checking for equality (which might require recursively checking members). \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But it cannot be substituted for equality where you may find more than one object as equivalent.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note that comparing equality of lists and tuples will assume that identity of objects are equal (because this is a fast check). This can create contradictions if the logic is inconsistent - as it is for \u0026lt;code\u0026gt;nan\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;[nan] == [nan]\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;(nan,) == (nan,)\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h2\u0026gt;A Cautionary Tale:\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The question is attempting to use \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; to compare integers. You shouldn\u0026apos;t assume that an instance of an integer is the same instance as one obtained by another reference. This story explains why.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A commenter had code that relied on the fact that small integers (-5 to 256 inclusive) are singletons in Python, instead of checking for equality.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Wow, this can lead to some insidious bugs. I had some code that checked if a is b, which worked as I wanted because a and b are typically small numbers. The bug only happened today, after six months in production, because a and b were finally large enough to not be cached.  gwg\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;It worked in development. It may have passed some unittests. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;And it worked in production - until the code checked for an integer larger than 256, at which point it failed in production. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is a production failure that could have been caught in code review or possibly with a style-checker.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Let me emphasize: \u0026lt;em\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/a/28864111/541136\u0026quot;\u0026gt;do not use \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; to compare integers.\u0026lt;/a\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; determines if the values are equal, while \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; determines if they are the exact same object.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;What\u0026apos;s the difference between \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt;?\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; are different comparison! As others already said:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; compares the values of the objects.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; compares the references of the objects.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;In Python names refer to objects, for example in this case \u0026lt;code\u0026gt;value1\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;value2\u0026lt;/code\u0026gt; refer to an \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; instance storing the value \u0026lt;code\u0026gt;1000\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;value1 = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;\nvalue2 = value1\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/WLzXy.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/WLzXy.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Because \u0026lt;code\u0026gt;value2\u0026lt;/code\u0026gt; refers to the same object \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; will give \u0026lt;code\u0026gt;True\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;value1 == value2\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;value1 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; value2\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In the following example the names \u0026lt;code\u0026gt;value1\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;value2\u0026lt;/code\u0026gt; refer to different \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; instances, even if both store the same integer:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;value1 = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;value2 = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/IJgBI.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/IJgBI.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Because the same value (integer) is stored \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; will be \u0026lt;code\u0026gt;True\u0026lt;/code\u0026gt;, that\u0026apos;s why it\u0026apos;s often called \u0026quot;value comparison\u0026quot;. However \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; will return \u0026lt;code\u0026gt;False\u0026lt;/code\u0026gt; because these are different objects:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;value1 == value2\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;value1 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; value2\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h2\u0026gt;When to use which?\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Generally \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; is a much faster comparison. That\u0026apos;s why CPython caches (or maybe \u0026lt;em\u0026gt;reuses\u0026lt;/em\u0026gt; would be the better term) certain objects like small integers, some strings, etc. But this should be treated as \u0026lt;em\u0026gt;implementation detail\u0026lt;/em\u0026gt; that could (even if unlikely) change at any point without warning.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;You should \u0026lt;strong\u0026gt;only use \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt; if you:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;want to check if two objects are really the same object (not just the same \u0026quot;value\u0026quot;). One example can be if \u0026lt;em\u0026gt;you\u0026lt;/em\u0026gt; use a singleton object as constant.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;want to compare a value to a \u0026lt;a href=\u0026quot;https://docs.python.org/library/constants.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Python \u0026lt;em\u0026gt;constant\u0026lt;/em\u0026gt;\u0026lt;/a\u0026gt;. The constants in Python are:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;None\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;True\u0026lt;/code\u0026gt;\u0026lt;sup\u0026gt;1\u0026lt;/sup\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;False\u0026lt;/code\u0026gt;\u0026lt;sup\u0026gt;1\u0026lt;/sup\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;NotImplemented\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;Ellipsis\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;__debug__\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;classes (for example \u0026lt;code\u0026gt;int is int\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;int is float\u0026lt;/code\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;there could be additional constants in built-in modules or 3rd party modules. For example \u0026lt;a href=\u0026quot;https://docs.scipy.org/doc/numpy/reference/maskedarray.baseclass.html#numpy.ma.masked\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;np.ma.masked\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; from the NumPy module)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;In \u0026lt;strong\u0026gt;every other case you should use \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt; to check for equality.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Can I customize the behavior?\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;There is some aspect to \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; that hasn\u0026apos;t been mentioned already in the other answers: It\u0026apos;s part of \u0026lt;a href=\u0026quot;https://docs.python.org/3/reference/datamodel.html#data-model\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Pythons \u0026quot;Data model\u0026quot;\u0026lt;/a\u0026gt;. That means its behavior can be customized using the \u0026lt;a href=\u0026quot;https://docs.python.org/reference/datamodel.html#object.__eq__\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;__eq__\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; method. For example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MyClass\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_ inherited__\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__init__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, val\u0026lt;/span\u0026gt;):\n        self._value = val\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__eq__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, other\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;__eq__ method called\u0026apos;\u0026lt;/span\u0026gt;)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;try\u0026lt;/span\u0026gt;:\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; self._value == other._value\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;except\u0026lt;/span\u0026gt; AttributeError:\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;raise\u0026lt;/span\u0026gt; TypeError(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Cannot compare {0} to objects of type {1}\u0026apos;\u0026lt;/span\u0026gt;\n                            .\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;format\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt;(self), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt;(other)))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This is just an artificial example to illustrate that the method is really called:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;MyClass(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;) == MyClass(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;)\n__eq__ method called\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Note that by default (if no other implementation of \u0026lt;code\u0026gt;__eq__\u0026lt;/code\u0026gt; can be found in the class or the superclasses) \u0026lt;code\u0026gt;__eq__\u0026lt;/code\u0026gt; uses \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;AClass\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_ inherited__\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__init__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, value\u0026lt;/span\u0026gt;):\n        self._value = value\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a = AClass(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;b = AClass(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a == b\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a == a\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;So it\u0026apos;s actually important to implement \u0026lt;code\u0026gt;__eq__\u0026lt;/code\u0026gt; if you want \u0026quot;more\u0026quot; than just reference-comparison for custom classes!\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;On the other hand you cannot customize \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; checks. It will always compare \u0026lt;em\u0026gt;just\u0026lt;/em\u0026gt; if you have the same reference.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Will these comparisons always return a boolean?\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Because \u0026lt;code\u0026gt;__eq__\u0026lt;/code\u0026gt; can be re-implemented or overridden, it\u0026apos;s not limited to return \u0026lt;code\u0026gt;True\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;False\u0026lt;/code\u0026gt;. It \u0026lt;em\u0026gt;could\u0026lt;/em\u0026gt; return anything (but in most cases it should return a boolean!).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For example with NumPy arrays the \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; will return an array:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; numpy \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; np\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;np.arange(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;) == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;\narray([\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;,  \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;], dtype=\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;But \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; checks will always return \u0026lt;code\u0026gt;True\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;False\u0026lt;/code\u0026gt;!\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;1\u0026lt;/sup\u0026gt; As Aaron Hall mentioned in the comments:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Generally you shouldn\u0026apos;t do any \u0026lt;code\u0026gt;is True\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;is False\u0026lt;/code\u0026gt; checks because one normally uses these \u0026quot;checks\u0026quot; in a context that implicitly converts the \u0026lt;em\u0026gt;condition\u0026lt;/em\u0026gt; to a boolean (for example in an \u0026lt;code\u0026gt;if\u0026lt;/code\u0026gt; statement). So doing the \u0026lt;code\u0026gt;is True\u0026lt;/code\u0026gt; comparison \u0026lt;strong\u0026gt;and\u0026lt;/strong\u0026gt; the implicit boolean cast is doing more work than just doing the boolean cast - and you limit yourself to booleans (which isn\u0026apos;t considered pythonic).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Like PEP8 mentions:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Don\u0026apos;t compare boolean values to \u0026lt;code\u0026gt;True\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;False\u0026lt;/code\u0026gt; using \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;Yes:   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; greeting:\nNo:    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; greeting == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;:\nWorse: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; greeting \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;:\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;They are \u0026lt;b\u0026gt;completely different\u0026lt;/b\u0026gt;.  \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; checks for object identity, while \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; checks for equality (a notion that depends on the two operands\u0026apos; types).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It is only a lucky coincidence that \u0026quot;\u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt;\u0026quot; seems to work correctly with small integers (e.g. 5 == 4+1).  That is because \u0026lt;a href=\u0026quot;https://docs.python.org/2/c-api/int.html#c.PyInt_FromLong\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;CPython optimizes the storage of integers in the range (-5 to 256) by making them singletons\u0026lt;/a\u0026gt;. This behavior is totally implementation-dependent and not guaranteed to be preserved under all manner of minor transformative operations.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example, Python 3.5 also makes short strings singletons, but slicing them disrupts this behavior:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;foo\u0026quot;\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;bar\u0026quot;\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;foobar\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;foo\u0026quot;\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;bar\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;foobar\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;foo\u0026quot;\u0026lt;/span\u0026gt;[:] + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;bar\u0026quot;\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;foobar\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;foo\u0026quot;\u0026lt;/span\u0026gt;[:] + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;bar\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;foobar\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://docs.python.org/library/stdtypes.html#comparisons\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://docs.python.org/library/stdtypes.html#comparisons\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; tests for identity\n\u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; tests for equality\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Each (small) integer value is mapped to a single value, so every 3 is identical and equal. This is an implementation detail, not part of the language spec though\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Your answer is correct. The \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; operator compares the identity of two objects.  The \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; operator compares the values of two objects.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;An object\u0026apos;s identity never changes once it has been created; you may think of it as the object\u0026apos;s address in memory.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can control comparison behaviour of object values by defining a \u0026lt;code\u0026gt;__cmp__\u0026lt;/code\u0026gt; method or a \u0026lt;a href=\u0026quot;https://docs.python.org/reference/datamodel.html#basic-customization\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;rich comparison\u0026lt;/a\u0026gt; method like \u0026lt;code\u0026gt;__eq__\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Have a look at Stack Overflow question \u0026lt;em\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/306313\u0026quot;\u0026gt;Python\u0026apos;s is operator behaves unexpectedly with integers\u0026lt;/a\u0026gt;\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;What it mostly boils down to is that \u0026quot;\u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt;\u0026quot; checks to see if they are the same object, not just equal to each other (the numbers below 256 are a special case).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In a nutshell, \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; checks whether two references point to the same object or not.\u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; checks whether two objects have the same value or not.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;a=[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;]\nb=a        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#a and b point to the same object\u0026lt;/span\u0026gt;\nc=\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;list\u0026lt;/span\u0026gt;(a)  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#c points to different object \u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; a==b:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;#\u0026apos;\u0026lt;/span\u0026gt;)   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#output:#\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; a \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; b:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;##\u0026apos;\u0026lt;/span\u0026gt;)  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#output:## \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; a==c:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;###\u0026apos;\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#output:## \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; a \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; c:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;####\u0026apos;\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#no output as c and a point to different object \u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As the other people in this post answer the question in details the difference between \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; for comparing Objects or variables, I would \u0026lt;strong\u0026gt;emphasize\u0026lt;/strong\u0026gt; mainly the comparison between \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; \u0026lt;strong\u0026gt;for strings\u0026lt;/strong\u0026gt; which can give different results and I would urge programmers to carefully use them.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For string comparison, make sure to use \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; instead of \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;hello\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;hello\u0026apos;\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;str is hello\u0026apos;\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;hello\u0026apos;\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;str == hello\u0026apos;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Out:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; hello\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt; == hello\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;But\u0026lt;/strong\u0026gt; in the below example \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; will get different results:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;str2 = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;hello sam\u0026apos;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (str2 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;hello sam\u0026apos;\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;str2 is hello sam\u0026apos;\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (str2 == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;hello sam\u0026apos;\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;str2 == hello sam\u0026apos;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Out:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;str2 == hello sam\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Conclusion and Analysis:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Use \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; carefully to compare between strings.\nSince \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; for comparing objects and since in Python 3+ every variable such as string interpret as an object, let\u0026apos;s see what happened in above paragraphs.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In python there is \u0026lt;a href=\u0026quot;https://www.geeksforgeeks.org/id-function-python/#:%7E:text=id()%20is%20an%20inbuilt,the%20same%20id()%20value.\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;id\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; function that shows a unique constant of an object during its lifetime. This id is using in back-end of Python interpreter to compare two objects using \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; keyword.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;hello\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;hello\u0026apos;\u0026lt;/span\u0026gt;)\n\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;140039832615152\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt;)\n\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;140039832615152\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;But\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;str2 = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;hello sam\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;hello sam\u0026apos;\u0026lt;/span\u0026gt;)\n\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;140039832615536\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(str2)\n\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;140039832615792\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As John Feminella said, most of the time you will use == and != because your objective is to  compare values. I\u0026apos;d just like to categorise what you would do the rest of the time:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There is one and only one instance of NoneType i.e. None is a singleton. Consequently \u0026lt;code\u0026gt;foo == None\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;foo is None\u0026lt;/code\u0026gt; mean the same. However the \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; test is faster and the Pythonic convention is to use \u0026lt;code\u0026gt;foo is None\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you are doing some introspection or mucking about with garbage collection or checking whether your custom-built string interning gadget is working or suchlike, then you probably have a use-case for \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;bar\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;True and False are also (now) singletons, but there is no use-case for \u0026lt;code\u0026gt;foo == True\u0026lt;/code\u0026gt; and no use case for \u0026lt;code\u0026gt;foo is True\u0026lt;/code\u0026gt;. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Most of them already answered to the point. Just as an additional note (based on my understanding and experimenting but not from a documented source), the statement \u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;== if the objects referred to by the variables are equal\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;from above answers should be read as \u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;== if the objects referred to by the variables are equal and objects belonging to the same type/class\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;. I arrived at this conclusion based on the below test:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;list1 = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;]\ntuple1 = (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;)\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(list1)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(tuple1)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(list1))\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(tuple1))\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(list1 == tuple1)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(list1 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; tuple1)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here the contents of the list and tuple are same but the type/class are different. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Python difference between is and equals(==)\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The is operator may seem like the same as the equality operator but\n  they are not same.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;The is checks if both the variables point to the same object whereas\n  the == sign checks if the values for the two variables are the same.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;So if the is operator returns True then the equality is definitely\n  True, but the opposite may or may not be True.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Here is an example to demonstrate the similarity and the difference.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a = b = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;c = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a == b\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a == c\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; b\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; c\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;b = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a == b\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; b\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;del\u0026lt;/span\u0026gt; a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a == b\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; b\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;Tip: Avoid using \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; operator \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; immutable types such \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; strings \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;and\u0026lt;/span\u0026gt; numbers, the result \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; unpredictable.\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    "],"id":413,"title":"Is there a difference between \"==\" and \"is\"?","content":"\n                    \u0026lt;div\u0026gt;\n            \u0026lt;aside class=\u0026quot;s-notice s-notice__info post-notice js-post-notice mb16\u0026quot; role=\u0026quot;status\u0026quot;\u0026gt;\n        \u0026lt;div class=\u0026quot;d-flex fd-column fw-nowrap\u0026quot;\u0026gt;\n            \u0026lt;div class=\u0026quot;d-flex fw-nowrap\u0026quot;\u0026gt;\n                    \u0026lt;div class=\u0026quot;flex--item mr8\u0026quot;\u0026gt;\n                        \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;svg-icon iconLock\u0026quot; width=\u0026quot;18\u0026quot; height=\u0026quot;18\u0026quot; viewBox=\u0026quot;0 0 18 18\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;M16 9a2 2 0 0 0-2-2V6A5 5 0 0 0 4 6v1a2 2 0 0 0-2 2v6c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V9Zm-7 5a2 2 0 1 1 0-4 2 2 0 0 1 0 4Zm3.1-7H5.9V6a3.1 3.1 0 0 1 6.2 0v1Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                    \u0026lt;/div\u0026gt;\n                \u0026lt;div class=\u0026quot;flex--item wmn0 fl1 lh-lg\u0026quot;\u0026gt;\n                    \u0026lt;div class=\u0026quot;flex--item fl1 lh-lg\u0026quot;\u0026gt;\n                        \u0026lt;b\u0026gt;This question\u0026apos;s answers are a \u0026lt;a href=\u0026quot;/help/privileges/edit-community-wiki\u0026quot;\u0026gt;community effort\u0026lt;/a\u0026gt;\u0026lt;/b\u0026gt;. Edit existing answers to improve this post. It is not currently accepting new answers or interactions.\n                        \n                    \u0026lt;/div\u0026gt;\n                \u0026lt;/div\u0026gt;\n            \u0026lt;/div\u0026gt;\n        \u0026lt;/div\u0026gt;\n\u0026lt;/aside\u0026gt;\n\n    \u0026lt;/div\u0026gt;\n\n\u0026lt;p\u0026gt;My \u0026lt;a href=\u0026quot;https://english.stackexchange.com/questions/19967/what-does-google-fu-mean\u0026quot;\u0026gt;Google-fu\u0026lt;/a\u0026gt; has failed me.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In Python, are the following two tests for equality equivalent?\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;n = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Test one.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; n == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Yay!\u0026apos;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Test two.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Yay!\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Does this hold true for objects where you would be comparing instances (a \u0026lt;code\u0026gt;list\u0026lt;/code\u0026gt; say)?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Okay, so this kind of answers my question:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;L = []\nL.append(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; L == [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Yay!\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Holds true, but...\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; L \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Yay!\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Doesn\u0026apos;t.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; tests value where \u0026lt;code\u0026gt;is\u0026lt;/code\u0026gt; tests to see if they are the same object?\u0026lt;/p\u0026gt;\n    ","slug":"is-there-a-difference-between-\"\"-and-\"is\"-1657387902231","postType":"QUESTION","createdAt":"2022-07-09T17:31:42.000Z","updatedAt":"2022-07-09T17:31:42.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"Why can't I store a value and a reference to that value in the same struct?","slug":"why-can't-i-store-a-value-and-a-reference-to-that-value-in-the-same-struct-1657387506828"},{"title":"Sort array of objects by string property value","slug":"sort-array-of-objects-by-string-property-value-1657384860090"},{"title":"How do I convert an existing callback API to promises?","slug":"how-do-i-convert-an-existing-callback-api-to-promises-1657384694006"},{"title":"Is it safe to expose Firebase apiKey to the public?","slug":"is-it-safe-to-expose-firebase-apikey-to-the-public-1657388268111"},{"title":"What does enctype='multipart/form-data' mean?","slug":"what-does-enctype'multipartform-data'-mean-1657388229352"},{"title":"MySQL pivot row into dynamic number of columns","slug":"mysql-pivot-row-into-dynamic-number-of-columns-1657387981930"},{"title":"What is move semantics?","slug":"what-is-move-semantics-1657387702625"},{"title":"UnboundLocalError on local variable when reassigned after first use","slug":"unboundlocalerror-on-local-variable-when-reassigned-after-first-use-1657387685248"},{"title":"How to include a PHP variable inside a MySQL statement","slug":"how-to-include-a-php-variable-inside-a-mysql-statement-1657387669365"},{"title":"How do I split a list into equally-sized chunks?","slug":"how-do-i-split-a-list-into-equally-sized-chunks-1657384580399"},{"title":"How do I generate random integers within a specific range in Java?","slug":"how-do-i-generate-random-integers-within-a-specific-range-in-java-1657385458888"},{"title":"When to use virtual destructors?","slug":"when-to-use-virtual-destructors-1657388152135"},{"title":"What is the difference between a deep copy and a shallow copy?","slug":"what-is-the-difference-between-a-deep-copy-and-a-shallow-copy-1657388445063"},{"title":"CSS selector for first element with class","slug":"css-selector-for-first-element-with-class-1657388028765"},{"title":"Why are mutable structs “evil”?","slug":"why-are-mutable-structs-\"evil\"-1657388508974"},{"title":"Why should there be spaces around '[' and ']' in Bash?","slug":"why-should-there-be-spaces-around-''-and-''-in-bash-1657387984122"},{"title":"Why is using the JavaScript eval function a bad idea?","slug":"why-is-using-the-javascript-eval-function-a-bad-idea-1657387485165"},{"title":"Sorting an array of objects by property values","slug":"sorting-an-array-of-objects-by-property-values-1657387447490"},{"title":"What happens if you use the 32-bit int 0x80 Linux ABI in 64-bit code?","slug":"what-happens-if-you-use-the-32-bit-int-0x80-linux-abi-in-64-bit-code-1657388560485"},{"title":"Is there a RegExp.escape function in JavaScript?","slug":"is-there-a-regexp.escape-function-in-javascript-1657387606651"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"is-there-a-difference-between-\"\"-and-\"is\"-1657387902231"},"buildId":"DSpI0pSdXueTMCIVyw0q4","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>