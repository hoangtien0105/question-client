{"pageProps":{"data":{"answer":["\n&lt;h2&gt;&lt;em&gt;Oh Yes You Can&lt;/em&gt; Use Regexes to Parse HTML!&lt;/h2&gt;\n&lt;p&gt;For the task you are attempting, regexes are &lt;strong&gt;&lt;em&gt;perfectly fine!&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;It &lt;em&gt;is&lt;/em&gt; true that most people underestimate the difficulty of parsing HTML with regular expressions and therefore do so poorly.&lt;/p&gt;\n&lt;p&gt;But this is not some fundamental flaw related to computational theory. &lt;a href=&quot;https://stackoverflow.com/a/1732454/459233&quot;&gt;That silliness is parroted a lot around here&lt;/a&gt;, but dont you believe them.&lt;/p&gt;\n&lt;p&gt;So while it certainly can be done (this posting serves as an existence proof of this incontrovertible fact), that doesnt mean it&amp;nbsp;&lt;strong&gt;&lt;em&gt;should&lt;/em&gt;&lt;/strong&gt;&amp;nbsp;be.&lt;/p&gt;\n&lt;p&gt;You must decide for yourself whether youre up to the task of writing what amounts to a dedicated, special-purpose HTML parser out of regexes. Most people are not.&lt;/p&gt;\n&lt;p&gt;But &lt;em&gt;I&lt;/em&gt; am. &lt;/p&gt;\n&lt;hr&gt;\n&lt;h2&gt;General Regex-Based HTML Parsing Solutions&lt;/h2&gt;\n&lt;p&gt;First Ill show how easy it is to parse &lt;strong&gt;arbitrary&lt;/strong&gt; HTML with regexes. The full programs at the end of this posting, but the heart of the parser is:&lt;/p&gt;\n&lt;pre class=&quot;lang-perl s-code-block&quot;&gt;&lt;code class=&quot;hljs language-perl&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (;;) {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;given&lt;/span&gt; ($html) {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;last&lt;/span&gt;                    &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;pos&lt;/span&gt; || &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) &amp;gt;= &lt;span class=&quot;hljs-keyword&quot;&gt;length&lt;/span&gt;;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\@%d=&quot;&lt;/span&gt;,              (&lt;span class=&quot;hljs-keyword&quot;&gt;pos&lt;/span&gt; || &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;print&lt;/span&gt;  &lt;span class=&quot;hljs-string&quot;&gt;&quot;doctype &quot;&lt;/span&gt;   &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; / \\G (?&amp;amp;doctype)  $RX_SUBS  /xgc;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;print&lt;/span&gt;  &lt;span class=&quot;hljs-string&quot;&gt;&quot;cdata &quot;&lt;/span&gt;     &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; / \\G (?&amp;amp;cdata)    $RX_SUBS  /xgc;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;print&lt;/span&gt;  &lt;span class=&quot;hljs-string&quot;&gt;&quot;xml &quot;&lt;/span&gt;       &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; / \\G (?&amp;amp;xml)      $RX_SUBS  /xgc;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;print&lt;/span&gt;  &lt;span class=&quot;hljs-string&quot;&gt;&quot;xhook &quot;&lt;/span&gt;     &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; / \\G (?&amp;amp;xhook)    $RX_SUBS  /xgc;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;print&lt;/span&gt;  &lt;span class=&quot;hljs-string&quot;&gt;&quot;script &quot;&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; / \\G (?&amp;amp;script)   $RX_SUBS  /xgc;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;print&lt;/span&gt;  &lt;span class=&quot;hljs-string&quot;&gt;&quot;style &quot;&lt;/span&gt;     &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; / \\G (?&amp;amp;style)    $RX_SUBS  /xgc;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;print&lt;/span&gt;  &lt;span class=&quot;hljs-string&quot;&gt;&quot;comment &quot;&lt;/span&gt;   &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; / \\G (?&amp;amp;comment)  $RX_SUBS  /xgc;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;print&lt;/span&gt;  &lt;span class=&quot;hljs-string&quot;&gt;&quot;tag &quot;&lt;/span&gt;       &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; / \\G (?&amp;amp;tag)      $RX_SUBS  /xgc;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;print&lt;/span&gt;  &lt;span class=&quot;hljs-string&quot;&gt;&quot;untag &quot;&lt;/span&gt;     &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; / \\G (?&amp;amp;untag)    $RX_SUBS  /xgc;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;print&lt;/span&gt;  &lt;span class=&quot;hljs-string&quot;&gt;&quot;nasty &quot;&lt;/span&gt;     &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; / \\G (?&amp;amp;nasty)    $RX_SUBS  /xgc;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;print&lt;/span&gt;  &lt;span class=&quot;hljs-string&quot;&gt;&quot;text &quot;&lt;/span&gt;      &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; / \\G (?&amp;amp;nontag)   $RX_SUBS  /xgc;\n    default {\n      &lt;span class=&quot;hljs-keyword&quot;&gt;die&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;UNCLASSIFIED: &quot;&lt;/span&gt; .\n        &lt;span class=&quot;hljs-keyword&quot;&gt;substr&lt;/span&gt;($_, &lt;span class=&quot;hljs-keyword&quot;&gt;pos&lt;/span&gt; || &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, (&lt;span class=&quot;hljs-keyword&quot;&gt;length&lt;/span&gt; &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;65&lt;/span&gt;) ? &lt;span class=&quot;hljs-number&quot;&gt;65&lt;/span&gt; : &lt;span class=&quot;hljs-keyword&quot;&gt;length&lt;/span&gt;);\n    }\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;See how &lt;em&gt;easy&lt;/em&gt; that is to read?&lt;/p&gt;\n&lt;p&gt;As written, it identifies each piece of HTML and tells  where it found that piece. You could easily modify it to do whatever else you want with any given type of piece, or for more particular types than these.&lt;/p&gt;\n&lt;p&gt;I have no failing test cases (left :): Ive successfully run this code on more than 100,000 HTML files  every single one I could quickly and easily get my hands on. Beyond those, Ive also run it on files &lt;em&gt;specifically constructed&lt;/em&gt; to break naïve parsers.&lt;/p&gt;\n&lt;p&gt;This is &lt;em&gt;not&lt;/em&gt; a naïve parser.&lt;/p&gt;\n&lt;p&gt;Oh, Im sure it isnt perfect, but I havent managed to break it yet.  I figure that even if something did, the fix would be easy to fit in because of the programs clear structure. Even regex-heavy programs should have stucture.&lt;/p&gt;\n&lt;p&gt;Now that thats out of the way, let me address the OPs question.&lt;/p&gt;\n&lt;h2&gt;Demo of Solving the OPs Task Using Regexes&lt;/h2&gt;\n&lt;p&gt;The little &lt;code&gt;html_input_rx&lt;/code&gt; program I include below produces the following output, so that you can see that parsing HTML with regexes works just fine for what you wish to do:&lt;/p&gt;\n&lt;pre class=&quot;lang-html s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;% html_input_rx Amazon.com-_Online_Shopping_for_Electronics,_Apparel,_Computers,_Books,_DVDs_\\&amp;amp;_more.htm \ninput tag #1 at character 9955:\n       class =&amp;gt; &quot;searchSelect&quot;\n          id =&amp;gt; &quot;twotabsearchtextbox&quot;\n        name =&amp;gt; &quot;field-keywords&quot;\n        size =&amp;gt; &quot;50&quot;\n       style =&amp;gt; &quot;width:100%; background-color: #FFF;&quot;\n       title =&amp;gt; &quot;Search for&quot;\n        type =&amp;gt; &quot;text&quot;\n       value =&amp;gt; &quot;&quot;\n\ninput tag #2 at character 10335:\n         alt =&amp;gt; &quot;Go&quot;\n         src =&amp;gt; &quot;http://g-ecx.images-amazon.com/images/G/01/x-locale/common/transparent-pixel._V192234675_.gif&quot;\n        type =&amp;gt; &quot;image&quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2&gt;&lt;em&gt;Parse Input Tags, See No Evil Input&lt;/em&gt;&lt;/h2&gt;\n&lt;p&gt;Heres the source for the program that produced the output above.&lt;/p&gt;\n&lt;pre class=&quot;lang-perl s-code-block&quot;&gt;&lt;code class=&quot;hljs language-perl&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;#!/usr/bin/env perl&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;#&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;# html_input_rx - pull out all &amp;lt;input&amp;gt; tags from (X)HTML src&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;#                  via simple regex processing&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;#&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;# Tom Christiansen &amp;lt;tchrist@perl.com&amp;gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;# Sat Nov 20 10:17:31 MST 2010&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;#&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;################################################################&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;5.012&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; strict;\n&lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; autodie;\n&lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; warnings &lt;span class=&quot;hljs-string&quot;&gt;FATAL =&amp;gt;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;all&quot;&lt;/span&gt;;    \n&lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; subs &lt;span class=&quot;hljs-string&quot;&gt;qw{\n    see_no_evil\n    parse_input_tags\n    input descape dequote\n    load_patterns\n}&lt;/span&gt;;    \n&lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;open&lt;/span&gt;        &lt;span class=&quot;hljs-string&quot;&gt;&quot;:std&quot;&lt;/span&gt;,\n          &lt;span class=&quot;hljs-string&quot;&gt;IN =&amp;gt;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;:bytes&quot;&lt;/span&gt;,\n         &lt;span class=&quot;hljs-string&quot;&gt;OUT =&amp;gt;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;:utf8&quot;&lt;/span&gt;;    \n&lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; Encode &lt;span class=&quot;hljs-string&quot;&gt;qw&amp;lt; encode decode &amp;gt;&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;###########################################################&lt;/span&gt;\n\n                        parse_input_tags \n                           see_no_evil \n                              input  \n\n    &lt;span class=&quot;hljs-comment&quot;&gt;###########################################################&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;until&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;eof&lt;/span&gt;(); &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;parse_input_tags&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;my&lt;/span&gt; $_ = &lt;span class=&quot;hljs-keyword&quot;&gt;shift&lt;/span&gt;();\n    &lt;span class=&quot;hljs-keyword&quot;&gt;our&lt;/span&gt;($Input_Tag_Rx, $Pull_Attr_Rx);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;my&lt;/span&gt; $count = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;hljs-regexp&quot;&gt;/$Input_Tag_Rx/pig&lt;/span&gt;) {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;my&lt;/span&gt; $input_tag = $+&lt;span class=&quot;hljs-string&quot;&gt;{TAG}&lt;/span&gt;;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;my&lt;/span&gt; $place     = &lt;span class=&quot;hljs-keyword&quot;&gt;pos&lt;/span&gt;() - &lt;span class=&quot;hljs-keyword&quot;&gt;length&lt;/span&gt; ${^MATCH};\n        &lt;span class=&quot;hljs-keyword&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;input tag #%d at character %d:\\n&quot;&lt;/span&gt;, ++$count, $place;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;my&lt;/span&gt; %attr = ();\n        &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; ($input_tag =~ &lt;span class=&quot;hljs-regexp&quot;&gt;/$Pull_Attr_Rx/g&lt;/span&gt;) {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;my&lt;/span&gt; ($name, $value) = @+{ &lt;span class=&quot;hljs-string&quot;&gt;qw&amp;lt; NAME VALUE &amp;gt;&lt;/span&gt; };\n            $value = dequote($value);\n            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;exists&lt;/span&gt; $attr{$name}) {\n                &lt;span class=&quot;hljs-keyword&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Discarding dup attr value &apos;%s&apos; on %s attr\\n&quot;&lt;/span&gt;,\n                    $attr{$name} // &lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;undef&amp;gt;&quot;&lt;/span&gt;, $name;\n            } \n            $attr{$name} = $value;\n        } \n        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;my&lt;/span&gt; $name (&lt;span class=&quot;hljs-keyword&quot;&gt;sort&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;keys&lt;/span&gt; %attr) {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;  %10s =&amp;gt; &quot;&lt;/span&gt;, $name;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;my&lt;/span&gt; $value = descape $attr{$name};\n            &lt;span class=&quot;hljs-keyword&quot;&gt;my&lt;/span&gt;  @Q; &lt;span class=&quot;hljs-keyword&quot;&gt;given&lt;/span&gt; ($value) {\n                @Q = &lt;span class=&quot;hljs-string&quot;&gt;qw[  &quot; &quot;  ]&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; !&lt;span class=&quot;hljs-regexp&quot;&gt;/&apos;/&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span class=&quot;hljs-regexp&quot;&gt;/&quot;/&lt;/span&gt;;\n                @Q = &lt;span class=&quot;hljs-string&quot;&gt;qw[  &quot; &quot;  ]&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt;  /&lt;span class=&quot;hljs-string&quot;&gt;&apos;/ &amp;amp;&amp;amp; !/&quot;/;\n                @Q = qw[  &apos;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;  ]  when !/&apos;&lt;/span&gt;/ &amp;amp;&amp;amp;  &lt;span class=&quot;hljs-regexp&quot;&gt;/&quot;/&lt;/span&gt;;\n                @Q = &lt;span class=&quot;hljs-string&quot;&gt;qw[ q( )  ]&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt;  /&lt;span class=&quot;hljs-string&quot;&gt;&apos;/ &amp;amp;&amp;amp;  /&quot;/;\n                default { die &quot;NOTREACHED&quot; }\n            } \n            say $Q[0], $value, $Q[1];\n        } \n        print &quot;\\n&quot;;\n    } \n\n}\n\nsub dequote {\n    my $_ = $_[0];\n    s{\n        (?&amp;lt;quote&amp;gt;   [&quot;&apos;&lt;/span&gt;]      )\n        (?&amp;lt;BODY&amp;gt;    \n          (?s: (?! \\k&amp;lt;quote&amp;gt; ) . ) * \n        )\n        \\k&amp;lt;quote&amp;gt; \n    }{$+&lt;span class=&quot;hljs-string&quot;&gt;{BODY}&lt;/span&gt;}six;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; $_;\n} \n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;descape&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;my&lt;/span&gt; $string = $_[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;];\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;my&lt;/span&gt; $_ ($string) {\n        &lt;span class=&quot;hljs-regexp&quot;&gt;s{\n            (?&amp;lt;! % )\n            % ( \\p{Hex_Digit} {2} )\n        }{\n            chr hex $1;\n        }gs&lt;/span&gt;ex;\n        &lt;span class=&quot;hljs-regexp&quot;&gt;s{\n            &amp;amp; \\043 \n            ( [0-9]+ )\n            (?: ; \n              | (?= [^0-9] )\n            )\n        }{\n            chr     $1;\n        }gs&lt;/span&gt;ex;\n        &lt;span class=&quot;hljs-regexp&quot;&gt;s{\n            &amp;amp; \\043 x\n            ( \\p{ASCII_HexDigit} + )\n            (?: ; \n              | (?= \\P{ASCII_HexDigit} )\n            )\n        }{\n            chr hex $1;\n        }gs&lt;/span&gt;ex;\n\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; $string;\n} \n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;input&lt;/span&gt; &lt;/span&gt;{ \n    &lt;span class=&quot;hljs-keyword&quot;&gt;our&lt;/span&gt; ($RX_SUBS, $Meta_Tag_Rx);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;my&lt;/span&gt; $_ = &lt;span class=&quot;hljs-keyword&quot;&gt;do&lt;/span&gt; { &lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt; $/; &amp;lt;&amp;gt; };  \n    &lt;span class=&quot;hljs-keyword&quot;&gt;my&lt;/span&gt; $encoding = &lt;span class=&quot;hljs-string&quot;&gt;&quot;iso-8859-1&quot;&lt;/span&gt;;  &lt;span class=&quot;hljs-comment&quot;&gt;# web default; wish we had the HTTP headers :(&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;hljs-regexp&quot;&gt;/$Meta_Tag_Rx/gi&lt;/span&gt;) {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;my&lt;/span&gt; $meta = $+&lt;span class=&quot;hljs-string&quot;&gt;{META}&lt;/span&gt;;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;unless&lt;/span&gt; $meta =~ &lt;span class=&quot;hljs-regexp&quot;&gt;m{             $RX_SUBS\n            (?= http-equiv ) \n            (?&amp;amp;name) \n            (?&amp;amp;equals) \n            (?= (?&amp;amp;quote)? content-type )\n            (?&amp;amp;value)    \n        }six&lt;/span&gt;;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;unless&lt;/span&gt; $meta =~ &lt;span class=&quot;hljs-regexp&quot;&gt;m{             $RX_SUBS\n            (?= content ) (?&amp;amp;name) \n                          (?&amp;amp;equals) \n            (?&amp;lt;CONTENT&amp;gt;   (?&amp;amp;value)    )\n        }six&lt;/span&gt;;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;unless&lt;/span&gt; $+&lt;span class=&quot;hljs-string&quot;&gt;{CONTENT}&lt;/span&gt; =~ &lt;span class=&quot;hljs-regexp&quot;&gt;m{       $RX_SUBS\n            (?= charset ) (?&amp;amp;name) \n                          (?&amp;amp;equals) \n            (?&amp;lt;CHARSET&amp;gt;   (?&amp;amp;value)    )\n        }six&lt;/span&gt;;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;lc&lt;/span&gt; $encoding &lt;span class=&quot;hljs-keyword&quot;&gt;ne&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;lc&lt;/span&gt; $+&lt;span class=&quot;hljs-string&quot;&gt;{CHARSET}&lt;/span&gt;) {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;[RESETTING ENCODING $encoding =&amp;gt; $+{CHARSET}]&quot;&lt;/span&gt;;\n            $encoding = $+&lt;span class=&quot;hljs-string&quot;&gt;{CHARSET}&lt;/span&gt;;\n        }\n    } \n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; decode($encoding, $_);\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;see_no_evil&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;my&lt;/span&gt; $_ = &lt;span class=&quot;hljs-keyword&quot;&gt;shift&lt;/span&gt;();\n\n    &lt;span class=&quot;hljs-regexp&quot;&gt;s{ &amp;lt;!    DOCTYPE  .*?         &amp;gt; }{}sx&lt;/span&gt;; \n    &lt;span class=&quot;hljs-regexp&quot;&gt;s{ &amp;lt;! \\[ CDATA \\[ .*?    \\]\\] &amp;gt; }{}gsx&lt;/span&gt;; \n\n    s{ &amp;lt;script&amp;gt; .*?  &amp;lt;&lt;span class=&quot;hljs-regexp&quot;&gt;/script&amp;gt; }{}gsix; \n    s{ &amp;lt;!--     .*?        --&amp;gt; }{}gsx;\n\n    return $_;\n}\n\nsub load_patterns { \n\n    our $RX_SUBS = qr{ (?(DEFINE)\n        (?&amp;lt;nv_pair&amp;gt;         (?&amp;amp;name) (?&amp;amp;equals) (?&amp;amp;value)         ) \n        (?&amp;lt;name&amp;gt;            \\b (?=  \\pL ) [\\w\\-] + (?&amp;lt;= \\pL ) \\b  )\n        (?&amp;lt;equals&amp;gt;          (?&amp;amp;might_white)  = (?&amp;amp;might_white)    )\n        (?&amp;lt;value&amp;gt;           (?&amp;amp;quoted_value) | (?&amp;amp;unquoted_value) )\n        (?&amp;lt;unwhite_chunk&amp;gt;   (?: (?! &amp;gt; ) \\S ) +                    )\n        (?&amp;lt;unquoted_value&amp;gt;  [\\w\\-] *                              )\n        (?&amp;lt;might_white&amp;gt;     \\s *                                  )\n        (?&amp;lt;quoted_value&amp;gt;\n            (?&amp;lt;quote&amp;gt;   [&quot;&apos;]      )\n            (?: (?! \\k&amp;lt;quote&amp;gt; ) . ) *\n            \\k&amp;lt;quote&amp;gt; \n        )\n        (?&amp;lt;start_tag&amp;gt;  &amp;lt; (?&amp;amp;might_white) )\n        (?&amp;lt;end_tag&amp;gt;          \n            (?&amp;amp;might_white)\n            (?: (?&amp;amp;html_end_tag) \n              | (?&amp;amp;xhtml_end_tag) \n             )\n        )\n        (?&amp;lt;html_end_tag&amp;gt;       &amp;gt;  )\n        (?&amp;lt;xhtml_end_tag&amp;gt;    /&lt;/span&gt; &amp;gt;  )\n    ) }six; \n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;our&lt;/span&gt; $Meta_Tag_Rx = &lt;span class=&quot;hljs-regexp&quot;&gt;qr{                          $RX_SUBS \n        (?&amp;lt;META&amp;gt; \n            (?&amp;amp;start_tag) meta \\b\n            (?:\n                (?&amp;amp;might_white) (?&amp;amp;nv_pair) \n            ) +\n            (?&amp;amp;end_tag)\n        )\n    }six&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;our&lt;/span&gt; $Pull_Attr_Rx = &lt;span class=&quot;hljs-regexp&quot;&gt;qr{                         $RX_SUBS\n        (?&amp;lt;NAME&amp;gt;  (?&amp;amp;name)      )\n                  (?&amp;amp;equals) \n        (?&amp;lt;VALUE&amp;gt; (?&amp;amp;value)     )\n    }six&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;our&lt;/span&gt; $Input_Tag_Rx = &lt;span class=&quot;hljs-regexp&quot;&gt;qr{                         $RX_SUBS \n\n        (?&amp;lt;TAG&amp;gt; (?&amp;amp;input_tag) )\n\n        (?(DEFINE)\n\n            (?&amp;lt;input_tag&amp;gt;\n                (?&amp;amp;start_tag)\n                input\n                (?&amp;amp;might_white) \n                (?&amp;amp;attributes) \n                (?&amp;amp;might_white) \n                (?&amp;amp;end_tag)\n            )\n\n            (?&amp;lt;attributes&amp;gt;\n                (?: \n                    (?&amp;amp;might_white) \n                    (?&amp;amp;one_attribute) \n                ) *\n            )\n\n            (?&amp;lt;one_attribute&amp;gt;\n                \\b\n                (?&amp;amp;legal_attribute)\n                (?&amp;amp;might_white) = (?&amp;amp;might_white) \n                (?:\n                    (?&amp;amp;quoted_value)\n                  | (?&amp;amp;unquoted_value)\n                )\n            )\n\n            (?&amp;lt;legal_attribute&amp;gt; \n                (?: (?&amp;amp;optional_attribute)\n                  | (?&amp;amp;standard_attribute)\n                  | (?&amp;amp;event_attribute)\n            # for LEGAL parse only, comment out next line \n                  | (?&amp;amp;illegal_attribute)\n                )\n            )\n\n            (?&amp;lt;illegal_attribute&amp;gt;  (?&amp;amp;name) )\n\n            (?&amp;lt;required_attribute&amp;gt; (?#no required attributes) )\n\n            (?&amp;lt;optional_attribute&amp;gt;\n                (?&amp;amp;permitted_attribute)\n              | (?&amp;amp;deprecated_attribute)\n            )\n\n            # NB: The white space in string literals \n            #     below DOES NOT COUNT!   It&apos;s just \n            #     there for legibility.\n\n            (?&amp;lt;permitted_attribute&amp;gt;\n                  accept\n                | alt\n                | bottom\n                | check box\n                | checked\n                | disabled\n                | file\n                | hidden\n                | image\n                | max length\n                | middle\n                | name\n                | password\n                | radio\n                | read only\n                | reset\n                | right\n                | size\n                | src\n                | submit\n                | text\n                | top\n                | type\n                | value\n            )\n\n            (?&amp;lt;deprecated_attribute&amp;gt;\n                  align\n            )\n\n            (?&amp;lt;standard_attribute&amp;gt;\n                  access key\n                | class\n                | dir\n                | ltr\n                | id\n                | lang\n                | style\n                | tab index\n                | title\n                | xml:lang\n            )\n\n            (?&amp;lt;event_attribute&amp;gt;\n                  on blur\n                | on change\n                | on click\n                | on dbl   click\n                | on focus\n                | on mouse down\n                | on mouse move\n                | on mouse out\n                | on mouse over\n                | on mouse up\n                | on key   down\n                | on key   press\n                | on key   up\n                | on select\n            )\n        )\n    }six&lt;/span&gt;;\n\n}\n\nUNITCHECK {\n    load_patterns();\n} \n\nEND {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;close&lt;/span&gt;(STDOUT) \n        || &lt;span class=&quot;hljs-keyword&quot;&gt;die&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;can&apos;t close stdout: $!&quot;&lt;/span&gt;;\n} \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;There you go! Nothing to it! :)&lt;/p&gt;\n&lt;p&gt;Only  &lt;strong&gt;&lt;em&gt;you&lt;/em&gt;&lt;/strong&gt; can judge whether your skill with regexes is up to any particular parsing task. Everyones level of skill is different, and every new task is different. For jobs where you have a well-defined input set, regexes are obviously the right choice, because it is trivial to put some together when you have a restricted subset of HTML to deal with. Even regex beginners should be handle those jobs with regexes.  Anything else is overkill.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;However&lt;/strong&gt;, once the HTML starts becoming less nailed down, once it starts to ramify in ways you cannot predict but which are perfectly legal, once you have to match more different sorts of things or with more complex dependencies, you will eventually reach a point where you have to work harder to effect a solution that uses regexes than you would have to using a parsing class. Where that break-even point falls  depends again on your own comfort level with regexes.&lt;/p&gt;\n&lt;h2&gt;So What Should I Do?&lt;/h2&gt;\n&lt;p&gt;Im not going to tell you what you &lt;em&gt;must&lt;/em&gt; do or what you &lt;em&gt;cannot&lt;/em&gt; do.  I think thats Wrong. I just want to present you with possibilties, open your eyes a bit. You get to choose what you want to do and how you want to do it. There are no absolutes  and nobody else knows your own situation as well as you yourself do. If something seems like its too much work, well, maybe it is.  Programming should be &lt;strong&gt;&lt;em&gt;fun&lt;/em&gt;&lt;/strong&gt;, you know. If it isnt, you may be doing it wrong.&lt;/p&gt;\n&lt;p&gt;One can look at my &lt;code&gt;html_input_rx&lt;/code&gt; program in any number of valid ways.  One such is that you indeed &lt;em&gt;can&lt;/em&gt; parse HTML with regular expressions. But another is that it is much, much, much harder than almost anyone ever thinks it is. This can easily lead to the conclusion that my program is a testament to what you should &lt;em&gt;not&lt;/em&gt; do, because it really is too hard.&lt;/p&gt;\n&lt;p&gt;I wont disagree with that.  Certainly if everything I do in my program doesnt make sense to you after some study, then you should not be attempting to use regexes for this kind of task. For specific HTML, regexes are great, but for generic HTML, theyre tantamount to madness. I use parsing classes all the time, especially if its HTML I havent generated myself.&lt;/p&gt;\n&lt;h2&gt;Regexes  optimal for &lt;em&gt;small&lt;/em&gt; HTML parsing problems,  pessimal for large ones&lt;/h2&gt;\n&lt;p&gt;Even if my program is taken as  illustrative of why you should &lt;strong&gt;not&lt;/strong&gt; use regexes for parsing general HTML  which is OK, because I kinda meant for it to be that    it still should be an eye-opener so more people break the terribly common and nasty, nasty habit of writing unreadable, unstructured, and unmaintainable patterns.&lt;/p&gt;\n&lt;p&gt;Patterns do not have to be ugly, and they do not have to be hard. If you create ugly patterns, it is a reflection on you, not them.&lt;/p&gt;\n&lt;h2&gt;Phenomenally Exquisite Regex Language&lt;/h2&gt;\n&lt;p&gt;Ive been asked to point out that my proferred solution to your problem has been written in Perl. Are you surprised? Did you not notice? Is this revelation a bombshell?&lt;/p&gt;\n&lt;p&gt;It is true that not all other tools and programming languages are quite as convenient, expressive, and powerful when it comes to regexes as Perl is. Theres a big spectrum out there, with some being more suitable than others.  In general, the languages that have expressed regexes as part of the core language instead of as a library are easier to work with. Ive done nothing with regexes that you couldnt do in, say, PCRE, although you would structure the program differently if you were using C.&lt;/p&gt;\n&lt;p&gt;Eventually other languages will be catch up with where Perl is now in terms of regexes.  I say this because back when Perl started, nobody else had anything like Perls regexes. Say anything you like, but this is where Perl clearly won: everybody copied Perls regexes albeit at varying stages of their development.  Perl pioneered almost (not quite all, but almost) everything that you have come to rely on in modern patterns today, no matter what tool or language you use.  So eventually the others &lt;em&gt;will&lt;/em&gt; catch up.&lt;/p&gt;\n&lt;p&gt;But theyll only catch up to where Perl was sometime in the past, just as it is now.  Everything advances.  In regexes if nothing else, where Perl leads, others follow. Where will Perl be once everybody else finally catches up to where Perl is now?  I have no idea, but I know we too will have moved. Probably well be closer to &lt;a href=&quot;http://perlcabal.org/syn/S05.html&quot; rel=&quot;noreferrer&quot;&gt;Perls style of crafting patterns&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;If you like that kind  of thing but would like to use it in Perl,  you might be interested in &lt;a href=&quot;http://search.cpan.org/search?query=regexp+grammars&amp;amp;mode=module&quot; rel=&quot;noreferrer&quot;&gt;Damian Conways &lt;strong&gt;wonderful&lt;/strong&gt; Regexp::Grammars&lt;/a&gt; module. Its completely awesome, and makes what Ive done here in my program seem just as primitive as mine makes the patterns that people cram together without whitespace or alphabetic identifiers.  Check it out!&lt;/p&gt;\n&lt;hr&gt;\n&lt;h2&gt;Simple HTML Chunker&lt;/h2&gt;\n&lt;p&gt;Here is the complete source to the parser I showed the centerpiece from at the beginning of this posting.&lt;/p&gt;\n&lt;p&gt;I am &lt;em&gt;not&lt;/em&gt; suggesting that you should use this over a rigorously tested parsing class. But I am tired of people pretending that nobody can parse HTML with regexes just because &lt;em&gt;they&lt;/em&gt; cant. You clearly can, and this program is proof of that assertion.&lt;/p&gt;\n&lt;p&gt;Sure,  it isnt easy, but &lt;strong&gt;it &lt;em&gt;is&lt;/em&gt; possible!&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;And trying to do so is a terrible waste of time, because good parsing classes exist which you &lt;em&gt;should&lt;/em&gt; use for this task.  The right answer to people trying to parse &lt;em&gt;arbitrary&lt;/em&gt; HTML is &lt;strong&gt;not&lt;/strong&gt; that it is impossible.  That is a facile and disingenuous answer.  The correct and honest answer is that they shouldnt attempt it because it is too much of a bother to figure out from scratch; they should not  break their back striving to reïnvent a wheel that works perfectly well.&lt;/p&gt;\n&lt;p&gt;On the other hand, HTML that falls &lt;em&gt;within a predicable subset&lt;/em&gt; is ultra-easy to parse with regexes. Its no wonder people try to use them, because for small problems, toy problems perhaps, nothing could be easier. Thats why its so important to distinguish the two tasks  specific vs generic  as these do not necessarily demand the same approach.&lt;/p&gt;\n&lt;p&gt;I hope in the future here to see a more fair and honest treatment of questions about HTML and regexes.&lt;/p&gt;\n&lt;p&gt;Heres my HTML lexer.  It doesnt try to do a validating parse; it just identifies the lexical elements. You might think of it more as &lt;strong&gt;an HTML chunker&lt;/strong&gt; than an HTML parser. It isnt very forgiving of broken HTML, although it makes some very small allowances in that direction.&lt;/p&gt;\n&lt;p&gt;Even if you never parse full HTML yourself (and why should you? its a solved problem!), this program has lots of cool regex bits that I believe a lot of people can learn a lot from.  Enjoy!&lt;/p&gt;\n&lt;pre class=&quot;lang-perl s-code-block&quot;&gt;&lt;code class=&quot;hljs language-perl&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;#!/usr/bin/env perl&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;#&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;# chunk_HTML - a regex-based HTML chunker&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;#&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;# Tom Christiansen &amp;lt;tchrist@perl.com&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;#   Sun Nov 21 19:16:02 MST 2010&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;########################################&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;5.012&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; strict;\n&lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; autodie;\n&lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; warnings &lt;span class=&quot;hljs-string&quot;&gt;qw&amp;lt; FATAL all &amp;gt;&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;open&lt;/span&gt;     &lt;span class=&quot;hljs-string&quot;&gt;qw&amp;lt; IN :bytes OUT :utf8 :std &amp;gt;&lt;/span&gt;;\n\nMAIN: {\n  $| = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n  lex_html(&lt;span class=&quot;hljs-keyword&quot;&gt;my&lt;/span&gt; $page = slurpy());\n  &lt;span class=&quot;hljs-keyword&quot;&gt;exit&lt;/span&gt;();\n}\n\n&lt;span class=&quot;hljs-comment&quot;&gt;########################################################################&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;lex_html&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;our&lt;/span&gt; $RX_SUBS;                                        &lt;span class=&quot;hljs-comment&quot;&gt;###############&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;my&lt;/span&gt;  $html = &lt;span class=&quot;hljs-keyword&quot;&gt;shift&lt;/span&gt;();                                 &lt;span class=&quot;hljs-comment&quot;&gt;# Am I...     #&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (;;) {                                           &lt;span class=&quot;hljs-comment&quot;&gt;# forgiven? :)#&lt;/span&gt;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;given&lt;/span&gt; ($html) {                                  &lt;span class=&quot;hljs-comment&quot;&gt;###############&lt;/span&gt;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;last&lt;/span&gt;                &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;pos&lt;/span&gt; || &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) &amp;gt;= &lt;span class=&quot;hljs-keyword&quot;&gt;length&lt;/span&gt;;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\@%d=&quot;&lt;/span&gt;,          (&lt;span class=&quot;hljs-keyword&quot;&gt;pos&lt;/span&gt; || &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);\n            &lt;span class=&quot;hljs-keyword&quot;&gt;print&lt;/span&gt;  &lt;span class=&quot;hljs-string&quot;&gt;&quot;doctype &quot;&lt;/span&gt;   &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; / \\G (?&amp;amp;doctype)  $RX_SUBS  /xgc;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;print&lt;/span&gt;  &lt;span class=&quot;hljs-string&quot;&gt;&quot;cdata &quot;&lt;/span&gt;     &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; / \\G (?&amp;amp;cdata)    $RX_SUBS  /xgc;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;print&lt;/span&gt;  &lt;span class=&quot;hljs-string&quot;&gt;&quot;xml &quot;&lt;/span&gt;       &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; / \\G (?&amp;amp;xml)      $RX_SUBS  /xgc;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;print&lt;/span&gt;  &lt;span class=&quot;hljs-string&quot;&gt;&quot;xhook &quot;&lt;/span&gt;     &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; / \\G (?&amp;amp;xhook)    $RX_SUBS  /xgc;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;print&lt;/span&gt;  &lt;span class=&quot;hljs-string&quot;&gt;&quot;script &quot;&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; / \\G (?&amp;amp;script)   $RX_SUBS  /xgc;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;print&lt;/span&gt;  &lt;span class=&quot;hljs-string&quot;&gt;&quot;style &quot;&lt;/span&gt;     &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; / \\G (?&amp;amp;style)    $RX_SUBS  /xgc;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;print&lt;/span&gt;  &lt;span class=&quot;hljs-string&quot;&gt;&quot;comment &quot;&lt;/span&gt;   &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; / \\G (?&amp;amp;comment)  $RX_SUBS  /xgc;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;print&lt;/span&gt;  &lt;span class=&quot;hljs-string&quot;&gt;&quot;tag &quot;&lt;/span&gt;       &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; / \\G (?&amp;amp;tag)      $RX_SUBS  /xgc;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;print&lt;/span&gt;  &lt;span class=&quot;hljs-string&quot;&gt;&quot;untag &quot;&lt;/span&gt;     &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; / \\G (?&amp;amp;untag)    $RX_SUBS  /xgc;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;print&lt;/span&gt;  &lt;span class=&quot;hljs-string&quot;&gt;&quot;nasty &quot;&lt;/span&gt;     &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; / \\G (?&amp;amp;nasty)    $RX_SUBS  /xgc;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;print&lt;/span&gt;  &lt;span class=&quot;hljs-string&quot;&gt;&quot;text &quot;&lt;/span&gt;      &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; / \\G (?&amp;amp;nontag)   $RX_SUBS  /xgc;\n            default {\n                &lt;span class=&quot;hljs-keyword&quot;&gt;die&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;UNCLASSIFIED: &quot;&lt;/span&gt; .\n                  &lt;span class=&quot;hljs-keyword&quot;&gt;substr&lt;/span&gt;($_, &lt;span class=&quot;hljs-keyword&quot;&gt;pos&lt;/span&gt; || &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, (&lt;span class=&quot;hljs-keyword&quot;&gt;length&lt;/span&gt; &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;65&lt;/span&gt;) ? &lt;span class=&quot;hljs-number&quot;&gt;65&lt;/span&gt; : &lt;span class=&quot;hljs-keyword&quot;&gt;length&lt;/span&gt;);\n            }\n        }\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;.&quot;&lt;/span&gt;;\n}\n&lt;span class=&quot;hljs-comment&quot;&gt;#####################&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;# Return correctly decoded contents of next complete&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;# file slurped in from the &amp;lt;ARGV&amp;gt; stream.&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;#&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;slurpy&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;our&lt;/span&gt; ($RX_SUBS, $Meta_Tag_Rx);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;my&lt;/span&gt; $_ = &lt;span class=&quot;hljs-keyword&quot;&gt;do&lt;/span&gt; { &lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt; $/; &amp;lt;ARGV&amp;gt; };   &lt;span class=&quot;hljs-comment&quot;&gt;# read all input&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;unless&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;length&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; Encode   &lt;span class=&quot;hljs-string&quot;&gt;qw&amp;lt; decode &amp;gt;&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;my&lt;/span&gt; $bom = &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;given&lt;/span&gt; ($_) {\n        $bom = &lt;span class=&quot;hljs-string&quot;&gt;&quot;UTF-32LE&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; / ^ \\xFf \\xFe \\&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;   \\&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;   /&lt;span class=&quot;hljs-keyword&quot;&gt;x&lt;/span&gt;;  &lt;span class=&quot;hljs-comment&quot;&gt;# LE&lt;/span&gt;\n        $bom = &lt;span class=&quot;hljs-string&quot;&gt;&quot;UTF-32BE&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; / ^ \\&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;   \\&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;   \\xFe \\xFf /&lt;span class=&quot;hljs-keyword&quot;&gt;x&lt;/span&gt;;  &lt;span class=&quot;hljs-comment&quot;&gt;#   BE&lt;/span&gt;\n        $bom = &lt;span class=&quot;hljs-string&quot;&gt;&quot;UTF-16LE&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; / ^ \\xFf \\xFe           /&lt;span class=&quot;hljs-keyword&quot;&gt;x&lt;/span&gt;;  &lt;span class=&quot;hljs-comment&quot;&gt;# le&lt;/span&gt;\n        $bom = &lt;span class=&quot;hljs-string&quot;&gt;&quot;UTF-16BE&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; / ^ \\xFe \\xFf           /&lt;span class=&quot;hljs-keyword&quot;&gt;x&lt;/span&gt;;  &lt;span class=&quot;hljs-comment&quot;&gt;#   be&lt;/span&gt;\n        $bom = &lt;span class=&quot;hljs-string&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; / ^ \\xEF \\xBB \\xBF      /&lt;span class=&quot;hljs-keyword&quot;&gt;x&lt;/span&gt;;  &lt;span class=&quot;hljs-comment&quot;&gt;# st00pid&lt;/span&gt;\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ($bom) {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;[BOM $bom]&quot;&lt;/span&gt;;\n        &lt;span class=&quot;hljs-regexp&quot;&gt;s/^...//&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; $bom eq &lt;span class=&quot;hljs-string&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;;                        &lt;span class=&quot;hljs-comment&quot;&gt;# st00pid&lt;/span&gt;\n\n        &lt;span class=&quot;hljs-comment&quot;&gt;# Must use UTF-(16|32) w/o -[BL]E to strip BOM.&lt;/span&gt;\n        $bom =~ &lt;span class=&quot;hljs-regexp&quot;&gt;s/-[LB]E//&lt;/span&gt;;\n\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; decode($bom, $_);\n\n        &lt;span class=&quot;hljs-comment&quot;&gt;# if BOM found, don&apos;t fall through to look&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;#  for embedded encoding spec&lt;/span&gt;\n    }\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;# Latin1 is web default if not otherwise specified.&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;# No way to do this correctly if it was overridden&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;# in the HTTP header, since we assume stream contains&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;# HTML only, not also the HTTP header.&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;my&lt;/span&gt; $encoding = &lt;span class=&quot;hljs-string&quot;&gt;&quot;iso-8859-1&quot;&lt;/span&gt;;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;hljs-regexp&quot;&gt;/ (?&amp;amp;xml) $RX_SUBS /pgx&lt;/span&gt;) {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;my&lt;/span&gt; $xml = ${^MATCH};\n        &lt;span class=&quot;hljs-keyword&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;unless&lt;/span&gt; $xml =~ &lt;span class=&quot;hljs-regexp&quot;&gt;m{              $RX_SUBS\n            (?= encoding )  (?&amp;amp;name)\n                            (?&amp;amp;equals)\n                            (?&amp;amp;quote) ?\n            (?&amp;lt;ENCODING&amp;gt;    (?&amp;amp;value)       )\n        }sx&lt;/span&gt;;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;lc&lt;/span&gt; $encoding &lt;span class=&quot;hljs-keyword&quot;&gt;ne&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;lc&lt;/span&gt; $+&lt;span class=&quot;hljs-string&quot;&gt;{ENCODING}&lt;/span&gt;) {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;[XML ENCODING $encoding =&amp;gt; $+{ENCODING}]&quot;&lt;/span&gt;;\n            $encoding = $+&lt;span class=&quot;hljs-string&quot;&gt;{ENCODING}&lt;/span&gt;;\n        }\n    }\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;hljs-regexp&quot;&gt;/$Meta_Tag_Rx/gi&lt;/span&gt;) {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;my&lt;/span&gt; $meta = $+&lt;span class=&quot;hljs-string&quot;&gt;{META}&lt;/span&gt;;\n\n        &lt;span class=&quot;hljs-keyword&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;unless&lt;/span&gt; $meta =~ &lt;span class=&quot;hljs-regexp&quot;&gt;m{             $RX_SUBS\n            (?= http-equiv )    (?&amp;amp;name)\n                                (?&amp;amp;equals)\n            (?= (?&amp;amp;quote)? content-type )\n                                (?&amp;amp;value)\n        }six&lt;/span&gt;;\n\n        &lt;span class=&quot;hljs-keyword&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;unless&lt;/span&gt; $meta =~ &lt;span class=&quot;hljs-regexp&quot;&gt;m{             $RX_SUBS\n            (?= content )       (?&amp;amp;name)\n                                (?&amp;amp;equals)\n            (?&amp;lt;CONTENT&amp;gt;         (?&amp;amp;value)    )\n        }six&lt;/span&gt;;\n\n        &lt;span class=&quot;hljs-keyword&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;unless&lt;/span&gt; $+&lt;span class=&quot;hljs-string&quot;&gt;{CONTENT}&lt;/span&gt; =~ &lt;span class=&quot;hljs-regexp&quot;&gt;m{       $RX_SUBS\n            (?= charset )       (?&amp;amp;name)\n                                (?&amp;amp;equals)\n            (?&amp;lt;CHARSET&amp;gt;         (?&amp;amp;value)    )\n        }six&lt;/span&gt;;\n\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;lc&lt;/span&gt; $encoding &lt;span class=&quot;hljs-keyword&quot;&gt;ne&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;lc&lt;/span&gt; $+&lt;span class=&quot;hljs-string&quot;&gt;{CHARSET}&lt;/span&gt;) {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;[HTTP-EQUIV ENCODING $encoding =&amp;gt; $+{CHARSET}]&quot;&lt;/span&gt;;\n            $encoding = $+&lt;span class=&quot;hljs-string&quot;&gt;{CHARSET}&lt;/span&gt;;\n        }\n    }\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; decode($encoding, $_);\n}\n&lt;span class=&quot;hljs-comment&quot;&gt;########################################################################&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;# Make sure to this function is called&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;# as soon as source unit has been compiled.&lt;/span&gt;\nUNITCHECK { load_rxsubs() }\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# useful regex subroutines for HTML parsing&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;load_rxsubs&lt;/span&gt; &lt;/span&gt;{\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;our&lt;/span&gt; $RX_SUBS = &lt;span class=&quot;hljs-string&quot;&gt;qr{\n      (?(DEFINE)\n\n        (?&amp;lt;WS&amp;gt; \\s *  )\n\n        (?&amp;lt;any_nv_pair&amp;gt;     (?&amp;amp;name) (?&amp;amp;equals) (?&amp;amp;value)         )\n        (?&amp;lt;name&amp;gt;            \\b (?=  \\pL ) [\\w:\\-] +  \\b           )\n        (?&amp;lt;equals&amp;gt;          (?&amp;amp;WS)  = (?&amp;amp;WS)    )\n        (?&amp;lt;value&amp;gt;           (?&amp;amp;quoted_value) | (?&amp;amp;unquoted_value) )\n        (?&amp;lt;unwhite_chunk&amp;gt;   (?: (?! &amp;gt; ) \\S ) +                    )\n\n        (?&amp;lt;unquoted_value&amp;gt;  [\\w:\\-] *                             )\n\n        (?&amp;lt;any_quote&amp;gt;  [&quot;&apos;]      )\n\n        (?&amp;lt;quoted_value&amp;gt;\n            (?&amp;lt;quote&amp;gt;   (?&amp;amp;any_quote)  )\n            (?: (?! \\k&amp;lt;quote&amp;gt; ) . ) *\n            \\k&amp;lt;quote&amp;gt;\n        )\n\n        (?&amp;lt;start_tag&amp;gt;       &amp;lt; (?&amp;amp;WS)      )\n        (?&amp;lt;html_end_tag&amp;gt;      &amp;gt;           )\n        (?&amp;lt;xhtml_end_tag&amp;gt;   / &amp;gt;           )\n        (?&amp;lt;end_tag&amp;gt;\n            (?&amp;amp;WS)\n            (?: (?&amp;amp;html_end_tag)\n              | (?&amp;amp;xhtml_end_tag) )\n         )\n\n        (?&amp;lt;tag&amp;gt;\n            (?&amp;amp;start_tag)\n            (?&amp;amp;name)\n            (?:\n                (?&amp;amp;WS)\n                (?&amp;amp;any_nv_pair)\n            ) *\n            (?&amp;amp;end_tag)\n        )\n\n        (?&amp;lt;untag&amp;gt; &amp;lt;/ (?&amp;amp;name) &amp;gt; )\n\n        # starts like a tag, but has screwed up quotes inside it\n        (?&amp;lt;nasty&amp;gt;\n            (?&amp;amp;start_tag)\n            (?&amp;amp;name)\n            .*?\n            (?&amp;amp;end_tag)\n        )\n\n        (?&amp;lt;nontag&amp;gt;    [^&amp;lt;] +            )\n\n        (?&amp;lt;string&amp;gt; (?&amp;amp;quoted_value)     )\n        (?&amp;lt;word&amp;gt;   (?&amp;amp;name)             )\n\n        (?&amp;lt;doctype&amp;gt;\n            &amp;lt;!DOCTYPE\n                # please don&apos;t feed me nonHTML\n                ### (?&amp;amp;WS) HTML\n            [^&amp;gt;]* &amp;gt;\n        )\n\n        (?&amp;lt;cdata&amp;gt;   &amp;lt;!\\[CDATA\\[     .*?     \\]\\]    &amp;gt; )\n        (?&amp;lt;script&amp;gt;  (?= &amp;lt;script ) (?&amp;amp;tag)   .*?     &amp;lt;/script&amp;gt; )\n        (?&amp;lt;style&amp;gt;   (?= &amp;lt;style  ) (?&amp;amp;tag)   .*?     &amp;lt;/style&amp;gt; )\n        (?&amp;lt;comment&amp;gt; &amp;lt;!--            .*?           --&amp;gt; )\n\n        (?&amp;lt;xml&amp;gt;\n            &amp;lt; \\? xml\n            (?:\n                (?&amp;amp;WS)\n                (?&amp;amp;any_nv_pair)\n            ) *\n            (?&amp;amp;WS)\n            \\? &amp;gt;\n        )\n\n        (?&amp;lt;xhook&amp;gt; &amp;lt; \\? .*? \\? &amp;gt; )\n\n      )\n\n    }&lt;/span&gt;six;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;our&lt;/span&gt; $Meta_Tag_Rx = &lt;span class=&quot;hljs-regexp&quot;&gt;qr{                          $RX_SUBS\n        (?&amp;lt;META&amp;gt;\n            (?&amp;amp;start_tag) meta \\b\n            (?:\n                (?&amp;amp;WS) (?&amp;amp;any_nv_pair)\n            ) +\n            (?&amp;amp;end_tag)\n        )\n    }six&lt;/span&gt;;\n\n}\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# nobody *ever* remembers to do this!&lt;/span&gt;\nEND { &lt;span class=&quot;hljs-keyword&quot;&gt;close&lt;/span&gt; STDOUT }\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;ol&gt;\n&lt;li&gt;You can write a novel like tchrist did&lt;/li&gt;\n&lt;li&gt;You can use a DOM library, load the HTML and use xpath and just use &lt;code&gt;//input[@type=&quot;hidden&quot;]&lt;/code&gt;. Or if you don&apos;t want to use xpath, just get all inputs and filter which ones are hidden with &lt;code&gt;getAttribute&lt;/code&gt;.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;I prefer #2.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-html s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;?php\n\n$d = new DOMDocument();\n$d-&amp;gt;loadHTML(\n    &apos;\n    &amp;lt;p&amp;gt;fsdjl&amp;lt;/p&amp;gt;\n    &amp;lt;form&amp;gt;&amp;lt;div&amp;gt;fdsjl&amp;lt;/div&amp;gt;&amp;lt;/form&amp;gt;\n    &amp;lt;input type=&quot;hidden&quot; name=&quot;blah&quot; value=&quot;hide yo kids&quot;&amp;gt;\n    &amp;lt;input type=&quot;text&quot; name=&quot;blah&quot; value=&quot;hide yo kids&quot;&amp;gt;\n    &amp;lt;input type=&quot;hidden&quot; name=&quot;blah&quot; value=&quot;hide yo wife&quot;&amp;gt;\n&apos;);\n$x = new DOMXpath($d);\n$inputs = $x-&amp;gt;evaluate(&apos;//input[@type=&quot;hidden&quot;]&apos;);\n\nforeach ( $inputs as $input ) {\n    echo $input-&amp;gt;getAttribute(&apos;value&apos;), &apos;&amp;lt;br&amp;gt;&apos;;\n}\n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Result:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-html s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;hide yo kids&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;br&lt;/span&gt;&amp;gt;&lt;/span&gt;hide yo wife&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;br&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Contrary to all the answers here, for what you&apos;re trying to do regex is a perfectly valid solution. This is because you are NOT trying to match balanced tags-- THAT would be impossible with regex! But you are only matching what&apos;s in one tag, and that&apos;s perfectly regular.&lt;/p&gt;\n\n&lt;p&gt;Here&apos;s the problem, though. You can&apos;t do it with just one regex... you need to do one match to capture an &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; tag, then do further processing on that. Note that this will only work if none of the attribute values have a &lt;code&gt;&amp;gt;&lt;/code&gt; character in them, so it&apos;s not perfect, but it should suffice for sane inputs.&lt;/p&gt;\n\n&lt;p&gt;Here&apos;s some Perl (pseudo)code to show you what I mean:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-html s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;my $html = readLargeInputFile();\n\nmy @input_tags = $html =~ m/\n    (\n        &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;input&lt;/span&gt;                      # &lt;span class=&quot;hljs-attr&quot;&gt;Starts&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;with&lt;/span&gt; &quot;&amp;lt;&lt;span class=&quot;hljs-attr&quot;&gt;input&lt;/span&gt;&quot;\n        (?=&lt;span class=&quot;hljs-string&quot;&gt;[^&lt;/span&gt;&amp;gt;&lt;/span&gt;]*?type=&quot;hidden&quot;)     # Use lookahead to make sure that type=&quot;hidden&quot;\n        [^&amp;gt;]+                       # Grab the rest of the tag...\n        \\/&amp;gt;                         # ...except for the /&amp;gt;, which is grabbed here\n    )/xgm;\n\n# Now each member of @input_tags is something like &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;hidden&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;SaveRequired&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;False&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;\n\nforeach my $input_tag (@input_tags)\n{\n  my $hash_ref = {};\n  # Now extract each of the fields one at a time.\n\n  ($hash_ref-&amp;gt;{&quot;name&quot;}) = $input_tag =~ /name=&quot;([^&quot;]*)&quot;/;\n  ($hash_ref-&amp;gt;{&quot;value&quot;}) = $input_tag =~ /value=&quot;([^&quot;]*)&quot;/;\n\n  # Put $hash_ref in a list or something, or otherwise process it\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The basic principle here is, don&apos;t try to do too much with one regular expression. As you noticed, regular expressions enforce a certain amount of order. So what you need to do instead is to first match the CONTEXT of what you&apos;re trying to extract, then do submatching on the data you want.&lt;/p&gt;\n\n&lt;p&gt;&lt;b&gt;EDIT:&lt;/b&gt; However, I will agree that in general, using an HTML parser is probably easier and better and you really should consider redesigning your code or re-examining your objectives. :-) But I had to post this answer as a counter to the knee-jerk reaction that parsing any subset of HTML is impossible: HTML and XML are both irregular when you consider the entire specification, but the specification of a tag is decently regular, certainly within the power of PCRE.&lt;/p&gt;\n    ","\n&lt;p&gt;In the spirit of Tom Christiansen&apos;s lexer solution, here&apos;s a link to Robert Cameron&apos;s seemingly forgotten 1998 article, &lt;em&gt;REX: XML Shallow Parsing with Regular Expressions.&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://www.cs.sfu.ca/~cameron/REX.html&quot;&gt;http://www.cs.sfu.ca/~cameron/REX.html&lt;/a&gt;&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Abstract&lt;/p&gt;\n  \n  &lt;p&gt;The syntax of XML is simple enough that it is possible to parse an XML document into a list of its markup and text items using a single regular expression. Such a shallow parse of an XML document can be very useful for the construction of a variety of lightweight XML processing tools. However, complex regular expressions can be difficult to construct and even more difficult to read. Using a form of literate programming for regular expressions, this paper documents a set of XML shallow parsing expressions that can be used a basis for simple, correct, efficient, robust and language-independent XML shallow parsing. Complete shallow parser implementations of less than 50 lines each in Perl, JavaScript and Lex/Flex are also given.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;If you enjoy reading about regular expressions, Cameron&apos;s paper is fascinating. His writing is concise, thorough, and very detailed. He&apos;s not simply showing you how to construct the REX regular expression but also an approach for building up any complex regex from smaller parts.&lt;/p&gt;\n\n&lt;p&gt;I&apos;ve been using the REX regular expression on and off for 10 years to solve the sort of problem the initial poster asked about (how do I match this particular tag but not some other very similar tag?). I&apos;ve found the regex he developed to be completely reliable.&lt;/p&gt;\n\n&lt;p&gt;REX is particularly useful when you&apos;re focusing on lexical details of a document -- for example, when transforming one kind of text document (e.g., plain text, XML, SGML, HTML) into another, where the document may not be valid, well formed, or even parsable for most of the transformation. It lets you target islands of markup anywhere within a document without disturbing the rest of the document.&lt;/p&gt;\n    ","\n&lt;p&gt;While I love the contents of the rest of these answers, they didn&apos;t really answer the question directly or as correctly.  Even Platinum&apos;s answer was overly complicated, and also less efficient.  So I was forced to put this.&lt;/p&gt;\n\n&lt;p&gt;I&apos;m a huge proponent of Regex, when used correctly.  But because of stigma (and performance), I always state that well-formed XML or HTML should use an XML Parser.  And even better performance would be string-parsing, though there&apos;s a line between readability if that gets too out-of-hand.  However, that isn&apos;t the question.  The question is how to match a hidden-type input tag.  The answer is:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-html s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;&amp;lt;input[^&amp;gt;]*type=&quot;hidden&quot;[^&amp;gt;]*&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Depending on your flavor, the only regex option you&apos;d need to include is the ignorecase option.&lt;/p&gt;\n    ","\n&lt;p&gt;you can try this :&lt;/p&gt;\n\n&lt;pre class=&quot;lang-html s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;&amp;lt;[A-Za-z =&quot;/_0-9+]*&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and for closer result you can try this :&lt;/p&gt;\n\n&lt;pre class=&quot;lang-html s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;&amp;lt;[ ]*input[ ]+type=&quot;hidden&quot;[ ]*name=[A-Za-z =&quot;_0-9+]*[ ]*[/]*&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;you can test your regex pattern here &lt;a href=&quot;http://regexpal.com/&quot; rel=&quot;nofollow&quot;&gt;http://regexpal.com/&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;these pattens are good for this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-html s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;hidden&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;SaveRequired&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;False&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;hidden&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;__VIEWSTATE1&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;1H4sIAAtzrkX7QfL5VEGj6nGi+nP&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;hidden&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;__VIEWSTATE2&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;0351118MK&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;hidden&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;__VIEWSTATE3&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;ZVVV91yjY&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;/p&gt;\n\n&lt;p&gt;and for random order of &lt;code&gt;type&lt;/code&gt; , &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; u can use this :&lt;/p&gt;\n\n&lt;pre class=&quot;lang-html s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;&amp;lt;[ ]*input[ ]*[A-Za-z =&quot;_0-9+/]*&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or&lt;/p&gt;\n\n&lt;pre class=&quot;lang-html s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;&amp;lt;[ ]*input[ ]*[A-Za-z =&quot;_0-9+/]*[ ]*[/]&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;on this :&lt;/p&gt;\n\n&lt;pre class=&quot;lang-html s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;input&lt;/span&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;SaveRequired&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;hidden&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;False&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;hidden&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;__VIEWSTATE1&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;1H4sIAAtzrkX7QfL5VEGj6nGi+nP&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;hidden&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;__VIEWSTATE2&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;0351118MK&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;input&lt;/span&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;__VIEWSTATE3&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;hidden&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;ZVVV91yjY&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;\n`&lt;/p&gt;\n\n&lt;p&gt;by the way i think you want something like this :&lt;/p&gt;\n\n&lt;pre class=&quot;lang-html s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;&amp;lt;[ ]*input(([ ]*type=&quot;hidden&quot;[ ]*name=[A-Za-z0-9_+&quot;]*[ ]*value=[A-Za-z0-9_+&quot;]*[ ]*)+)[ ]*/&amp;gt;|&amp;lt;[ ]*input(([ ]*type=&quot;hidden&quot;[ ]*value=[A-Za-z0-9_+&quot;]*[ ]*name=[A-Za-z0-9_+&quot;]*[ ]*)+)[ ]*/&amp;gt;|&amp;lt;[ ]*input(([ ]*name=[A-Za-z0-9_+&quot;]*[ ]*type=&quot;hidden&quot;[ ]*value=[A-Za-z0-9_+&quot;]*[ ]*)+)[ ]*/&amp;gt;|&amp;lt;[ ]*input(([ ]*value=[A-Za-z0-9_+&quot;]*[ ]*type=&quot;hidden&quot;[ ]*name=[A-Za-z0-9_+&quot;]*[ ]*)+)[ ]*/&amp;gt;|&amp;lt;[ ]*input(([ ]*name=[A-Za-z0-9_+&quot;]*[ ]*value=[A-Za-z0-9_+&quot;]*[ ]*type=&quot;hidden&quot;[ ]*)+)[ ]*/&amp;gt;|&amp;lt;[ ]*input(([ ]*value=[A-Za-z0-9_+&quot;]*[ ]*name=[A-Za-z0-9_+&quot;]*[ ]*type=&quot;hidden&quot;[ ]*)+)[ ]*/&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;its not good but it works in any way.&lt;/p&gt;\n\n&lt;p&gt;test it in : &lt;a href=&quot;http://regexpal.com/&quot; rel=&quot;nofollow&quot;&gt;http://regexpal.com/&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;I would like to use &lt;code&gt;**DOMDocument**&lt;/code&gt; to extract the html code.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-html s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;$dom = new DOMDocument();\n$dom -&amp;gt;loadHTML($input);\n$x = new DOMXpath($dom );\n$results = $x-&amp;gt;evaluate(&apos;//input[@type=&quot;hidden&quot;]&apos;);\n\nforeach ( $results as $item) {\n    print_r( $item-&amp;gt;getAttribute(&apos;value&apos;) );\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;BTW, you can test it in here - regex101.com. It shows the result at real time.\nSome rules about Regexp: &lt;a href=&quot;http://www.eclipse.org/tptp/home/downloads/installguide/gla_42/ref/rregexp.html&quot; rel=&quot;nofollow&quot;&gt;http://www.eclipse.org/tptp/home/downloads/installguide/gla_42/ref/rregexp.html&lt;/a&gt;\n&lt;a href=&quot;http://note.taable.com&quot; rel=&quot;nofollow&quot;&gt;Reader&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;suppose your html content is stored in string html then in order to get every input that contain type hidden you can use regular expression&lt;/p&gt;\n\n&lt;pre class=&quot;lang-html s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;var regex = /(&amp;lt;input.*?type\\s?=\\s?[&quot;&apos;]hidden[&quot;&apos;].*?&amp;gt;)/g;\nhtml.match(regex);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;the above regex find &lt;code&gt;&amp;lt;input&lt;/code&gt; followed by any number of characters until it gets &lt;code&gt;type=&quot;hidden&quot;&lt;/code&gt; or type=&apos;hidden&apos; followed by any number of characters till it gets &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;/g tell regular expression to find every substring that matches to the given pattern.&lt;/p&gt;\n    "],"id":471,"title":"What to do Regular expression pattern doesn't match anywhere in string?","content":"\n                \n&lt;p&gt;I am trying to match &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; type “hidden” fields using this pattern:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-html s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;/&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;hidden&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;([^&quot;&lt;/span&gt;]*?)&quot; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;([^&quot;&lt;/span&gt;]*?)&quot; /&amp;gt;&lt;/span&gt;/\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This is sample form data:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-html s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;hidden&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;SaveRequired&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;False&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;hidden&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;__VIEWSTATE1&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;1H4sIAAtzrkX7QfL5VEGj6nGi+nP&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;hidden&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;__VIEWSTATE2&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;0351118MK&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;hidden&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;__VIEWSTATE3&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;ZVVV91yjY&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;hidden&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;__VIEWSTATE0&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;3&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;hidden&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;__VIEWSTATE&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;hidden&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;__VIEWSTATE&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;But I am not sure that the &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt;, and &lt;code&gt;value&lt;/code&gt; attributes will always appear in the same order. If the &lt;code&gt;type&lt;/code&gt; attribute comes last, the match will fail because in my pattern it’s at the start.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt;&lt;br&gt;\nHow can I change my pattern so it will match regardless of the positions of the attributes in the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; tag?&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;P.S.:&lt;/strong&gt; By the way I am using the &lt;em&gt;Adobe Air&lt;/em&gt; based &lt;a href=&quot;http://gskinner.com/RegExr/desktop/&quot; rel=&quot;noreferrer&quot; title=&quot;RegEx Desktop tool&quot;&gt;&lt;em&gt;RegEx Desktop Tool&lt;/em&gt;&lt;/a&gt; for testing regular expressions.&lt;/p&gt;\n    ","slug":"what-to-do-regular-expression-pattern-doesn't-match-anywhere-in-string-1657388095896","postType":"QUESTION","createdAt":"2022-07-09T17:34:55.000Z","updatedAt":"2022-07-09T17:34:55.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"Get the data received in a Flask request","slug":"get-the-data-received-in-a-flask-request-1657387804432"},{"title":"Why are these numbers not equal?","slug":"why-are-these-numbers-not-equal-1657384729559"},{"title":"Object comparison in JavaScript [duplicate]","slug":"object-comparison-in-javascript-duplicate-1657387675463"},{"title":"The Use of Multiple JFrames: Good or Bad Practice? [closed]","slug":"the-use-of-multiple-jframes:-good-or-bad-practice-closed-1657384478184"},{"title":"Why does my function that calls an API or launches a coroutine return an empty or null value?","slug":"why-does-my-function-that-calls-an-api-or-launches-a-coroutine-return-an-empty-or-null-value-1657388483820"},{"title":"RegEx match open tags except XHTML self-contained tags","slug":"regex-match-open-tags-except-xhtml-self-contained-tags-1657384228245"},{"title":"Get the cartesian product of a series of lists?","slug":"get-the-cartesian-product-of-a-series-of-lists-1657387709890"},{"title":"What does \"Fatal error: Unexpectedly found nil while unwrapping an Optional value\" mean?","slug":"what-does-\"fatal-error:-unexpectedly-found-nil-while-unwrapping-an-optional-value\"-mean-1657384593944"},{"title":"How to join (merge) data frames (inner, outer, left, right)","slug":"how-to-join-(merge)-data-frames-(inner-outer-left-right)-1657384406445"},{"title":"What is the difference between a deep copy and a shallow copy?","slug":"what-is-the-difference-between-a-deep-copy-and-a-shallow-copy-1657388445063"},{"title":"What are the nuances of scope prototypal / prototypical inheritance in AngularJS?","slug":"what-are-the-nuances-of-scope-prototypal-prototypical-inheritance-in-angularjs-1657387340067"},{"title":"Deserialize JSON into C# dynamic object?","slug":"deserialize-json-into-c-dynamic-object-1657388568720"},{"title":"What are metaclasses in Python?","slug":"what-are-metaclasses-in-python-1657387811608"},{"title":"How to use variables in SQL statement in Python?","slug":"how-to-use-variables-in-sql-statement-in-python-1657388479077"},{"title":"How do I execute a program or call a system command?","slug":"how-do-i-execute-a-program-or-call-a-system-command-1657385465629"},{"title":"How do I format a date in JavaScript?","slug":"how-do-i-format-a-date-in-javascript-1657384649498"},{"title":"Undefined behavior and sequence points","slug":"undefined-behavior-and-sequence-points-1657384639493"},{"title":"How do I return the response from an asynchronous call?","slug":"how-do-i-return-the-response-from-an-asynchronous-call-1657384208012"},{"title":"What does enctype='multipart/form-data' mean?","slug":"what-does-enctype'multipartform-data'-mean-1657388229352"},{"title":"Iterating over dictionaries using 'for' loops","slug":"iterating-over-dictionaries-using-'for'-loops-1657388334481"}]},"__N_SSG":true}