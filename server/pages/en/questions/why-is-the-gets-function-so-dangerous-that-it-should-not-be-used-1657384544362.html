<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="fgets,buffer-overflow,gets,solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/why-is-the-gets-function-so-dangerous-that-it-should-not-be-used-1657384544362","name":"Questions"}}]}</script><title>Why is the gets function so dangerous that it should not be used? | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="When I try to compile C code that uses the gets() function with GCC, I get this warning: 


  (.text+0x34): warning: the `gets&#x27; function is dangerous and should not be used.


I remember this has something to do with stack protection and security, but I&#x27;m not sure exactly why.

How can I remove this warning and why is there such a warning about using gets()? 

If gets() is so dangerous then why can&#x27;t we remove it?
    "/><meta property="og:title" content="Why is the gets function so dangerous that it should not be used? | Solution Checker"/><meta property="og:description" content="When I try to compile C code that uses the gets() function with GCC, I get this warning: 


  (.text+0x34): warning: the `gets&#x27; function is dangerous and should not be used.


I remember this has something to do with stack protection and security, but I&#x27;m not sure exactly why.

How can I remove this warning and why is there such a warning about using gets()? 

If gets() is so dangerous then why can&#x27;t we remove it?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Why is the gets function so dangerous that it should not be used?","text":"When I try to compile C code that uses the gets() function with GCC, I get this warning: \n\n\n  (.text+0x34): warning: the `gets&apos; function is dangerous and should not be used.\n\n\nI remember this has something to do with stack protection and security, but I&apos;m not sure exactly why.\n\nHow can I remove this warning and why is there such a warning about using gets()? \n\nIf gets() is so dangerous then why can&apos;t we remove it?\n    ","answerCount":13,"upVoteCount":500,"suggestedAnswer":[{"text":"In order to use gets safely, you have to know exactly how many characters you will be reading, so that you can make your buffer large enough. You will only know that if you know exactly what data you will be reading.\nInstead of using gets, you want to use fgets, which has the signature\nchar* fgets(char *string, int length, FILE * stream);\n\n(fgets, if it reads an entire line, will leave the &apos;\\n&apos; in the string; you&apos;ll have to deal with that.)\ngets remained an official part of the language up to the 1999 ISO C standard, but it was officially removed in the 2011 standard. Most C implementations still support it, but at least gcc issues a warning for any code that uses it.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"Why is gets() dangerous\n\nThe first internet worm (the Morris Internet Worm) escaped about 30 years ago (1988-11-02), and it used gets() and a buffer overflow as one of its methods of propagating from system to system. The basic problem is that the function doesn&apos;t know how big the buffer is, so it continues reading until it finds a newline or encounters EOF, and may overflow the bounds of the buffer it was given.\n\nYou should forget you ever heard that gets() existed.\n\nThe C11 standard ISO/IEC 9899:2011 eliminated gets() as a standard function, which is A Good Thing (it was formally marked as &apos;obsolescent&apos; and &apos;deprecated&apos; in ISO/IEC 9899:1999/Cor.3:2007  Technical Corrigendum 3 for C99, and then removed in C11).  Sadly, it will remain in libraries for many years (meaning &apos;decades&apos;) for reasons of backwards compatibility. If it were up to me, the implementation of gets() would become:\n\nchar *gets(char *buffer)\n{\n    assert(buffer != 0);\n    abort();\n    return 0;\n}\n\n\nGiven that your code will crash anyway, sooner or later, it is better to head the trouble off sooner rather than later.  I&apos;d be prepared to add an error message: \n\nfputs(&quot;obsolete and dangerous function gets() called\\n&quot;, stderr);\n\n\nModern versions of the Linux compilation system generates warnings if you link gets()  and also for some other functions that also have security problems (mktemp(), ).\n\nAlternatives to gets()\n\nfgets()\n\nAs everyone else said, the canonical alternative to gets() is fgets() specifying stdin as the file stream.\n\nchar buffer[BUFSIZ];\n\nwhile (fgets(buffer, sizeof(buffer), stdin) != 0)\n{\n    ...process line of data...\n}\n\n\nWhat no-one else yet mentioned is that gets() does not include the newline but fgets() does.  So, you might need to use a wrapper around fgets() that deletes the newline:\n\nchar *fgets_wrapper(char *buffer, size_t buflen, FILE *fp)\n{\n    if (fgets(buffer, buflen, fp) != 0)\n    {\n        size_t len = strlen(buffer);\n        if (len &gt; 0 &amp;&amp; buffer[len-1] == &apos;\\n&apos;)\n            buffer[len-1] = &apos;\\0&apos;;\n        return buffer;\n    }\n    return 0;\n}\n\n\nOr, better:\n\nchar *fgets_wrapper(char *buffer, size_t buflen, FILE *fp)\n{\n    if (fgets(buffer, buflen, fp) != 0)\n    {\n        buffer[strcspn(buffer, &quot;\\n&quot;)] = &apos;\\0&apos;;\n        return buffer;\n    }\n    return 0;\n}\n\n\nAlso, as caf points out in a comment and paxdiablo shows in his answer, with fgets() you might have data left over on a line.  My wrapper code leaves that data to be read next time; you can readily modify it to gobble the rest of the line of data if you prefer:\n\n        if (len &gt; 0 &amp;&amp; buffer[len-1] == &apos;\\n&apos;)\n            buffer[len-1] = &apos;\\0&apos;;\n        else\n        {\n             int ch;\n             while ((ch = getc(fp)) != EOF &amp;&amp; ch != &apos;\\n&apos;)\n                 ;\n        }\n\n\nThe residual problem is how to report the three different result states  EOF or error, line read and not truncated, and partial line read but data was truncated.\n\nThis problem doesn&apos;t arise with gets() because it doesn&apos;t know where your buffer ends and merrily tramples beyond the end, wreaking havoc on your beautifully tended memory layout, often messing up the return stack (a Stack Overflow) if the buffer is allocated on the stack, or trampling over the control information if the buffer is dynamically allocated, or copying data over other precious global (or module) variables if the buffer is statically allocated.  None of these is a good idea  they epitomize the phrase &apos;undefined behaviour`.\n\n\n\nThere is also the TR 24731-1 (Technical Report from the C Standard Committee) which provides safer alternatives to a variety of functions, including gets():\n\n\n  ยง6.5.4.1 The gets_s function\n  \n  Synopsis\n\n#define __STDC_WANT_LIB_EXT1__ 1\n#include &lt;stdio.h&gt;\nchar *gets_s(char *s, rsize_t n);\n\n  \n  Runtime-constraints\n  \n  s shall not be a null pointer. n shall neither be equal to zero nor be greater than\n  RSIZE_MAX. A new-line character, end-of-file, or read error shall occur within reading\n  n-1 characters from stdin.25)\n  \n  3 If there is a runtime-constraint violation, s[0] is set to the null character, and characters\n  are read and discarded from stdin until a new-line character is read, or end-of-file or a\n  read error occurs.\n  \n  Description\n  \n  4 The gets_s function reads at most one less than the number of characters specified by n\n  from the stream pointed to by stdin, into the array pointed to by s. No additional\n  characters are read after a new-line character (which is discarded) or after end-of-file.\n  The discarded new-line character does not count towards number of characters read. A\n  null character is written immediately after the last character read into the array.\n  \n  5 If end-of-file is encountered and no characters have been read into the array, or if a read\n  error occurs during the operation, then s[0] is set to the null character, and the other\n  elements of s take unspecified values.\n  \n  Recommended practice\n  \n  6 The fgets function allows properly-written programs to safely process input lines too\n  long to store in the result array. In general this requires that callers of fgets pay\n  attention to the presence or absence of a new-line character in the result array. Consider\n  using fgets (along with any needed processing based on new-line characters) instead of\n  gets_s.\n  \n  25) The gets_s function, unlike gets, makes it a runtime-constraint violation for a line of input to\n  overflow the buffer to store it. Unlike fgets, gets_s maintains a one-to-one relationship between\n  input lines and successful calls to gets_s. Programs that use gets expect such a relationship.\n\n\nThe Microsoft Visual Studio compilers implement an approximation to the TR 24731-1 standard, but there are differences between the signatures implemented by Microsoft and those in the TR.\n\nThe C11 standard, ISO/IEC 9899-2011, includes TR24731 in Annex K as an optional part of the library. Unfortunately, it is seldom implemented on Unix-like systems.\n\n\n\ngetline()  POSIX\n\nPOSIX 2008 also provides a safe alternative to gets() called getline().  It allocates space for the line dynamically, so you end up needing to free it.  It removes the limitation on line length, therefore. It also returns the length of the data that was read, or -1 (and not EOF!), which means that null bytes in the input can be handled reliably.  There is also a &apos;choose your own single-character delimiter&apos; variation called getdelim(); this can be useful if you are dealing with the output from find -print0 where the ends of the file names are marked with an ASCII NUL &apos;\\0&apos; character, for example.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"Because gets doesn&apos;t do any kind of check while getting bytes from stdin and putting them somewhere. A simple example:\n\nchar array1[] = &quot;12345&quot;;\nchar array2[] = &quot;67890&quot;;\n\ngets(array1);\n\n\nNow, first of all you are allowed to input how many characters you want, gets won&apos;t care about it. Secondly the bytes over the size of the array in which you put them (in this case array1) will overwrite whatever they find in memory because gets will write them. In the previous example this means that if you input &quot;abcdefghijklmnopqrts&quot; maybe, unpredictably, it will overwrite also array2 or whatever.\n\nThe function is unsafe because it assumes consistent input. NEVER USE IT!\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"You should not use gets since it has no way to stop a buffer overflow. If the user types in more data than can fit in your buffer, you will most likely end up with corruption or worse.\n\nIn fact, ISO have actually taken the step of removing gets from the C standard (as of C11, though it was deprecated in C99) which, given how highly they rate backward compatibility, should be an indication of how bad that function was.\n\nThe correct thing to do is to use the fgets function with the stdin file handle since you can limit the characters read from the user.\n\nBut this also has its problems such as:\n\n\nextra characters entered by the user will be picked up the next time around.\nthere&apos;s no quick notification that the user entered too much data.\n\n\nTo that end, almost every C coder at some point in their career will write a more useful wrapper around fgets as well. Here&apos;s mine:\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n#define OK       0\n#define NO_INPUT 1\n#define TOO_LONG 2\nstatic int getLine (char *prmpt, char *buff, size_t sz) {\n    int ch, extra;\n\n    // Get line with buffer overrun protection.\n    if (prmpt != NULL) {\n        printf (&quot;%s&quot;, prmpt);\n        fflush (stdout);\n    }\n    if (fgets (buff, sz, stdin) == NULL)\n        return NO_INPUT;\n\n    // If it was too long, there&apos;ll be no newline. In that case, we flush\n    // to end of line so that excess doesn&apos;t affect the next call.\n    if (buff[strlen(buff)-1] != &apos;\\n&apos;) {\n        extra = 0;\n        while (((ch = getchar()) != &apos;\\n&apos;) &amp;&amp; (ch != EOF))\n            extra = 1;\n        return (extra == 1) ? TOO_LONG : OK;\n    }\n\n    // Otherwise remove newline and give string back to caller.\n    buff[strlen(buff)-1] = &apos;\\0&apos;;\n    return OK;\n}\n\n\nwith some test code:\n\n// Test program for getLine().\n\nint main (void) {\n    int rc;\n    char buff[10];\n\n    rc = getLine (&quot;Enter string&gt; &quot;, buff, sizeof(buff));\n    if (rc == NO_INPUT) {\n        printf (&quot;No input\\n&quot;);\n        return 1;\n    }\n\n    if (rc == TOO_LONG) {\n        printf (&quot;Input too long\\n&quot;);\n        return 1;\n    }\n\n    printf (&quot;OK [%s]\\n&quot;, buff);\n\n    return 0;\n}\n\n\nIt provides the same protections as fgets in that it prevents buffer overflows but it also notifies the caller as to what happened and clears out the excess characters so that they do not affect your next input operation.\n\nFeel free to use it as you wish, I hereby release it under the &quot;do what you damn well want to&quot; licence :-)\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"fgets.\n\nTo read from the stdin:\n\nchar string[512];\n\nfgets(string, sizeof(string), stdin); /* no buffer overflows here, you&apos;re safe! */\n\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"You can&apos;t remove API functions without breaking the API. If you would, many applications would no longer compile or run at all.\n\nThis is the reason that one reference gives:\n\n\n  Reading a line that overflows the\n  array pointed to by s results in\n  undefined behavior. The use of fgets()\n  is recommended.\n\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"I read recently, in a USENET post to comp.lang.c, that gets() is getting removed from the Standard. WOOHOO\n\n\n  You&apos;ll be happy to know that the\n  committee just voted (unanimously, as\n  it turns out) to remove gets() from\n  the draft as well.\n\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"In C11(ISO/IEC 9899:201x), gets() has been removed. (It&apos;s deprecated in ISO/IEC 9899:1999/Cor.3:2007(E))\n\nIn addition to fgets(), C11 introduces a new safe alternative gets_s():\n\n\n  C11 K.3.5.4.1 The gets_s function\n\n#define __STDC_WANT_LIB_EXT1__ 1\n#include &lt;stdio.h&gt;\nchar *gets_s(char *s, rsize_t n);\n\n\n\nHowever, in the Recommended practice section, fgets() is still preferred.\n\n\n  The fgets function allows properly-written programs to safely process input lines too\n  long to store in the result array. In general this requires that callers of fgets pay\n  attention to the presence or absence of a new-line character in the result array. Consider\n  using fgets (along with any needed processing based on new-line characters) instead of\n  gets_s.\n\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"gets() is dangerous because it is possible for the user to crash the program by typing too much into the prompt. It can&apos;t detect the end of available memory, so if you allocate an amount of memory too small for the purpose, it can cause a seg fault and crash. Sometimes it seems very unlikely that a user will type 1000 letters into a prompt meant for a person&apos;s name, but as programmers, we need to make our programs bulletproof. (it may also be a security risk if a user can crash a system program by sending too much data).\n\nfgets() allows you to specify how many characters are taken out of the standard input buffer, so they don&apos;t overrun the variable.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"The C gets function is dangerous and has been a very costly mistake. Tony Hoare singles it out for specific mention in his talk &quot;Null References: The Billion Dollar Mistake&quot;:\n\nhttp://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare\n\nThe whole hour is worth watching but for his comments view from 30 minutes on with the specific gets criticism around 39 minutes.\n\nHopefully this whets your appetite for the whole talk, which draws attention to how we need more formal correctness proofs in languages and how language designers should be blamed for the mistakes in their languages, not the programmer. This seems to have been the whole dubious reason for designers of bad languages to push the blame to programmers in the guise of &apos;programmer freedom&apos;.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"I would like to extend an earnest invitation to any C library maintainers out there who are still including gets in their libraries &quot;just in case anyone is still depending on it&quot;: Please replace your implementation with the equivalent of\n\nchar *gets(char *str)\n{\n    strcpy(str, &quot;Never use gets!&quot;);\n    return str;\n}\n\n\nThis will help make sure nobody is still depending on it.  Thank you.\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"In a few words gets() (can) be dangerous because the user might input something bigger than what the variable has enough space to store. First answer says about fgets() and why it is safer.\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"Additional info:\nFrom man 3 gets on Linux Ubuntu you&apos;ll see (emphasis added):\n\nDESCRIPTION\n       Never use this function.\n\n\nAnd, from the cppreference.com wiki here (https://en.cppreference.com/w/c/io/gets) you&apos;ll see: Notes  Never use gets().:\n\nNotes\nThe gets() function does not perform bounds checking, therefore this function is extremely vulnerable to buffer-overflow attacks. It cannot be used safely (unless the program runs in an environment which restricts what can appear on stdin). For this reason, the function has been deprecated in the third corrigendum to the C99 standard and removed altogether in the C11 standard. fgets() and gets_s() are the recommended replacements.\nNever use gets().\n\nAs you can see, the function has been deprecated and removed entirely in C11 or later.\nUse fgets() or gets_s() instead.\nHere is my demo usage of fgets(), with full error checking:\nFrom read_stdin_fgets_basic_input_from_user.c:\n#include &lt;errno.h&gt;   // `errno`\n#include &lt;stdio.h&gt;   // `printf()`, `fgets()`\n#include &lt;stdlib.h&gt;  // `exit()`\n#include &lt;string.h&gt;  // `strerror()`\n\n// int main(int argc, char *argv[])  // alternative prototype\nint main()\n{\n    char buf[10];\n\n    // NEVER USE `gets()`! USE `fgets()` BELOW INSTEAD!\n\n    // USE THIS!: `fgets()`: &quot;file get string&quot;, which reads until either EOF is\n    // reached, OR a newline (`\\n`) is found, keeping the newline char in\n    // `buf`.\n    // For `feof()` and `ferror()`, see:\n    // 1. https://en.cppreference.com/w/c/io/feof\n    // 1. https://en.cppreference.com/w/c/io/ferror\n    printf(&quot;Enter up to %zu chars: &quot;, sizeof(buf) - 1); // - 1 to save room\n                                                        // for null terminator\n    char* retval = fgets(buf, sizeof(buf), stdin);\n    if (feof(stdin))\n    {\n        // Check for `EOF`, which means &quot;End of File was reached&quot;.\n        // - This doesn&apos;t really make sense on `stdin` I think, but it is a good\n        //   check to have when reading from a regular file with `fgets\n        //   ()`. Keep it here regardless, just in case.\n        printf(&quot;EOF (End of File) reached.\\n&quot;);\n    }\n    if (ferror(stdin))\n    {\n        printf(&quot;Error indicator set. IO error when reading from file &quot;\n               &quot;`stdin`.\\n&quot;);\n    }\n    if (retval == NULL)\n    {\n        printf(&quot;ERROR in %s(): fgets() failed; errno = %i: %s\\n&quot;,\n            __func__, errno, strerror(errno));\n\n        exit(EXIT_FAILURE);\n    }\n\n    size_t num_chars_written = strlen(buf) + 1; // + 1 for null terminator\n    if (num_chars_written &gt;= sizeof(buf))\n    {\n        printf(&quot;Warning: user input may have been truncated! All %zu chars &quot;\n               &quot;were written into buffer.\\n&quot;, num_chars_written);\n    }\n    printf(&quot;You entered \\&quot;%s\\&quot;.\\n&quot;, buf);\n\n\n    return 0;\n}\n\nSample runs and output:\neRCaGuy_hello_world/c$ gcc -Wall -Wextra -Werror -O3 -std=c17 read_stdin_fgets_basic_input_from_user.c -o bin/a &amp;&amp; bin/a\nEnter up to 9 chars: hello world!\nWarning: user input may have been truncated! All 10 chars were written into buffer.\nYou entered &quot;hello wor&quot;.\n\neRCaGuy_hello_world/c$ gcc -Wall -Wextra -Werror -O3 -std=c17 read_stdin_fgets_basic_input_from_user.c -o bin/a &amp;&amp; bin/a\nEnter up to 9 chars: hey\nYou entered &quot;hey\n&quot;.\n\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><link rel="preload" href="/_next/static/css/c116652e2d6f4ad0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c116652e2d6f4ad0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c0d2dcb5e85faf18.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-50e201fdaa1e0fd1.js" defer=""></script><script src="/_next/static/DSpI0pSdXueTMCIVyw0q4/_buildManifest.js" defer=""></script><script src="/_next/static/DSpI0pSdXueTMCIVyw0q4/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/why-is-the-gets-function-so-dangerous-that-it-should-not-be-used-1657384544362#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/why-is-the-gets-function-so-dangerous-that-it-should-not-be-used-1657384544362"><h1>Why is the gets function so dangerous that it should not be used?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/fgets">fgets</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/buffer-overflow">buffer-overflow</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/gets">gets</a></div></div><div class="question-content mt-5">
                
<p>When I try to compile C code that uses the <code>gets()</code> function with GCC, I get this warning: </p>

<blockquote>
  <p>(.text+0x34): warning: the `gets' function is dangerous and should not be used.</p>
</blockquote>

<p>I remember this has something to do with stack protection and security, but I'm not sure exactly why.</p>

<p>How can I remove this warning and why is there such a warning about using <code>gets()</code>? </p>

<p>If <code>gets()</code> is so dangerous then why can't we remove it?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/fgets">fgets</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/buffer-overflow">buffer-overflow</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/gets">gets</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In order to use <code>gets</code> safely, you have to know exactly how many characters you will be reading, so that you can make your buffer large enough. You will only know that if you know exactly what data you will be reading.</p>
<p>Instead of using <code>gets</code>, you want to use <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf" rel="noreferrer"><code>fgets</code></a>, which has the signature</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span>* <span class="hljs-title function_">fgets</span><span class="hljs-params">(<span class="hljs-type">char</span> *<span class="hljs-built_in">string</span>, <span class="hljs-type">int</span> length, FILE * stream)</span>;
</code></pre>
<p>(<code>fgets</code>, if it reads an entire line, will leave the <code>'\n'</code> in the string; you'll have to deal with that.)</p>
<p><code>gets</code> remained an official part of the language up to the 1999 ISO C standard, but it was officially removed in the <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf" rel="noreferrer">2011 standard</a>. Most C implementations still support it, but at least gcc issues a warning for any code that uses it.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/fgets">fgets</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/buffer-overflow">buffer-overflow</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/gets">gets</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>Why is <code>gets()</code> dangerous</h1>

<p>The first internet worm (the <a href="https://en.wikipedia.org/wiki/Morris_worm" rel="noreferrer">Morris Internet Worm</a>) escaped about 30 years ago (1988-11-02), and it used <code>gets()</code> and a buffer overflow as one of its methods of propagating from system to system. The basic problem is that the function doesn't know how big the buffer is, so it continues reading until it finds a newline or encounters EOF, and may overflow the bounds of the buffer it was given.</p>

<p>You should forget you ever heard that <code>gets()</code> existed.</p>

<p>The C11 standard ISO/IEC 9899:2011 eliminated <code>gets()</code> as a standard function, which is A Good Thing (it was formally marked as 'obsolescent' and 'deprecated' in ISO/IEC 9899:1999/Cor.3:2007  Technical Corrigendum 3 for C99, and then removed in C11).  Sadly, it will remain in libraries for many years (meaning 'decades') for reasons of backwards compatibility. If it were up to me, the implementation of <code>gets()</code> would become:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *<span class="hljs-title function_">gets</span><span class="hljs-params">(<span class="hljs-type">char</span> *buffer)</span>
{
    assert(buffer != <span class="hljs-number">0</span>);
    <span class="hljs-built_in">abort</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>Given that your code will crash anyway, sooner or later, it is better to head the trouble off sooner rather than later.  I'd be prepared to add an error message: </p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-built_in">fputs</span>(<span class="hljs-string">"obsolete and dangerous function gets() called\n"</span>, <span class="hljs-built_in">stderr</span>);
</code></pre>

<p>Modern versions of the Linux compilation system generates warnings if you link <code>gets()</code>  and also for some other functions that also have security problems (<code>mktemp()</code>, ).</p>

<h1>Alternatives to <code>gets()</code></h1>

<h2>fgets()</h2>

<p>As everyone else said, the canonical alternative to <code>gets()</code> is <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/fgets.html" rel="noreferrer"><code>fgets()</code></a> specifying <code>stdin</code> as the file stream.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> buffer[BUFSIZ];

<span class="hljs-keyword">while</span> (fgets(buffer, <span class="hljs-keyword">sizeof</span>(buffer), <span class="hljs-built_in">stdin</span>) != <span class="hljs-number">0</span>)
{
    ...process line of data...
}
</code></pre>

<p>What no-one else yet mentioned is that <code>gets()</code> does not include the newline but <code>fgets()</code> does.  So, you might need to use a wrapper around <code>fgets()</code> that deletes the newline:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *<span class="hljs-title function_">fgets_wrapper</span><span class="hljs-params">(<span class="hljs-type">char</span> *buffer, <span class="hljs-type">size_t</span> buflen, FILE *fp)</span>
{
    <span class="hljs-keyword">if</span> (fgets(buffer, buflen, fp) != <span class="hljs-number">0</span>)
    {
        <span class="hljs-type">size_t</span> len = <span class="hljs-built_in">strlen</span>(buffer);
        <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span> &amp;&amp; buffer[len<span class="hljs-number">-1</span>] == <span class="hljs-string">'\n'</span>)
            buffer[len<span class="hljs-number">-1</span>] = <span class="hljs-string">'\0'</span>;
        <span class="hljs-keyword">return</span> buffer;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>Or, better:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *<span class="hljs-title function_">fgets_wrapper</span><span class="hljs-params">(<span class="hljs-type">char</span> *buffer, <span class="hljs-type">size_t</span> buflen, FILE *fp)</span>
{
    <span class="hljs-keyword">if</span> (fgets(buffer, buflen, fp) != <span class="hljs-number">0</span>)
    {
        buffer[<span class="hljs-built_in">strcspn</span>(buffer, <span class="hljs-string">"\n"</span>)] = <span class="hljs-string">'\0'</span>;
        <span class="hljs-keyword">return</span> buffer;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>Also, as <a href="https://stackoverflow.com/users/134633/caf">caf</a> points out in a comment and <a href="https://stackoverflow.com/users/14860/paxdiablo">paxdiablo</a> shows in his answer, with <code>fgets()</code> you might have data left over on a line.  My wrapper code leaves that data to be read next time; you can readily modify it to gobble the rest of the line of data if you prefer:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">        <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span> &amp;&amp; buffer[len<span class="hljs-number">-1</span>] == <span class="hljs-string">'\n'</span>)
            buffer[len<span class="hljs-number">-1</span>] = <span class="hljs-string">'\0'</span>;
        <span class="hljs-keyword">else</span>
        {
             <span class="hljs-type">int</span> ch;
             <span class="hljs-keyword">while</span> ((ch = getc(fp)) != EOF &amp;&amp; ch != <span class="hljs-string">'\n'</span>)
                 ;
        }
</code></pre>

<p>The residual problem is how to report the three different result states  EOF or error, line read and not truncated, and partial line read but data was truncated.</p>

<p>This problem doesn't arise with <code>gets()</code> because it doesn't know where your buffer ends and merrily tramples beyond the end, wreaking havoc on your beautifully tended memory layout, often messing up the return stack (a <a href="https://stackoverflow.com/">Stack Overflow</a>) if the buffer is allocated on the stack, or trampling over the control information if the buffer is dynamically allocated, or copying data over other precious global (or module) variables if the buffer is statically allocated.  None of these is a good idea  they epitomize the phrase 'undefined behaviour`.</p>

<hr>

<p>There is also the <a href="https://stackoverflow.com/questions/372980/do-you-use-the-tr-24731-safe-functions-in-your-c-code">TR 24731-1</a> (Technical Report from the C Standard Committee) which provides safer alternatives to a variety of functions, including <code>gets()</code>:</p>

<blockquote>
  <h2>ยง6.5.4.1 The <code>gets_s</code> function</h2>
  
  <h3>Synopsis</h3>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __STDC_WANT_LIB_EXT1__ 1</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-type">char</span> *<span class="hljs-title function_">gets_s</span><span class="hljs-params">(<span class="hljs-type">char</span> *s, <span class="hljs-type">rsize_t</span> n)</span>;
</code></pre>
  
  <h3>Runtime-constraints</h3>
  
  <p><code>s</code> shall not be a null pointer. <code>n</code> shall neither be equal to zero nor be greater than
  RSIZE_MAX. A new-line character, end-of-file, or read error shall occur within reading
  <code>n-1</code> characters from <code>stdin</code>.<sup>25)</sup></p>
  
  <p>3 If there is a runtime-constraint violation, <code>s[0]</code> is set to the null character, and characters
  are read and discarded from <code>stdin</code> until a new-line character is read, or end-of-file or a
  read error occurs.</p>
  
  <h3>Description</h3>
  
  <p>4 The <code>gets_s</code> function reads at most one less than the number of characters specified by <code>n</code>
  from the stream pointed to by <code>stdin</code>, into the array pointed to by <code>s</code>. No additional
  characters are read after a new-line character (which is discarded) or after end-of-file.
  The discarded new-line character does not count towards number of characters read. A
  null character is written immediately after the last character read into the array.</p>
  
  <p>5 If end-of-file is encountered and no characters have been read into the array, or if a read
  error occurs during the operation, then <code>s[0]</code> is set to the null character, and the other
  elements of <code>s</code> take unspecified values.</p>
  
  <h3>Recommended practice</h3>
  
  <p>6 The <code>fgets</code> function allows properly-written programs to safely process input lines too
  long to store in the result array. In general this requires that callers of <code>fgets</code> pay
  attention to the presence or absence of a new-line character in the result array. Consider
  using <code>fgets</code> (along with any needed processing based on new-line characters) instead of
  <code>gets_s</code>.</p>
  
  <p><sup>25)</sup> The <code>gets_s</code> function, unlike <code>gets</code>, makes it a runtime-constraint violation for a line of input to
  overflow the buffer to store it. Unlike <code>fgets</code>, <code>gets_s</code> maintains a one-to-one relationship between
  input lines and successful calls to <code>gets_s</code>. Programs that use <code>gets</code> expect such a relationship.</p>
</blockquote>

<p>The Microsoft Visual Studio compilers implement an approximation to the TR 24731-1 standard, but there are differences between the signatures implemented by Microsoft and those in the TR.</p>

<p>The C11 standard, ISO/IEC 9899-2011, includes TR24731 in Annex K as an optional part of the library. Unfortunately, it is seldom implemented on Unix-like systems.</p>

<hr>

<h2><code>getline()</code>  POSIX</h2>

<p>POSIX 2008 also provides a safe alternative to <code>gets()</code> called <a href="http://www.opengroup.org/onlinepubs/9699919799/functions/getline.html" rel="noreferrer"><code>getline()</code></a>.  It allocates space for the line dynamically, so you end up needing to free it.  It removes the limitation on line length, therefore. It also returns the length of the data that was read, or <code>-1</code> (and not <code>EOF</code>!), which means that null bytes in the input can be handled reliably.  There is also a 'choose your own single-character delimiter' variation called <code>getdelim()</code>; this can be useful if you are dealing with the output from <code>find -print0</code> where the ends of the file names are marked with an ASCII NUL <code>'\0'</code> character, for example.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/fgets">fgets</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/buffer-overflow">buffer-overflow</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/gets">gets</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Because <code>gets</code> doesn't do any kind of check while getting bytes from <em>stdin</em> and putting them somewhere. A simple example:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> array1[] = <span class="hljs-string">"12345"</span>;
<span class="hljs-type">char</span> array2[] = <span class="hljs-string">"67890"</span>;

gets(array1);
</code></pre>

<p>Now, first of all you are allowed to input how many characters you want, <code>gets</code> won't care about it. Secondly the bytes over the size of the array in which you put them (in this case <code>array1</code>) will overwrite whatever they find in memory because <code>gets</code> will write them. In the previous example this means that if you input <code>"abcdefghijklmnopqrts"</code> maybe, unpredictably, it will overwrite also <code>array2</code> or whatever.</p>

<p>The function is unsafe because it assumes consistent input. <strong>NEVER USE IT!</strong></p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/fgets">fgets</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/buffer-overflow">buffer-overflow</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/gets">gets</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You should not use <code>gets</code> since it has no way to stop a buffer overflow. If the user types in more data than can fit in your buffer, you will most likely end up with corruption or worse.</p>

<p>In fact, ISO have actually taken the step of <em>removing</em> <code>gets</code> from the C standard (as of C11, though it was deprecated in C99) which, given how highly they rate backward compatibility, should be an indication of how bad that function was.</p>

<p>The correct thing to do is to use the <code>fgets</code> function with the <code>stdin</code> file handle since you can limit the characters read from the user.</p>

<p>But this also has its problems such as:</p>

<ul>
<li>extra characters entered by the user will be picked up the next time around.</li>
<li>there's no quick notification that the user entered too much data.</li>
</ul>

<p>To that end, almost every C coder at some point in their career will write a more useful wrapper around <code>fgets</code> as well. Here's mine:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> OK       0</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> NO_INPUT 1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> TOO_LONG 2</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getLine</span> <span class="hljs-params">(<span class="hljs-type">char</span> *prmpt, <span class="hljs-type">char</span> *buff, <span class="hljs-type">size_t</span> sz)</span> {
    <span class="hljs-type">int</span> ch, extra;

    <span class="hljs-comment">// Get line with buffer overrun protection.</span>
    <span class="hljs-keyword">if</span> (prmpt != <span class="hljs-literal">NULL</span>) {
        <span class="hljs-built_in">printf</span> (<span class="hljs-string">"%s"</span>, prmpt);
        fflush (<span class="hljs-built_in">stdout</span>);
    }
    <span class="hljs-keyword">if</span> (fgets (buff, sz, <span class="hljs-built_in">stdin</span>) == <span class="hljs-literal">NULL</span>)
        <span class="hljs-keyword">return</span> NO_INPUT;

    <span class="hljs-comment">// If it was too long, there'll be no newline. In that case, we flush</span>
    <span class="hljs-comment">// to end of line so that excess doesn't affect the next call.</span>
    <span class="hljs-keyword">if</span> (buff[<span class="hljs-built_in">strlen</span>(buff)<span class="hljs-number">-1</span>] != <span class="hljs-string">'\n'</span>) {
        extra = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (((ch = getchar()) != <span class="hljs-string">'\n'</span>) &amp;&amp; (ch != EOF))
            extra = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">return</span> (extra == <span class="hljs-number">1</span>) ? TOO_LONG : OK;
    }

    <span class="hljs-comment">// Otherwise remove newline and give string back to caller.</span>
    buff[<span class="hljs-built_in">strlen</span>(buff)<span class="hljs-number">-1</span>] = <span class="hljs-string">'\0'</span>;
    <span class="hljs-keyword">return</span> OK;
}
</code></pre>

<p>with some test code:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-comment">// Test program for getLine().</span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span> {
    <span class="hljs-type">int</span> rc;
    <span class="hljs-type">char</span> buff[<span class="hljs-number">10</span>];

    rc = getLine (<span class="hljs-string">"Enter string&gt; "</span>, buff, <span class="hljs-keyword">sizeof</span>(buff));
    <span class="hljs-keyword">if</span> (rc == NO_INPUT) {
        <span class="hljs-built_in">printf</span> (<span class="hljs-string">"No input\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }

    <span class="hljs-keyword">if</span> (rc == TOO_LONG) {
        <span class="hljs-built_in">printf</span> (<span class="hljs-string">"Input too long\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }

    <span class="hljs-built_in">printf</span> (<span class="hljs-string">"OK [%s]\n"</span>, buff);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>It provides the same protections as <code>fgets</code> in that it prevents buffer overflows but it also notifies the caller as to what happened and clears out the excess characters so that they do not affect your next input operation.</p>

<p>Feel free to use it as you wish, I hereby release it under the "do what you damn well want to" licence :-)</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/fgets">fgets</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/buffer-overflow">buffer-overflow</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/gets">gets</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><a href="http://www.cplusplus.com/reference/clibrary/cstdio/fgets/" rel="noreferrer">fgets</a>.</p>

<p>To read from the stdin:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> <span class="hljs-built_in">string</span>[<span class="hljs-number">512</span>];

fgets(<span class="hljs-built_in">string</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">string</span>), <span class="hljs-built_in">stdin</span>); <span class="hljs-comment">/* no buffer overflows here, you're safe! */</span>
</code></pre>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 6</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/fgets">fgets</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/buffer-overflow">buffer-overflow</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/gets">gets</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You can't remove API functions without breaking the API. If you would, many applications would no longer compile or run at all.</p>

<p>This is the reason that <a href="http://www.opengroup.org/onlinepubs/009695399/functions/gets.html" rel="noreferrer">one reference</a> gives:</p>

<blockquote>
  <p>Reading a line that overflows the
  array pointed to by s results in
  undefined behavior. The use of fgets()
  is recommended.</p>
</blockquote>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 7</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/fgets">fgets</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/buffer-overflow">buffer-overflow</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/gets">gets</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I read recently, in a <a href="http://groups.google.com/group/comp.lang.c/msg/7e92710bc5ff2ba8" rel="noreferrer">USENET post to <code>comp.lang.c</code></a>, that <code>gets()</code> is getting removed from the Standard. <strong>WOOHOO</strong></p>

<blockquote>
  <p>You'll be happy to know that the
  committee just voted (unanimously, as
  it turns out) to remove gets() from
  the draft as well.</p>
</blockquote>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 8</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/fgets">fgets</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/buffer-overflow">buffer-overflow</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/gets">gets</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In C11(ISO/IEC 9899:201x), <code>gets()</code> has been removed. (It's deprecated in ISO/IEC 9899:1999/Cor.3:2007(E))</p>

<p>In addition to <code>fgets()</code>, C11 introduces a new safe alternative <code>gets_s()</code>:</p>

<blockquote>
  <h3>C11 K.3.5.4.1 The <code>gets_s</code> function</h3>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __STDC_WANT_LIB_EXT1__ 1</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-type">char</span> *<span class="hljs-title function_">gets_s</span><span class="hljs-params">(<span class="hljs-type">char</span> *s, <span class="hljs-type">rsize_t</span> n)</span>;
</code></pre>
</blockquote>

<p>However, in the <em>Recommended practice</em> section, <code>fgets()</code> is still preferred.</p>

<blockquote>
  <p>The <code>fgets</code> function allows properly-written programs to safely process input lines too
  long to store in the result array. In general this requires that callers of <code>fgets</code> pay
  attention to the presence or absence of a new-line character in the result array. Consider
  using <code>fgets</code> (along with any needed processing based on new-line characters) instead of
  <code>gets_s</code>.</p>
</blockquote>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 9</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/fgets">fgets</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/buffer-overflow">buffer-overflow</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/gets">gets</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><code>gets()</code> is dangerous because it is possible for the user to crash the program by typing too much into the prompt. It can't detect the end of available memory, so if you allocate an amount of memory too small for the purpose, it can cause a seg fault and crash. Sometimes it seems very unlikely that a user will type 1000 letters into a prompt meant for a person's name, but as programmers, we need to make our programs bulletproof. (it may also be a security risk if a user can crash a system program by sending too much data).</p>

<p><code>fgets()</code> allows you to specify how many characters are taken out of the standard input buffer, so they don't overrun the variable.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 10</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/fgets">fgets</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/buffer-overflow">buffer-overflow</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/gets">gets</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The C gets function is dangerous and has been a very costly mistake. Tony Hoare singles it out for specific mention in his talk "Null References: The Billion Dollar Mistake":</p>

<p><a href="http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare" rel="nofollow">http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare</a></p>

<p>The whole hour is worth watching but for his comments view from 30 minutes on with the specific gets criticism around 39 minutes.</p>

<p>Hopefully this whets your appetite for the whole talk, which draws attention to how we need more formal correctness proofs in languages and how language designers should be blamed for the mistakes in their languages, not the programmer. This seems to have been the whole dubious reason for designers of bad languages to push the blame to programmers in the guise of 'programmer freedom'.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 11</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/fgets">fgets</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/buffer-overflow">buffer-overflow</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/gets">gets</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I would like to extend an earnest invitation to any C library maintainers out there who are still including <code>gets</code> in their libraries "just in case anyone is still depending on it": Please replace your implementation with the equivalent of</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">char</span> *<span class="hljs-title function_">gets</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span>
{
    <span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">"Never use gets!"</span>);
    <span class="hljs-keyword">return</span> str;
}
</code></pre>

<p>This will help make sure nobody is still depending on it.  Thank you.</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 12</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/fgets">fgets</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/buffer-overflow">buffer-overflow</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/gets">gets</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In a few words <code>gets()</code> (can) be dangerous because the user might input something bigger than what the variable has enough space to store. First answer says about <code>fgets()</code> and why it is safer.</p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 13</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/fgets">fgets</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/buffer-overflow">buffer-overflow</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/gets">gets</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Additional info:</p>
<p>From <code>man 3 gets</code> on Linux Ubuntu you'll see (emphasis added):</p>
<blockquote>
<pre class="lang-c s-code-block"><code class="hljs language-c">DESCRIPTION
       Never use this function.
</code></pre>
</blockquote>
<p>And, from the cppreference.com wiki here (<a href="https://en.cppreference.com/w/c/io/gets" rel="nofollow noreferrer">https://en.cppreference.com/w/c/io/gets</a>) you'll see: <code>Notes  Never use gets().</code>:</p>
<blockquote>
<h2>Notes</h2>
<p>The <code>gets()</code> function does not perform bounds checking, therefore this function is extremely vulnerable to buffer-overflow attacks. It cannot be used safely (unless the program runs in an environment which restricts what can appear on <code>stdin</code>). For this reason, the function has been deprecated in the third corrigendum to the C99 standard and removed altogether in the C11 standard. <code>fgets()</code> and <code>gets_s()</code> are the recommended replacements.</p>
<p><strong>Never use <code>gets()</code>.</strong></p>
</blockquote>
<p>As you can see, the function has been deprecated and removed entirely in C11 or later.</p>
<p>Use <a href="https://en.cppreference.com/w/c/io/fgets" rel="nofollow noreferrer"><code>fgets()</code></a> or <a href="https://en.cppreference.com/w/c/io/gets" rel="nofollow noreferrer"><code>gets_s()</code></a> instead.</p>
<p>Here is my demo usage of <code>fgets()</code>, with full error checking:</p>
<p>From <a href="https://github.com/ElectricRCAircraftGuy/eRCaGuy_hello_world/blob/master/c/read_stdin_fgets_basic_input_from_user.c" rel="nofollow noreferrer"><strong>read_stdin_fgets_basic_input_from_user.c</strong></a>:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span>   <span class="hljs-comment">// `errno`</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>   <span class="hljs-comment">// `printf()`, `fgets()`</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>  <span class="hljs-comment">// `exit()`</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span>  <span class="hljs-comment">// `strerror()`</span></span>

<span class="hljs-comment">// int main(int argc, char *argv[])  // alternative prototype</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>
{
    <span class="hljs-type">char</span> buf[<span class="hljs-number">10</span>];

    <span class="hljs-comment">// NEVER USE `gets()`! USE `fgets()` BELOW INSTEAD!</span>

    <span class="hljs-comment">// USE THIS!: `fgets()`: "file get string", which reads until either EOF is</span>
    <span class="hljs-comment">// reached, OR a newline (`\n`) is found, keeping the newline char in</span>
    <span class="hljs-comment">// `buf`.</span>
    <span class="hljs-comment">// For `feof()` and `ferror()`, see:</span>
    <span class="hljs-comment">// 1. https://en.cppreference.com/w/c/io/feof</span>
    <span class="hljs-comment">// 1. https://en.cppreference.com/w/c/io/ferror</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter up to %zu chars: "</span>, <span class="hljs-keyword">sizeof</span>(buf) - <span class="hljs-number">1</span>); <span class="hljs-comment">// - 1 to save room</span>
                                                        <span class="hljs-comment">// for null terminator</span>
    <span class="hljs-type">char</span>* retval = fgets(buf, <span class="hljs-keyword">sizeof</span>(buf), <span class="hljs-built_in">stdin</span>);
    <span class="hljs-keyword">if</span> (feof(<span class="hljs-built_in">stdin</span>))
    {
        <span class="hljs-comment">// Check for `EOF`, which means "End of File was reached".</span>
        <span class="hljs-comment">// - This doesn't really make sense on `stdin` I think, but it is a good</span>
        <span class="hljs-comment">//   check to have when reading from a regular file with `fgets</span>
        <span class="hljs-comment">//   ()`. Keep it here regardless, just in case.</span>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"EOF (End of File) reached.\n"</span>);
    }
    <span class="hljs-keyword">if</span> (ferror(<span class="hljs-built_in">stdin</span>))
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Error indicator set. IO error when reading from file "</span>
               <span class="hljs-string">"`stdin`.\n"</span>);
    }
    <span class="hljs-keyword">if</span> (retval == <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"ERROR in %s(): fgets() failed; errno = %i: %s\n"</span>,
            __func__, errno, strerror(errno));

        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);
    }

    <span class="hljs-type">size_t</span> num_chars_written = <span class="hljs-built_in">strlen</span>(buf) + <span class="hljs-number">1</span>; <span class="hljs-comment">// + 1 for null terminator</span>
    <span class="hljs-keyword">if</span> (num_chars_written &gt;= <span class="hljs-keyword">sizeof</span>(buf))
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Warning: user input may have been truncated! All %zu chars "</span>
               <span class="hljs-string">"were written into buffer.\n"</span>, num_chars_written);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"You entered \"%s\".\n"</span>, buf);


    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>Sample runs and output:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">eRCaGuy_hello_world/c$ gcc -Wall -Wextra -Werror -O3 -<span class="hljs-built_in">std</span>=c17 read_stdin_fgets_basic_input_from_user.c -o bin/a &amp;&amp; bin/a
Enter up to <span class="hljs-number">9</span> chars: hello world!
Warning: user input may have been truncated! All <span class="hljs-number">10</span> chars were written into buffer.
You entered <span class="hljs-string">"hello wor"</span>.

eRCaGuy_hello_world/c$ gcc -Wall -Wextra -Werror -O3 -<span class="hljs-built_in">std</span>=c17 read_stdin_fgets_basic_input_from_user.c -o bin/a &amp;&amp; bin/a
Enter up to <span class="hljs-number">9</span> chars: hey
You entered <span class="hljs-string">"hey
"</span>.
</code></pre>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/how-do-javascript-closures-work-1657384418555">How do JavaScript closures work?</a><a href="/questions/how-do-i-properly-compare-strings-in-c-1657387467202">How do I properly compare strings in C?</a><a href="/questions/relative-imports-for-the-billionth-time-1657387756383">Relative imports for the billionth time</a><a href="/questions/how-do-i-set-a-variable-to-the-output-of-a-command-in-bash-1657387250909">How do I set a variable to the output of a command in Bash?</a><a href="/questions/how-to-filter-object-array-based-on-attributes-1657388211247">How to filter object array based on attributes?</a><a href="/questions/what-is-a-stackoverflowerror-1657388319634">What is a StackOverflowError?</a><a href="/questions/why-is-using-&#x27;eval&#x27;-a-bad-practice-1657387348760">Why is using &#x27;eval&#x27; a bad practice?</a><a href="/questions/preview-an-image-before-it-is-uploaded-1657388048128">Preview an image before it is uploaded</a><a href="/questions/how-do-i-detect-a-click-outside-an-element-1657387505351">How do I detect a click outside an element?</a><a href="/questions/javascript-function-doesn&#x27;t-work-when-link-is-clicked-1657387767488">javascript function doesn&#x27;t work when link is clicked</a><a href="/questions/how-do-i-undo-the-most-recent-local-commits-in-git-1657388262945">How do I undo the most recent local commits in Git?</a><a href="/questions/how-to-removedelete-a-large-file-from-commit-history-in-the-git-repository-1657387589093">How to remove/delete a large file from commit history in the Git repository?</a><a href="/questions/non-static-variable-cannot-be-referenced-from-a-static-context-1657387386240">Non-static variable cannot be referenced from a static context</a><a href="/questions/get-all-unique-values-in-a-javascript-array-(remove-duplicates)-1657387435296">Get all unique values in a JavaScript array (remove duplicates)</a><a href="/questions/how-to-compare-arrays-in-javascript-1657387352277">How to compare arrays in JavaScript?</a><a href="/questions/convert-form-data-to-javascript-object-with-jquery-1657388036834">Convert form data to JavaScript object with jQuery</a><a href="/questions/how-can-i-find-the-time-complexity-of-an-algorithm-1657388486001">How can I find the time complexity of an algorithm?</a><a href="/questions/what-is-event-bubbling-and-capturing-1657388059203">What is event bubbling and capturing?</a><a href="/questions/flexbox:-center-horizontally-and-vertically-1657384587888">Flexbox: center horizontally and vertically</a><a href="/questions/what-is-a-debugger-and-how-can-it-help-me-diagnose-problems-1657384472469">What is a debugger and how can it help me diagnose problems?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;In order to use \u0026lt;code\u0026gt;gets\u0026lt;/code\u0026gt; safely, you have to know exactly how many characters you will be reading, so that you can make your buffer large enough. You will only know that if you know exactly what data you will be reading.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Instead of using \u0026lt;code\u0026gt;gets\u0026lt;/code\u0026gt;, you want to use \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;fgets\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;, which has the signature\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;fgets\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; length, FILE * stream)\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;(\u0026lt;code\u0026gt;fgets\u0026lt;/code\u0026gt;, if it reads an entire line, will leave the \u0026lt;code\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/code\u0026gt; in the string; you\u0026apos;ll have to deal with that.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;gets\u0026lt;/code\u0026gt; remained an official part of the language up to the 1999 ISO C standard, but it was officially removed in the \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;2011 standard\u0026lt;/a\u0026gt;. Most C implementations still support it, but at least gcc issues a warning for any code that uses it.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;Why is \u0026lt;code\u0026gt;gets()\u0026lt;/code\u0026gt; dangerous\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;The first internet worm (the \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Morris_worm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Morris Internet Worm\u0026lt;/a\u0026gt;) escaped about 30 years ago (1988-11-02), and it used \u0026lt;code\u0026gt;gets()\u0026lt;/code\u0026gt; and a buffer overflow as one of its methods of propagating from system to system. The basic problem is that the function doesn\u0026apos;t know how big the buffer is, so it continues reading until it finds a newline or encounters EOF, and may overflow the bounds of the buffer it was given.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You should forget you ever heard that \u0026lt;code\u0026gt;gets()\u0026lt;/code\u0026gt; existed.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The C11 standard ISO/IEC 9899:2011 eliminated \u0026lt;code\u0026gt;gets()\u0026lt;/code\u0026gt; as a standard function, which is A Good Thing (it was formally marked as \u0026apos;obsolescent\u0026apos; and \u0026apos;deprecated\u0026apos; in ISO/IEC 9899:1999/Cor.3:2007  Technical Corrigendum 3 for C99, and then removed in C11).  Sadly, it will remain in libraries for many years (meaning \u0026apos;decades\u0026apos;) for reasons of backwards compatibility. If it were up to me, the implementation of \u0026lt;code\u0026gt;gets()\u0026lt;/code\u0026gt; would become:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;gets\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *buffer)\u0026lt;/span\u0026gt;\n{\n    assert(buffer != \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;abort\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Given that your code will crash anyway, sooner or later, it is better to head the trouble off sooner rather than later.  I\u0026apos;d be prepared to add an error message: \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fputs\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;obsolete and dangerous function gets() called\\n\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stderr\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Modern versions of the Linux compilation system generates warnings if you link \u0026lt;code\u0026gt;gets()\u0026lt;/code\u0026gt;  and also for some other functions that also have security problems (\u0026lt;code\u0026gt;mktemp()\u0026lt;/code\u0026gt;, ).\u0026lt;/p\u0026gt;\n\n\u0026lt;h1\u0026gt;Alternatives to \u0026lt;code\u0026gt;gets()\u0026lt;/code\u0026gt;\u0026lt;/h1\u0026gt;\n\n\u0026lt;h2\u0026gt;fgets()\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;As everyone else said, the canonical alternative to \u0026lt;code\u0026gt;gets()\u0026lt;/code\u0026gt; is \u0026lt;a href=\u0026quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fgets.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;fgets()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; specifying \u0026lt;code\u0026gt;stdin\u0026lt;/code\u0026gt; as the file stream.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; buffer[BUFSIZ];\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (fgets(buffer, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(buffer), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stdin\u0026lt;/span\u0026gt;) != \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n{\n    ...process line of data...\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;What no-one else yet mentioned is that \u0026lt;code\u0026gt;gets()\u0026lt;/code\u0026gt; does not include the newline but \u0026lt;code\u0026gt;fgets()\u0026lt;/code\u0026gt; does.  So, you might need to use a wrapper around \u0026lt;code\u0026gt;fgets()\u0026lt;/code\u0026gt; that deletes the newline:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;fgets_wrapper\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *buffer, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; buflen, FILE *fp)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (fgets(buffer, buflen, fp) != \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n    {\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; len = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(buffer);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (len \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; buffer[len\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;)\n            buffer[len\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; buffer;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Or, better:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;fgets_wrapper\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *buffer, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; buflen, FILE *fp)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (fgets(buffer, buflen, fp) != \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n    {\n        buffer[\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strcspn\u0026lt;/span\u0026gt;(buffer, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;)] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; buffer;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Also, as \u0026lt;a href=\u0026quot;https://stackoverflow.com/users/134633/caf\u0026quot;\u0026gt;caf\u0026lt;/a\u0026gt; points out in a comment and \u0026lt;a href=\u0026quot;https://stackoverflow.com/users/14860/paxdiablo\u0026quot;\u0026gt;paxdiablo\u0026lt;/a\u0026gt; shows in his answer, with \u0026lt;code\u0026gt;fgets()\u0026lt;/code\u0026gt; you might have data left over on a line.  My wrapper code leaves that data to be read next time; you can readily modify it to gobble the rest of the line of data if you prefer:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (len \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; buffer[len\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;)\n            buffer[len\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n        {\n             \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; ch;\n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; ((ch = getc(fp)) != EOF \u0026amp;amp;\u0026amp;amp; ch != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;)\n                 ;\n        }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The residual problem is how to report the three different result states  EOF or error, line read and not truncated, and partial line read but data was truncated.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This problem doesn\u0026apos;t arise with \u0026lt;code\u0026gt;gets()\u0026lt;/code\u0026gt; because it doesn\u0026apos;t know where your buffer ends and merrily tramples beyond the end, wreaking havoc on your beautifully tended memory layout, often messing up the return stack (a \u0026lt;a href=\u0026quot;https://stackoverflow.com/\u0026quot;\u0026gt;Stack Overflow\u0026lt;/a\u0026gt;) if the buffer is allocated on the stack, or trampling over the control information if the buffer is dynamically allocated, or copying data over other precious global (or module) variables if the buffer is statically allocated.  None of these is a good idea  they epitomize the phrase \u0026apos;undefined behaviour`.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;There is also the \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/372980/do-you-use-the-tr-24731-safe-functions-in-your-c-code\u0026quot;\u0026gt;TR 24731-1\u0026lt;/a\u0026gt; (Technical Report from the C Standard Committee) which provides safer alternatives to a variety of functions, including \u0026lt;code\u0026gt;gets()\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;h2\u0026gt;ยง6.5.4.1 The \u0026lt;code\u0026gt;gets_s\u0026lt;/code\u0026gt; function\u0026lt;/h2\u0026gt;\n  \n  \u0026lt;h3\u0026gt;Synopsis\u0026lt;/h3\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; __STDC_WANT_LIB_EXT1__ 1\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;gets_s\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;rsize_t\u0026lt;/span\u0026gt; n)\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n  \n  \u0026lt;h3\u0026gt;Runtime-constraints\u0026lt;/h3\u0026gt;\n  \n  \u0026lt;p\u0026gt;\u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; shall not be a null pointer. \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt; shall neither be equal to zero nor be greater than\n  RSIZE_MAX. A new-line character, end-of-file, or read error shall occur within reading\n  \u0026lt;code\u0026gt;n-1\u0026lt;/code\u0026gt; characters from \u0026lt;code\u0026gt;stdin\u0026lt;/code\u0026gt;.\u0026lt;sup\u0026gt;25)\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;3 If there is a runtime-constraint violation, \u0026lt;code\u0026gt;s[0]\u0026lt;/code\u0026gt; is set to the null character, and characters\n  are read and discarded from \u0026lt;code\u0026gt;stdin\u0026lt;/code\u0026gt; until a new-line character is read, or end-of-file or a\n  read error occurs.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;h3\u0026gt;Description\u0026lt;/h3\u0026gt;\n  \n  \u0026lt;p\u0026gt;4 The \u0026lt;code\u0026gt;gets_s\u0026lt;/code\u0026gt; function reads at most one less than the number of characters specified by \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt;\n  from the stream pointed to by \u0026lt;code\u0026gt;stdin\u0026lt;/code\u0026gt;, into the array pointed to by \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt;. No additional\n  characters are read after a new-line character (which is discarded) or after end-of-file.\n  The discarded new-line character does not count towards number of characters read. A\n  null character is written immediately after the last character read into the array.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;5 If end-of-file is encountered and no characters have been read into the array, or if a read\n  error occurs during the operation, then \u0026lt;code\u0026gt;s[0]\u0026lt;/code\u0026gt; is set to the null character, and the other\n  elements of \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt; take unspecified values.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;h3\u0026gt;Recommended practice\u0026lt;/h3\u0026gt;\n  \n  \u0026lt;p\u0026gt;6 The \u0026lt;code\u0026gt;fgets\u0026lt;/code\u0026gt; function allows properly-written programs to safely process input lines too\n  long to store in the result array. In general this requires that callers of \u0026lt;code\u0026gt;fgets\u0026lt;/code\u0026gt; pay\n  attention to the presence or absence of a new-line character in the result array. Consider\n  using \u0026lt;code\u0026gt;fgets\u0026lt;/code\u0026gt; (along with any needed processing based on new-line characters) instead of\n  \u0026lt;code\u0026gt;gets_s\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;25)\u0026lt;/sup\u0026gt; The \u0026lt;code\u0026gt;gets_s\u0026lt;/code\u0026gt; function, unlike \u0026lt;code\u0026gt;gets\u0026lt;/code\u0026gt;, makes it a runtime-constraint violation for a line of input to\n  overflow the buffer to store it. Unlike \u0026lt;code\u0026gt;fgets\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;gets_s\u0026lt;/code\u0026gt; maintains a one-to-one relationship between\n  input lines and successful calls to \u0026lt;code\u0026gt;gets_s\u0026lt;/code\u0026gt;. Programs that use \u0026lt;code\u0026gt;gets\u0026lt;/code\u0026gt; expect such a relationship.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;The Microsoft Visual Studio compilers implement an approximation to the TR 24731-1 standard, but there are differences between the signatures implemented by Microsoft and those in the TR.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The C11 standard, ISO/IEC 9899-2011, includes TR24731 in Annex K as an optional part of the library. Unfortunately, it is seldom implemented on Unix-like systems.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h2\u0026gt;\u0026lt;code\u0026gt;getline()\u0026lt;/code\u0026gt;  POSIX\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;POSIX 2008 also provides a safe alternative to \u0026lt;code\u0026gt;gets()\u0026lt;/code\u0026gt; called \u0026lt;a href=\u0026quot;http://www.opengroup.org/onlinepubs/9699919799/functions/getline.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;getline()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;.  It allocates space for the line dynamically, so you end up needing to free it.  It removes the limitation on line length, therefore. It also returns the length of the data that was read, or \u0026lt;code\u0026gt;-1\u0026lt;/code\u0026gt; (and not \u0026lt;code\u0026gt;EOF\u0026lt;/code\u0026gt;!), which means that null bytes in the input can be handled reliably.  There is also a \u0026apos;choose your own single-character delimiter\u0026apos; variation called \u0026lt;code\u0026gt;getdelim()\u0026lt;/code\u0026gt;; this can be useful if you are dealing with the output from \u0026lt;code\u0026gt;find -print0\u0026lt;/code\u0026gt; where the ends of the file names are marked with an ASCII NUL \u0026lt;code\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/code\u0026gt; character, for example.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Because \u0026lt;code\u0026gt;gets\u0026lt;/code\u0026gt; doesn\u0026apos;t do any kind of check while getting bytes from \u0026lt;em\u0026gt;stdin\u0026lt;/em\u0026gt; and putting them somewhere. A simple example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; array1[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;12345\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; array2[] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;67890\u0026quot;\u0026lt;/span\u0026gt;;\n\ngets(array1);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now, first of all you are allowed to input how many characters you want, \u0026lt;code\u0026gt;gets\u0026lt;/code\u0026gt; won\u0026apos;t care about it. Secondly the bytes over the size of the array in which you put them (in this case \u0026lt;code\u0026gt;array1\u0026lt;/code\u0026gt;) will overwrite whatever they find in memory because \u0026lt;code\u0026gt;gets\u0026lt;/code\u0026gt; will write them. In the previous example this means that if you input \u0026lt;code\u0026gt;\u0026quot;abcdefghijklmnopqrts\u0026quot;\u0026lt;/code\u0026gt; maybe, unpredictably, it will overwrite also \u0026lt;code\u0026gt;array2\u0026lt;/code\u0026gt; or whatever.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The function is unsafe because it assumes consistent input. \u0026lt;strong\u0026gt;NEVER USE IT!\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You should not use \u0026lt;code\u0026gt;gets\u0026lt;/code\u0026gt; since it has no way to stop a buffer overflow. If the user types in more data than can fit in your buffer, you will most likely end up with corruption or worse.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In fact, ISO have actually taken the step of \u0026lt;em\u0026gt;removing\u0026lt;/em\u0026gt; \u0026lt;code\u0026gt;gets\u0026lt;/code\u0026gt; from the C standard (as of C11, though it was deprecated in C99) which, given how highly they rate backward compatibility, should be an indication of how bad that function was.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The correct thing to do is to use the \u0026lt;code\u0026gt;fgets\u0026lt;/code\u0026gt; function with the \u0026lt;code\u0026gt;stdin\u0026lt;/code\u0026gt; file handle since you can limit the characters read from the user.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But this also has its problems such as:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;extra characters entered by the user will be picked up the next time around.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;there\u0026apos;s no quick notification that the user entered too much data.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;To that end, almost every C coder at some point in their career will write a more useful wrapper around \u0026lt;code\u0026gt;fgets\u0026lt;/code\u0026gt; as well. Here\u0026apos;s mine:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; OK       0\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; NO_INPUT 1\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; TOO_LONG 2\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getLine\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *prmpt, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *buff, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; sz)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; ch, extra;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Get line with buffer overrun protection.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (prmpt != \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%s\u0026quot;\u0026lt;/span\u0026gt;, prmpt);\n        fflush (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stdout\u0026lt;/span\u0026gt;);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (fgets (buff, sz, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stdin\u0026lt;/span\u0026gt;) == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; NO_INPUT;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// If it was too long, there\u0026apos;ll be no newline. In that case, we flush\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// to end of line so that excess doesn\u0026apos;t affect the next call.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (buff[\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(buff)\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;] != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;) {\n        extra = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (((ch = getchar()) != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;) \u0026amp;amp;\u0026amp;amp; (ch != EOF))\n            extra = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (extra == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) ? TOO_LONG : OK;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Otherwise remove newline and give string back to caller.\u0026lt;/span\u0026gt;\n    buff[\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(buff)\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; OK;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;with some test code:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Test program for getLine().\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; rc;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; buff[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;];\n\n    rc = getLine (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Enter string\u0026amp;gt; \u0026quot;\u0026lt;/span\u0026gt;, buff, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(buff));\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (rc == NO_INPUT) {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;No input\\n\u0026quot;\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (rc == TOO_LONG) {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Input too long\\n\u0026quot;\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;OK [%s]\\n\u0026quot;\u0026lt;/span\u0026gt;, buff);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It provides the same protections as \u0026lt;code\u0026gt;fgets\u0026lt;/code\u0026gt; in that it prevents buffer overflows but it also notifies the caller as to what happened and clears out the excess characters so that they do not affect your next input operation.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Feel free to use it as you wish, I hereby release it under the \u0026quot;do what you damn well want to\u0026quot; licence :-)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://www.cplusplus.com/reference/clibrary/cstdio/fgets/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;fgets\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To read from the stdin:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;512\u0026lt;/span\u0026gt;];\n\nfgets(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stdin\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* no buffer overflows here, you\u0026apos;re safe! */\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You can\u0026apos;t remove API functions without breaking the API. If you would, many applications would no longer compile or run at all.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is the reason that \u0026lt;a href=\u0026quot;http://www.opengroup.org/onlinepubs/009695399/functions/gets.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;one reference\u0026lt;/a\u0026gt; gives:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Reading a line that overflows the\n  array pointed to by s results in\n  undefined behavior. The use of fgets()\n  is recommended.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I read recently, in a \u0026lt;a href=\u0026quot;http://groups.google.com/group/comp.lang.c/msg/7e92710bc5ff2ba8\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;USENET post to \u0026lt;code\u0026gt;comp.lang.c\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;, that \u0026lt;code\u0026gt;gets()\u0026lt;/code\u0026gt; is getting removed from the Standard. \u0026lt;strong\u0026gt;WOOHOO\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;You\u0026apos;ll be happy to know that the\n  committee just voted (unanimously, as\n  it turns out) to remove gets() from\n  the draft as well.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In C11(ISO/IEC 9899:201x), \u0026lt;code\u0026gt;gets()\u0026lt;/code\u0026gt; has been removed. (It\u0026apos;s deprecated in ISO/IEC 9899:1999/Cor.3:2007(E))\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In addition to \u0026lt;code\u0026gt;fgets()\u0026lt;/code\u0026gt;, C11 introduces a new safe alternative \u0026lt;code\u0026gt;gets_s()\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;h3\u0026gt;C11 K.3.5.4.1 The \u0026lt;code\u0026gt;gets_s\u0026lt;/code\u0026gt; function\u0026lt;/h3\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; __STDC_WANT_LIB_EXT1__ 1\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;gets_s\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *s, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;rsize_t\u0026lt;/span\u0026gt; n)\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;However, in the \u0026lt;em\u0026gt;Recommended practice\u0026lt;/em\u0026gt; section, \u0026lt;code\u0026gt;fgets()\u0026lt;/code\u0026gt; is still preferred.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;fgets\u0026lt;/code\u0026gt; function allows properly-written programs to safely process input lines too\n  long to store in the result array. In general this requires that callers of \u0026lt;code\u0026gt;fgets\u0026lt;/code\u0026gt; pay\n  attention to the presence or absence of a new-line character in the result array. Consider\n  using \u0026lt;code\u0026gt;fgets\u0026lt;/code\u0026gt; (along with any needed processing based on new-line characters) instead of\n  \u0026lt;code\u0026gt;gets_s\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;gets()\u0026lt;/code\u0026gt; is dangerous because it is possible for the user to crash the program by typing too much into the prompt. It can\u0026apos;t detect the end of available memory, so if you allocate an amount of memory too small for the purpose, it can cause a seg fault and crash. Sometimes it seems very unlikely that a user will type 1000 letters into a prompt meant for a person\u0026apos;s name, but as programmers, we need to make our programs bulletproof. (it may also be a security risk if a user can crash a system program by sending too much data).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;fgets()\u0026lt;/code\u0026gt; allows you to specify how many characters are taken out of the standard input buffer, so they don\u0026apos;t overrun the variable.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The C gets function is dangerous and has been a very costly mistake. Tony Hoare singles it out for specific mention in his talk \u0026quot;Null References: The Billion Dollar Mistake\u0026quot;:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The whole hour is worth watching but for his comments view from 30 minutes on with the specific gets criticism around 39 minutes.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Hopefully this whets your appetite for the whole talk, which draws attention to how we need more formal correctness proofs in languages and how language designers should be blamed for the mistakes in their languages, not the programmer. This seems to have been the whole dubious reason for designers of bad languages to push the blame to programmers in the guise of \u0026apos;programmer freedom\u0026apos;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I would like to extend an earnest invitation to any C library maintainers out there who are still including \u0026lt;code\u0026gt;gets\u0026lt;/code\u0026gt; in their libraries \u0026quot;just in case anyone is still depending on it\u0026quot;: Please replace your implementation with the equivalent of\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;gets\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *str)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strcpy\u0026lt;/span\u0026gt;(str, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Never use gets!\u0026quot;\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; str;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This will help make sure nobody is still depending on it.  Thank you.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In a few words \u0026lt;code\u0026gt;gets()\u0026lt;/code\u0026gt; (can) be dangerous because the user might input something bigger than what the variable has enough space to store. First answer says about \u0026lt;code\u0026gt;fgets()\u0026lt;/code\u0026gt; and why it is safer.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Additional info:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;From \u0026lt;code\u0026gt;man 3 gets\u0026lt;/code\u0026gt; on Linux Ubuntu you\u0026apos;ll see (emphasis added):\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;DESCRIPTION\n       Never use this function.\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;And, from the cppreference.com wiki here (\u0026lt;a href=\u0026quot;https://en.cppreference.com/w/c/io/gets\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://en.cppreference.com/w/c/io/gets\u0026lt;/a\u0026gt;) you\u0026apos;ll see: \u0026lt;code\u0026gt;Notes  Never use gets().\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;h2\u0026gt;Notes\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;gets()\u0026lt;/code\u0026gt; function does not perform bounds checking, therefore this function is extremely vulnerable to buffer-overflow attacks. It cannot be used safely (unless the program runs in an environment which restricts what can appear on \u0026lt;code\u0026gt;stdin\u0026lt;/code\u0026gt;). For this reason, the function has been deprecated in the third corrigendum to the C99 standard and removed altogether in the C11 standard. \u0026lt;code\u0026gt;fgets()\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;gets_s()\u0026lt;/code\u0026gt; are the recommended replacements.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Never use \u0026lt;code\u0026gt;gets()\u0026lt;/code\u0026gt;.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;As you can see, the function has been deprecated and removed entirely in C11 or later.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Use \u0026lt;a href=\u0026quot;https://en.cppreference.com/w/c/io/fgets\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;fgets()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; or \u0026lt;a href=\u0026quot;https://en.cppreference.com/w/c/io/gets\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;gets_s()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; instead.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Here is my demo usage of \u0026lt;code\u0026gt;fgets()\u0026lt;/code\u0026gt;, with full error checking:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;From \u0026lt;a href=\u0026quot;https://github.com/ElectricRCAircraftGuy/eRCaGuy_hello_world/blob/master/c/read_stdin_fgets_basic_input_from_user.c\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;read_stdin_fgets_basic_input_from_user.c\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;errno.h\u0026amp;gt;\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// `errno`\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// `printf()`, `fgets()`\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdlib.h\u0026amp;gt;\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// `exit()`\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string.h\u0026amp;gt;\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// `strerror()`\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// int main(int argc, char *argv[])  // alternative prototype\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; buf[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;];\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// NEVER USE `gets()`! USE `fgets()` BELOW INSTEAD!\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// USE THIS!: `fgets()`: \u0026quot;file get string\u0026quot;, which reads until either EOF is\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// reached, OR a newline (`\\n`) is found, keeping the newline char in\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// `buf`.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// For `feof()` and `ferror()`, see:\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 1. https://en.cppreference.com/w/c/io/feof\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 1. https://en.cppreference.com/w/c/io/ferror\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Enter up to %zu chars: \u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(buf) - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// - 1 to save room\u0026lt;/span\u0026gt;\n                                                        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// for null terminator\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* retval = fgets(buf, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(buf), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stdin\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (feof(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stdin\u0026lt;/span\u0026gt;))\n    {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Check for `EOF`, which means \u0026quot;End of File was reached\u0026quot;.\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// - This doesn\u0026apos;t really make sense on `stdin` I think, but it is a good\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//   check to have when reading from a regular file with `fgets\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//   ()`. Keep it here regardless, just in case.\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;EOF (End of File) reached.\\n\u0026quot;\u0026lt;/span\u0026gt;);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (ferror(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stdin\u0026lt;/span\u0026gt;))\n    {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Error indicator set. IO error when reading from file \u0026quot;\u0026lt;/span\u0026gt;\n               \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;`stdin`.\\n\u0026quot;\u0026lt;/span\u0026gt;);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (retval == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;)\n    {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;ERROR in %s(): fgets() failed; errno = %i: %s\\n\u0026quot;\u0026lt;/span\u0026gt;,\n            __func__, errno, strerror(errno));\n\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;exit\u0026lt;/span\u0026gt;(EXIT_FAILURE);\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; num_chars_written = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(buf) + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// + 1 for null terminator\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (num_chars_written \u0026amp;gt;= \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(buf))\n    {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Warning: user input may have been truncated! All %zu chars \u0026quot;\u0026lt;/span\u0026gt;\n               \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;were written into buffer.\\n\u0026quot;\u0026lt;/span\u0026gt;, num_chars_written);\n    }\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;You entered \\\u0026quot;%s\\\u0026quot;.\\n\u0026quot;\u0026lt;/span\u0026gt;, buf);\n\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Sample runs and output:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;eRCaGuy_hello_world/c$ gcc -Wall -Wextra -Werror -O3 -\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;=c17 read_stdin_fgets_basic_input_from_user.c -o bin/a \u0026amp;amp;\u0026amp;amp; bin/a\nEnter up to \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt; chars: hello world!\nWarning: user input may have been truncated! All \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt; chars were written into buffer.\nYou entered \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello wor\u0026quot;\u0026lt;/span\u0026gt;.\n\neRCaGuy_hello_world/c$ gcc -Wall -Wextra -Werror -O3 -\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;=c17 read_stdin_fgets_basic_input_from_user.c -o bin/a \u0026amp;amp;\u0026amp;amp; bin/a\nEnter up to \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt; chars: hey\nYou entered \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hey\n\u0026quot;\u0026lt;/span\u0026gt;.\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    "],"id":86,"title":"Why is the gets function so dangerous that it should not be used?","content":"\n                \n\u0026lt;p\u0026gt;When I try to compile C code that uses the \u0026lt;code\u0026gt;gets()\u0026lt;/code\u0026gt; function with GCC, I get this warning: \u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;(.text+0x34): warning: the `gets\u0026apos; function is dangerous and should not be used.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;I remember this has something to do with stack protection and security, but I\u0026apos;m not sure exactly why.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;How can I remove this warning and why is there such a warning about using \u0026lt;code\u0026gt;gets()\u0026lt;/code\u0026gt;? \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If \u0026lt;code\u0026gt;gets()\u0026lt;/code\u0026gt; is so dangerous then why can\u0026apos;t we remove it?\u0026lt;/p\u0026gt;\n    ","slug":"why-is-the-gets-function-so-dangerous-that-it-should-not-be-used-1657384544362","postType":"QUESTION","createdAt":"2022-07-09T16:35:44.000Z","updatedAt":"2022-07-09T16:35:44.000Z","tags":[{"id":317,"name":"fgets","slug":"fgets","createdAt":"2022-07-09T16:35:44.000Z","updatedAt":"2022-07-09T16:35:44.000Z","Questions_Tags":{"questionId":86,"tagId":317}},{"id":318,"name":"buffer-overflow","slug":"buffer-overflow","createdAt":"2022-07-09T16:35:44.000Z","updatedAt":"2022-07-09T16:35:44.000Z","Questions_Tags":{"questionId":86,"tagId":318}},{"id":319,"name":"gets","slug":"gets","createdAt":"2022-07-09T16:35:44.000Z","updatedAt":"2022-07-09T16:35:44.000Z","Questions_Tags":{"questionId":86,"tagId":319}}],"relatedQuestions":[{"title":"Why is the gets function so dangerous that it should not be used?","slug":"why-is-the-gets-function-so-dangerous-that-it-should-not-be-used-1657384544362","tags":[{"name":"fgets","Questions_Tags":{"questionId":86,"tagId":317}},{"name":"buffer-overflow","Questions_Tags":{"questionId":86,"tagId":318}},{"name":"gets","Questions_Tags":{"questionId":86,"tagId":319}}]}]},"randomQuestions":[{"title":"How do JavaScript closures work?","slug":"how-do-javascript-closures-work-1657384418555"},{"title":"How do I properly compare strings in C?","slug":"how-do-i-properly-compare-strings-in-c-1657387467202"},{"title":"Relative imports for the billionth time","slug":"relative-imports-for-the-billionth-time-1657387756383"},{"title":"How do I set a variable to the output of a command in Bash?","slug":"how-do-i-set-a-variable-to-the-output-of-a-command-in-bash-1657387250909"},{"title":"How to filter object array based on attributes?","slug":"how-to-filter-object-array-based-on-attributes-1657388211247"},{"title":"What is a StackOverflowError?","slug":"what-is-a-stackoverflowerror-1657388319634"},{"title":"Why is using 'eval' a bad practice?","slug":"why-is-using-'eval'-a-bad-practice-1657387348760"},{"title":"Preview an image before it is uploaded","slug":"preview-an-image-before-it-is-uploaded-1657388048128"},{"title":"How do I detect a click outside an element?","slug":"how-do-i-detect-a-click-outside-an-element-1657387505351"},{"title":"javascript function doesn't work when link is clicked","slug":"javascript-function-doesn't-work-when-link-is-clicked-1657387767488"},{"title":"How do I undo the most recent local commits in Git?","slug":"how-do-i-undo-the-most-recent-local-commits-in-git-1657388262945"},{"title":"How to remove/delete a large file from commit history in the Git repository?","slug":"how-to-removedelete-a-large-file-from-commit-history-in-the-git-repository-1657387589093"},{"title":"Non-static variable cannot be referenced from a static context","slug":"non-static-variable-cannot-be-referenced-from-a-static-context-1657387386240"},{"title":"Get all unique values in a JavaScript array (remove duplicates)","slug":"get-all-unique-values-in-a-javascript-array-(remove-duplicates)-1657387435296"},{"title":"How to compare arrays in JavaScript?","slug":"how-to-compare-arrays-in-javascript-1657387352277"},{"title":"Convert form data to JavaScript object with jQuery","slug":"convert-form-data-to-javascript-object-with-jquery-1657388036834"},{"title":"How can I find the time complexity of an algorithm?","slug":"how-can-i-find-the-time-complexity-of-an-algorithm-1657388486001"},{"title":"What is event bubbling and capturing?","slug":"what-is-event-bubbling-and-capturing-1657388059203"},{"title":"Flexbox: center horizontally and vertically","slug":"flexbox:-center-horizontally-and-vertically-1657384587888"},{"title":"What is a debugger and how can it help me diagnose problems?","slug":"what-is-a-debugger-and-how-can-it-help-me-diagnose-problems-1657384472469"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"why-is-the-gets-function-so-dangerous-that-it-should-not-be-used-1657384544362"},"buildId":"DSpI0pSdXueTMCIVyw0q4","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>