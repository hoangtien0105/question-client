<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/what-should-main()-return-in-c-and-c++-1657384745630","name":"Questions"}}]}</script><title>What should main() return in C and C++? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="What is the correct (most efficient) way to define the main() function in C and C++ — int main() or void main() — and why? And how about the arguments?
If int main() then return 1 or return 0?

There are numerous duplicates of this question, including:

What are the valid signatures for C&#x27;s main() function?
The return type of main() function
Difference between void main() and int main()?
main()&#x27;s signature in C++
What is the proper declaration of main()? — For C++, with a very good answer indeed.
Styles of main() functions in C
Return type of main() method in C
int main() vs void main() in C

Related:

C++ — int main(int argc, char **argv)
C++ — int main(int argc, char *argv[])
Is char *envp[] as a third argument to main() portable?
Must the int main() function return a value in all compilers?
Why is the type of the main() function in C and C++ left to the user to define?
Why does int main(){} compile?
Legal definitions of main() in C++14?

    "/><meta property="og:title" content="What should main() return in C and C++? | Solutions Checker"/><meta property="og:description" content="What is the correct (most efficient) way to define the main() function in C and C++ — int main() or void main() — and why? And how about the arguments?
If int main() then return 1 or return 0?

There are numerous duplicates of this question, including:

What are the valid signatures for C&#x27;s main() function?
The return type of main() function
Difference between void main() and int main()?
main()&#x27;s signature in C++
What is the proper declaration of main()? — For C++, with a very good answer indeed.
Styles of main() functions in C
Return type of main() method in C
int main() vs void main() in C

Related:

C++ — int main(int argc, char **argv)
C++ — int main(int argc, char *argv[])
Is char *envp[] as a third argument to main() portable?
Must the int main() function return a value in all compilers?
Why is the type of the main() function in C and C++ left to the user to define?
Why does int main(){} compile?
Legal definitions of main() in C++14?

    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"What should main() return in C and C++?","text":"What is the correct (most efficient) way to define the main() function in C and C++ — int main() or void main() — and why? And how about the arguments?\nIf int main() then return 1 or return 0?\n\nThere are numerous duplicates of this question, including:\n\nWhat are the valid signatures for C&apos;s main() function?\nThe return type of main() function\nDifference between void main() and int main()?\nmain()&apos;s signature in C++\nWhat is the proper declaration of main()? — For C++, with a very good answer indeed.\nStyles of main() functions in C\nReturn type of main() method in C\nint main() vs void main() in C\n\nRelated:\n\nC++ — int main(int argc, char **argv)\nC++ — int main(int argc, char *argv[])\nIs char *envp[] as a third argument to main() portable?\nMust the int main() function return a value in all compilers?\nWhy is the type of the main() function in C and C++ left to the user to define?\nWhy does int main(){} compile?\nLegal definitions of main() in C++14?\n\n    ","answerCount":18,"upVoteCount":500,"suggestedAnswer":[{"text":"The return value for main indicates how the program exited. Normal exit is represented by a 0 return value from main. Abnormal exit is signaled by a non-zero return, but there is no standard for how non-zero codes are interpreted. As noted by others, void main() is prohibited by the C++ standard and should not be used. The valid C++ main signatures are:\n\nint main()\n\n\nand\n\nint main(int argc, char* argv[])\n\n\nwhich is equivalent to\n\nint main(int argc, char** argv)\n\n\nIt is also worth noting that in C++, int main() can be left without a return-statement, at which point it defaults to returning 0. This is also true with a C99 program. Whether return 0; should be omitted or not is open to debate. The range of valid C program main signatures is much greater.  \n\nEfficiency is not an issue with the main function. It can only be entered and left once (marking the program&apos;s start and termination) according to the C++ standard. For C, re-entering main() is allowed, but should be avoided.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"The accepted answer appears to be targetted for C++, so I thought I&apos;d add an answer that pertains to C, and this differs in a few ways. There were also some changes made between ISO/IEC 9899:1989 (C90) and ISO/IEC 9899:1999 (C99).\nmain() should be declared as either:\nint main(void)\nint main(int argc, char **argv)\n\nOr equivalent. For example, int main(int argc, char *argv[]) is equivalent to the second one. In C90, the int return type can be omitted as it is a default, but in C99 and newer, the int return type may not be omitted.\nIf an implementation permits it, main() can be declared in other ways (e.g., int main(int argc, char *argv[], char *envp[])), but this makes the program implementation defined, and no longer strictly conforming.\nThe standard defines 3 values for returning that are strictly conforming (that is, does not rely on implementation defined behaviour): 0 and EXIT_SUCCESS for a successful termination, and EXIT_FAILURE for an unsuccessful termination. Any other values are non-standard and implementation defined. In C90, main() must have an explicit return statement at the end to avoid undefined behaviour. In C99 and newer, you may omit the return statement from main(). If you do, and main() finished, there is an implicit return 0.\nFinally, there is nothing wrong from a standards point of view with calling main() recursively from a C program.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"Standard C  Hosted Environment\n\nFor a hosted environment (that&apos;s the normal one), the C11 standard (ISO/IEC 9899:2011) says:\n\n\n  5.1.2.2.1 Program startup\n  \n  The function called at program startup is named main. The implementation declares no\n  prototype for this function. It shall be defined with a return type of int and with no\n  parameters:\n\nint main(void) { /* ... */ }\n\n  \n  or with two parameters (referred to here as argc and argv, though any names may be\n  used, as they are local to the function in which they are declared):\n\nint main(int argc, char *argv[]) { /* ... */ }\n\n  \n  or equivalent;10) or in some other implementation-defined manner.\n  \n  If they are declared, the parameters to the main function shall obey the following\n  constraints:\n  \n  \n  The value of argc shall be nonnegative.\n  argv[argc] shall be a null pointer.\n  If the value of argc is greater than zero, the array members argv[0] through\n  argv[argc-1] inclusive shall contain pointers to strings, which are given\n  implementation-defined values by the host environment prior to program startup. The\n  intent is to supply to the program information determined prior to program startup\n  from elsewhere in the hosted environment. If the host environment is not capable of\n  supplying strings with letters in both uppercase and lowercase, the implementation\n  shall ensure that the strings are received in lowercase.\n  If the value of argc is greater than zero, the string pointed to by argv[0]\n  represents the program name; argv[0][0] shall be the null character if the\n  program name is not available from the host environment. If the value of argc is\n  greater than one, the strings pointed to by argv[1] through argv[argc-1]\n  represent the program parameters.\n  The parameters argc and argv and the strings pointed to by the argv array shall\n  be modifiable by the program, and retain their last-stored values between program\n  startup and program termination.\n  \n  \n  10) Thus, int can be replaced by a typedef name defined as int, or the type of argv can be written as\n  char **argv, and so on.\n\n\nProgram termination in C99 or C11\n\nThe value returned from main() is transmitted to the &apos;environment&apos; in an implementation-defined way.\n\n\n  5.1.2.2.3 Program termination\n  \n  1 If the return type of the main function is a type compatible with int, a return from the\n  initial call to the main function is equivalent to calling the exit function with the value\n  returned by the main function as its argument;11) reaching the } that terminates the\n  main function returns a value of 0. If the return type is not compatible with int, the\n  termination status returned to the host environment is unspecified.\n  \n  11) In accordance with 6.2.4, the lifetimes of objects with automatic storage duration declared in main\n  will have ended in the former case, even where they would not have in the latter.\n\n\nNote that 0 is mandated as &apos;success&apos;. You can use EXIT_FAILURE and EXIT_SUCCESS from &lt;stdlib.h&gt; if you prefer, but 0 is well established, and so is 1. See also Exit codes greater than 255  possible?.\n\nIn C89 (and hence in Microsoft C), there is no statement about what happens if the main() function returns but does not specify a return value; it therefore leads to undefined behaviour.\n\n\n  7.22.4.4 The exit function\n  \n  ¶5 Finally, control is returned to the host environment. If the value of status is zero or EXIT_SUCCESS, an implementation-defined form of the status successful termination is returned. If the value of status is EXIT_FAILURE, an implementation-defined form of the status unsuccessful termination is returned. Otherwise the status returned is implementation-defined.\n\n\nStandard C++  Hosted Environment\n\nThe C++11 standard (ISO/IEC 14882:2011) says:\n\n\n  3.6.1 Main function [basic.start.main]\n  \n  ¶1 A program shall contain a global function called main, which is the designated start of the program. [...]\n  \n  ¶2 An implementation shall not predefine the main function. This function shall not be overloaded. It shall\n  have a return type of type int, but otherwise its type is implementation defined.\n  All implementations\n  shall allow both of the following definitions of main:\n\nint main() { /* ... */ }\n\n  \n  and\n\nint main(int argc, char* argv[]) { /* ... */ }\n\n  \n  In the latter form argc shall be the number of arguments passed to the program from the environment\n  in which the program is run. If argc is nonzero these arguments shall be supplied in argv[0]\n  through argv[argc-1] as pointers to the initial characters of null-terminated multibyte strings (NTMBSs) (17.5.2.1.4.2) and argv[0] shall be the pointer to the initial character of a NTMBS that represents the\n  name used to invoke the program or &quot;&quot;. The value of argc shall be non-negative. The value of argv[argc]\n  shall be 0. [ Note: It is recommended that any further (optional) parameters be added after argv. end\n  note ]\n  \n  ¶3 The function main shall not be used within a program. The linkage (3.5) of main is implementation-defined. [...]\n  \n  ¶5 A return statement in main has the effect of leaving the main function (destroying any objects with automatic\n  storage duration) and calling std::exit with the return value as the argument. If control reaches the end\n  of main without encountering a return statement, the effect is that of executing\n\nreturn 0;\n\n\n\nThe C++ standard explicitly says &quot;It [the main function] shall have a return type of type int, but otherwise its type is implementation defined&quot;, and requires the same two signatures as the C standard to be supported as options. So a &apos;void main()&apos; is directly not allowed by the C++ standard, though there&apos;s nothing it can do to stop a non-standard implementation allowing alternatives.  Note that C++ forbids the user from calling main (but the C standard does not).\n\nThere&apos;s a paragraph of §18.5 Start and termination in the C++11 standard that is identical to the paragraph from §7.22.4.4 The exit function in the C11 standard (quoted above), apart from a footnote (which simply documents that EXIT_SUCCESS and EXIT_FAILURE are defined in &lt;cstdlib&gt;).\n\nStandard C  Common Extension\n\nClassically, Unix systems support a third variant:\n\nint main(int argc, char **argv, char **envp) { ... }\n\n\nThe third argument is a null-terminated list of pointers to strings, each of which is an environment variable which has a name, an equals sign, and a value (possibly empty).  If you do not use this, you can still get at the environment via &apos;extern char **environ;&apos;.  This global variable is unique among those in POSIX in that it does not have a header that declares it.\n\nThis is recognized by the C standard as a common extension, documented in Annex J:\n\n\n  J.5.1 Environment arguments\n  \n  ¶1 In a hosted environment, the main function receives a third argument, char *envp[],\n  that points to a null-terminated array of pointers to char, each of which points to a string\n  that provides information about the environment for this execution of the program (5.1.2.2.1).\n\n\nMicrosoft C\n\nThe Microsoft VS 2010 compiler is interesting. The web site says:\n\n\n  The declaration syntax for main is\n\n int main();\n\n  \n  or, optionally,\n\nint main(int argc, char *argv[], char *envp[]);\n\n  \n  Alternatively, the main and wmain functions can be declared as returning void (no return value). If you declare main or wmain as returning void, you cannot return an exit code to the parent process or operating system by using a return statement. To return an exit code when main or wmain is declared as void, you must use the exit function.\n\n\nIt is not clear to me what happens (what exit code is returned to the parent or OS) when a program with void main() does exit  and the MS web site is silent too.\n\nInterestingly, MS does not prescribe the two-argument version of main() that the C and C++ standards require. It only prescribes a three argument form where the third argument is char **envp, a pointer to a list of environment variables.\n\nThe Microsoft page also lists some other alternatives  wmain() which takes wide character strings, and some more.\n\nThe Microsoft Visual Studio 2005 version of this page does not list void main() as an alternative.  The versions from Microsoft Visual Studio 2008 onwards do.\n\nStandard C  Freestanding Environment\n\nAs noted early on, the requirements above apply to hosted environments. If you are working with a freestanding environment (which is the alternative to a hosted environment), then the standard has much less to say. For a freestanding environment, the function called at program startup need not be called main and there are no constraints on its return type.  The standard says:\n\n\n  5.1.2 Execution environments\n  \n  Two execution environments are defined: freestanding and hosted. In both cases,\n  program startup occurs when a designated C function is called by the execution\n  environment. All objects with static storage duration shall be initialized (set to their initial values) before program startup. The manner and timing of such initialization are otherwise unspecified. Program termination returns control to the execution environment.\n  \n  5.1.2.1 Freestanding environment\n  \n  In a freestanding environment (in which C program execution may take place without any benefit of an operating system), the name and type of the function called at program startup are implementation-defined. Any library facilities available to a freestanding program, other than the minimal set required by clause 4, are implementation-defined.\n  \n  The effect of program termination in a freestanding environment is implementation-defined.\n\n\nThe cross-reference to clause 4 Conformance refers to this:\n\n\n  ¶5 A strictly conforming program shall use only those features of the language and library specified in this International Standard.3) It shall not produce output dependent on any unspecified, undefined, or implementation-defined behavior, and shall not exceed any minimum implementation limit.\n  \n  ¶6 The two forms of conforming implementation are hosted and freestanding. A conforming hosted implementation shall accept any strictly conforming program. A conforming freestanding implementation shall accept any strictly conforming program in which the use of the features specified in the library clause (clause 7) is confined to the contents of the standard headers &lt;float.h&gt;, &lt;iso646.h&gt;, &lt;limits.h&gt;, &lt;stdalign.h&gt;,\n  &lt;stdarg.h&gt;, &lt;stdbool.h&gt;, &lt;stddef.h&gt;, &lt;stdint.h&gt;, and\n  &lt;stdnoreturn.h&gt;. A conforming implementation may have extensions (including\n  additional library functions), provided they do not alter the behavior of any strictly conforming program.4)\n  \n  ¶7 A conforming program is one that is acceptable to a conforming implementation.5)\n  \n  3) A strictly conforming program can use conditional features (see 6.10.8.3) provided the use is guarded by an appropriate conditional inclusion preprocessing directive using the related macro. For example:\n\n#ifdef __STDC_IEC_559__ /* FE_UPWARD defined */\n    /* ... */\n    fesetround(FE_UPWARD);\n    /* ... */\n#endif\n\n  \n  4) This implies that a conforming implementation reserves no identifiers other than those explicitly reserved in this International Standard.\n  \n  5) Strictly conforming programs are intended to be maximally portable among conforming implementations. Conforming programs may depend upon non-portable features of a conforming implementation.\n\n\nIt is noticeable that the only header required of a freestanding environment that actually defines any functions is &lt;stdarg.h&gt; (and even those may be  and often are  just macros).\n\nStandard C++  Freestanding Environment\n\nJust as the C standard recognizes both hosted and freestanding environment, so too does the C++ standard. (Quotes from ISO/IEC 14882:2011.)\n\n\n  1.4 Implementation compliance [intro.compliance]\n  \n  ¶7 Two kinds of implementations are defined: a hosted implementation and a freestanding implementation. For a hosted implementation, this International Standard defines the set of available libraries. A freestanding\n  implementation is one in which execution may take place without the benefit of an operating system, and has an implementation-defined set of libraries that includes certain language-support libraries (17.6.1.3).\n  \n  ¶8 A conforming implementation may have extensions (including additional library functions), provided they do not alter the behavior of any well-formed program. Implementations are required to diagnose programs that\n  use such extensions that are ill-formed according to this International Standard. Having done so, however, they can compile and execute such programs.\n  \n  ¶9 Each implementation shall include documentation that identifies all conditionally-supported constructs that it does not support and defines all locale-specific characteristics.3\n  \n  3) This documentation also defines implementation-defined behavior; see 1.9.\n  \n  17.6.1.3 Freestanding implementations [compliance]\n  \n  Two kinds of implementations are defined: hosted and freestanding (1.4). For a hosted implementation, this International Standard describes the set of available headers.\n  \n  A freestanding implementation has an implementation-defined set of headers. This set shall include at least the headers shown in Table 16.\n  \n  The supplied version of the header &lt;cstdlib&gt; shall declare at least the functions abort, atexit, at_quick_exit, exit, and quick_exit (18.5). The other headers listed in this table shall meet the same requirements as for a hosted implementation.\n  \n  Table 16  C++ headers for freestanding implementations\n\nSubclause                           Header(s)\n                                    &lt;ciso646&gt;\n18.2  Types                         &lt;cstddef&gt;\n18.3  Implementation properties     &lt;cfloat&gt; &lt;limits&gt; &lt;climits&gt;\n18.4  Integer types                 &lt;cstdint&gt;\n18.5  Start and termination         &lt;cstdlib&gt;\n18.6  Dynamic memory management     &lt;new&gt;\n18.7  Type identification           &lt;typeinfo&gt;\n18.8  Exception handling            &lt;exception&gt;\n18.9  Initializer lists             &lt;initializer_list&gt;\n18.10 Other runtime support         &lt;cstdalign&gt; &lt;cstdarg&gt; &lt;cstdbool&gt;\n20.9  Type traits                   &lt;type_traits&gt;\n29    Atomics                       &lt;atomic&gt;\n\n\n\nWhat about using int main() in C?\n\nThe standard §5.1.2.2.1 of the C11 standard shows the preferred notation  int main(void)  but there are also two examples in the standard which show int main(): §6.5.3.4 ¶8 and §6.7.6.3 ¶20.  Now, it is important to note that examples are not &apos;normative&apos;; they are only illustrative.  If there are bugs in the examples, they do not directly affect the main text of the standard.  That said, they are strongly indicative of expected behaviour, so if the standard includes int main() in an example, it suggests that int main() is not forbidden, even if it is not the preferred notation.\n\n\n  6.5.3.4 The sizeof and _Alignof operators\n  \n  \n  \n  ¶8 EXAMPLE 3 In this example, the size of a variable length array is computed and returned from a function:\n\n#include &lt;stddef.h&gt;\n\nsize_t fsize3(int n)\n{\n    char b[n+3]; // variable length array\n    return sizeof b; // execution time sizeof\n}\nint main()\n{\n    size_t size;\n    size = fsize3(10); // fsize3 returns 13\n    return 0;\n}\n\n\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"I believe that main() should return either EXIT_SUCCESS or EXIT_FAILURE. They are defined in stdlib.h\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"Note that the C and C++ standards define two kinds of implementations: freestanding and hosted.\n\nC90 hosted environment\n\nAllowed forms 1:\nint main (void)\nint main (int argc, char *argv[])\n\nmain (void)\nmain (int argc, char *argv[])\n/*... etc, similar forms with implicit int */\n\nComments:\nThe former two are explicitly stated as the allowed forms, the others are implicitly allowed because C90 allowed &quot;implicit int&quot; for return type and function parameters. No other form is allowed.\n\nC90 freestanding environment\n\nAny form or name of main is allowed 2.\n\nC99 hosted environment\n\nAllowed forms 3:\nint main (void)\nint main (int argc, char *argv[])\n/* or in some other implementation-defined manner. */\n\nComments:\nC99 removed &quot;implicit int&quot; so main() is no longer valid.\nA strange, ambiguous sentence &quot;or in some other implementation-defined manner&quot; has been introduced. This can either be interpreted as &quot;the parameters to int main() may vary&quot; or as &quot;main can have any implementation-defined form&quot;.\nSome compilers have chosen to interpret the standard in the latter way. Arguably, one cannot easily state that they are not conforming by citing the standard in itself, since it is is ambiguous.\nHowever, to allow completely wild forms of main() was probably(?) not the intention of this new sentence. The C99 rationale (not normative) implies that the sentence refers to additional parameters to int main 4.\nYet the section for hosted environment program termination then goes on arguing about the case where main does not return int 5. Although that section is not normative for how main should be declared, it definitely implies that main might be declared in a completely implementation-defined way even on hosted systems.\n\nC99 freestanding environment\n\nAny form or name of main is allowed 6.\n\nC11 hosted environment\n\nAllowed forms 7:\nint main (void)\nint main (int argc, char *argv[])\n/* or in some other implementation-defined manner. */\n\n\nC11 freestanding environment\n\nAny form or name of main is allowed 8.\n\nNote that int main() was never listed as a valid form for any hosted implementation of C in any of the above versions. In C, unlike C++, () and (void) have different meanings. The former is an obsolescent feature which may be removed from the language. See C11 future language directions:\n\n6.11.6 Function declarators\nThe use of function declarators with empty parentheses (not prototype-format parameter type declarators) is an obsolescent feature.\n\n\n\nC++03 hosted environment\n\nAllowed forms 9:\nint main ()\nint main (int argc, char *argv[])\n\nComments:\nNote the empty parenthesis in the first form. C++ and C are different in this case, because in C++ this means that the function takes no parameters. But in C it means that it may take any parameter.\n\nC++03 freestanding environment\n\nThe name of the function called at startup is implementation-defined. If it is named main() it must follow the stated forms 10:\n// implementation-defined name, or \nint main ()\nint main (int argc, char *argv[])\n\n\nC++11 hosted environment\n\nAllowed forms 11:\nint main ()\nint main (int argc, char *argv[])\n\nComments:\nThe text of the standard has been changed but it has the same meaning.\n\nC++11 freestanding environment\n\nThe name of the function called at startup is implementation-defined. If it is named main() it must follow the stated forms 12:\n// implementation-defined name, or \nint main ()\nint main (int argc, char *argv[])\n\n\nReferences\n\nANSI X3.159-1989 2.1.2.2 Hosted environment. &quot;Program startup&quot;\n\n\nThe function called at program startup is named main. The\nimplementation declares no prototype for this function. It shall be\ndefined with a return type of int and with no parameters:\n\nint main(void) { /* ... */ } \n\n\nor with two parameters (referred to here as\nargc and argv, though any names may be used, as they are local to the\nfunction in which they are declared):\n\nint main(int argc, char *argv[]) { /* ... */ }\n\n\nANSI X3.159-1989 2.1.2.1 Freestanding environment:\n\n\nIn a freestanding environment (in which C program execution may take\nplace without any benefit of an operating system), the name and type\nof the function called at program startup are implementation-defined.\n\n\nISO 9899:1999 5.1.2.2 Hosted environment -&gt; 5.1.2.2.1 Program startup\n\n\nThe function called at program startup is named main. The\nimplementation declares no prototype for this function. It shall be\ndefined with a return type of int and with no parameters:\n\nint main(void) { /* ... */ } \n\n\nor with two parameters (referred to here as\nargc and argv, though any names may be used, as they are local to the\nfunction in which they are declared):\n\nint main(int argc, char *argv[]) { /* ... */ }\n\n\nor equivalent;9) or in some other implementation-defined\nmanner.\n\n\nRationale for International Standard  Programming Languages  C, Revision 5.10. 5.1.2.2 Hosted environment --&gt; 5.1.2.2.1 Program startup\n\n\nThe behavior of the arguments to main, and of the interaction of exit, main and atexit\n(see §7.20.4.2) has been codified to curb some unwanted variety in the representation of argv\nstrings, and in the meaning of values returned by main.\n\n\nThe specification of argc and argv as arguments to main recognizes extensive prior practice.\nargv[argc] is required to be a null pointer to provide a redundant check for the end of the list, also on the basis of common practice.\n\n\nmain is the only function that may portably be declared either with zero or two arguments. (The number of other functions arguments must match exactly between invocation and definition.)\nThis special case simply recognizes the widespread practice of leaving off the arguments to main when the program does not access the program argument strings. While many implementations support more than two arguments to main, such practice is neither blessed nor forbidden by the Standard; a program that defines main with three arguments is not strictly conforming (see §J.5.1.).\n\n\nISO 9899:1999 5.1.2.2 Hosted environment --&gt; 5.1.2.2.3 Program termination\n\n\nIf the return type of the main function is a type compatible with int, a return from the initial call to the main function is equivalent to calling the exit function with the value returned by the main function as its argument;11) reaching the } that terminates the main function returns a value of 0. If the return type is not compatible with int, the termination status returned to the host environment is unspecified.\n\n\nISO 9899:1999 5.1.2.1 Freestanding environment\n\n\nIn a freestanding environment (in which C program execution may take place without any benefit of an operating system), the name and type of the function called at program startup are implementation-defined.\n\n\nISO 9899:2011 5.1.2.2 Hosted environment -&gt; 5.1.2.2.1 Program startup\n\nThis section is identical to the C99 one cited above.\n\nISO 9899:1999 5.1.2.1 Freestanding environment\n\nThis section is identical to the C99 one cited above.\n\nISO 14882:2003 3.6.1 Main function\n\n\nAn implementation shall not predefine the main function. This function shall not be overloaded. It shall have a return type of type int, but otherwise its type is implementation-defined. All implementations shall allow both of the following definitions of main:\n\nint main() { /* ... */ }\n\n\nand\n\nint main(int argc, char* argv[]) { /* ... */ }\n\n\nISO 14882:2003 3.6.1 Main function\n\n\nIt is implementation-defined whether a program in a freestanding environment is required to define a main function.\n\n\nISO 14882:2011 3.6.1 Main function\n\n\nAn implementation shall not predefine the main function. This function shall not be overloaded. It shall have a return type of type int, but otherwise its type is implementation-defined. All implementations shall\nallow both\n a function of () returning int and\n a function of (int, pointer to pointer to char) returning int\nas the type of main (8.3.5).\n\n\nISO 14882:2011 3.6.1 Main function\n\nThis section is identical to the C++03 one cited above.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"Return 0 on success and non-zero for error. This is the standard used by UNIX and DOS scripting to find out what happened with your program.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"main() in C89 and K&amp;R C unspecified return types default to int`.\nreturn 1? return 0?\n\n\nIf you do not write a return statement in int main(), the closing } will return 0 by default.\n\n(In c++ and c99 onwards only, for c90 you must write return statement. Please see Why main does not return 0 here?)\n\nreturn 0 or return 1 will be received by the parent process. In a shell it goes into a shell variable, and if you are running your program form a shell and not using that variable then you need not worry about the return value of main().\n\nSee How can I get what my main function has returned?.\n$ ./a.out\n$ echo $?\n\nThis way you can see that it is the variable $? which receives the least significant byte of the return value of main().\nIn Unix and DOS scripting, return 0 on success and non-zero for error are usually returned. This is the standard used by Unix and DOS scripting to find out what happened with your program and controlling the whole flow.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"Keep in mind that,even though you&apos;re returning an int, some OSes (Windows) truncate the returned value to a single byte (0-255).\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"The return value can be used by the operating system to check how the program was closed.\n\nReturn value 0 usually means OK in most operating systems (the ones I can think of anyway).\n\nIt also can be checked when you call a process yourself, and see if the program exited and finished properly.\n\nIt&apos;s NOT just a programming convention.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"The return value of main() shows how the program exited. If the return value is zero it means that the execution was successful while any non-zero value will represent that something went bad in the execution.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"Returning 0 should tell the programmer that the program has successfully finished the job.\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"Omit return 0\n\nWhen a C or C++ program reaches the end of main the compiler will automatically generate code to return 0, so there is no need to put return 0; explicitly at the end of main.  \n\nNote: when I make this suggestion, it&apos;s almost invariably followed by one of two kinds of comments:  &quot;I didn&apos;t know that.&quot; or &quot;That&apos;s bad advice!&quot;  My rationale is that it&apos;s safe and useful to rely on compiler behavior explicitly supported by the standard.  For C, since C99; see ISO/IEC 9899:1999 section 5.1.2.2.3:\n\n\n  [...] a return from the initial call to the main function is equivalent to calling the exit function with the value returned by the main function as its argument; reaching the } that terminates the main function returns a value of 0.\n\n\nFor C++, since the first standard in 1998; see ISO/IEC 14882:1998 section 3.6.1:\n\n\n  If control reaches the end of main without encountering a return statement, the effect is that of executing return 0;\n\n\nAll versions of both standards since then (C99 and C++98) have maintained the same idea.  We rely on automatically generated member functions in C++, and few people write explicit return; statements at the end of a void function.  Reasons against omitting seem to boil down to &quot;it looks weird&quot;.  If, like me, you&apos;re curious about the rationale for the change to the C standard read this question.  Also note that in the early 1990s this was considered &quot;sloppy practice&quot; because it was undefined behavior (although widely supported) at the time.  \n\nAdditionally, the C++ Core Guidelines contains multiple instances of omitting return 0; at the end of main and no instances in which an explicit return is written.  Although there is not yet a specific guideline on this particular topic in that document, that seems at least a tacit endorsement of the practice.\n\nSo I advocate omitting it; others disagree (often vehemently!)  In any case, if you encounter code that omits it, you&apos;ll know that it&apos;s explicitly supported by the standard and you&apos;ll know what it means.\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"What to return depends on what you want to do with the executable. For example if you are using your program with a command line shell, then you need to return 0 for a success and a non zero for failure. Then you would be able to use the program in shells with conditional processing depending on the outcome of your code. Also you can assign any nonzero value as per your interpretation, for example for critical errors different program exit points could terminate a program with different exit values , and which is available to the calling shell which can decide what to do by inspecting the value returned.\nIf the code is not intended for use with shells and the returned value does not bother anybody then it might be omitted. I personally use the signature int main (void) { .. return 0; .. }\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"If you really have issues related to efficiency of returning an integer from a process, you should probably avoid to call that process so many times that this return value becomes an issue.\n\nIf you are doing this (call a process so many times), you should find a way to put your logic directly inside the caller, or in a DLL file, without allocate a specific process for each call; the multiple process allocations bring you the relevant efficiency problem in this case.\n\nIn detail, if you only want to know if returning 0 is more or less efficient than returning 1, it could depend from the compiler in some cases, but generically, assuming they are read from the same source (local, field, constant, embedded in the code, function result, etc.) it requires exactly the same number of clock cycles.\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"Here is a small demonstration of the usage of return codes...\n\nWhen using the various tools that the Linux terminal provides one can use the return code for example for error handling after the process has been completed. Imagine that the following text file myfile is present:\n\n\n  This is some example in order to check how grep works.\n\n\nWhen you execute the grep command a process is created. Once it is through (and didn&apos;t break) it returns some code between 0 and 255. For example:\n\n$ grep order myfile\n\n\nIf you do\n\n$ echo $?\n$ 0\n\n\nyou will get a 0. Why? Because grep found a match and returned an exit code 0, which is the usual value for exiting with a success. Let&apos;s check it out again but with something that is not inside our text file and thus no match will be found:\n\n$ grep foo myfile\n$ echo $?\n$ 1\n\n\nSince grep failed to match the token &quot;foo&quot; with the content of our file the return code is 1 (this is the usual case when a failure occurs but as stated above you have plenty of values to choose from).\n\nNow the following bash script (simply type it in a Linux terminal) although very basic should give some idea of error handling:\n\n$ grep foo myfile\n$ CHECK=$?\n$ [ $CHECK -eq 0] &amp;&amp; echo &apos;Match found&apos;\n$ [ $CHECK -ne 0] &amp;&amp; echo &apos;No match was found&apos;\n$ No match was found\n\n\nAfter the second line nothing is printed to the terminal since &quot;foo&quot; made grep return 1 and we check if the return code of grep was equal to 0. The second conditional statement echoes its message in the last line since it is true due to CHECK == 1.\n\nAs you can see if you are calling this and that process it is sometimes essential to see what it has returned (by the return value of main()).\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"\n  What is the correct (most efficient) way to define the main() function in C and C++  int main() or void main()  and why?\n\n\nThose words &quot;(most efficient)&quot; don&apos;t change the question.  Unless you&apos;re in a freestanding environment, there is one universally correct way to declare main(), and that&apos;s as returning int.\n\n\n  What should main() return in C and C++?\n\n\nIt&apos;s not what should main() return, it&apos;s what does main() return.  main() is, of course, a function that someone else calls.  You don&apos;t have any control over the code that calls main().  Therefore, you must declare main() with a type-correct signature to match its caller.  You simply don&apos;t have any choice in the matter.  You don&apos;t have to ask yourself what&apos;s more or less efficient, or what&apos;s better or worse style, or anything like that, because the answer is already perfectly well defined, for you, by the C and C+ standards.  Just follow them.\n\n\n  If int main() then return 1 or return 0?\n\n\n0 for success, nonzero for failure.  Again, not something you need to (or get to) pick: it&apos;s defined by the interface you&apos;re supposed to be conforming to.\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"In C, the Section 5.1.2.2.1 of the C11 standard (emphasis mine):\n\nIt shall be defined with a return type of int and with no\nparameters:\nint main(void) { /* ... */ }\n\nor with two parameters (referred to here as argc and argv, though\nany names may be used, as they are local to the function in which they\nare declared):\nint main(int argc, char *argv[]) { /* ... */ }\n\n\nHowever for some beginners like me, an abstract example would allow me to get a grasp on it:\nWhen you write a method in your program, e.g. int read_file(char filename[LEN]);, then you want, as the caller of this method to know if everything went well (because failures can happen, e.g. file could not be found). By checking the return value of the method you can know if everything went well or not, it&apos;s a mechanism for the method to signal you about its successful execution (or not), and let the caller (you, e.g. in your main method) decide how to handle an unexpected failure.\nSo now imagine I write a C program for a micro-mechanism which is used in a more complex system. When the system calls the micro-mechanism, it wants to know if everything went as expected, so that it can handle any potential error. If the C program&apos;s main method would return void, then how would the calling-system know about the execution of its subsystem (the micro-mechanism)? It cannot, that&apos;s why main() returns int, in order to communicate to its caller a successful (or not) execution.\nIn other words:\nThe rational is that the host environment (i.e. Operating System (OS)) needs to know if the program finished correctly. Without an int-compatible type as a return type (eg. void), the &quot;status returned to the host environment is unspecified&quot; (i.e. undefined behavior on most OS).\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"On Windows, if a program crashes due to an access violation, the exit code will be STATUS_ACCESS_VIOLATION (0xC0000005).  Similar for other kinds of crashes from an x86 exception as well.\nSo there are things other than what you return from main or pass to exit that can cause an exit code to be seen.\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="17"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-7e79b78ef884195a.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-c1a73f3e758d48b9.js" defer=""></script><script src="/_next/static/XDXakEY6gSPdgAODPxtjg/_buildManifest.js" defer=""></script><script src="/_next/static/XDXakEY6gSPdgAODPxtjg/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/what-should-main()-return-in-c-and-c++-1657384745630#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-should-main()-return-in-c-and-c++-1657384745630"><h1>What should main() return in C and C++?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/return-value">return-value</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/main">main</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/return-type">return-type</a></div></div><div class="question-content mt-5">
                
<p>What is the correct (most efficient) way to define the <code>main()</code> function in C and C++ — <code>int main()</code> or <code>void main()</code> — and why? And how about the arguments?
If <code>int main()</code> then <code>return 1</code> or <code>return 0</code>?</p>
<hr>
<p><em>There are numerous duplicates of this question, including:</em></p>
<ul>
<li><a href="https://stackoverflow.com/questions/2108192/what-are-the-valid-signatures-for-cs-main-function/">What are the valid signatures for C's <code>main()</code> function?</a></li>
<li><a href="https://stackoverflow.com/questions/17715008/the-return-type-of-main-function/">The return type of <code>main()</code> function</a></li>
<li><a href="https://stackoverflow.com/questions/636829/difference-between-void-main-and-int-main">Difference between <code>void main()</code> and <code>int main()</code>?</a></li>
<li><a href="https://stackoverflow.com/questions/1621574/mains-signature-in-c"><code>main()</code>'s signature in C++</a></li>
<li><a href="https://stackoverflow.com/questions/4207134/what-is-the-proper-declaration-of-main">What is the proper declaration of <code>main()</code>?</a> — For C++, with a very good answer indeed.</li>
<li><a href="https://stackoverflow.com/questions/8692120/styles-of-main-functions-in-c">Styles of <code>main()</code> functions in C</a></li>
<li><a href="https://stackoverflow.com/questions/10915713/return-type-of-main-method-in-c">Return type of <code>main()</code> method in C</a></li>
<li><a href="https://stackoverflow.com/questions/9356510/int-main-vs-void-main-in-c"><code>int main()</code> vs <code>void main()</code> in C</a></li>
</ul>
<p>Related:</p>
<ul>
<li><a href="https://stackoverflow.com/questions/5191965/c-int-mainint-argc-char-argv">C++ — <code>int main(int argc, char **argv)</code></a></li>
<li><a href="https://stackoverflow.com/questions/5217395/c-int-mainint-argc-char-argv">C++ — <code>int main(int argc, char *argv[])</code></a></li>
<li><a href="https://stackoverflow.com/questions/10321435/is-char-envp-as-a-third-argument-to-main-portable">Is <code>char *envp[]</code> as a third argument to <code>main()</code> portable?</a></li>
<li><a href="https://stackoverflow.com/questions/18402853/must-the-int-main-function-return-a-value-in-all-compilers">Must the <code>int main()</code> function return a value in all compilers?</a></li>
<li><a href="https://stackoverflow.com/questions/5296163/why-is-the-type-of-the-main-function-in-c-and-c-left-to-the-user-to-define">Why is the type of the <code>main()</code> function in C and C++ left to the user to define?</a></li>
<li><a href="https://stackoverflow.com/questions/22239/why-does-int-main-compile">Why does <code>int main(){}</code> compile?</a></li>
<li><a href="https://stackoverflow.com/questions/26470912/legal-definitions-of-main-in-c14">Legal definitions of <code>main()</code> in C++14?</a></li>
</ul>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-value">return-value</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/main">main</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-type">return-type</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The return value for <code>main</code> indicates how the program exited. Normal exit is represented by a 0 return value from <code>main</code>. Abnormal exit is signaled by a non-zero return, but there is no standard for how non-zero codes are interpreted. As noted by others, <code>void main()</code> is prohibited by the C++ standard and should not be used. The valid C++ <code>main</code> signatures are:</p>

<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()
</span></code></pre>

<p>and</p>

<pre class="default s-code-block"><code class="hljs language-java"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span>
</code></pre>

<p>which is equivalent to</p>

<pre class="default s-code-block"><code class="hljs language-java"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span>
</code></pre>

<p>It is also worth noting that in C++, <code>int main()</code> can be left without a return-statement, at which point it defaults to returning 0. This is also true with a C99 program. Whether <code>return 0;</code> should be omitted or not is open to debate. The range of valid C program main signatures is much greater.  </p>

<p>Efficiency is not an issue with the <code>main</code> function. It can only be entered and left once (marking the program's start and termination) according to the C++ standard. For C, re-entering <code>main()</code> is allowed, but should be avoided.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-value">return-value</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/main">main</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-type">return-type</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The accepted answer appears to be targetted for C++, so I thought I'd add an answer that pertains to C, and this differs in a few ways. There were also some changes made between ISO/IEC 9899:1989 (C90) and ISO/IEC 9899:1999 (C99).</p>
<p><code>main()</code> should be declared as either:</p>
<pre class="default s-code-block"><code class="hljs language-java"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span>
</code></pre>
<p>Or equivalent. For example, <code>int main(int argc, char *argv[])</code> is equivalent to the second one. In C90, the <code>int</code> return type can be omitted as it is a default, but in C99 and newer, the <code>int</code> return type may not be omitted.</p>
<p>If an implementation permits it, <code>main()</code> can be declared in other ways (e.g., <code>int main(int argc, char *argv[], char *envp[])</code>), but this makes the program implementation defined, and no longer strictly conforming.</p>
<p>The standard defines 3 values for returning that are strictly conforming (that is, does not rely on implementation defined behaviour): <code>0</code> and <code>EXIT_SUCCESS</code> for a successful termination, and <code>EXIT_FAILURE</code> for an unsuccessful termination. Any other values are non-standard and implementation defined. In C90, <code>main()</code> must have an explicit <code>return</code> statement at the end to avoid undefined behaviour. In C99 and newer, you may omit the return statement from <code>main()</code>. If you do, and <code>main()</code> finished, there is an implicit <code>return 0</code>.</p>
<p>Finally, there is nothing wrong from a standards point of view with calling <code>main()</code> <em>recursively</em> from a C program.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-value">return-value</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/main">main</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-type">return-type</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2>Standard C  Hosted Environment</h2>

<p>For a hosted environment (that's the normal one), the C11 standard (ISO/IEC 9899:2011) says:</p>

<blockquote>
  <h3>5.1.2.2.1 Program startup</h3>
  
  <p>The function called at program startup is named <code>main</code>. The implementation declares no
  prototype for this function. It shall be defined with a return type of <code>int</code> and with no
  parameters:</p>

<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)</span> { <span class="hljs-comment">/* ... */</span> }
</code></pre>
  
  <p>or with two parameters (referred to here as <code>argc</code> and <code>argv</code>, though any names may be
  used, as they are local to the function in which they are declared):</p>

<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> argc, <span class="hljs-built_in">char</span> *argv[]</span>)</span> { <span class="hljs-comment">/* ... */</span> }
</code></pre>
  
  <p>or equivalent;<sup>10)</sup> or in some other implementation-defined manner.</p>
  
  <p>If they are declared, the parameters to the main function shall obey the following
  constraints:</p>
  
  <ul>
  <li>The value of <code>argc</code> shall be nonnegative.</li>
  <li><code>argv[argc]</code> shall be a null pointer.</li>
  <li>If the value of <code>argc</code> is greater than zero, the array members <code>argv[0]</code> through
  <code>argv[argc-1]</code> inclusive shall contain pointers to strings, which are given
  implementation-defined values by the host environment prior to program startup. The
  intent is to supply to the program information determined prior to program startup
  from elsewhere in the hosted environment. If the host environment is not capable of
  supplying strings with letters in both uppercase and lowercase, the implementation
  shall ensure that the strings are received in lowercase.</li>
  <li>If the value of <code>argc</code> is greater than zero, the string pointed to by <code>argv[0]</code>
  represents the program name; <code>argv[0][0]</code> shall be the null character if the
  program name is not available from the host environment. If the value of <code>argc</code> is
  greater than one, the strings pointed to by <code>argv[1]</code> through <code>argv[argc-1]</code>
  represent the program parameters.</li>
  <li>The parameters <code>argc</code> and <code>argv</code> and the strings pointed to by the <code>argv</code> array shall
  be modifiable by the program, and retain their last-stored values between program
  startup and program termination.</li>
  </ul>
  
  <p><sup>10)</sup> Thus, <code>int</code> can be replaced by a typedef name defined as <code>int</code>, or the type of <code>argv</code> can be written as
  <code>char **argv</code>, and so on.</p>
</blockquote>

<h3>Program termination in C99 or C11</h3>

<p>The value returned from <code>main()</code> is transmitted to the 'environment' in an implementation-defined way.</p>

<blockquote>
  <h3>5.1.2.2.3 Program termination</h3>
  
  <p>1 If the return type of the <code>main</code> function is a type compatible with <code>int</code>, a return from the
  initial call to the <code>main</code> function is equivalent to calling the <code>exit</code> function with the value
  returned by the <code>main</code> function as its argument;<sup>11)</sup> reaching the <code>}</code> that terminates the
  <code>main</code> function returns a value of 0. If the return type is not compatible with <code>int</code>, the
  termination status returned to the host environment is unspecified.</p>
  
  <p><sup>11)</sup> In accordance with 6.2.4, the lifetimes of objects with automatic storage duration declared in <code>main</code>
  will have ended in the former case, even where they would not have in the latter.</p>
</blockquote>

<p>Note that <code>0</code> is mandated as 'success'. You can use <code>EXIT_FAILURE</code> and <code>EXIT_SUCCESS</code> from <code>&lt;stdlib.h&gt;</code> if you prefer, but 0 is well established, and so is 1. See also <a href="https://stackoverflow.com/questions/179565/exitcodes-bigger-than-255-possible/">Exit codes greater than 255  possible?</a>.</p>

<p>In C89 (and hence in Microsoft C), there is no statement about what happens if the <code>main()</code> function returns but does not specify a return value; it therefore leads to undefined behaviour.</p>

<blockquote>
  <h3>7.22.4.4 The <code>exit</code> function</h3>
  
  <p>¶5 Finally, control is returned to the host environment. If the value of <code>status</code> is zero or <code>EXIT_SUCCESS</code>, an implementation-defined form of the status <em>successful termination</em> is returned. If the value of <code>status</code> is <code>EXIT_FAILURE</code>, an implementation-defined form of the status <em>unsuccessful termination</em> is returned. Otherwise the status returned is implementation-defined.</p>
</blockquote>

<h2>Standard C++  Hosted Environment</h2>

<p>The C++11 standard (ISO/IEC 14882:2011) says:</p>

<blockquote>
  <h3>3.6.1 Main function [basic.start.main]</h3>
  
  <p>¶1 A program shall contain a global function called main, which is the designated start of the program. [...]</p>
  
  <p>¶2 An implementation shall not predefine the main function. This function shall not be overloaded. It shall
  have a return type of type int, but otherwise its type is implementation defined.
  All implementations
  shall allow both of the following definitions of main:</p>

<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> { <span class="hljs-comment">/* ... */</span> }
</code></pre>
  
  <p>and</p>

<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> argc, <span class="hljs-built_in">char</span>* argv[]</span>)</span> { <span class="hljs-comment">/* ... */</span> }
</code></pre>
  
  <p>In the latter form <code>argc</code> shall be the number of arguments passed to the program from the environment
  in which the program is run. If <code>argc</code> is nonzero these arguments shall be supplied in <code>argv[0]</code>
  through <code>argv[argc-1]</code> as pointers to the initial characters of null-terminated multibyte strings (NTMBSs) (17.5.2.1.4.2) and <code>argv[0]</code> shall be the pointer to the initial character of a NTMBS that represents the
  name used to invoke the program or <code>""</code>. The value of <code>argc</code> shall be non-negative. The value of <code>argv[argc]</code>
  shall be 0. [ Note: It is recommended that any further (optional) parameters be added after <code>argv</code>. end
  note ]</p>
  
  <p>¶3 The function <code>main</code> shall not be used within a program. The linkage (3.5) of <code>main</code> is implementation-defined. [...]</p>
  
  <p>¶5 A return statement in main has the effect of leaving the main function (destroying any objects with automatic
  storage duration) and calling <code>std::exit</code> with the return value as the argument. If control reaches the end
  of main without encountering a return statement, the effect is that of executing</p>

<pre class="default s-code-block"><code class="hljs language-kotlin"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</code></pre>
</blockquote>

<p>The C++ standard explicitly says "It [the main function] shall have a return type of type <code>int</code>, but otherwise its type is implementation defined", and requires the same two signatures as the C standard to be supported as options. So a 'void main()' is directly not allowed by the C++ standard, though there's nothing it can do to stop a non-standard implementation allowing alternatives.  Note that C++ forbids the user from calling <code>main</code> (but the C standard does not).</p>

<p>There's a paragraph of §18.5 <strong>Start and termination</strong> in the C++11 standard that is identical to the paragraph from §7.22.4.4 <strong>The <code>exit</code> function</strong> in the C11 standard (quoted above), apart from a footnote (which simply documents that <code>EXIT_SUCCESS</code> and <code>EXIT_FAILURE</code> are defined in <code>&lt;cstdlib&gt;</code>).</p>

<h2>Standard C  Common Extension</h2>

<p>Classically, Unix systems support a third variant:</p>

<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> argc, <span class="hljs-built_in">char</span> **argv, <span class="hljs-built_in">char</span> **envp</span>)</span> { ... }
</code></pre>

<p>The third argument is a null-terminated list of pointers to strings, each of which is an environment variable which has a name, an equals sign, and a value (possibly empty).  If you do not use this, you can still get at the environment via '<code>extern char **environ;</code>'.  This global variable is unique among those in POSIX in that it does not have a header that declares it.</p>

<p>This is recognized by the C standard as a common extension, documented in Annex J:</p>

<blockquote>
  <h3>J.5.1 Environment arguments</h3>
  
  <p>¶1 In a hosted environment, the main function receives a third argument, <code>char *envp[]</code>,
  that points to a null-terminated array of pointers to <code>char</code>, each of which points to a string
  that provides information about the environment for this execution of the program (5.1.2.2.1).</p>
</blockquote>

<h2>Microsoft C</h2>

<p>The <a href="http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.100%29.aspx" rel="noreferrer">Microsoft VS 2010</a> compiler is interesting. The web site says:</p>

<blockquote>
  <p>The declaration syntax for main is</p>

<pre class="default s-code-block"><code class="hljs language-csharp"> <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span>;
</code></pre>
  
  <p>or, optionally,</p>

<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> argc, <span class="hljs-built_in">char</span> *argv[], <span class="hljs-built_in">char</span> *envp[]</span>)</span>;
</code></pre>
  
  <p>Alternatively, the <code>main</code> and <code>wmain</code> functions can be declared as returning <code>void</code> (no return value). If you declare <code>main</code> or <code>wmain</code> as returning void, you cannot return an exit code to the parent process or operating system by using a return statement. To return an exit code when <code>main</code> or <code>wmain</code> is declared as <code>void</code>, you must use the <code>exit</code> function.</p>
</blockquote>

<p>It is not clear to me what happens (what exit code is returned to the parent or OS) when a program with <code>void main()</code> does exit  and the MS web site is silent too.</p>

<p>Interestingly, MS does not prescribe the two-argument version of <code>main()</code> that the C and C++ standards require. It only prescribes a three argument form where the third argument is <code>char **envp</code>, a pointer to a list of environment variables.</p>

<p>The Microsoft page also lists some other alternatives  <code>wmain()</code> which takes wide character strings, and some more.</p>

<p>The Microsoft <a href="http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2005" rel="noreferrer">Visual&nbsp;Studio&nbsp;2005</a> version of <a href="http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.80%29.aspx" rel="noreferrer">this page</a> does not list <code>void main()</code> as an alternative.  The <a href="http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.90%29.aspx" rel="noreferrer">versions</a> from Microsoft <a href="http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2008" rel="noreferrer">Visual&nbsp;Studio&nbsp;2008</a> onwards do.</p>

<h2>Standard C  Freestanding Environment</h2>

<p>As noted early on, the requirements above apply to hosted environments. If you are working with a freestanding environment (which is the alternative to a hosted environment), then the standard has much less to say. For a freestanding environment, the function called at program startup need not be called <code>main</code> and there are no constraints on its return type.  The standard says:</p>

<blockquote>
  <h3>5.1.2 Execution environments</h3>
  
  <p>Two execution environments are defined: freestanding and hosted. In both cases,
  program startup occurs when a designated C function is called by the execution
  environment. All objects with static storage duration shall be initialized (set to their initial values) before program startup. The manner and timing of such initialization are otherwise unspecified. Program termination returns control to the execution environment.</p>
  
  <h3>5.1.2.1 Freestanding environment</h3>
  
  <p>In a freestanding environment (in which C program execution may take place without any benefit of an operating system), the name and type of the function called at program startup are implementation-defined. Any library facilities available to a freestanding program, other than the minimal set required by clause 4, are implementation-defined.</p>
  
  <p>The effect of program termination in a freestanding environment is implementation-defined.</p>
</blockquote>

<p>The cross-reference to clause 4 Conformance refers to this:</p>

<blockquote>
  <p>¶5 A <em>strictly conforming program</em> shall use only those features of the language and library specified in this International Standard.<sup>3)</sup> It shall not produce output dependent on any unspecified, undefined, or implementation-defined behavior, and shall not exceed any minimum implementation limit.</p>
  
  <p>¶6 The two forms of conforming implementation are <em>hosted</em> and <em>freestanding</em>. A <em>conforming hosted implementation</em> shall accept any strictly conforming program. A <em>conforming freestanding implementation</em> shall accept any strictly conforming program in which the use of the features specified in the library clause (clause 7) is confined to the contents of the standard headers <code>&lt;float.h&gt;</code>, <code>&lt;iso646.h&gt;</code>, <code>&lt;limits.h&gt;</code>, <code>&lt;stdalign.h&gt;</code>,
  <code>&lt;stdarg.h&gt;</code>, <code>&lt;stdbool.h&gt;</code>, <code>&lt;stddef.h&gt;</code>, <code>&lt;stdint.h&gt;</code>, and
  <code>&lt;stdnoreturn.h&gt;</code>. A conforming implementation may have extensions (including
  additional library functions), provided they do not alter the behavior of any strictly conforming program.<sup>4)</sup></p>
  
  <p>¶7 A <em>conforming program</em> is one that is acceptable to a conforming implementation.<sup>5)</sup></p>
  
  <p><sup>3)</sup> A strictly conforming program can use conditional features (see 6.10.8.3) provided the use is guarded by an appropriate conditional inclusion preprocessing directive using the related macro. For example:</p>

<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __STDC_IEC_559__ <span class="hljs-comment">/* FE_UPWARD defined */</span></span>
    <span class="hljs-comment">/* ... */</span>
    <span class="hljs-built_in">fesetround</span>(FE_UPWARD);
    <span class="hljs-comment">/* ... */</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>
  
  <p><sup>4)</sup> This implies that a conforming implementation reserves no identifiers other than those explicitly reserved in this International Standard.</p>
  
  <p><sup>5)</sup> Strictly conforming programs are intended to be maximally portable among conforming implementations. Conforming programs may depend upon non-portable features of a conforming implementation.</p>
</blockquote>

<p>It is noticeable that the only header required of a freestanding environment that actually defines any functions is <code>&lt;stdarg.h&gt;</code> (and even those may be  and often are  just macros).</p>

<h2>Standard C++  Freestanding Environment</h2>

<p>Just as the C standard recognizes both hosted and freestanding environment, so too does the C++ standard. (Quotes from ISO/IEC 14882:2011.)</p>

<blockquote>
  <h3>1.4 Implementation compliance [intro.compliance]</h3>
  
  <p>¶7 Two kinds of implementations are defined: a <em>hosted implementation</em> and a <em>freestanding implementation</em>. For a hosted implementation, this International Standard defines the set of available libraries. A freestanding
  implementation is one in which execution may take place without the benefit of an operating system, and has an implementation-defined set of libraries that includes certain language-support libraries (17.6.1.3).</p>
  
  <p>¶8 A conforming implementation may have extensions (including additional library functions), provided they do not alter the behavior of any well-formed program. Implementations are required to diagnose programs that
  use such extensions that are ill-formed according to this International Standard. Having done so, however, they can compile and execute such programs.</p>
  
  <p>¶9 Each implementation shall include documentation that identifies all conditionally-supported constructs that it does not support and defines all locale-specific characteristics.<sup>3</sup></p>
  
  <p><sup>3)</sup> This documentation also defines implementation-defined behavior; see 1.9.</p>
  
  <h3>17.6.1.3 Freestanding implementations [compliance]</h3>
  
  <p>Two kinds of implementations are defined: hosted and freestanding (1.4). For a hosted implementation, this International Standard describes the set of available headers.</p>
  
  <p>A freestanding implementation has an implementation-defined set of headers. This set shall include at least the headers shown in Table 16.</p>
  
  <p>The supplied version of the header <code>&lt;cstdlib&gt;</code> shall declare at least the functions <code>abort</code>, <code>atexit</code>, <code>at_quick_exit</code>, <code>exit</code>, and <code>quick_exit</code> (18.5). The other headers listed in this table shall meet the same requirements as for a hosted implementation.</p>
  
  <p>Table 16  C++ headers for freestanding implementations</p>

<pre class="default s-code-block"><code class="hljs language-xml">Subclause                           Header(s)
                                    <span class="hljs-tag">&lt;<span class="hljs-name">ciso646</span>&gt;</span>
18.2  Types                         <span class="hljs-tag">&lt;<span class="hljs-name">cstddef</span>&gt;</span>
18.3  Implementation properties     <span class="hljs-tag">&lt;<span class="hljs-name">cfloat</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">limits</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">climits</span>&gt;</span>
18.4  Integer types                 <span class="hljs-tag">&lt;<span class="hljs-name">cstdint</span>&gt;</span>
18.5  Start and termination         <span class="hljs-tag">&lt;<span class="hljs-name">cstdlib</span>&gt;</span>
18.6  Dynamic memory management     <span class="hljs-tag">&lt;<span class="hljs-name">new</span>&gt;</span>
18.7  Type identification           <span class="hljs-tag">&lt;<span class="hljs-name">typeinfo</span>&gt;</span>
18.8  Exception handling            <span class="hljs-tag">&lt;<span class="hljs-name">exception</span>&gt;</span>
18.9  Initializer lists             <span class="hljs-tag">&lt;<span class="hljs-name">initializer_list</span>&gt;</span>
18.10 Other runtime support         <span class="hljs-tag">&lt;<span class="hljs-name">cstdalign</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">cstdarg</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">cstdbool</span>&gt;</span>
20.9  Type traits                   <span class="hljs-tag">&lt;<span class="hljs-name">type_traits</span>&gt;</span>
29    Atomics                       <span class="hljs-tag">&lt;<span class="hljs-name">atomic</span>&gt;</span>
</code></pre>
</blockquote>

<h2>What about using <code>int main()</code> in C?</h2>

<p>The standard §5.1.2.2.1 of the C11 standard shows the preferred notation &nbsp;<code>int main(void)</code>  but there are also two examples in the standard which show <code>int main()</code>: <a href="https://port70.net/~nsz/c/c11/n1570.html#6.5.3.4p8" rel="noreferrer">§6.5.3.4 ¶8</a> and <a href="https://port70.net/~nsz/c/c11/n1570.html#6.7.6.3p20" rel="noreferrer">§6.7.6.3 ¶20</a>.  Now, it is important to note that examples are not 'normative'; they are only illustrative.  If there are bugs in the examples, they do not directly affect the main text of the standard.  That said, they are strongly indicative of expected behaviour, so if the standard includes <code>int main()</code> in an example, it suggests that <code>int main()</code> is not forbidden, even if it is not the preferred notation.</p>

<blockquote>
  <h3>6.5.3.4 The <code>sizeof</code> and <code>_Alignof</code> operators</h3>
  
  <p></p>
  
  <p>¶8 EXAMPLE 3 In this example, the size of a variable length array is computed and returned from a function:</p>

<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stddef.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">fsize3</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>
</span>{
    <span class="hljs-type">char</span> b[n+<span class="hljs-number">3</span>]; <span class="hljs-comment">// variable length array</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">sizeof</span> b; <span class="hljs-comment">// execution time sizeof</span>
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">size_t</span> size;
    size = <span class="hljs-built_in">fsize3</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// fsize3 returns 13</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
</blockquote>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-value">return-value</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/main">main</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-type">return-type</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I believe that <code>main()</code> should return either <code>EXIT_SUCCESS</code> or <code>EXIT_FAILURE</code>. They are defined in <code>stdlib.h</code></p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-value">return-value</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/main">main</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-type">return-type</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Note that the C and C++ standards define two kinds of implementations: freestanding and hosted.</p>
<ul>
<li><strong>C90 hosted environment</strong></li>
</ul>
<p>Allowed forms <sup>1</sup>:</p>
<pre class="default s-code-block"><code class="hljs language-java"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>

main (<span class="hljs-keyword">void</span>)
main (<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])
<span class="hljs-comment">/*... etc, similar forms with implicit int */</span>
</code></pre>
<p>Comments:</p>
<p>The former two are explicitly stated as the allowed forms, the others are implicitly allowed because C90 allowed "implicit int" for return type and function parameters. No other form is allowed.</p>
<ul>
<li><strong>C90 freestanding environment</strong></li>
</ul>
<p>Any form or name of main is allowed <sup>2</sup>.</p>
<ul>
<li><strong>C99 hosted environment</strong></li>
</ul>
<p>Allowed forms <sup>3</sup>:</p>
<pre class="default s-code-block"><code class="hljs language-java"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>
<span class="hljs-comment">/* or in some other implementation-defined manner. */</span>
</code></pre>
<p>Comments:</p>
<p>C99 removed "implicit int" so <code>main()</code> is no longer valid.</p>
<p>A strange, ambiguous sentence "or in some other implementation-defined manner" has been introduced. This can either be interpreted as "the parameters to <code>int main()</code> may vary" or as "main can have any implementation-defined form".</p>
<p>Some compilers have chosen to interpret the standard in the latter way. Arguably, one cannot easily state that they are not conforming by citing the standard in itself, since it is is ambiguous.</p>
<p>However, to allow completely wild forms of <code>main()</code> was probably(?) not the intention of this new sentence. The C99 rationale (not normative) implies that the sentence refers to additional parameters to <code>int main</code> <sup>4</sup>.</p>
<p>Yet the section for hosted environment program termination then goes on arguing about the case where main does not return int <sup>5</sup>. Although that section is not normative for how main should be declared, it definitely implies that main might be declared in a completely implementation-defined way even on hosted systems.</p>
<ul>
<li><strong>C99 freestanding environment</strong></li>
</ul>
<p>Any form or name of main is allowed <sup>6</sup>.</p>
<ul>
<li><strong>C11 hosted environment</strong></li>
</ul>
<p>Allowed forms <sup>7</sup>:</p>
<pre class="default s-code-block"><code class="hljs language-java"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>
<span class="hljs-comment">/* or in some other implementation-defined manner. */</span>
</code></pre>
<ul>
<li><strong>C11 freestanding environment</strong></li>
</ul>
<p>Any form or name of main is allowed <sup>8</sup>.</p>
<hr>
<p>Note that <code>int main()</code> was never listed as a valid form for any hosted implementation of C in any of the above versions. In C, unlike C++, <code>()</code> and <code>(void)</code> have different meanings. The former is an obsolescent feature which may be removed from the language. See C11 future language directions:</p>
<blockquote>
<p>6.11.6 Function declarators</p>
<p>The use of function declarators with empty parentheses (not prototype-format parameter type declarators) is an obsolescent feature.</p>
</blockquote>
<hr>
<ul>
<li><strong>C++03 hosted environment</strong></li>
</ul>
<p>Allowed forms <sup>9</sup>:</p>
<pre class="default s-code-block"><code class="hljs language-java"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>
</code></pre>
<p>Comments:</p>
<p>Note the empty parenthesis in the first form. C++ and C are different in this case, because in C++ this means that the function takes no parameters. But in C it means that it may take any parameter.</p>
<ul>
<li><strong>C++03 freestanding environment</strong></li>
</ul>
<p>The name of the function called at startup is implementation-defined. If it is named <code>main()</code> it must follow the stated forms <sup>10</sup>:</p>
<pre class="default s-code-block"><code class="hljs language-java"><span class="hljs-comment">// implementation-defined name, or </span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>
</code></pre>
<ul>
<li><strong>C++11 hosted environment</strong></li>
</ul>
<p>Allowed forms <sup>11</sup>:</p>
<pre class="default s-code-block"><code class="hljs language-java"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>
</code></pre>
<p>Comments:</p>
<p>The text of the standard has been changed but it has the same meaning.</p>
<ul>
<li><strong>C++11 freestanding environment</strong></li>
</ul>
<p>The name of the function called at startup is implementation-defined. If it is named <code>main()</code> it must follow the stated forms <sup>12</sup>:</p>
<pre class="default s-code-block"><code class="hljs language-java"><span class="hljs-comment">// implementation-defined name, or </span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>
</code></pre>
<hr>
<p><strong>References</strong></p>
<ol>
<li>ANSI X3.159-1989 2.1.2.2 Hosted environment. "Program startup"</li>
</ol>
<blockquote>
<p>The function called at program startup is named main. The
implementation declares no prototype for this function. It shall be
defined with a return type of int and with no parameters:</p>
</blockquote>
<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)</span> { <span class="hljs-comment">/* ... */</span> } 
</code></pre>
<blockquote>
<p>or with two parameters (referred to here as
argc and argv, though any names may be used, as they are local to the
function in which they are declared):</p>
</blockquote>
<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> argc, <span class="hljs-built_in">char</span> *argv[]</span>)</span> { <span class="hljs-comment">/* ... */</span> }
</code></pre>
<ol start="2">
<li>ANSI X3.159-1989 2.1.2.1 Freestanding environment:</li>
</ol>
<blockquote>
<p>In a freestanding environment (in which C program execution may take
place without any benefit of an operating system), the name and type
of the function called at program startup are implementation-defined.</p>
</blockquote>
<ol start="3">
<li>ISO 9899:1999 5.1.2.2 Hosted environment -&gt; 5.1.2.2.1 Program startup</li>
</ol>
<blockquote>
<p>The function called at program startup is named main. The
implementation declares no prototype for this function. It shall be
defined with a return type of int and with no parameters:</p>
</blockquote>
<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)</span> { <span class="hljs-comment">/* ... */</span> } 
</code></pre>
<blockquote>
<p>or with two parameters (referred to here as
argc and argv, though any names may be used, as they are local to the
function in which they are declared):</p>
</blockquote>
<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> argc, <span class="hljs-built_in">char</span> *argv[]</span>)</span> { <span class="hljs-comment">/* ... */</span> }
</code></pre>
<blockquote>
<p>or equivalent;9) or in some other implementation-defined
manner.</p>
</blockquote>
<ol start="4">
<li>Rationale for International Standard  Programming Languages  C, Revision 5.10. 5.1.2.2 Hosted environment --&gt; 5.1.2.2.1 Program startup</li>
</ol>
<blockquote>
<p>The behavior of the arguments to main, and of the interaction of exit, main and atexit
(see §7.20.4.2) has been codified to curb some unwanted variety in the representation of argv
strings, and in the meaning of values returned by main.</p>
</blockquote>
<blockquote>
<p>The specification of argc and argv as arguments to main recognizes extensive prior practice.
argv[argc] is required to be a null pointer to provide a redundant check for the end of the list, also on the basis of common practice.</p>
</blockquote>
<blockquote>
<p>main is the only function that may portably be declared either with zero or two arguments. (The number of other functions arguments must match exactly between invocation and definition.)
This special case simply recognizes the widespread practice of leaving off the arguments to main when the program does not access the program argument strings. While many implementations support more than two arguments to main, such practice is neither blessed nor forbidden by the Standard; a program that defines main with three arguments is not strictly conforming (see §J.5.1.).</p>
</blockquote>
<ol start="5">
<li>ISO 9899:1999 5.1.2.2 Hosted environment --&gt; 5.1.2.2.3 Program termination</li>
</ol>
<blockquote>
<p>If the return type of the main function is a type compatible with int, a return from the initial call to the main function is equivalent to calling the exit function with the value returned by the main function as its argument;11) reaching the <code>}</code> that terminates the main function returns a value of 0. If the return type is not compatible with int, the termination status returned to the host environment is unspecified.</p>
</blockquote>
<ol start="6">
<li>ISO 9899:1999 5.1.2.1 Freestanding environment</li>
</ol>
<blockquote>
<p>In a freestanding environment (in which C program execution may take place without any benefit of an operating system), the name and type of the function called at program startup are implementation-defined.</p>
</blockquote>
<ol start="7">
<li>ISO 9899:2011 5.1.2.2 Hosted environment -&gt; 5.1.2.2.1 Program startup</li>
</ol>
<p>This section is identical to the C99 one cited above.</p>
<ol start="8">
<li>ISO 9899:1999 5.1.2.1 Freestanding environment</li>
</ol>
<p>This section is identical to the C99 one cited above.</p>
<ol start="9">
<li>ISO 14882:2003 3.6.1 Main function</li>
</ol>
<blockquote>
<p>An implementation shall not predefine the main function. This function shall not be overloaded. It shall have a return type of type int, but otherwise its type is implementation-defined. All implementations shall allow both of the following definitions of main:</p>
</blockquote>
<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> { <span class="hljs-comment">/* ... */</span> }
</code></pre>
<blockquote>
<p>and</p>
</blockquote>
<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> argc, <span class="hljs-built_in">char</span>* argv[]</span>)</span> { <span class="hljs-comment">/* ... */</span> }
</code></pre>
<ol start="10">
<li>ISO 14882:2003 3.6.1 Main function</li>
</ol>
<blockquote>
<p>It is implementation-defined whether a program in a freestanding environment is required to define a main function.</p>
</blockquote>
<ol start="11">
<li>ISO 14882:2011 3.6.1 Main function</li>
</ol>
<blockquote>
<p>An implementation shall not predefine the main function. This function shall not be overloaded. It shall have a return type of type int, but otherwise its type is implementation-defined. All implementations shall
allow both</p>
<p> a function of () returning int and</p>
<p> a function of (int, pointer to pointer to char) returning int</p>
<p>as the type of main (8.3.5).</p>
</blockquote>
<ol start="12">
<li>ISO 14882:2011 3.6.1 Main function</li>
</ol>
<p>This section is identical to the C++03 one cited above.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-value">return-value</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/main">main</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-type">return-type</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Return 0 on success and non-zero for error. This is the standard used by UNIX and DOS scripting to find out what happened with your program.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-value">return-value</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/main">main</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-type">return-type</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><code>main()</code> in C89 and K&amp;R C unspecified return types default to int`.</p>
<pre class="default s-code-block"><code class="hljs language-kotlin"><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>? <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>?
</code></pre>
<ol>
<li>If you do not write a return statement in <code>int main()</code>, the closing <code>}</code> will return 0 by default.</li>
</ol>
<p>(In c++ and c99 onwards only, for c90 you must write return statement. Please see <a href="https://stackoverflow.com/questions/8677672/why-main-does-not-return-0-here">Why main does not return 0 here?</a>)</p>
<ol start="2">
<li><code>return 0</code> or <code>return 1</code> will be received by the parent process. In a shell it goes into a shell variable, and if you are running your program form a shell and not using that variable then you need not worry about the return value of <code>main()</code>.</li>
</ol>
<p>See <a href="https://stackoverflow.com/q/8626109/775964">How can I get what my main function has returned?</a>.</p>
<pre class="default s-code-block"><code class="hljs language-shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./a.out</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> $?</span>
</code></pre>
<p>This way you can see that it is the variable <code>$?</code> which receives the least significant byte of the return value of <code>main()</code>.</p>
<p>In Unix and DOS scripting, <code>return 0</code> on success and non-zero for error are usually returned. This is the standard used by Unix and DOS scripting to find out what happened with your program and controlling the whole flow.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-value">return-value</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/main">main</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-type">return-type</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Keep in mind that,even though you're returning an int, some OSes (Windows) truncate the returned value to a single byte (0-255).</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-value">return-value</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/main">main</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-type">return-type</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The return value can be used by the operating system to check how the program was closed.</p>

<p>Return value 0 usually means OK in most operating systems (the ones I can think of anyway).</p>

<p>It also can be checked when you call a process yourself, and see if the program exited and finished properly.</p>

<p>It's <strong>NOT</strong> just a programming convention.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-value">return-value</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/main">main</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-type">return-type</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The return value of <code>main()</code> shows how the program exited. If the return value is <code>zero</code> it means that the execution was successful while any non-zero value will represent that something went bad in the execution.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-value">return-value</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/main">main</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-type">return-type</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Returning 0 should tell the programmer that the program has successfully finished the job.</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-value">return-value</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/main">main</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-type">return-type</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2>Omit <code>return 0</code></h2>

<p>When a C or C++ program reaches the end of <code>main</code> the compiler will automatically generate code to return 0, so there is no need to put <code>return 0;</code> explicitly at the end of <code>main</code>.  </p>

<p><strong>Note:</strong> when I make this suggestion, it's almost invariably followed by one of two kinds of comments:  "I didn't know that." or "That's bad advice!"  My rationale is that it's safe and useful to rely on compiler behavior explicitly supported by the standard.  For C, since C99; see ISO/IEC 9899:1999 section 5.1.2.2.3:</p>

<blockquote>
  <p>[...] a return from the initial call to the <code>main</code> function is equivalent to calling the <code>exit</code> function with the value returned by the <code>main</code> function as its argument; reaching the <code>}</code> that terminates the <code>main</code> function returns a value of 0.</p>
</blockquote>

<p>For C++, since the first standard in 1998; see ISO/IEC 14882:1998 section 3.6.1:</p>

<blockquote>
  <p>If control reaches the end of main without encountering a return statement, the effect is that of executing return 0;</p>
</blockquote>

<p>All versions of both standards since then (C99 and C++98) have maintained the same idea.  We rely on automatically generated member functions in C++, and few people write explicit <code>return;</code> statements at the end of a <code>void</code> function.  Reasons against omitting seem to boil down to <a href="https://stackoverflow.com/questions/2581993/what-the-reasons-for-against-returning-0-from-main-in-iso-c/2582015#2582015">"it looks weird"</a>.  If, like me, you're curious about the rationale for the change to the C standard <a href="https://stackoverflow.com/questions/31394171/what-was-the-rationale-for-making-return-0-at-the-end-of-main-optional">read this question</a>.  Also note that in the early 1990s this was considered "sloppy practice" because it was undefined behavior (although widely supported) at the time.  </p>

<p>Additionally, the <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md" rel="nofollow noreferrer">C++ Core Guidelines</a> contains multiple instances of omitting <code>return 0;</code> at the end of <code>main</code> and no instances in which an explicit return is written.  Although there is not yet a specific guideline on this particular topic in that document, that seems at least a tacit endorsement of the practice.</p>

<p>So I advocate omitting it; others disagree (often vehemently!)  In any case, if you encounter code that omits it, you'll know that it's explicitly supported by the standard and you'll know what it means.</p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-value">return-value</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/main">main</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-type">return-type</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>What to return depends on what you want to do with the executable. For example if you are using your program with a command line shell, then you need to return 0 for a success and a non zero for failure. Then you would be able to use the program in shells with conditional processing depending on the outcome of your code. Also you can assign any nonzero value as per your interpretation, for example for critical errors different program exit points could terminate a program with different exit values , and which is available to the calling shell which can decide what to do by inspecting the value returned.
If the code is not intended for use with shells and the returned value does not bother anybody then it might be omitted. I personally use the signature <code>int main (void) { .. return 0; .. }</code></p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-value">return-value</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/main">main</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-type">return-type</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you really have issues related to efficiency of returning an integer from a process, you should probably avoid to call that process so many times that this return value becomes an issue.</p>

<p>If you are doing this (call a process so many times), you should find a way to put your logic directly inside the caller, or in a DLL file, without allocate a specific process for each call; the multiple process allocations bring you the relevant efficiency problem in this case.</p>

<p>In detail, if you only want to know if returning 0 is more or less efficient than returning 1, it could depend from the compiler in some cases, but generically, assuming they are read from the same source (local, field, constant, embedded in the code, function result, etc.) it requires exactly the same number of clock cycles.</p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-value">return-value</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/main">main</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-type">return-type</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is a small demonstration of the usage of return codes...</p>

<p>When using the various tools that the Linux terminal provides one can use the return code for example for error handling after the process has been completed. Imagine that the following text file myfile is present:</p>

<blockquote>
  <p>This is some example in order to check how grep works.</p>
</blockquote>

<p>When you execute the grep command a process is created. Once it is through (and didn't break) it returns some code between 0 and 255. For example:</p>

<pre class="default s-code-block"><code class="hljs language-perl">$ <span class="hljs-keyword">grep</span> order myfile
</code></pre>

<p>If you do</p>

<pre class="default s-code-block"><code class="hljs language-ruby"><span class="hljs-variable">$ </span>echo <span class="hljs-variable">$?</span>
<span class="hljs-variable">$ </span><span class="hljs-number">0</span>
</code></pre>

<p>you will get a 0. Why? Because <a href="http://en.wikipedia.org/wiki/Grep" rel="nofollow">grep</a> found a match and returned an exit code 0, which is the usual value for exiting with a success. Let's check it out again but with something that is not inside our text file and thus no match will be found:</p>

<pre class="default s-code-block"><code class="hljs language-ruby"><span class="hljs-variable">$ </span>grep foo myfile
<span class="hljs-variable">$ </span>echo <span class="hljs-variable">$?</span>
<span class="hljs-variable">$ </span><span class="hljs-number">1</span>
</code></pre>

<p>Since grep failed to match the token "foo" with the content of our file the return code is 1 (this is the usual case when a failure occurs but as stated above you have plenty of values to choose from).</p>

<p>Now the following bash script (simply type it in a Linux terminal) although very basic should give some idea of error handling:</p>

<pre class="default s-code-block"><code class="hljs language-shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">grep foo myfile</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash">CHECK=$?</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash">[ <span class="hljs-variable">$CHECK</span> -eq 0] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">'Match found'</span></span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash">[ <span class="hljs-variable">$CHECK</span> -ne 0] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">'No match was found'</span></span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash">No match was found</span>
</code></pre>

<p>After the second line nothing is printed to the terminal since "foo" made grep return 1 and we check if the return code of grep was equal to 0. The second conditional statement echoes its message in the last line since it is true due to CHECK == 1.</p>

<p>As you can see if you are calling this and that process it is sometimes essential to see what it has returned (by the return value of main()).</p>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-value">return-value</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/main">main</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-type">return-type</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<blockquote>
  <p>What is the correct (most efficient) way to define the main() function in C and C++  int main() or void main()  and why?</p>
</blockquote>

<p>Those words "(most efficient)" don't change the question.  Unless you're in a freestanding environment, there is one universally correct way to declare <code>main()</code>, and that's as returning int.</p>

<blockquote>
  <p>What should <code>main()</code> return in C and C++?</p>
</blockquote>

<p>It's not what <em>should</em> <code>main()</code> return, it's what <em>does</em> <code>main()</code> return.  <code>main()</code> is, of course, a function that someone else calls.  You don't have any control over the code that calls <code>main()</code>.  Therefore, you must declare <code>main()</code> with a type-correct signature to match its caller.  You simply don't have any choice in the matter.  You don't have to ask yourself what's more or less efficient, or what's better or worse style, or anything like that, because the answer is already perfectly well defined, for you, by the C and C+ standards.  Just follow them.</p>

<blockquote>
  <p>If int main() then return 1 or return 0?</p>
</blockquote>

<p>0 for success, nonzero for failure.  Again, not something you need to (or get to) pick: it's defined by the interface you're supposed to be conforming to.</p>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-value">return-value</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/main">main</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-type">return-type</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In C, the <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf" rel="nofollow noreferrer">Section 5.1.2.2.1 of the C11 standard</a> (emphasis mine):</p>
<blockquote>
<p>It shall be defined with a <strong>return type of <code>int</code></strong> and with no
parameters:</p>
<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)</span> { <span class="hljs-comment">/* ... */</span> }
</code></pre>
<p>or with two parameters (referred to here as <code>argc</code> and <code>argv</code>, though
any names may be used, as they are local to the function in which they
are declared):</p>
<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> argc, <span class="hljs-built_in">char</span> *argv[]</span>)</span> { <span class="hljs-comment">/* ... */</span> }
</code></pre>
</blockquote>
<p>However for some beginners like me, an abstract example would allow me to get a grasp on it:</p>
<p>When you write a method in your program, e.g. <code>int read_file(char filename[LEN]);</code>, then you want, as the caller of this method to know if everything went well (because failures can happen, e.g. file could not be found). By checking the return value of the method you can know if everything went well or not, it's a mechanism for the method to signal you about its successful execution (or not), and let the caller (you, e.g. in your main method) decide how to handle an unexpected failure.</p>
<p>So now imagine I write a C program for a micro-mechanism which is used in a more complex system. When the system calls the micro-mechanism, it wants to know if everything went as expected, so that it can handle any potential error. If the C program's main method would return void, then how would the calling-system know about the execution of its subsystem (the micro-mechanism)? It cannot, that's why main() returns int, in order to communicate to its caller a successful (or not) execution.</p>
<p>In other words:</p>
<p>The rational is that the host environment (i.e. Operating System (OS)) needs to know if the program finished correctly. Without an int-compatible type as a return type (eg. void), the "status returned to the host environment is unspecified" (i.e. undefined behavior on most OS).</p>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 18</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-value">return-value</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/main">main</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/return-type">return-type</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>On Windows, if a program crashes due to an access violation, the exit code will be <code>STATUS_ACCESS_VIOLATION (0xC0000005)</code>.  Similar for other kinds of crashes from an x86 exception as well.</p>
<p>So there are things other than what you return from <code>main</code> or pass to <code>exit</code> that can cause an exit code to be seen.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/using-asyncawait-with-a-foreach-loop-1657384512667">Using async/await with a forEach loop</a><a href="/questions/how-to-use-regular-expressions-(regex)-in-microsoft-excel-both-in-cell-and-loops-1657387487287">How to use Regular Expressions (Regex) in Microsoft Excel both in-cell and loops</a><a href="/questions/resolve-build-errors-due-to-circular-dependency-amongst-classes-1657384903462">Resolve build errors due to circular dependency amongst classes</a><a href="/questions/what-is-the-best-regular-expression-to-check-if-a-string-is-a-valid-url-1657387618306">What is the best regular expression to check if a string is a valid URL?</a><a href="/questions/what-is-selenium-and-what-is-webdriver-1657385470372">What Is Selenium And What Is WebDriver?</a><a href="/questions/how-to-make-function-decorators-and-chain-them-together-1657388180803">How to make function decorators and chain them together?</a><a href="/questions/why-is-iostream::eof-inside-a-loop-condition-(i.e.-while-(!stream.eof()))-considered-wrong-1657384355427">Why is iostream::eof inside a loop condition (i.e. `while (!stream.eof())`) considered wrong?</a><a href="/questions/how-does-the-%22this%22-keyword-work-and-when-should-it-be-used-1657384384385">How does the &quot;this&quot; keyword work, and when should it be used?</a><a href="/questions/what-is-move-semantics-1657387702625">What is move semantics?</a><a href="/questions/how-do-i-copy-to-the-clipboard-in-javascript-1657385501223">How do I copy to the clipboard in JavaScript?</a><a href="/questions/why-is-using-&#x27;eval&#x27;-a-bad-practice-1657387348760">Why is using &#x27;eval&#x27; a bad practice?</a><a href="/questions/why-are-these-numbers-not-equal-1657384729559">Why are these numbers not equal?</a><a href="/questions/how-to-return-value-from-an-asynchronous-callback-function-duplicate-1657387545611">How to return value from an asynchronous callback function? [duplicate]</a><a href="/questions/the-use-of-multiple-jframes:-good-or-bad-practice-closed-1657384478184">The Use of Multiple JFrames: Good or Bad Practice? [closed]</a><a href="/questions/how-can-i-do-a-full-outer-join-in-mysql-1657388175444">How can I do a FULL OUTER JOIN in MySQL?</a><a href="/questions/how-to-remove-items-from-a-list-while-iterating-1657384496375">How to remove items from a list while iterating?</a><a href="/questions/how-to-avoid-having-class-data-shared-among-instances-1657387687732">How to avoid having class data shared among instances?</a><a href="/questions/regex-match-open-tags-except-xhtml-self-contained-tags-1657384228245">RegEx match open tags except XHTML self-contained tags</a><a href="/questions/object-comparison-in-javascript-duplicate-1657387675463">Object comparison in JavaScript [duplicate]</a><a href="/questions/android-permission-doesn&#x27;t-work-even-if-i-have-declared-it-1657387726990">Android permission doesn&#x27;t work even if I have declared it</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;The return value for \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; indicates how the program exited. Normal exit is represented by a 0 return value from \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt;. Abnormal exit is signaled by a non-zero return, but there is no standard for how non-zero codes are interpreted. As noted by others, \u0026lt;code\u0026gt;void main()\u0026lt;/code\u0026gt; is prohibited by the C++ standard and should not be used. The valid C++ \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; signatures are:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;()\n\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* argv[])\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;which is equivalent to\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;** argv)\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It is also worth noting that in C++, \u0026lt;code\u0026gt;int main()\u0026lt;/code\u0026gt; can be left without a return-statement, at which point it defaults to returning 0. This is also true with a C99 program. Whether \u0026lt;code\u0026gt;return 0;\u0026lt;/code\u0026gt; should be omitted or not is open to debate. The range of valid C program main signatures is much greater.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Efficiency is not an issue with the \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; function. It can only be entered and left once (marking the program\u0026apos;s start and termination) according to the C++ standard. For C, re-entering \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; is allowed, but should be avoided.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The accepted answer appears to be targetted for C++, so I thought I\u0026apos;d add an answer that pertains to C, and this differs in a few ways. There were also some changes made between ISO/IEC 9899:1989 (C90) and ISO/IEC 9899:1999 (C99).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; should be declared as either:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; **argv)\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Or equivalent. For example, \u0026lt;code\u0026gt;int main(int argc, char *argv[])\u0026lt;/code\u0026gt; is equivalent to the second one. In C90, the \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; return type can be omitted as it is a default, but in C99 and newer, the \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; return type may not be omitted.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If an implementation permits it, \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; can be declared in other ways (e.g., \u0026lt;code\u0026gt;int main(int argc, char *argv[], char *envp[])\u0026lt;/code\u0026gt;), but this makes the program implementation defined, and no longer strictly conforming.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The standard defines 3 values for returning that are strictly conforming (that is, does not rely on implementation defined behaviour): \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;EXIT_SUCCESS\u0026lt;/code\u0026gt; for a successful termination, and \u0026lt;code\u0026gt;EXIT_FAILURE\u0026lt;/code\u0026gt; for an unsuccessful termination. Any other values are non-standard and implementation defined. In C90, \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; must have an explicit \u0026lt;code\u0026gt;return\u0026lt;/code\u0026gt; statement at the end to avoid undefined behaviour. In C99 and newer, you may omit the return statement from \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt;. If you do, and \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; finished, there is an implicit \u0026lt;code\u0026gt;return 0\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Finally, there is nothing wrong from a standards point of view with calling \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;recursively\u0026lt;/em\u0026gt; from a C program.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;Standard C  Hosted Environment\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;For a hosted environment (that\u0026apos;s the normal one), the C11 standard (ISO/IEC 9899:2011) says:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;h3\u0026gt;5.1.2.2.1 Program startup\u0026lt;/h3\u0026gt;\n  \n  \u0026lt;p\u0026gt;The function called at program startup is named \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt;. The implementation declares no\n  prototype for this function. It shall be defined with a return type of \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; and with no\n  parameters:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n  \n  \u0026lt;p\u0026gt;or with two parameters (referred to here as \u0026lt;code\u0026gt;argc\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;argv\u0026lt;/code\u0026gt;, though any names may be\n  used, as they are local to the function in which they are declared):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *argv[]\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n  \n  \u0026lt;p\u0026gt;or equivalent;\u0026lt;sup\u0026gt;10)\u0026lt;/sup\u0026gt; or in some other implementation-defined manner.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;If they are declared, the parameters to the main function shall obey the following\n  constraints:\u0026lt;/p\u0026gt;\n  \n  \u0026lt;ul\u0026gt;\n  \u0026lt;li\u0026gt;The value of \u0026lt;code\u0026gt;argc\u0026lt;/code\u0026gt; shall be nonnegative.\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;code\u0026gt;argv[argc]\u0026lt;/code\u0026gt; shall be a null pointer.\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;If the value of \u0026lt;code\u0026gt;argc\u0026lt;/code\u0026gt; is greater than zero, the array members \u0026lt;code\u0026gt;argv[0]\u0026lt;/code\u0026gt; through\n  \u0026lt;code\u0026gt;argv[argc-1]\u0026lt;/code\u0026gt; inclusive shall contain pointers to strings, which are given\n  implementation-defined values by the host environment prior to program startup. The\n  intent is to supply to the program information determined prior to program startup\n  from elsewhere in the hosted environment. If the host environment is not capable of\n  supplying strings with letters in both uppercase and lowercase, the implementation\n  shall ensure that the strings are received in lowercase.\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;If the value of \u0026lt;code\u0026gt;argc\u0026lt;/code\u0026gt; is greater than zero, the string pointed to by \u0026lt;code\u0026gt;argv[0]\u0026lt;/code\u0026gt;\n  represents the program name; \u0026lt;code\u0026gt;argv[0][0]\u0026lt;/code\u0026gt; shall be the null character if the\n  program name is not available from the host environment. If the value of \u0026lt;code\u0026gt;argc\u0026lt;/code\u0026gt; is\n  greater than one, the strings pointed to by \u0026lt;code\u0026gt;argv[1]\u0026lt;/code\u0026gt; through \u0026lt;code\u0026gt;argv[argc-1]\u0026lt;/code\u0026gt;\n  represent the program parameters.\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;The parameters \u0026lt;code\u0026gt;argc\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;argv\u0026lt;/code\u0026gt; and the strings pointed to by the \u0026lt;code\u0026gt;argv\u0026lt;/code\u0026gt; array shall\n  be modifiable by the program, and retain their last-stored values between program\n  startup and program termination.\u0026lt;/li\u0026gt;\n  \u0026lt;/ul\u0026gt;\n  \n  \u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;10)\u0026lt;/sup\u0026gt; Thus, \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; can be replaced by a typedef name defined as \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;, or the type of \u0026lt;code\u0026gt;argv\u0026lt;/code\u0026gt; can be written as\n  \u0026lt;code\u0026gt;char **argv\u0026lt;/code\u0026gt;, and so on.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;h3\u0026gt;Program termination in C99 or C11\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;The value returned from \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; is transmitted to the \u0026apos;environment\u0026apos; in an implementation-defined way.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;h3\u0026gt;5.1.2.2.3 Program termination\u0026lt;/h3\u0026gt;\n  \n  \u0026lt;p\u0026gt;1 If the return type of the \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; function is a type compatible with \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;, a return from the\n  initial call to the \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; function is equivalent to calling the \u0026lt;code\u0026gt;exit\u0026lt;/code\u0026gt; function with the value\n  returned by the \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; function as its argument;\u0026lt;sup\u0026gt;11)\u0026lt;/sup\u0026gt; reaching the \u0026lt;code\u0026gt;}\u0026lt;/code\u0026gt; that terminates the\n  \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; function returns a value of 0. If the return type is not compatible with \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;, the\n  termination status returned to the host environment is unspecified.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;11)\u0026lt;/sup\u0026gt; In accordance with 6.2.4, the lifetimes of objects with automatic storage duration declared in \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt;\n  will have ended in the former case, even where they would not have in the latter.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Note that \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt; is mandated as \u0026apos;success\u0026apos;. You can use \u0026lt;code\u0026gt;EXIT_FAILURE\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;EXIT_SUCCESS\u0026lt;/code\u0026gt; from \u0026lt;code\u0026gt;\u0026amp;lt;stdlib.h\u0026amp;gt;\u0026lt;/code\u0026gt; if you prefer, but 0 is well established, and so is 1. See also \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/179565/exitcodes-bigger-than-255-possible/\u0026quot;\u0026gt;Exit codes greater than 255  possible?\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In C89 (and hence in Microsoft C), there is no statement about what happens if the \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; function returns but does not specify a return value; it therefore leads to undefined behaviour.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;h3\u0026gt;7.22.4.4 The \u0026lt;code\u0026gt;exit\u0026lt;/code\u0026gt; function\u0026lt;/h3\u0026gt;\n  \n  \u0026lt;p\u0026gt;¶5 Finally, control is returned to the host environment. If the value of \u0026lt;code\u0026gt;status\u0026lt;/code\u0026gt; is zero or \u0026lt;code\u0026gt;EXIT_SUCCESS\u0026lt;/code\u0026gt;, an implementation-defined form of the status \u0026lt;em\u0026gt;successful termination\u0026lt;/em\u0026gt; is returned. If the value of \u0026lt;code\u0026gt;status\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;EXIT_FAILURE\u0026lt;/code\u0026gt;, an implementation-defined form of the status \u0026lt;em\u0026gt;unsuccessful termination\u0026lt;/em\u0026gt; is returned. Otherwise the status returned is implementation-defined.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;h2\u0026gt;Standard C++  Hosted Environment\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The C++11 standard (ISO/IEC 14882:2011) says:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;h3\u0026gt;3.6.1 Main function [basic.start.main]\u0026lt;/h3\u0026gt;\n  \n  \u0026lt;p\u0026gt;¶1 A program shall contain a global function called main, which is the designated start of the program. [...]\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;¶2 An implementation shall not predefine the main function. This function shall not be overloaded. It shall\n  have a return type of type int, but otherwise its type is implementation defined.\n  All implementations\n  shall allow both of the following definitions of main:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;()\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n  \n  \u0026lt;p\u0026gt;and\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* argv[]\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n  \n  \u0026lt;p\u0026gt;In the latter form \u0026lt;code\u0026gt;argc\u0026lt;/code\u0026gt; shall be the number of arguments passed to the program from the environment\n  in which the program is run. If \u0026lt;code\u0026gt;argc\u0026lt;/code\u0026gt; is nonzero these arguments shall be supplied in \u0026lt;code\u0026gt;argv[0]\u0026lt;/code\u0026gt;\n  through \u0026lt;code\u0026gt;argv[argc-1]\u0026lt;/code\u0026gt; as pointers to the initial characters of null-terminated multibyte strings (NTMBSs) (17.5.2.1.4.2) and \u0026lt;code\u0026gt;argv[0]\u0026lt;/code\u0026gt; shall be the pointer to the initial character of a NTMBS that represents the\n  name used to invoke the program or \u0026lt;code\u0026gt;\u0026quot;\u0026quot;\u0026lt;/code\u0026gt;. The value of \u0026lt;code\u0026gt;argc\u0026lt;/code\u0026gt; shall be non-negative. The value of \u0026lt;code\u0026gt;argv[argc]\u0026lt;/code\u0026gt;\n  shall be 0. [ Note: It is recommended that any further (optional) parameters be added after \u0026lt;code\u0026gt;argv\u0026lt;/code\u0026gt;. end\n  note ]\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;¶3 The function \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; shall not be used within a program. The linkage (3.5) of \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; is implementation-defined. [...]\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;¶5 A return statement in main has the effect of leaving the main function (destroying any objects with automatic\n  storage duration) and calling \u0026lt;code\u0026gt;std::exit\u0026lt;/code\u0026gt; with the return value as the argument. If control reaches the end\n  of main without encountering a return statement, the effect is that of executing\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-kotlin\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;The C++ standard explicitly says \u0026quot;It [the main function] shall have a return type of type \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;, but otherwise its type is implementation defined\u0026quot;, and requires the same two signatures as the C standard to be supported as options. So a \u0026apos;void main()\u0026apos; is directly not allowed by the C++ standard, though there\u0026apos;s nothing it can do to stop a non-standard implementation allowing alternatives.  Note that C++ forbids the user from calling \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; (but the C standard does not).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There\u0026apos;s a paragraph of §18.5 \u0026lt;strong\u0026gt;Start and termination\u0026lt;/strong\u0026gt; in the C++11 standard that is identical to the paragraph from §7.22.4.4 \u0026lt;strong\u0026gt;The \u0026lt;code\u0026gt;exit\u0026lt;/code\u0026gt; function\u0026lt;/strong\u0026gt; in the C11 standard (quoted above), apart from a footnote (which simply documents that \u0026lt;code\u0026gt;EXIT_SUCCESS\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;EXIT_FAILURE\u0026lt;/code\u0026gt; are defined in \u0026lt;code\u0026gt;\u0026amp;lt;cstdlib\u0026amp;gt;\u0026lt;/code\u0026gt;).\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Standard C  Common Extension\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Classically, Unix systems support a third variant:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; **argv, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; **envp\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; { ... }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The third argument is a null-terminated list of pointers to strings, each of which is an environment variable which has a name, an equals sign, and a value (possibly empty).  If you do not use this, you can still get at the environment via \u0026apos;\u0026lt;code\u0026gt;extern char **environ;\u0026lt;/code\u0026gt;\u0026apos;.  This global variable is unique among those in POSIX in that it does not have a header that declares it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is recognized by the C standard as a common extension, documented in Annex J:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;h3\u0026gt;J.5.1 Environment arguments\u0026lt;/h3\u0026gt;\n  \n  \u0026lt;p\u0026gt;¶1 In a hosted environment, the main function receives a third argument, \u0026lt;code\u0026gt;char *envp[]\u0026lt;/code\u0026gt;,\n  that points to a null-terminated array of pointers to \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt;, each of which points to a string\n  that provides information about the environment for this execution of the program (5.1.2.2.1).\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;h2\u0026gt;Microsoft C\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;a href=\u0026quot;http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.100%29.aspx\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Microsoft VS 2010\u0026lt;/a\u0026gt; compiler is interesting. The web site says:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The declaration syntax for main is\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;()\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n  \n  \u0026lt;p\u0026gt;or, optionally,\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *argv[], \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *envp[]\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n  \n  \u0026lt;p\u0026gt;Alternatively, the \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;wmain\u0026lt;/code\u0026gt; functions can be declared as returning \u0026lt;code\u0026gt;void\u0026lt;/code\u0026gt; (no return value). If you declare \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;wmain\u0026lt;/code\u0026gt; as returning void, you cannot return an exit code to the parent process or operating system by using a return statement. To return an exit code when \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;wmain\u0026lt;/code\u0026gt; is declared as \u0026lt;code\u0026gt;void\u0026lt;/code\u0026gt;, you must use the \u0026lt;code\u0026gt;exit\u0026lt;/code\u0026gt; function.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;It is not clear to me what happens (what exit code is returned to the parent or OS) when a program with \u0026lt;code\u0026gt;void main()\u0026lt;/code\u0026gt; does exit  and the MS web site is silent too.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Interestingly, MS does not prescribe the two-argument version of \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; that the C and C++ standards require. It only prescribes a three argument form where the third argument is \u0026lt;code\u0026gt;char **envp\u0026lt;/code\u0026gt;, a pointer to a list of environment variables.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The Microsoft page also lists some other alternatives  \u0026lt;code\u0026gt;wmain()\u0026lt;/code\u0026gt; which takes wide character strings, and some more.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The Microsoft \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2005\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Visual\u0026amp;nbsp;Studio\u0026amp;nbsp;2005\u0026lt;/a\u0026gt; version of \u0026lt;a href=\u0026quot;http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.80%29.aspx\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;this page\u0026lt;/a\u0026gt; does not list \u0026lt;code\u0026gt;void main()\u0026lt;/code\u0026gt; as an alternative.  The \u0026lt;a href=\u0026quot;http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.90%29.aspx\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;versions\u0026lt;/a\u0026gt; from Microsoft \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2008\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Visual\u0026amp;nbsp;Studio\u0026amp;nbsp;2008\u0026lt;/a\u0026gt; onwards do.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Standard C  Freestanding Environment\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;As noted early on, the requirements above apply to hosted environments. If you are working with a freestanding environment (which is the alternative to a hosted environment), then the standard has much less to say. For a freestanding environment, the function called at program startup need not be called \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; and there are no constraints on its return type.  The standard says:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;h3\u0026gt;5.1.2 Execution environments\u0026lt;/h3\u0026gt;\n  \n  \u0026lt;p\u0026gt;Two execution environments are defined: freestanding and hosted. In both cases,\n  program startup occurs when a designated C function is called by the execution\n  environment. All objects with static storage duration shall be initialized (set to their initial values) before program startup. The manner and timing of such initialization are otherwise unspecified. Program termination returns control to the execution environment.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;h3\u0026gt;5.1.2.1 Freestanding environment\u0026lt;/h3\u0026gt;\n  \n  \u0026lt;p\u0026gt;In a freestanding environment (in which C program execution may take place without any benefit of an operating system), the name and type of the function called at program startup are implementation-defined. Any library facilities available to a freestanding program, other than the minimal set required by clause 4, are implementation-defined.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;The effect of program termination in a freestanding environment is implementation-defined.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;The cross-reference to clause 4 Conformance refers to this:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;¶5 A \u0026lt;em\u0026gt;strictly conforming program\u0026lt;/em\u0026gt; shall use only those features of the language and library specified in this International Standard.\u0026lt;sup\u0026gt;3)\u0026lt;/sup\u0026gt; It shall not produce output dependent on any unspecified, undefined, or implementation-defined behavior, and shall not exceed any minimum implementation limit.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;¶6 The two forms of conforming implementation are \u0026lt;em\u0026gt;hosted\u0026lt;/em\u0026gt; and \u0026lt;em\u0026gt;freestanding\u0026lt;/em\u0026gt;. A \u0026lt;em\u0026gt;conforming hosted implementation\u0026lt;/em\u0026gt; shall accept any strictly conforming program. A \u0026lt;em\u0026gt;conforming freestanding implementation\u0026lt;/em\u0026gt; shall accept any strictly conforming program in which the use of the features specified in the library clause (clause 7) is confined to the contents of the standard headers \u0026lt;code\u0026gt;\u0026amp;lt;float.h\u0026amp;gt;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026amp;lt;iso646.h\u0026amp;gt;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026amp;lt;limits.h\u0026amp;gt;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026amp;lt;stdalign.h\u0026amp;gt;\u0026lt;/code\u0026gt;,\n  \u0026lt;code\u0026gt;\u0026amp;lt;stdarg.h\u0026amp;gt;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026amp;lt;stdbool.h\u0026amp;gt;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026amp;lt;stddef.h\u0026amp;gt;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026amp;lt;stdint.h\u0026amp;gt;\u0026lt;/code\u0026gt;, and\n  \u0026lt;code\u0026gt;\u0026amp;lt;stdnoreturn.h\u0026amp;gt;\u0026lt;/code\u0026gt;. A conforming implementation may have extensions (including\n  additional library functions), provided they do not alter the behavior of any strictly conforming program.\u0026lt;sup\u0026gt;4)\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;¶7 A \u0026lt;em\u0026gt;conforming program\u0026lt;/em\u0026gt; is one that is acceptable to a conforming implementation.\u0026lt;sup\u0026gt;5)\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;3)\u0026lt;/sup\u0026gt; A strictly conforming program can use conditional features (see 6.10.8.3) provided the use is guarded by an appropriate conditional inclusion preprocessing directive using the related macro. For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ifdef\u0026lt;/span\u0026gt; __STDC_IEC_559__ \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* FE_UPWARD defined */\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fesetround\u0026lt;/span\u0026gt;(FE_UPWARD);\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;endif\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n  \n  \u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;4)\u0026lt;/sup\u0026gt; This implies that a conforming implementation reserves no identifiers other than those explicitly reserved in this International Standard.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;5)\u0026lt;/sup\u0026gt; Strictly conforming programs are intended to be maximally portable among conforming implementations. Conforming programs may depend upon non-portable features of a conforming implementation.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;It is noticeable that the only header required of a freestanding environment that actually defines any functions is \u0026lt;code\u0026gt;\u0026amp;lt;stdarg.h\u0026amp;gt;\u0026lt;/code\u0026gt; (and even those may be  and often are  just macros).\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Standard C++  Freestanding Environment\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Just as the C standard recognizes both hosted and freestanding environment, so too does the C++ standard. (Quotes from ISO/IEC 14882:2011.)\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;h3\u0026gt;1.4 Implementation compliance [intro.compliance]\u0026lt;/h3\u0026gt;\n  \n  \u0026lt;p\u0026gt;¶7 Two kinds of implementations are defined: a \u0026lt;em\u0026gt;hosted implementation\u0026lt;/em\u0026gt; and a \u0026lt;em\u0026gt;freestanding implementation\u0026lt;/em\u0026gt;. For a hosted implementation, this International Standard defines the set of available libraries. A freestanding\n  implementation is one in which execution may take place without the benefit of an operating system, and has an implementation-defined set of libraries that includes certain language-support libraries (17.6.1.3).\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;¶8 A conforming implementation may have extensions (including additional library functions), provided they do not alter the behavior of any well-formed program. Implementations are required to diagnose programs that\n  use such extensions that are ill-formed according to this International Standard. Having done so, however, they can compile and execute such programs.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;¶9 Each implementation shall include documentation that identifies all conditionally-supported constructs that it does not support and defines all locale-specific characteristics.\u0026lt;sup\u0026gt;3\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;3)\u0026lt;/sup\u0026gt; This documentation also defines implementation-defined behavior; see 1.9.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;h3\u0026gt;17.6.1.3 Freestanding implementations [compliance]\u0026lt;/h3\u0026gt;\n  \n  \u0026lt;p\u0026gt;Two kinds of implementations are defined: hosted and freestanding (1.4). For a hosted implementation, this International Standard describes the set of available headers.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;A freestanding implementation has an implementation-defined set of headers. This set shall include at least the headers shown in Table 16.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;The supplied version of the header \u0026lt;code\u0026gt;\u0026amp;lt;cstdlib\u0026amp;gt;\u0026lt;/code\u0026gt; shall declare at least the functions \u0026lt;code\u0026gt;abort\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;atexit\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;at_quick_exit\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;exit\u0026lt;/code\u0026gt;, and \u0026lt;code\u0026gt;quick_exit\u0026lt;/code\u0026gt; (18.5). The other headers listed in this table shall meet the same requirements as for a hosted implementation.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;Table 16  C++ headers for freestanding implementations\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;Subclause                           Header(s)\n                                    \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ciso646\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n18.2  Types                         \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;cstddef\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n18.3  Implementation properties     \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;cfloat\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;limits\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;climits\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n18.4  Integer types                 \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;cstdint\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n18.5  Start and termination         \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;cstdlib\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n18.6  Dynamic memory management     \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n18.7  Type identification           \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;typeinfo\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n18.8  Exception handling            \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;exception\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n18.9  Initializer lists             \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;initializer_list\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n18.10 Other runtime support         \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;cstdalign\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;cstdarg\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;cstdbool\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n20.9  Type traits                   \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;type_traits\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n29    Atomics                       \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;atomic\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;h2\u0026gt;What about using \u0026lt;code\u0026gt;int main()\u0026lt;/code\u0026gt; in C?\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The standard §5.1.2.2.1 of the C11 standard shows the preferred notation \u0026amp;nbsp;\u0026lt;code\u0026gt;int main(void)\u0026lt;/code\u0026gt;  but there are also two examples in the standard which show \u0026lt;code\u0026gt;int main()\u0026lt;/code\u0026gt;: \u0026lt;a href=\u0026quot;https://port70.net/~nsz/c/c11/n1570.html#6.5.3.4p8\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;§6.5.3.4 ¶8\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;https://port70.net/~nsz/c/c11/n1570.html#6.7.6.3p20\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;§6.7.6.3 ¶20\u0026lt;/a\u0026gt;.  Now, it is important to note that examples are not \u0026apos;normative\u0026apos;; they are only illustrative.  If there are bugs in the examples, they do not directly affect the main text of the standard.  That said, they are strongly indicative of expected behaviour, so if the standard includes \u0026lt;code\u0026gt;int main()\u0026lt;/code\u0026gt; in an example, it suggests that \u0026lt;code\u0026gt;int main()\u0026lt;/code\u0026gt; is not forbidden, even if it is not the preferred notation.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;h3\u0026gt;6.5.3.4 The \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;_Alignof\u0026lt;/code\u0026gt; operators\u0026lt;/h3\u0026gt;\n  \n  \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;¶8 EXAMPLE 3 In this example, the size of a variable length array is computed and returned from a function:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stddef.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;fsize3\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; b[n+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;]; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// variable length array\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; b; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// execution time sizeof\u0026lt;/span\u0026gt;\n}\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; size;\n    size = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fsize3\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// fsize3 returns 13\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I believe that \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; should return either \u0026lt;code\u0026gt;EXIT_SUCCESS\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;EXIT_FAILURE\u0026lt;/code\u0026gt;. They are defined in \u0026lt;code\u0026gt;stdlib.h\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Note that the C and C++ standards define two kinds of implementations: freestanding and hosted.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;C90 hosted environment\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Allowed forms \u0026lt;sup\u0026gt;1\u0026lt;/sup\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *argv[])\u0026lt;/span\u0026gt;\n\nmain (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\nmain (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *argv[])\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*... etc, similar forms with implicit int */\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Comments:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The former two are explicitly stated as the allowed forms, the others are implicitly allowed because C90 allowed \u0026quot;implicit int\u0026quot; for return type and function parameters. No other form is allowed.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;C90 freestanding environment\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Any form or name of main is allowed \u0026lt;sup\u0026gt;2\u0026lt;/sup\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;C99 hosted environment\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Allowed forms \u0026lt;sup\u0026gt;3\u0026lt;/sup\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *argv[])\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* or in some other implementation-defined manner. */\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Comments:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;C99 removed \u0026quot;implicit int\u0026quot; so \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; is no longer valid.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A strange, ambiguous sentence \u0026quot;or in some other implementation-defined manner\u0026quot; has been introduced. This can either be interpreted as \u0026quot;the parameters to \u0026lt;code\u0026gt;int main()\u0026lt;/code\u0026gt; may vary\u0026quot; or as \u0026quot;main can have any implementation-defined form\u0026quot;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Some compilers have chosen to interpret the standard in the latter way. Arguably, one cannot easily state that they are not conforming by citing the standard in itself, since it is is ambiguous.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;However, to allow completely wild forms of \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; was probably(?) not the intention of this new sentence. The C99 rationale (not normative) implies that the sentence refers to additional parameters to \u0026lt;code\u0026gt;int main\u0026lt;/code\u0026gt; \u0026lt;sup\u0026gt;4\u0026lt;/sup\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Yet the section for hosted environment program termination then goes on arguing about the case where main does not return int \u0026lt;sup\u0026gt;5\u0026lt;/sup\u0026gt;. Although that section is not normative for how main should be declared, it definitely implies that main might be declared in a completely implementation-defined way even on hosted systems.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;C99 freestanding environment\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Any form or name of main is allowed \u0026lt;sup\u0026gt;6\u0026lt;/sup\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;C11 hosted environment\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Allowed forms \u0026lt;sup\u0026gt;7\u0026lt;/sup\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *argv[])\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* or in some other implementation-defined manner. */\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;C11 freestanding environment\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Any form or name of main is allowed \u0026lt;sup\u0026gt;8\u0026lt;/sup\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;Note that \u0026lt;code\u0026gt;int main()\u0026lt;/code\u0026gt; was never listed as a valid form for any hosted implementation of C in any of the above versions. In C, unlike C++, \u0026lt;code\u0026gt;()\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;(void)\u0026lt;/code\u0026gt; have different meanings. The former is an obsolescent feature which may be removed from the language. See C11 future language directions:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;6.11.6 Function declarators\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The use of function declarators with empty parentheses (not prototype-format parameter type declarators) is an obsolescent feature.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;C++03 hosted environment\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Allowed forms \u0026lt;sup\u0026gt;9\u0026lt;/sup\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *argv[])\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Comments:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Note the empty parenthesis in the first form. C++ and C are different in this case, because in C++ this means that the function takes no parameters. But in C it means that it may take any parameter.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;C++03 freestanding environment\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;The name of the function called at startup is implementation-defined. If it is named \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; it must follow the stated forms \u0026lt;sup\u0026gt;10\u0026lt;/sup\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// implementation-defined name, or \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *argv[])\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;C++11 hosted environment\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Allowed forms \u0026lt;sup\u0026gt;11\u0026lt;/sup\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *argv[])\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Comments:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The text of the standard has been changed but it has the same meaning.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;C++11 freestanding environment\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;The name of the function called at startup is implementation-defined. If it is named \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; it must follow the stated forms \u0026lt;sup\u0026gt;12\u0026lt;/sup\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// implementation-defined name, or \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *argv[])\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;References\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;ANSI X3.159-1989 2.1.2.2 Hosted environment. \u0026quot;Program startup\u0026quot;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;The function called at program startup is named main. The\nimplementation declares no prototype for this function. It shall be\ndefined with a return type of int and with no parameters:\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; } \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;or with two parameters (referred to here as\nargc and argv, though any names may be used, as they are local to the\nfunction in which they are declared):\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *argv[]\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;ol start=\u0026quot;2\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;ANSI X3.159-1989 2.1.2.1 Freestanding environment:\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;In a freestanding environment (in which C program execution may take\nplace without any benefit of an operating system), the name and type\nof the function called at program startup are implementation-defined.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;ol start=\u0026quot;3\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;ISO 9899:1999 5.1.2.2 Hosted environment -\u0026amp;gt; 5.1.2.2.1 Program startup\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;The function called at program startup is named main. The\nimplementation declares no prototype for this function. It shall be\ndefined with a return type of int and with no parameters:\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; } \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;or with two parameters (referred to here as\nargc and argv, though any names may be used, as they are local to the\nfunction in which they are declared):\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *argv[]\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;or equivalent;9) or in some other implementation-defined\nmanner.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;ol start=\u0026quot;4\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;Rationale for International Standard  Programming Languages  C, Revision 5.10. 5.1.2.2 Hosted environment --\u0026amp;gt; 5.1.2.2.1 Program startup\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;The behavior of the arguments to main, and of the interaction of exit, main and atexit\n(see §7.20.4.2) has been codified to curb some unwanted variety in the representation of argv\nstrings, and in the meaning of values returned by main.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;The specification of argc and argv as arguments to main recognizes extensive prior practice.\nargv[argc] is required to be a null pointer to provide a redundant check for the end of the list, also on the basis of common practice.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;main is the only function that may portably be declared either with zero or two arguments. (The number of other functions arguments must match exactly between invocation and definition.)\nThis special case simply recognizes the widespread practice of leaving off the arguments to main when the program does not access the program argument strings. While many implementations support more than two arguments to main, such practice is neither blessed nor forbidden by the Standard; a program that defines main with three arguments is not strictly conforming (see §J.5.1.).\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;ol start=\u0026quot;5\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;ISO 9899:1999 5.1.2.2 Hosted environment --\u0026amp;gt; 5.1.2.2.3 Program termination\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;If the return type of the main function is a type compatible with int, a return from the initial call to the main function is equivalent to calling the exit function with the value returned by the main function as its argument;11) reaching the \u0026lt;code\u0026gt;}\u0026lt;/code\u0026gt; that terminates the main function returns a value of 0. If the return type is not compatible with int, the termination status returned to the host environment is unspecified.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;ol start=\u0026quot;6\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;ISO 9899:1999 5.1.2.1 Freestanding environment\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;In a freestanding environment (in which C program execution may take place without any benefit of an operating system), the name and type of the function called at program startup are implementation-defined.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;ol start=\u0026quot;7\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;ISO 9899:2011 5.1.2.2 Hosted environment -\u0026amp;gt; 5.1.2.2.1 Program startup\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;This section is identical to the C99 one cited above.\u0026lt;/p\u0026gt;\n\u0026lt;ol start=\u0026quot;8\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;ISO 9899:1999 5.1.2.1 Freestanding environment\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;This section is identical to the C99 one cited above.\u0026lt;/p\u0026gt;\n\u0026lt;ol start=\u0026quot;9\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;ISO 14882:2003 3.6.1 Main function\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;An implementation shall not predefine the main function. This function shall not be overloaded. It shall have a return type of type int, but otherwise its type is implementation-defined. All implementations shall allow both of the following definitions of main:\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;()\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;and\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* argv[]\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;ol start=\u0026quot;10\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;ISO 14882:2003 3.6.1 Main function\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;It is implementation-defined whether a program in a freestanding environment is required to define a main function.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;ol start=\u0026quot;11\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;ISO 14882:2011 3.6.1 Main function\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;An implementation shall not predefine the main function. This function shall not be overloaded. It shall have a return type of type int, but otherwise its type is implementation-defined. All implementations shall\nallow both\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt; a function of () returning int and\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt; a function of (int, pointer to pointer to char) returning int\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;as the type of main (8.3.5).\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;ol start=\u0026quot;12\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;ISO 14882:2011 3.6.1 Main function\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;This section is identical to the C++03 one cited above.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Return 0 on success and non-zero for error. This is the standard used by UNIX and DOS scripting to find out what happened with your program.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; in C89 and K\u0026amp;amp;R C unspecified return types default to int`.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-kotlin\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;? \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;?\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;If you do not write a return statement in \u0026lt;code\u0026gt;int main()\u0026lt;/code\u0026gt;, the closing \u0026lt;code\u0026gt;}\u0026lt;/code\u0026gt; will return 0 by default.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;(In c++ and c99 onwards only, for c90 you must write return statement. Please see \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/8677672/why-main-does-not-return-0-here\u0026quot;\u0026gt;Why main does not return 0 here?\u0026lt;/a\u0026gt;)\u0026lt;/p\u0026gt;\n\u0026lt;ol start=\u0026quot;2\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;return 0\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;return 1\u0026lt;/code\u0026gt; will be received by the parent process. In a shell it goes into a shell variable, and if you are running your program form a shell and not using that variable then you need not worry about the return value of \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;See \u0026lt;a href=\u0026quot;https://stackoverflow.com/q/8626109/775964\u0026quot;\u0026gt;How can I get what my main function has returned?\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-shell\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta prompt_\u0026quot;\u0026gt;$ \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;language-bash\u0026quot;\u0026gt;./a.out\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta prompt_\u0026quot;\u0026gt;$ \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;language-bash\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; $?\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This way you can see that it is the variable \u0026lt;code\u0026gt;$?\u0026lt;/code\u0026gt; which receives the least significant byte of the return value of \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In Unix and DOS scripting, \u0026lt;code\u0026gt;return 0\u0026lt;/code\u0026gt; on success and non-zero for error are usually returned. This is the standard used by Unix and DOS scripting to find out what happened with your program and controlling the whole flow.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Keep in mind that,even though you\u0026apos;re returning an int, some OSes (Windows) truncate the returned value to a single byte (0-255).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The return value can be used by the operating system to check how the program was closed.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Return value 0 usually means OK in most operating systems (the ones I can think of anyway).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It also can be checked when you call a process yourself, and see if the program exited and finished properly.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It\u0026apos;s \u0026lt;strong\u0026gt;NOT\u0026lt;/strong\u0026gt; just a programming convention.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The return value of \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; shows how the program exited. If the return value is \u0026lt;code\u0026gt;zero\u0026lt;/code\u0026gt; it means that the execution was successful while any non-zero value will represent that something went bad in the execution.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Returning 0 should tell the programmer that the program has successfully finished the job.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;Omit \u0026lt;code\u0026gt;return 0\u0026lt;/code\u0026gt;\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;When a C or C++ program reaches the end of \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; the compiler will automatically generate code to return 0, so there is no need to put \u0026lt;code\u0026gt;return 0;\u0026lt;/code\u0026gt; explicitly at the end of \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt;.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Note:\u0026lt;/strong\u0026gt; when I make this suggestion, it\u0026apos;s almost invariably followed by one of two kinds of comments:  \u0026quot;I didn\u0026apos;t know that.\u0026quot; or \u0026quot;That\u0026apos;s bad advice!\u0026quot;  My rationale is that it\u0026apos;s safe and useful to rely on compiler behavior explicitly supported by the standard.  For C, since C99; see ISO/IEC 9899:1999 section 5.1.2.2.3:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;[...] a return from the initial call to the \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; function is equivalent to calling the \u0026lt;code\u0026gt;exit\u0026lt;/code\u0026gt; function with the value returned by the \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; function as its argument; reaching the \u0026lt;code\u0026gt;}\u0026lt;/code\u0026gt; that terminates the \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; function returns a value of 0.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;For C++, since the first standard in 1998; see ISO/IEC 14882:1998 section 3.6.1:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;If control reaches the end of main without encountering a return statement, the effect is that of executing return 0;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;All versions of both standards since then (C99 and C++98) have maintained the same idea.  We rely on automatically generated member functions in C++, and few people write explicit \u0026lt;code\u0026gt;return;\u0026lt;/code\u0026gt; statements at the end of a \u0026lt;code\u0026gt;void\u0026lt;/code\u0026gt; function.  Reasons against omitting seem to boil down to \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/2581993/what-the-reasons-for-against-returning-0-from-main-in-iso-c/2582015#2582015\u0026quot;\u0026gt;\u0026quot;it looks weird\u0026quot;\u0026lt;/a\u0026gt;.  If, like me, you\u0026apos;re curious about the rationale for the change to the C standard \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/31394171/what-was-the-rationale-for-making-return-0-at-the-end-of-main-optional\u0026quot;\u0026gt;read this question\u0026lt;/a\u0026gt;.  Also note that in the early 1990s this was considered \u0026quot;sloppy practice\u0026quot; because it was undefined behavior (although widely supported) at the time.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Additionally, the \u0026lt;a href=\u0026quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;C++ Core Guidelines\u0026lt;/a\u0026gt; contains multiple instances of omitting \u0026lt;code\u0026gt;return 0;\u0026lt;/code\u0026gt; at the end of \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; and no instances in which an explicit return is written.  Although there is not yet a specific guideline on this particular topic in that document, that seems at least a tacit endorsement of the practice.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So I advocate omitting it; others disagree (often vehemently!)  In any case, if you encounter code that omits it, you\u0026apos;ll know that it\u0026apos;s explicitly supported by the standard and you\u0026apos;ll know what it means.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;What to return depends on what you want to do with the executable. For example if you are using your program with a command line shell, then you need to return 0 for a success and a non zero for failure. Then you would be able to use the program in shells with conditional processing depending on the outcome of your code. Also you can assign any nonzero value as per your interpretation, for example for critical errors different program exit points could terminate a program with different exit values , and which is available to the calling shell which can decide what to do by inspecting the value returned.\nIf the code is not intended for use with shells and the returned value does not bother anybody then it might be omitted. I personally use the signature \u0026lt;code\u0026gt;int main (void) { .. return 0; .. }\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you really have issues related to efficiency of returning an integer from a process, you should probably avoid to call that process so many times that this return value becomes an issue.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you are doing this (call a process so many times), you should find a way to put your logic directly inside the caller, or in a DLL file, without allocate a specific process for each call; the multiple process allocations bring you the relevant efficiency problem in this case.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In detail, if you only want to know if returning 0 is more or less efficient than returning 1, it could depend from the compiler in some cases, but generically, assuming they are read from the same source (local, field, constant, embedded in the code, function result, etc.) it requires exactly the same number of clock cycles.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is a small demonstration of the usage of return codes...\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When using the various tools that the Linux terminal provides one can use the return code for example for error handling after the process has been completed. Imagine that the following text file myfile is present:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;This is some example in order to check how grep works.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;When you execute the grep command a process is created. Once it is through (and didn\u0026apos;t break) it returns some code between 0 and 255. For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-perl\u0026quot;\u0026gt;$ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;grep\u0026lt;/span\u0026gt; order myfile\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If you do\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-ruby\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$ \u0026lt;/span\u0026gt;echo \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$?\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$ \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;you will get a 0. Why? Because \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Grep\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;grep\u0026lt;/a\u0026gt; found a match and returned an exit code 0, which is the usual value for exiting with a success. Let\u0026apos;s check it out again but with something that is not inside our text file and thus no match will be found:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-ruby\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$ \u0026lt;/span\u0026gt;grep foo myfile\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$ \u0026lt;/span\u0026gt;echo \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$?\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$ \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Since grep failed to match the token \u0026quot;foo\u0026quot; with the content of our file the return code is 1 (this is the usual case when a failure occurs but as stated above you have plenty of values to choose from).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now the following bash script (simply type it in a Linux terminal) although very basic should give some idea of error handling:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-shell\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta prompt_\u0026quot;\u0026gt;$ \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;language-bash\u0026quot;\u0026gt;grep foo myfile\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta prompt_\u0026quot;\u0026gt;$ \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;language-bash\u0026quot;\u0026gt;CHECK=$?\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta prompt_\u0026quot;\u0026gt;$ \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;language-bash\u0026quot;\u0026gt;[ \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$CHECK\u0026lt;/span\u0026gt; -eq 0] \u0026amp;amp;\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Match found\u0026apos;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta prompt_\u0026quot;\u0026gt;$ \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;language-bash\u0026quot;\u0026gt;[ \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$CHECK\u0026lt;/span\u0026gt; -ne 0] \u0026amp;amp;\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;echo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;No match was found\u0026apos;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta prompt_\u0026quot;\u0026gt;$ \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;language-bash\u0026quot;\u0026gt;No match was found\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;After the second line nothing is printed to the terminal since \u0026quot;foo\u0026quot; made grep return 1 and we check if the return code of grep was equal to 0. The second conditional statement echoes its message in the last line since it is true due to CHECK == 1.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As you can see if you are calling this and that process it is sometimes essential to see what it has returned (by the return value of main()).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;What is the correct (most efficient) way to define the main() function in C and C++  int main() or void main()  and why?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Those words \u0026quot;(most efficient)\u0026quot; don\u0026apos;t change the question.  Unless you\u0026apos;re in a freestanding environment, there is one universally correct way to declare \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt;, and that\u0026apos;s as returning int.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;What should \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; return in C and C++?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;It\u0026apos;s not what \u0026lt;em\u0026gt;should\u0026lt;/em\u0026gt; \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; return, it\u0026apos;s what \u0026lt;em\u0026gt;does\u0026lt;/em\u0026gt; \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; return.  \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; is, of course, a function that someone else calls.  You don\u0026apos;t have any control over the code that calls \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt;.  Therefore, you must declare \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; with a type-correct signature to match its caller.  You simply don\u0026apos;t have any choice in the matter.  You don\u0026apos;t have to ask yourself what\u0026apos;s more or less efficient, or what\u0026apos;s better or worse style, or anything like that, because the answer is already perfectly well defined, for you, by the C and C+ standards.  Just follow them.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;If int main() then return 1 or return 0?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;0 for success, nonzero for failure.  Again, not something you need to (or get to) pick: it\u0026apos;s defined by the interface you\u0026apos;re supposed to be conforming to.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In C, the \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Section 5.1.2.2.1 of the C11 standard\u0026lt;/a\u0026gt; (emphasis mine):\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;It shall be defined with a \u0026lt;strong\u0026gt;return type of \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt; and with no\nparameters:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;or with two parameters (referred to here as \u0026lt;code\u0026gt;argc\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;argv\u0026lt;/code\u0026gt;, though\nany names may be used, as they are local to the function in which they\nare declared):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *argv[]\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;However for some beginners like me, an abstract example would allow me to get a grasp on it:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;When you write a method in your program, e.g. \u0026lt;code\u0026gt;int read_file(char filename[LEN]);\u0026lt;/code\u0026gt;, then you want, as the caller of this method to know if everything went well (because failures can happen, e.g. file could not be found). By checking the return value of the method you can know if everything went well or not, it\u0026apos;s a mechanism for the method to signal you about its successful execution (or not), and let the caller (you, e.g. in your main method) decide how to handle an unexpected failure.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So now imagine I write a C program for a micro-mechanism which is used in a more complex system. When the system calls the micro-mechanism, it wants to know if everything went as expected, so that it can handle any potential error. If the C program\u0026apos;s main method would return void, then how would the calling-system know about the execution of its subsystem (the micro-mechanism)? It cannot, that\u0026apos;s why main() returns int, in order to communicate to its caller a successful (or not) execution.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In other words:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The rational is that the host environment (i.e. Operating System (OS)) needs to know if the program finished correctly. Without an int-compatible type as a return type (eg. void), the \u0026quot;status returned to the host environment is unspecified\u0026quot; (i.e. undefined behavior on most OS).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;On Windows, if a program crashes due to an access violation, the exit code will be \u0026lt;code\u0026gt;STATUS_ACCESS_VIOLATION (0xC0000005)\u0026lt;/code\u0026gt;.  Similar for other kinds of crashes from an x86 exception as well.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So there are things other than what you return from \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; or pass to \u0026lt;code\u0026gt;exit\u0026lt;/code\u0026gt; that can cause an exit code to be seen.\u0026lt;/p\u0026gt;\n    "],"id":141,"title":"What should main() return in C and C++?","content":"\n                \n\u0026lt;p\u0026gt;What is the correct (most efficient) way to define the \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; function in C and C++ — \u0026lt;code\u0026gt;int main()\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;void main()\u0026lt;/code\u0026gt; — and why? And how about the arguments?\nIf \u0026lt;code\u0026gt;int main()\u0026lt;/code\u0026gt; then \u0026lt;code\u0026gt;return 1\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;return 0\u0026lt;/code\u0026gt;?\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;There are numerous duplicates of this question, including:\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/2108192/what-are-the-valid-signatures-for-cs-main-function/\u0026quot;\u0026gt;What are the valid signatures for C\u0026apos;s \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; function?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/17715008/the-return-type-of-main-function/\u0026quot;\u0026gt;The return type of \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; function\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/636829/difference-between-void-main-and-int-main\u0026quot;\u0026gt;Difference between \u0026lt;code\u0026gt;void main()\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;int main()\u0026lt;/code\u0026gt;?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/1621574/mains-signature-in-c\u0026quot;\u0026gt;\u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt;\u0026apos;s signature in C++\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/4207134/what-is-the-proper-declaration-of-main\u0026quot;\u0026gt;What is the proper declaration of \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt;?\u0026lt;/a\u0026gt; — For C++, with a very good answer indeed.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/8692120/styles-of-main-functions-in-c\u0026quot;\u0026gt;Styles of \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; functions in C\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/10915713/return-type-of-main-method-in-c\u0026quot;\u0026gt;Return type of \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; method in C\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/9356510/int-main-vs-void-main-in-c\u0026quot;\u0026gt;\u0026lt;code\u0026gt;int main()\u0026lt;/code\u0026gt; vs \u0026lt;code\u0026gt;void main()\u0026lt;/code\u0026gt; in C\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Related:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/5191965/c-int-mainint-argc-char-argv\u0026quot;\u0026gt;C++ — \u0026lt;code\u0026gt;int main(int argc, char **argv)\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/5217395/c-int-mainint-argc-char-argv\u0026quot;\u0026gt;C++ — \u0026lt;code\u0026gt;int main(int argc, char *argv[])\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/10321435/is-char-envp-as-a-third-argument-to-main-portable\u0026quot;\u0026gt;Is \u0026lt;code\u0026gt;char *envp[]\u0026lt;/code\u0026gt; as a third argument to \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; portable?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/18402853/must-the-int-main-function-return-a-value-in-all-compilers\u0026quot;\u0026gt;Must the \u0026lt;code\u0026gt;int main()\u0026lt;/code\u0026gt; function return a value in all compilers?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/5296163/why-is-the-type-of-the-main-function-in-c-and-c-left-to-the-user-to-define\u0026quot;\u0026gt;Why is the type of the \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; function in C and C++ left to the user to define?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/22239/why-does-int-main-compile\u0026quot;\u0026gt;Why does \u0026lt;code\u0026gt;int main(){}\u0026lt;/code\u0026gt; compile?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/26470912/legal-definitions-of-main-in-c14\u0026quot;\u0026gt;Legal definitions of \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; in C++14?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","slug":"what-should-main()-return-in-c-and-c++-1657384745630","postType":"QUESTION","createdAt":"2022-07-09T16:39:05.000Z","updatedAt":"2022-07-09T16:39:05.000Z","tags":[{"id":515,"name":"return-value","slug":"return-value","createdAt":"2022-07-09T16:39:05.000Z","updatedAt":"2022-07-09T16:39:05.000Z","Questions_Tags":{"questionId":141,"tagId":515}},{"id":516,"name":"main","slug":"main","createdAt":"2022-07-09T16:39:05.000Z","updatedAt":"2022-07-09T16:39:05.000Z","Questions_Tags":{"questionId":141,"tagId":516}},{"id":517,"name":"return-type","slug":"return-type","createdAt":"2022-07-09T16:39:05.000Z","updatedAt":"2022-07-09T16:39:05.000Z","Questions_Tags":{"questionId":141,"tagId":517}}],"relatedQuestions":[{"title":"What should main() return in C and C++?","slug":"what-should-main()-return-in-c-and-c++-1657384745630","tags":[{"name":"return-value","Questions_Tags":{"questionId":141,"tagId":515}},{"name":"main","Questions_Tags":{"questionId":141,"tagId":516}},{"name":"return-type","Questions_Tags":{"questionId":141,"tagId":517}}]}]},"randomQuestions":[{"title":"Using async/await with a forEach loop","slug":"using-asyncawait-with-a-foreach-loop-1657384512667"},{"title":"How to use Regular Expressions (Regex) in Microsoft Excel both in-cell and loops","slug":"how-to-use-regular-expressions-(regex)-in-microsoft-excel-both-in-cell-and-loops-1657387487287"},{"title":"Resolve build errors due to circular dependency amongst classes","slug":"resolve-build-errors-due-to-circular-dependency-amongst-classes-1657384903462"},{"title":"What is the best regular expression to check if a string is a valid URL?","slug":"what-is-the-best-regular-expression-to-check-if-a-string-is-a-valid-url-1657387618306"},{"title":"What Is Selenium And What Is WebDriver?","slug":"what-is-selenium-and-what-is-webdriver-1657385470372"},{"title":"How to make function decorators and chain them together?","slug":"how-to-make-function-decorators-and-chain-them-together-1657388180803"},{"title":"Why is iostream::eof inside a loop condition (i.e. `while (!stream.eof())`) considered wrong?","slug":"why-is-iostream::eof-inside-a-loop-condition-(i.e.-while-(!stream.eof()))-considered-wrong-1657384355427"},{"title":"How does the \"this\" keyword work, and when should it be used?","slug":"how-does-the-\"this\"-keyword-work-and-when-should-it-be-used-1657384384385"},{"title":"What is move semantics?","slug":"what-is-move-semantics-1657387702625"},{"title":"How do I copy to the clipboard in JavaScript?","slug":"how-do-i-copy-to-the-clipboard-in-javascript-1657385501223"},{"title":"Why is using 'eval' a bad practice?","slug":"why-is-using-'eval'-a-bad-practice-1657387348760"},{"title":"Why are these numbers not equal?","slug":"why-are-these-numbers-not-equal-1657384729559"},{"title":"How to return value from an asynchronous callback function? [duplicate]","slug":"how-to-return-value-from-an-asynchronous-callback-function-duplicate-1657387545611"},{"title":"The Use of Multiple JFrames: Good or Bad Practice? [closed]","slug":"the-use-of-multiple-jframes:-good-or-bad-practice-closed-1657384478184"},{"title":"How can I do a FULL OUTER JOIN in MySQL?","slug":"how-can-i-do-a-full-outer-join-in-mysql-1657388175444"},{"title":"How to remove items from a list while iterating?","slug":"how-to-remove-items-from-a-list-while-iterating-1657384496375"},{"title":"How to avoid having class data shared among instances?","slug":"how-to-avoid-having-class-data-shared-among-instances-1657387687732"},{"title":"RegEx match open tags except XHTML self-contained tags","slug":"regex-match-open-tags-except-xhtml-self-contained-tags-1657384228245"},{"title":"Object comparison in JavaScript [duplicate]","slug":"object-comparison-in-javascript-duplicate-1657387675463"},{"title":"Android permission doesn't work even if I have declared it","slug":"android-permission-doesn't-work-even-if-i-have-declared-it-1657387726990"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"what-should-main()-return-in-c-and-c++-1657384745630"},"buildId":"XDXakEY6gSPdgAODPxtjg","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>