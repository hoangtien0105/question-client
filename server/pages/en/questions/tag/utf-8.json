{"pageProps":{"data":{"count":1,"rows":[{"id":27,"title":"UTF-8 all the way through","slug":"utf-8-all-the-way-through-1657384323434","postType":"QUESTION","createdAt":"2022-07-09T16:32:03.000Z","updatedAt":"2022-07-09T16:32:03.000Z","tags":[{"id":91,"name":"utf-8","slug":"utf-8","createdAt":"2022-07-09T16:32:03.000Z","updatedAt":"2022-07-09T16:32:03.000Z","Questions_Tags":{"questionId":27,"tagId":91}}]}]},"slug":"utf-8","page":1,"answers":{"27":["\n&lt;p&gt;&lt;strong&gt;Data Storage&lt;/strong&gt;:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;Specify the &lt;code&gt;utf8mb4&lt;/code&gt; character set on all tables and text columns in your database.  This makes MySQL physically store and retrieve values encoded natively in UTF-8.  Note that MySQL will implicitly use &lt;code&gt;utf8mb4&lt;/code&gt; encoding if a &lt;code&gt;utf8mb4_*&lt;/code&gt; collation is specified (without any explicit character set).&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;In older versions of MySQL (&amp;lt; 5.5.3), you&apos;ll unfortunately be forced to use simply &lt;code&gt;utf8&lt;/code&gt;, which only supports a subset of Unicode characters.  I wish I were kidding.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;Data Access&lt;/strong&gt;:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;In your application code (e.g. PHP), in whatever DB access method you use, you&apos;ll need to set the connection charset to &lt;code&gt;utf8mb4&lt;/code&gt;.  This way, MySQL does no conversion from its native UTF-8 when it hands data off to your application and vice versa.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Some drivers provide their own mechanism for configuring the connection character set, which both updates its own internal state and informs MySQL of the encoding to be used on the connectionthis is usually the preferred approach.   In PHP:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;If you&apos;re using the &lt;a href=&quot;http://www.php.net/manual/en/book.pdo.php&quot; rel=&quot;noreferrer&quot;&gt;PDO&lt;/a&gt; abstraction layer with PHP  5.3.6, you can specify &lt;code&gt;charset&lt;/code&gt; in the &lt;a href=&quot;http://php.net/manual/en/ref.pdo-mysql.connection.php&quot; rel=&quot;noreferrer&quot;&gt;DSN&lt;/a&gt;:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$dbh&lt;/span&gt; = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;PDO&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;mysql:charset=utf8mb4&apos;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;If you&apos;re using &lt;a href=&quot;http://www.php.net/manual/en/book.mysqli.php&quot; rel=&quot;noreferrer&quot;&gt;mysqli&lt;/a&gt;, you can call &lt;a href=&quot;http://php.net/manual/en/mysqli.set-charset.php&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;set_charset()&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;  &lt;span class=&quot;hljs-variable&quot;&gt;$mysqli&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;set_charset&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;utf8mb4&apos;&lt;/span&gt;);       &lt;span class=&quot;hljs-comment&quot;&gt;// object oriented style&lt;/span&gt;\n  &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;mysqli_set_charset&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$link&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;utf8mb4&apos;&lt;/span&gt;);  &lt;span class=&quot;hljs-comment&quot;&gt;// procedural style&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;If you&apos;re stuck with plain &lt;a href=&quot;http://php.net/manual/en/book.mysql.php&quot; rel=&quot;noreferrer&quot;&gt;mysql&lt;/a&gt; but happen to be running PHP  5.2.3, you can call &lt;a href=&quot;http://php.net/manual/en/function.mysql-set-charset.php&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;mysql_set_charset&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;If the driver does not provide its own mechanism for setting the connection character set, you may have to issue a query to tell MySQL how your application expects data on the connection to be encoded: &lt;a href=&quot;http://dev.mysql.com/doc/en/charset-connection.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;SET NAMES &apos;utf8mb4&apos;&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;The same consideration regarding &lt;code&gt;utf8mb4&lt;/code&gt;/&lt;code&gt;utf8&lt;/code&gt; applies as above.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;Output&lt;/strong&gt;:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;UTF-8 should be set in the HTTP header, such as &lt;code&gt;Content-Type: text/html; charset=utf-8&lt;/code&gt;. You can achieve that either by setting &lt;a href=&quot;http://www.php.net/manual/en/ini.core.php#ini.default-charset&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;default_charset&lt;/code&gt;&lt;/a&gt; in php.ini (preferred), or manually using &lt;code&gt;header()&lt;/code&gt; function.&lt;/li&gt;\n&lt;li&gt;If your application transmits text to other systems, they will also need to be informed of the character encoding.  With web applications, the browser must be informed of the encoding in which data is sent (through HTTP response headers or &lt;a href=&quot;https://stackoverflow.com/q/4696499&quot;&gt;HTML metadata&lt;/a&gt;).&lt;/li&gt;\n&lt;li&gt;When encoding the output using &lt;code&gt;json_encode()&lt;/code&gt;, add &lt;code&gt;JSON_UNESCAPED_UNICODE&lt;/code&gt; as a second parameter.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;Input&lt;/strong&gt;:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Browsers will submit data in the character set specified for the document, hence nothing particular has to be done on the input.&lt;/li&gt;\n&lt;li&gt;In case you have doubts about request encoding (in case it could be tampered with), you may verify every received string as being valid UTF-8 before you try to store it or use it anywhere.  PHP&apos;s &lt;a href=&quot;http://php.net/manual/en/function.mb-check-encoding.php&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;mb_check_encoding()&lt;/code&gt;&lt;/a&gt; does the trick, but you have to use it religiously.  There&apos;s really no way around this, as malicious clients can submit data in whatever encoding they want, and I haven&apos;t found a trick to get PHP to do this for you reliably.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;Other Code Considerations&lt;/strong&gt;:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;Obviously enough, all files you&apos;ll be serving (PHP, HTML, JavaScript, etc.) should be encoded in valid UTF-8.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;You need to make sure that every time you process a UTF-8 string, you do so safely.  This is, unfortunately, the hard part.  You&apos;ll probably want to make extensive use of PHP&apos;s &lt;a href=&quot;http://www.php.net/manual/en/book.mbstring.php&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;mbstring&lt;/code&gt;&lt;/a&gt; extension.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;PHP&apos;s built-in string operations are &lt;em&gt;not&lt;/em&gt; by default UTF-8 safe.&lt;/strong&gt;  There are some things you can safely do with normal PHP string operations (like concatenation), but for most things you should use the equivalent &lt;code&gt;mbstring&lt;/code&gt; function.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;To know what you&apos;re doing (read: not mess it up), you really need to know UTF-8 and how it works on the lowest possible level.  Check out any of the links from &lt;a href=&quot;http://www.utf8.com/&quot; rel=&quot;noreferrer&quot;&gt;utf8.com&lt;/a&gt; for some good resources to learn everything you need to know.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;I&apos;d like to add one thing to &lt;a href=&quot;https://stackoverflow.com/questions/279170/utf-8-all-the-way-through#279279&quot;&gt;chazomaticus&apos; excellent answer&lt;/a&gt;:&lt;/p&gt;\n\n&lt;p&gt;Don&apos;t forget the META tag either (like this, or &lt;a href=&quot;http://www.w3.org/International/questions/qa-html-encoding-declarations#quicklookup&quot; rel=&quot;noreferrer&quot;&gt;the HTML4 or XHTML version of it&lt;/a&gt;):&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;charset&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;That seems trivial, but IE7 has given me problems with that before.&lt;/p&gt;\n\n&lt;p&gt;I was doing everything right; the database, database connection and Content-Type HTTP header were all set to UTF-8, and it worked fine in all other browsers, but Internet Explorer still insisted on using the &quot;Western European&quot; encoding.&lt;/p&gt;\n\n&lt;p&gt;It turned out the page was missing the META tag. Adding that solved the problem.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;The W3C actually has a rather large &lt;a href=&quot;http://www.w3.org/International/&quot; rel=&quot;noreferrer&quot;&gt;section dedicated to I18N&lt;/a&gt;. They have a number of articles related to this issue  describing the HTTP, (X)HTML and CSS side of things:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;http://www.w3.org/International/questions/qa-changing-encoding&quot; rel=&quot;noreferrer&quot;&gt;FAQ: Changing (X)HTML page encoding to UTF-8&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://www.w3.org/International/questions/qa-html-encoding-declarations&quot; rel=&quot;noreferrer&quot;&gt;Declaring character encodings in HTML&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://www.w3.org/International/tutorials/tutorial-char-enc/&quot; rel=&quot;noreferrer&quot;&gt;Tutorial: Character sets &amp;amp; encodings in XHTML, HTML and CSS&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://www.w3.org/International/O-HTTP-charset&quot; rel=&quot;noreferrer&quot;&gt;Setting the HTTP charset parameter&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;They recommend using both the HTTP header and HTML meta tag (or XML declaration in case of XHTML served as XML).&lt;/p&gt;\n    ","\n&lt;p&gt;In addition to setting &lt;code&gt;default_charset&lt;/code&gt; in php.ini, you can send the correct charset using &lt;code&gt;header()&lt;/code&gt; from within your code, before any output:&lt;/p&gt;\n&lt;pre class=&quot;lang-php s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;header&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Content-Type: text/html; charset=utf-8&apos;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Working with Unicode in PHP is easy as long as you realize that most of the &lt;strong&gt;string functions don&apos;t work with Unicode, and some might mangle strings completely&lt;/strong&gt;. PHP considers &quot;characters&quot; to be 1 byte long. Sometimes this is okay (for example, &lt;a href=&quot;https://www.php.net/manual/en/function.explode.php&quot; rel=&quot;nofollow noreferrer&quot;&gt;explode()&lt;/a&gt; only looks for a byte sequence and uses it as a separator -- so it doesn&apos;t matter what actual characters you look for). But other times, when the function is actually designed to work on &lt;em&gt;characters&lt;/em&gt;, PHP has no idea that your text has multi-byte characters that are found with Unicode.&lt;/p&gt;\n&lt;p&gt;A good library to check into is &lt;a href=&quot;http://phputf8.sourceforge.net/&quot; rel=&quot;nofollow noreferrer&quot;&gt;phputf8&lt;/a&gt;. This rewrites all of the &quot;bad&quot; functions so you can safely work on UTF8 strings. There are extensions like the &lt;a href=&quot;https://www.php.net/manual/en/book.mbstring.php&quot; rel=&quot;nofollow noreferrer&quot;&gt;mb_string&lt;/a&gt; extension that try to do this for you, too, but I prefer using the library because it&apos;s more portable (but I write mass-market products, so that&apos;s important for me). But phputf8 can use mb_string behind the scenes, anyway, to increase performance.&lt;/p&gt;\n    ","\n&lt;blockquote&gt;\n&lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; This answer applies to PHP 5.3.5 and lower. Do not use it for PHP version 5.3.6 (released in March 2011) or later.&lt;/p&gt;\n&lt;p&gt;Compare with &lt;a href=&quot;https://stackoverflow.com/a/21373793/367456&quot;&gt;Palec&apos;s answer to &lt;em&gt;PDO + MySQL and broken UTF-8 encoding&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;hr&gt;\n&lt;p&gt;I found an issue with someone using &lt;a href=&quot;https://en.wikipedia.org/wiki/PHP#Development_and_community&quot; rel=&quot;nofollow noreferrer&quot;&gt;PDO&lt;/a&gt; and the answer was to use this for the PDO connection string:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$pdo&lt;/span&gt; = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;PDO&lt;/span&gt;(\n    &lt;span class=&quot;hljs-string&quot;&gt;&apos;mysql:host=mysql.example.com;dbname=example_db&apos;&lt;/span&gt;,\n    &lt;span class=&quot;hljs-string&quot;&gt;&quot;username&quot;&lt;/span&gt;,\n    &lt;span class=&quot;hljs-string&quot;&gt;&quot;password&quot;&lt;/span&gt;,\n    &lt;span class=&quot;hljs-keyword&quot;&gt;array&lt;/span&gt;(PDO::&lt;span class=&quot;hljs-variable constant_&quot;&gt;MYSQL_ATTR_INIT_COMMAND&lt;/span&gt; =&amp;gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;SET NAMES utf8&quot;&lt;/span&gt;));\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;In my case, I was using &lt;code&gt;mb_split&lt;/code&gt;, which uses regular expressions.  Therefore I also had to manually make sure the regular expression  encoding was UTF-8 by doing &lt;code&gt;mb_regex_encoding(&apos;UTF-8&apos;);&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;As a side note, I also discovered by running &lt;code&gt;mb_internal_encoding()&lt;/code&gt; that the internal encoding wasn&apos;t UTF-8, and I changed that by running &lt;code&gt;mb_internal_encoding(&quot;UTF-8&quot;);&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;First of all, if you are in PHP before 5.3 then no. You&apos;ve got a ton of problems to tackle.&lt;/p&gt;\n&lt;p&gt;I am surprised that none has mentioned the &lt;a href=&quot;http://php.net/intl&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;strong&gt;intl&lt;/strong&gt;&lt;/a&gt; library, the one that has good support for &lt;strong&gt;Unicode&lt;/strong&gt;, &lt;strong&gt;graphemes&lt;/strong&gt;, &lt;strong&gt;string operations&lt;/strong&gt;, &lt;strong&gt;localisation&lt;/strong&gt; and many more, see below.&lt;/p&gt;\n&lt;p&gt;I will quote some information about Unicode support in PHP by &lt;strong&gt;Elizabeth Smith&apos;s&lt;/strong&gt; &lt;a href=&quot;http://www.slideshare.net/auroraeosrose/using-unicode-with-php&quot; rel=&quot;nofollow noreferrer&quot;&gt;slides&lt;/a&gt; at &lt;strong&gt;PHPBenelux&apos;14&lt;/strong&gt;&lt;/p&gt;\n&lt;h2&gt;&lt;strong&gt;INTL&lt;/strong&gt;&lt;/h2&gt;\n&lt;p&gt;Good:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Wrapper around ICU library&lt;/li&gt;\n&lt;li&gt;Standardised locales, set locale per script&lt;/li&gt;\n&lt;li&gt;Number formatting&lt;/li&gt;\n&lt;li&gt;Currency formatting&lt;/li&gt;\n&lt;li&gt;Message formatting (replaces gettext)&lt;/li&gt;\n&lt;li&gt;Calendars, dates, time zone and time&lt;/li&gt;\n&lt;li&gt;Transliterator&lt;/li&gt;\n&lt;li&gt;Spoofchecker&lt;/li&gt;\n&lt;li&gt;Resource bundles&lt;/li&gt;\n&lt;li&gt;Convertors&lt;/li&gt;\n&lt;li&gt;IDN support&lt;/li&gt;\n&lt;li&gt;Graphemes&lt;/li&gt;\n&lt;li&gt;Collation&lt;/li&gt;\n&lt;li&gt;Iterators&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Bad:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Does not support zend_multibyte&lt;/li&gt;\n&lt;li&gt;Does not support HTTP input output conversion&lt;/li&gt;\n&lt;li&gt;Does not support function overloading&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2&gt;&lt;strong&gt;mb_string&lt;/strong&gt;&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;Enables zend_multibyte support&lt;/li&gt;\n&lt;li&gt;Supports transparent HTTP in/out encoding&lt;/li&gt;\n&lt;li&gt;Provides some wrappers for functionality such as strtoupper&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2&gt;&lt;strong&gt;ICONV&lt;/strong&gt;&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;Primary for charset conversion&lt;/li&gt;\n&lt;li&gt;Output buffer handler&lt;/li&gt;\n&lt;li&gt;mime encoding functionality&lt;/li&gt;\n&lt;li&gt;conversion&lt;/li&gt;\n&lt;li&gt;some string helpers (len, substr, strpos, strrpos)&lt;/li&gt;\n&lt;li&gt;Stream Filter &lt;code&gt;stream_filter_append($fp, &apos;convert.iconv.ISO-2022-JP/EUC-JP&apos;)&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2&gt;&lt;strong&gt;DATABASES&lt;/strong&gt;&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;MySQL: Charset and collation on tables and on the connection (not the collation). Also, don&apos;t use mysql - mysqli or PDO&lt;/li&gt;\n&lt;li&gt;postgresql: pg_set_client_encoding&lt;/li&gt;\n&lt;li&gt;sqlite(3): Make sure it was compiled with Unicode and intl support&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2&gt;&lt;strong&gt;Some other gotchas&lt;/strong&gt;&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;You cannot use Unicode filenames with PHP and windows unless you use a 3rd part extension.&lt;/li&gt;\n&lt;li&gt;Send everything in ASCII if you are using exec, proc_open and other command line calls&lt;/li&gt;\n&lt;li&gt;Plain text is not plain text, files have encodings&lt;/li&gt;\n&lt;li&gt;You can convert files on the fly with the iconv filter&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;The only thing I would add to these amazing answers is to emphasize on saving your files in UTF-8 encoding, I have noticed that browsers accept this property over setting UTF-8 as your code encoding. Any decent text editor will show you this. For example, &lt;a href=&quot;https://en.wikipedia.org/wiki/Notepad%2B%2B&quot; rel=&quot;nofollow noreferrer&quot;&gt;Notepad++&lt;/a&gt; has a menu option for file encoding, and it shows you the current encoding and enables you to change it. For all my PHP files I use UTF-8 without a &lt;a href=&quot;https://en.wikipedia.org/wiki/Byte_order_mark&quot; rel=&quot;nofollow noreferrer&quot;&gt;BOM&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;Sometime ago I had someone ask me to add UTF-8 support for a PHP and MySQL application designed by someone else. I noticed that all files were encoded in ANSI, so I had to use &lt;a href=&quot;https://en.wikipedia.org/wiki/Iconv&quot; rel=&quot;nofollow noreferrer&quot;&gt;iconv&lt;/a&gt; to convert all files, change the database tables to use the UTF-8 character set and &lt;em&gt;utf8_general_ci&lt;/em&gt; collate, add &apos;SET NAMES utf8&apos; to the database abstraction layer after the connection (if using 5.3.6 or earlier. Otherwise, you have to use charset=utf8 in the connection string) and change string functions to use the PHP multibyte string functions equivalent.&lt;/p&gt;\n    ","\n&lt;p&gt;I recently discovered that using &lt;code&gt;strtolower()&lt;/code&gt; can cause issues where the data is truncated after a special character.&lt;/p&gt;\n\n&lt;p&gt;The solution was to use &lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;mb_strtolower(&lt;span class=&quot;hljs-variable&quot;&gt;$string&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;UTF-8&apos;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;mb_ uses MultiByte. It supports more characters but in general is a little slower.&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;In PHP, you&apos;ll need to either use the &lt;a href=&quot;http://us2.php.net/manual/en/ref.mbstring.php&quot; rel=&quot;noreferrer&quot;&gt;multibyte functions&lt;/a&gt;, or turn on &lt;a href=&quot;http://us2.php.net/manual/en/mbstring.configuration.php&quot; rel=&quot;noreferrer&quot;&gt;mbstring.func_overload&lt;/a&gt;. That way things like strlen will work if you have characters that take more than one byte.&lt;/p&gt;\n\n&lt;p&gt;You&apos;ll also need to identify the character set of your responses. You can either use AddDefaultCharset, as above, or write PHP code that returns the header. (Or you can add a META tag to your HTML documents.)&lt;/p&gt;\n    ","\n&lt;p&gt;I have just gone through the same issue and found a good solution at PHP manuals.&lt;/p&gt;\n&lt;p&gt;I changed all my files&apos; encoding to UTF8 and then the default encoding on my connection. This solved all the problems.&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-perl&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!$mysqli-&amp;gt;set_charset(&lt;span class=&quot;hljs-string&quot;&gt;&quot;utf8&quot;&lt;/span&gt;)) {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Error loading character set utf8: %s\\n&quot;&lt;/span&gt;, $mysqli-&amp;gt;error);\n} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {\n   &lt;span class=&quot;hljs-keyword&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Current character set: %s\\n&quot;&lt;/span&gt;, $mysqli-&amp;gt;character_set_name());\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;a href=&quot;http://php.net/manual/en/mysqli.set-charset.php&quot; rel=&quot;nofollow noreferrer&quot;&gt;View Source&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Unicode support in PHP is still a huge mess. While it&apos;s capable of converting an &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO/IEC_8859-1&quot; rel=&quot;nofollow noreferrer&quot;&gt;ISO&amp;nbsp;8859&lt;/a&gt; string (which it uses internally) to UTF-8, it lacks the capability to work with Unicode strings natively, which means all the string processing functions will mangle and corrupt your strings.&lt;/p&gt;\n&lt;p&gt;So you have to either use a separate library for proper UTF-8 support, or rewrite all the string handling functions yourself.&lt;/p&gt;\n&lt;p&gt;The easy part is just specifying the charset in HTTP headers and in the database and such, but none of that matters if your PHP code doesn&apos;t output valid UTF-8. That&apos;s the hard part, and PHP gives you virtually no help there. (I think PHP&amp;nbsp;6 is supposed to fix the worst of this, but that&apos;s still a while away.)&lt;/p&gt;\n    ","\n&lt;p&gt;If you want a MySQL server to decide the character set, and not PHP as a client (old behaviour; preferred, in my opinion), try adding &lt;code&gt;skip-character-set-client-handshake&lt;/code&gt; to your &lt;code&gt;my.cnf&lt;/code&gt;, under &lt;code&gt;[mysqld]&lt;/code&gt;, and restart &lt;code&gt;mysql&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;This may cause trouble in case you&apos;re using anything other than UTF-8.&lt;/p&gt;\n    ","\n&lt;p&gt;The top answer is excellent. Here is what I had to on a regular &lt;a href=&quot;https://en.wikipedia.org/wiki/Debian&quot; rel=&quot;nofollow noreferrer&quot;&gt;Debian&lt;/a&gt;, PHP, and &lt;a href=&quot;https://en.wikipedia.org/wiki/MySQL&quot; rel=&quot;nofollow noreferrer&quot;&gt;MySQL&lt;/a&gt; setup:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-scss&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Storage&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// Debian. Apparently already UTF-8&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// Retrieval&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// The MySQL database was stored in UTF-8,&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// but apparently PHP was requesting ISO 8859-1. This worked:&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// ***notice &quot;utf8&quot;, without dash, this is a MySQL encoding***&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;mysql_set_charset&lt;/span&gt;(&apos;utf8&apos;);\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// Delivery&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// File *php.ini* did not have a default charset,&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// (it was commented out, shared host) and&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// no HTTP encoding was specified in the Apache headers.&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// This made Apache send out a UTF-8 header&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// (and perhaps made PHP actually send out UTF-8)&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// ***notice &quot;utf-8&quot;, with dash, this is a php encoding***&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;ini_set&lt;/span&gt;(&apos;default_charset&apos;,&apos;utf-&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;&apos;);\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// Submission&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// This worked in all major browsers once Apache&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// was sending out the UTF-8 header. I didnt add&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// the accept-charset attribute.&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// Processing&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// Changed a few commands in PHP, like substr(),&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// to mb_substr()&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;That was all!&lt;/p&gt;\n    "]},"randomTags":[{"name":"default-constructor","slug":"default-constructor"},{"name":"android-layout","slug":"android-layout"},{"name":"centering","slug":"centering"},{"name":"nested","slug":"nested"},{"name":"full-outer-join","slug":"full-outer-join"},{"name":"hash","slug":"hash"},{"name":"flask-restless","slug":"flask-restless"},{"name":"dimension","slug":"dimension"},{"name":"data-manipulation","slug":"data-manipulation"},{"name":"bitwise-operators","slug":"bitwise-operators"},{"name":"cartesian-product","slug":"cartesian-product"},{"name":"collision-detection","slug":"collision-detection"},{"name":"autowired","slug":"autowired"},{"name":"uniqueidentifier","slug":"uniqueidentifier"},{"name":"regex","slug":"regex"},{"name":"http-redirect","slug":"http-redirect"},{"name":"substring","slug":"substring"},{"name":"css","slug":"css"},{"name":"python-import","slug":"python-import"},{"name":"c99","slug":"c99"}]},"__N_SSG":true}