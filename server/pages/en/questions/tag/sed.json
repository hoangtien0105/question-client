{"pageProps":{"data":{"count":1,"rows":[{"id":563,"title":"Is it possible to escape regex metacharacters reliably with sed","slug":"is-it-possible-to-escape-regex-metacharacters-reliably-with-sed-1657388428795","postType":"QUESTION","createdAt":"2022-07-09T17:40:28.000Z","updatedAt":"2022-07-09T17:40:28.000Z","tags":[{"id":2721,"name":"sed","slug":"sed","createdAt":"2022-07-09T17:40:28.000Z","updatedAt":"2022-07-09T17:40:28.000Z","Questions_Tags":{"questionId":563,"tagId":2721}}]}]},"slug":"sed","page":1,"answers":{"563":["\n&lt;p&gt;Note:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;If you&apos;re looking for &lt;strong&gt;prepackaged functionality&lt;/strong&gt; based on the techniques discussed in this answer:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;&lt;code&gt;bash&lt;/code&gt; functions&lt;/strong&gt; that enable &lt;strong&gt;robust escaping&lt;/strong&gt; even in &lt;strong&gt;&lt;em&gt;multi-line&lt;/em&gt; substitutions&lt;/strong&gt; can be found at the &lt;strong&gt;bottom of this post&lt;/strong&gt; (plus a &lt;code&gt;perl&lt;/code&gt; solution that uses &lt;code&gt;perl&lt;/code&gt;&apos;s built-in support for such escaping).&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/a/29626460/1745001&quot;&gt;@EdMorton&apos;s answer&lt;/a&gt; contains a &lt;strong&gt;tool&lt;/strong&gt; (&lt;code&gt;bash&lt;/code&gt; script) that robustly performs &lt;strong&gt;&lt;em&gt;single-line&lt;/em&gt; substitutions&lt;/strong&gt;.\n&lt;ul&gt;\n&lt;li&gt;Ed&apos;s answer now has &lt;strong&gt;an &lt;em&gt;improved&lt;/em&gt; version of the &lt;code&gt;sed&lt;/code&gt; command used below&lt;/strong&gt;, which is needed if you want &lt;strong&gt;to escape string literals for potential use with &lt;em&gt;other&lt;/em&gt; regex-processing tools, such as &lt;code&gt;awk&lt;/code&gt; and &lt;code&gt;perl&lt;/code&gt;.&lt;/strong&gt; In short: &lt;strong&gt;for cross-tool use, &lt;code&gt;\\&lt;/code&gt; must be escaped as &lt;code&gt;\\\\&lt;/code&gt; rather than as &lt;code&gt;[\\]&lt;/code&gt;&lt;/strong&gt;, which means: instead of the&lt;br&gt;\n&lt;code&gt;sed &apos;s/[^^]/[&amp;amp;]/g; s/\\^/\\\\^/g&apos;&lt;/code&gt; command used below, you must use&lt;br&gt;\n&lt;code&gt;sed &apos;s/[^^\\\\]/[&amp;amp;]/g; s/\\^/\\\\^/g; s/\\\\/\\\\\\\\/g&apos;&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;All snippets assume &lt;code&gt;bash&lt;/code&gt; as the shell (POSIX-compliant reformulations are possible):&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;h2&gt;SINGLE-line Solutions&lt;/h2&gt;\n&lt;hr&gt;\n&lt;h3&gt;Escaping a string literal for use as a &lt;em&gt;regex&lt;/em&gt; in &lt;code&gt;sed&lt;/code&gt;:&lt;/h3&gt;\n&lt;p&gt;&lt;sup&gt;To give credit where credit is due: I found the regex used below in &lt;a href=&quot;https://stackoverflow.com/a/28783790/45375&quot;&gt;this answer&lt;/a&gt;.&lt;/sup&gt;&lt;/p&gt;\n&lt;p&gt;Assuming that the search string is a &lt;em&gt;single&lt;/em&gt;-line string:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;search=&lt;span class=&quot;hljs-string&quot;&gt;&apos;abc\\n\\t[a-z]\\+\\([^ ]\\)\\{2,3\\}\\3&apos;&lt;/span&gt;  &lt;span class=&quot;hljs-comment&quot;&gt;# sample input containing metachars.&lt;/span&gt;\n\nsearchEscaped=$(sed &lt;span class=&quot;hljs-string&quot;&gt;&apos;s/[^^]/[&amp;amp;]/g; s/\\^/\\\\^/g&apos;&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$search&lt;/span&gt;&quot;&lt;/span&gt;) &lt;span class=&quot;hljs-comment&quot;&gt;# escape it.&lt;/span&gt;\n\nsed -n &lt;span class=&quot;hljs-string&quot;&gt;&quot;s/&lt;span class=&quot;hljs-variable&quot;&gt;$searchEscaped&lt;/span&gt;/foo/p&quot;&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$search&lt;/span&gt;&quot;&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;# if ok, echoes &apos;foo&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;Every character except &lt;code&gt;^&lt;/code&gt; is placed in its own character set &lt;code&gt;[...]&lt;/code&gt; expression to treat it as a literal.\n&lt;ul&gt;\n&lt;li&gt;Note that &lt;code&gt;^&lt;/code&gt; is the one char. you &lt;em&gt;cannot&lt;/em&gt; represent as &lt;code&gt;[^]&lt;/code&gt;, because it has special meaning in that location (negation).&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;Then, &lt;code&gt;^&lt;/code&gt; chars. are escaped as &lt;code&gt;\\^&lt;/code&gt;.\n&lt;ul&gt;\n&lt;li&gt;Note that you cannot just escape every char by putting a &lt;code&gt;\\&lt;/code&gt; in front of it because that can turn a literal char into a metachar, e.g. &lt;code&gt;\\&amp;lt;&lt;/code&gt; and &lt;code&gt;\\b&lt;/code&gt; are word boundaries in some tools, &lt;code&gt;\\n&lt;/code&gt; is a newline, &lt;code&gt;\\{&lt;/code&gt; is the start of a RE interval like &lt;code&gt;\\{1,3\\}&lt;/code&gt;, etc.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;The approach is robust, but not efficient.&lt;/p&gt;\n&lt;p&gt;The &lt;strong&gt;robustness comes from &lt;em&gt;not&lt;/em&gt; trying to anticipate all special regex characters&lt;/strong&gt; - which will vary across regex dialects - but to &lt;strong&gt;focus on only 2 features &lt;em&gt;shared by all regex dialects&lt;/em&gt;&lt;/strong&gt;:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;the ability to specify literal characters inside a character set.&lt;/li&gt;\n&lt;li&gt;the ability to escape a literal  &lt;code&gt;^&lt;/code&gt; as &lt;code&gt;\\^&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;h3&gt;Escaping a string literal for use as the &lt;em&gt;replacement string&lt;/em&gt; in &lt;code&gt;sed&lt;/code&gt;&apos;s &lt;code&gt;s///&lt;/code&gt; command:&lt;/h3&gt;\n&lt;p&gt;The replacement string in a &lt;code&gt;sed&lt;/code&gt; &lt;code&gt;s///&lt;/code&gt; command is not a regex, but it recognizes &lt;em&gt;placeholders&lt;/em&gt; that refer to either the entire string matched by the regex (&lt;code&gt;&amp;amp;&lt;/code&gt;) or specific capture-group results by index (&lt;code&gt;\\1&lt;/code&gt;, &lt;code&gt;\\2&lt;/code&gt;, ...), so these must be escaped, along with the (customary) regex delimiter, &lt;code&gt;/&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;Assuming that the replacement string is a &lt;em&gt;single&lt;/em&gt;-line string:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;replace=&lt;span class=&quot;hljs-string&quot;&gt;&apos;Laurel &amp;amp; Hardy; PS\\2&apos;&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;# sample input containing metachars.&lt;/span&gt;\n\nreplaceEscaped=$(sed &lt;span class=&quot;hljs-string&quot;&gt;&apos;s/[&amp;amp;/\\]/\\\\&amp;amp;/g&apos;&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$replace&lt;/span&gt;&quot;&lt;/span&gt;) &lt;span class=&quot;hljs-comment&quot;&gt;# escape it&lt;/span&gt;\n\nsed -n &lt;span class=&quot;hljs-string&quot;&gt;&quot;s/\\(.*\\) \\(.*\\)/&lt;span class=&quot;hljs-variable&quot;&gt;$replaceEscaped&lt;/span&gt;/p&quot;&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;foo bar&quot;&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;# if ok, outputs $replace as is&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;hr&gt;\n&lt;hr&gt;\n&lt;h2&gt;MULTI-line Solutions&lt;/h2&gt;\n&lt;hr&gt;\n&lt;h3&gt;Escaping a MULTI-LINE string literal for use as a &lt;em&gt;regex&lt;/em&gt; in &lt;code&gt;sed&lt;/code&gt;:&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: This only makes sense if &lt;em&gt;multiple input lines&lt;/em&gt; (possibly ALL) have been read before attempting to match.&lt;br&gt;\nSince tools such as &lt;code&gt;sed&lt;/code&gt; and &lt;code&gt;awk&lt;/code&gt; operate on a &lt;em&gt;single&lt;/em&gt; line at a time by default, extra steps are needed to make them read more than one line at a time.&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# Define sample multi-line literal.&lt;/span&gt;\nsearch=&lt;span class=&quot;hljs-string&quot;&gt;&apos;/abc\\n\\t[a-z]\\+\\([^ ]\\)\\{2,3\\}\\3\n/def\\n\\t[A-Z]\\+\\([^ ]\\)\\{3,4\\}\\4&apos;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# Escape it.&lt;/span&gt;\nsearchEscaped=$(sed -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;s/[^^]/[&amp;amp;]/g; s/\\^/\\\\^/g; $!a\\&apos;&lt;/span&gt;$&lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&apos;\\\\n&apos;&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$search&lt;/span&gt;&quot;&lt;/span&gt; | &lt;span class=&quot;hljs-built_in&quot;&gt;tr&lt;/span&gt; -d &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;)           &lt;span class=&quot;hljs-comment&quot;&gt;#&apos;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# Use in a Sed command that reads ALL input lines up front.&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;# If ok, echoes &apos;foo&apos;&lt;/span&gt;\nsed -n -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;:a&apos;&lt;/span&gt; -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;$!{N;ba&apos;&lt;/span&gt; -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;}&apos;&lt;/span&gt; -e &lt;span class=&quot;hljs-string&quot;&gt;&quot;s/&lt;span class=&quot;hljs-variable&quot;&gt;$searchEscaped&lt;/span&gt;/foo/p&quot;&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$search&lt;/span&gt;&quot;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;The newlines in multi-line input strings must be translated to &lt;code&gt;&apos;\\n&apos;&lt;/code&gt; &lt;em&gt;strings&lt;/em&gt;, which is how newlines are encoded in a regex.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;$!a\\&apos;$&apos;\\n&apos;&apos;\\\\n&apos;&lt;/code&gt; appends &lt;em&gt;string&lt;/em&gt; &lt;code&gt;&apos;\\n&apos;&lt;/code&gt; to every output line but the last (the last newline is ignored, because it was added by &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;)&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;tr -d &apos;\\n&lt;/code&gt; then removes all &lt;em&gt;actual&lt;/em&gt; newlines from the string (&lt;code&gt;sed&lt;/code&gt; adds one whenever it prints its pattern space), effectively replacing all newlines in the input with &lt;code&gt;&apos;\\n&apos;&lt;/code&gt; strings.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;&lt;code&gt;-e &apos;:a&apos; -e &apos;$!{N;ba&apos; -e &apos;}&apos;&lt;/code&gt; is the POSIX-compliant form of a &lt;code&gt;sed&lt;/code&gt; idiom that reads &lt;em&gt;all&lt;/em&gt; input lines a loop, therefore leaving subsequent commands to operate on all input lines at once.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;If you&apos;re using &lt;em&gt;GNU&lt;/em&gt; &lt;code&gt;sed&lt;/code&gt; (only), you can use its &lt;code&gt;-z&lt;/code&gt; option to simplify reading all input lines at once:&lt;br&gt;\n&lt;code&gt;sed -z &quot;s/$searchEscaped/foo/&quot; &amp;lt;&amp;lt;&amp;lt;&quot;$search&quot;&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;h3&gt;Escaping a MULTI-LINE string literal for use as the &lt;em&gt;replacement string&lt;/em&gt; in &lt;code&gt;sed&lt;/code&gt;&apos;s &lt;code&gt;s///&lt;/code&gt; command:&lt;/h3&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# Define sample multi-line literal.&lt;/span&gt;\nreplace=&lt;span class=&quot;hljs-string&quot;&gt;&apos;Laurel &amp;amp; Hardy; PS\\2\nMasters\\1 &amp;amp; Johnson\\2&apos;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# Escape it for use as a Sed replacement string.&lt;/span&gt;\nIFS= &lt;span class=&quot;hljs-built_in&quot;&gt;read&lt;/span&gt; -d &lt;span class=&quot;hljs-string&quot;&gt;&apos;&apos;&lt;/span&gt; -r &amp;lt; &amp;lt;(sed -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;:a&apos;&lt;/span&gt; -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;$!{N;ba&apos;&lt;/span&gt; -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;}&apos;&lt;/span&gt; -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;s/[&amp;amp;/\\]/\\\\&amp;amp;/g; s/\\n/\\\\&amp;amp;/g&apos;&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$replace&lt;/span&gt;&quot;&lt;/span&gt;)\nreplaceEscaped=&lt;span class=&quot;hljs-variable&quot;&gt;${REPLY%$&apos;\\n&apos;}&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# If ok, outputs $replace as is.&lt;/span&gt;\nsed -n &lt;span class=&quot;hljs-string&quot;&gt;&quot;s/\\(.*\\) \\(.*\\)/&lt;span class=&quot;hljs-variable&quot;&gt;$replaceEscaped&lt;/span&gt;/p&quot;&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;foo bar&quot;&lt;/span&gt; \n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;Newlines in the input string must be retained as actual newlines, but &lt;code&gt;\\&lt;/code&gt;-escaped.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;-e &apos;:a&apos; -e &apos;$!{N;ba&apos; -e &apos;}&apos;&lt;/code&gt; is the POSIX-compliant form of a &lt;code&gt;sed&lt;/code&gt; idiom that reads &lt;em&gt;all&lt;/em&gt; input lines a loop.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;&apos;s/[&amp;amp;/\\]/\\\\&amp;amp;/g&lt;/code&gt; escapes all &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;\\&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt; instances, as in the single-line solution.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;s/\\n/\\\\&amp;amp;/g&apos;&lt;/code&gt; then &lt;code&gt;\\&lt;/code&gt;-prefixes all actual newlines.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;IFS= read -d &apos;&apos; -r&lt;/code&gt; is used to read the &lt;code&gt;sed&lt;/code&gt; command&apos;s output &lt;em&gt;as is&lt;/em&gt; (to avoid the automatic removal of trailing newlines that a command substitution (&lt;code&gt;$(...)&lt;/code&gt;) would perform).&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;${REPLY%$&apos;\\n&apos;}&lt;/code&gt; then removes a &lt;em&gt;single&lt;/em&gt; trailing newline, which the &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; has implicitly appended to the input.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;hr&gt;\n&lt;h2&gt;&lt;em&gt;&lt;code&gt;bash&lt;/code&gt; functions&lt;/em&gt; based on the above (for &lt;code&gt;sed&lt;/code&gt;):&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;quoteRe()&lt;/code&gt; quotes (escapes) for use in a &lt;em&gt;regex&lt;/em&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;quoteSubst()&lt;/code&gt; quotes for use in the &lt;em&gt;substitution string&lt;/em&gt; of a &lt;code&gt;s///&lt;/code&gt; call.&lt;/li&gt;\n&lt;li&gt;both handle &lt;em&gt;multi-line&lt;/em&gt; input correctly\n&lt;ul&gt;\n&lt;li&gt;Note that because &lt;code&gt;sed&lt;/code&gt; reads a &lt;em&gt;single&lt;/em&gt; line at at time by default, use of &lt;code&gt;quoteRe()&lt;/code&gt; with multi-line strings only makes sense in &lt;code&gt;sed&lt;/code&gt; commands that explicitly read multiple (or all) lines at once.&lt;/li&gt;\n&lt;li&gt;Also, using command substitutions (&lt;code&gt;$(...)&lt;/code&gt;) to call the functions won&apos;t work for strings that have &lt;em&gt;trailing&lt;/em&gt; newlines; in that event, use something like &lt;code&gt;IFS= read -d &apos;&apos; -r escapedValue &amp;lt;(quoteSubst &quot;$value&quot;)&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre class=&quot;lang-sh s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# SYNOPSIS&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;#   quoteRe &amp;lt;text&amp;gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;quoteRe&lt;/span&gt;&lt;/span&gt;() { sed -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;s/[^^]/[&amp;amp;]/g; s/\\^/\\\\^/g; $!a\\&apos;&lt;/span&gt;$&lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&apos;\\\\n&apos;&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$1&lt;/span&gt;&quot;&lt;/span&gt; | &lt;span class=&quot;hljs-built_in&quot;&gt;tr&lt;/span&gt; -d &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;; }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-perl&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# SYNOPSIS&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;#  quoteSubst &amp;lt;text&amp;gt;&lt;/span&gt;\nquoteSubst() {\n  IFS= &lt;span class=&quot;hljs-keyword&quot;&gt;read&lt;/span&gt; -d &lt;span class=&quot;hljs-string&quot;&gt;&apos;&apos;&lt;/span&gt; -r &amp;lt; &amp;lt;(sed -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;:a&apos;&lt;/span&gt; -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;$!{N;ba&apos;&lt;/span&gt; -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;}&apos;&lt;/span&gt; -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;s/[&amp;amp;/\\]/\\\\&amp;amp;/g; s/\\n/\\\\&amp;amp;/g&apos;&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;$1&quot;&lt;/span&gt;)\n  &lt;span class=&quot;hljs-keyword&quot;&gt;printf&lt;/span&gt; %s &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-subst&quot;&gt;${REPLY%$&lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;}&lt;/span&gt;&quot;&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;from=$&lt;span class=&quot;hljs-string&quot;&gt;&apos;Cost\\(*):\\n$3.&apos;&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;# sample input containing metachars. &lt;/span&gt;\nto=&lt;span class=&quot;hljs-string&quot;&gt;&apos;You &amp;amp; I&apos;&lt;/span&gt;$&lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&apos;eating A\\1 sauce.&apos;&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;# sample replacement string with metachars.&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# Should print the unmodified value of $to&lt;/span&gt;\nsed -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;:a&apos;&lt;/span&gt; -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;$!{N;ba&apos;&lt;/span&gt; -e &lt;span class=&quot;hljs-string&quot;&gt;&apos;}&apos;&lt;/span&gt; -e &lt;span class=&quot;hljs-string&quot;&gt;&quot;s/&lt;span class=&quot;hljs-subst&quot;&gt;$(quoteRe &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$from&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;/&lt;span class=&quot;hljs-subst&quot;&gt;$(quoteSubst &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$to&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;/&quot;&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$from&lt;/span&gt;&quot;&lt;/span&gt; \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Note the use of &lt;code&gt;-e &apos;:a&apos; -e &apos;$!{N;ba&apos; -e &apos;}&apos;&lt;/code&gt; to read all input at once, so that the multi-line substitution works.&lt;/p&gt;\n&lt;hr&gt;\n&lt;hr&gt;\n&lt;h2&gt;&lt;code&gt;perl&lt;/code&gt; solution:&lt;/h2&gt;\n&lt;p&gt;&lt;strong&gt;Perl has built-in support&lt;/strong&gt; for escaping arbitrary strings for literal use in a regex: the &lt;strong&gt;&lt;a href=&quot;http://perldoc.perl.org/functions/quotemeta.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;quotemeta()&lt;/code&gt; function&lt;/a&gt; or its equivalent &lt;code&gt;\\Q...\\E&lt;/code&gt; quoting&lt;/strong&gt;.&lt;br&gt;\nThe approach is the same for both single- and multi-line strings; for example:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt;=$&lt;span class=&quot;hljs-string&quot;&gt;&apos;Cost\\(*):\\n$3.&apos;&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;# sample input containing metachars.&lt;/span&gt;\nto=&lt;span class=&quot;hljs-string&quot;&gt;&apos;You owe me $1/$&amp;amp; for&apos;&lt;/span&gt;$&lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&apos;eating A\\1 sauce.&apos;&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;# sample replacement string w/ metachars.&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# Should print the unmodified value of $to.&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;# Note that the replacement value needs NO escaping.&lt;/span&gt;\nperl -s -&lt;span class=&quot;hljs-number&quot;&gt;0777&lt;/span&gt; -pe &lt;span class=&quot;hljs-string&quot;&gt;&apos;s/\\Q$from\\E/$to/&apos;&lt;/span&gt; -- -&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-subst&quot;&gt;$from&lt;/span&gt;&quot;&lt;/span&gt; -to=&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-subst&quot;&gt;$to&lt;/span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-subst&quot;&gt;$from&lt;/span&gt;&quot;&lt;/span&gt; \n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;Note the use of &lt;code&gt;-0777&lt;/code&gt; to read all input at once, so that the multi-line substitution works.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;The &lt;code&gt;-s&lt;/code&gt; option allows placing &lt;code&gt;-&amp;lt;var&amp;gt;=&amp;lt;val&amp;gt;&lt;/code&gt;-style Perl variable definitions following &lt;code&gt;--&lt;/code&gt; after the script, before any filename operands.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;Building upon &lt;a href=&quot;https://stackoverflow.com/a/29613573/1745001&quot;&gt;@mklement0&apos;s answer&lt;/a&gt; in this thread, the following tool will replace any single-line string (as opposed to regexp) with any other single-line string using &lt;code&gt;sed&lt;/code&gt; and &lt;code&gt;bash&lt;/code&gt;:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;$ &lt;span class=&quot;hljs-built_in&quot;&gt;cat&lt;/span&gt; sedstr\n&lt;span class=&quot;hljs-comment&quot;&gt;#!/bin/bash&lt;/span&gt;\nold=&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$1&lt;/span&gt;&quot;&lt;/span&gt;\nnew=&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$2&lt;/span&gt;&quot;&lt;/span&gt;\nfile=&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;${3:--}&lt;/span&gt;&quot;&lt;/span&gt;\nescOld=$(sed &lt;span class=&quot;hljs-string&quot;&gt;&apos;s/[^^\\\\]/[&amp;amp;]/g; s/\\^/\\\\^/g; s/\\\\/\\\\\\\\/g&apos;&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$old&lt;/span&gt;&quot;&lt;/span&gt;)\nescNew=$(sed &lt;span class=&quot;hljs-string&quot;&gt;&apos;s/[&amp;amp;/\\]/\\\\&amp;amp;/g&apos;&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$new&lt;/span&gt;&quot;&lt;/span&gt;)\nsed &lt;span class=&quot;hljs-string&quot;&gt;&quot;s/&lt;span class=&quot;hljs-variable&quot;&gt;$escOld&lt;/span&gt;/&lt;span class=&quot;hljs-variable&quot;&gt;$escNew&lt;/span&gt;/g&quot;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$file&lt;/span&gt;&quot;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;To illustrate the need for this tool, consider trying to replace &lt;code&gt;a.*/b{2,}\\nc&lt;/code&gt; with &lt;code&gt;d&amp;amp;e\\1f&lt;/code&gt; by calling &lt;code&gt;sed&lt;/code&gt; directly:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;$ &lt;span class=&quot;hljs-built_in&quot;&gt;cat&lt;/span&gt; file\na.*/b{2,}\\nc\naxx/bb\\nc\n\n$ sed &lt;span class=&quot;hljs-string&quot;&gt;&apos;s/a.*/b{2,}\\nc/d&amp;amp;e\\1f/&apos;&lt;/span&gt; file  \nsed: -e expression &lt;span class=&quot;hljs-comment&quot;&gt;#1, char 16: unknown option to `s&apos;&lt;/span&gt;\n$ sed &lt;span class=&quot;hljs-string&quot;&gt;&apos;s/a.*\\/b{2,}\\nc/d&amp;amp;e\\1f/&apos;&lt;/span&gt; file\nsed: -e expression &lt;span class=&quot;hljs-comment&quot;&gt;#1, char 23: invalid reference \\1 on `s&apos; command&apos;s RHS&lt;/span&gt;\n$ sed &lt;span class=&quot;hljs-string&quot;&gt;&apos;s/a.*\\/b{2,}\\nc/d&amp;amp;e\\\\1f/&apos;&lt;/span&gt; file\na.*/b{2,}\\nc\naxx/bb\\nc\n&lt;span class=&quot;hljs-comment&quot;&gt;# .... and so on, peeling the onion ad nauseum until:&lt;/span&gt;\n$ sed &lt;span class=&quot;hljs-string&quot;&gt;&apos;s/a\\.\\*\\/b{2,}\\\\nc/d\\&amp;amp;e\\\\1f/&apos;&lt;/span&gt; file\nd&amp;amp;e\\1f\naxx/bb\\nc\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;or use the above tool:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;$ sedstr &lt;span class=&quot;hljs-string&quot;&gt;&apos;a.*/b{2,}\\nc&apos;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;d&amp;amp;e\\1f&apos;&lt;/span&gt; file  \nd&amp;amp;e\\1f\naxx/bb\\nc\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The reason this is useful is that it can be easily augmented to use word-delimiters to replace words if necessary, e.g. in GNU &lt;code&gt;sed&lt;/code&gt; syntax:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;sed &lt;span class=&quot;hljs-string&quot;&gt;&quot;s/\\&amp;lt;&lt;span class=&quot;hljs-variable&quot;&gt;$escOld&lt;/span&gt;\\&amp;gt;/&lt;span class=&quot;hljs-variable&quot;&gt;$escNew&lt;/span&gt;/g&quot;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$file&lt;/span&gt;&quot;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;whereas the tools that actually operate on strings (e.g. &lt;code&gt;awk&lt;/code&gt;&apos;s &lt;code&gt;index()&lt;/code&gt;) cannot use word-delimiters.&lt;/p&gt;\n&lt;p&gt;NOTE: the reason to not wrap &lt;code&gt;\\&lt;/code&gt; in a bracket expression is that if you were using a tool that accepts &lt;code&gt;[\\]]&lt;/code&gt; as a literal &lt;code&gt;]&lt;/code&gt; inside a bracket expression (e.g. perl and most awk implementations) to do the actual final substitution (i.e. instead of &lt;code&gt;sed &quot;s/$escOld/$escNew/g&quot;&lt;/code&gt;) then you couldn&apos;t use the approach of:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;sed &lt;span class=&quot;hljs-string&quot;&gt;&apos;s/[^^]/[&amp;amp;]/g; s/\\^/\\\\^/g&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;to escape &lt;code&gt;\\&lt;/code&gt; by enclosing it in &lt;code&gt;[]&lt;/code&gt; because then &lt;code&gt;\\x&lt;/code&gt; would become &lt;code&gt;[\\][x]&lt;/code&gt; which means &lt;code&gt;\\ or ] or [ or x&lt;/code&gt;. Instead you&apos;d need:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;sed &lt;span class=&quot;hljs-string&quot;&gt;&apos;s/[^^\\\\]/[&amp;amp;]/g; s/\\^/\\\\^/g; s/\\\\/\\\\\\\\/g&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;So while &lt;code&gt;[\\]&lt;/code&gt; is probably OK for all current sed implementations, we know that &lt;code&gt;\\\\&lt;/code&gt; will work for all sed, awk, perl, etc. implementations and so use that form of escaping.&lt;/p&gt;\n    ","\n&lt;p&gt;It should be noted that the regular expression used in some answers above among &lt;a href=&quot;https://stackoverflow.com/a/29626460/6646161&quot;&gt;this&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/a/29613573/6646161&quot;&gt;that one&lt;/a&gt;:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&apos;s/[^^\\\\]/[&amp;amp;]/g; s/\\^/\\\\^/g; s/\\\\/\\\\\\\\/g&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;seems to be wrong:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Doing first &lt;code&gt;s/\\^/\\\\^/g&lt;/code&gt; followed by &lt;code&gt;s/\\\\/\\\\\\\\/g&lt;/code&gt; is an error, as any &lt;code&gt;^&lt;/code&gt; escaped first to &lt;code&gt;\\^&lt;/code&gt; will then have its &lt;code&gt;\\&lt;/code&gt; escaped again.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;A better way seems to be: &lt;code&gt;&apos;s/[^\\^]/[&amp;amp;]/g; s/[\\^]/\\\\&amp;amp;/g;&apos;&lt;/code&gt;.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;[^^\\\\]&lt;/code&gt; with sed (BRE/ERE) should be just &lt;code&gt;[^\\^]&lt;/code&gt; (or &lt;code&gt;[^^\\]&lt;/code&gt;). &lt;code&gt;\\&lt;/code&gt; has no special meaning inside a bracket expression and needs not to be quoted.&lt;/li&gt;\n&lt;/ul&gt;\n    "]},"randomTags":[{"name":"variable-expansion","slug":"variable-expansion"},{"name":"addeventlistener","slug":"addeventlistener"},{"name":"file-upload","slug":"file-upload"},{"name":"mongodb","slug":"mongodb"},{"name":"boolean-expression","slug":"boolean-expression"},{"name":"php-password-hash","slug":"php-password-hash"},{"name":"copy-constructor","slug":"copy-constructor"},{"name":"typescript","slug":"typescript"},{"name":"heredoc","slug":"heredoc"},{"name":"facelets","slug":"facelets"},{"name":"oracle","slug":"oracle"},{"name":"aggregate","slug":"aggregate"},{"name":"shadowing","slug":"shadowing"},{"name":"observable","slug":"observable"},{"name":"dynamic-languages","slug":"dynamic-languages"},{"name":"environment-variables","slug":"environment-variables"},{"name":"git-checkout","slug":"git-checkout"},{"name":"variable-length-array","slug":"variable-length-array"},{"name":"dhtml","slug":"dhtml"},{"name":"combinatorics","slug":"combinatorics"}]},"__N_SSG":true}