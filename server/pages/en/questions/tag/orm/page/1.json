{"pageProps":{"data":{"count":1,"rows":[{"id":460,"title":"What is the \"N+1 selects problem\" in ORM (Object-Relational Mapping)?","slug":"what-is-the-\"n+1-selects-problem\"-in-orm-(object-relational-mapping)-1657388055597","postType":"QUESTION","createdAt":"2022-07-09T17:34:15.000Z","updatedAt":"2022-07-09T17:34:15.000Z","tags":[{"id":2356,"name":"orm","slug":"orm","createdAt":"2022-07-09T17:34:15.000Z","updatedAt":"2022-07-09T17:34:15.000Z","Questions_Tags":{"questionId":460,"tagId":2356}}]}]},"slug":"orm","page":"1","answers":{"460":["\n&lt;p&gt;Let&apos;s say you have a collection of &lt;code&gt;Car&lt;/code&gt; objects (database rows), and each &lt;code&gt;Car&lt;/code&gt; has a collection of &lt;code&gt;Wheel&lt;/code&gt; objects (also rows).  In other words, &lt;code&gt;Car&lt;/code&gt;  &lt;code&gt;Wheel&lt;/code&gt; is a 1-to-many relationship.&lt;/p&gt;\n&lt;p&gt;Now, let&apos;s say you need to iterate through all the cars, and for each one, print out a list of the wheels. The naive O/R implementation would do the following:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;SELECT * FROM Cars;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;And then &lt;strong&gt;for each &lt;code&gt;Car&lt;/code&gt;:&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;SELECT * FROM Wheel WHERE CarId = ?\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In other words, you have one select for the Cars, and then N additional selects, where N is the total number of cars.&lt;/p&gt;\n&lt;p&gt;Alternatively, one could get all wheels and perform the lookups in memory:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;SELECT * FROM Wheel\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This reduces the number of round-trips to the database from N+1 to 2.\nMost ORM tools give you several ways to prevent N+1 selects.&lt;/p&gt;\n&lt;p&gt;Reference: &lt;em&gt;&lt;a href=&quot;http://www.manning.com/bauer2/&quot; rel=&quot;noreferrer&quot;&gt;Java Persistence with Hibernate&lt;/a&gt;&lt;/em&gt;, chapter 13.&lt;/p&gt;\n    ","\n&lt;h2&gt;What is the N+1 query problem&lt;/h2&gt;\n&lt;p&gt;The N+1 query problem happens when the data access framework executed N additional SQL statements to fetch the same data that could have been retrieved when executing the primary SQL query.&lt;/p&gt;\n&lt;p&gt;The larger the value of N, the more queries will be executed, the larger the performance impact. And, unlike the slow query log that can help you find slow running queries, the N+1 issue wont be spot because each individual additional query runs sufficiently fast to not trigger the slow query log.&lt;/p&gt;\n&lt;p&gt;The problem is executing a large number of additional queries that, overall, take sufficient time to slow down response time.&lt;/p&gt;\n&lt;p&gt;Lets consider we have the following post and post_comments database tables which form a one-to-many table relationship:&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/T1uWG.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/T1uWG.png&quot; alt=&quot;The post and post_comments tables&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;We are going to create the following 4 &lt;code&gt;post&lt;/code&gt; rows:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;INSERT INTO post (title, id)\nVALUES (&apos;High-Performance Java Persistence - Part 1&apos;, 1)\n \nINSERT INTO post (title, id)\nVALUES (&apos;High-Performance Java Persistence - Part 2&apos;, 2)\n \nINSERT INTO post (title, id)\nVALUES (&apos;High-Performance Java Persistence - Part 3&apos;, 3)\n \nINSERT INTO post (title, id)\nVALUES (&apos;High-Performance Java Persistence - Part 4&apos;, 4)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;And, we will also create 4 &lt;code&gt;post_comment&lt;/code&gt; child records:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;INSERT INTO post_comment (post_id, review, id)\nVALUES (1, &apos;Excellent book to understand Java Persistence&apos;, 1)\n \nINSERT INTO post_comment (post_id, review, id)\nVALUES (2, &apos;Must-read for Java developers&apos;, 2)\n \nINSERT INTO post_comment (post_id, review, id)\nVALUES (3, &apos;Five Stars&apos;, 3)\n \nINSERT INTO post_comment (post_id, review, id)\nVALUES (4, &apos;A great reference book&apos;, 4)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2&gt;N+1 query problem with plain SQL&lt;/h2&gt;\n&lt;p&gt;If you select the &lt;code&gt;post_comments&lt;/code&gt; using this SQL query:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;List&amp;lt;Tuple&amp;gt; comments = entityManager.createNativeQuery(&quot;&quot;&quot;\n    SELECT\n        pc.id AS id,\n        pc.review AS review,\n        pc.post_id AS postId\n    FROM post_comment pc\n    &quot;&quot;&quot;, Tuple.class)\n.getResultList();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;And, later, you decide to fetch the associated &lt;code&gt;post&lt;/code&gt; &lt;code&gt;title&lt;/code&gt; for each &lt;code&gt;post_comment&lt;/code&gt;:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;for (Tuple comment : comments) {\n    String review = (String) comment.get(&quot;review&quot;);\n    Long postId = ((Number) comment.get(&quot;postId&quot;)).longValue();\n \n    String postTitle = (String) entityManager.createNativeQuery(&quot;&quot;&quot;\n        SELECT\n            p.title\n        FROM post p\n        WHERE p.id = :postId\n        &quot;&quot;&quot;)\n    .setParameter(&quot;postId&quot;, postId)\n    .getSingleResult();\n \n    LOGGER.info(\n        &quot;The Post &apos;{}&apos; got this review &apos;{}&apos;&quot;,\n        postTitle,\n        review\n    );\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;You are going to trigger the N+1 query issue because, instead of one SQL query, you executed 5 (1 + 4):&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;SELECT\n    pc.id AS id,\n    pc.review AS review,\n    pc.post_id AS postId\nFROM post_comment pc\n \nSELECT p.title FROM post p WHERE p.id = 1\n-- The Post &apos;High-Performance Java Persistence - Part 1&apos; got this review\n-- &apos;Excellent book to understand Java Persistence&apos;\n    \nSELECT p.title FROM post p WHERE p.id = 2\n-- The Post &apos;High-Performance Java Persistence - Part 2&apos; got this review\n-- &apos;Must-read for Java developers&apos;\n     \nSELECT p.title FROM post p WHERE p.id = 3\n-- The Post &apos;High-Performance Java Persistence - Part 3&apos; got this review\n-- &apos;Five Stars&apos;\n     \nSELECT p.title FROM post p WHERE p.id = 4\n-- The Post &apos;High-Performance Java Persistence - Part 4&apos; got this review\n-- &apos;A great reference book&apos;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Fixing the N+1 query issue is very easy. All you need to do is extract all the data you need in the original SQL query, like this:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;List&amp;lt;Tuple&amp;gt; comments = entityManager.createNativeQuery(&quot;&quot;&quot;\n    SELECT\n        pc.id AS id,\n        pc.review AS review,\n        p.title AS postTitle\n    FROM post_comment pc\n    JOIN post p ON pc.post_id = p.id\n    &quot;&quot;&quot;, Tuple.class)\n.getResultList();\n \nfor (Tuple comment : comments) {\n    String review = (String) comment.get(&quot;review&quot;);\n    String postTitle = (String) comment.get(&quot;postTitle&quot;);\n \n    LOGGER.info(\n        &quot;The Post &apos;{}&apos; got this review &apos;{}&apos;&quot;,\n        postTitle,\n        review\n    );\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This time, only one SQL query is executed to fetch all the data we are further interested in using.&lt;/p&gt;\n&lt;h2&gt;N+1 query problem with JPA and Hibernate&lt;/h2&gt;\n&lt;p&gt;When using JPA and Hibernate, there are several ways you can trigger the N+1 query issue, so its very important to know how you can avoid these situations.&lt;/p&gt;\n&lt;p&gt;For the next examples, consider we are mapping the &lt;code&gt;post&lt;/code&gt; and &lt;code&gt;post_comments&lt;/code&gt; tables to the following entities:&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/rZJne.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/rZJne.png&quot; alt=&quot;Post and PostComment entities&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;The JPA mappings look like this:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;@Entity(name = &quot;Post&quot;)\n@Table(name = &quot;post&quot;)\npublic class Post {\n \n    @Id\n    private Long id;\n \n    private String title;\n \n    //Getters and setters omitted for brevity\n}\n \n@Entity(name = &quot;PostComment&quot;)\n@Table(name = &quot;post_comment&quot;)\npublic class PostComment {\n \n    @Id\n    private Long id;\n \n    @ManyToOne\n    private Post post;\n \n    private String review;\n \n    //Getters and setters omitted for brevity\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2&gt;&lt;code&gt;FetchType.EAGER&lt;/code&gt;&lt;/h2&gt;\n&lt;p&gt;Using &lt;code&gt;FetchType.EAGER&lt;/code&gt; either implicitly or explicitly for your JPA associations is a bad idea because you are going to fetch way more data that you need. More, the &lt;code&gt;FetchType.EAGER&lt;/code&gt; strategy is also prone to N+1 query issues.&lt;/p&gt;\n&lt;p&gt;Unfortunately, the &lt;code&gt;@ManyToOne&lt;/code&gt; and &lt;code&gt;@OneToOne&lt;/code&gt; associations use &lt;code&gt;FetchType.EAGER&lt;/code&gt; by default, so if your mappings look like this:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;@ManyToOne\nprivate Post post;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;You are using the &lt;code&gt;FetchType.EAGER&lt;/code&gt; strategy, and, every time you forget to use &lt;code&gt;JOIN FETCH&lt;/code&gt; when loading some &lt;code&gt;PostComment&lt;/code&gt; entities with a JPQL or Criteria API query:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;List&amp;lt;PostComment&amp;gt; comments = entityManager\n.createQuery(&quot;&quot;&quot;\n    select pc\n    from PostComment pc\n    &quot;&quot;&quot;, PostComment.class)\n.getResultList();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;You are going to trigger the N+1 query issue:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;SELECT \n    pc.id AS id1_1_, \n    pc.post_id AS post_id3_1_, \n    pc.review AS review2_1_ \nFROM \n    post_comment pc\n\nSELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 1\nSELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 2\nSELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 3\nSELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 4\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Notice the additional SELECT statements that are executed because the &lt;code&gt;post&lt;/code&gt; association has to be fetched prior to returning the &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;PostComment&lt;/code&gt; entities.&lt;/p&gt;\n&lt;p&gt;Unlike the default fetch plan, which you are using when calling the &lt;code&gt;find&lt;/code&gt; method of the &lt;code&gt;EntityManager&lt;/code&gt;, a JPQL or Criteria API query defines an explicit plan that Hibernate cannot change by injecting a JOIN FETCH automatically. So, you need to do it manually.&lt;/p&gt;\n&lt;p&gt;If you didn&apos;t need the &lt;code&gt;post&lt;/code&gt; association at all, you are out of luck when using &lt;code&gt;FetchType.EAGER&lt;/code&gt; because there is no way to avoid fetching it. That&apos;s why it&apos;s better to use &lt;code&gt;FetchType.LAZY&lt;/code&gt; by default.&lt;/p&gt;\n&lt;p&gt;But, if you wanted to use &lt;code&gt;post&lt;/code&gt; association, then you can use &lt;code&gt;JOIN FETCH&lt;/code&gt; to avoid the N+1 query problem:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;List&amp;lt;PostComment&amp;gt; comments = entityManager.createQuery(&quot;&quot;&quot;\n    select pc\n    from PostComment pc\n    join fetch pc.post p\n    &quot;&quot;&quot;, PostComment.class)\n.getResultList();\n\nfor(PostComment comment : comments) {\n    LOGGER.info(\n        &quot;The Post &apos;{}&apos; got this review &apos;{}&apos;&quot;, \n        comment.getPost().getTitle(), \n        comment.getReview()\n    );\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This time, Hibernate will execute a single SQL statement:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;SELECT \n    pc.id as id1_1_0_, \n    pc.post_id as post_id3_1_0_, \n    pc.review as review2_1_0_, \n    p.id as id1_0_1_, \n    p.title as title2_0_1_ \nFROM \n    post_comment pc \nINNER JOIN \n    post p ON pc.post_id = p.id\n    \n-- The Post &apos;High-Performance Java Persistence - Part 1&apos; got this review \n-- &apos;Excellent book to understand Java Persistence&apos;\n\n-- The Post &apos;High-Performance Java Persistence - Part 2&apos; got this review \n-- &apos;Must-read for Java developers&apos;\n\n-- The Post &apos;High-Performance Java Persistence - Part 3&apos; got this review \n-- &apos;Five Stars&apos;\n\n-- The Post &apos;High-Performance Java Persistence - Part 4&apos; got this review \n-- &apos;A great reference book&apos;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2&gt;&lt;code&gt;FetchType.LAZY&lt;/code&gt;&lt;/h2&gt;\n&lt;p&gt;Even if you switch to using &lt;code&gt;FetchType.LAZY&lt;/code&gt; explicitly for all associations, you can still bump into the N+1 issue.&lt;/p&gt;\n&lt;p&gt;This time, the &lt;code&gt;post&lt;/code&gt; association is mapped like this:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;@ManyToOne(fetch = FetchType.LAZY)\nprivate Post post;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Now, when you fetch the &lt;code&gt;PostComment&lt;/code&gt; entities:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;List&amp;lt;PostComment&amp;gt; comments = entityManager\n.createQuery(&quot;&quot;&quot;\n    select pc\n    from PostComment pc\n    &quot;&quot;&quot;, PostComment.class)\n.getResultList();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Hibernate will execute a single SQL statement:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;SELECT \n    pc.id AS id1_1_, \n    pc.post_id AS post_id3_1_, \n    pc.review AS review2_1_ \nFROM \n    post_comment pc\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;But, if afterward, you are going to reference the lazy-loaded &lt;code&gt;post&lt;/code&gt; association:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;for(PostComment comment : comments) {\n    LOGGER.info(\n        &quot;The Post &apos;{}&apos; got this review &apos;{}&apos;&quot;, \n        comment.getPost().getTitle(), \n        comment.getReview()\n    );\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;You will get the N+1 query issue:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;SELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 1\n-- The Post &apos;High-Performance Java Persistence - Part 1&apos; got this review \n-- &apos;Excellent book to understand Java Persistence&apos;\n\nSELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 2\n-- The Post &apos;High-Performance Java Persistence - Part 2&apos; got this review \n-- &apos;Must-read for Java developers&apos;\n\nSELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 3\n-- The Post &apos;High-Performance Java Persistence - Part 3&apos; got this review \n-- &apos;Five Stars&apos;\n\nSELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 4\n-- The Post &apos;High-Performance Java Persistence - Part 4&apos; got this review \n-- &apos;A great reference book&apos;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Because the &lt;code&gt;post&lt;/code&gt; association is fetched lazily, a secondary SQL statement will be executed when accessing the lazy association in order to build the log message.&lt;/p&gt;\n&lt;p&gt;Again, the fix consists in adding a &lt;code&gt;JOIN FETCH&lt;/code&gt; clause to the JPQL query:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;List&amp;lt;PostComment&amp;gt; comments = entityManager.createQuery(&quot;&quot;&quot;\n    select pc\n    from PostComment pc\n    join fetch pc.post p\n    &quot;&quot;&quot;, PostComment.class)\n.getResultList();\n\nfor(PostComment comment : comments) {\n    LOGGER.info(\n        &quot;The Post &apos;{}&apos; got this review &apos;{}&apos;&quot;, \n        comment.getPost().getTitle(), \n        comment.getReview()\n    );\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;And, just like in the &lt;code&gt;FetchType.EAGER&lt;/code&gt; example, this JPQL query will generate a single SQL statement.&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Even if you are using &lt;code&gt;FetchType.LAZY&lt;/code&gt; and don&apos;t reference the child association of a bidirectional &lt;code&gt;@OneToOne&lt;/code&gt; JPA relationship, you can still trigger the N+1 query issue.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2&gt;How to automatically detect the N+1 query issue&lt;/h2&gt;\n&lt;p&gt;If you want to automatically detect N+1 query issue in your data access layer, you can use the &lt;a href=&quot;https://github.com/vladmihalcea/db-util&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;db-util&lt;/code&gt;&lt;/a&gt; open-source project.&lt;/p&gt;\n&lt;p&gt;First, you need to add the following Maven dependency:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;\n    &amp;lt;groupId&amp;gt;com.vladmihalcea&amp;lt;/groupId&amp;gt;\n    &amp;lt;artifactId&amp;gt;db-util&amp;lt;/artifactId&amp;gt;\n    &amp;lt;version&amp;gt;${db-util.version}&amp;lt;/version&amp;gt;\n&amp;lt;/dependency&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Afterward, you just have to use &lt;code&gt;SQLStatementCountValidator&lt;/code&gt; utility to assert the underlying SQL statements that get generated:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;SQLStatementCountValidator.reset();\n\nList&amp;lt;PostComment&amp;gt; comments = entityManager.createQuery(&quot;&quot;&quot;\n    select pc\n    from PostComment pc\n    &quot;&quot;&quot;, PostComment.class)\n.getResultList();\n\nSQLStatementCountValidator.assertSelectCount(1);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In case you are using &lt;code&gt;FetchType.EAGER&lt;/code&gt; and run the above test case, you will get the following test case failure:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;SELECT \n    pc.id as id1_1_, \n    pc.post_id as post_id3_1_, \n    pc.review as review2_1_ \nFROM \n    post_comment pc\n\nSELECT p.id as id1_0_0_, p.title as title2_0_0_ FROM post p WHERE p.id = 1\n\nSELECT p.id as id1_0_0_, p.title as title2_0_0_ FROM post p WHERE p.id = 2\n\n\n-- SQLStatementCountMismatchException: Expected 1 statement(s) but recorded 3 instead!\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;pre&gt;&lt;code&gt;SELECT \ntable1.*\n, table2.*\nINNER JOIN table2 ON table2.SomeFkId = table1.SomeId\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;That gets you a result set where child rows in table2 cause duplication by returning the table1 results for each child row in table2.  O/R mappers should differentiate table1 instances based on a unique key field, then use all the table2 columns to populate child instances.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;SELECT table1.*\n\nSELECT table2.* WHERE SomeFkId = #\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The N+1 is where the first query populates the primary object and the second query populates all the child objects for each of the unique primary objects returned.&lt;/p&gt;\n\n&lt;p&gt;Consider:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;class House\n{\n    int Id { get; set; }\n    string Address { get; set; }\n    Person[] Inhabitants { get; set; }\n}\n\nclass Person\n{\n    string Name { get; set; }\n    int HouseId { get; set; }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and tables with a similar structure.  A single query for the address &quot;22 Valley St&quot; may return:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;Id Address      Name HouseId\n1  22 Valley St Dave 1\n1  22 Valley St John 1\n1  22 Valley St Mike 1\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The O/RM should fill an instance of Home with ID=1, Address=&quot;22 Valley St&quot; and then populate the Inhabitants array with People instances for Dave, John, and Mike with just one query.&lt;/p&gt;\n\n&lt;p&gt;A N+1 query for the same address used above would result in:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;Id Address\n1  22 Valley St\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;with a separate query like&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;SELECT * FROM Person WHERE HouseId = 1\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and resulting in a separate data set like&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;Name    HouseId\nDave    1\nJohn    1\nMike    1\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and the final result being the same as above with the single query.&lt;/p&gt;\n\n&lt;p&gt;The advantages to single select is that you get all the data up front which may be what you ultimately desire.  The advantages to N+1 is query complexity is reduced and you can use lazy loading where the child result sets are only loaded upon first request.&lt;/p&gt;\n    ","\n&lt;p&gt;Supplier with a one-to-many relationship with Product. One Supplier has (supplies) many Products.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;***** Table: Supplier *****\n+-----+-------------------+\n| ID  |       NAME        |\n+-----+-------------------+\n|  1  |  Supplier Name 1  |\n|  2  |  Supplier Name 2  |\n|  3  |  Supplier Name 3  |\n|  4  |  Supplier Name 4  |\n+-----+-------------------+\n\n***** Table: Product *****\n+-----+-----------+--------------------+-------+------------+\n| ID  |   NAME    |     DESCRIPTION    | PRICE | SUPPLIERID |\n+-----+-----------+--------------------+-------+------------+\n|1    | Product 1 | Name for Product 1 |  2.0  |     1      |\n|2    | Product 2 | Name for Product 2 | 22.0  |     1      |\n|3    | Product 3 | Name for Product 3 | 30.0  |     2      |\n|4    | Product 4 | Name for Product 4 |  7.0  |     3      |\n+-----+-----------+--------------------+-------+------------+\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Factors:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;Lazy mode for Supplier set to true (default)&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Fetch mode used for querying on Product is Select&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Fetch mode (default): Supplier information is accessed&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Caching does not play a role for the first time the&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Supplier is accessed&lt;/p&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Fetch mode is Select Fetch (default)&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;// It takes Select fetch mode as a default\nQuery query = session.createQuery( &quot;from Product p&quot;);\nList list = query.list();\n// Supplier is being accessed\ndisplayProductsListWithSupplierName(results);\n\nselect ... various field names ... from PRODUCT\nselect ... various field names ... from SUPPLIER where SUPPLIER.id=?\nselect ... various field names ... from SUPPLIER where SUPPLIER.id=?\nselect ... various field names ... from SUPPLIER where SUPPLIER.id=?\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Result:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;1 select statement for Product&lt;/li&gt;\n&lt;li&gt;N select statements for Supplier&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;This is N+1 select problem!&lt;/p&gt;\n    ","\n&lt;p&gt;I can&apos;t comment directly on other answers, because I don&apos;t have enough reputation. But it&apos;s worth noting that the problem essentially only arises because, historically, a lot of dbms have been quite poor when it comes to handling joins (MySQL being a particularly noteworthy example). So n+1 has, often, been notably faster than a join. And then there are ways to improve on n+1 but still without needing a join, which is what the original problem relates to.&lt;/p&gt;\n\n&lt;p&gt;However, MySQL is now a lot better than it used to be when it comes to joins. When I first learned MySQL, I used joins a lot. Then I discovered how slow they are, and switched to n+1 in the code instead. But, recently, I&apos;ve been moving back to joins, because MySQL is now a heck of a lot better at handling them than it was when I first started using it.&lt;/p&gt;\n\n&lt;p&gt;These days, a simple join on a properly indexed set of tables is rarely a problem, in performance terms. And if it does give a performance hit, then the use of index hints often solves them.&lt;/p&gt;\n\n&lt;p&gt;This is discussed here by one of the MySQL development team:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://jorgenloland.blogspot.co.uk/2013/02/dbt-3-q3-6-x-performance-in-mysql-5610.html&quot; rel=&quot;noreferrer&quot;&gt;http://jorgenloland.blogspot.co.uk/2013/02/dbt-3-q3-6-x-performance-in-mysql-5610.html&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;So the summary is: If you&apos;ve been avoiding joins in the past because of MySQL&apos;s abysmal performance with them, then try again on the latest versions. You&apos;ll probably be pleasantly surprised.&lt;/p&gt;\n    ","\n&lt;p&gt;We moved away from the ORM in Django because of this problem. Basically, if you try and do&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;for p in person:\n    print p.car.colour\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The ORM will happily return all people (typically as instances of a Person object), but then it will need to query the car table for each Person.&lt;/p&gt;\n\n&lt;p&gt;A simple and very effective approach to this is something I call &quot;&lt;strong&gt;fanfolding&lt;/strong&gt;&quot;, which avoids the nonsensical idea that query results from a relational database should map back to the original tables from which the query is composed.&lt;/p&gt;\n\n&lt;p&gt;Step 1: Wide select&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;  select * from people_car_colour; # this is a view or sql function\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This will return something like&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;  p.id | p.name | p.telno | car.id | car.type | car.colour\n  -----+--------+---------+--------+----------+-----------\n  2    | jones  | 2145    | 77     | ford     | red\n  2    | jones  | 2145    | 1012   | toyota   | blue\n  16   | ashby  | 124     | 99     | bmw      | yellow\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Step 2: Objectify&lt;/p&gt;\n\n&lt;p&gt;Suck the results into a generic object creator with an argument to split after the third item. This means that &quot;jones&quot; object won&apos;t be made more than once.&lt;/p&gt;\n\n&lt;p&gt;Step 3: Render&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;for p in people:\n    print p.car.colour # no more car queries\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;See &lt;a href=&quot;http://campbell-lange.net/company/articles/dbwrapper/&quot; rel=&quot;noreferrer&quot;&gt;this web page&lt;/a&gt; for an implementation of &lt;strong&gt;fanfolding&lt;/strong&gt; for python.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;a href=&quot;https://web.archive.org/web/20160310145416/http://www.realsolve.co.uk/site/tech/hib-tip-pitfall.php?name=why-lazy&quot; rel=&quot;noreferrer&quot;&gt;Here&apos;s a good description of the problem&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Now that you understand the problem it can typically be avoided by doing a join fetch in your query. This basically forces the fetch of the lazy loaded object so the data is retrieved in one query instead of n+1 queries.  Hope this helps.&lt;/p&gt;\n    ","\n&lt;p&gt;Suppose you have COMPANY and EMPLOYEE. COMPANY has many EMPLOYEES (i.e. EMPLOYEE has a field COMPANY_ID).&lt;/p&gt;\n\n&lt;p&gt;In some O/R configurations, when you have a mapped Company object and go to access its Employee objects, the O/R tool will do one select for every employee, wheras if you were just doing things in straight SQL, you could &lt;code&gt;select * from employees where company_id = XX&lt;/code&gt;.  Thus N (# of employees) plus 1 (company)&lt;/p&gt;\n\n&lt;p&gt;This is how the initial versions of EJB Entity Beans worked.  I believe things like Hibernate have done away with this, but I&apos;m not too sure.  Most tools usually include info as to their strategy for mapping.&lt;/p&gt;\n    ","\n&lt;p&gt;Check Ayende post on the topic: &lt;a href=&quot;http://ayende.com/blog/1328/combating-the-select-n-1-problem-in-nhibernate&quot; rel=&quot;nofollow noreferrer&quot;&gt;Combating the Select N + 1 Problem In NHibernate&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;Basically, when using an ORM like NHibernate or EntityFramework, if you have a one-to-many (master-detail) relationship, and want to list all the details per each master record, you have to make N + 1 query calls to the database, &quot;N&quot; being the number of master records: 1 query to get all the master records, and N queries, one per master record, to get all the details per master record.&lt;/p&gt;\n\n&lt;p&gt;More database query calls  more latency time  decreased application/database performance.&lt;/p&gt;\n\n&lt;p&gt;However, ORMs have options to avoid this problem, mainly using JOINs.&lt;/p&gt;\n    ","\n&lt;p&gt;It is much faster to issue 1 query which returns 100 results than to issue 100 queries which each return 1 result.&lt;/p&gt;\n    ","\n&lt;p&gt;In my opinion the article written in &lt;a href=&quot;http://www.realsolve.co.uk/site/tech/hib-tip-pitfall.php?name=why-lazy&quot; rel=&quot;noreferrer&quot;&gt;Hibernate Pitfall: Why Relationships Should Be Lazy&lt;/a&gt; is exactly opposite of real N+1 issue is.&lt;/p&gt;\n\n&lt;p&gt;If you need correct explanation please refer &lt;a href=&quot;http://docs.jboss.org/hibernate/core/3.3/reference/en/html/performance.html#performance-fetching&quot; rel=&quot;noreferrer&quot;&gt;Hibernate - Chapter 19: Improving Performance - Fetching Strategies&lt;/a&gt;&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Select fetching (the default) is\n  extremely vulnerable to N+1 selects\n  problems, so we might want to enable\n  join fetching&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;The supplied link has a very simply example of the n + 1 problem. If you apply it to Hibernate it&apos;s basically talking about the same thing. When you query for an object, the entity is loaded but any associations (unless configured otherwise) will be lazy loaded. Hence one query for the root objects and another query to load the associations for each of these. 100 objects returned means one initial query and then 100 additional queries to get the association for each, n + 1.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://pramatr.com/2009/02/05/sql-n-1-selects-explained/&quot; rel=&quot;noreferrer&quot;&gt;http://pramatr.com/2009/02/05/sql-n-1-selects-explained/&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;N+1 select issue is a pain, and it makes sense to detect such cases in unit tests.\nI have developed a small library for verifying the number of queries executed by a given test method or just an arbitrary block of code - &lt;a href=&quot;https://github.com/bedrin/jdbc-sniffer&quot; rel=&quot;noreferrer&quot;&gt;JDBC Sniffer&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Just add a special JUnit rule to your test class and place annotation with expected number of queries on your test methods:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;@Rule\npublic final QueryCounter queryCounter = new QueryCounter();\n\n@Expectation(atMost = 3)\n@Test\npublic void testInvokingDatabase() {\n    // your JDBC or JPA code\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;N+1 problem in Hibernate &amp;amp; Spring Data JPA&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;N+1 problem is a performance issue in Object Relational Mapping that fires multiple select queries (N+1 to be exact, where N = number of records in table) in database for a single select query at application layer. Hibernate &amp;amp; Spring Data JPA provides multiple ways to catch and address this performance problem.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;What is N+1 Problem?&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;To understand N+1 problem, lets consider with a scenario. Lets say we have a collection of &lt;em&gt;User&lt;/em&gt; objects mapped to &lt;em&gt;DB_USER&lt;/em&gt; table in database, and each user has collection or &lt;em&gt;Role&lt;/em&gt; mapped to &lt;em&gt;DB_ROLE&lt;/em&gt; table using a joining table &lt;em&gt;DB_USER_ROLE&lt;/em&gt;. At the ORM level a &lt;strong&gt;User&lt;/strong&gt; has &lt;strong&gt;many to many&lt;/strong&gt; relationship with &lt;strong&gt;Role&lt;/strong&gt;.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;Entity Model\n@Entity\n@Table(name = &quot;DB_USER&quot;)\npublic class User {\n\n    @Id\n    @GeneratedValue(strategy=GenerationType.AUTO)\n    private Long id;\n    private String name;\n\n    @ManyToMany(fetch = FetchType.LAZY)                   \n    private Set&amp;lt;Role&amp;gt; roles;\n    //Getter and Setters \n }\n\n@Entity\n@Table(name = &quot;DB_ROLE&quot;)\npublic class Role {\n\n    @Id\n    @GeneratedValue(strategy= GenerationType.AUTO)\n    private Long id;\n\n    private String name;\n    //Getter and Setters\n }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;A user can have many roles. Roles are loaded Lazily.&lt;/strong&gt; Now lets say we want to &lt;em&gt;fetch all users from this table and print roles for each one&lt;/em&gt;. Very naive Object Relational implementation could be -\n&lt;strong&gt;UserRepository&lt;/strong&gt; with &lt;strong&gt;findAllBy&lt;/strong&gt; method&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;public interface UserRepository extends CrudRepository&amp;lt;User, Long&amp;gt; {\n\n    List&amp;lt;User&amp;gt; findAllBy();\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;The equivalent SQL queries executed by ORM will be:&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;First Get &lt;strong&gt;All User&lt;/strong&gt; (1)&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;Select * from DB_USER;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Then get &lt;strong&gt;roles for each user&lt;/strong&gt; executed N times (where N is number of users)&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;Select * from DB_USER_ROLE where userid = &amp;lt;userid&amp;gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;So we need &lt;strong&gt;one select for User&lt;/strong&gt; and &lt;strong&gt;N additional selects for fetching roles for each user&lt;/strong&gt;, where &lt;em&gt;N is total number of users&lt;/em&gt;. &lt;em&gt;&lt;strong&gt;This is a classic N+1 problem in ORM&lt;/strong&gt;&lt;/em&gt;.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;How to identify it?&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;Hibernate provide tracing option that enables SQL logging in the console/logs. &lt;em&gt;&lt;strong&gt;using logs you can easily see if hibernate is issuing N+1 queries for a given call&lt;/strong&gt;&lt;/em&gt;.&lt;/p&gt;\n&lt;p&gt;If you see multiple entries for SQL for a given select query, then there are high chances that its due to N+1 problem.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;N+1 Resolution&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;At SQL level&lt;/strong&gt;, what ORM needs to achieve to avoid N+1 is to &lt;em&gt;fire a query that joins the two tables and get the combined results in single query&lt;/em&gt;.&lt;/p&gt;\n&lt;p&gt;&lt;em&gt;&lt;strong&gt;Fetch Join SQL that retrieves everything (user and roles) in Single Query&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;OR Plain SQL&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;select user0_.id, role2_.id, user0_.name, role2_.name, roles1_.user_id, roles1_.roles_id from db_user user0_ left outer join db_user_roles roles1_ on user0_.id=roles1_.user_id left outer join db_role role2_ on roles1_.roles_id=role2_.id\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;Hibernate &amp;amp; Spring Data JPA provide mechanism to solve the N+1 ORM issue.&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;1. Spring Data JPA Approach:&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;If we are using Spring Data JPA, then we have two options to achieve this - using &lt;em&gt;&lt;strong&gt;EntityGraph&lt;/strong&gt;&lt;/em&gt; or using &lt;em&gt;&lt;strong&gt;select query with fetch join.&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;public interface UserRepository extends CrudRepository&amp;lt;User, Long&amp;gt; {\n\n    List&amp;lt;User&amp;gt; findAllBy();             \n\n    @Query(&quot;SELECT p FROM User p LEFT JOIN FETCH p.roles&quot;)  \n    List&amp;lt;User&amp;gt; findWithoutNPlusOne();\n\n    @EntityGraph(attributePaths = {&quot;roles&quot;})                \n    List&amp;lt;User&amp;gt; findAll();\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;N+1 queries are issued at database level using left join fetch, we resolve the N+1 problem using attributePaths, Spring Data JPA avoids N+1 problem&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;2. Hibernate Approach:&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;If its pure Hibernate, then the following solutions will work.&lt;/p&gt;\n&lt;p&gt;Using &lt;strong&gt;HQL&lt;/strong&gt; :&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;from User u *join fetch* u.roles roles roles\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Using &lt;strong&gt;Criteria&lt;/strong&gt; API:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;Criteria criteria = session.createCriteria(User.class);\ncriteria.setFetchMode(&quot;roles&quot;, FetchMode.EAGER);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;All these approaches work similar and they issue a similar database query with left join fetch&lt;/p&gt;\n    ","\n&lt;p&gt;The issue as others have stated more elegantly is that you either have a Cartesian product of the OneToMany columns or you&apos;re doing N+1 Selects. Either possible gigantic resultset or chatty with the database, respectively.&lt;/p&gt;\n\n&lt;p&gt;I&apos;m surprised this isn&apos;t mentioned but this how I have gotten around this issue... &lt;strong&gt;I make a semi-temporary ids table&lt;/strong&gt;. &lt;a href=&quot;https://stackoverflow.com/a/11119642/318174&quot;&gt;I also do this when you have the &lt;code&gt;IN ()&lt;/code&gt; clause limitation&lt;/a&gt;. &lt;/p&gt;\n\n&lt;p&gt;This doesn&apos;t work for all cases (probably not even a majority) but it works particularly well if you have a lot of child objects such that the Cartesian product will get out of hand (ie lots of &lt;code&gt;OneToMany&lt;/code&gt; columns the number of results will be a multiplication of the columns) and its more of a batch like job.&lt;/p&gt;\n\n&lt;p&gt;First you insert your parent object ids as batch into an ids table.\nThis batch_id is something we generate in our app and hold onto.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;INSERT INTO temp_ids \n    (product_id, batch_id)\n    (SELECT p.product_id, ? \n    FROM product p ORDER BY p.product_id\n    LIMIT ? OFFSET ?);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Now for each &lt;code&gt;OneToMany&lt;/code&gt; column you just do a &lt;code&gt;SELECT&lt;/code&gt; on the ids table &lt;code&gt;INNER JOIN&lt;/code&gt;ing  the child table with a &lt;code&gt;WHERE batch_id=&lt;/code&gt; (or vice versa). You just want to make sure you order by the id column as it will make merging result columns easier (otherwise you will need a HashMap/Table for the entire result set which may not be that bad).&lt;/p&gt;\n\n&lt;p&gt;Then you just periodically clean the ids table.&lt;/p&gt;\n\n&lt;p&gt;This also works particularly well if the user selects say 100 or so distinct items for some sort of bulk processing. Put the 100 distinct ids in the temporary table.&lt;/p&gt;\n\n&lt;p&gt;Now the number of queries you are doing is by the number of OneToMany columns.&lt;/p&gt;\n    ","\n&lt;p&gt;Without going into tech stack implementation details, architecturally speaking there are at least two solutions to N + 1 Problem:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Have Only 1 - big query - with Joins. This makes a lot of information be transported from the database to the application layer, especially if there are multiple child records. The typical result of a database is a set of rows, not graph of objects (there are solutions to that with different DB systems)&lt;/li&gt;\n&lt;li&gt;Have Two(or more for more children needed to be joined) Queries - 1 for the parent and after you have them - query by IDs the children and map them. This will minimize data transfer between the DB and APP layers.&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;Take Matt Solnit example, imagine that you define an association between Car and Wheels as LAZY and you need some Wheels fields. This means that after the first select, hibernate is going to do  &quot;Select * from Wheels where car_id = :id&quot; FOR EACH Car.&lt;/p&gt;\n\n&lt;p&gt;This makes the first select and more 1 select by each N car, that&apos;s why it&apos;s called n+1 problem.&lt;/p&gt;\n\n&lt;p&gt;To avoid this, make the association fetch as eager, so that hibernate loads data with a join.&lt;/p&gt;\n\n&lt;p&gt;But attention, if many times you don&apos;t access associated Wheels, it&apos;s better to keep it LAZY or change fetch type with Criteria.&lt;/p&gt;\n    ","\n&lt;h3&gt;A generalisation of N+1&lt;/h3&gt;\n&lt;p&gt;The N+1 problem is an ORM specific name of a problem where you move loops that could be reasonably executed on a server to the client. The generic problem isn&apos;t specific to ORMs, you can have it with any remote API. &lt;a href=&quot;https://blog.jooq.org/the-cost-of-jdbc-server-roundtrips/&quot; rel=&quot;nofollow noreferrer&quot;&gt;In this article, I&apos;ve shown how JDBC roundtrips are very costly&lt;/a&gt;, if you&apos;re calling an API N times instead of only 1 time. The difference in the example is whether you&apos;re calling the Oracle PL/SQL procedure:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;dbms_output.get_lines&lt;/code&gt; (call it once, receive N items)&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;dbms_output.get_line&lt;/code&gt; (call it N times, receive 1 item each time)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;They&apos;re logically equivalent, but due to the latency between server and client, you&apos;re adding N latency waits to your loop, instead of waiting only once.&lt;/p&gt;\n&lt;h3&gt;The ORM case&lt;/h3&gt;\n&lt;p&gt;In fact, the ORM-y N+1 problem isn&apos;t even ORM specific either, you can achieve it by running your own queries manually as well, e.g. when you do something like this in PL/SQL:&lt;/p&gt;\n&lt;pre class=&quot;lang-sql s-code-block&quot;&gt;&lt;code class=&quot;hljs language-sql&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;-- This loop is executed once&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; parent &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; parent) loop\n\n  &lt;span class=&quot;hljs-comment&quot;&gt;-- This loop is executed N times&lt;/span&gt;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; child &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; child &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; parent_id &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; parent.id) loop\n    ...\n  &lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt; loop;\n&lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt; loop;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;It would be much better to implement this using a join (in this case):&lt;/p&gt;\n&lt;pre class=&quot;lang-sql s-code-block&quot;&gt;&lt;code class=&quot;hljs language-sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; rec &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; (\n  &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;*&lt;/span&gt;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; parent p\n  &lt;span class=&quot;hljs-keyword&quot;&gt;join&lt;/span&gt; child c &lt;span class=&quot;hljs-keyword&quot;&gt;on&lt;/span&gt; c.parent_id &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; p.id\n)\nloop\n  ...\n&lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt; loop;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Now, the loop is executed only once, and the logic of the loop has been moved from the client (PL/SQL) to the server (SQL), which can even optimise it differently, e.g. by running a hash join (&lt;code&gt;O(N)&lt;/code&gt;) rather than a nested loop join (&lt;code&gt;O(N log N)&lt;/code&gt; with index)&lt;/p&gt;\n&lt;h3&gt;Auto-detecting N+1 problems&lt;/h3&gt;\n&lt;p&gt;If you&apos;re using JDBC, &lt;a href=&quot;https://blog.jooq.org/using-jooqs-diagnosticsconnection-to-detect-n1-queries/&quot; rel=&quot;nofollow noreferrer&quot;&gt;you could use jOOQ as a JDBC proxy behind the scenes to auto-detect your N+1 problems&lt;/a&gt;. jOOQ&apos;s parser normalises your SQL queries and caches data about consecutive executions of parent and child queries. This even works if your queries aren&apos;t exactly the same, but semantically equivalent.&lt;/p&gt;\n    ","\n&lt;p&gt;N+1 SELECT problem is really hard to spot, especially in projects with large domain, to the moment when it starts degrading the performance. Even if the problem is fixed i.e. by adding eager loading, a further development may break the solution and/or introduce N+1 SELECT problem again in other places.&lt;/p&gt;\n&lt;p&gt;I&apos;ve created open source library &lt;a href=&quot;https://github.com/adgadev/jplusone&quot; rel=&quot;nofollow noreferrer&quot;&gt;jplusone&lt;/a&gt; to address those problems in JPA based Spring Boot Java applications. The library provides two major features:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Generates reports correlating SQL statements with executions of JPA operations which triggered them and places in source code of your application which were involved in it&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;2020-10-22 18:41:43.236 DEBUG 14913 --- [           main] c.a.j.core.report.ReportGenerator        :\n    ROOT\n        com.adgadev.jplusone.test.domain.bookshop.BookshopControllerTest.shouldGetBookDetailsLazily(BookshopControllerTest.java:65)\n        com.adgadev.jplusone.test.domain.bookshop.BookshopController.getSampleBookUsingLazyLoading(BookshopController.java:31)\n        com.adgadev.jplusone.test.domain.bookshop.BookshopService.getSampleBookDetailsUsingLazyLoading [PROXY]\n            SESSION BOUNDARY\n                OPERATION [IMPLICIT]\n                    com.adgadev.jplusone.test.domain.bookshop.BookshopService.getSampleBookDetailsUsingLazyLoading(BookshopService.java:35)\n                    com.adgadev.jplusone.test.domain.bookshop.Author.getName [PROXY]\n                    com.adgadev.jplusone.test.domain.bookshop.Author [FETCHING ENTITY]\n                        STATEMENT [READ]\n                            select [...] from\n                                author author0_\n                                left outer join genre genre1_ on author0_.genre_id=genre1_.id\n                            where\n                                author0_.id=1\n                OPERATION [IMPLICIT]\n                    com.adgadev.jplusone.test.domain.bookshop.BookshopService.getSampleBookDetailsUsingLazyLoading(BookshopService.java:36)\n                    com.adgadev.jplusone.test.domain.bookshop.Author.countWrittenBooks(Author.java:53)\n                    com.adgadev.jplusone.test.domain.bookshop.Author.books [FETCHING COLLECTION]\n                        STATEMENT [READ]\n                            select [...] from\n                                book books0_\n                            where\n                                books0_.author_id=1\n&lt;/pre&gt;\n&lt;ol start=&quot;2&quot;&gt;\n&lt;li&gt;Provides API which allows to write tests checking how effectively your application is using JPA (i.e. assert amount of lazy loading operations )&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@SpringBootTest&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;LazyLoadingTest&lt;/span&gt; {\n\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Autowired&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; JPlusOneAssertionContext assertionContext;\n\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Autowired&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; SampleService sampleService;\n\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Test&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;shouldBusinessCheckOperationAgainstJPlusOneAssertionRule&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n        &lt;span class=&quot;hljs-type&quot;&gt;JPlusOneAssertionRule&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;rule&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; JPlusOneAssertionRule\n                .within().lastSession()\n                .shouldBe().noImplicitOperations().exceptAnyOf(exclusions -&amp;gt; exclusions\n                        .loadingEntity(Author.class).times(atMost(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;))\n                        .loadingCollection(Author.class, &lt;span class=&quot;hljs-string&quot;&gt;&quot;books&quot;&lt;/span&gt;)\n                );\n\n        &lt;span class=&quot;hljs-comment&quot;&gt;// trigger business operation which you wish to be asserted against the rule,&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;// i.e. calling a service or sending request to your API controller&lt;/span&gt;\n        sampleService.executeBusinessOperation();\n\n        rule.check(assertionContext);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n    "]},"randomTags":[{"name":"instantiation","slug":"instantiation"},{"name":"ssl-certificate","slug":"ssl-certificate"},{"name":"iostream","slug":"iostream"},{"name":"istream","slug":"istream"},{"name":"grouping","slug":"grouping"},{"name":"events","slug":"events"},{"name":"tsql","slug":"tsql"},{"name":"jsf","slug":"jsf"},{"name":"fetch-api","slug":"fetch-api"},{"name":"rest","slug":"rest"},{"name":"non-greedy","slug":"non-greedy"},{"name":"eval","slug":"eval"},{"name":"access-modifiers","slug":"access-modifiers"},{"name":"hierarchical-data","slug":"hierarchical-data"},{"name":"turbo-c++","slug":"turbo-c++"},{"name":"angular","slug":"angular"},{"name":"forward-declaration","slug":"forward-declaration"},{"name":"http-get","slug":"http-get"},{"name":"scanf","slug":"scanf"},{"name":"restriction","slug":"restriction"}]},"__N_SSG":true}