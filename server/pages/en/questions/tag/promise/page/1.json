{"pageProps":{"data":{"count":1,"rows":[{"id":57,"title":"What is the explicit promise construction antipattern and how do I avoid it?","slug":"what-is-the-explicit-promise-construction-antipattern-and-how-do-i-avoid-it-1657384436212","postType":"QUESTION","createdAt":"2022-07-09T16:33:56.000Z","updatedAt":"2022-07-09T16:33:56.000Z","tags":[{"id":204,"name":"promise","slug":"promise","createdAt":"2022-07-09T16:33:56.000Z","updatedAt":"2022-07-09T16:33:56.000Z","Questions_Tags":{"questionId":57,"tagId":204}}]}]},"slug":"promise","page":"1","answers":{"57":["\n&lt;p&gt;The &lt;a href=&quot;https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern&quot; rel=&quot;noreferrer&quot;&gt;deferred antipattern (now explicit-construction anti-pattern)&lt;/a&gt; coined by &lt;a href=&quot;https://stackoverflow.com/users/995876/esailija&quot;&gt;Esailija&lt;/a&gt; is a common anti-pattern people who are new to promises make, I&apos;ve made it myself when I first used promises. The problem with the above code is that is fails to utilize the fact that promises chain.&lt;/p&gt;\n\n&lt;p&gt;Promises can chain with &lt;code&gt;.then&lt;/code&gt; and you can return promises directly. Your code in &lt;code&gt;getStuffDone&lt;/code&gt; can be rewritten as:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;getStuffDone&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;param&lt;/span&gt;){\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;myPromiseFn&lt;/span&gt;(param+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;// much nicer, right?&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Promises are all about making asynchronous code more readable and behave like synchronous code without hiding that fact. Promises represent an abstraction over a value of one time operation, they abstract the notion of a statement or expression in a programming language.&lt;/p&gt;\n\n&lt;p&gt;You should only use deferred objects when you are &lt;a href=&quot;https://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises&quot;&gt;converting an API to promises&lt;/a&gt; and can&apos;t do it automatically, or when you&apos;re writing aggregation functions that are easier expressed this way. &lt;/p&gt;\n\n&lt;p&gt;Quoting Esailija:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;This is the most common anti-pattern. It is easy to fall into this when you don&apos;t really understand promises and think of them as glorified event emitters or callback utility. Let&apos;s recap: promises are about making asynchronous code retain most of the lost properties of synchronous code such as flat indentation and one exception channel.&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;h1&gt;What&apos;s wrong with it?&lt;/h1&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;But the pattern works!&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Lucky you. Unfortunately, it probably doesn&apos;t, as you likely forgot some edge case. In more than half of the occurrences I&apos;ve seen, the author has forgotten to take care of the error handler:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;resolve&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-title function_&quot;&gt;getOtherPromise&lt;/span&gt;().&lt;span class=&quot;hljs-title function_&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;result&lt;/span&gt;) {\n        &lt;span class=&quot;hljs-title function_&quot;&gt;resolve&lt;/span&gt;(result.&lt;span class=&quot;hljs-property&quot;&gt;property&lt;/span&gt;.&lt;span class=&quot;hljs-property&quot;&gt;example&lt;/span&gt;);\n    });\n})\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;If the other promise is rejected, this will happen unnoticed instead of being propagated to the new promise (where it would get handled) - and the new promise stays forever pending, which can induce leaks.&lt;/p&gt;\n\n&lt;p&gt;The same thing happens in the case that your callback code causes an error - e.g. when &lt;code&gt;result&lt;/code&gt; doesn&apos;t have a &lt;code&gt;property&lt;/code&gt; and an exception is thrown. That would go unhandled and leave the new promise unresolved. &lt;/p&gt;\n\n&lt;p&gt;In contrast, using &lt;code&gt;.then()&lt;/code&gt; does automatically take care of both these scenarios, and rejects the new promise when an error happens:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;getOtherPromise&lt;/span&gt;().&lt;span class=&quot;hljs-title function_&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;result&lt;/span&gt;) {\n     &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; result.&lt;span class=&quot;hljs-property&quot;&gt;property&lt;/span&gt;.&lt;span class=&quot;hljs-property&quot;&gt;example&lt;/span&gt;;\n })\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The deferred antipattern is not only cumbersome, but also &lt;strong&gt;error-prone&lt;/strong&gt;. Using &lt;code&gt;.then()&lt;/code&gt; for chaining is much safer.&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;But I&apos;ve handled everything!&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Really? Good. However, this will be pretty detailed and copious, especially if you use a promise library that supports other features like cancellation or message passing. Or maybe it will in the future, or you want to swap your library against a better one? You won&apos;t want to rewrite your code for that.&lt;/p&gt;\n\n&lt;p&gt;The libraries&apos; methods (&lt;code&gt;then&lt;/code&gt;) do not only natively support all the features, they also might have certain optimisations in place. Using them will likely make your code faster, or at least allow to be optimised by future revisions of the library.&lt;/p&gt;\n\n&lt;h1&gt;How do I avoid it?&lt;/h1&gt;\n\n&lt;p&gt;So whenever you find yourself manually creating a &lt;code&gt;Promise&lt;/code&gt; or &lt;code&gt;Deferred&lt;/code&gt; and already existing promises are involved, &lt;strong&gt;check the library API first&lt;/strong&gt;. The Deferred antipattern is often applied by people who see promises [only] as an observer pattern - but &lt;a href=&quot;https://stackoverflow.com/a/22562045/1048572&quot;&gt;promises are &lt;em&gt;more&lt;/em&gt; than callbacks&lt;/a&gt;: they are supposed to be composable. Every decent library has lots of easy-to-use functions for the composition of promises in every thinkable manner, taking care of all the low-level stuff you don&apos;t want to deal with.&lt;/p&gt;\n\n&lt;p&gt;If you have found a need to compose some promises in a new way that is not supported by an existing helper function, writing your own function with unavoidable Deferreds should be your last option. Consider switching to a more featureful library, and/or file a bug against your current library. Its maintainer should be able to derive the composition from existing functions, implement a new helper function for you and/or help to identify the edge cases that need to be handled.&lt;/p&gt;\n    ","\n&lt;p&gt;Now 7 years later there is a simpler answer to this question:&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;How do I avoid the explicit constructor antipattern?&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;Use &lt;code&gt;async function&lt;/code&gt;s, then &lt;code&gt;await&lt;/code&gt; every Promise!&lt;/p&gt;\n&lt;p&gt;Instead of manually constructing nested Promise chains such as this one:&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;promised&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;resolve&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-title function_&quot;&gt;getOtherPromise&lt;/span&gt;().&lt;span class=&quot;hljs-title function_&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;result&lt;/span&gt;) {\n      &lt;span class=&quot;hljs-title function_&quot;&gt;getAnotherPromise&lt;/span&gt;(result).&lt;span class=&quot;hljs-title function_&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;result2&lt;/span&gt;) {\n        &lt;span class=&quot;hljs-title function_&quot;&gt;resolve&lt;/span&gt;(result2);\n      });\n    });\n  });\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;just turn your function &lt;code&gt;async&lt;/code&gt; and use the &lt;code&gt;await&lt;/code&gt; keyword to &lt;em&gt;stop execution of the function&lt;/em&gt; until the Promise resolves:&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;promised&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {\n   &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; result =  &lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;getOtherPromise&lt;/span&gt;();\n   &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; result2 = &lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;getAnotherPromise&lt;/span&gt;(result);\n   &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; result2;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This has various benefits:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Calling the &lt;code&gt;async&lt;/code&gt; function always returns a Promise, which resolves with the returned value and rejects if an error get&apos;s thrown inside the async function&lt;/li&gt;\n&lt;li&gt;If an &lt;code&gt;await&lt;/code&gt;ed Promise rejects, the error get&apos;s thrown inside the async function, so you can just &lt;code&gt;try { ... } catch(error) { ... }&lt;/code&gt; it like the synchronous errors.&lt;/li&gt;\n&lt;li&gt;You can &lt;code&gt;await&lt;/code&gt; inside loops and if branches, making most of the Promise chain logic trivial&lt;/li&gt;\n&lt;li&gt;Although async functions behave mostly like chains of Promises, they are way easier to read (and easier to reason about)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;How can I &lt;code&gt;await&lt;/code&gt; a callback?&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;If the callback only calls back once, and the API you are calling does not provide a Promise already (most of them do!) this is the &lt;em&gt;only reason&lt;/em&gt; to use a Promise constructor:&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt; &lt;span class=&quot;hljs-comment&quot;&gt;// Create a wrapper around the &quot;old&quot; function taking a callback, passing the &apos;resolve&apos; function as callback&lt;/span&gt;\n &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;delay&lt;/span&gt; = time =&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt;\n   &lt;span class=&quot;hljs-built_in&quot;&gt;setTimeout&lt;/span&gt;(resolve, time)\n ); \n\n &lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;delay&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;If &lt;code&gt;await&lt;/code&gt; stops execution, does calling an &lt;code&gt;async function&lt;/code&gt; return the result directly?&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;No. If you call an async function, a Promise gets always returned. You can then &lt;code&gt;await&lt;/code&gt; that Promise too inside an async function. You cannot wait for the result inside of a synchronous function (you would have to call &lt;code&gt;.then&lt;/code&gt; and attach a callback).&lt;/p&gt;\n&lt;p&gt;Conceptually, synchronous &lt;code&gt;function&lt;/code&gt;s always run to completion in one job, while &lt;code&gt;async function&lt;/code&gt;s run synchronously till they reach an &lt;code&gt;await&lt;/code&gt;, then they continue in another job.&lt;/p&gt;\n    "]},"randomTags":[{"name":"subprocess","slug":"subprocess"},{"name":"prototypal-inheritance","slug":"prototypal-inheritance"},{"name":"pass-by-value","slug":"pass-by-value"},{"name":"callback","slug":"callback"},{"name":"soft-keyboard","slug":"soft-keyboard"},{"name":"preg-replace","slug":"preg-replace"},{"name":"algorithm","slug":"algorithm"},{"name":"awt","slug":"awt"},{"name":"css-transitions","slug":"css-transitions"},{"name":"urlconnection","slug":"urlconnection"},{"name":"regex","slug":"regex"},{"name":"google-chrome-extension","slug":"google-chrome-extension"},{"name":"addeventlistener","slug":"addeventlistener"},{"name":"pandas-explode","slug":"pandas-explode"},{"name":"bash","slug":"bash"},{"name":"array-difference","slug":"array-difference"},{"name":"system.in","slug":"system.in"},{"name":"exception","slug":"exception"},{"name":"reference","slug":"reference"},{"name":"raw-types","slug":"raw-types"}]},"__N_SSG":true}