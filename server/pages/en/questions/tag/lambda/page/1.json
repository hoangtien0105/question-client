{"pageProps":{"data":{"count":1,"rows":[{"id":445,"title":"What is a lambda expression in C++11?","slug":"what-is-a-lambda-expression-in-c++11-1657387999252","postType":"QUESTION","createdAt":"2022-07-09T17:33:19.000Z","updatedAt":"2022-07-09T17:33:19.000Z","tags":[{"id":2306,"name":"lambda","slug":"lambda","createdAt":"2022-07-09T17:33:19.000Z","updatedAt":"2022-07-09T17:33:19.000Z","Questions_Tags":{"questionId":445,"tagId":2306}}]}]},"slug":"lambda","page":"1","answers":{"445":["\n&lt;h1&gt;The problem&lt;/h1&gt;\n&lt;p&gt;C++ includes useful generic functions like &lt;code&gt;std::for_each&lt;/code&gt; and &lt;code&gt;std::transform&lt;/code&gt;, which can be very handy. Unfortunately they can also be quite cumbersome to use, particularly if the &lt;a href=&quot;https://stackoverflow.com/questions/356950/c-functors-and-their-uses&quot;&gt;functor&lt;/a&gt; you would like to apply is unique to the particular function.&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;f&lt;/span&gt; {\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{\n      &lt;span class=&quot;hljs-comment&quot;&gt;// do something&lt;/span&gt;\n    }\n  };\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(std::vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; v)&lt;/span&gt; &lt;/span&gt;{\n  f f;\n  std::for_each(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(), f);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;If you only use &lt;code&gt;f&lt;/code&gt; once and in that specific place it seems overkill to be writing a whole class just to do something trivial and one off.&lt;/p&gt;\n&lt;p&gt;In C++03 you might be tempted to write something like the following, to keep the functor local:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;func2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(std::vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; v)&lt;/span&gt; &lt;/span&gt;{\n  &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{\n       &lt;span class=&quot;hljs-comment&quot;&gt;// do something&lt;/span&gt;\n    }\n  } f;\n  std::for_each(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(), f);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;however this is not allowed, &lt;code&gt;f&lt;/code&gt; cannot be passed to a &lt;a href=&quot;https://en.cppreference.com/w/cpp/language/function_template&quot; rel=&quot;noreferrer&quot;&gt;template&lt;/a&gt; function in C++03.&lt;/p&gt;\n&lt;h1&gt;The new solution&lt;/h1&gt;\n&lt;p&gt;C++11 introduces lambdas allow you to write an inline, anonymous functor to replace the &lt;code&gt;struct f&lt;/code&gt;. For small simple examples this can be cleaner to read (it keeps everything in one place) and potentially simpler to maintain, for example in the simplest form:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;func3&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(std::vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; v)&lt;/span&gt; &lt;/span&gt;{\n  std::for_each(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(), [](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;) { &lt;span class=&quot;hljs-comment&quot;&gt;/* do something here*/&lt;/span&gt; });\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Lambda functions are just syntactic sugar for anonymous functors.&lt;/p&gt;\n&lt;h2&gt;Return types&lt;/h2&gt;\n&lt;p&gt;In simple cases the return type of the lambda is deduced for you, e.g.:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;func4&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(std::vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt;&amp;gt;&amp;amp; v)&lt;/span&gt; &lt;/span&gt;{\n  std::&lt;span class=&quot;hljs-built_in&quot;&gt;transform&lt;/span&gt;(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(),\n                 [](&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; d) { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; d &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;0.00001&lt;/span&gt; ? &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; : d; }\n                 );\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;however when you start to write more complex lambdas you will quickly encounter cases where the return type cannot be deduced by the compiler, e.g.:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;func4&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(std::vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt;&amp;gt;&amp;amp; v)&lt;/span&gt; &lt;/span&gt;{\n    std::&lt;span class=&quot;hljs-built_in&quot;&gt;transform&lt;/span&gt;(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(),\n        [](&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; d) {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (d &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;0.0001&lt;/span&gt;) {\n                &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n            } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {\n                &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; d;\n            }\n        });\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;To resolve this you are allowed to explicitly specify a return type for a lambda function, using &lt;code&gt;-&amp;gt; T&lt;/code&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;func4&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(std::vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt;&amp;gt;&amp;amp; v)&lt;/span&gt; &lt;/span&gt;{\n    std::&lt;span class=&quot;hljs-built_in&quot;&gt;transform&lt;/span&gt;(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(),\n        [](&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; d) -&amp;gt; &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (d &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;0.0001&lt;/span&gt;) {\n                &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n            } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {\n                &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; d;\n            }\n        });\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2&gt;&quot;Capturing&quot; variables&lt;/h2&gt;\n&lt;p&gt;So far we&apos;ve not used anything other than what was passed to the lambda within it, but we can also use other variables, within the lambda. If you want to access other variables you can use the capture clause (the &lt;code&gt;[]&lt;/code&gt; of the expression), which has so far been unused in these examples, e.g.:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;func5&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(std::vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt;&amp;gt;&amp;amp; v, &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt;&amp;amp; epsilon)&lt;/span&gt; &lt;/span&gt;{\n    std::&lt;span class=&quot;hljs-built_in&quot;&gt;transform&lt;/span&gt;(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(),\n        [epsilon](&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; d) -&amp;gt; &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (d &amp;lt; epsilon) {\n                &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n            } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {\n                &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; d;\n            }\n        });\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;You can capture by both reference and value, which you can specify using &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;=&lt;/code&gt; respectively:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;[&amp;amp;epsilon, zeta]&lt;/code&gt; captures epsilon by reference and zeta by value&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;[&amp;amp;]&lt;/code&gt; captures all variables used in the lambda by reference&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;[=]&lt;/code&gt; captures all variables used in the lambda by value&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;[&amp;amp;, epsilon]&lt;/code&gt; captures all variables used in the lambda by reference but captures epsilon by value&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;[=, &amp;amp;epsilon]&lt;/code&gt; captures all variables used in the lambda by value but captures epsilon by reference&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;The generated &lt;code&gt;operator()&lt;/code&gt; is &lt;code&gt;const&lt;/code&gt; by default, with the implication that captures will be &lt;code&gt;const&lt;/code&gt; when you access them by default. This has the effect that each call with the same input would produce the same result, however you can &lt;a href=&quot;https://stackoverflow.com/questions/5501959/why-does-c0xs-lambda-require-mutable-keyword-for-capture-by-value-by-defaul&quot;&gt;mark the lambda as &lt;code&gt;mutable&lt;/code&gt;&lt;/a&gt; to request that the &lt;code&gt;operator()&lt;/code&gt; that is produced is not &lt;code&gt;const&lt;/code&gt;.&lt;/p&gt;\n\n    ","\n&lt;h1&gt;What is a lambda function?&lt;/h1&gt;\n\n&lt;p&gt;The C++ concept of a lambda function originates in the lambda calculus and functional programming. A lambda is an unnamed function that is useful (in actual programming, not theory) for short snippets of code that are impossible to reuse and are not worth naming.&lt;/p&gt;\n\n&lt;p&gt;In C++ a lambda function is defined like this&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;[]() { } &lt;span class=&quot;hljs-comment&quot;&gt;// barebone lambda&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or in all its glory&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;[]() &lt;span class=&quot;hljs-keyword&quot;&gt;mutable&lt;/span&gt; -&amp;gt; T { } &lt;span class=&quot;hljs-comment&quot;&gt;// T is the return type, still lacking throw()&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;[]&lt;/code&gt; is the capture list, &lt;code&gt;()&lt;/code&gt; the argument list and &lt;code&gt;{}&lt;/code&gt; the function body.&lt;/p&gt;\n\n&lt;h2&gt;The capture list&lt;/h2&gt;\n\n&lt;p&gt;The capture list defines what from the outside of the lambda should be available inside the function body and how.\nIt can be either:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;a value: [x]&lt;/li&gt;\n&lt;li&gt;a reference [&amp;amp;x]&lt;/li&gt;\n&lt;li&gt;any variable currently in scope by reference [&amp;amp;]&lt;/li&gt;\n&lt;li&gt;same as 3, but by value [=]&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;You can mix any of the above in a comma separated list &lt;code&gt;[x, &amp;amp;y]&lt;/code&gt;.&lt;/p&gt;\n\n&lt;h2&gt;The argument list&lt;/h2&gt;\n\n&lt;p&gt;The argument list is the same as in any other C++ function. &lt;/p&gt;\n\n&lt;h2&gt;The function body&lt;/h2&gt;\n\n&lt;p&gt;The code that will be executed when the lambda is actually called.&lt;/p&gt;\n\n&lt;h2&gt;Return type deduction&lt;/h2&gt;\n\n&lt;p&gt;If a lambda has only one return statement, the return type can be omitted and has the implicit type of &lt;code&gt;decltype(return_statement)&lt;/code&gt;.&lt;/p&gt;\n\n&lt;h2&gt;Mutable&lt;/h2&gt;\n\n&lt;p&gt;If a lambda is marked mutable (e.g. &lt;code&gt;[]() mutable { }&lt;/code&gt;) it is allowed to mutate the values that have been captured by value.&lt;/p&gt;\n\n&lt;h1&gt;Use cases&lt;/h1&gt;\n\n&lt;p&gt;The library defined by the ISO standard benefits heavily from lambdas and raises the usability several bars as now users don&apos;t have to clutter their code with small functors in some accessible scope.&lt;/p&gt;\n\n&lt;h1&gt;C++14&lt;/h1&gt;\n\n&lt;p&gt;In C++14 lambdas have been extended by various proposals.&lt;/p&gt;\n\n&lt;h2&gt;Initialized Lambda Captures&lt;/h2&gt;\n\n&lt;p&gt;An element of the capture list can now be initialized with &lt;code&gt;=&lt;/code&gt;. This allows renaming of variables and to capture by moving. An example taken from the standard:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; y = [&amp;amp;r = x, x = x+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]()-&amp;gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; {\n            r += &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; x+&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;\n         }();  &lt;span class=&quot;hljs-comment&quot;&gt;// Updates ::x to 6, and initializes y to 7.&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and one taken from Wikipedia showing how to capture with &lt;code&gt;std::move&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; ptr = std::&lt;span class=&quot;hljs-built_in&quot;&gt;make_unique&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;// See below for std::make_unique&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; lambda = [ptr = std::&lt;span class=&quot;hljs-built_in&quot;&gt;move&lt;/span&gt;(ptr)] {&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; *ptr;};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h2&gt;Generic Lambdas&lt;/h2&gt;\n\n&lt;p&gt;Lambdas can now be generic (&lt;code&gt;auto&lt;/code&gt; would be equivalent to &lt;code&gt;T&lt;/code&gt; here if\n&lt;code&gt;T&lt;/code&gt; were a type template argument somewhere in the surrounding scope):&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; lambda = [](&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; x, &lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; y) {&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; x + y;};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h2&gt;Improved Return Type Deduction&lt;/h2&gt;\n\n&lt;p&gt;C++14 allows deduced return types for every function and does not restrict it to functions of the form &lt;code&gt;return expression;&lt;/code&gt;. This is also extended to lambdas.&lt;/p&gt;\n    ","\n&lt;p&gt;Lambda expressions are typically used to encapsulate algorithms so that they can be passed to another function.  However, &lt;strong&gt;it is possible to execute a lambda immediately upon definition&lt;/strong&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;[&amp;amp;](){ ...your code... }(); &lt;span class=&quot;hljs-comment&quot;&gt;// immediately executed lambda expression&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;is functionally equivalent to&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;{ ...your code... } &lt;span class=&quot;hljs-comment&quot;&gt;// simple code block&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This makes lambda expressions &lt;strong&gt;a powerful tool for refactoring complex functions&lt;/strong&gt;.  You start by wrapping a code section in a lambda function as shown above.  The process of explicit parameterization can then be performed gradually with intermediate testing after each step.  Once you have the code-block fully parameterized (as demonstrated by the removal of the &lt;code&gt;&amp;amp;&lt;/code&gt;), you can move the code to an external location and make it a normal function.&lt;/p&gt;\n\n&lt;p&gt;Similarly, you can use lambda expressions to &lt;strong&gt;initialize variables based on the result of an algorithm&lt;/strong&gt;...&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a = []( &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b ){ &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; r=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (b&amp;gt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) r*=b--; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; r; }(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;// 5!&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;As &lt;strong&gt;a way of partitioning your program logic&lt;/strong&gt;, you might even find it useful to pass a lambda expression as an argument to another lambda expression...&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;[&amp;amp;]( std::function&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;void&lt;/span&gt;()&amp;gt; algorithm ) &lt;span class=&quot;hljs-comment&quot;&gt;// wrapper section&lt;/span&gt;\n   {\n   ...your wrapper code...\n   &lt;span class=&quot;hljs-built_in&quot;&gt;algorithm&lt;/span&gt;();\n   ...your wrapper code...\n   }\n([&amp;amp;]() &lt;span class=&quot;hljs-comment&quot;&gt;// algorithm section&lt;/span&gt;\n   {\n   ...your algorithm code...\n   });\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Lambda expressions also let you create named &lt;a href=&quot;http://en.wikipedia.org/wiki/Nested_function&quot; rel=&quot;noreferrer&quot;&gt;&lt;strong&gt;nested functions&lt;/strong&gt;&lt;/a&gt;, which can be a convenient way of avoiding duplicate logic.  Using named lambdas also tends to be a little easier on the eyes (compared to anonymous inline lambdas) when passing a non-trivial function as a parameter to another function.  &lt;em&gt;Note: don&apos;t forget the semicolon after the closing curly brace.&lt;/em&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; algorithm = [&amp;amp;]( &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; x, &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; m, &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; b ) -&amp;gt; &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt;\n   {\n   &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; m*x+b;\n   };\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a=&lt;span class=&quot;hljs-built_in&quot;&gt;algorithm&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;), b=&lt;span class=&quot;hljs-built_in&quot;&gt;algorithm&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;If subsequent profiling reveals significant initialization overhead for the function object, you might choose to rewrite this as a normal function.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Answers&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Q: What is a lambda expression in C++11?&lt;/p&gt;\n\n&lt;p&gt;A: Under the hood, it is the object of an autogenerated class with overloading &lt;strong&gt;operator() const&lt;/strong&gt;. Such object is called &lt;em&gt;closure&lt;/em&gt; and created by compiler.\nThis &apos;closure&apos; concept is near with the bind concept from C++11. \nBut lambdas typically generate better code. And calls through closures allow full inlining.&lt;/p&gt;\n\n&lt;p&gt;Q: When would I use one?&lt;/p&gt;\n\n&lt;p&gt;A: To define &quot;simple and small logic&quot; and ask compiler perform generation from previous question. You give a compiler some expressions which you want to be inside operator(). All other stuff compiler will generate to you.&lt;/p&gt;\n\n&lt;p&gt;Q: What class of problem do they solve that wasn&apos;t possible prior to their introduction?&lt;/p&gt;\n\n&lt;p&gt;A: It is some kind of syntax sugar like operators overloading instead of functions for custom &lt;em&gt;add, subrtact&lt;/em&gt; operations...But it save more lines of unneeded code to wrap 1-3 lines of real logic to some classes, and etc.! Some engineers think that if the number of lines is smaller then there is a less chance to make errors in it (I&apos;m also think so)&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Example of usage&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; x = [=](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; arg1){&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%i&quot;&lt;/span&gt;, arg1); };\n&lt;span class=&quot;hljs-built_in&quot;&gt;void&lt;/span&gt;(*f)(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;) = x;\n&lt;span class=&quot;hljs-built_in&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);\n&lt;span class=&quot;hljs-built_in&quot;&gt;x&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;Extras about lambdas, not covered by question. Ignore this section if you&apos;re not interest&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;1. Captured values. What you can to capture&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;1.1. You can reference to a variable with static storage duration in lambdas. They all are captured.&lt;/p&gt;\n\n&lt;p&gt;1.2. You can use lambda for capture values &quot;by value&quot;. In such case captured vars will be copied to the function object (closure).&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;[captureVar1,captureVar2](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; arg1){}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;1.3. You can capture be reference. &amp;amp; -- in this context mean reference, not pointers.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;   [&amp;amp;captureVar1,&amp;amp;captureVar2](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; arg1){}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;1.4. It exists notation to capture all non-static vars by value, or by reference&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;  [=](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; arg1){} &lt;span class=&quot;hljs-comment&quot;&gt;// capture all not-static vars by value&lt;/span&gt;\n\n  [&amp;amp;](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; arg1){} &lt;span class=&quot;hljs-comment&quot;&gt;// capture all not-static vars by reference&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;1.5.  It exists notation to capture all non-static vars by value, or by reference and specify smth. more.\nExamples:\nCapture all not-static vars by value, but by reference capture Param2&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;[=,&amp;amp;Param2](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; arg1){} \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Capture all not-static vars by reference, but by value capture Param2&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;[&amp;amp;,Param2](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; arg1){} \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;em&gt;2. Return type deduction&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;2.1. Lambda return type can be deduced if lambda is one expression. Or you can explicitly specify it.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;[=](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; arg1)-&amp;gt;trailing_return_type{&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;trailing_return_type&lt;/span&gt;();}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;If lambda has more then one expression, then return type must be specified via trailing return type. \n  Also, similar syntax can be applied to auto functions and member-functions&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;3. Captured values. What you can not capture&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;3.1. You can capture only local vars, not member variable of the object.&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;4. Сonversions&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;4.1 !! Lambda is not a function pointer and it is not an anonymous function, but &lt;strong&gt;capture-less&lt;/strong&gt; lambdas can be implicitly converted to a function pointer.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;p.s.&lt;/strong&gt; &lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;More about lambda grammar information can be found in Working draft for Programming Language C++ #337, 2012-01-16, 5.1.2. Lambda Expressions, p.88&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;In C++14 the extra feature which has named as &quot;init capture&quot; have been added. It allow to perform arbitarily declaration of closure data members:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; toFloat = [](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; value) { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;float&lt;/span&gt;(value);};\n&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; interpolate = [min = &lt;span class=&quot;hljs-built_in&quot;&gt;toFloat&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;), max = &lt;span class=&quot;hljs-built_in&quot;&gt;toFloat&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;255&lt;/span&gt;)](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; value)-&amp;gt;&lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt; { &lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; (value - min) / (max - min);};\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;/ol&gt;\n    ","\n&lt;p&gt;A lambda function is an anonymous function that you create in-line. It can capture variables as some have explained, (e.g. &lt;a href=&quot;http://www.stroustrup.com/C++11FAQ.html#lambda&quot;&gt;http://www.stroustrup.com/C++11FAQ.html#lambda&lt;/a&gt;) but there are some limitations. For example, if there&apos;s a callback interface like this, &lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; (*f)(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;))&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-built_in&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;you can write a function on the spot to use it like the one passed to apply below:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; col=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-built_in&quot;&gt;apply&lt;/span&gt;([](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; data) {\n        cout &amp;lt;&amp;lt; data &amp;lt;&amp;lt; ((++col % &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;) ? &lt;span class=&quot;hljs-string&quot;&gt;&apos; &apos;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;);\n    });\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;But you can&apos;t do this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; col=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;apply&lt;/span&gt;([&amp;amp;col,n](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; data) {\n        cout &amp;lt;&amp;lt; data &amp;lt;&amp;lt; ((++col % &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;) ? &lt;span class=&quot;hljs-string&quot;&gt;&apos; &apos;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;);\n    });\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;because of limitations in the C++11 standard. If you want to use captures, you have to rely on the library and &lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;functional&amp;gt;&lt;/span&gt; &lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;(or some other STL library like algorithm to get it indirectly) and then work with std::function instead of passing normal functions as parameters like this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;functional&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(std::function&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;)&amp;gt; f)&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-built_in&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;);\n}\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; width)&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; col;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;apply&lt;/span&gt;([width,&amp;amp;col](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; data) {\n        cout &amp;lt;&amp;lt; data &amp;lt;&amp;lt; ((++col % width) ? &lt;span class=&quot;hljs-string&quot;&gt;&apos; &apos;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;);\n    });\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;One of the best explanation of &lt;code&gt;lambda expression&lt;/code&gt; is given from author of C++ &lt;strong&gt;Bjarne Stroustrup&lt;/strong&gt; in his book &lt;code&gt;***The C++ Programming Language***&lt;/code&gt; chapter 11 (&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0321563840&quot; rel=&quot;noreferrer&quot;&gt;ISBN-13: 978-0321563842&lt;/a&gt;):&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;code&gt;What is a lambda expression?&lt;/code&gt;&lt;/strong&gt; &lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;A &lt;em&gt;lambda expression&lt;/em&gt;, sometimes also referred to as a &lt;em&gt;lambda&lt;/em&gt;\n  function or (strictly speaking incorrectly, but colloquially) as a\n  &lt;em&gt;lambda&lt;/em&gt;, is a simplified notation for defining and using an &lt;strong&gt;anonymous function object&lt;/strong&gt;. Instead of defining a named class with an operator(), later making an object of that class, and finally\n  invoking it, we can use a shorthand.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;code&gt;When would I use one?&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;This is particularly useful when we want to pass an operation as an\n  argument to an algorithm. In the context of graphical user interfaces\n  (and elsewhere), such operations are often referred to as &lt;em&gt;callbacks&lt;/em&gt;.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;code&gt;What class of problem do they solve that wasn&apos;t possible prior to their introduction?&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Here i guess every action done with lambda expression can be solved without them, but with much more code and much bigger complexity. Lambda expression this is the way of optimization for your code and a way of making it more attractive. As sad by Stroustup :&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;effective ways of optimizing&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;code&gt;Some examples&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;via lambda expression&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;print_modulo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; v, ostream&amp;amp; os, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; m)&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;// output v[i] to os if v[i]%m==0&lt;/span&gt;\n&lt;/span&gt;{\n    for_each(&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(v),&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(v),\n        [&amp;amp;os,m](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x) { \n           &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (x%m==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) os &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;;\n         });\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or via function&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Modulo_print&lt;/span&gt; {\n         ostream&amp;amp; os; &lt;span class=&quot;hljs-comment&quot;&gt;// members to hold the capture list int m;&lt;/span&gt;\n     &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n         &lt;span class=&quot;hljs-built_in&quot;&gt;Modulo_print&lt;/span&gt;(ostream&amp;amp; s, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; mm) :&lt;span class=&quot;hljs-built_in&quot;&gt;os&lt;/span&gt;(s), &lt;span class=&quot;hljs-built_in&quot;&gt;m&lt;/span&gt;(mm) {} \n         &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;\n           &lt;/span&gt;{ \n             &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (x%m==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) os &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;; \n           }\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or even&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;print_modulo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; v, ostream&amp;amp; os, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; m)&lt;/span&gt; \n     &lt;span class=&quot;hljs-comment&quot;&gt;// output v[i] to os if v[i]%m==0&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Modulo_print&lt;/span&gt; {\n        ostream&amp;amp; os; &lt;span class=&quot;hljs-comment&quot;&gt;// members to hold the capture list&lt;/span&gt;\n        &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; m; \n        &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n           &lt;span class=&quot;hljs-built_in&quot;&gt;Modulo_print&lt;/span&gt; (ostream&amp;amp; s, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; mm) :&lt;span class=&quot;hljs-built_in&quot;&gt;os&lt;/span&gt;(s), &lt;span class=&quot;hljs-built_in&quot;&gt;m&lt;/span&gt;(mm) {}\n           &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;\n           &lt;/span&gt;{ \n               &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (x%m==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) os &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;;\n           }\n     };\n     for_each(&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(v),&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(v),Modulo_print{os,m}); \n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;if u need u can name &lt;code&gt;lambda expression&lt;/code&gt; like below:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;print_modulo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; v, ostream&amp;amp; os, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; m)&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// output v[i] to os if v[i]%m==0&lt;/span&gt;\n&lt;/span&gt;{\n      &lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; Modulo_print = [&amp;amp;os,m] (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x) { &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (x%m==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) os &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;; };\n      for_each(&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(v),&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(v),Modulo_print);\n }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Or assume another simple sample&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;TestFunctions::simpleLambda&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; sensitive = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;\n    std::vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt; v = std::&lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;({&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;33&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;});\n\n    &lt;span class=&quot;hljs-built_in&quot;&gt;sort&lt;/span&gt;(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(),v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(),\n         [sensitive](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; y) {\n             &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n%i\\n&quot;&lt;/span&gt;,  x &amp;lt; y);\n             &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; sensitive ? x &amp;lt; y : &lt;span class=&quot;hljs-built_in&quot;&gt;abs&lt;/span&gt;(x) &amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;abs&lt;/span&gt;(y);\n         });\n\n\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;sorted&quot;&lt;/span&gt;);\n    for_each(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(),\n             [](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x) {\n                 &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;x - %i;&quot;&lt;/span&gt;, x);\n             }\n             );\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;will generate next&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;0&lt;/p&gt;\n  \n  &lt;p&gt;1&lt;/p&gt;\n  \n  &lt;p&gt;0&lt;/p&gt;\n  \n  &lt;p&gt;1&lt;/p&gt;\n  \n  &lt;p&gt;0&lt;/p&gt;\n  \n  &lt;p&gt;1&lt;/p&gt;\n  \n  &lt;p&gt;0&lt;/p&gt;\n  \n  &lt;p&gt;1&lt;/p&gt;\n  \n  &lt;p&gt;0&lt;/p&gt;\n  \n  &lt;p&gt;1&lt;/p&gt;\n  \n  &lt;p&gt;0 sortedx - 1;x - 3;x - 4;x - 5;x - 6;x - 7;x - 33;&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;&lt;code&gt;[]&lt;/code&gt; - this is capture list or &lt;code&gt;lambda introducer&lt;/code&gt;: if &lt;code&gt;lambdas&lt;/code&gt; require no access to their local environment we can use it.&lt;/p&gt;\n\n&lt;p&gt;Quote from book:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;The first character of a lambda expression is always &lt;strong&gt;[&lt;/strong&gt;. A lambda\n  introducer can take various forms:&lt;/p&gt;\n  \n  &lt;p&gt; &lt;strong&gt;[]&lt;/strong&gt;: an empty capture list. This\n  implies that no local names from the surrounding context can be used\n  in the lambda body. For such lambda expressions, data is obtained from\n  arguments or from nonlocal variables. &lt;/p&gt;\n  \n  &lt;p&gt; &lt;strong&gt;[&amp;amp;]&lt;/strong&gt;: implicitly capture by\n  reference. All local names can be used. All local variables are\n  accessed by reference.&lt;/p&gt;\n  \n  &lt;p&gt; &lt;strong&gt;[=]&lt;/strong&gt;: implicitly capture by value. All local\n  names can be used. All names refer to copies of the local variables\n  taken at the point of call of the lambda expression.&lt;/p&gt;\n  \n  &lt;p&gt; &lt;strong&gt;[capture-list]:&lt;/strong&gt;  explicit capture; the capture-list is the list of names of local  variables to be captured (i.e., stored in the object) by reference or by value. Variables with names preceded by &amp;amp; are captured by\n  reference. Other variables are captured by value. A capture list can\n  also contain this and names followed by ... as elements. &lt;/p&gt;\n  \n  &lt;p&gt; &lt;strong&gt;[&amp;amp;,  capture-list]&lt;/strong&gt;: implicitly capture by reference all local variables  with names not men- tioned in the list. The capture list can contain  this. Listed names cannot be preceded by &amp;amp;. Variables named in the\n  capture list are captured by value. &lt;/p&gt;\n  \n  &lt;p&gt; &lt;strong&gt;[=, capture-list]&lt;/strong&gt;: implicitly capture by value all local variables with names not mentioned in the  list. The capture list cannot contain this. The listed names must be preceded by &amp;amp;. Vari- ables named in the capture list are captured by  reference. &lt;/p&gt;\n  \n  &lt;p&gt;Note that a local name preceded by &amp;amp; is always captured by\n  reference and a local name not pre- ceded by &amp;amp; is always captured by\n  value. Only capture by reference allows modification of variables in\n  the calling environment.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;code&gt;Additional&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;Lambda expression&lt;/code&gt; format&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/03yye.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/03yye.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Additional references:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Anonymous_function#C.2B.2B_.28since_C.2B.2B11.29&quot; rel=&quot;noreferrer&quot;&gt;Wiki&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf&quot; rel=&quot;noreferrer&quot;&gt;open-std.org&lt;/a&gt;, chapter 5.1.2&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;The lambda&apos;s in c++ are treated as &quot;on the go available function&quot;.\nyes its literally on the go, you define it; use it; and as the parent function scope finishes the lambda function is gone.&lt;/p&gt;\n\n&lt;p&gt;c++ introduced it in c++ 11 and everyone started using it like at every possible place.\nthe example and what is lambda can be find here &lt;a href=&quot;https://en.cppreference.com/w/cpp/language/lambda&quot; rel=&quot;noreferrer&quot;&gt;https://en.cppreference.com/w/cpp/language/lambda&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;em&gt;i will describe which is not there but essential to know for every c++ programmer&lt;/em&gt;&lt;/strong&gt; &lt;/p&gt;\n\n&lt;p&gt;Lambda is not meant to use everywhere and every function cannot be replaced with lambda. It&apos;s also not the fastest one compare to normal function. because it has some overhead which need to be handled by lambda.&lt;/p&gt;\n\n&lt;p&gt;it will surely help in reducing number of lines in some cases.\nit can be basically used for the section of code, which is getting called in same function one or more time and that piece of code is not needed anywhere else so that you can create standalone function for it.&lt;/p&gt;\n\n&lt;p&gt;Below is the basic example of lambda and what happens in background.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;User code:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n  &lt;span class=&quot;hljs-comment&quot;&gt;// Lambda &amp;amp; auto&lt;/span&gt;\n  &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; member=&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; endGame = [=](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b){ &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a+b+member;};\n\n  &lt;span class=&quot;hljs-built_in&quot;&gt;endGame&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;);\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;How compile expands it:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n  &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; member = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;__lambda_6_18&lt;/span&gt;\n  {\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; member;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;: \n    &lt;span class=&quot;hljs-keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;/*constexpr */&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b)&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;\n    &lt;/span&gt;{\n      &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a + b + member;\n    }\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;: __lambda_6_18(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; _member)\n    : member{_member}\n    {}\n\n  };\n\n  __lambda_6_18 endGame = __lambda_6_18{member};\n  endGame.&lt;span class=&quot;hljs-built_in&quot;&gt;operator&lt;/span&gt;()(&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;);\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;so as you can see, what kind of overhead it adds when you use it.\nso its not good idea to use them everywhere.\nit can be used at places where they are applicable.&lt;/p&gt;\n    ","\n&lt;p&gt;Well, one practical use I&apos;ve found out is reducing boiler plate code. For example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;process_z_vec&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; vec)&lt;/span&gt;\n&lt;/span&gt;{\n  &lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; print_2d = [](&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; board, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; bsize)\n  {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i&amp;lt;bsize; i++)\n    {\n      &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; j=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; j&amp;lt;bsize; j++)\n      {\n        cout &amp;lt;&amp;lt; board[bsize*i+j] &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt;;\n      }\n      cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n&quot;&lt;/span&gt;;\n    }\n  };\n  &lt;span class=&quot;hljs-comment&quot;&gt;// Do sth with the vec.&lt;/span&gt;\n  &lt;span class=&quot;hljs-built_in&quot;&gt;print_2d&lt;/span&gt;(vec,x_size);\n  &lt;span class=&quot;hljs-comment&quot;&gt;// Do sth else with the vec.&lt;/span&gt;\n  &lt;span class=&quot;hljs-built_in&quot;&gt;print_2d&lt;/span&gt;(vec,y_size);\n  &lt;span class=&quot;hljs-comment&quot;&gt;//... &lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Without lambda, you may need to do something for different &lt;code&gt;bsize&lt;/code&gt; cases. Of course you could create a function but what if you want to limit the usage within the scope of the soul user function? the nature of lambda fulfills this requirement and I use it for that case.&lt;/p&gt;\n    ","\n&lt;p&gt;C++ 11 introduced lambda expression to allow us write an inline function which can be used for short snippets of code&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;[ capture clause ] (parameters) -&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;-type\n{\n   definition of method\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Generally return-type in lambda expression are evaluated by compiler itself and we dont need to specify that explicitly and -&amp;gt; return-type part can be ignored but in some complex case as in conditional statement, compiler cant make out the return type and we need to specify that.&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// C++ program to demonstrate lambda expression in C++&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// Function to print vector&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;printVector&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt; v)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-comment&quot;&gt;// lambda expression to print vector&lt;/span&gt;\n    for_each(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(), [](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i)\n    {\n        std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt;;\n    });\n    cout &amp;lt;&amp;lt; endl;\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt; v {&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;};\n\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printVector&lt;/span&gt;(v);\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// below snippet find first number greater than 4&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// find_if searches for an element for which&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// function(third argument) returns true&lt;/span&gt;\n    vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;:: iterator p = &lt;span class=&quot;hljs-built_in&quot;&gt;find_if&lt;/span&gt;(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(), [](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i)\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; i &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;;\n    });\n    cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;First number greater than 4 is : &quot;&lt;/span&gt; &amp;lt;&amp;lt; *p &amp;lt;&amp;lt; endl;\n\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// function to sort vector, lambda expression is for sorting in&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// non-decreasing order Compiler can make out return type as&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// bool, but shown here just for explanation&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;sort&lt;/span&gt;(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(), [](&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;amp; a, &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;amp; b) -&amp;gt; &lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a &amp;gt; b;\n    });\n\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printVector&lt;/span&gt;(v);\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// function to count numbers greater than or equal to 5&lt;/span&gt;\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; count_5 = &lt;span class=&quot;hljs-built_in&quot;&gt;count_if&lt;/span&gt;(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(), [](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a)\n    {\n        &lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; (a &amp;gt;= &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;);\n    });\n    cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;The number of elements greater than or equal to 5 is : &quot;&lt;/span&gt;\n        &amp;lt;&amp;lt; count_5 &amp;lt;&amp;lt; endl;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// function for removing duplicate element (after sorting all&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// duplicate comes together)&lt;/span&gt;\n    p = &lt;span class=&quot;hljs-built_in&quot;&gt;unique&lt;/span&gt;(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(), [](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b)\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a == b;\n    });\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// resizing vector to make size equal to total different number&lt;/span&gt;\n    v.&lt;span class=&quot;hljs-built_in&quot;&gt;resize&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;distance&lt;/span&gt;(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), p));\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printVector&lt;/span&gt;(v);\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// accumulate function accumulate the container on the basis of&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// function provided as third argument&lt;/span&gt;\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; arr[] = {&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;};\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; f = &lt;span class=&quot;hljs-built_in&quot;&gt;accumulate&lt;/span&gt;(arr, arr + &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, [](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; j)\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; i * j;\n    });\n\n    cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Factorial of 10 is : &quot;&lt;/span&gt; &amp;lt;&amp;lt; f &amp;lt;&amp;lt; endl;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;//   We can also access function by storing this into variable&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; square = [](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i)\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; i * i;\n    };\n\n    cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Square of 5 is : &quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;square&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;) &amp;lt;&amp;lt; endl;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Output&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;\nFirst number greater than &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; is : &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\nThe number of elements greater than &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; equal to &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; is : &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\nFactorial of &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt; is : &lt;span class=&quot;hljs-number&quot;&gt;3628800&lt;/span&gt;\nSquare of &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; is : &lt;span class=&quot;hljs-number&quot;&gt;25&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;A lambda expression can have more power than an ordinary function by having access to variables from the enclosing scope. We can capture external variables from enclosing scope by three ways :&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Capture by reference&lt;/li&gt;\n&lt;li&gt;Capture by value&lt;/li&gt;\n&lt;li&gt;Capture by both (mixed capture)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;The syntax used for capturing variables :&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;[&amp;amp;] : capture all external variable by reference&lt;/li&gt;\n&lt;li&gt;[=] : capture all external variable by value&lt;/li&gt;\n&lt;li&gt;[a, &amp;amp;b] : capture a by value and b by reference\nA lambda with empty capture clause [ ] can access only those variable which are local to it.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;    &lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; std;\n    \n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n    &lt;/span&gt;{\n        vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt; v1 = {&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;};\n        vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt; v2 = {&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;16&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;};\n    \n        &lt;span class=&quot;hljs-comment&quot;&gt;// access v1 and v2 by reference&lt;/span&gt;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; pushinto = [&amp;amp;] (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; m)\n        {\n            v1.&lt;span class=&quot;hljs-built_in&quot;&gt;push_back&lt;/span&gt;(m);\n            v2.&lt;span class=&quot;hljs-built_in&quot;&gt;push_back&lt;/span&gt;(m);\n        };\n    \n        &lt;span class=&quot;hljs-comment&quot;&gt;// it pushes 20 in both v1 and v2&lt;/span&gt;\n        &lt;span class=&quot;hljs-built_in&quot;&gt;pushinto&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;);\n    \n        &lt;span class=&quot;hljs-comment&quot;&gt;// access v1 by copy&lt;/span&gt;\n        [v1]()\n        {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; p = v1.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(); p != v1.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(); p++)\n            {\n                cout &amp;lt;&amp;lt; *p &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt;;\n            }\n        };\n    \n        &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; N = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;\n    \n        &lt;span class=&quot;hljs-comment&quot;&gt;// below snippet find first number greater than N&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;// [N] denotes, can access only N by value&lt;/span&gt;\n        vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;:: iterator p = &lt;span class=&quot;hljs-built_in&quot;&gt;find_if&lt;/span&gt;(v1.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v1.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(), [N](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i)\n        {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; i &amp;gt; N;\n        });\n    \n        cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;First number greater than 5 is : &quot;&lt;/span&gt; &amp;lt;&amp;lt; *p &amp;lt;&amp;lt; endl;\n    \n        &lt;span class=&quot;hljs-comment&quot;&gt;// function to count numbers greater than or equal to N&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;// [=] denotes, can access all variable&lt;/span&gt;\n        &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; count_N = &lt;span class=&quot;hljs-built_in&quot;&gt;count_if&lt;/span&gt;(v1.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v1.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(), [=](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a)\n        {\n            &lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; (a &amp;gt;= N);\n        });\n    \n        cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;The number of elements greater than or equal to 5 is : &quot;&lt;/span&gt;\n            &amp;lt;&amp;lt; count_N &amp;lt;&amp;lt; endl;\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Output:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;   First number greater than &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; is : &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;\n   The number of elements greater than &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; equal to &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; is : &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;One problem it solves: &lt;a href=&quot;https://stackoverflow.com/questions/31078201/code-simpler-than-lambda-for-a-call-in-constructor-that-uses-an-output-parameter&quot;&gt;Code simpler than lambda for a call in constructor that uses an output parameter function for initializing a const member&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;You can initialize a const member of your class, with a call to a function that sets its value by giving back its output as an output parameter.&lt;/p&gt;\n    "]},"randomTags":[{"name":"hex","slug":"hex"},{"name":"threetenabp","slug":"threetenabp"},{"name":"dynamic-languages","slug":"dynamic-languages"},{"name":"python-decorators","slug":"python-decorators"},{"name":"reflection","slug":"reflection"},{"name":"callback","slug":"callback"},{"name":"objective-c","slug":"objective-c"},{"name":"prepared-statement","slug":"prepared-statement"},{"name":"webdriver","slug":"webdriver"},{"name":"android-permissions","slug":"android-permissions"},{"name":"dictionary","slug":"dictionary"},{"name":"outer-join","slug":"outer-join"},{"name":"relative-path","slug":"relative-path"},{"name":"scriptlet","slug":"scriptlet"},{"name":"quotes","slug":"quotes"},{"name":"thread-safety","slug":"thread-safety"},{"name":"android-asynctask","slug":"android-asynctask"},{"name":"el","slug":"el"},{"name":"invoke","slug":"invoke"},{"name":"web-scraping","slug":"web-scraping"}]},"__N_SSG":true}