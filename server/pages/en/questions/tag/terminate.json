{"pageProps":{"data":{"count":1,"rows":[{"id":399,"title":"Is there any way to kill a Thread?","slug":"is-there-any-way-to-kill-a-thread-1657387859831","postType":"QUESTION","createdAt":"2022-07-09T17:30:59.000Z","updatedAt":"2022-07-09T17:30:59.000Z","tags":[{"id":2149,"name":"terminate","slug":"terminate","createdAt":"2022-07-09T17:30:59.000Z","updatedAt":"2022-07-09T17:30:59.000Z","Questions_Tags":{"questionId":399,"tagId":2149}}]}]},"slug":"terminate","page":1,"answers":{"399":["\n&lt;p&gt;It is generally a bad pattern to kill a thread abruptly, in Python, and in any language. Think of the following cases:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;the thread is holding a critical resource that must be closed properly&lt;/li&gt;\n&lt;li&gt;the thread has created several other threads that must be killed as well.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;The nice way of handling this, if you can afford it (if you are managing your own threads), is to have an exit_request flag that each thread checks on a regular interval to see if it is time for it to exit.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;For example:&lt;/strong&gt;&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; threading\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;StoppableThread&lt;/span&gt;(threading.Thread):\n    &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;Thread class with a stop() method. The thread itself has to check\n    regularly for the stopped() condition.&quot;&quot;&quot;&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self,  *args, **kwargs&lt;/span&gt;):\n        &lt;span class=&quot;hljs-built_in&quot;&gt;super&lt;/span&gt;(StoppableThread, self).__init__(*args, **kwargs)\n        self._stop_event = threading.Event()\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;stop&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n        self._stop_event.&lt;span class=&quot;hljs-built_in&quot;&gt;set&lt;/span&gt;()\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;stopped&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self._stop_event.is_set()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In this code, you should call &lt;code&gt;stop()&lt;/code&gt; on the thread when you want it to exit, and wait for the thread to exit properly using &lt;code&gt;join()&lt;/code&gt;. The thread should check the stop flag at regular intervals.&lt;/p&gt;\n&lt;p&gt;There are cases, however, when you really need to kill a thread. An example is when you are wrapping an external library that is busy for long calls, and you want to interrupt it.&lt;/p&gt;\n&lt;p&gt;The following code allows (with some restrictions) to raise an Exception in a Python thread:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;_async_raise&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;tid, exctype&lt;/span&gt;):\n    &lt;span class=&quot;hljs-string&quot;&gt;&apos;&apos;&apos;Raises an exception in the threads with id tid&apos;&apos;&apos;&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; inspect.isclass(exctype):\n        &lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; TypeError(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Only types can be raised (not instances)&quot;&lt;/span&gt;)\n    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(ctypes.c_long(tid),\n                                                     ctypes.py_object(exctype))\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; res == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;:\n        &lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; ValueError(&lt;span class=&quot;hljs-string&quot;&gt;&quot;invalid thread id&quot;&lt;/span&gt;)\n    &lt;span class=&quot;hljs-keyword&quot;&gt;elif&lt;/span&gt; res != &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;:\n        &lt;span class=&quot;hljs-comment&quot;&gt;# &quot;if it returns a number greater than one, you&apos;re in trouble,&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;# and you should call it again with exc=NULL to revert the effect&quot;&lt;/span&gt;\n        ctypes.pythonapi.PyThreadState_SetAsyncExc(ctypes.c_long(tid), &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;)\n        &lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; SystemError(&lt;span class=&quot;hljs-string&quot;&gt;&quot;PyThreadState_SetAsyncExc failed&quot;&lt;/span&gt;)\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ThreadWithExc&lt;/span&gt;(threading.Thread):\n    &lt;span class=&quot;hljs-string&quot;&gt;&apos;&apos;&apos;A thread class that supports raising an exception in the thread from\n       another thread.\n    &apos;&apos;&apos;&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;_get_my_tid&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n        &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;determines this (self&apos;s) thread id\n\n        CAREFUL: this function is executed in the context of the caller\n        thread, to get the identity of the thread represented by this\n        instance.\n        &quot;&quot;&quot;&lt;/span&gt;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; self.isAlive():\n            &lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; threading.ThreadError(&lt;span class=&quot;hljs-string&quot;&gt;&quot;the thread is not active&quot;&lt;/span&gt;)\n\n        &lt;span class=&quot;hljs-comment&quot;&gt;# do we have it cached?&lt;/span&gt;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;hasattr&lt;/span&gt;(self, &lt;span class=&quot;hljs-string&quot;&gt;&quot;_thread_id&quot;&lt;/span&gt;):\n            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self._thread_id\n\n        &lt;span class=&quot;hljs-comment&quot;&gt;# no, look for it in the _active dict&lt;/span&gt;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; tid, tobj &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; threading._active.items():\n            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; tobj &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; self:\n                self._thread_id = tid\n                &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; tid\n\n        &lt;span class=&quot;hljs-comment&quot;&gt;# &lt;span class=&quot;hljs-doctag&quot;&gt;TODO:&lt;/span&gt; in python 2.6, there&apos;s a simpler way to do: self.ident&lt;/span&gt;\n\n        &lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; AssertionError(&lt;span class=&quot;hljs-string&quot;&gt;&quot;could not determine the thread&apos;s id&quot;&lt;/span&gt;)\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;raiseExc&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, exctype&lt;/span&gt;):\n        &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;Raises the given exception type in the context of this thread.\n\n        If the thread is busy in a system call (time.sleep(),\n        socket.accept(), ...), the exception is simply ignored.\n\n        If you are sure that your exception should terminate the thread,\n        one way to ensure that it works is:\n\n            t = ThreadWithExc( ... )\n            ...\n            t.raiseExc( SomeException )\n            while t.isAlive():\n                time.sleep( 0.1 )\n                t.raiseExc( SomeException )\n\n        If the exception is to be caught by the thread, you need a way to\n        check that your thread has caught it.\n\n        CAREFUL: this function is executed in the context of the\n        caller thread, to raise an exception in the context of the\n        thread represented by this instance.\n        &quot;&quot;&quot;&lt;/span&gt;\n        _async_raise( self._get_my_tid(), exctype )\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;(Based on &lt;a href=&quot;http://tomerfiliba.com/recipes/Thread2/&quot; rel=&quot;noreferrer&quot;&gt;Killable Threads&lt;/a&gt; by Tomer Filiba. The quote about the return value of &lt;code&gt;PyThreadState_SetAsyncExc&lt;/code&gt; appears to be from an &lt;a href=&quot;https://svn.python.org/projects/stackless/Python-2.4.3/dev/Python/pystate.c&quot; rel=&quot;noreferrer&quot;&gt;old version of Python&lt;/a&gt;.)&lt;/p&gt;\n&lt;p&gt;As noted in the documentation, this is not a magic bullet because if the thread is busy outside the Python interpreter, it will not catch the interruption.&lt;/p&gt;\n&lt;p&gt;A good usage pattern of this code is to have the thread catch a specific exception and perform the cleanup. That way, you can interrupt a task and still have proper cleanup.&lt;/p&gt;\n    ","\n&lt;p&gt;A &lt;a href=&quot;https://docs.python.org/library/multiprocessing.html#multiprocessing.Process&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;multiprocessing.Process&lt;/code&gt;&lt;/a&gt; can &lt;a href=&quot;https://docs.python.org/library/multiprocessing.html#multiprocessing.Process.terminate&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;p.terminate()&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;In the cases where I want to kill a thread, but do not want to use flags/locks/signals/semaphores/events/whatever, I promote the threads to full blown processes. For code that makes use of just a few threads the overhead is not that bad.&lt;/p&gt;\n&lt;p&gt;E.g. this comes in handy to easily terminate helper &quot;threads&quot; which execute blocking I/O&lt;/p&gt;\n&lt;p&gt;The conversion is trivial: In related code replace all &lt;code&gt;threading.Thread&lt;/code&gt; with &lt;code&gt;multiprocessing.Process&lt;/code&gt; and all &lt;code&gt;queue.Queue&lt;/code&gt; with &lt;code&gt;multiprocessing.Queue&lt;/code&gt; and add the required calls of &lt;code&gt;p.terminate()&lt;/code&gt; to your parent process which wants to kill its child &lt;code&gt;p&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;See the &lt;a href=&quot;https://docs.python.org/library/multiprocessing.html&quot; rel=&quot;noreferrer&quot;&gt;Python documentation for &lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;Example:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; multiprocessing\nproc = multiprocessing.Process(target=your_proc_function, args=())\nproc.start()\n&lt;span class=&quot;hljs-comment&quot;&gt;# Terminate the process&lt;/span&gt;\nproc.terminate()  &lt;span class=&quot;hljs-comment&quot;&gt;# sends a SIGTERM&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;There is no official API to do that, no.&lt;/p&gt;\n\n&lt;p&gt;You need to use platform API to kill the thread, e.g. pthread_kill, or TerminateThread. You can access such API e.g. through pythonwin, or through ctypes.&lt;/p&gt;\n\n&lt;p&gt;Notice that this is inherently unsafe. It will likely lead to uncollectable garbage (from local variables of the stack frames that become garbage), and may lead to deadlocks, if the thread being killed has the GIL at the point when it is killed.&lt;/p&gt;\n    ","\n&lt;p&gt;If you are trying to terminate the whole program you can set the thread as a &quot;daemon&quot;. see\n&lt;a href=&quot;http://docs.python.org/library/threading.html#threading.Thread.daemon&quot; rel=&quot;noreferrer&quot;&gt;Thread.daemon&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;As others have mentioned, the norm is to set a stop flag. For something lightweight (no subclassing of Thread, no global variable), a lambda callback is an option. (Note the parentheses in &lt;code&gt;if stop()&lt;/code&gt;.)&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; threading\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; time\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;do_work&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;id&lt;/span&gt;, stop&lt;/span&gt;):\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;I am thread&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-built_in&quot;&gt;id&lt;/span&gt;)\n    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;:\n        &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;I am thread {} doing something&quot;&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;format&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;id&lt;/span&gt;))\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; stop():\n            &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;  Exiting loop.&quot;&lt;/span&gt;)\n            &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Thread {}, signing off&quot;&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;format&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;id&lt;/span&gt;))\n\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;():\n    stop_threads = &lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;\n    workers = []\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;):\n        tmp = threading.Thread(target=do_work, args=(&lt;span class=&quot;hljs-built_in&quot;&gt;id&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt;: stop_threads))\n        workers.append(tmp)\n        tmp.start()\n    time.sleep(&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;)\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;main: done sleeping; time to stop the threads.&apos;&lt;/span&gt;)\n    stop_threads = &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; worker &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; workers:\n        worker.join()\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Finis.&apos;&lt;/span&gt;)\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;hljs-string&quot;&gt;&apos;__main__&apos;&lt;/span&gt;:\n    main()\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Replacing &lt;code&gt;print()&lt;/code&gt; with a &lt;code&gt;pr()&lt;/code&gt; function that always flushes (&lt;code&gt;sys.stdout.flush()&lt;/code&gt;) may improve the precision of the shell output.&lt;/p&gt;\n\n&lt;p&gt;(Only tested on Windows/Eclipse/Python3.3)&lt;/p&gt;\n    ","\n&lt;p&gt;In Python, you simply cannot kill a Thread directly.&lt;/p&gt;\n\n&lt;p&gt;If you do NOT really need to have a Thread (!), what you can do, instead of using the &lt;a href=&quot;http://docs.python.org/2/library/threading.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;em&gt;threading&lt;/em&gt; package &lt;/a&gt;, is to use the \n&lt;a href=&quot;http://docs.python.org/2/library/multiprocessing.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;em&gt;multiprocessing&lt;/em&gt; package &lt;/a&gt;. Here, to kill a process, you can simply call the method:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;yourProcess.terminate()  &lt;span class=&quot;hljs-comment&quot;&gt;# kill the process!&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Python will kill your process (on Unix through the SIGTERM signal, while on Windows through the &lt;code&gt;TerminateProcess()&lt;/code&gt; call). Pay attention to use it while using a Queue or a Pipe! (it may corrupt the data in the Queue/Pipe)&lt;/p&gt;\n\n&lt;p&gt;Note that the &lt;code&gt;multiprocessing.Event&lt;/code&gt; and the &lt;code&gt;multiprocessing.Semaphore&lt;/code&gt; work exactly in the same way of the &lt;code&gt;threading.Event&lt;/code&gt; and the &lt;code&gt;threading.Semaphore&lt;/code&gt; respectively. In fact, the first ones are clones of the latters.&lt;/p&gt;\n\n&lt;p&gt;If you REALLY need to use a Thread, there is no way to kill it directly. What you can do, however, is to use a &lt;em&gt;&quot;daemon thread&quot;&lt;/em&gt;. In fact, in Python, a Thread can be flagged as &lt;em&gt;daemon&lt;/em&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;yourThread.daemon = &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;  &lt;span class=&quot;hljs-comment&quot;&gt;# set the Thread as a &quot;daemon thread&quot;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The main program will exit when no alive non-daemon threads are left. In other words, when your main thread (which is, of course, a non-daemon thread) will finish its operations, the program will exit even if there are still some daemon threads working.&lt;/p&gt;\n\n&lt;p&gt;Note that it is necessary to set a Thread as &lt;code&gt;daemon&lt;/code&gt; before the &lt;code&gt;start()&lt;/code&gt; method is called!&lt;/p&gt;\n\n&lt;p&gt;Of course you can, and should, use &lt;code&gt;daemon&lt;/code&gt; even with &lt;code&gt;multiprocessing&lt;/code&gt;. Here, when the main process exits, it attempts to terminate all of its daemonic child processes.&lt;/p&gt;\n\n&lt;p&gt;Finally, please, note that &lt;code&gt;sys.exit()&lt;/code&gt; and &lt;code&gt;os.kill()&lt;/code&gt; are not choices.&lt;/p&gt;\n    ","\n&lt;p&gt;This is based on the &lt;a href=&quot;https://web.archive.org/web/20100514180958id_/http://code.activestate.com:80/recipes/496960-thread2-killable-threads/?in=lang-python&quot; rel=&quot;nofollow noreferrer&quot;&gt;thread2 -- killable threads&lt;/a&gt; ActiveState recipe.&lt;/p&gt;\n&lt;p&gt;You need to call &lt;a href=&quot;https://docs.python.org/3/c-api/init.html#c.PyThreadState_SetAsyncExc&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;PyThreadState_SetAsyncExc()&lt;/code&gt;&lt;/a&gt;, which is only available through the &lt;a href=&quot;https://docs.python.org/3/library/ctypes.html#module-ctypes&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; module.&lt;/p&gt;\n&lt;p&gt;This has only been tested on Python 2.7.3, but it is likely to work with other recent 2.x releases. &lt;code&gt;PyThreadState_SetAsyncExc()&lt;/code&gt; still exists in Python 3 for backwards compatibility (but I have not tested it).&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; ctypes\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;terminate_thread&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;thread&lt;/span&gt;):\n    &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;Terminates a python thread from another thread.\n\n    :param thread: a threading.Thread instance\n    &quot;&quot;&quot;&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; thread.isAlive():\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;\n\n    exc = ctypes.py_object(SystemExit)\n    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(\n        ctypes.c_long(thread.ident), exc)\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; res == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;:\n        &lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; ValueError(&lt;span class=&quot;hljs-string&quot;&gt;&quot;nonexistent thread id&quot;&lt;/span&gt;)\n    &lt;span class=&quot;hljs-keyword&quot;&gt;elif&lt;/span&gt; res &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;:\n        &lt;span class=&quot;hljs-comment&quot;&gt;# &quot;&quot;&quot;if it returns a number greater than one, you&apos;re in trouble,&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;# and you should call it again with exc=NULL to revert the effect&quot;&quot;&quot;&lt;/span&gt;\n        ctypes.pythonapi.PyThreadState_SetAsyncExc(thread.ident, &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;)\n        &lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; SystemError(&lt;span class=&quot;hljs-string&quot;&gt;&quot;PyThreadState_SetAsyncExc failed&quot;&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;You should never forcibly kill a thread without cooperating with it.&lt;/p&gt;\n\n&lt;p&gt;Killing a thread removes any guarantees that try/finally blocks set up so you might leave locks locked, files open, etc.&lt;/p&gt;\n\n&lt;p&gt;The only time you can argue that forcibly killing threads is a good idea is to kill a program fast, but never single threads.&lt;/p&gt;\n    ","\n&lt;p&gt;If you are explicitly calling &lt;code&gt;time.sleep()&lt;/code&gt; as part of your thread (say polling some external service), an improvement upon Phillipe&apos;s method is to use the timeout in the &lt;code&gt;event&lt;/code&gt;&apos;s &lt;code&gt;wait()&lt;/code&gt; method wherever you &lt;code&gt;sleep()&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;For example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; threading\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;KillableThread&lt;/span&gt;(threading.Thread):\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, sleep_interval=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;):\n        &lt;span class=&quot;hljs-built_in&quot;&gt;super&lt;/span&gt;().__init__()\n        self._kill = threading.Event()\n        self._interval = sleep_interval\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;run&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n        &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;:\n            &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Do Something&quot;&lt;/span&gt;)\n\n            &lt;span class=&quot;hljs-comment&quot;&gt;# If no kill signal is set, sleep for the interval,&lt;/span&gt;\n            &lt;span class=&quot;hljs-comment&quot;&gt;# If kill signal comes in while sleeping, immediately&lt;/span&gt;\n            &lt;span class=&quot;hljs-comment&quot;&gt;#  wake up and handle&lt;/span&gt;\n            is_killed = self._kill.wait(self._interval)\n            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; is_killed:\n                &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;\n\n        &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Killing Thread&quot;&lt;/span&gt;)\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;kill&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n        self._kill.&lt;span class=&quot;hljs-built_in&quot;&gt;set&lt;/span&gt;()\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Then to run it&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;t = KillableThread(sleep_interval=&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;)\nt.start()\n&lt;span class=&quot;hljs-comment&quot;&gt;# Every 5 seconds it prints:&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;#: Do Something&lt;/span&gt;\nt.kill()\n&lt;span class=&quot;hljs-comment&quot;&gt;#: Killing Thread&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The advantage of using &lt;code&gt;wait()&lt;/code&gt; instead of &lt;code&gt;sleep()&lt;/code&gt;ing and regularly checking the event is that you can program in longer intervals of sleep, the thread is stopped almost immediately (when you would otherwise be &lt;code&gt;sleep()&lt;/code&gt;ing) and in my opinion, the code for handling exit is significantly simpler.&lt;/p&gt;\n    ","\n&lt;p&gt;You can kill a thread by installing trace into the thread that will exit the thread.   See attached link for one possible implementation.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://web.archive.org/web/20130503082442/http://mail.python.org/pipermail/python-list/2004-May/281943.html&quot; rel=&quot;noreferrer&quot;&gt;Kill a thread in Python&lt;/a&gt; &lt;/p&gt;\n    ","\n&lt;p&gt;It is better if you don&apos;t kill a thread.\nA way could be to introduce a &quot;try&quot; block into the thread&apos;s cycle and to throw an exception when you want to stop the thread (for example a break/return/... that stops your for/while/...). \nI&apos;ve used this on my app and it works...&lt;/p&gt;\n    ","\n&lt;p&gt;It is definitely possible to implement a &lt;code&gt;Thread.stop&lt;/code&gt; method as shown in the following example code:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; sys\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; threading\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; time\n\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;StopThread&lt;/span&gt;(&lt;span class=&quot;hljs-title class_ inherited__&quot;&gt;StopIteration&lt;/span&gt;):\n    &lt;span class=&quot;hljs-keyword&quot;&gt;pass&lt;/span&gt;\n\nthreading.SystemExit = SystemExit, StopThread\n\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Thread2&lt;/span&gt;(threading.Thread):\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;stop&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n        self.__stop = &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;_bootstrap&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; threading._trace_hook &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;:\n            &lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; ValueError(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Cannot run thread with tracing!&apos;&lt;/span&gt;)\n        self.__stop = &lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;\n        sys.settrace(self.__trace)\n        &lt;span class=&quot;hljs-built_in&quot;&gt;super&lt;/span&gt;()._bootstrap()\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__trace&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, frame, event, arg&lt;/span&gt;):\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; self.__stop:\n            &lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; StopThread()\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self.__trace\n\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Thread3&lt;/span&gt;(threading.Thread):\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;_bootstrap&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, stop_thread=&lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;&lt;/span&gt;):\n        &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;stop&lt;/span&gt;():\n            &lt;span class=&quot;hljs-keyword&quot;&gt;nonlocal&lt;/span&gt; stop_thread\n            stop_thread = &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n        self.stop = stop\n\n        &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;tracer&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;*_&lt;/span&gt;):\n            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; stop_thread:\n                &lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; StopThread()\n            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; tracer\n        sys.settrace(tracer)\n        &lt;span class=&quot;hljs-built_in&quot;&gt;super&lt;/span&gt;()._bootstrap()\n\n&lt;span class=&quot;hljs-comment&quot;&gt;###############################################################################&lt;/span&gt;\n\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;():\n    test1 = Thread2(target=printer)\n    test1.start()\n    time.sleep(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)\n    test1.stop()\n    test1.join()\n    test2 = Thread2(target=speed_test)\n    test2.start()\n    time.sleep(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)\n    test2.stop()\n    test2.join()\n    test3 = Thread3(target=speed_test)\n    test3.start()\n    time.sleep(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)\n    test3.stop()\n    test3.join()\n\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;printer&lt;/span&gt;():\n    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;:\n        &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(time.time() % &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)\n        time.sleep(&lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt;)\n\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;speed_test&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;count=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;):\n    &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;:\n        &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;:\n            count += &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;except&lt;/span&gt; StopThread:\n        &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Count =&apos;&lt;/span&gt;, count)\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;hljs-string&quot;&gt;&apos;__main__&apos;&lt;/span&gt;:\n    main()\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The &lt;code&gt;Thread3&lt;/code&gt; class appears to run code approximately 33% faster than the &lt;code&gt;Thread2&lt;/code&gt; class.&lt;/p&gt;\n    ","\n&lt;p&gt;I&apos;m way late to this game, but I&apos;ve been wrestling with &lt;a href=&quot;https://stackoverflow.com/q/50473309/2123176&quot;&gt;a similar question&lt;/a&gt; and the following appears to both resolve the issue perfectly for me AND lets me do some basic thread state checking and cleanup when the daemonized sub-thread exits:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; threading\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; time\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; atexit\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;do_work&lt;/span&gt;():\n\n  i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;  @atexit.register&lt;/span&gt;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;goodbye&lt;/span&gt;():\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; (&lt;span class=&quot;hljs-string&quot;&gt;&quot;&apos;CLEANLY&apos; kill sub-thread with value: %s [THREAD: %s]&quot;&lt;/span&gt; %\n           (i, threading.currentThread().ident))\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;:\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; i\n    i += &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n    time.sleep(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)\n\nt = threading.Thread(target=do_work)\nt.daemon = &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\nt.start()\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;after_timeout&lt;/span&gt;():\n  &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;KILL MAIN THREAD: %s&quot;&lt;/span&gt; % threading.currentThread().ident\n  &lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; SystemExit\n\nthreading.Timer(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, after_timeout).start()\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Yields:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\nKILL MAIN THREAD: &lt;span class=&quot;hljs-number&quot;&gt;140013208254208&lt;/span&gt;\n&lt;span class=&quot;hljs-string&quot;&gt;&apos;CLEANLY&apos;&lt;/span&gt; kill sub-thread &lt;span class=&quot;hljs-keyword&quot;&gt;with&lt;/span&gt; value: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; [THREAD: &lt;span class=&quot;hljs-number&quot;&gt;140013674317568&lt;/span&gt;]\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Following workaround can be used to kill a thread:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;kill_threads = &lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;doSomething&lt;/span&gt;():\n    &lt;span class=&quot;hljs-keyword&quot;&gt;global&lt;/span&gt; kill_threads\n    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;:\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; kill_threads:\n            thread.exit()\n        ......\n        ......\n\nthread.start_new_thread(doSomething, ())\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This can be used even for terminating threads, whose code is written in another module, from main thread. We can declare a global variable in that module and use it to terminate thread/s spawned in that module.&lt;/p&gt;\n\n&lt;p&gt;I usually use this to terminate all the threads at the program exit. This might not be the perfect way to terminate thread/s but could help.&lt;/p&gt;\n    ","\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; ctypes &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; *\npthread = cdll.LoadLibrary(&lt;span class=&quot;hljs-string&quot;&gt;&quot;libpthread-2.15.so&quot;&lt;/span&gt;)\npthread.pthread_cancel(c_ulong(t.ident))\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;t&lt;/strong&gt; is your &lt;code&gt;Thread&lt;/code&gt; object.&lt;/p&gt;\n\n&lt;p&gt;Read the python source (&lt;code&gt;Modules/threadmodule.c&lt;/code&gt; and &lt;code&gt;Python/thread_pthread.h&lt;/code&gt;) you can see the &lt;code&gt;Thread.ident&lt;/code&gt; is an &lt;code&gt;pthread_t&lt;/code&gt; type, so you can do anything &lt;code&gt;pthread&lt;/code&gt; can do in python use &lt;code&gt;libpthread&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;Here&apos;s yet another way to do it, but with extremely clean and simple code, that works in Python 3.7 in 2021:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; ctypes \n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;kill_thread&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;thread&lt;/span&gt;):\n    &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;\n    thread: a threading.Thread object\n    &quot;&quot;&quot;&lt;/span&gt;\n    thread_id = thread.ident\n    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(thread_id, ctypes.py_object(SystemExit))\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; res &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;:\n        ctypes.pythonapi.PyThreadState_SetAsyncExc(thread_id, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)\n        &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Exception raise failure&apos;&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Adapted from here: &lt;a href=&quot;https://www.geeksforgeeks.org/python-different-ways-to-kill-a-thread/&quot; rel=&quot;noreferrer&quot;&gt;https://www.geeksforgeeks.org/python-different-ways-to-kill-a-thread/&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;One thing I want to add is that if you read official documentation in &lt;a href=&quot;https://docs.python.org/2/library/threading.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;threading lib Python&lt;/a&gt;, it&apos;s recommended to avoid use of &quot;demonic&quot; threads, when you don&apos;t want threads end abruptly, with the flag that Paolo Rovelli &lt;a href=&quot;https://stackoverflow.com/a/15185771&quot;&gt;mentioned&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;From official documentation:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Daemon threads are abruptly stopped at shutdown. Their resources (such as open files, database transactions, etc.) may not be released properly. If you want your threads to stop gracefully, make them non-daemonic and use a suitable signaling mechanism such as an Event.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;I think that creating daemonic threads depends of your application, but in general (and in my opinion) it&apos;s better to avoid killing them or making them daemonic. In multiprocessing you can use &lt;code&gt;is_alive()&lt;/code&gt; to check process status  and &quot;terminate&quot; for finish them (Also you avoid GIL problems). But you can find more problems, sometimes, when you execute your code in Windows.&lt;/p&gt;\n\n&lt;p&gt;And always remember that if you have &quot;live threads&quot;, the Python interpreter will be running for wait them. (Because of this daemonic can help you if don&apos;t matter abruptly ends).&lt;/p&gt;\n    ","\n&lt;p&gt;There is a library built for this purpose, &lt;a href=&quot;https://pypi.org/project/stopit/&quot; rel=&quot;nofollow noreferrer&quot;&gt;stopit&lt;/a&gt;. Although some of the same cautions listed herein still apply, at least this library presents a regular, repeatable technique for achieving the stated goal.&lt;/p&gt;\n    ","\n&lt;p&gt;Asuming, that you want to have multiple threads of the same function, this is IMHO the easiest implementation to stop one by id:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; time\n&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; threading &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; Thread\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;doit&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;):\n    doit.stop=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;start id:%d&quot;&lt;/span&gt;%&lt;span class=&quot;hljs-built_in&quot;&gt;id&lt;/span&gt;)\n    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;:\n        time.sleep(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)\n        &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;.&quot;&lt;/span&gt;)\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; doit.stop==&lt;span class=&quot;hljs-built_in&quot;&gt;id&lt;/span&gt;:\n            doit.stop=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;end thread %d&quot;&lt;/span&gt;%&lt;span class=&quot;hljs-built_in&quot;&gt;id&lt;/span&gt;)\n\nt5=Thread(target=doit, args=(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;,))\nt6=Thread(target=doit, args=(&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;,))\n\nt5.start() ; t6.start()\ntime.sleep(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)\ndoit.stop =&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;  &lt;span class=&quot;hljs-comment&quot;&gt;#kill t5&lt;/span&gt;\ntime.sleep(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)\ndoit.stop =&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;  &lt;span class=&quot;hljs-comment&quot;&gt;#kill t6&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The nice thing is here, you can have multiple of same and different functions, and stop them all by &lt;code&gt;functionname.stop&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;If you want to have only one thread of the function then you don&apos;t need to remember the id. Just stop, if &lt;code&gt;doit.stop&lt;/code&gt; &amp;gt; 0.&lt;/p&gt;\n    ","\n&lt;p&gt;Just to build up on @SCB&apos;s idea (which was exactly what I needed) to create a KillableThread  subclass with a customized function:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; threading &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; Thread, Event\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;KillableThread&lt;/span&gt;(&lt;span class=&quot;hljs-title class_ inherited__&quot;&gt;Thread&lt;/span&gt;):\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, sleep_interval=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, target=&lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;, name=&lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;, args=(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;), kwargs={}&lt;/span&gt;):\n        &lt;span class=&quot;hljs-built_in&quot;&gt;super&lt;/span&gt;().__init__(&lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;, target, name, args, kwargs)\n        self._kill = Event()\n        self._interval = sleep_interval\n        &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(self._target)\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;run&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n        &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;:\n            &lt;span class=&quot;hljs-comment&quot;&gt;# Call custom function with arguments&lt;/span&gt;\n            self._target(*self._args)\n\n            &lt;span class=&quot;hljs-comment&quot;&gt;# If no kill signal is set, sleep for the interval,&lt;/span&gt;\n            &lt;span class=&quot;hljs-comment&quot;&gt;# If kill signal comes in while sleeping, immediately&lt;/span&gt;\n            &lt;span class=&quot;hljs-comment&quot;&gt;#  wake up and handle&lt;/span&gt;\n            is_killed = self._kill.wait(self._interval)\n            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; is_killed:\n                &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;\n\n        &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Killing Thread&quot;&lt;/span&gt;)\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;kill&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n        self._kill.&lt;span class=&quot;hljs-built_in&quot;&gt;set&lt;/span&gt;()\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;hljs-string&quot;&gt;&apos;__main__&apos;&lt;/span&gt;:\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;print_msg&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;msg&lt;/span&gt;):\n        &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(msg)\n\n    t = KillableThread(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, print_msg, args=(&lt;span class=&quot;hljs-string&quot;&gt;&quot;hello world&quot;&lt;/span&gt;))\n    t.start()\n    time.sleep(&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;)\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;About to kill thread&quot;&lt;/span&gt;)\n    t.kill()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Naturally, like with @SBC, the thread doesn&apos;t wait to run a new loop to stop. In this example, you would see the &quot;Killing Thread&quot; message printed right after the &quot;About to kill thread&quot; instead of waiting for 4 more seconds for the thread to complete (since we have slept for 6 seconds already).&lt;/p&gt;\n&lt;p&gt;Second argument in KillableThread constructor is your custom function (print_msg here). Args argument are the arguments that will be used when calling the function ((&quot;hello world&quot;)) here.&lt;/p&gt;\n    ","\n&lt;p&gt;While it&apos;s rather old, &lt;a href=&quot;http://code.activestate.com/recipes/496960-thread2-killable-threads/&quot; rel=&quot;nofollow noreferrer&quot;&gt;this&lt;/a&gt; might be a handy solution for some:  &lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;A little module that extends the threading&apos;s module functionality --\n  allows one thread to raise exceptions in the context of another\n  thread. By raising &lt;code&gt;SystemExit&lt;/code&gt;, you can finally kill python threads.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; threading\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; ctypes     \n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;_async_raise&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;tid, excobj&lt;/span&gt;):\n    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, ctypes.py_object(excobj))\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; res == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;:\n        &lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; ValueError(&lt;span class=&quot;hljs-string&quot;&gt;&quot;nonexistent thread id&quot;&lt;/span&gt;)\n    &lt;span class=&quot;hljs-keyword&quot;&gt;elif&lt;/span&gt; res &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;:\n        &lt;span class=&quot;hljs-comment&quot;&gt;# &quot;&quot;&quot;if it returns a number greater than one, you&apos;re in trouble, &lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;# and you should call it again with exc=NULL to revert the effect&quot;&quot;&quot;&lt;/span&gt;\n        ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)\n        &lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; SystemError(&lt;span class=&quot;hljs-string&quot;&gt;&quot;PyThreadState_SetAsyncExc failed&quot;&lt;/span&gt;)\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Thread&lt;/span&gt;(threading.Thread):\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;raise_exc&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, excobj&lt;/span&gt;):\n        &lt;span class=&quot;hljs-keyword&quot;&gt;assert&lt;/span&gt; self.isAlive(), &lt;span class=&quot;hljs-string&quot;&gt;&quot;thread must be started&quot;&lt;/span&gt;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; tid, tobj &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; threading._active.items():\n            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; tobj &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; self:\n                _async_raise(tid, excobj)\n                &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;\n\n        &lt;span class=&quot;hljs-comment&quot;&gt;# the thread was alive when we entered the loop, but was not found &lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;# in the dict, hence it must have been already terminated. should we raise&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;# an exception here? silently ignore?&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;terminate&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n        &lt;span class=&quot;hljs-comment&quot;&gt;# must raise the SystemExit type, instead of a SystemExit() instance&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;# due to a bug in PyThreadState_SetAsyncExc&lt;/span&gt;\n        self.raise_exc(SystemExit)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So, it allows a &quot;thread to raise exceptions in the context of another thread&quot; and in this way, the terminated thread can handle the termination without regularly checking an abort flag.&lt;/p&gt;\n\n&lt;p&gt;However, according to its &lt;a href=&quot;http://tomerfiliba.com/recipes/Thread2/&quot; rel=&quot;nofollow noreferrer&quot;&gt;original source&lt;/a&gt;, there are some issues with this code.&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;ul&gt;\n  &lt;li&gt;The exception will be raised only when executing python bytecode. If    your thread calls a native/built-in blocking function, the\n  exception    will be raised only when execution returns to the python\n  code. \n  \n  &lt;ul&gt;\n  &lt;li&gt;There is also an issue if the built-in function internally calls    PyErr_Clear(), which would effectively cancel your pending exception. \n  You can try to raise it again.&lt;/li&gt;\n  &lt;/ul&gt;&lt;/li&gt;\n  &lt;li&gt;Only exception types can be raised    safely. Exception instances are likely to cause unexpected behavior,    and are thus restricted.\n  \n  &lt;ul&gt;\n  &lt;li&gt;For example: t1.raise_exc(TypeError) and    not t1.raise_exc(TypeError(&quot;blah&quot;)).&lt;/li&gt;\n  &lt;li&gt;IMHO it&apos;s a bug, and I reported it as one. For more info,    &lt;a href=&quot;http://mail.python.org/pipermail/python-dev/2006-August/068158.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;http://mail.python.org/pipermail/python-dev/2006-August/068158.html&lt;/a&gt;  &lt;/li&gt;\n  &lt;/ul&gt;&lt;/li&gt;\n  &lt;li&gt;I asked to expose this function in the built-in thread module, but    since ctypes has become a standard library (as of 2.5), and this&lt;br&gt;\n  feature is not likely to be implementation-agnostic, it may be kept&lt;br&gt;\n  unexposed.&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;As mentioned in @Kozyarchuk&apos;s &lt;a href=&quot;https://stackoverflow.com/questions/323972/is-there-any-way-to-kill-a-thread/325027#325027&quot;&gt;answer&lt;/a&gt;, installing trace works. Since this answer contained no code, here is a working ready-to-use example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; sys, threading, time \n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;TraceThread&lt;/span&gt;(threading.Thread): \n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, *args, **keywords&lt;/span&gt;): \n        threading.Thread.__init__(self, *args, **keywords) \n        self.killed = &lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;start&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;): \n        self._run = self.run \n        self.run = self.settrace_and_run\n        threading.Thread.start(self) \n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;settrace_and_run&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;): \n        sys.settrace(self.globaltrace) \n        self._run()\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;globaltrace&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, frame, event, arg&lt;/span&gt;): \n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self.localtrace &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; event == &lt;span class=&quot;hljs-string&quot;&gt;&apos;call&apos;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;localtrace&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, frame, event, arg&lt;/span&gt;): \n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; self.killed &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; event == &lt;span class=&quot;hljs-string&quot;&gt;&apos;line&apos;&lt;/span&gt;: \n            &lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; SystemExit() \n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self.localtrace \n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;f&lt;/span&gt;(): \n    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;: \n        &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;1&apos;&lt;/span&gt;) \n        time.sleep(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)\n        &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;2&apos;&lt;/span&gt;) \n        time.sleep(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)\n        &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;3&apos;&lt;/span&gt;) \n        time.sleep(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)\n\nt = TraceThread(target=f) \nt.start() \ntime.sleep(&lt;span class=&quot;hljs-number&quot;&gt;2.5&lt;/span&gt;) \nt.killed = &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It stops after having printed &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt;. &lt;code&gt;3&lt;/code&gt; is not printed.&lt;/p&gt;\n    ","\n&lt;p&gt;Python version: 3.8&lt;/p&gt;\n&lt;p&gt;Using daemon thread to execute what we wanted, if we want to daemon thread be terminated, all we need is making parent thread exit, then system will terminate daemon thread which parent thread created.&lt;/p&gt;\n&lt;p&gt;Also support coroutine and coroutine function.&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;():\n    start_time = time.perf_counter()\n    t1 = ExitThread(time.sleep, (&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,), debug=&lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;)\n    t1.start()\n    time.sleep(&lt;span class=&quot;hljs-number&quot;&gt;0.5&lt;/span&gt;)\n    t1.exit()\n    &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;:\n        &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(t1.result_future.result())\n    &lt;span class=&quot;hljs-keyword&quot;&gt;except&lt;/span&gt; concurrent.futures.CancelledError:\n        &lt;span class=&quot;hljs-keyword&quot;&gt;pass&lt;/span&gt;\n    end_time = time.perf_counter()\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;f&quot;time cost &lt;span class=&quot;hljs-subst&quot;&gt;{end_time - start_time:&lt;span class=&quot;hljs-number&quot;&gt;0.2&lt;/span&gt;f}&lt;/span&gt;&quot;&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;below is ExitThread source code&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; concurrent.futures\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; threading\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; typing\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; asyncio\n\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;_WorkItem&lt;/span&gt;(&lt;span class=&quot;hljs-title class_ inherited__&quot;&gt;object&lt;/span&gt;):\n    &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot; concurrent\\futures\\thread.py\n\n    &quot;&quot;&quot;&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, future, fn, args, kwargs, *, debug=&lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;&lt;/span&gt;):\n        self._debug = debug\n        self.future = future\n        self.fn = fn\n        self.args = args\n        self.kwargs = kwargs\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;run&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; self._debug:\n            &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;ExitThread._WorkItem run&quot;&lt;/span&gt;)\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; self.future.set_running_or_notify_cancel():\n            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;\n\n        &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;:\n            coroutine = &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; asyncio.iscoroutinefunction(self.fn):\n                coroutine = self.fn(*self.args, **self.kwargs)\n            &lt;span class=&quot;hljs-keyword&quot;&gt;elif&lt;/span&gt; asyncio.iscoroutine(self.fn):\n                coroutine = self.fn\n            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; coroutine &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;:\n                result = self.fn(*self.args, **self.kwargs)\n            &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:\n                result = asyncio.run(coroutine)\n            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; self._debug:\n                &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;_WorkItem done&quot;&lt;/span&gt;)\n        &lt;span class=&quot;hljs-keyword&quot;&gt;except&lt;/span&gt; BaseException &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; exc:\n            self.future.set_exception(exc)\n            &lt;span class=&quot;hljs-comment&quot;&gt;# Break a reference cycle with the exception &apos;exc&apos;&lt;/span&gt;\n            self = &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:\n            self.future.set_result(result)\n\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ExitThread&lt;/span&gt;:\n    &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot; Like a stoppable thread\n\n    Using coroutine for target then exit before running may cause RuntimeWarning.\n\n    &quot;&quot;&quot;&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, target: typing.&lt;span class=&quot;hljs-type&quot;&gt;Union&lt;/span&gt;[typing.&lt;span class=&quot;hljs-type&quot;&gt;Coroutine&lt;/span&gt;, typing.&lt;span class=&quot;hljs-type&quot;&gt;Callable&lt;/span&gt;] = &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;\n                 , args=(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;), kwargs={}, *, daemon=&lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;, debug=&lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;&lt;/span&gt;):\n        &lt;span class=&quot;hljs-comment&quot;&gt;#&lt;/span&gt;\n        self._debug = debug\n        self._parent_thread = threading.Thread(target=self._parent_thread_run, name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;ExitThread_parent_thread&quot;&lt;/span&gt;\n                                               , daemon=daemon)\n        self._child_daemon_thread = &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;\n        self.result_future = concurrent.futures.Future()\n        self._workItem = _WorkItem(self.result_future, target, args, kwargs, debug=debug)\n        self._parent_thread_exit_lock = threading.Lock()\n        self._parent_thread_exit_lock.acquire()\n        self._parent_thread_exit_lock_released = &lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;  &lt;span class=&quot;hljs-comment&quot;&gt;# When done it will be True&lt;/span&gt;\n        self._started = &lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;\n        self._exited = &lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;\n        self.result_future.add_done_callback(self._release_parent_thread_exit_lock)\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;_parent_thread_run&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n        self._child_daemon_thread = threading.Thread(target=self._child_daemon_thread_run\n                                                     , name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;ExitThread_child_daemon_thread&quot;&lt;/span&gt;\n                                                     , daemon=&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;)\n        self._child_daemon_thread.start()\n        &lt;span class=&quot;hljs-comment&quot;&gt;# Block manager thread&lt;/span&gt;\n        self._parent_thread_exit_lock.acquire()\n        self._parent_thread_exit_lock.release()\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; self._debug:\n            &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;ExitThread._parent_thread_run exit&quot;&lt;/span&gt;)\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;_release_parent_thread_exit_lock&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, _future&lt;/span&gt;):\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; self._debug:\n            &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;f&quot;ExitThread._release_parent_thread_exit_lock &lt;span class=&quot;hljs-subst&quot;&gt;{self._parent_thread_exit_lock_released}&lt;/span&gt; &lt;span class=&quot;hljs-subst&quot;&gt;{_future}&lt;/span&gt;&quot;&lt;/span&gt;)\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; self._parent_thread_exit_lock_released:\n            self._parent_thread_exit_lock_released = &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n            self._parent_thread_exit_lock.release()\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;_child_daemon_thread_run&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n        self._workItem.run()\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;start&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; self._debug:\n            &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;f&quot;ExitThread.start &lt;span class=&quot;hljs-subst&quot;&gt;{self._started}&lt;/span&gt;&quot;&lt;/span&gt;)\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; self._started:\n            self._started = &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n            self._parent_thread.start()\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;exit&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; self._debug:\n            &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;f&quot;ExitThread.exit exited: &lt;span class=&quot;hljs-subst&quot;&gt;{self._exited}&lt;/span&gt; lock_released: &lt;span class=&quot;hljs-subst&quot;&gt;{self._parent_thread_exit_lock_released}&lt;/span&gt;&quot;&lt;/span&gt;)\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; self._parent_thread_exit_lock_released:\n            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; self._exited:\n            self._exited = &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; self.result_future.cancel():\n                &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; self.result_future.running():\n                    self.result_future.set_exception(concurrent.futures.CancelledError())\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;This seems to work with pywin32 on windows 7&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;my_thread = threading.Thread()\nmy_thread.start()\nmy_thread._Thread__stop()\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Pieter Hintjens -- one of the founders of the &lt;a href=&quot;http://zguide.zeromq.org/py:all&quot; rel=&quot;nofollow noreferrer&quot;&gt;ØMQ&lt;/a&gt;-project -- says, using ØMQ and avoiding synchronization primitives like locks, mutexes, events etc., is the sanest and securest way to write multi-threaded programs:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://zguide.zeromq.org/py:all#Multithreading-with-ZeroMQ&quot; rel=&quot;nofollow noreferrer&quot;&gt;http://zguide.zeromq.org/py:all#Multithreading-with-ZeroMQ&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;This includes telling a child thread, that it should cancel its work. This would be done by equipping the thread with a ØMQ-socket and polling on that socket for a message saying that it should cancel.&lt;/p&gt;\n\n&lt;p&gt;The link also provides an example on multi-threaded python code with ØMQ.&lt;/p&gt;\n    ","\n&lt;p&gt;An alternative is to use &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.pthread_kill&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;signal.pthread_kill&lt;/code&gt;&lt;/a&gt; to send a stop signal.&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; signal &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; pthread_kill, SIGTSTP\n&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; threading &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; Thread\n&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; itertools &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; count\n&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; time &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; sleep\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;target&lt;/span&gt;():\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; num &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; count():\n        &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(num)\n        sleep(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)\n\nthread = Thread(target=target)\nthread.start()\nsleep(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;)\npthread_kill(thread.ident, SIGTSTP)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;result&lt;/p&gt;\n&lt;pre class=&quot;lang-bash s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;0\n1\n2\n3\n4\n\n[14]+  Stopped\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;If you really need the ability to kill a sub-task, use an alternate implementation. &lt;code&gt;multiprocessing&lt;/code&gt; and &lt;code&gt;gevent&lt;/code&gt; both support indiscriminately killing a &quot;thread&quot;.&lt;/p&gt;\n\n&lt;p&gt;Python&apos;s threading does not support cancellation. Do not even try. Your code is very likely to deadlock, corrupt or leak memory, or have other unintended &quot;interesting&quot; hard-to-debug effects which happen rarely and nondeterministically.&lt;/p&gt;\n    ","\n&lt;p&gt;You can execute your command in a process and then kill it using the process id.\nI needed to sync between two thread one of which  doesnt return by itself.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;processIds = []\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;executeRecord&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;command&lt;/span&gt;):\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(command)\n\n    process = subprocess.Popen(command, stdout=subprocess.PIPE)\n    processIds.append(process.pid)\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(processIds[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;])\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;#Command that doesn&apos;t return by itself&lt;/span&gt;\n    process.stdout.read().decode(&lt;span class=&quot;hljs-string&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;)\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;;\n\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;recordThread&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;command, timeOut&lt;/span&gt;):\n\n    thread = Thread(target=executeRecord, args=(command,))\n    thread.start()\n    thread.join(timeOut)\n\n    os.kill(processIds.pop(), signal.SIGINT)\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;The most simple way is this:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; threading &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; Thread\n&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; time &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; sleep\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;do_something&lt;/span&gt;():\n    &lt;span class=&quot;hljs-keyword&quot;&gt;global&lt;/span&gt; thread_work\n    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; thread_work:\n        &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;doing something&apos;&lt;/span&gt;)\n        sleep(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;)\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Thread stopped&apos;&lt;/span&gt;)\n\nthread_work = &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\nThread(target=do_something).start()\nsleep(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;)\nthread_work = &lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;blockquote&gt;\n  &lt;p&gt;&lt;strong&gt;This is a bad answer, see the comments&lt;/strong&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Here&apos;s how to do it:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; threading &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; *\n\n...\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; thread &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;enumerate&lt;/span&gt;():\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; thread.isAlive():\n        &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;:\n            thread._Thread__stop()\n        &lt;span class=&quot;hljs-keyword&quot;&gt;except&lt;/span&gt;:\n            &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;str&lt;/span&gt;(thread.getName()) + &lt;span class=&quot;hljs-string&quot;&gt;&apos; could not be terminated&apos;&lt;/span&gt;))\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Give it a few seconds then your thread should be stopped. Check also the &lt;code&gt;thread._Thread__delete()&lt;/code&gt; method.&lt;/p&gt;\n\n&lt;p&gt;I&apos;d recommend a &lt;code&gt;thread.quit()&lt;/code&gt; method for convenience. For example if you have a socket in your thread, I&apos;d recommend creating a &lt;code&gt;quit()&lt;/code&gt; method in your socket-handle class, terminate the socket, then run a &lt;code&gt;thread._Thread__stop()&lt;/code&gt; inside of your &lt;code&gt;quit()&lt;/code&gt;.&lt;/p&gt;\n    "]},"randomTags":[{"name":"gcc","slug":"gcc"},{"name":"out-of-memory","slug":"out-of-memory"},{"name":"floating-point","slug":"floating-point"},{"name":"magic-methods","slug":"magic-methods"},{"name":"formatting","slug":"formatting"},{"name":"conditional-operator","slug":"conditional-operator"},{"name":"action","slug":"action"},{"name":"istream","slug":"istream"},{"name":"form-submit","slug":"form-submit"},{"name":"error-handling","slug":"error-handling"},{"name":"preg-match","slug":"preg-match"},{"name":"android-edittext","slug":"android-edittext"},{"name":"operators","slug":"operators"},{"name":"reshape","slug":"reshape"},{"name":"default-constructor","slug":"default-constructor"},{"name":"clearfix","slug":"clearfix"},{"name":"event-bubbling","slug":"event-bubbling"},{"name":"circular-dependency","slug":"circular-dependency"},{"name":"invoke","slug":"invoke"},{"name":"cannot-find-symbol","slug":"cannot-find-symbol"}]},"__N_SSG":true}