{"pageProps":{"data":{"count":1,"rows":[{"id":217,"title":"What is the canonical way to check for errors using the CUDA runtime API?","slug":"what-is-the-canonical-way-to-check-for-errors-using-the-cuda-runtime-api-1657387302698","postType":"QUESTION","createdAt":"2022-07-09T17:21:42.000Z","updatedAt":"2022-07-09T17:21:42.000Z","tags":[{"id":1496,"name":"cuda","slug":"cuda","createdAt":"2022-07-09T17:21:42.000Z","updatedAt":"2022-07-09T17:21:42.000Z","Questions_Tags":{"questionId":217,"tagId":1496}}]}]},"slug":"cuda","page":1,"answers":{"217":["\n&lt;p&gt;Probably the best way to check for errors in runtime API code is to define an assert style handler function and wrapper macro like this:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-scss&quot;&gt;&lt;span class=&quot;hljs-selector-id&quot;&gt;#define&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;gpuErrchk&lt;/span&gt;(ans) { &lt;span class=&quot;hljs-built_in&quot;&gt;gpuAssert&lt;/span&gt;((ans), __FILE__, __LINE__); }\ninline void &lt;span class=&quot;hljs-built_in&quot;&gt;gpuAssert&lt;/span&gt;(cudaError_t code, const char *file, int line, bool abort=true)\n{\n   if (code != cudaSuccess) \n   {\n      &lt;span class=&quot;hljs-built_in&quot;&gt;fprintf&lt;/span&gt;(stderr,&quot;GPUassert: %s %s %d\\n&quot;, cudaGetErrorString(code), file, line);\n      if (abort) &lt;span class=&quot;hljs-built_in&quot;&gt;exit&lt;/span&gt;(code);\n   }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You can then wrap each API call with the &lt;code&gt;gpuErrchk&lt;/code&gt; macro, which will process the return status of the API call it wraps, for example:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-lisp&quot;&gt;gpuErrchk( &lt;span class=&quot;hljs-name&quot;&gt;cudaMalloc&lt;/span&gt;(&lt;span class=&quot;hljs-name&quot;&gt;&amp;amp;a_d&lt;/span&gt;, size*sizeof(&lt;span class=&quot;hljs-name&quot;&gt;int&lt;/span&gt;)) )&lt;span class=&quot;hljs-comment&quot;&gt;;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;If there is an error in a call, a textual message describing the error and the file and line in your code where the error occurred will be emitted to &lt;code&gt;stderr&lt;/code&gt; and the application will exit. You could conceivably modify &lt;code&gt;gpuAssert&lt;/code&gt; to raise an exception rather than call &lt;code&gt;exit()&lt;/code&gt; in a more sophisticated application if it were required.&lt;/p&gt;\n\n&lt;p&gt;A second related question is how to check for errors in kernel launches, which can&apos;t be directly wrapped in a macro call like standard runtime API calls. For kernels, something like this:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-scss&quot;&gt;kernel&amp;lt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;(a);\n&lt;span class=&quot;hljs-built_in&quot;&gt;gpuErrchk&lt;/span&gt;( cudaPeekAtLastError() );\n&lt;span class=&quot;hljs-built_in&quot;&gt;gpuErrchk&lt;/span&gt;( cudaDeviceSynchronize() );\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;will firstly check for invalid launch argument, then force the host to wait until the kernel stops and checks for an execution error. The synchronisation can be eliminated if you have a subsequent blocking API call like this:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-scss&quot;&gt;kernel&amp;lt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;(a_d);\n&lt;span class=&quot;hljs-built_in&quot;&gt;gpuErrchk&lt;/span&gt;( cudaPeekAtLastError() );\n&lt;span class=&quot;hljs-built_in&quot;&gt;gpuErrchk&lt;/span&gt;( cudaMemcpy(a_h, a_d, size * sizeof(int), cudaMemcpyDeviceToHost) );\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;in which case the &lt;code&gt;cudaMemcpy&lt;/code&gt; call can return either errors which occurred during the kernel execution or those from the memory copy itself. This can be confusing for the beginner, and I would recommend using explicit synchronisation after a kernel launch during debugging to make it easier to understand where problems might be arising. &lt;/p&gt;\n\n&lt;p&gt;Note that when using &lt;a href=&quot;https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#cuda-dynamic-parallelism&quot; rel=&quot;noreferrer&quot;&gt;CUDA Dynamic Parallelism&lt;/a&gt;, a very similar methodology can and should be applied to any usage of the CUDA runtime API in device kernels, as well as after any device kernel launches:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;assert.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; cdpErrchk(ans) { cdpAssert((ans), __FILE__, __LINE__); }&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;__device__ &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;cdpAssert&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(cudaError_t code, &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *file, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; line, &lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; abort=&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;)&lt;/span&gt;\n&lt;/span&gt;{\n   &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (code != cudaSuccess)\n   {\n      &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;GPU kernel assert: %s %s %d\\n&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-built_in&quot;&gt;cudaGetErrorString&lt;/span&gt;(code), file, line);\n      &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (abort) &lt;span class=&quot;hljs-built_in&quot;&gt;assert&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);\n   }\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;talonmies&apos; answer above is a fine way to abort an application in an &lt;code&gt;assert&lt;/code&gt;-style manner.&lt;/p&gt;\n\n&lt;p&gt;Occasionally we may wish to report and recover from an error condition in a C++ context as part of a larger application.&lt;/p&gt;\n\n&lt;p&gt;Here&apos;s a reasonably terse way to do that by throwing a C++ exception derived from &lt;code&gt;std::runtime_error&lt;/code&gt; using &lt;code&gt;thrust::system_error&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;thrust/system_error.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;thrust/system/cuda/error.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;sstream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;throw_on_cuda_error&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(cudaError_t code, &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *file, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; line)&lt;/span&gt;\n&lt;/span&gt;{\n  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(code != cudaSuccess)\n  {\n    std::stringstream ss;\n    ss &amp;lt;&amp;lt; file &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;(&quot;&lt;/span&gt; &amp;lt;&amp;lt; line &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;)&quot;&lt;/span&gt;;\n    std::string file_and_line;\n    ss &amp;gt;&amp;gt; file_and_line;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;throw&lt;/span&gt; thrust::&lt;span class=&quot;hljs-built_in&quot;&gt;system_error&lt;/span&gt;(code, thrust::&lt;span class=&quot;hljs-built_in&quot;&gt;cuda_category&lt;/span&gt;(), file_and_line);\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This will incorporate the filename, line number, and an English language description of the &lt;code&gt;cudaError_t&lt;/code&gt; into the thrown exception&apos;s &lt;code&gt;.what()&lt;/code&gt; member:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;main&lt;/span&gt;()\n{\n  &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;\n  {\n    &lt;span class=&quot;hljs-comment&quot;&gt;// do something crazy&lt;/span&gt;\n    &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;throw_on_cuda_error&lt;/span&gt;(&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;cudaSetDevice&lt;/span&gt;(-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;), &lt;span class=&quot;hljs-keyword&quot;&gt;__FILE__&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;__LINE__&lt;/span&gt;);\n  }\n  &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt;(thrust::&lt;span class=&quot;hljs-variable constant_&quot;&gt;system_error&lt;/span&gt; &amp;amp;e)\n  {\n    std::&lt;span class=&quot;hljs-variable constant_&quot;&gt;cerr&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;CUDA error after cudaSetDevice: &quot;&lt;/span&gt; &amp;lt;&amp;lt; e.&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;what&lt;/span&gt;() &amp;lt;&amp;lt; std::&lt;span class=&quot;hljs-variable constant_&quot;&gt;endl&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// oops, recover&lt;/span&gt;\n    &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;cudaSetDevice&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);\n  }\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The output:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-ocaml&quot;&gt;$ nvcc &lt;span class=&quot;hljs-keyword&quot;&gt;exception&lt;/span&gt;.cu -run\n&lt;span class=&quot;hljs-type&quot;&gt;CUDA&lt;/span&gt; error after cudaSetDevice: &lt;span class=&quot;hljs-keyword&quot;&gt;exception&lt;/span&gt;.cu(&lt;span class=&quot;hljs-number&quot;&gt;23&lt;/span&gt;): invalid device ordinal\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;A client of &lt;code&gt;some_function&lt;/code&gt; can distinguish CUDA errors from other kinds of errors if desired:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;\n{\n  &lt;span class=&quot;hljs-comment&quot;&gt;// call some_function which may throw something&lt;/span&gt;\n  &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;some_function&lt;/span&gt;();\n}\n&lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt;(thrust::&lt;span class=&quot;hljs-variable constant_&quot;&gt;system_error&lt;/span&gt; &amp;amp;e)\n{\n  std::&lt;span class=&quot;hljs-variable constant_&quot;&gt;cerr&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;CUDA error during some_function: &quot;&lt;/span&gt; &amp;lt;&amp;lt; e.&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;what&lt;/span&gt;() &amp;lt;&amp;lt; std::&lt;span class=&quot;hljs-variable constant_&quot;&gt;endl&lt;/span&gt;;\n}\n&lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt;(std::&lt;span class=&quot;hljs-variable constant_&quot;&gt;bad_alloc&lt;/span&gt; &amp;amp;e)\n{\n  std::&lt;span class=&quot;hljs-variable constant_&quot;&gt;cerr&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Bad memory allocation during some_function: &quot;&lt;/span&gt; &amp;lt;&amp;lt; e.&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;what&lt;/span&gt;() &amp;lt;&amp;lt; std::&lt;span class=&quot;hljs-variable constant_&quot;&gt;endl&lt;/span&gt;;\n}\n&lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt;(std::&lt;span class=&quot;hljs-variable constant_&quot;&gt;runtime_error&lt;/span&gt; &amp;amp;e)\n{\n  std::&lt;span class=&quot;hljs-variable constant_&quot;&gt;cerr&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Runtime error during some_function: &quot;&lt;/span&gt; &amp;lt;&amp;lt; e.&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;what&lt;/span&gt;() &amp;lt;&amp;lt; std::&lt;span class=&quot;hljs-variable constant_&quot;&gt;endl&lt;/span&gt;;\n}\n&lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt;(...)\n{\n  std::&lt;span class=&quot;hljs-variable constant_&quot;&gt;cerr&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Some other kind of error during some_function&quot;&lt;/span&gt; &amp;lt;&amp;lt; std::&lt;span class=&quot;hljs-variable constant_&quot;&gt;endl&lt;/span&gt;;\n\n  &lt;span class=&quot;hljs-comment&quot;&gt;// no idea what to do, so just rethrow the exception&lt;/span&gt;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;throw&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Because &lt;code&gt;thrust::system_error&lt;/code&gt; is a &lt;code&gt;std::runtime_error&lt;/code&gt;, we can alternatively handle it in the same manner of a broad class of errors if we don&apos;t require the precision of the previous example:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;\n{\n  &lt;span class=&quot;hljs-comment&quot;&gt;// call some_function which may throw something&lt;/span&gt;\n  &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;some_function&lt;/span&gt;();\n}\n&lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt;(std::&lt;span class=&quot;hljs-variable constant_&quot;&gt;runtime_error&lt;/span&gt; &amp;amp;e)\n{\n  std::&lt;span class=&quot;hljs-variable constant_&quot;&gt;cerr&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Runtime error during some_function: &quot;&lt;/span&gt; &amp;lt;&amp;lt; e.&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;what&lt;/span&gt;() &amp;lt;&amp;lt; std::&lt;span class=&quot;hljs-variable constant_&quot;&gt;endl&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;h3&gt;The C++-canonical way: Don&apos;t check for errors...use the C++ bindings which throw exceptions.&lt;/h3&gt;\n&lt;p&gt;I used to be irked by this problem; and I used to have a macro-cum-wrapper-function solution just like in Talonmies and Jared&apos;s answers, but, honestly? It makes using the CUDA Runtime API even more ugly and C-like.&lt;/p&gt;\n&lt;p&gt;So I&apos;ve approached this in a different and more fundamental way. For a sample of the result, here&apos;s part of the CUDA &lt;code&gt;vectorAdd&lt;/code&gt; sample - with &lt;em&gt;complete&lt;/em&gt; error checking of every runtime API call:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-rust&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// (... prepare host-side buffers here ...)&lt;/span&gt;\n\nauto current_device = cuda::device::current::&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;get&lt;/span&gt;();\nauto d_A = cuda::memory::device::make_unique&amp;lt;float[]&amp;gt;(current_device, numElements);\nauto d_B = cuda::memory::device::make_unique&amp;lt;float[]&amp;gt;(current_device, numElements);\nauto d_C = cuda::memory::device::make_unique&amp;lt;float[]&amp;gt;(current_device, numElements);\n\ncuda::memory::&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;copy&lt;/span&gt;(d_A.&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;get&lt;/span&gt;(), h_A.&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;get&lt;/span&gt;(), size);\ncuda::memory::&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;copy&lt;/span&gt;(d_B.&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;get&lt;/span&gt;(), h_B.&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;get&lt;/span&gt;(), size);\n\nauto launch_config = cuda::&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;launch_config_builder&lt;/span&gt;()\n    .&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;overall_size&lt;/span&gt;(numElements)\n    .&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;block_size&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;256&lt;/span&gt;)\n    .&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;build&lt;/span&gt;();\n\ncuda::&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;launch&lt;/span&gt;(vectorAdd, launch_config,\n    d_A.&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;get&lt;/span&gt;(), d_B.&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;get&lt;/span&gt;(), d_C.&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;get&lt;/span&gt;(), numElements\n);    \ncuda::memory::&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;copy&lt;/span&gt;(h_C.&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;get&lt;/span&gt;(), d_C.&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;get&lt;/span&gt;(), size);\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// (... verify results here...)&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Again - all potential errors are checked , and an exception if an error occurred (caveat: If the kernel caused some error &lt;em&gt;after&lt;/em&gt; launch, it will be caught after the attempt to copy the result, not before; to ensure the kernel was successful you would need to check for error between the launch and the copy with a &lt;code&gt;cuda::outstanding_error::ensure_none()&lt;/code&gt; command).&lt;/p&gt;\n&lt;p&gt;The code above uses my&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://github.com/eyalroz/cuda-api-wrappers&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;strong&gt;Thin Modern-C++ wrappers for the CUDA Runtime API library&lt;/strong&gt;&lt;/a&gt; (Github)&lt;/p&gt;\n&lt;p&gt;Note that the exceptions carry both a string explanation and the CUDA runtime API status code after the failing call.&lt;/p&gt;\n&lt;p&gt;A few links to how CUDA errors are automagically checked with these wrappers:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;https://github.com/eyalroz/cuda-api-wrappers/blob/master/examples/by_runtime_api_module/error_handling.cu&quot; rel=&quot;nofollow noreferrer&quot;&gt;A test program throwing and catching a bunch of exceptions&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://codedocs.xyz/eyalroz/cuda-api-wrappers/error_8hpp.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Documentation for the error-related functionality&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;The solution discussed &lt;a href=&quot;https://code.google.com/p/stanford-cs193g-sp2010/wiki/TutorialWhenSomethingGoesWrong&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt; worked well for me. This solution uses built-in cuda functions and is very simple to implement.&lt;/p&gt;\n\n&lt;p&gt;The relevant code is copied below:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;__global__ &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *ptr)&lt;/span&gt;\n&lt;/span&gt;{\n  *ptr = &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;;\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;\n&lt;/span&gt;{\n  foo&amp;lt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);\n\n  &lt;span class=&quot;hljs-comment&quot;&gt;// make the host block until the device is finished with foo&lt;/span&gt;\n  &lt;span class=&quot;hljs-built_in&quot;&gt;cudaDeviceSynchronize&lt;/span&gt;();\n\n  &lt;span class=&quot;hljs-comment&quot;&gt;// check for error&lt;/span&gt;\n  cudaError_t error = &lt;span class=&quot;hljs-built_in&quot;&gt;cudaGetLastError&lt;/span&gt;();\n  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(error != cudaSuccess)\n  {\n    &lt;span class=&quot;hljs-comment&quot;&gt;// print the CUDA error message and exit&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;CUDA error: %s\\n&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-built_in&quot;&gt;cudaGetErrorString&lt;/span&gt;(error));\n    &lt;span class=&quot;hljs-built_in&quot;&gt;exit&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;);\n  }\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    "]},"randomTags":[{"name":"excel-formula","slug":"excel-formula"},{"name":"dst","slug":"dst"},{"name":"iec10967","slug":"iec10967"},{"name":"apache","slug":"apache"},{"name":"z-index","slug":"z-index"},{"name":"c++-faq","slug":"c++-faq"},{"name":"model","slug":"model"},{"name":"abi","slug":"abi"},{"name":"ranking","slug":"ranking"},{"name":"mutable","slug":"mutable"},{"name":"instantiation","slug":"instantiation"},{"name":"commandlink","slug":"commandlink"},{"name":"pythonpath","slug":"pythonpath"},{"name":"string-aggregation","slug":"string-aggregation"},{"name":"git-rewrite-history","slug":"git-rewrite-history"},{"name":"sharedpreferences","slug":"sharedpreferences"},{"name":"w3c","slug":"w3c"},{"name":"blob","slug":"blob"},{"name":"naming-conventions","slug":"naming-conventions"},{"name":"public","slug":"public"}]},"__N_SSG":true}