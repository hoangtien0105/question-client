{"pageProps":{"data":{"count":1,"rows":[{"id":534,"title":"Alternatives to gprof [closed]","slug":"alternatives-to-gprof-closed-1657388336554","postType":"QUESTION","createdAt":"2022-07-09T17:38:56.000Z","updatedAt":"2022-07-09T17:38:56.000Z","tags":[{"id":2620,"name":"gprof","slug":"gprof","createdAt":"2022-07-09T17:38:56.000Z","updatedAt":"2022-07-09T17:38:56.000Z","Questions_Tags":{"questionId":534,"tagId":2620}}]}]},"slug":"gprof","page":"1","answers":{"534":["\n&lt;p&gt;&lt;strong&gt;gprof&lt;/strong&gt; &lt;a href=&quot;http://docs.freebsd.org/44doc/psd/18.gprof/paper.pdf&quot; rel=&quot;noreferrer&quot;&gt;(read the paper)&lt;/a&gt; exists for historical reasons. \nIf you think it will help you find performance problems, it was never advertised as such.\nHere&apos;s what the paper says:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;The prole can be used to compare and assess the costs of\n  various implementations.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;It does not say it can be used to &lt;em&gt;identify&lt;/em&gt; the various implementations to be assessed, although it does &lt;em&gt;imply&lt;/em&gt; that it could, under special circumstances:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;especially if small portions of the program are found to dominate its\n  execution time.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;What about problems that are not so localized?\nDo those not matter?\nDon&apos;t place expectations on &lt;strong&gt;gprof&lt;/strong&gt; that were never claimed for it.\nIt is &lt;em&gt;only&lt;/em&gt; a measurement tool, and only of CPU-bound operations.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/375913/what-can-i-use-to-profile-c-code-in-linux/378024#378024&quot;&gt;Try this instead.&lt;/a&gt;&lt;br&gt;\n&lt;a href=&quot;https://stackoverflow.com/questions/926266/performance-optimization-strategies-of-last-resort/927773#927773&quot;&gt;Here&apos;s an example of a 44x speedup.&lt;/a&gt;&lt;br&gt;\n&lt;a href=&quot;https://scicomp.stackexchange.com/a/1870/1262&quot;&gt;Here&apos;s a 730x speedup.&lt;/a&gt;&lt;br&gt;\n&lt;a href=&quot;http://youtu.be/xPg3sRpdW1U&quot; rel=&quot;noreferrer&quot;&gt;Here&apos;s an 8-minute video demonstration.&lt;/a&gt;&lt;br&gt;\n&lt;a href=&quot;https://scicomp.stackexchange.com/a/2719/1262&quot;&gt;Here&apos;s an explanation of the statistics.&lt;/a&gt;&lt;br&gt;\n&lt;a href=&quot;https://stackoverflow.com/a/18217639/23771&quot;&gt;Here&apos;s an answer to critiques.&lt;/a&gt;  &lt;/p&gt;\n\n&lt;p&gt;There&apos;s a simple observation about programs. In a given execution, every instruction is responsible for some fraction of the overall time (especially &lt;code&gt;call&lt;/code&gt; instructions), in the sense that if it were not there, the time would not be spent. During that time, the instruction is on the stack **. When that is understood, you can see that -  &lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;gprof&lt;/strong&gt; embodies certain myths about performance, such as:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;&lt;em&gt;that program counter sampling is useful.&lt;/em&gt;&lt;br&gt;\nIt is only useful if you have an unnecessary hotspot bottleneck such as a bubble sort of a big array of scalar values. As soon as you, for example, change it into a sort using string-compare, it is still a bottleneck, but program counter sampling will not see it because now the hotspot is in string-compare. On the other hand if it were to sample the &lt;strong&gt;extended&lt;/strong&gt; program counter (the call stack), the point at which the string-compare is called, the sort loop, is clearly displayed. &lt;em&gt;In fact, &lt;strong&gt;gprof&lt;/strong&gt; was an attempt to remedy the limitations of pc-only sampling.&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;em&gt;that timing functions is more important than capturing time-consuming lines of code.&lt;/em&gt;&lt;br&gt;\nThe reason for that myth is that &lt;strong&gt;gprof&lt;/strong&gt; was not able to capture stack samples, so instead it times functions, counts their invocations, and tries to capture the call graph. However, once a costly function is identified, you still need to look inside it for the lines that are responsible for the time. If there were stack samples you would not need to look, those lines would be on the samples. (A typical function might have 100 - 1000 instructions. A function &lt;em&gt;call&lt;/em&gt; is 1 instruction, so something that locates costly calls is 2-3 orders of magnitude more precise.)&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;em&gt;that the call graph is important.&lt;/em&gt;&lt;br&gt;\nWhat you need to know about a program is not &lt;strong&gt;where&lt;/strong&gt; it spends its time, but &lt;strong&gt;why&lt;/strong&gt;. When it is spending time in a function, every line of code on the stack gives one link in the chain of reasoning of why it is there. If you can only see part of the stack, you can only see part of the reason why, so you can&apos;t tell for sure if that time is actually necessary.\nWhat does the call graph tell you? Each arc tells you that some function A was in the process of calling some function B for some fraction of the time. Even if A has only one such line of code calling B, that line only gives a small part of the reason why. If you are lucky enough, maybe that line has a poor reason. Usually, you need to see multiple simultaneous lines to find a poor reason if it is there. If A calls B in more than one place, then it tells you even less.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;em&gt;that recursion is a tricky confusing issue.&lt;/em&gt;&lt;br&gt;\nThat is only because &lt;strong&gt;gprof&lt;/strong&gt; and other profilers perceive a need to generate a call-graph and then attribute times to the nodes. If one has samples of the stack, the time-cost of each line of code that appears on samples is a very simple number - the fraction of samples it is on. If there is recursion, then a given line can appear more than once on a sample. \n&lt;em&gt;No matter.&lt;/em&gt; Suppose samples are taken every N ms, and the line appears on F% of them (singly or not). If that line can be made to take no time (such as by deleting it or branching around it), then those samples would &lt;em&gt;disappear&lt;/em&gt;, and the time would be reduced by F%.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;em&gt;that accuracy of time measurement (and therefore a large number of samples) is important.&lt;/em&gt;&lt;br&gt;\nThink about it for a second. If a line of code is on 3 samples out of five, then if you could shoot it out like a light bulb, that is roughly 60% less time that would be used. Now, you know that if you had taken a different 5 samples, you might have only seen it 2 times, or as many as 4. So that 60% measurement is more like a general range from 40% to 80%. If it were only 40%, would you say the problem is not worth fixing? So what&apos;s the point of time accuracy, when what you really want is to &lt;strong&gt;find the problems&lt;/strong&gt;?\n500 or 5000 samples would have measured the problem with greater precision, but would not have found it any more accurately.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;em&gt;that counting of statement or function invocations is useful.&lt;/em&gt;&lt;br&gt;\nSuppose you know a function has been called 1000 times. Can you tell from that what fraction of time it costs? You also need to know how long it takes to run, on average, multiply it by the count, and divide by the total time. The average invocation time could vary from nanoseconds to seconds, so the count alone doesn&apos;t tell much. If there are stack samples, the cost of a routine or of any statement is just the fraction of samples it is on. That fraction of time is what could in principle be saved overall if the routine or statement could be made to take no time, so that is what has the most direct relationship to performance.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;em&gt;that samples need not be taken when blocked&lt;/em&gt;&lt;br&gt;\nThe reasons for this myth are twofold: 1) that PC sampling is meaningless when the program is waiting, and 2) the preoccupation with accuracy of timing. However, for (1) the program may very well be waiting for something that it asked for, such as file I/O, which you &lt;em&gt;need to know&lt;/em&gt;, and which stack samples reveal. (Obviously you want to exclude samples while waiting for user input.) For (2) if the program is waiting simply because of competition with other processes, that presumably happens in a fairly random way while it&apos;s running.\nSo while the program may be taking longer, that will not have a large effect on the statistic that matters, the percentage of time that statements are on the stack.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;em&gt;that &quot;self time&quot; matters&lt;/em&gt;&lt;br&gt;\nSelf time only makes sense if you are measuring at the function level, not line level, and you think you need help in discerning if the function time goes into purely local computation versus in called routines. If summarizing at the line level, a line represents self time if it is at the end of the stack, otherwise it represents inclusive time. Either way, what it costs is the percentage of stack samples it is on, so that locates it for you in either case.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;em&gt;that samples have to be taken at high frequency&lt;/em&gt;&lt;br&gt;\nThis comes from the idea that a performance problem may be fast-acting, and that samples have to be frequent in order to hit it. But, if the problem is costing, 20%, say, out of a total running time of 10 sec (or whatever), then each sample in that total time will have a 20% chance of hitting it, no matter if the problem occurs in a single piece like this&lt;br&gt;\n&lt;code&gt;.....XXXXXXXX...........................&lt;/code&gt;&lt;br&gt;\n&lt;code&gt;.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^&lt;/code&gt; (20 samples, 4 hits)&lt;br&gt;\nor in many small pieces like this&lt;br&gt;\n&lt;code&gt;X...X...X.X..X.........X.....X....X.....&lt;/code&gt;&lt;br&gt;\n&lt;code&gt;.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^&lt;/code&gt; (20 samples, 3 hits)&lt;br&gt;\nEither way, the number of hits will average about 1 in 5, no matter how many samples are taken, or how few. (Average = 20 * 0.2 = 4. Standard deviation = +/- sqrt(20 * 0.2 * 0.8) = 1.8.)&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;em&gt;that you are trying to find &lt;strong&gt;the&lt;/strong&gt; bottleneck&lt;/em&gt;&lt;br&gt;\nas if there were only one. Consider the following execution timeline: &lt;code&gt;vxvWvzvWvxvWvYvWvxvWv.vWvxvWvYvW&lt;/code&gt;&lt;br&gt;\nIt consists of real useful work, represented by &lt;code&gt;.&lt;/code&gt;. There are performance problems &lt;code&gt;vWxYz&lt;/code&gt; taking 1/2, 1/4, 1/8, 1/16, 1/32 of the time, respectively. Sampling finds &lt;code&gt;v&lt;/code&gt; easily. It is removed, leaving&lt;br&gt;\n&lt;code&gt;xWzWxWYWxW.WxWYW&lt;/code&gt;&lt;br&gt;\nNow the program takes half as long to run, and now &lt;code&gt;W&lt;/code&gt; takes half the time, and is found easily. It is removed, leaving&lt;br&gt;\n&lt;code&gt;xzxYx.xY&lt;/code&gt;&lt;br&gt;\nThis process continues, each time removing the biggest, by percentage, performance problem, until nothing to remove can be found. Now the only thing executed is &lt;code&gt;.&lt;/code&gt;, which executes in 1/32 of the time used by the original program. This is the &lt;em&gt;magnification effect&lt;/em&gt;, by which removing any problem makes the remainder larger, by percent, because the denominator is reduced.&lt;br&gt;\nAnother crucial point is that &lt;em&gt;every single problem must be found&lt;/em&gt; - missing none of the 5. Any problem not found and fixed severely reduces the final speedup ratio. Just finding some, but not all, is not &quot;good enough&quot;.&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;ADDED: I would just like to point out one reason why &lt;em&gt;gprof&lt;/em&gt; is popular - it is being taught,\npresumably because it&apos;s free, easy to teach, and it&apos;s been around a long time.\nA quick Google search locates some academic institutions that teach it (or appear to):&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;berkeley bu clemson\n  colorado duke earlham fsu indiana mit msu\n  ncsa.illinois ncsu nyu ou princeton psu\n  stanford ucsd umd umich utah utexas utk wustl&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;** With the exception of other ways of requesting work to be done, that don&apos;t leave a trace telling &lt;em&gt;why&lt;/em&gt;, such as by message posting.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Valgrind&quot; rel=&quot;noreferrer&quot;&gt;Valgrind&lt;/a&gt; has an instruction-count profiler with a very nice visualizer called &lt;a href=&quot;http://en.wikipedia.org/wiki/Valgrind#Tools&quot; rel=&quot;noreferrer&quot;&gt;KCacheGrind&lt;/a&gt;.  As Mike Dunlavey recommends, Valgrind counts the fraction of instructions for which a procedure is live on the stack, although I&apos;m sorry to say it appears to become confused in the presence of mutual recursion.  But the visualizer is very nice and light years ahead of &lt;code&gt;gprof&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;Since I did&apos;t see here anything about &lt;strong&gt;&lt;code&gt;perf&lt;/code&gt;&lt;/strong&gt; which is a relatively new tool for profiling the kernel and user applications on Linux I decided to add this information.&lt;/p&gt;\n\n&lt;p&gt;First of all - this is a tutorial about &lt;a href=&quot;https://perf.wiki.kernel.org/index.php/Tutorial&quot; rel=&quot;noreferrer&quot;&gt;Linux profiling with &lt;code&gt;perf&lt;/code&gt; &lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;You can use &lt;code&gt;perf&lt;/code&gt; if your Linux Kernel is greater than 2.6.32 or &lt;code&gt;oprofile&lt;/code&gt; if it is older. Both programs don&apos;t require from you to instrument your program (like &lt;code&gt;gprof&lt;/code&gt; requires). However in order to get call graph correctly in &lt;code&gt;perf&lt;/code&gt; you need to build you program with &lt;code&gt;-fno-omit-frame-pointer&lt;/code&gt;. For example: &lt;code&gt;g++ -fno-omit-frame-pointer -O2 main.cpp&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;You can see &quot;live&quot; analysis of your application with &lt;code&gt;perf top&lt;/code&gt;: &lt;br&gt;&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;sudo perf top -p `pidof a.out` -K\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Or you can record performance data of a running application and analyze them after that:&lt;/p&gt;\n\n&lt;p&gt;1) To record performance data:&lt;br&gt;&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;perf record -p `pidof a.out`\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or  to record for 10 secs:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;perf record -p `pidof a.out` sleep 10\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or to record with call graph ()&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;perf record -g -p `pidof a.out` \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;2) To analyze the recorded data&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;perf report --stdio\nperf report --stdio --sort=dso -g none\nperf report --stdio -g none\nperf report --stdio -g\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Or you can record performace data of a application and analyze them after that just by launching the application in this way and waiting for it to exit:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;perf record ./a.out\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;This is an example of profiling a test program&lt;/strong&gt; &lt;/p&gt;\n\n&lt;p&gt;The test program is in file main.cpp (I will put main.cpp at the bottom of the message):&lt;/p&gt;\n\n&lt;p&gt;I compile it in this way:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;g++ -m64 -fno-omit-frame-pointer -g main.cpp -L.  -ltcmalloc_minimal -o my_test\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I use &lt;code&gt;libmalloc_minimial.so&lt;/code&gt; since it is compiled with &lt;code&gt;-fno-omit-frame-pointer&lt;/code&gt; while libc malloc seems to be compiled without this option.\nThen I run my test program&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;./my_test 100000000 \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Then I record performance data of a running process:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;perf record -g  -p `pidof my_test` -o ./my_test.perf.data sleep 30\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Then I analyze load per module:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;perf report --stdio  -g none --sort comm,dso  -i ./my_test.perf.data&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;pre&gt;&lt;code&gt;# Overhead  Command                 Shared Object\n# ........  .......  ............................\n#\n    70.06%  my_test  my_test\n    28.33%  my_test  libtcmalloc_minimal.so.0.1.0\n     1.61%  my_test  [kernel.kallsyms]\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Then load per function is analyzed:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;perf report --stdio  -g none  -i ./my_test.perf.data | c++filt&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;pre&gt;&lt;code&gt;# Overhead  Command                 Shared Object                       Symbol\n# ........  .......  ............................  ...........................\n#\n    29.30%  my_test  my_test                       [.] f2(long)\n    29.14%  my_test  my_test                       [.] f1(long)\n    15.17%  my_test  libtcmalloc_minimal.so.0.1.0  [.] operator new(unsigned long)\n    13.16%  my_test  libtcmalloc_minimal.so.0.1.0  [.] operator delete(void*)\n     9.44%  my_test  my_test                       [.] process_request(long)\n     1.01%  my_test  my_test                       [.] operator delete(void*)@plt\n     0.97%  my_test  my_test                       [.] operator new(unsigned long)@plt\n     0.20%  my_test  my_test                       [.] main\n     0.19%  my_test  [kernel.kallsyms]             [k] apic_timer_interrupt\n     0.16%  my_test  [kernel.kallsyms]             [k] _spin_lock\n     0.13%  my_test  [kernel.kallsyms]             [k] native_write_msr_safe\n\n     and so on ...\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Then call chains are analyzed:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;perf report --stdio  -g graph  -i ./my_test.perf.data | c++filt&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;pre&gt;&lt;code&gt;# Overhead  Command                 Shared Object                       Symbol\n# ........  .......  ............................  ...........................\n#\n    29.30%  my_test  my_test                       [.] f2(long)\n            |\n            --- f2(long)\n               |\n                --29.01%-- process_request(long)\n                          main\n                          __libc_start_main\n\n    29.14%  my_test  my_test                       [.] f1(long)\n            |\n            --- f1(long)\n               |\n               |--15.05%-- process_request(long)\n               |          main\n               |          __libc_start_main\n               |\n                --13.79%-- f2(long)\n                          process_request(long)\n                          main\n                          __libc_start_main\n\n    15.17%  my_test  libtcmalloc_minimal.so.0.1.0  [.] operator new(unsigned long)\n            |\n            --- operator new(unsigned long)\n               |\n               |--11.44%-- f1(long)\n               |          |\n               |          |--5.75%-- process_request(long)\n               |          |          main\n               |          |          __libc_start_main\n               |          |\n               |           --5.69%-- f2(long)\n               |                     process_request(long)\n               |                     main\n               |                     __libc_start_main\n               |\n                --3.01%-- process_request(long)\n                          main\n                          __libc_start_main\n\n    13.16%  my_test  libtcmalloc_minimal.so.0.1.0  [.] operator delete(void*)\n            |\n            --- operator delete(void*)\n               |\n               |--9.13%-- f1(long)\n               |          |\n               |          |--4.63%-- f2(long)\n               |          |          process_request(long)\n               |          |          main\n               |          |          __libc_start_main\n               |          |\n               |           --4.51%-- process_request(long)\n               |                     main\n               |                     __libc_start_main\n               |\n               |--3.05%-- process_request(long)\n               |          main\n               |          __libc_start_main\n               |\n                --0.80%-- f2(long)\n                          process_request(long)\n                          main\n                          __libc_start_main\n\n     9.44%  my_test  my_test                       [.] process_request(long)\n            |\n            --- process_request(long)\n               |\n                --9.39%-- main\n                          __libc_start_main\n\n     1.01%  my_test  my_test                       [.] operator delete(void*)@plt\n            |\n            --- operator delete(void*)@plt\n\n     0.97%  my_test  my_test                       [.] operator new(unsigned long)@plt\n            |\n            --- operator new(unsigned long)@plt\n\n     0.20%  my_test  my_test                       [.] main\n     0.19%  my_test  [kernel.kallsyms]             [k] apic_timer_interrupt\n     0.16%  my_test  [kernel.kallsyms]             [k] _spin_lock\n     and so on ...\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So at this point you know where your program spends time.&lt;/p&gt;\n\n&lt;p&gt;And this is main.cpp for the test:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;\n#include &amp;lt;stdlib.h&amp;gt;\n#include &amp;lt;time.h&amp;gt;\n\ntime_t f1(time_t time_value)\n{\n  for (int j =0; j &amp;lt; 10; ++j) {\n    ++time_value;\n    if (j%5 == 0) {\n      double *p = new double;\n      delete p;\n    }\n  }\n  return time_value;\n}\n\ntime_t f2(time_t time_value)\n{\n  for (int j =0; j &amp;lt; 40; ++j) {\n    ++time_value;\n  }\n  time_value=f1(time_value);\n  return time_value;\n}\n\ntime_t process_request(time_t time_value)\n{\n\n  for (int j =0; j &amp;lt; 10; ++j) {\n    int *p = new int;\n    delete p;\n    for (int m =0; m &amp;lt; 10; ++m) {\n      ++time_value;\n    }\n  }\n  for (int i =0; i &amp;lt; 10; ++i) {\n    time_value=f1(time_value);\n    time_value=f2(time_value);\n  }\n  return time_value;\n}\n\nint main(int argc, char* argv2[])\n{\n  int number_loops = argc &amp;gt; 1 ? atoi(argv2[1]) : 1;\n  time_t time_value = time(0);\n  printf(&quot;number loops %d\\n&quot;, number_loops);\n  printf(&quot;time_value: %d\\n&quot;, time_value );\n\n  for (int i =0; i &amp;lt; number_loops; ++i) {\n    time_value = process_request(time_value);\n  }\n  printf(&quot;time_value: %ld\\n&quot;, time_value );\n  return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Try &lt;a href=&quot;http://oprofile.sourceforge.net/about/&quot; rel=&quot;noreferrer&quot;&gt;OProfile&lt;/a&gt;. It is a much better tool for profiling your code. I would also suggest Intel &lt;a href=&quot;http://en.wikipedia.org/wiki/VTune&quot; rel=&quot;noreferrer&quot;&gt;VTune&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;The two tools above can narrow down time spent in a particular line of code, annotate your code, show assembly and how much particular instruction takes.  Beside time metric, you can also query specific counters, i.e. cache hits, etc.&lt;/p&gt;\n\n&lt;p&gt;Unlike gprof, you can profile any process/binary running on your system using either of the two.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;a href=&quot;http://code.google.com/p/google-perftools/&quot;&gt;Google performance tools&lt;/a&gt; include a simple to use profiler. CPU as well as heap profiler is available.&lt;/p&gt;\n    ","\n&lt;p&gt;Take a look at &lt;a href=&quot;http://sysprof.com/&quot; rel=&quot;noreferrer&quot;&gt;Sysprof&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;Your distribution may have it already.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;a href=&quot;http://lttng.org/&quot; rel=&quot;nofollow&quot;&gt;http://lttng.org/&lt;/a&gt; if you want a high performance tracer&lt;/p&gt;\n    "]},"randomTags":[{"name":"readlines","slug":"readlines"},{"name":"instance-variables","slug":"instance-variables"},{"name":"sqlexception","slug":"sqlexception"},{"name":"pseudo-element","slug":"pseudo-element"},{"name":"listener","slug":"listener"},{"name":"arrays","slug":"arrays"},{"name":"html-parsing","slug":"html-parsing"},{"name":"android-networking","slug":"android-networking"},{"name":"events","slug":"events"},{"name":"subprocess","slug":"subprocess"},{"name":"python-2.x","slug":"python-2.x"},{"name":"arraylist","slug":"arraylist"},{"name":"optimization","slug":"optimization"},{"name":"dom","slug":"dom"},{"name":"timezone","slug":"timezone"},{"name":"equality-operator","slug":"equality-operator"},{"name":"python-2.7","slug":"python-2.7"},{"name":"java.util.scanner","slug":"java.util.scanner"},{"name":"pointers","slug":"pointers"},{"name":"fetch-api","slug":"fetch-api"}]},"__N_SSG":true}