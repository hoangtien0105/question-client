{"pageProps":{"data":{"count":1,"rows":[{"id":518,"title":"What does the comma operator , do?","slug":"what-does-the-comma-operator-do-1657388258021","postType":"QUESTION","createdAt":"2022-07-09T17:37:38.000Z","updatedAt":"2022-07-09T17:37:38.000Z","tags":[{"id":2563,"name":"comma-operator","slug":"comma-operator","createdAt":"2022-07-09T17:37:38.000Z","updatedAt":"2022-07-09T17:37:38.000Z","Questions_Tags":{"questionId":518,"tagId":2563}}]}]},"slug":"comma-operator","page":"1","answers":{"518":["\n&lt;p&gt;The expression:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;(expression1,  expression2)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;First &lt;code&gt;expression1&lt;/code&gt; is evaluated, then &lt;code&gt;expression2&lt;/code&gt; is evaluated, and the value of &lt;code&gt;expression2&lt;/code&gt; is returned for the whole expression.&lt;/p&gt;\n    ","\n&lt;p&gt;I&apos;ve seen used most in &lt;code&gt;while&lt;/code&gt; loops:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; s;\n&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(read_string(s), s.len() &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;)\n{\n   &lt;span class=&quot;hljs-comment&quot;&gt;//do something&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It will do the operation, then do a test based on a side-effect. The other way would be to do it like this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; s;\nread_string(s);\n&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(s.len() &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;)\n{\n   &lt;span class=&quot;hljs-comment&quot;&gt;//do something&lt;/span&gt;\n   read_string(s);\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Comma_operator&quot; rel=&quot;noreferrer&quot;&gt;comma operator&lt;/a&gt; will evaluate the left operand, discard the result and then evaluate the right operand and that will be the result. The &lt;em&gt;idiomatic&lt;/em&gt; use as noted in the link is when initializing the variables used in a &lt;code&gt;for&lt;/code&gt; loop, and it gives the following example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;rev&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *s, &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; len)&lt;/span&gt;\n{\n  &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *first;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; ( first = s, s += len - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; s &amp;gt;= first; --s)\n      &lt;span class=&quot;hljs-comment&quot;&gt;/*^^^^^^^^^^^^^^^^^^^^^^^*/&lt;/span&gt; \n      &lt;span class=&quot;hljs-built_in&quot;&gt;putchar&lt;/span&gt;(*s);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Otherwise there are not many &lt;em&gt;great&lt;/em&gt; uses of the &lt;em&gt;comma operator&lt;/em&gt;, although it is easy to abuse to generate code that is hard to read and maintain.&lt;/p&gt;\n\n&lt;p&gt;From the &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&quot; rel=&quot;noreferrer&quot;&gt;draft C99 standard&lt;/a&gt; the grammar is as follows:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;expression:\n  assignment-expression\n  expression , assignment-expression\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and &lt;em&gt;paragraph 2&lt;/em&gt; says:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;The &lt;strong&gt;left operand of a comma operator is evaluated as a void expression;&lt;/strong&gt; there is a sequence point after its evaluation. Then the &lt;strong&gt;right operand is evaluated; the result has its type and value.&lt;/strong&gt; &lt;sup&gt;97)&lt;/sup&gt; If an attempt is made to modify the result of a comma operator or to access it after the next sequence point, the behavior is undefined.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;&lt;em&gt;Footnote 97&lt;/em&gt; says:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;A comma operator does &lt;strong&gt;not yield an lvalue&lt;/strong&gt;.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;which means you can not assign to the result of the &lt;em&gt;comma operator&lt;/em&gt;.&lt;/p&gt;\n\n&lt;p&gt;It is important to note that the comma operator has the &lt;a href=&quot;https://en.cppreference.com/w/c/language/operator_precedence&quot; rel=&quot;noreferrer&quot;&gt;lowest precedence&lt;/a&gt; and therefore there are cases where using &lt;code&gt;()&lt;/code&gt; can make a big difference, for example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x, y ;\n\n    x = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; ;\n    y = (&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;) ;\n\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;( &lt;span class=&quot;hljs-string&quot;&gt;&quot;%d %d\\n&quot;&lt;/span&gt;, x, y ) ;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;will have the following output:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;The comma operator combines the two expressions either side of it into one, evaluating them both in left-to-right order.  The value of the right-hand side is returned as the value of the whole expression.\n &lt;code&gt;(expr1, expr2)&lt;/code&gt; is like &lt;code&gt;{ expr1; expr2; }&lt;/code&gt; but you can use the result of &lt;code&gt;expr2&lt;/code&gt; in a function call or assignment.&lt;/p&gt;\n\n&lt;p&gt;It is often seen in &lt;code&gt;for&lt;/code&gt; loops to initialise or maintain multiple variables like this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (low = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, high = MAXSIZE; low &amp;lt; high; low = newlow, high = newhigh)\n{\n    &lt;span class=&quot;hljs-comment&quot;&gt;/* do something with low and high and put new values\n       in newlow and newhigh */&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Apart from this, I&apos;ve only used it &quot;in anger&quot; in one other case, when wrapping up two operations that should always go together in a macro.  We had code that copied various binary values into a byte buffer for sending on a network, and a pointer maintained where we had got up to:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; outbuff[BUFFSIZE];\n&lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *ptr = outbuff;\n\n*ptr++ = first_byte_value;\n*ptr++ = second_byte_value;\n\nsend_buff(outbuff, (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;)(ptr - outbuff));\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Where the values were &lt;code&gt;short&lt;/code&gt;s or &lt;code&gt;int&lt;/code&gt;s we did this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;*((&lt;span class=&quot;hljs-type&quot;&gt;short&lt;/span&gt; *)ptr)++ = short_value;\n*((&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *)ptr)++ = int_value;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Later we read that this was not really valid C, because &lt;code&gt;(short *)ptr&lt;/code&gt; is no longer an l-value and can&apos;t be incremented, although our compiler at the time didn&apos;t mind.  To fix this, we split the expression in two:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;*(&lt;span class=&quot;hljs-type&quot;&gt;short&lt;/span&gt; *)ptr = short_value;\nptr += &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;short&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;However, this approach relied on all developers remembering to put both statements in all the time.  We wanted a function where you could pass in the output pointer, the value and and the value&apos;s type.  This being C, not C++ with templates, we couldn&apos;t have a function take an arbitrary type, so we settled on a macro:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; ASSIGN_INCR(p, val, type)  ((*((type) *)(p) = (val)), (p) += sizeof(type))&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;By using the comma operator we were able to use this in expressions or as statements as we wished:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (need_to_output_short)\n    ASSIGN_INCR(ptr, short_value, &lt;span class=&quot;hljs-type&quot;&gt;short&lt;/span&gt;);\n\nlatest_pos = ASSIGN_INCR(ptr, int_value, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;);\n\nsend_buff(outbuff, (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;)(ASSIGN_INCR(ptr, last_value, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;) - outbuff));\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I&apos;m not suggesting any of these examples are good style!  Indeed, I seem to remember Steve McConnell&apos;s &lt;em&gt;Code Complete&lt;/em&gt; advising against even using comma operators in a &lt;code&gt;for&lt;/code&gt; loop: for readability and maintainability, the loop should be controlled by only one variable, and the expressions in the &lt;code&gt;for&lt;/code&gt; line itself should only contain loop-control code, not other extra bits of initialisation or loop maintenance.&lt;/p&gt;\n    ","\n&lt;p&gt;It causes the evaluation of multiple statements, but uses only the last one as a resulting value (rvalue, I think).&lt;/p&gt;\n\n&lt;p&gt;So...&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;; }\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;; }\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x = (&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;assigning x&quot;&lt;/span&gt;), f(), g() );\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;should result in x being set to 8.&lt;/p&gt;\n    ","\n&lt;p&gt;As earlier answers have stated it evaluates all statements but uses the last one as the value of the expression. Personally I&apos;ve only found it useful in loop expressions:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (tmp=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, i = MAX; i &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i--)\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;The only place I&apos;ve seen it being useful is when you write a funky loop where you want to do multiple things in one of the expressions (probably the init expression or loop expression. Something like:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;arraysAreMirrored&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a1[], &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a2[], &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; size)&lt;/span&gt;\n{\n  &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; i1, i2;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(i1 = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, i2 = size - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; i1 &amp;lt; size; i1++, i2--)\n  {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(a1[i1] != a2[i2])\n    {\n      &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;;\n    }\n  }\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Pardon me if there are any syntax errors or if I mixed in anything that&apos;s not strict C. I&apos;m not arguing that the , operator is good form, but that&apos;s what you could use it for. In the case above I&apos;d probably use a &lt;code&gt;while&lt;/code&gt; loop instead so the multiple expressions on init and loop would be more obvious. (And I&apos;d initialize i1 and i2 inline instead of declaring and then initializing.... blah blah blah.)&lt;/p&gt;\n    ","\n&lt;p&gt;I&apos;m reviving this simply to address questions from @Rajesh and @JeffMercado which i think are very important since this is one of the top search engine hits.&lt;/p&gt;\n\n&lt;p&gt;Take the following snippet of code for example &lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = (&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; j;\nj = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d %d\\n&quot;&lt;/span&gt;, i , j);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It will print&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The &lt;code&gt;i&lt;/code&gt; case is handled as explained by most answers. All expressions are evaluated in left-to-right order but only the last one is assigned to &lt;code&gt;i&lt;/code&gt;. The result of the &lt;code&gt;(&lt;/code&gt; &lt;em&gt;expression&lt;/em&gt; )&lt;code&gt;is&lt;/code&gt;1`. &lt;/p&gt;\n\n&lt;p&gt;The &lt;code&gt;j&lt;/code&gt; case follows different precedence rules since &lt;code&gt;,&lt;/code&gt; has the lowest operator precedence. Because of those rules, the compiler sees &lt;em&gt;assignment-expression, constant, constant ...&lt;/em&gt;. The expressions are again evaluated in left-to-right order and their side-effects stay visible, therefore, &lt;code&gt;j&lt;/code&gt; is &lt;code&gt;5&lt;/code&gt; as a result of &lt;code&gt;j = 5&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;Interstingly, &lt;code&gt;int j = 5,4,3,2,1;&lt;/code&gt; is not allowed by the language spec. An &lt;em&gt;initializer&lt;/em&gt; expects an &lt;em&gt;assignment-expression&lt;/em&gt; so a direct &lt;code&gt;,&lt;/code&gt; operator is not allowed.&lt;/p&gt;\n\n&lt;p&gt;Hope this helps.&lt;/p&gt;\n    "]},"randomTags":[{"name":"sql-server-2008","slug":"sql-server-2008"},{"name":"werkzeug","slug":"werkzeug"},{"name":"soft-keyboard","slug":"soft-keyboard"},{"name":"utf-8","slug":"utf-8"},{"name":"equality-operator","slug":"equality-operator"},{"name":"mod-rewrite","slug":"mod-rewrite"},{"name":"javascript-objects","slug":"javascript-objects"},{"name":"gethashcode","slug":"gethashcode"},{"name":"variable-assignment","slug":"variable-assignment"},{"name":"pointer-arithmetic","slug":"pointer-arithmetic"},{"name":"variable-variables","slug":"variable-variables"},{"name":"syntax","slug":"syntax"},{"name":"command-line","slug":"command-line"},{"name":"winforms","slug":"winforms"},{"name":"return-value","slug":"return-value"},{"name":"directory","slug":"directory"},{"name":"vertical-alignment","slug":"vertical-alignment"},{"name":"php","slug":"php"},{"name":"recursion","slug":"recursion"},{"name":"httpurlconnection","slug":"httpurlconnection"}]},"__N_SSG":true}