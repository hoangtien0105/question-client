<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>dependent-name tags | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="All questions and solutions for dependent-name tags - page 1"/><meta property="og:title" content="dependent-name tags | Solutions Checker"/><meta property="og:description" content="All questions and solutions for dependent-name tags - page 1"/><meta name="next-head-count" content="15"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-b06815e21c943e0d.js" defer=""></script><script src="/_next/static/chunks/816-14d8d742fae4ce97.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/tag/%5Bslug%5D/page/%5Bpage%5D-ddde2f39b1530ef5.js" defer=""></script><script src="/_next/static/6ctJfCympFH_chh5mjicD/_buildManifest.js" defer=""></script><script src="/_next/static/6ctJfCympFH_chh5mjicD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/tag/dependent-name/page/1#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="pagination-page-wrapper"><span class="pagination-buttons previous bg-stone-500 cursor-not-allowed  hover:bg-stone-500 text-white font-bold py-2 px-4 rounded">Previous</span></div><div class="question my-5"><div class="flex items-center justify-center"><div class="rounded-xl border p-5 shadow-md post-layout-inner bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/where-and-why-do-i-have-to-put-the-%22template%22-and-%22typename%22-keywords-1657384467606">Where and why do I have to put the &quot;template&quot; and &quot;typename&quot; keywords?</a></div></div></div><div class="tags-wrap h-max space-x-8"><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/dependent-name">dependent-name</a></div></div></div><div><div class="flex items-center justify-between text-slate-500"><div class="flex space-x-4 md:space-x-8"><span class="btn bg-stone-500 cursor-pointer  hover:bg-stone-500 text-white font-bold py-2 px-4 rounded">Show Solution</span></div></div></div></div></div></div><div class="pagination-page-wrapper"><span class="pagination-buttons next bg-stone-500 cursor-not-allowed  hover:bg-stone-500 text-white font-bold py-2 px-4 rounded">Next</span></div><div class="widget"><a href="/questions/tag/getelementbyid">getelementbyid</a><a href="/questions/tag/printing">printing</a><a href="/questions/tag/form-submit">form-submit</a><a href="/questions/tag/events">events</a><a href="/questions/tag/typename">typename</a><a href="/questions/tag/complexity-theory">complexity-theory</a><a href="/questions/tag/tsql">tsql</a><a href="/questions/tag/unique">unique</a><a href="/questions/tag/datetimeoffset">datetimeoffset</a><a href="/questions/tag/asp.net-mvc">asp.net-mvc</a><a href="/questions/tag/stdin">stdin</a><a href="/questions/tag/propertynotfoundexception">propertynotfoundexception</a><a href="/questions/tag/z-index">z-index</a><a href="/questions/tag/jvm-hotspot">jvm-hotspot</a><a href="/questions/tag/awt">awt</a><a href="/questions/tag/lapply">lapply</a><a href="/questions/tag/cpu-architecture">cpu-architecture</a><a href="/questions/tag/printf">printf</a><a href="/questions/tag/greatest-n-per-group">greatest-n-per-group</a><a href="/questions/tag/regex-greedy">regex-greedy</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"count":1,"rows":[{"id":65,"title":"Where and why do I have to put the \"template\" and \"typename\" keywords?","slug":"where-and-why-do-i-have-to-put-the-\"template\"-and-\"typename\"-keywords-1657384467606","postType":"QUESTION","createdAt":"2022-07-09T16:34:27.000Z","updatedAt":"2022-07-09T16:34:27.000Z","tags":[{"id":241,"name":"dependent-name","slug":"dependent-name","createdAt":"2022-07-09T16:34:27.000Z","updatedAt":"2022-07-09T16:34:27.000Z","Questions_Tags":{"questionId":65,"tagId":241}}]}]},"slug":"dependent-name","page":"1","answers":{"65":["\n\u0026lt;p\u0026gt;(See \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/17579889/4561887\u0026quot;\u0026gt;here also for my C++11 answer\u0026lt;/a\u0026gt;)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In order to parse a C++ program, the compiler needs to know whether certain names are types or not. The following example demonstrates that:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;t * f;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;How should this be parsed? For many languages a compiler doesn\u0026apos;t need to know the meaning of a name in order to parse and basically know what action a line of code does. In C++, the above however can yield vastly different interpretations depending on what \u0026lt;code\u0026gt;t\u0026lt;/code\u0026gt; means. If it\u0026apos;s a type, then it will be a declaration of a pointer \u0026lt;code\u0026gt;f\u0026lt;/code\u0026gt;. However if it\u0026apos;s not a type, it will be a multiplication. So the C++ Standard says at paragraph (3/7):\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Some names denote types or templates. In general, whenever a name is encountered it is necessary to determine whether that name denotes one of these entities before continuing to parse the program that contains it. The process that determines this is called name lookup.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;How will the compiler find out what a name \u0026lt;code\u0026gt;t::x\u0026lt;/code\u0026gt; refers to, if \u0026lt;code\u0026gt;t\u0026lt;/code\u0026gt; refers to a template type parameter? \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; could be a static int data member that could be multiplied or could equally well be a nested class or typedef that could yield to a declaration. \u0026lt;strong\u0026gt;If a name has this property - that it can\u0026apos;t be looked up until the actual template arguments are known - then it\u0026apos;s called a \u0026lt;em\u0026gt;dependent name\u0026lt;/em\u0026gt; (it \u0026quot;depends\u0026quot; on the template parameters).\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You might recommend to just wait till the user instantiates the template: \u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Let\u0026apos;s wait until the user instantiates the template, and then later find out the real meaning of \u0026lt;code\u0026gt;t::x * f;\u0026lt;/code\u0026gt;.\u0026lt;/em\u0026gt; \u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;This will work and actually is allowed by the Standard as a possible implementation approach. These compilers basically copy the template\u0026apos;s text into an internal buffer, and only when an instantiation is needed, they parse the template and possibly detect errors in the definition. But instead of bothering the template\u0026apos;s users (poor colleagues!) with errors made by a template\u0026apos;s author, other implementations choose to check templates early on and give errors in the definition as soon as possible, before an instantiation even takes place. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So there has to be a way to tell the compiler that certain names are types and that certain names aren\u0026apos;t. \u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;The \u0026quot;typename\u0026quot; keyword\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The answer is: \u0026lt;em\u0026gt;We\u0026lt;/em\u0026gt; decide how the compiler should parse this. If \u0026lt;code\u0026gt;t::x\u0026lt;/code\u0026gt; is a dependent name, then we need to prefix it by \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; to tell the compiler to parse it in a certain way. The Standard says at (14.6/2):\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;A name used in a template declaration or definition and that is dependent on a template-parameter is\n  assumed not to name a type unless the applicable name lookup finds a type name or the name is qualified\n  by the keyword typename. \u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;There are many names for which \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; is not necessary, because the compiler can, with the applicable name lookup in the template definition, figure out how to parse a construct itself - for example with \u0026lt;code\u0026gt;T *f;\u0026lt;/code\u0026gt;, when \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; is a type template parameter. But for \u0026lt;code\u0026gt;t::x * f;\u0026lt;/code\u0026gt; to be a declaration, it must be written as \u0026lt;code\u0026gt;typename t::x *f;\u0026lt;/code\u0026gt;. If you omit the keyword and the name is taken to be a non-type, but when instantiation finds it denotes a type, the usual error messages are emitted by the compiler. Sometimes, the error consequently is given at definition time:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// t::x is taken as non-type, but as an expression the following misses an\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// operator between the two names or a semicolon separating them.\u0026lt;/span\u0026gt;\nt::x f;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;The syntax allows \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; only before qualified names\u0026lt;/em\u0026gt; - it is therefor taken as granted that unqualified names are always known to refer to types if they do so.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A similar gotcha exists for names that denote templates, as hinted at by the introductory text.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;The \u0026quot;template\u0026quot; keyword\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Remember the initial quote above and how the Standard requires special handling for templates as well? Let\u0026apos;s take the following innocent-looking example: \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;boost::function\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;() \u0026amp;gt; f;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It might look obvious to a human reader. Not so for the compiler. Imagine the following arbitrary definition of \u0026lt;code\u0026gt;boost::function\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;f\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; boost { \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; function = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; }\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; f = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n  boost::function\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;() \u0026amp;gt; f; \n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;That\u0026apos;s actually a valid \u0026lt;em\u0026gt;expression\u0026lt;/em\u0026gt;! It uses the less-than operator to compare \u0026lt;code\u0026gt;boost::function\u0026lt;/code\u0026gt; against zero (\u0026lt;code\u0026gt;int()\u0026lt;/code\u0026gt;), and then uses the greater-than operator to compare the resulting \u0026lt;code\u0026gt;bool\u0026lt;/code\u0026gt; against \u0026lt;code\u0026gt;f\u0026lt;/code\u0026gt;. However as you might well know, \u0026lt;code\u0026gt;boost::function\u0026lt;/code\u0026gt; \u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/1_54_0/doc/html/function.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;in real life\u0026lt;/a\u0026gt; is a template, so the compiler knows (14.2/3):\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;After name lookup (3.4) finds that a name is a template-name, if this name is followed by a \u0026amp;lt;, the \u0026amp;lt; is\n  always taken as the beginning of a template-argument-list and never as a name followed by the less-than\n  operator.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Now we are back to the same problem as with \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt;. What if we can\u0026apos;t know yet whether the name is a template when parsing the code? We will need to insert \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt; immediately before the template name, as specified by \u0026lt;code\u0026gt;14.2/4\u0026lt;/code\u0026gt;. This looks like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;t::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// call a function template\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Template names can not only occur after a \u0026lt;code\u0026gt;::\u0026lt;/code\u0026gt; but also after a \u0026lt;code\u0026gt;-\u0026amp;gt;\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;.\u0026lt;/code\u0026gt; in a class member access. You need to insert the keyword there too:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// call a function template\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h2\u0026gt;Dependencies\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;For the people that have thick Standardese books on their shelf and that want to know what exactly I was talking about, I\u0026apos;ll talk a bit about how this is specified in the Standard.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In template declarations some constructs have different meanings depending on what template arguments you use to instantiate the template: Expressions may have different types or values, variables may have different types or function calls might end up calling different functions. Such constructs are generally said to \u0026lt;em\u0026gt;depend\u0026lt;/em\u0026gt; on template parameters.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The Standard defines precisely the rules by whether a construct is dependent or not. It separates them into logically different groups: One catches types, another catches expressions. Expressions may depend by their value and/or their type. So we have, with typical examples appended:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Dependent types (e.g: a type template parameter \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Value-dependent expressions (e.g: a non-type template parameter \u0026lt;code\u0026gt;N\u0026lt;/code\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Type-dependent expressions (e.g: a cast to a type template parameter \u0026lt;code\u0026gt;(T)0\u0026lt;/code\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Most of the rules are intuitive and are built up recursively: For example, a type constructed as \u0026lt;code\u0026gt;T[N]\u0026lt;/code\u0026gt; is a dependent type if \u0026lt;code\u0026gt;N\u0026lt;/code\u0026gt; is a value-dependent expression or \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; is a dependent type. The details of this can be read in section \u0026lt;code\u0026gt;(14.6.2/1\u0026lt;/code\u0026gt;) for dependent types, \u0026lt;code\u0026gt;(14.6.2.2)\u0026lt;/code\u0026gt; for type-dependent expressions and \u0026lt;code\u0026gt;(14.6.2.3)\u0026lt;/code\u0026gt; for value-dependent expressions. \u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;Dependent names\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;The Standard is a bit unclear about what \u0026lt;em\u0026gt;exactly\u0026lt;/em\u0026gt; is a \u0026lt;em\u0026gt;dependent name\u0026lt;/em\u0026gt;. On a simple read (you know, the principle of least surprise), all it defines as a \u0026lt;em\u0026gt;dependent name\u0026lt;/em\u0026gt; is the special case for function names below. But since clearly \u0026lt;code\u0026gt;T::x\u0026lt;/code\u0026gt; also needs to be looked up in the instantiation context, it also needs to be a dependent name (fortunately, as of mid C++14 the committee has started to look into how to fix this confusing definition). \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To avoid this problem, I have resorted to a simple interpretation of the Standard text. Of all the constructs that denote dependent types or expressions, a subset of them represent names. Those names are therefore \u0026quot;dependent names\u0026quot;. A name can take different forms - the Standard says:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;A name is a use of an identifier (2.11), operator-function-id (13.5), conversion-function-id (12.3.2), or template-id (14.2) that denotes an entity or label (6.6.4, 6.1)\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;An identifier is just a plain sequence of characters / digits, while the next two are the \u0026lt;code\u0026gt;operator +\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;operator type\u0026lt;/code\u0026gt; form. The last form is \u0026lt;code\u0026gt;template-name \u0026amp;lt;argument list\u0026amp;gt;\u0026lt;/code\u0026gt;. All these are names, and by conventional use in the Standard, a name can also include qualifiers that say what namespace or class a name should be looked up in.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A value dependent expression \u0026lt;code\u0026gt;1 + N\u0026lt;/code\u0026gt; is not a name, but \u0026lt;code\u0026gt;N\u0026lt;/code\u0026gt; is. The subset of all dependent constructs that are names is called \u0026lt;em\u0026gt;dependent name\u0026lt;/em\u0026gt;. Function names, however, may have different meaning in different instantiations of a template, but unfortunately are not caught by this general rule. \u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;Dependent function names\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;Not primarily a concern of this article, but still worth mentioning: Function names are an exception that are handled separately. An identifier function name is dependent not by itself, but by the type dependent argument expressions used in a call. In the example \u0026lt;code\u0026gt;f((T)0)\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;f\u0026lt;/code\u0026gt; is a dependent name. In the Standard, this is specified at \u0026lt;code\u0026gt;(14.6.2/1)\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Additional notes and examples\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;In enough cases we need both of \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt;. Your code should look like the following\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Tail\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;UnionNode\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Tail {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; U\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;inUnion\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Tail::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; inUnion\u0026amp;lt;U\u0026amp;gt; dummy;\n    };\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...\u0026lt;/span\u0026gt;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The keyword \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt; doesn\u0026apos;t always have to appear in the last part of a name. It can appear in the middle before a class name that\u0026apos;s used as a scope, like in the following example\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; t::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; iterator\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;::value_type v;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In some cases, the keywords are forbidden, as detailed below\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;On the name of a dependent base class you are not allowed to write \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt;. It\u0026apos;s assumed that the name given is a class type name. This is true for both names in the base-class list and the constructor initializer list:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;derive_from_Has_type\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* typename */\u0026lt;/span\u0026gt; SomeBase\u0026amp;lt;T\u0026amp;gt;::type \n { };\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;In using-declarations it\u0026apos;s not possible to use \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt; after the last \u0026lt;code\u0026gt;::\u0026lt;/code\u0026gt;, and the C++ committee \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#109\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;said\u0026lt;/a\u0026gt; not to work on a solution. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;derive_from_Has_type\u0026lt;/span\u0026gt; : SomeBase\u0026amp;lt;T\u0026amp;gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; SomeBase\u0026amp;lt;T\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; type; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// error\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; SomeBase\u0026amp;lt;T\u0026amp;gt;::type; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// typename *is* allowed\u0026lt;/span\u0026gt;\n };\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;C++11\u0026lt;/h2\u0026gt;\n\n\u0026lt;h3\u0026gt;Problem\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;While the rules in C++03 about when you need \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt; are largely reasonable, there is one annoying disadvantage of its formulation\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt; {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; result_type;\n\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// error, \u0026quot;this\u0026quot; is dependent, \u0026quot;template\u0026quot; keyword needed\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;g\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt;\u0026amp;gt;();\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;g\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt;\u0026amp;gt;();\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// error, \u0026quot;A\u0026amp;lt;T\u0026amp;gt;\u0026quot; is dependent, \u0026quot;typename\u0026quot; keyword needed\u0026lt;/span\u0026gt;\n    A\u0026amp;lt;T\u0026amp;gt;::result_type n1;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK\u0026lt;/span\u0026gt;\n    result_type n2; \n  }\n\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; U\u0026amp;gt;\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;g\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;As can be seen, we need the disambiguation keyword even if the compiler could perfectly figure out itself that \u0026lt;code\u0026gt;A::result_type\u0026lt;/code\u0026gt; can only be \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; (and is hence a type), and \u0026lt;code\u0026gt;this-\u0026amp;gt;g\u0026lt;/code\u0026gt; can only be the member template \u0026lt;code\u0026gt;g\u0026lt;/code\u0026gt; declared later (even if \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; is explicitly specialized somewhere, that would not affect the code within that template, so its meaning cannot be affected by a later specialization of \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;!). \u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;Current instantiation\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;To improve the situation, in C++11 the language tracks when a type refers to the enclosing template. To know that, the type must have been formed by using a certain form of name, which is its own name (in the above, \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;A\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;::A\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt;). A type referenced by such a name is known to be  the \u0026lt;em\u0026gt;current instantiation\u0026lt;/em\u0026gt;. There may be multiple types that are all the current instantiation if the type from which the name is formed is a member/nested class (then, \u0026lt;code\u0026gt;A::NestedClass\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; are both current instantiations). \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Based on this notion, the language says that \u0026lt;code\u0026gt;CurrentInstantiation::Foo\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;Foo\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;CurrentInstantiationTyped-\u0026amp;gt;Foo\u0026lt;/code\u0026gt; (such as \u0026lt;code\u0026gt;A *a = this; a-\u0026amp;gt;Foo\u0026lt;/code\u0026gt;) are all \u0026lt;em\u0026gt;member of the current instantiation\u0026lt;/em\u0026gt; \u0026lt;strong\u0026gt;if\u0026lt;/strong\u0026gt; they are found to be members of a class that is the current instantiation or one of its non-dependent base classes (by just doing the name lookup immediately). \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The keywords \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt; are now not required anymore if the qualifier is a member of the current instantiation. A keypoint here to remember is that \u0026lt;code\u0026gt;A\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; is \u0026lt;em\u0026gt;still\u0026lt;/em\u0026gt; a type-dependent name (after all \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; is also type dependent). But \u0026lt;code\u0026gt;A\u0026amp;lt;T\u0026amp;gt;::result_type\u0026lt;/code\u0026gt; is known to be a type - the compiler will \u0026quot;magically\u0026quot; look into this kind of dependent types to figure this out. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt; {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; result_type;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;C\u0026lt;/span\u0026gt; { }; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// could be specialized!\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;D\u0026lt;/span\u0026gt; : B, C\u0026amp;lt;T\u0026amp;gt; {\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK, member of current instantiation!\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// A::result_type is not dependent: int\u0026lt;/span\u0026gt;\n    D::result_type r1;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// error, not a member of the current instantiation\u0026lt;/span\u0026gt;\n    D::questionable_type r2;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK for now - relying on C\u0026amp;lt;T\u0026amp;gt; to provide it\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// But not a member of the current instantiation\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; D::questionable_type r3;        \n  }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;That\u0026apos;s impressive, but can we do better? The language even goes further and \u0026lt;em\u0026gt;requires\u0026lt;/em\u0026gt; that an implementation again looks up \u0026lt;code\u0026gt;D::result_type\u0026lt;/code\u0026gt; when instantiating \u0026lt;code\u0026gt;D::f\u0026lt;/code\u0026gt; (even if it found its meaning already at definition time). When now the lookup result differs or results in ambiguity, the program is ill-formed and a diagnostic must be given. Imagine what happens if we defined \u0026lt;code\u0026gt;C\u0026lt;/code\u0026gt; like this\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;C\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; result_type;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; questionable_type;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;A compiler is required to catch the error when instantiating \u0026lt;code\u0026gt;D\u0026amp;lt;int\u0026amp;gt;::f\u0026lt;/code\u0026gt;. So you get the best of the two worlds: \u0026quot;Delayed\u0026quot; lookup protecting you if you could get in trouble with dependent base classes, and also \u0026quot;Immediate\u0026quot; lookup that frees you from \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;Unknown specializations\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;In the code of \u0026lt;code\u0026gt;D\u0026lt;/code\u0026gt;, the name \u0026lt;code\u0026gt;typename D::questionable_type\u0026lt;/code\u0026gt; is not a member of the current instantiation. Instead the language marks it as a \u0026lt;em\u0026gt;member of an unknown specialization\u0026lt;/em\u0026gt;. In particular, this is always the case when you are doing \u0026lt;code\u0026gt;DependentTypeName::Foo\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;DependentTypedName-\u0026amp;gt;Foo\u0026lt;/code\u0026gt; and either the dependent type is \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; the current instantiation (in which case the compiler can give up and say \u0026quot;we will look later what \u0026lt;code\u0026gt;Foo\u0026lt;/code\u0026gt; is) or it \u0026lt;em\u0026gt;is\u0026lt;/em\u0026gt; the current instantiation and the name was not found in it or its non-dependent base classes and there are also dependent base classes. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Imagine what happens if we had a member function \u0026lt;code\u0026gt;h\u0026lt;/code\u0026gt; within the above defined \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; class template\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;h\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; A\u0026amp;lt;T\u0026amp;gt;::questionable_type x;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In C++03, the language allowed to catch this error because there could never be a valid way to instantiate \u0026lt;code\u0026gt;A\u0026amp;lt;T\u0026amp;gt;::h\u0026lt;/code\u0026gt; (whatever argument you give to \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt;). In C++11, the language now has a further check to give more reason for compilers to implement this rule. Since \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; has no dependent base classes, and \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; declares no member \u0026lt;code\u0026gt;questionable_type\u0026lt;/code\u0026gt;, the name \u0026lt;code\u0026gt;A\u0026amp;lt;T\u0026amp;gt;::questionable_type\u0026lt;/code\u0026gt; is \u0026lt;em\u0026gt;neither\u0026lt;/em\u0026gt; a member of the current instantiation \u0026lt;em\u0026gt;nor\u0026lt;/em\u0026gt; a member of an unknown specialization. In that case, there should be no way that that code could validly compile at instantiation time, so the language forbids a name where the qualifier is the current instantiation to be neither a member of an unknown specialization nor a member of the current instantiation (however, this violation is still not required to be diagnosed).\u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;Examples and trivia\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;You can try this knowledge on \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/14005063/34509\u0026quot;\u0026gt;this answer\u0026lt;/a\u0026gt; and see whether the above definitions make sense for you on a real-world example (they are repeated slightly less detailed in that answer).  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The C++11 rules make the following valid C++03 code ill-formed (which was not intended by the C++ committee, but will probably not be fixed)\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; B { \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; };\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;C\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; B, T {\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;g\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;(); }\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \n  C\u0026amp;lt;A\u0026amp;gt; c; c.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;g\u0026lt;/span\u0026gt;(); \n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This valid C++03 code would bind \u0026lt;code\u0026gt;this-\u0026amp;gt;f\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;A::f\u0026lt;/code\u0026gt; at instantiation time and everything is fine. C++11 however immediately binds it to \u0026lt;code\u0026gt;B::f\u0026lt;/code\u0026gt; and requires a double-check when instantiating, checking whether the lookup still matches. However when instantiating \u0026lt;code\u0026gt;C\u0026amp;lt;A\u0026amp;gt;::g\u0026lt;/code\u0026gt;, the \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Dominance_(C%2B%2B)\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Dominance Rule\u0026lt;/a\u0026gt; applies and lookup will find \u0026lt;code\u0026gt;A::f\u0026lt;/code\u0026gt; instead.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Preface\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This post is meant to be an \u0026lt;em\u0026gt;easy-to-read\u0026lt;/em\u0026gt; alternative to \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords/17579889#17579889\u0026quot;\u0026gt;litb\u0026apos;s post\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;The underlying purpose is the same; an explanation to \u0026quot;When?\u0026quot; and \u0026quot;Why?\u0026quot; \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt; must be applied.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h1\u0026gt;What\u0026apos;s the purpose of \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt;?\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt; are usable in circumstances other than when declaring a template.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;There are certain contexts in \u0026lt;em\u0026gt;C++\u0026lt;/em\u0026gt; where the compiler must explicitly be told how to treat a name, and all these contexts have one thing in common; they depend on at least one \u0026lt;em\u0026gt;template-parameter\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;We refer to such names, where there can be an ambiguity in interpretation, as; \u0026quot;\u0026lt;em\u0026gt;dependent names\u0026lt;/em\u0026gt;\u0026quot;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This post will offer an explanation to the relationship between \u0026lt;em\u0026gt;dependent-names\u0026lt;/em\u0026gt;, and the two keywords.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;A snippet says more than 1000 words\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Try to explain what is going on in the following \u0026lt;em\u0026gt;function-template\u0026lt;/em\u0026gt;, either to yourself, a friend, or perhaps your cat; what is happening in the statement marked (\u0026lt;em\u0026gt;A\u0026lt;/em\u0026gt;)?\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f_tmpl\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ T::foo * x; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* \u0026amp;lt;-- (A) */\u0026lt;/span\u0026gt; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;\u0026lt;br\u0026gt;\u0026lt;/sup\u0026gt;\nIt might not be as easy as one thinks, more specifically the result of evaluating (\u0026lt;em\u0026gt;A\u0026lt;/em\u0026gt;) heavily \u0026lt;em\u0026gt;depends\u0026lt;/em\u0026gt; on the definition of the type passed as template-parameter \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Different \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt;s can drastically change the semantics involved.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;       foo;       }; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* (C) --\u0026amp;gt; */\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f_tmpl\u0026lt;/span\u0026gt;\u0026amp;lt;X\u0026amp;gt; ();\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Y\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; foo = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;123\u0026lt;/span\u0026gt;; }; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* (D) --\u0026amp;gt; */\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f_tmpl\u0026lt;/span\u0026gt;\u0026amp;lt;Y\u0026amp;gt; ();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;\u0026lt;br\u0026gt;\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;The two different scenarios\u0026lt;/strong\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If we instantiate the function-template with type \u0026lt;em\u0026gt;X\u0026lt;/em\u0026gt;, as in (\u0026lt;em\u0026gt;C\u0026lt;/em\u0026gt;), we will have a declaration of a \u0026lt;em\u0026gt;pointer-to int\u0026lt;/em\u0026gt; named \u0026lt;em\u0026gt;x\u0026lt;/em\u0026gt;, but;\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;if we instantiate the template with type \u0026lt;em\u0026gt;Y\u0026lt;/em\u0026gt;, as in (\u0026lt;em\u0026gt;D\u0026lt;/em\u0026gt;), (\u0026lt;em\u0026gt;A\u0026lt;/em\u0026gt;) would instead consist of an expression that calculates the product of \u0026lt;em\u0026gt;123\u0026lt;/em\u0026gt; multiplied with some already declared variable \u0026lt;em\u0026gt;x\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;br\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;The Rationale\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;The C++ Standard cares about our safety and well-being, at least in this case.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;To prevent an implementation from potentially suffering from nasty surprises, the Standard mandates that we sort out the ambiguity of a \u0026lt;em\u0026gt;dependent-name\u0026lt;/em\u0026gt; by \u0026lt;em\u0026gt;explicitly\u0026lt;/em\u0026gt; stating the intent anywhere we\u0026apos;d like to treat the name as either a \u0026lt;em\u0026gt;type-name\u0026lt;/em\u0026gt;, or a \u0026lt;em\u0026gt;template-id\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If nothing is stated, the \u0026lt;em\u0026gt;dependent-name\u0026lt;/em\u0026gt; will be considered to be either a variable, or a function.\u0026lt;/p\u0026gt;\n\u0026lt;br\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;How to handle dependent names?\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;If this was a Hollywood film, \u0026lt;em\u0026gt;dependent-names\u0026lt;/em\u0026gt; would be the disease that spreads through body contact, instantly affects its host to make it confused. Confusion that could, possibly, lead to an ill-formed perso-, erhm.. program.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A \u0026lt;em\u0026gt;dependent-name\u0026lt;/em\u0026gt; is \u0026lt;strong\u0026gt;any\u0026lt;/strong\u0026gt; name that directly, or indirectly, depends on a \u0026lt;em\u0026gt;template-parameter\u0026lt;/em\u0026gt;.\n\u0026lt;sup\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;g_tmpl\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n   SomeTrait\u0026amp;lt;T\u0026amp;gt;::type                   foo; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (E), ill-formed\u0026lt;/span\u0026gt;\n   SomeTrait\u0026amp;lt;T\u0026amp;gt;::NestedTrait\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;::type bar; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (F), ill-formed\u0026lt;/span\u0026gt;\n   foo.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; ();                         \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (G), ill-formed    \u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;We have four \u0026lt;em\u0026gt;dependent\u0026lt;/em\u0026gt; names in the above snippet:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;E\u0026lt;/strong\u0026gt;)\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026quot;type\u0026quot;\u0026lt;/strong\u0026gt; depends on the instantiation of \u0026lt;code\u0026gt;SomeTrait\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt;, which include \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt;, and;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;F\u0026lt;/strong\u0026gt;)\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026quot;NestedTrait\u0026quot;\u0026lt;/strong\u0026gt;, which is a \u0026lt;em\u0026gt;template-id\u0026lt;/em\u0026gt;, depends on \u0026lt;code\u0026gt;SomeTrait\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt;, and;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026quot;type\u0026quot;\u0026lt;/strong\u0026gt; at the end of (\u0026lt;em\u0026gt;F\u0026lt;/em\u0026gt;) depends on \u0026lt;em\u0026gt;NestedTrait\u0026lt;/em\u0026gt;, which depends on \u0026lt;code\u0026gt;SomeTrait\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt;, and;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;G\u0026lt;/strong\u0026gt;)\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026quot;data\u0026quot;\u0026lt;/strong\u0026gt;, which looks like a \u0026lt;em\u0026gt;member-function template\u0026lt;/em\u0026gt;, is indirectly a \u0026lt;em\u0026gt;dependent-name\u0026lt;/em\u0026gt; since the type of \u0026lt;em\u0026gt;foo\u0026lt;/em\u0026gt; depends on the instantiation of \u0026lt;code\u0026gt;SomeTrait\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Neither of statement (\u0026lt;em\u0026gt;E\u0026lt;/em\u0026gt;), (\u0026lt;em\u0026gt;F\u0026lt;/em\u0026gt;) or (\u0026lt;em\u0026gt;G\u0026lt;/em\u0026gt;) is valid if the compiler would interpret the \u0026lt;em\u0026gt;dependent-names\u0026lt;/em\u0026gt; as variables/functions (which as stated earlier is what happens if we don\u0026apos;t explicitly say otherwise).\n\u0026lt;sup\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;The solution\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;To make \u0026lt;code\u0026gt;g_tmpl\u0026lt;/code\u0026gt; have a valid definition we must explicitly tell the compiler that we expect a type in (\u0026lt;em\u0026gt;E\u0026lt;/em\u0026gt;), a \u0026lt;em\u0026gt;template-id\u0026lt;/em\u0026gt; and a \u0026lt;em\u0026gt;type\u0026lt;/em\u0026gt; in (\u0026lt;em\u0026gt;F\u0026lt;/em\u0026gt;), and a \u0026lt;em\u0026gt;template-id\u0026lt;/em\u0026gt; in (\u0026lt;em\u0026gt;G\u0026lt;/em\u0026gt;).\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;g_tmpl\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; SomeTrait\u0026amp;lt;T\u0026amp;gt;::type foo;                            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (G), legal\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; SomeTrait\u0026amp;lt;T\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; NestedTrait\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;::type bar; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (H), legal\u0026lt;/span\u0026gt;\n   foo.\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; ();                                  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (I), legal\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Every time a \u0026lt;em\u0026gt;name\u0026lt;/em\u0026gt; denotes a type, \u0026lt;strong\u0026gt;all\u0026lt;/strong\u0026gt; \u0026lt;em\u0026gt;names\u0026lt;/em\u0026gt; involved must be either \u0026lt;em\u0026gt;type-names\u0026lt;/em\u0026gt; or \u0026lt;em\u0026gt;namespaces\u0026lt;/em\u0026gt;, with this in mind it\u0026apos;s quite easy to see that we apply \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; at the beginning of our fully \u0026lt;em\u0026gt;qualified name\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt; however, is different in this regard, since there\u0026apos;s no way of coming to a conclusion such as; \u0026lt;em\u0026gt;\u0026quot;oh, this is a template, then this other thing must also be a template\u0026quot;\u0026lt;/em\u0026gt;. This means that we apply \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt; directly in front of any \u0026lt;em\u0026gt;name\u0026lt;/em\u0026gt; that we\u0026apos;d like to treat as such.\u0026lt;/p\u0026gt;\n\u0026lt;br\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;Can I just stick the \u0026lt;em\u0026gt;keywords\u0026lt;/em\u0026gt; in front of any name?\u0026lt;/h2\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026quot;\u0026lt;em\u0026gt;Can I just stick \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt; in front of any name? I don\u0026apos;t want to worry about the context in which they appear...\u0026lt;/em\u0026gt;\u0026quot; - \u0026lt;code\u0026gt;Some C++ Developer\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;The rules in the Standard states that you may apply the keywords as long as you are dealing with a \u0026lt;em\u0026gt;qualified-name\u0026lt;/em\u0026gt; (\u0026lt;em\u0026gt;K\u0026lt;/em\u0026gt;), but if the name isn\u0026apos;t \u0026lt;em\u0026gt;qualified\u0026lt;/em\u0026gt; the application is ill-formed (\u0026lt;em\u0026gt;L\u0026lt;/em\u0026gt;).\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; N {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt; { };\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;         N::         X\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; a; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...  legal\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; N::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; X\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; b; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (K), legal\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;    X\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; c; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (L), ill-formed\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;\u0026lt;strong\u0026gt;Note\u0026lt;/strong\u0026gt;: Applying \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt; in a context where it is not required is not considered good practice; just because you can do something, doesn\u0026apos;t mean that you should.\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;br\u0026gt;\n\u0026lt;p\u0026gt;Additionally there are contexts where \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt; are \u0026lt;strong\u0026gt;explicitly\u0026lt;/strong\u0026gt; disallowed:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;When specifying the bases of which a class inherits\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Every name written in a derived class\u0026apos;s \u0026lt;em\u0026gt;base-specifier-list\u0026lt;/em\u0026gt; is already treated as a \u0026lt;em\u0026gt;type-name\u0026lt;/em\u0026gt;, explicitly specifying \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; is both ill-formed, and redundant.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;                    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// .------- the base-specifier-list\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// v\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Derived\u0026lt;/span\u0026gt;      : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; SomeTrait\u0026amp;lt;T\u0026amp;gt;::type \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* \u0026amp;lt;- ill-formed */\u0026lt;/span\u0026gt; {\n    ...\n  };\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n \u0026lt;br\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;When the \u0026lt;em\u0026gt;template-id\u0026lt;/em\u0026gt; is the one being referred to in a derived class\u0026apos;s \u0026lt;em\u0026gt;using-directive\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Base\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt; { };\n  };\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Derived\u0026lt;/span\u0026gt; : Base {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; Base::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; type; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ill-formed\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; Base::type;          \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// legal\u0026lt;/span\u0026gt;\n  };\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;sub\u0026gt;\n\u0026lt;em\u0026gt;This answer is meant to be a rather short and sweet one to answer (part of) the titled question. If you want an answer with more detail that explains why you have to put them there, please go \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/613132/1381108\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt;.\u0026lt;/em\u0026gt;\n\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;The general rule for putting the \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; keyword is mostly when you\u0026apos;re using a template parameter and you want to access a nested \u0026lt;code\u0026gt;typedef\u0026lt;/code\u0026gt; or using-alias, for example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; type = T; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// no typename required\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; underlying_type = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T::type \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// typename required\u0026lt;/span\u0026gt;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that this also applies for meta functions or things that take generic template parameters too. However, if the template parameter provided is an explicit type then you don\u0026apos;t have to specify \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt;, for example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// typename required\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; type = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; std::conditional\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T\u0026amp;amp;, T\u0026amp;amp;\u0026amp;amp;\u0026amp;gt;::type;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// no typename required\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; integer = std::conditional\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt;\u0026amp;gt;::type;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The general rules for adding the \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt; qualifier are mostly similar except they typically involve templated member functions (static or otherwise) of a struct/class that is itself templated, for example:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Given this struct and function:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; U\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n        std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;get\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; test\u0026amp;lt;T\u0026amp;gt;\u0026amp;amp; t)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    t.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// error\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Attempting to access \u0026lt;code\u0026gt;t.get\u0026amp;lt;int\u0026amp;gt;()\u0026lt;/code\u0026gt; from inside the function will result in an error:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-none s-code-block\u0026quot;\u0026gt;\u0026lt;code\u0026gt;main.cpp:13:11: error: expected primary-expression before \u0026apos;int\u0026apos;\n     t.get\u0026amp;lt;int\u0026amp;gt;();\n           ^\nmain.cpp:13:11: error: expected \u0026apos;;\u0026apos; before \u0026apos;int\u0026apos;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Thus in this context you would need the \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt; keyword beforehand and call it like so:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;t.template get\u0026amp;lt;int\u0026amp;gt;()\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;That way the compiler will parse this properly rather than \u0026lt;code\u0026gt;t.get \u0026amp;lt; int\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Tail::inUnion\u0026amp;lt;U\u0026amp;gt; dummy;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;However, I\u0026apos;m not sure you\u0026apos;re implementation of inUnion is correct. If I understand correctly, this class is not supposed to be instantiated, therefore the \u0026quot;fail\u0026quot; tab will never avtually fails. Maybe it would be better to indicates whether the type is in the union or not with a simple boolean value.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; TypeList\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Contains\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Head, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Tail\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Contains\u0026lt;/span\u0026gt;\u0026amp;lt;T, UnionNode\u0026amp;lt;Head, Tail\u0026amp;gt; \u0026amp;gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { result = Contains\u0026amp;lt;T, Tail\u0026amp;gt;::result };\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Tail\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Contains\u0026lt;/span\u0026gt;\u0026amp;lt;T, UnionNode\u0026amp;lt;T, Tail\u0026amp;gt; \u0026amp;gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { result = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt; };\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Contains\u0026lt;/span\u0026gt;\u0026amp;lt;T, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;\u0026amp;gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { result = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt; };\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;PS: Have a look at \u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/1_38_0/doc/html/variant.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Boost::Variant\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;PS2: Have a look at \u0026lt;a href=\u0026quot;http://www.ddj.com/cpp/184403813\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;typelists\u0026lt;/a\u0026gt;, notably in Andrei Alexandrescu\u0026apos;s book: Modern C++ Design\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;C++20 aka C++2a\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;As outlined in this \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0634r3.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Proposal\u0026lt;/a\u0026gt;, C++20 / C++2a has further relaxed the requirements for the \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; keyword. In particular, \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; may now be omitted in all those places, where syntactically only a type is legal. So, if an unknown token must be a type, C++20 will actually treat it as a type. For backwards compatibility, \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; may still be used, though.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In particular, most \u0026lt;code\u0026gt;using\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;typedef\u0026lt;/code\u0026gt; declarations can now be written without \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt;. \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; can also be omitted in the declaration of method return types (including trailing return types), in the declaration of method and lambda parameters and in the type argument to \u0026lt;code\u0026gt;static_cast\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;const_cast\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;dynamic_cast\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;reinterpret_cast\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;One notable exception, where \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; is still required, is in the argument list of instantiations of user or library defined templates: Even, if that particular argument was declared to be a type, the \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; keyword is still required. So \u0026lt;code\u0026gt;static_cast\u0026amp;lt;A::B\u0026amp;gt;(arg)\u0026lt;/code\u0026gt; is legal in C++20, but \u0026lt;code\u0026gt;my_template_class\u0026amp;lt;A::B\u0026amp;gt;(arg)\u0026lt;/code\u0026gt; is ill-formed, if A is a dependant scope and \u0026lt;code\u0026gt;my_template_class\u0026lt;/code\u0026gt; expects a type.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A few examples:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; type; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; val { \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; }; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt; type; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; val { \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; }; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;C\u0026lt;/span\u0026gt; {};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; I\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;D\u0026lt;/span\u0026gt; {};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt; {\n    T::type v;                                  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;T::type \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T::type arg)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; arg; }      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;T::type \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;g\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; arg)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_cast\u0026lt;/span\u0026gt;\u0026amp;lt;T::type\u0026amp;gt;(arg); } \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// C\u0026amp;lt;T::type\u0026amp;gt; c1;                           // error\u0026lt;/span\u0026gt;\n    D\u0026amp;lt;T::val\u0026amp;gt; d;                                \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK (as has always been)\u0026lt;/span\u0026gt;\n    C\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T::type\u0026amp;gt; c2;                     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK (old style)\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; T::type mytype;                     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; mytypeagain = T::type;                \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK\u0026lt;/span\u0026gt;\n    C\u0026amp;lt;mytype\u0026amp;gt; c3;                               \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK (via typedef / using)\u0026lt;/span\u0026gt;\n};\nX\u0026amp;lt;A\u0026amp;gt; xa;\nX\u0026amp;lt;B\u0026amp;gt; xb;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I am placing JLBorges\u0026apos;s excellent \u0026lt;a href=\u0026quot;http://www.cplusplus.com/forum/general/122765/#msg669061\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;response\u0026lt;/a\u0026gt; to a similar question verbatim from cplusplus.com, as it is the most succinct explanation I\u0026apos;ve read on the subject.\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;In a template that we write, there are two kinds of names that could be used - dependant names and non- dependant names. A dependant name is a name that depends on a template parameter; a non-dependant name has the same meaning irrespective of what the template parameters are.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( T\u0026amp;amp; x, std::string str, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; count )\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// these names are looked up during the second phase\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// when foo is instantiated and the type T is known\u0026lt;/span\u0026gt;\n    x.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// dependant name (non-type)\u0026lt;/span\u0026gt;\n    T::instance_count ; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// dependant name (non-type)\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T::iterator i ; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// dependant name (type)\u0026lt;/span\u0026gt;\n      \n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// during the first phase, \u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// T::instance_count is treated as a non-type (this is the default)\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// the typename keyword specifies that T::iterator is to be treated as a type.\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// these names are looked up during the first phase\u0026lt;/span\u0026gt;\n    std::string::size_type s ; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// non-dependant name (type)\u0026lt;/span\u0026gt;\n    std::string::npos ; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// non-dependant name (non-type)\u0026lt;/span\u0026gt;\n    str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;empty\u0026lt;/span\u0026gt;() ; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// non-dependant name (non-type)\u0026lt;/span\u0026gt;\n    count ; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// non-dependant name (non-type)\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;What a dependant name refers to could be something different for each different instantiation of the template. As a consequence, C++ templates are subject to \u0026quot;two-phase name lookup\u0026quot;. When a template is initially parsed (before any instantiation takes place) the compiler looks up the non-dependent names. When a particular instantiation of the template takes place, the template parameters are known by then, and the compiler looks up dependent names.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;During the first phase, the parser needs to know if a dependant name is the name of a type or the name of a non-type. By default, a dependant name is assumed to be the name of a non-type. The typename keyword before a dependant name specifies that it is the name of a type.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Summary\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Use the keyword typename only in template declarations and definitions provided you have a qualified name that refers to a type and depends on a template parameter.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Dependent name is a name depends on template parameters, we need to instruct compiler in order to compile the template class/function properly before actually instiatiate them.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;typename -\u0026amp;gt; tell compiler the dependent name is an actual type\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;DependentType\u0026lt;/span\u0026gt;\n{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T::type a;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; Type=\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T::type;\n};\n\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;template -\u0026amp;gt; tell compiler the dependent name is a template function/class\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;DependentTemplate\u0026lt;/span\u0026gt;\n{\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// template function\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;U\u0026lt;/span\u0026gt;\u0026amp;gt;\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{}\n\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// template class\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;U\u0026lt;/span\u0026gt;\u0026amp;gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ClassName\u0026lt;/span\u0026gt;{};\n};\n\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T2\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 3 ways to call a dependent template function\u0026lt;/span\u0026gt;\n  DependentTemplate\u0026amp;lt;T1\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt;\u0026amp;lt;T2\u0026amp;gt;();\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;DependentTemplate\u0026lt;/span\u0026gt;\u0026amp;lt;T1\u0026amp;gt;().\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt;\u0026amp;lt;T2\u0026amp;gt;();\n  (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;DependentTemplate\u0026lt;/span\u0026gt;\u0026amp;lt;T1\u0026amp;gt;())-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt;\u0026amp;lt;T2\u0026amp;gt;();\n\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// You need both typename and template to reference a dependent template class\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; DependentTemplate\u0026amp;lt;T1\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; ClassName\u0026amp;lt;T2\u0026amp;gt; obj;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; Type=\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; DependentTemplate\u0026amp;lt;T1\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; ClassName\u0026amp;lt;T2\u0026amp;gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    "]},"randomTags":[{"name":"getelementbyid","slug":"getelementbyid"},{"name":"printing","slug":"printing"},{"name":"form-submit","slug":"form-submit"},{"name":"events","slug":"events"},{"name":"typename","slug":"typename"},{"name":"complexity-theory","slug":"complexity-theory"},{"name":"tsql","slug":"tsql"},{"name":"unique","slug":"unique"},{"name":"datetimeoffset","slug":"datetimeoffset"},{"name":"asp.net-mvc","slug":"asp.net-mvc"},{"name":"stdin","slug":"stdin"},{"name":"propertynotfoundexception","slug":"propertynotfoundexception"},{"name":"z-index","slug":"z-index"},{"name":"jvm-hotspot","slug":"jvm-hotspot"},{"name":"awt","slug":"awt"},{"name":"lapply","slug":"lapply"},{"name":"cpu-architecture","slug":"cpu-architecture"},{"name":"printf","slug":"printf"},{"name":"greatest-n-per-group","slug":"greatest-n-per-group"},{"name":"regex-greedy","slug":"regex-greedy"}]},"__N_SSG":true},"page":"/questions/tag/[slug]/page/[page]","query":{"slug":"dependent-name","page":"1"},"buildId":"6ctJfCympFH_chh5mjicD","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>