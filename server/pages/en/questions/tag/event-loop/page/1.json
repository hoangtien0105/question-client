{"pageProps":{"data":{"count":1,"rows":[{"id":546,"title":"Why is setTimeout(fn, 0) sometimes useful?","slug":"why-is-settimeout(fn-0)-sometimes-useful-1657388379869","postType":"QUESTION","createdAt":"2022-07-09T17:39:39.000Z","updatedAt":"2022-07-09T17:39:39.000Z","tags":[{"id":2660,"name":"event-loop","slug":"event-loop","createdAt":"2022-07-09T17:39:39.000Z","updatedAt":"2022-07-09T17:39:39.000Z","Questions_Tags":{"questionId":546,"tagId":2660}}]}]},"slug":"event-loop","page":"1","answers":{"546":["\n&lt;p&gt;In the question, there existed a &lt;a href=&quot;https://en.wikipedia.org/wiki/Race_condition&quot; rel=&quot;noreferrer&quot;&gt;race condition&lt;/a&gt; between:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;The browser&apos;s attempt to initialize the drop-down list, ready to have its selected index updated, and&lt;/li&gt;\n&lt;li&gt;Your code to set the selected index&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;Your code was consistently winning this race and attempting to set drop-down selection before the browser was ready, meaning that the bug would appear.&lt;/p&gt;\n\n&lt;p&gt;This race existed because JavaScript has a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop&quot; rel=&quot;noreferrer&quot;&gt;single thread of execution&lt;/a&gt; that is shared with page rendering. In effect, running JavaScript blocks the updating of the DOM.&lt;/p&gt;\n\n&lt;p&gt;Your workaround was:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;setTimeout&lt;/span&gt;(callback, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Invoking &lt;code&gt;setTimeout&lt;/code&gt; with a callback, and zero as the second argument will schedule the callback to be run &lt;strong&gt;asynchronously&lt;/strong&gt;, after the shortest possible delay - which will be around 10ms when the tab has focus and the JavaScript thread of execution is not busy.&lt;/p&gt;\n\n&lt;p&gt;The OP&apos;s solution, therefore was to delay by about 10ms, the setting of the selected index. This gave the browser an opportunity to initialize the DOM, fixing the bug.&lt;/p&gt;\n\n&lt;p&gt;Every version of Internet Explorer exhibited quirky behaviors and this kind of workaround was necessary at times. Alternatively it might have been a genuine bug in the OP&apos;s codebase. &lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;See Philip Roberts talk &lt;a href=&quot;https://www.youtube.com/watch?v=8aGhZQkoFbQ&quot; rel=&quot;noreferrer&quot;&gt;&quot;What the heck is the event loop?&quot;&lt;/a&gt; for more thorough explanation.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;&lt;em&gt;Preface:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Some of the other answers are correct but don&apos;t actually illustrate what the problem being solved is, so I created this answer to present that detailed illustration.&lt;/p&gt;\n\n&lt;p&gt;As such, I am posting a &lt;strong&gt;detailed walk-through of what the browser does and how using &lt;code&gt;setTimeout()&lt;/code&gt; helps&lt;/strong&gt;. It looks longish but is actually very simple and straightforward - I just made it very detailed. &lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;UPDATE:&lt;/strong&gt; I have made a JSFiddle to live-demonstrate the explanation below: &lt;a href=&quot;http://jsfiddle.net/C2YBE/31/&quot; rel=&quot;noreferrer&quot;&gt;http://jsfiddle.net/C2YBE/31/&lt;/a&gt; . Many &lt;strong&gt;thanks&lt;/strong&gt; to @ThangChung for helping to kickstart it.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;UPDATE2:&lt;/strong&gt; Just in case JSFiddle web site dies, or deletes the code, I added the code to this answer at the very end.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;DETAILS&lt;/strong&gt;:&lt;/p&gt;\n\n&lt;p&gt;Imagine a web app with a &quot;do something&quot; button and a result div.&lt;/p&gt;\n\n&lt;p&gt;The &lt;code&gt;onClick&lt;/code&gt; handler for &quot;do something&quot; button calls a function &quot;LongCalc()&quot;, which does 2 things:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;Makes a very long calculation (say takes 3 min)&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Prints the results of calculation into the result div.&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;Now, your users start testing this, click &quot;do something&quot; button, and the page sits there doing seemingly nothing for 3 minutes, they get restless, click the button again, wait 1 min, nothing happens, click button again... &lt;/p&gt;\n\n&lt;p&gt;The problem is obvious - you want a &quot;Status&quot; DIV, which shows what&apos;s going on. Let&apos;s see how that works.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;So you add a &quot;Status&quot; DIV (initially empty), and modify the &lt;code&gt;onclick&lt;/code&gt; handler (function &lt;code&gt;LongCalc()&lt;/code&gt;) to do 4 things:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;Populate the status &quot;Calculating... may take ~3 minutes&quot; into status DIV&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Makes a very long calculation (say takes 3 min)&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Prints the results of calculation into the result div.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Populate the status &quot;Calculation done&quot; into status DIV&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;And, you happily give the app to users to re-test.&lt;/p&gt;\n\n&lt;p&gt;They come back to you looking very angry. And explain that when they clicked the button, &lt;strong&gt;the Status DIV never got updated with &quot;Calculating...&quot; status!!!&lt;/strong&gt;&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;You scratch your head, ask around on StackOverflow (or read docs or google), and realize the problem:&lt;/p&gt;\n\n&lt;p&gt;The browser places all its &quot;TODO&quot; tasks (both UI tasks and JavaScript commands) resulting from events into a &lt;strong&gt;single queue&lt;/strong&gt;. And unfortunately, re-drawing the &quot;Status&quot; DIV with the new &quot;Calculating...&quot; value is a separate TODO which goes to the end of the queue!&lt;/p&gt;\n\n&lt;p&gt;Here&apos;s a breakdown of the events during your user&apos;s test, contents of the queue after each event:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Queue: &lt;code&gt;[Empty]&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;Event: Click the button. Queue after event: &lt;code&gt;[Execute OnClick handler(lines 1-4)]&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;Event: Execute first line in OnClick handler (e.g. change Status DIV value). Queue after event: &lt;code&gt;[Execute OnClick handler(lines 2-4), re-draw Status DIV with new &quot;Calculating&quot; value]&lt;/code&gt;. &lt;strong&gt;Please note that while the DOM changes happen instantaneously, to re-draw the corresponding DOM element you need a new event, triggered by the DOM change, that went at the end of the queue&lt;/strong&gt;.&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;PROBLEM!!!&lt;/strong&gt; &lt;strong&gt;PROBLEM!!!&lt;/strong&gt; Details explained below.&lt;/li&gt;\n&lt;li&gt;Event: Execute second line in handler (calculation). Queue after: &lt;code&gt;[Execute OnClick handler(lines 3-4), re-draw Status DIV with &quot;Calculating&quot; value]&lt;/code&gt;.&lt;/li&gt;\n&lt;li&gt;Event: Execute 3rd line in handler (populate result DIV). Queue after: &lt;code&gt;[Execute OnClick handler(line 4), re-draw Status DIV with &quot;Calculating&quot; value, re-draw result DIV with result]&lt;/code&gt;.&lt;/li&gt;\n&lt;li&gt;Event: Execute 4th line in handler (populate status DIV with &quot;DONE&quot;). Queue: &lt;code&gt;[Execute OnClick handler, re-draw Status DIV with &quot;Calculating&quot; value, re-draw result DIV with result; re-draw Status DIV with &quot;DONE&quot; value]&lt;/code&gt;.&lt;/li&gt;\n&lt;li&gt;Event: execute implied &lt;code&gt;return&lt;/code&gt; from &lt;code&gt;onclick&lt;/code&gt; handler sub. We take the &quot;Execute OnClick handler&quot; off the queue and start executing next item on the queue.&lt;/li&gt;\n&lt;li&gt;NOTE: Since we already finished the calculation, 3 minutes already passed for the user. &lt;strong&gt;The re-draw event didn&apos;t happen yet!!!&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;Event: re-draw Status DIV with &quot;Calculating&quot; value. We do the re-draw and take that off the queue.&lt;/li&gt;\n&lt;li&gt;Event: re-draw Result DIV with result value. We do the re-draw and take that off the queue.&lt;/li&gt;\n&lt;li&gt;Event: re-draw Status DIV with &quot;Done&quot; value. We do the re-draw and take that off the queue.\nSharp-eyed viewers might even notice &quot;Status DIV with &quot;Calculating&quot; value flashing for fraction of a microsecond - &lt;strong&gt;AFTER THE CALCULATION FINISHED&lt;/strong&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;So, the underlying problem is that the re-draw event for &quot;Status&quot; DIV is placed on the queue at the end, AFTER the &quot;execute line 2&quot; event which takes 3 minutes, so the actual re-draw doesn&apos;t happen until AFTER the calculation is done.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;To the rescue comes the &lt;code&gt;setTimeout()&lt;/code&gt;. How does it help? Because by calling long-executing code via &lt;code&gt;setTimeout&lt;/code&gt;, you actually create 2 events: &lt;code&gt;setTimeout&lt;/code&gt; execution itself, and (due to 0 timeout), separate queue entry for the code being executed.&lt;/p&gt;\n\n&lt;p&gt;So, to fix your problem, you modify your &lt;code&gt;onClick&lt;/code&gt; handler to be TWO statements (in a new function or just a block within &lt;code&gt;onClick&lt;/code&gt;):&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;Populate the status &quot;Calculating... may take ~3 minutes&quot; into status DIV&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Execute &lt;code&gt;setTimeout()&lt;/code&gt; with 0 timeout and a call to &lt;code&gt;LongCalc()&lt;/code&gt; function&lt;/strong&gt;. &lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;LongCalc()&lt;/code&gt; function is almost the same as last time but obviously doesn&apos;t have &quot;Calculating...&quot; status DIV update as first step; and instead starts the calculation right away.&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;So, what does the event sequence and the queue look like now?&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Queue: &lt;code&gt;[Empty]&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;Event: Click the button. Queue after event: &lt;code&gt;[Execute OnClick handler(status update, setTimeout() call)]&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;Event: Execute first line in OnClick handler (e.g. change Status DIV value). Queue after event: &lt;code&gt;[Execute OnClick handler(which is a setTimeout call), re-draw Status DIV with new &quot;Calculating&quot; value]&lt;/code&gt;. &lt;/li&gt;\n&lt;li&gt;Event: Execute second line in handler (setTimeout call). Queue after: &lt;code&gt;[re-draw Status DIV with &quot;Calculating&quot; value]&lt;/code&gt;. The queue has nothing new in it for 0 more seconds.&lt;/li&gt;\n&lt;li&gt;Event: Alarm from the timeout goes off, 0 seconds later. Queue after: &lt;code&gt;[re-draw Status DIV with &quot;Calculating&quot; value, execute LongCalc (lines 1-3)]&lt;/code&gt;. &lt;/li&gt;\n&lt;li&gt;Event: &lt;strong&gt;re-draw Status DIV with &quot;Calculating&quot; value&lt;/strong&gt;. Queue after: &lt;code&gt;[execute LongCalc (lines 1-3)]&lt;/code&gt;. Please note that this re-draw event might actually happen BEFORE the alarm goes off, which works just as well.&lt;/li&gt;\n&lt;li&gt;...&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Hooray! The Status DIV just got updated to &quot;Calculating...&quot; before the calculation started!!!&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;Below is the sample code from the JSFiddle illustrating these examples: &lt;a href=&quot;http://jsfiddle.net/C2YBE/31/&quot; rel=&quot;noreferrer&quot;&gt;http://jsfiddle.net/C2YBE/31/&lt;/a&gt; :&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;HTML code:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&amp;lt;table border=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&amp;gt;\n    &lt;span class=&quot;language-xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;tr&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;td&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;button&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&apos;do&apos;&lt;/span&gt;&amp;gt;&lt;/span&gt;Do long calc - bad status!&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;td&lt;/span&gt;&amp;gt;&lt;/span&gt;\n        &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;td&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&apos;status&apos;&lt;/span&gt;&amp;gt;&lt;/span&gt;Not Calculating yet.&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;td&lt;/span&gt;&amp;gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;tr&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;language-xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;tr&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;td&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;button&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&apos;do_ok&apos;&lt;/span&gt;&amp;gt;&lt;/span&gt;Do long calc - good status!&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;td&lt;/span&gt;&amp;gt;&lt;/span&gt;\n        &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;td&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&apos;status_ok&apos;&lt;/span&gt;&amp;gt;&lt;/span&gt;Not Calculating yet.&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;td&lt;/span&gt;&amp;gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;tr&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&amp;lt;/table&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;JavaScript code: (Executed on &lt;code&gt;onDomReady&lt;/code&gt; and may require jQuery 1.9)&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;long_running&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;status_div&lt;/span&gt;) {\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; result = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Use 1000/700/300 limits in Chrome, &lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;//    300/100/100 in IE8, &lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;//    1000/500/200 in FireFox&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// I have no idea why identical runtimes fail on diff browsers.&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;; i++) {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; j = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; j &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;700&lt;/span&gt;; j++) {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; k = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; k &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;300&lt;/span&gt;; k++) {\n                result = result + i + j + k;\n            }\n        }\n    }\n    $(status_div).&lt;span class=&quot;hljs-title function_&quot;&gt;text&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;calculation done&apos;&lt;/span&gt;);\n}\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// Assign events to buttons&lt;/span&gt;\n$(&lt;span class=&quot;hljs-string&quot;&gt;&apos;#do&apos;&lt;/span&gt;).&lt;span class=&quot;hljs-title function_&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;click&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {\n    $(&lt;span class=&quot;hljs-string&quot;&gt;&apos;#status&apos;&lt;/span&gt;).&lt;span class=&quot;hljs-title function_&quot;&gt;text&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;calculating....&apos;&lt;/span&gt;);\n    &lt;span class=&quot;hljs-title function_&quot;&gt;long_running&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;#status&apos;&lt;/span&gt;);\n});\n\n$(&lt;span class=&quot;hljs-string&quot;&gt;&apos;#do_ok&apos;&lt;/span&gt;).&lt;span class=&quot;hljs-title function_&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;click&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {\n    $(&lt;span class=&quot;hljs-string&quot;&gt;&apos;#status_ok&apos;&lt;/span&gt;).&lt;span class=&quot;hljs-title function_&quot;&gt;text&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;calculating....&apos;&lt;/span&gt;);\n    &lt;span class=&quot;hljs-comment&quot;&gt;// This works on IE8. Works in Chrome&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Does NOT work in FireFox 25 with timeout =0 or =1&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// DOES work in FF if you change timeout from 0 to 500&lt;/span&gt;\n    &lt;span class=&quot;hljs-variable language_&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;){ &lt;span class=&quot;hljs-title function_&quot;&gt;long_running&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;#status_ok&apos;&lt;/span&gt;) }, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);\n});\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Take a look at John Resig&apos;s article about &lt;a href=&quot;http://ejohn.org/blog/how-javascript-timers-work/&quot;&gt;How JavaScript Timers Work&lt;/a&gt;. When you set a timeout, it actually queues the asynchronous code until the engine executes the current call stack.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;code&gt;setTimeout()&lt;/code&gt; buys you some time until the DOM elements are loaded, even if is set to 0.&lt;/p&gt;\n\n&lt;p&gt;Check this out: &lt;a href=&quot;http://snook.ca/archives/javascript/settimeout_solve_domcontentloaded&quot; rel=&quot;noreferrer&quot;&gt;setTimeout&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Browsers have a process called &quot;main thread&quot;, that is responsible for executing some JavaScript tasks, UI updates e.g.: painting, redraw, reflow, etc.\nJavaScript tasks are queued to a message queue and then are dispatched to the browser&apos;s main thread to be executed.\nWhen UI updates are generated while the main thread is busy, tasks are added into the message queue.&lt;/p&gt;\n    ","\n&lt;p&gt;There are conflicting upvoted answers here, and without proof there is no way to know whom to believe. Here is proof that @DVK is right and @SalvadorDali is incorrect. The latter claims:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;&quot;And here is why: it is not possible to have setTimeout with a time\n  delay of 0 milliseconds. The Minimum value is determined by the\n  browser and it is not 0 milliseconds. Historically browsers sets this\n  minimum to 10 milliseconds, but the HTML5 specs and modern browsers\n  have it set at 4 milliseconds.&quot;&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;The 4ms minimum timeout is irrelevant to what is happening. What really happens is that setTimeout pushes the callback function to the end of the execution queue. If after setTimeout(callback, 0) you have blocking code which takes several seconds to run, the callback will not be executed for several seconds, until the blocking code has finished. Try this code:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;testSettimeout0&lt;/span&gt; () {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; startTime = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Date&lt;/span&gt;().&lt;span class=&quot;hljs-title function_&quot;&gt;getTime&lt;/span&gt;()\n    &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;setting timeout 0 callback at &apos;&lt;/span&gt; +&lt;span class=&quot;hljs-title function_&quot;&gt;sinceStart&lt;/span&gt;())\n    &lt;span class=&quot;hljs-built_in&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;){\n        &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;in timeout callback at &apos;&lt;/span&gt; +&lt;span class=&quot;hljs-title function_&quot;&gt;sinceStart&lt;/span&gt;())\n    }, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)\n    &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;starting blocking loop at &apos;&lt;/span&gt; +&lt;span class=&quot;hljs-title function_&quot;&gt;sinceStart&lt;/span&gt;())\n    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;hljs-title function_&quot;&gt;sinceStart&lt;/span&gt;() &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;3000&lt;/span&gt;) {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;\n    }\n    &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;blocking loop ended at &apos;&lt;/span&gt; +&lt;span class=&quot;hljs-title function_&quot;&gt;sinceStart&lt;/span&gt;())\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;// functions below&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;sinceStart&lt;/span&gt; () {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Date&lt;/span&gt;().&lt;span class=&quot;hljs-title function_&quot;&gt;getTime&lt;/span&gt;() - startTime\n    } &lt;span class=&quot;hljs-comment&quot;&gt;// sinceStart&lt;/span&gt;\n} &lt;span class=&quot;hljs-comment&quot;&gt;// testSettimeout0&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Output is:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;setting timeout &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; callback at &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;\nstarting blocking loop at &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;\nblocking loop ended at &lt;span class=&quot;hljs-number&quot;&gt;3000&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; timeout callback at &lt;span class=&quot;hljs-number&quot;&gt;3033&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;One reason to do that is to defer the execution of code to a separate, subsequent event loop. When responding to a browser event of some kind (mouse click, for example), sometimes it&apos;s necessary to perform operations only &lt;em&gt;after&lt;/em&gt; the current event is processed. The &lt;code&gt;setTimeout()&lt;/code&gt; facility is the simplest way to do it.&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;edit&lt;/em&gt; now that it&apos;s 2015 I should note that there&apos;s also &lt;code&gt;requestAnimationFrame()&lt;/code&gt;, which isn&apos;t exactly the same but it&apos;s sufficiently close to &lt;code&gt;setTimeout(fn, 0)&lt;/code&gt; that it&apos;s worth mentioning.&lt;/p&gt;\n    ","\n&lt;p&gt;Both of these two top-rated answers are wrong. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop&quot; rel=&quot;noreferrer&quot;&gt;Check out the MDN description on the concurrency model and the event loop&lt;/a&gt;, and it should become clear what&apos;s going on (that MDN resource is a real gem). And &lt;strong&gt;simply using&lt;/strong&gt; &lt;code&gt;setTimeout&lt;/code&gt; can be adding unexpected problems in your code in addition to &quot;solving&quot; this little problem.&lt;/p&gt;\n\n&lt;p&gt;What&apos;s &lt;strong&gt;actually&lt;/strong&gt; going on here is not that &quot;the browser might not be quite ready yet because concurrency,&quot; or something based on &quot;each line is an event that gets added to the back of the queue&quot;.&lt;/p&gt;\n\n&lt;p&gt;The &lt;a href=&quot;http://jsfiddle.net/C2YBE/31/&quot; rel=&quot;noreferrer&quot;&gt;jsfiddle&lt;/a&gt; provided by DVK indeed illustrates a problem, but his explanation for it isn&apos;t correct.&lt;/p&gt;\n\n&lt;p&gt;What&apos;s happening in his code is that he&apos;s first attaching an event handler to the &lt;code&gt;click&lt;/code&gt; event on the &lt;code&gt;#do&lt;/code&gt; button.&lt;/p&gt;\n\n&lt;p&gt;Then, when you actually click the button, a &lt;code&gt;message&lt;/code&gt; is created referencing the event handler function, which gets added to the &lt;code&gt;message queue&lt;/code&gt;. When the &lt;code&gt;event loop&lt;/code&gt; reaches this message, it creates a &lt;code&gt;frame&lt;/code&gt; on the stack, with the function call to the click event handler in the jsfiddle.&lt;/p&gt;\n\n&lt;p&gt;And this is where it gets interesting. We&apos;re so used to thinking of Javascript as being asynchronous that we&apos;re prone to overlook this tiny fact: &lt;strong&gt;Any frame has to be executed, in full, before the next frame can be executed&lt;/strong&gt;. No concurrency, people. &lt;/p&gt;\n\n&lt;p&gt;What does this mean? It means that whenever a function is invoked from the message queue, it blocks the queue until the stack it generates has been emptied. Or, in more general terms, it blocks until the function has returned. And it blocks &lt;strong&gt;everything&lt;/strong&gt;, including DOM rendering operations, scrolling, and whatnot. If you want confirmation, just try to increase the duration of the long running operation in the fiddle (e.g. run the outer loop 10 more times), and you&apos;ll notice that while it runs, you cannot scroll the page. If it runs long enough, your browser will ask you if you want to kill the process, because it&apos;s making the page unresponsive. The frame is being executed, and the event loop and message queue are stuck until it finishes.&lt;/p&gt;\n\n&lt;p&gt;So why this side-effect of the text not updating? Because while you &lt;strong&gt;have&lt;/strong&gt; changed the value of the element in the DOM  you can &lt;code&gt;console.log()&lt;/code&gt; its value immediately after changing it and see that it &lt;strong&gt;has&lt;/strong&gt; been changed (which shows why DVK&apos;s explanation isn&apos;t correct)  the browser is waiting for the stack to deplete (the &lt;code&gt;on&lt;/code&gt; handler function to return) and thus the message to finish, so that it can eventually get around to executing the message that has been added by the runtime as a reaction to our mutation operation, and in order to reflect that mutation in the UI.&lt;/p&gt;\n\n&lt;p&gt;This is because we are actually waiting for code to finish running. We haven&apos;t said &quot;someone fetch this and then call this function with the results, thanks, and now I&apos;m done so imma return, do whatever now,&quot; like we usually do with our event-based asynchronous Javascript. We enter a click event handler function, we update a DOM element, we call another function, the other function works for a long time and then returns, we then update the same DOM element, and &lt;strong&gt;then&lt;/strong&gt; we return from the initial function, effectively emptying the stack. And &lt;strong&gt;then&lt;/strong&gt; the browser can get to the next message in the queue, which might very well be a message generated by us by triggering some internal &quot;on-DOM-mutation&quot; type event.&lt;/p&gt;\n\n&lt;p&gt;The browser UI cannot (or chooses not to) update the UI until the currently executing frame has completed (the function has returned). Personally, I think this is rather by design than restriction.&lt;/p&gt;\n\n&lt;p&gt;Why does the &lt;code&gt;setTimeout&lt;/code&gt; thing work then? It does so, because it effectively removes the call to the long-running function from its own frame, scheduling it to be executed later in the &lt;code&gt;window&lt;/code&gt; context, so that it itself can &lt;strong&gt;return immediately&lt;/strong&gt; and allow the message queue to process other messages. And the idea is that the UI &quot;on update&quot; message that has been triggered by us in Javascript when changing the text in the DOM is now ahead of the message queued for the long-running function, so that the UI update happens before we block for a long time.&lt;/p&gt;\n\n&lt;p&gt;Note that a) The long-running function &lt;strong&gt;still blocks&lt;/strong&gt; everything when it runs, and b) you&apos;re not guaranteed that the UI update is actually ahead of it in the message queue. On my June 2018 Chrome browser, a value of &lt;code&gt;0&lt;/code&gt; does not &quot;fix&quot; the problem the fiddle demonstrates  10 does. I&apos;m actually a bit stifled by this, because it seems logical to me that the UI update message should be queued up before it, since its trigger is executed before scheduling the long-running function to be run &quot;later&quot;. But perhaps there&apos;re some optimisations in the V8 engine that may interfere, or maybe my understanding is just lacking.&lt;/p&gt;\n\n&lt;p&gt;Okay, so what&apos;s the problem with using &lt;code&gt;setTimeout&lt;/code&gt;, and what&apos;s a better solution for this particular case?&lt;/p&gt;\n\n&lt;p&gt;First off, the problem with using &lt;code&gt;setTimeout&lt;/code&gt; on any event handler like this, to try to alleviate another problem, is prone to mess with other code. Here&apos;s a real-life example from my work:&lt;/p&gt;\n\n&lt;p&gt;A colleague, in a mis-informed understanding on the event loop, tried to &quot;thread&quot; Javascript by having some template rendering code use &lt;code&gt;setTimeout 0&lt;/code&gt; for its rendering. He&apos;s no longer here to ask, but I can presume that perhaps he inserted timers to gauge the rendering speed (which would be the return immediacy of functions) and found that using this approach would make for blisteringly fast responses from that function.&lt;/p&gt;\n\n&lt;p&gt;First problem is obvious; you cannot thread javascript, so you win nothing here while you add obfuscation. Secondly, you have now effectively detached the rendering of a template from the stack of possible event listeners that might expect that very template to have been rendered, while it may very well not have been. The actual behaviour of that function was now non-deterministic, as was  unknowingly so  any function that would run it, or depend on it. You can make educated guesses, but you cannot properly code for its behaviour.&lt;/p&gt;\n\n&lt;p&gt;The &quot;fix&quot; when writing a new event handler that depended on its logic was to &lt;strong&gt;also&lt;/strong&gt; use &lt;code&gt;setTimeout 0&lt;/code&gt;. But, that&apos;s not a fix, it is hard to understand, and it is no fun to debug errors that are caused by code like this. Sometimes there&apos;s no problem ever, other times it concistently fails, and then again, sometimes it works and breaks sporadically, depending on the current performance of the platform and whatever else happens to going on at the time. This is why I personally would advise against using this hack (it &lt;strong&gt;is&lt;/strong&gt; a hack, and we should all know that it is), unless you really know what you&apos;re doing and what the consequences are.&lt;/p&gt;\n\n&lt;p&gt;But what &lt;strong&gt;can&lt;/strong&gt; we do instead? Well, as the referenced MDN article suggests, either split the work into multiple messages (if you can) so that other messages that are queued up may be interleaved with your work and executed while it runs, or use a web worker, which can run in tandem with your page and return results when done with its calculations.&lt;/p&gt;\n\n&lt;p&gt;Oh, and if you&apos;re thinking, &quot;Well, couldn&apos;t I just put a callback in the long-running function to make it asynchronous?,&quot; then no. The callback doesn&apos;t make it asynchronous, it&apos;ll still have to run the long-running code before explicitly calling your callback.&lt;/p&gt;\n    ","\n&lt;p&gt;This is an old questions with old answers. I wanted to add a new look at this problem and to answer why is this happens and not why is this useful.&lt;/p&gt;\n\n&lt;p&gt;So you have two functions:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; f1 = &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {    \n   &lt;span class=&quot;hljs-built_in&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;){\n      &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;f1&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;First function call...&quot;&lt;/span&gt;);\n   }, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);\n};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; f2 = &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;f2&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Second call...&quot;&lt;/span&gt;);\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and then call them in the following order &lt;code&gt;f1(); f2();&lt;/code&gt; just to see that the second one executed first. &lt;/p&gt;\n\n&lt;p&gt;And here is why: it is not possible to have &lt;code&gt;setTimeout&lt;/code&gt; with a time delay of 0 milliseconds. The &lt;strong&gt;Minimum value is determined by the browser&lt;/strong&gt; and it is not 0 milliseconds. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/window.setTimeout?redirectlocale=en-US&amp;amp;redirectslug=DOM/window.setTimeout#Minimum.2F_maximum_delay_and_timeout_nesting&quot;&gt;Historically&lt;/a&gt; browsers sets this minimum to 10 milliseconds, but the &lt;a href=&quot;http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#timers&quot;&gt;HTML5 specs&lt;/a&gt; and modern browsers have it set at 4 milliseconds. &lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;If nesting level is greater than 5, and timeout is less than 4, then\n  increase timeout to 4.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Also from mozilla:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;To implement a 0 ms timeout in a modern browser, you can use\n  window.postMessage() as described &lt;a href=&quot;http://dbaron.org/log/20100309-faster-timeouts&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;P.S. information is taken after reading the following &lt;a href=&quot;http://geekabyte.blogspot.com/2014/01/javascript-effect-of-setting-settimeout.html&quot;&gt;article&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;If you don&apos;t want to watch &lt;a href=&quot;https://www.youtube.com/watch?v=8aGhZQkoFbQ&quot; rel=&quot;noreferrer&quot;&gt;a whole video&lt;/a&gt;, here&apos;s a simple explanation of the things one needs to understand, in order to be able to understand the answer to this question:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;strong&gt;JavaScript is single-threaded&lt;/strong&gt; meaning it does only one thing at a time when running.&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;But the environments in which the JavaScript is running, can be multi-threaded.&lt;/strong&gt; E.g., browsers are often multi-threaded creatures, i.e., are able to do multiple things at a time. So they can run JavaScript and at the same time keep track of dealing with other stuff too.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;From this point on, we&apos;re talking about JavaScript &quot;in browsers&quot;. Things like &lt;code&gt;setTimeout&lt;/code&gt; are indeed browser things, and are not part of the JavaScript itself.&lt;/p&gt;\n&lt;ol start=&quot;3&quot;&gt;\n&lt;li&gt;&lt;strong&gt;The thing that allows JavaScript to run asynchronously is the multi-threaded browser!&lt;/strong&gt; Other than the main space Javascript uses (called the &lt;em&gt;the call stack&lt;/em&gt;) to put each line of code on and run them one by one, browsers also provide JavaScript with another space to put things on.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;Now let&apos;s call that other space &lt;strong&gt;the second space&lt;/strong&gt;.&lt;/p&gt;\n&lt;ol start=&quot;4&quot;&gt;\n&lt;li&gt;Let&apos;s assume &lt;code&gt;fn&lt;/code&gt; is a function. &lt;strong&gt;The important thing to understand here is that &lt;code&gt;fn();&lt;/code&gt; call is not equal to the &lt;code&gt;setTimeout(fn, 0);&lt;/code&gt; call&lt;/strong&gt; as will be explained further below.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;Instead of a &lt;code&gt;0&lt;/code&gt; delay, let&apos;s assume another delay first, e.g., 5000 milliseconds: &lt;code&gt;setTimeout(fn, 5000);&lt;/code&gt;. It&apos;s important to note that this is still a &quot;function call&quot;, so it has to be put on the main space, and removed from it when it&apos;s done, but wait!, we don&apos;t like a whole lengthy and boring 5 seconds delay. That would block the main space and will not allow JavaScript to run ANYTHING else in the meantime.&lt;/p&gt;\n&lt;p&gt;Thankfully this is not how the browser designers designed them to work. &lt;strong&gt;Instead, this call(&lt;code&gt;setTimeout(fn, 5000);&lt;/code&gt;) is done &lt;em&gt;instantly&lt;/em&gt;. This is very important: Even with the 5000 milliseconds delay, this function call is complete in an instant!&lt;/strong&gt; What will happen next? It gets removed from the main space. Where will it be put on? (because we don&apos;t want to lose it). You might have guessed right: &lt;strong&gt;The browser &lt;em&gt;hears&lt;/em&gt; this call and puts it on the second space.&lt;/strong&gt;\n&lt;a href=&quot;https://i.stack.imgur.com/ZBd8y.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/ZBd8y.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;The browser keeps track of the 5 seconds delay &lt;strong&gt;and once it&apos;s passed, it looks at the main space, and &quot;WHEN IT&apos;S EMPTY&quot;, puts the &lt;code&gt;fn();&lt;/code&gt; call back on it&lt;/strong&gt;. That is how the &lt;code&gt;setTimeout&lt;/code&gt; works.&lt;/p&gt;\n&lt;p&gt;So, back to the &lt;code&gt;setTimeout(fn, 0)&lt;/code&gt;, even though the delay is zero, this is still a call to the browser, and the browser hears it instantly and picks it up, and puts it on the second space and puts it back on the main space &lt;strong&gt;only when the main space is empty again, and not really 0 milliseconds later&lt;/strong&gt;.&lt;/p&gt;\n&lt;p&gt;I really recommend watching that video as well since he&apos;s explained it really well, and opens technical things up more.&lt;/p&gt;\n    ","\n&lt;p&gt;Since it is being passed a duration of &lt;code&gt;0&lt;/code&gt;, I suppose it is in order to remove the code passed to the &lt;code&gt;setTimeout&lt;/code&gt; from the flow of execution. So if it&apos;s a function that could take a while, it won&apos;t prevent the subsequent code from executing.&lt;/p&gt;\n    ","\n&lt;p&gt;The other thing this does is push the function invocation to the bottom of the stack, preventing a stack overflow if you are recursively calling a function. This has the effect of a &lt;code&gt;while&lt;/code&gt; loop but lets the JavaScript engine fire other asynchronous timers.&lt;/p&gt;\n    ","\n&lt;p&gt;By calling setTimeout you give the page time to react to the whatever the user is doing. This is particularly helpful for functions run during page load. &lt;/p&gt;\n    ","\n&lt;p&gt;Some other cases where setTimeout is useful:&lt;/p&gt;\n\n&lt;p&gt;You want to break a long-running loop or calculation into smaller components so that the browser doesn&apos;t appear to &apos;freeze&apos; or say &quot;Script on page is busy&quot;.&lt;/p&gt;\n\n&lt;p&gt;You want to disable a form submit button when clicked, but if you disable the button in the onClick handler the form will not be submitted. setTimeout with a time of zero does the trick, allowing the event to end, the form to begin submitting, then your button can be disabled.&lt;/p&gt;\n    ","\n&lt;p&gt;The problem was you were trying to perform a Javascript operation on a non existing element. The element was yet to be loaded and &lt;code&gt;setTimeout()&lt;/code&gt; gives more time for an element to load in the following ways:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;code&gt;setTimeout()&lt;/code&gt; causes the event to be &lt;strong&gt;ansynchronous&lt;/strong&gt; therefore being executed after all the synchronous code, giving your element more time to load. Asynchronous callbacks like the callback in &lt;code&gt;setTimeout()&lt;/code&gt; are placed in the &lt;strong&gt;event queue&lt;/strong&gt; and put on the stack by the &lt;strong&gt;event loop&lt;/strong&gt; after the stack of synchronous code is empty. &lt;/li&gt;\n&lt;li&gt;The value 0 for ms as a second argument in function &lt;code&gt;setTimeout()&lt;/code&gt; is often slightly higher (4-10ms depending on browser). This slightly higher time needed for executing the &lt;code&gt;setTimeout()&lt;/code&gt; callbacks is caused by the amount of &apos;ticks&apos; (where a tick is pushing a callback on the stack if stack is empty) of the event loop. Because of performance and battery life reasons the amount of ticks in the event loop are restricted to a certain amount &lt;strong&gt;less&lt;/strong&gt; than 1000 times per second.&lt;/li&gt;\n&lt;/ol&gt;\n    ","\n&lt;p&gt;The answers about execution loops and rendering the DOM before some other code completes are correct. Zero second timeouts in JavaScript help make the code pseudo-multithreaded, even though it is not.&lt;/p&gt;\n\n&lt;p&gt;I want to add that the BEST value for a cross browser / cross platform zero-second timeout in JavaScript is actually about 20 milliseconds instead of 0 (zero), because many mobile browsers can&apos;t register timeouts smaller than 20 milliseconds due to clock limitations on AMD chips.&lt;/p&gt;\n\n&lt;p&gt;Also, long-running processes that do not involve DOM manipulation should be sent to Web Workers now, as they provide true multithreaded execution of JavaScript.&lt;/p&gt;\n    ","\n&lt;p&gt;setTimout on 0 is also very useful in the pattern of setting up a deferred promise, which you want to return right away:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;myObject.&lt;span class=&quot;hljs-property&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;prototype&lt;/span&gt;&lt;/span&gt;.&lt;span class=&quot;hljs-property&quot;&gt;myMethodDeferred&lt;/span&gt; = &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; deferredObject = $.&lt;span class=&quot;hljs-title class_&quot;&gt;Deferred&lt;/span&gt;();\n    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; that = &lt;span class=&quot;hljs-variable language_&quot;&gt;this&lt;/span&gt;;  &lt;span class=&quot;hljs-comment&quot;&gt;// Because setTimeout won&apos;t work right with this&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) { \n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; myMethodActualWork.&lt;span class=&quot;hljs-title function_&quot;&gt;call&lt;/span&gt;(that, deferredObject);\n    }, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; deferredObject.&lt;span class=&quot;hljs-title function_&quot;&gt;promise&lt;/span&gt;();\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//When need &quot;new a&quot;, setTimeout(fn, 0) is useful, when need to wait some action. Example:&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;){&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;);};\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; b = &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;){&lt;span class=&quot;hljs-built_in&quot;&gt;setTimeout&lt;/span&gt;(b, &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;);}; &lt;span class=&quot;hljs-comment&quot;&gt;//wait some action before override this function&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;//without setTimeout:&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;no setTimeout: b.toString():&apos;&lt;/span&gt;, b.&lt;span class=&quot;hljs-title function_&quot;&gt;toString&lt;/span&gt;());\n&lt;span class=&quot;hljs-title function_&quot;&gt;b&lt;/span&gt;();    &lt;span class=&quot;hljs-comment&quot;&gt;//&quot;b&quot; is an old function&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;no setTieout: a.toString(): &apos;&lt;/span&gt;, a.&lt;span class=&quot;hljs-title function_&quot;&gt;toString&lt;/span&gt;());\n&lt;span class=&quot;hljs-title function_&quot;&gt;a&lt;/span&gt;();    &lt;span class=&quot;hljs-comment&quot;&gt;//and &quot;a&quot; is not overrided&lt;/span&gt;\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;hljs-comment&quot;&gt;//but with setTimeout(fn, 0):&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;){\n        &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;After timeout 0, b.toString(): &apos;&lt;/span&gt;, b.&lt;span class=&quot;hljs-title function_&quot;&gt;toString&lt;/span&gt;());\n        &lt;span class=&quot;hljs-title function_&quot;&gt;b&lt;/span&gt;();    &lt;span class=&quot;hljs-comment&quot;&gt;//&quot;b&quot; is a new function&lt;/span&gt;\n        &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;After timeout 0, a.toString(): &apos;&lt;/span&gt;, a.&lt;span class=&quot;hljs-title function_&quot;&gt;toString&lt;/span&gt;());\n        &lt;span class=&quot;hljs-title function_&quot;&gt;a&lt;/span&gt;();    &lt;span class=&quot;hljs-comment&quot;&gt;//and &quot;a&quot; is overrided&lt;/span&gt;\n    },\n    &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;\n);\n\n&lt;span class=&quot;hljs-comment&quot;&gt;//override var &quot;b&quot;, which was been undefined&lt;/span&gt;\nb = &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;){\n    a = &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;){&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;new a&apos;&lt;/span&gt;);};\n}&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif1&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Javascript is single threaded application so that don&apos;t allow to run function concurrently so to achieve this event loops are use. So exactly what setTimeout(fn, 0) do that its pussed into task quest which is executed when your call stack is empty. I know this explanation is pretty boring, so i recommend you to go through this video this will help you how things work under the hood in browser.\nCheck out this video:- &lt;a href=&quot;https://www.youtube.com/watch?time_continue=392&amp;amp;v=8aGhZQkoFbQ&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://www.youtube.com/watch?time_continue=392&amp;amp;v=8aGhZQkoFbQ&lt;/a&gt;&lt;/p&gt;\n    "]},"randomTags":[{"name":"spring-mvc","slug":"spring-mvc"},{"name":"raw-types","slug":"raw-types"},{"name":"algorithm","slug":"algorithm"},{"name":"mod-rewrite","slug":"mod-rewrite"},{"name":"sfinae","slug":"sfinae"},{"name":"html-parsing","slug":"html-parsing"},{"name":"iterator","slug":"iterator"},{"name":"observable","slug":"observable"},{"name":"flatten","slug":"flatten"},{"name":"module","slug":"module"},{"name":"dom","slug":"dom"},{"name":"android","slug":"android"},{"name":"dynamic-allocation","slug":"dynamic-allocation"},{"name":"dynamic-memory-allocation","slug":"dynamic-memory-allocation"},{"name":"numbers","slug":"numbers"},{"name":"firebase","slug":"firebase"},{"name":"multithreading","slug":"multithreading"},{"name":"git-checkout","slug":"git-checkout"},{"name":"passwords","slug":"passwords"},{"name":"form-submit","slug":"form-submit"}]},"__N_SSG":true}