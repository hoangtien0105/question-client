{"pageProps":{"data":{"count":1,"rows":[{"id":15,"title":"Do I cast the result of malloc?","slug":"do-i-cast-the-result-of-malloc-1657384271583","postType":"QUESTION","createdAt":"2022-07-09T16:31:11.000Z","updatedAt":"2022-07-09T16:31:11.000Z","tags":[{"id":51,"name":"malloc","slug":"malloc","createdAt":"2022-07-09T16:31:11.000Z","updatedAt":"2022-07-09T16:31:11.000Z","Questions_Tags":{"questionId":15,"tagId":51}}]}]},"slug":"malloc","page":"1","answers":{"15":["\n&lt;h3&gt;TL;DR&lt;/h3&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *sieve = (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *) &lt;span class=&quot;hljs-built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;) * length);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;has two problems. The cast and that you&apos;re using the type instead of variable as argument for sizeof. Instead, do like this:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *sieve = &lt;span class=&quot;hljs-built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; *sieve * length);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;Long version&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;No&lt;/strong&gt;; you &lt;em&gt;don&apos;t&lt;/em&gt; cast the result, since:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;It is unnecessary, as &lt;code&gt;void *&lt;/code&gt; is automatically and safely promoted to any other pointer type in this case.&lt;/li&gt;\n&lt;li&gt;It adds clutter to the code, casts are not very easy to read (especially if the pointer type is long).&lt;/li&gt;\n&lt;li&gt;It makes you repeat yourself, which is generally bad.&lt;/li&gt;\n&lt;li&gt;It can hide an error if you forgot to include &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;. This can cause crashes (or, worse, &lt;em&gt;not&lt;/em&gt; cause a crash until way later in some totally different part of the code). Consider what happens if pointers and integers are differently sized; then you&apos;re hiding a warning by casting and might lose bits of your returned address. Note: as of C99 implicit functions are gone from C, and this point is no longer relevant since there&apos;s no automatic assumption that undeclared functions return &lt;code&gt;int&lt;/code&gt;.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;As a clarification, note that I said &quot;you don&apos;t cast&quot;, not &quot;you don&apos;t &lt;em&gt;need&lt;/em&gt; to cast&quot;. In my opinion, it&apos;s a failure to include the cast, even if you got it right. There are simply no benefits to doing it, but a bunch of potential risks, and including the cast indicates that you don&apos;t know about the risks.&lt;/p&gt;\n&lt;p&gt;Also note, as commentators point out, that the above talks about straight C, not C++. I very firmly believe in C and C++ as separate languages.&lt;/p&gt;\n&lt;p&gt;To add further, your code needlessly repeats the type information (&lt;code&gt;int&lt;/code&gt;) which can cause errors. It&apos;s better to de-reference the pointer being used to store the return value, to &quot;lock&quot; the two together:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *sieve = &lt;span class=&quot;hljs-built_in&quot;&gt;malloc&lt;/span&gt;(length * &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; *sieve);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This also moves the &lt;code&gt;length&lt;/code&gt; to the front for increased visibility, and drops the redundant parentheses with &lt;code&gt;sizeof&lt;/code&gt;; they &lt;em&gt;are only needed&lt;/em&gt; when the argument is a type name. Many people seem to not know (or ignore) this, which makes their code more verbose. Remember: &lt;code&gt;sizeof&lt;/code&gt; is not a function! :)&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;While moving &lt;code&gt;length&lt;/code&gt; to the front &lt;em&gt;may&lt;/em&gt; increase visibility in some rare cases, one should also pay attention that in the general case, it should be better to write the expression as:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *sieve = &lt;span class=&quot;hljs-built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; *sieve * length);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Since keeping the &lt;code&gt;sizeof&lt;/code&gt; first, in this case, ensures multiplication is done with at least &lt;code&gt;size_t&lt;/code&gt; math.&lt;/p&gt;\n&lt;p&gt;Compare: &lt;code&gt;malloc(sizeof *sieve * length * width)&lt;/code&gt; vs. &lt;code&gt;malloc(length * width * sizeof *sieve)&lt;/code&gt; the second may overflow the &lt;code&gt;length * width&lt;/code&gt; when &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;length&lt;/code&gt; are smaller types than &lt;code&gt;size_t&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;In C, you don&apos;t need to cast the return value of &lt;code&gt;malloc&lt;/code&gt;. The pointer to void returned by &lt;code&gt;malloc&lt;/code&gt; is automagically converted to the correct type. However, if you want your code to compile with a C++ compiler, a cast is needed. A preferred alternative among the community is to use the following:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *sieve = &lt;span class=&quot;hljs-built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; *sieve * length);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;which additionally frees you from having to worry about changing the right-hand side of the expression if ever you change the type of &lt;code&gt;sieve&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;Casts are bad, as people have pointed out. Especially pointer casts. &lt;/p&gt;\n    ","\n&lt;p&gt;You &lt;strong&gt;do&lt;/strong&gt; cast, because:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;It makes your code &lt;strong&gt;more portable&lt;/strong&gt; between C and C++, and as SO experience shows, a great many programmers claim they are writing in C when they are really writing in C++ (or C plus local compiler extensions).&lt;/li&gt;\n&lt;li&gt;Failing to do so &lt;strong&gt;can hide an error&lt;/strong&gt;: note all the SO examples of confusing when to write &lt;code&gt;type *&lt;/code&gt; versus &lt;code&gt;type **&lt;/code&gt;.&lt;/li&gt;\n&lt;li&gt;The idea that it keeps you from noticing you failed to &lt;code&gt;#include&lt;/code&gt; an appropriate header file misses &lt;strong&gt;the forest for the trees&lt;/strong&gt;. It&apos;s the same as saying &quot;don&apos;t worry about the fact you failed to ask the compiler to complain about not seeing prototypes -- that pesky stdlib.h is the REAL important thing to remember!&quot;&lt;/li&gt;\n&lt;li&gt;It forces an &lt;strong&gt;extra cognitive cross-check&lt;/strong&gt;. It puts the (alleged) desired type right next to the arithmetic you&apos;re doing for the raw size of that variable. I bet you could do an SO study that shows that &lt;code&gt;malloc()&lt;/code&gt; bugs are caught much faster when there&apos;s a cast. As with assertions, annotations that reveal intent decrease bugs. &lt;/li&gt;\n&lt;li&gt;Repeating yourself in a way that the machine can check is often a &lt;strong&gt;great&lt;/strong&gt; idea. In fact, that&apos;s what an assertion is, and this use of cast is an assertion. Assertions are still the most general technique we have for getting code correct, since Turing came up with the idea so many years ago.&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;As others stated, it is not needed for C, but necessary for C++. If you think you are going to compile your C code with a C++ compiler, for whatever reasons, you can use a macro instead, like:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;ifdef&lt;/span&gt; __cplusplus&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;# &lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; NEW(type, count) ((type *)calloc(count, sizeof(type)))&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;# &lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; NEW(type, count) (calloc(count, sizeof(type)))&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;That way you can still write it in a very compact way:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *sieve = NEW(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and it will compile for C and C++.&lt;/p&gt;\n    ","\n&lt;p&gt;From the &lt;a href=&quot;https://en.wikipedia.org/wiki/C_dynamic_memory_allocation#Advantages_to_casting&quot; rel=&quot;noreferrer&quot;&gt;Wikipedia&lt;/a&gt;:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;&lt;strong&gt;Advantages to casting&lt;/strong&gt;&lt;/p&gt;\n  \n  &lt;ul&gt;\n  &lt;li&gt;&lt;p&gt;Including the cast may allow a C program or function to compile as C++.&lt;/p&gt;&lt;/li&gt;\n  &lt;li&gt;&lt;p&gt;The cast allows for pre-1989 versions of malloc that originally returned a char *.&lt;/p&gt;&lt;/li&gt;\n  &lt;li&gt;&lt;p&gt;Casting can help the developer identify inconsistencies in type sizing should the destination pointer type change, particularly if the pointer is declared far from the malloc() call (although modern compilers and static analyzers can warn on such behaviour without requiring the cast).&lt;/p&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n  \n  &lt;p&gt;&lt;strong&gt;Disadvantages to casting&lt;/strong&gt;&lt;/p&gt;\n  \n  &lt;ul&gt;\n  &lt;li&gt;&lt;p&gt;Under the ANSI C standard, the cast is redundant.&lt;/p&gt;&lt;/li&gt;\n  &lt;li&gt;&lt;p&gt;Adding the cast may mask failure to include the header &lt;em&gt;stdlib.h&lt;/em&gt;, in\n  which the prototype for malloc is found. In the absence of a\n  prototype for malloc, the standard requires that the C compiler\n  assume malloc returns an int. If there is no cast, a warning is\n  issued when this integer is assigned to the pointer; however, with\n  the cast, this warning is not produced, hiding a bug. On certain\n  architectures and data models (such as LP64 on 64-bit systems, where\n  long and pointers are 64-bit and int is 32-bit), this error can\n  actually result in undefined behaviour, as the implicitly declared\n  malloc returns a 32-bit value whereas the actually defined function\n  returns a 64-bit value. Depending on calling conventions and memory\n  layout, this may result in stack smashing. This issue is less likely\n  to go unnoticed in modern compilers, as they uniformly produce\n  warnings that an undeclared function has been used, so a warning will\n  still appear. For example, GCC&apos;s default behaviour is to show a\n  warning that reads &quot;incompatible implicit declaration of built-in\n  function&quot; regardless of whether the cast is present or not.&lt;/p&gt;&lt;/li&gt;\n  &lt;li&gt;&lt;p&gt;If the type of the pointer is changed at its declaration, one may\n  also, need to change all lines where malloc is called and cast.&lt;/p&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Although &lt;strong&gt;malloc without casting is preferred method and most experienced programmers choose it&lt;/strong&gt;, you should use whichever you like having aware of the issues.&lt;/p&gt;\n\n&lt;p&gt;i.e: If you need to compile C program as C++ (Although it is a separate language) you must cast the result of use &lt;code&gt;malloc&lt;/code&gt;. &lt;/p&gt;\n    ","\n&lt;p&gt;In C you can implicitly convert a &lt;code&gt;void&lt;/code&gt; pointer to any other kind of pointer, so a cast is not necessary. Using one may suggest to the casual observer that there is some reason why one is needed, which may be misleading.&lt;/p&gt;\n    ","\n&lt;p&gt;You don&apos;t cast the result of &lt;code&gt;malloc&lt;/code&gt;, because doing so adds pointless clutter to your code.&lt;/p&gt;\n&lt;p&gt;The most common reason why people cast the result of &lt;code&gt;malloc&lt;/code&gt; is because they are unsure about how the C language works. That&apos;s a warning sign: if you don&apos;t know how a particular language mechanism works, then &lt;em&gt;don&apos;t&lt;/em&gt; take a guess. Look it up or ask on Stack Overflow.&lt;/p&gt;\n&lt;p&gt;Some comments:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;A void pointer can be converted to/from any other pointer type without an explicit cast (C11 6.3.2.3 and 6.5.16.1).&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;C++ will however not allow an implicit cast between &lt;code&gt;void*&lt;/code&gt; and another pointer type. So in C++, the cast would have been correct. But if you program in C++, you should use &lt;code&gt;new&lt;/code&gt; and not &lt;code&gt;malloc()&lt;/code&gt;. And you should never compile C code using a C++ compiler.&lt;/p&gt;\n&lt;p&gt;If you need to support both C and C++ with the same source code, use compiler switches to mark the differences. Do not attempt to sate both language standards with the same code, because they are not compatible.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;If a C compiler cannot find a function because you forgot to include the header, you will get a compiler/linker error about that. So if you forgot to include &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; that&apos;s no biggie, you won&apos;t be able to build your program.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;On ancient compilers that follow a version of the standard which is more than 25 years old, forgetting to include &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; would result in dangerous behavior. Because in that ancient standard, functions without a visible prototype implicitly converted the return type to &lt;code&gt;int&lt;/code&gt;. Casting the result from &lt;code&gt;malloc&lt;/code&gt; explicitly would then hide away this bug.&lt;/p&gt;\n&lt;p&gt;But that is really a non-issue. You aren&apos;t using a 25 years old computer, so why would you use a 25 years old compiler?&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;In C you get an implicit conversion from &lt;code&gt;void *&lt;/code&gt; to any other (data) pointer.&lt;/p&gt;\n    ","\n&lt;p&gt;Casting the value returned by &lt;code&gt;malloc()&lt;/code&gt; is not necessary now, but I&apos;d like to add one point that seems no one has pointed out:&lt;/p&gt;\n\n&lt;p&gt;In the ancient days, that is, before &lt;strong&gt;ANSI C&lt;/strong&gt; provides the &lt;code&gt;void *&lt;/code&gt; as the generic type of pointers, &lt;code&gt;char *&lt;/code&gt; is the type for such usage. In that case, the cast can shut down the compiler warnings.&lt;/p&gt;\n\n&lt;p&gt;Reference: &lt;a href=&quot;http://c-faq.com/malloc/cast.html&quot; rel=&quot;noreferrer&quot;&gt;C FAQ&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Just adding my experience, studying computer engineering I see that the two or three professors that I have seen writing in C always cast malloc, however the one I asked (with an immense CV and understanding of C) told me that it is absolutely unnecessary but only used to be absolutely specific, and to get the students into the mentality of being absolutely specific. Essentially casting will not change anything in how it works, it does exactly what it says, allocates memory, and casting does not effect it, you get the same memory, and even if you cast it to something else by mistake (and somehow evade compiler errors) C will access it the same way.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; Casting has a certain point. When you use array notation, the code generated has to know how many memory places it has to advance to reach the beginning of the next element, this is achieved through casting. This way you know that for a double you go 8 bytes ahead while for an int you go 4, and so on. Thus it has no effect if you use pointer notation, in array notation it becomes necessary.&lt;/p&gt;\n    ","\n&lt;p&gt;It is not mandatory to cast the results of &lt;code&gt;malloc&lt;/code&gt;, since it returns &lt;code&gt;void*&lt;/code&gt; , and a &lt;code&gt;void*&lt;/code&gt; can be pointed to any datatype. &lt;/p&gt;\n    ","\n&lt;p&gt;This is what &lt;a href=&quot;http://www.gnu.org/software/libc/manual/html_node/Basic-Allocation.html&quot; rel=&quot;noreferrer&quot;&gt;The GNU C Library Reference&lt;/a&gt; manual says: &lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;You can store the result of &lt;code&gt;malloc&lt;/code&gt; into any pointer variable without a\n  cast, because ISO C automatically converts the type &lt;code&gt;void *&lt;/code&gt; to another\n  type of pointer when necessary. But the cast is necessary in contexts\n  other than assignment operators or if you might want your code to run\n  in traditional C.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;And indeed the &lt;a href=&quot;http://www.compsci.hunter.cuny.edu/~sweiss/resources/c11standard.pdf&quot; rel=&quot;noreferrer&quot;&gt;ISO C11 standard&lt;/a&gt; (p347) says so: &lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;The pointer returned if the allocation succeeds is suitably aligned so\n  that it may be assigned to a pointer to any type of object with a\n  fundamental alignment requirement and then used to access such an\n  object or an array of such objects in the space allocated (until the\n  space is explicitly deallocated)&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;A void pointer is a generic object pointer and C supports implicit conversion from a void pointer type to other types, so there is no need of explicitly typecasting it.&lt;/p&gt;\n\n&lt;p&gt;However, if you want the same code work perfectly compatible on a C++ platform, which does not support implicit conversion, you need to do the typecasting, so it all depends on usability.&lt;/p&gt;\n    ","\n&lt;p&gt;The returned type is void*, which can be cast to the desired type of data pointer in order to be dereferenceable.&lt;/p&gt;\n    ","\n&lt;p&gt;It depends on the programming language and compiler. If you use &lt;code&gt;malloc&lt;/code&gt; in C, there is no need to type cast it, as it will automatically type cast. However, if you are using C++, then you should type cast because &lt;code&gt;malloc&lt;/code&gt; will return a &lt;code&gt;void*&lt;/code&gt; type.&lt;/p&gt;\n    ","\n&lt;p&gt;In the C language, a void pointer can be assigned to any pointer, which is why you should not use a type cast. If you want &quot;type safe&quot; allocation, I can recommend the following macro functions, which I always use in my C projects:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; NEW_ARRAY(ptr, n) (ptr) = malloc((n) * sizeof *(ptr))&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; NEW(ptr) NEW_ARRAY((ptr), 1)&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;With these in place you can simply say&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;NEW_ARRAY(sieve, length);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;For non-dynamic arrays, the third must-have function macro is&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; LEN(arr) (sizeof (arr) / sizeof (arr)[0])&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;which makes array loops safer and more convenient:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i, a[&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;];\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; LEN(a); i++) {\n   ...\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;People used to GCC and Clang are spoiled.  It&apos;s not all that good out there.&lt;/p&gt;\n\n&lt;p&gt;I have been pretty horrified over the years by the staggeringly aged compilers I&apos;ve been required to use.  Often companies and managers adopt an ultra-conservative approach to changing compilers and will not even &lt;em&gt;test&lt;/em&gt; if a new compiler ( with better standards compliance and code optimization ) will work in their system.  The practical reality for working developers is that when you&apos;re coding you need to cover your bases and, unfortunately, casting mallocs is a good habit if you cannot control what compiler may be applied to your code.&lt;/p&gt;\n\n&lt;p&gt;I would also suggest that many organizations apply a coding standard of their own and that &lt;em&gt;that&lt;/em&gt; should be the method people follow if it is defined.  In the absence of explicit guidance I tend to go for most likely to compile everywhere, rather than slavish adherence to a standard.&lt;/p&gt;\n\n&lt;p&gt;The argument that it&apos;s not necessary under current standards is quite valid.  But that argument omits the practicalities of the real world.  We do not code in a world ruled exclusively by the standard of the day, but by the practicalities of what I like to call &quot;local management&apos;s reality field&quot;.  And that&apos;s bent and twisted more than space time ever was. :-)&lt;/p&gt;\n\n&lt;p&gt;YMMV.&lt;/p&gt;\n\n&lt;p&gt;I tend to think of casting malloc as a defensive operation.  Not pretty, not perfect, but generally safe.  ( Honestly, if you&apos;ve not included stdlib.h then you&apos;ve &lt;em&gt;way&lt;/em&gt; more problems than casting malloc ! ).&lt;/p&gt;\n    ","\n&lt;h1&gt;&lt;strong&gt;This question is subject of opinion-based abuse.&lt;/strong&gt;&lt;/h1&gt;\n&lt;p&gt;Sometimes I notice comments like that:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc&quot;&gt;Don&apos;t cast the result of malloc&lt;/a&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;or&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc&quot;&gt;Why you don&apos;t cast the result of malloc&lt;/a&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;on questions where OP uses casting. The comments itself contain a hyperlink to this question.&lt;/p&gt;\n&lt;p&gt;That is in &lt;em&gt;any&lt;/em&gt; possible manner inappropriate and incorrect as well. There is no right and no wrong when it is truly a matter of one&apos;s own coding-style.&lt;/p&gt;\n&lt;hr&gt;\n&lt;h3&gt;Why is this happening?&lt;/h3&gt;\n&lt;p&gt;It&apos;s based upon two reasons:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;This question is indeed opinion-based. Technically, the question should have been closed as opinion-based years ago. A &quot;&lt;em&gt;Do I&lt;/em&gt;&quot; or &quot;&lt;em&gt;Don&apos;t I&lt;/em&gt;&quot; or equivalent &quot;&lt;em&gt;Should I&lt;/em&gt;&quot; or &quot;&lt;em&gt;Shouldn&apos;t I&lt;/em&gt;&quot; question, you just can&apos;t answer focused without an attitude of one&apos;s own opinion. One of the reason to close a question is because it &quot;might lead to opinion-based answers&quot; as it is well shown here.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Many answers (including the most apparent and accepted &lt;a href=&quot;https://stackoverflow.com/a/605858/12139179&quot;&gt;answer&lt;/a&gt; of &lt;a href=&quot;https://stackoverflow.com/users/28169/unwind&quot;&gt;@unwind&lt;/a&gt;) are either completely or almost entirely opinion-based (f.e. a mysterious &quot;clutter&quot; that would be added to your code if you do casting or repeating yourself would be bad) and show a clear and focused tendency to omit the cast. They argue about the redundancy of the cast on one side but also and even worse argue to solve a bug caused by a bug/failure of programming itself - to not &lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/code&gt; if one want to use &lt;code&gt;malloc()&lt;/code&gt;.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;hr&gt;\n&lt;p&gt;I want to bring a true view of some points discussed, with less of my personal opinion. A few points need to be noted especially:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;Such a very susceptible question to fall into one&apos;s own opinion needs an answer with neutral pros and cons. Not only cons or pros.&lt;/p&gt;\n&lt;p&gt;A good overview of pros and cons is listed in this answer:&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/a/33047365/12139179&quot;&gt;https://stackoverflow.com/a/33047365/12139179&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;(I personally consider this because of that reason the best answer, so far.)&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;hr&gt;\n&lt;ol start=&quot;2&quot;&gt;\n&lt;li&gt;&lt;p&gt;One reason which is encountered at most to reason the omission of the cast is that the cast might hide a bug.&lt;/p&gt;\n&lt;p&gt;If someone uses an implicit declared &lt;code&gt;malloc()&lt;/code&gt; that returns &lt;code&gt;int&lt;/code&gt; (implicit functions are gone from the standard since C99) and &lt;code&gt;sizeof(int) != sizeof(int*)&lt;/code&gt;, as shown in this question&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/q/7545365/168175&quot;&gt;Why does this code segfault on 64-bit architecture but work fine on 32-bit?&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;the cast would hide a bug.&lt;/p&gt;\n&lt;p&gt;While this is true, it only shows half of the story as the omission of the cast would only be a forward-bringing solution to an even bigger bug - not including &lt;code&gt;stdlib.h&lt;/code&gt; when using &lt;code&gt;malloc()&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;This will never be a serious issue, If you,&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;Use a compiler compliant to C99 or above (which is recommended and should be mandatory), and&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Aren&apos;t so absent to forgot to include &lt;code&gt;stdlib.h&lt;/code&gt;, when you want to use &lt;code&gt;malloc()&lt;/code&gt; in your code, which is a huge bug itself.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;hr&gt;\n&lt;ol start=&quot;3&quot;&gt;\n&lt;li&gt;&lt;p&gt;Some people argue about C++ compliance of C code, as the cast is obliged in C++.&lt;/p&gt;\n&lt;p&gt;First of all to say in general: Compiling C code with a C++ compiler is not a good practice.&lt;/p&gt;\n&lt;p&gt;C and C++ are in fact two completely different languages with different semantics.&lt;/p&gt;\n&lt;p&gt;But If you really want/need to make C code compliant to C++ and vice versa use compiler switches instead of any cast.&lt;/p&gt;\n&lt;p&gt;Since the cast is with tendency declared as redundant or even harmful, I want to take a focus on these questions, which give good reasons why casting can be useful or even necessary:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/a/34094068/12139179&quot;&gt;https://stackoverflow.com/a/34094068/12139179&lt;/a&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/a/36297486/12139179&quot;&gt;https://stackoverflow.com/a/36297486/12139179&lt;/a&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/a/33044300/12139179&quot;&gt;https://stackoverflow.com/a/33044300/12139179&lt;/a&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;hr&gt;\n&lt;ol start=&quot;4&quot;&gt;\n&lt;li&gt;The cast can be non-beneficial when your code, respectively the type of the assigned pointer (and with that the type of the cast), changes, although this is in most cases unlikely. Then you would need to maintain/change all casts too and if you have a few thousand calls to memory-management functions in your code, this can really summarizing up and decrease the maintenance efficiency.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;hr&gt;\n&lt;h3&gt;Summary:&lt;/h3&gt;\n&lt;p&gt;Fact is, that the cast is redundant per the C standard (already since ANSI-C (C89/C90)) if the assigned pointer point to an object of fundamental alignment requirement (which includes the most of all objects).&lt;/p&gt;\n&lt;p&gt;You don&apos;t need to do the cast as the pointer is automatically aligned in this case:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&quot;The order and contiguity of storage allocated by successive calls to the aligned_alloc, calloc, malloc, and realloc functions is unspecified. &lt;strong&gt;The pointer returned if the allocation succeeds is suitably aligned so that it may be assigned to a pointer to any type of object with a fundamental alignment requirement&lt;/strong&gt; and then used to access such an object or an array of such objects in the space allocated (until the space is explicitly deallocated).&quot;&lt;/p&gt;\n&lt;p&gt;Source: C18, ยง7.22.3/1&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;hr&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&quot;A &lt;em&gt;fundamental alignment&lt;/em&gt; is a valid alignment less than or equal to &lt;code&gt;_Alignof (max_align_t)&lt;/code&gt;. Fundamental alignments shall be supported by the implementation for objects of all storage durations. The alignment requirements of the following types shall be fundamental alignments:&lt;/p&gt;\n&lt;p&gt;  all atomic, qualified, or unqualified basic types;&lt;/p&gt;\n&lt;p&gt;  all atomic, qualified, or unqualified enumerated types;&lt;/p&gt;\n&lt;p&gt;  all atomic, qualified, or unqualified pointer types;&lt;/p&gt;\n&lt;p&gt;  all array types whose element type has a fundamental alignment requirement;57)&lt;/p&gt;\n&lt;p&gt;  all types specified in Clause 7 as complete object types;&lt;/p&gt;\n&lt;p&gt;  all structure or union types all of whose elements have types with fundamental alignment requirements and none of whose elements have an alignment specifier specifying an alignment that is not a fundamental alignment.&lt;/p&gt;\n&lt;ol start=&quot;57&quot;&gt;\n&lt;li&gt;As specified in 6.2.1, the later declaration might hide the prior declaration.&quot;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;Source: C18, ยง6.2.8/2&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;However, if you allocate memory for an implementation-defined object of extended alignment requirement, the cast would be needed.&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;An &lt;em&gt;extended alignment&lt;/em&gt; is represented by an alignment greater than &lt;code&gt;_Alignof (max_align_t)&lt;/code&gt;. It is implementation-defined whether any extended alignments are supported and the storage durations for which they are supported. A type having an extended alignment requirement is an over-aligned type.58)&lt;/p&gt;\n&lt;p&gt;Source. C18, ยง6.2.8/3&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Everything else is a matter of the specific use case and one&apos;s own opinion.&lt;/p&gt;\n&lt;p&gt;Please be careful how you educate yourself.&lt;/p&gt;\n&lt;p&gt;I recommend you to read &lt;em&gt;all&lt;/em&gt; of the answers made so far carefully first (as well as their comments which may point at a failure) and then build your own opinion if you or if you not cast the result of &lt;code&gt;malloc()&lt;/code&gt; at a specific case.&lt;/p&gt;\n&lt;p&gt;Please note:&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;There is no right and wrong answer to that question. It is a matter of style and you yourself decide which way you choose (if you aren&apos;t forced to by education or job of course). Please be aware of that and don&apos;t let trick you&lt;/strong&gt;.&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;Last note: I voted to lately close this question as opinion-based, which is indeed needed since years. If you got the close/reopen privilege I would like to invite you to do so, too.&lt;/p&gt;\n    ","\n&lt;h2&gt;No, you don&apos;t cast the result of &lt;code&gt;malloc()&lt;/code&gt;.&lt;/h2&gt;\n\n&lt;p&gt;In general, you &lt;strong&gt;don&apos;t cast to or from &lt;code&gt;void *&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;\n\n&lt;p&gt;A typical reason given for not doing so is that failure to &lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/code&gt; could go unnoticed. This isn&apos;t an issue anymore for a long time now as C99 made &lt;em&gt;implicit function declarations&lt;/em&gt; illegal, so if your compiler conforms to at least C99, you will get a diagnostic message.&lt;/p&gt;\n\n&lt;p&gt;But there&apos;s a &lt;strong&gt;much stronger reason&lt;/strong&gt; not to introduce unnecessary pointer casts:&lt;/p&gt;\n\n&lt;p&gt;In C, a &lt;strong&gt;pointer cast is almost always an error&lt;/strong&gt;. This is because of the following rule (&lt;strong&gt;ยง6.5 p7&lt;/strong&gt; in N1570, the latest draft for C11):&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;An object shall have its stored value accessed only by an lvalue expression that has one of\n  the following types:&lt;br&gt;\n   a type compatible with the effective type of the object,&lt;br&gt;\n   a qualified version of a type compatible with the effective type of the object,&lt;br&gt;\n   a type that is the signed or unsigned type corresponding to the effective type of the\n  object,&lt;br&gt;\n   a type that is the signed or unsigned type corresponding to a qualified version of the\n  effective type of the object,&lt;br&gt;\n   an aggregate or union type that includes one of the aforementioned types among its\n  members (including, recursively, a member of a subaggregate or contained union), or&lt;br&gt;\n   a character type.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;This is also known as the &lt;em&gt;strict aliasing rule&lt;/em&gt;. So the following code is &lt;em&gt;undefined behavior&lt;/em&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;long&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; *p = (&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; *)&amp;amp;x;\n&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; y = *p;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And, sometimes surprisingly, the following is as well:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt; {&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x; };\n&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;bar&lt;/span&gt; {&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; y; };\n&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;b&lt;/span&gt; =&lt;/span&gt; { &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;};\n&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt; *&lt;span class=&quot;hljs-title&quot;&gt;p&lt;/span&gt; =&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; foo *)&amp;amp;b;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; z = p-&amp;gt;x;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Sometimes, you &lt;strong&gt;do&lt;/strong&gt; need to cast pointers, but given the &lt;em&gt;strict aliasing rule&lt;/em&gt;, you have to be very careful with it. So, any occurrence of a pointer cast in your code is a place you &lt;strong&gt;have to double-check for its validity&lt;/strong&gt;. Therefore, you never write an unnecessary pointer cast.&lt;/p&gt;\n\n&lt;h3&gt;tl;dr&lt;/h3&gt;\n\n&lt;p&gt;In a nutshell: Because in C, &lt;strong&gt;any&lt;/strong&gt; occurrence of a &lt;em&gt;pointer cast&lt;/em&gt; should raise a red flag for code requiring special attention, you should never write &lt;em&gt;unnecessary&lt;/em&gt; pointer casts.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;Side notes:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;There are cases where you actually &lt;em&gt;need&lt;/em&gt; a cast to &lt;code&gt;void *&lt;/code&gt;, e.g. if you want to print a pointer:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%p\\n&quot;&lt;/span&gt;, (&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; *)&amp;amp;x);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The cast is necessary here, because &lt;code&gt;printf()&lt;/code&gt; is a variadic function, so implicit conversions don&apos;t work.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;In C++, the situation is different. Casting pointer types is somewhat common (and correct) when dealing with objects of derived classes. Therefore, it makes sense that in C++, the conversion to and from &lt;code&gt;void *&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; implicit. C++ has a whole set of different flavors of casting.&lt;/p&gt;&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;I put in the cast simply to show disapproval of the ugly hole in the type system, which allows code such as the following snippet to compile without diagnostics, even though no casts are used to bring about the bad conversion:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; d;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; *p = &amp;amp;d;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *q = p;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I wish that didn&apos;t exist (and it doesn&apos;t in C++) and so I cast. It represents my taste, and my programming politics. I&apos;m not only casting a pointer, but effectively, casting a ballot, and &lt;a href=&quot;http://dilbert.com/strip/1994-02-03&quot;&gt;casting out demons of stupidity&lt;/a&gt;. If I can&apos;t &lt;em&gt;actually&lt;/em&gt; &lt;a href=&quot;http://dilbert.com/strip/1994-02-02&quot;&gt;cast out stupidity&lt;/a&gt;, then at least let me express the wish to do so with a gesture of protest.&lt;/p&gt;\n\n&lt;p&gt;In fact, a good practice is to wrap &lt;code&gt;malloc&lt;/code&gt; (and friends) with functions that return &lt;code&gt;unsigned char *&lt;/code&gt;, and basically never to use &lt;code&gt;void *&lt;/code&gt; in your code.  If you need a generic pointer-to-any-object, use a &lt;code&gt;char *&lt;/code&gt; or &lt;code&gt;unsigned char *&lt;/code&gt;, and have casts in both directions. The one relaxation that can be indulged, perhaps, is using functions like &lt;code&gt;memset&lt;/code&gt; and &lt;code&gt;memcpy&lt;/code&gt; without casts.&lt;/p&gt;\n\n&lt;p&gt;On the topic of casting and C++ compatibility, if you write your code so that it compiles as both C and C++ (in which case you &lt;em&gt;have to&lt;/em&gt; cast the return value of &lt;code&gt;malloc&lt;/code&gt; when assigning it to something other than &lt;code&gt;void *&lt;/code&gt;), you can do a very helpful thing for yourself: you can use macros for casting which translate to C++ style casts when compiling as C++, but reduce to a C cast when compiling as C:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;/* In a header somewhere */&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;ifdef&lt;/span&gt; __cplusplus&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; strip_qual(TYPE, EXPR) (const_cast&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;TYPE&amp;gt;&lt;/span&gt;(EXPR))&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; convert(TYPE, EXPR) (static_cast&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;TYPE&amp;gt;&lt;/span&gt;(EXPR))&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; coerce(TYPE, EXPR) (reinterpret_cast&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;TYPE&amp;gt;&lt;/span&gt;(EXPR))&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; strip_qual(TYPE, EXPR) ((TYPE) (EXPR))&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; convert(TYPE, EXPR) ((TYPE) (EXPR))&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; coerce(TYPE, EXPR) ((TYPE) (EXPR))&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;If you adhere to these macros, then a simple &lt;code&gt;grep&lt;/code&gt; search of your code base for these identifiers will show you where all your casts are, so you can review whether any of them are incorrect.&lt;/p&gt;\n\n&lt;p&gt;Then, going forward, if you regularly compile the code with C++, it will enforce the use of an appropriate cast. For instance, if you use &lt;code&gt;strip_qual&lt;/code&gt; just to remove a &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;volatile&lt;/code&gt;, but the program changes in such a way that a type conversion is now involved, you will get a diagnostic, and you will have to use a combination of casts to get the desired conversion.&lt;/p&gt;\n\n&lt;p&gt;To help you adhere to these macros, the the GNU C++ (not C!) compiler has a beautiful feature: an optional diagnostic which is produced for all occurrences of C style casts.&lt;/p&gt;\n\n&lt;pre&gt;     -Wold-style-cast (C++ and Objective-C++ only)\n         Warn if an old-style (C-style) cast to a non-void type is used\n         within a C++ program.  The new-style casts (dynamic_cast,\n         static_cast, reinterpret_cast, and const_cast) are less vulnerable\n         to unintended effects and much easier to search for.\n&lt;/pre&gt;\n\n&lt;p&gt;If your C code compiles as C++, you can use this &lt;code&gt;-Wold-style-cast&lt;/code&gt; option to find out all occurrences of the &lt;code&gt;(type)&lt;/code&gt; casting syntax that may creep into the code, and follow up on these diagnostics by replacing it with an appropriate choice from among the above macros (or a combination, if necessary).&lt;/p&gt;\n\n&lt;p&gt;This treatment of conversions is the single largest standalone technical justification for working in a &quot;Clean C&quot;: the combined C and C++ dialect, which in turn technically justifies casting the return value of &lt;code&gt;malloc&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;The best thing to do when programming in C whenever it is possible:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;Make your program compile through a C compiler with all warnings turned on &lt;code&gt;-Wall&lt;/code&gt; and fix all errors and warnings&lt;/li&gt;\n&lt;li&gt;Make sure there are no variables declared as &lt;code&gt;auto&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;Then compile it using a C++ compiler with &lt;code&gt;-Wall&lt;/code&gt; and &lt;code&gt;-std=c++11&lt;/code&gt;. Fix all errors and warnings.&lt;/li&gt;\n&lt;li&gt;Now compile using the C compiler again. Your program should now compile without any warning and contain fewer bugs.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;This procedure lets you take advantage of C++ strict type checking, thus reducing the number of bugs. In particular, this procedure forces you to include &lt;code&gt;stdlib.h&lt;/code&gt;or you will get&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;&lt;code&gt;malloc&lt;/code&gt; was not declared within this scope&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;and also forces you to cast the result of &lt;code&gt;malloc&lt;/code&gt; or you will get&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;invalid conversion from &lt;code&gt;void*&lt;/code&gt; to &lt;code&gt;T*&lt;/code&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;or what ever your target type is.&lt;/p&gt;\n\n&lt;p&gt;The only benefits from writing in C instead of C++ I can find are&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;C has a well specified ABI&lt;/li&gt;\n&lt;li&gt;C++ may generate more code [exceptions, RTTI, templates, &lt;em&gt;runtime&lt;/em&gt; polymorphism]&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;Notice that the second cons should in the ideal case disappear when using the subset common to C together with the &lt;em&gt;static&lt;/em&gt; polymorphic feature.&lt;/p&gt;\n\n&lt;p&gt;For those that finds C++ strict rules inconvenient, we can use the C++11 feature with inferred  type&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; memblock=static_cast&amp;lt;T*&amp;gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;malloc&lt;/span&gt;(n*&lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(T))); &lt;span class=&quot;hljs-comment&quot;&gt;//Mult may overflow...&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I prefer to do the cast, but not manually. My favorite is using &lt;code&gt;g_new&lt;/code&gt; and &lt;code&gt;g_new0&lt;/code&gt; macros from glib. If glib is not used, I would add similar macros. Those macros reduce code duplication without compromising type safety. If you get the type wrong, you would get an implicit cast between non-void pointers, which would cause a warning (error in C++). If you forget to include the header that defines &lt;code&gt;g_new&lt;/code&gt; and &lt;code&gt;g_new0&lt;/code&gt;, you would get an error. &lt;code&gt;g_new&lt;/code&gt; and &lt;code&gt;g_new0&lt;/code&gt; both take the same arguments, unlike &lt;code&gt;malloc&lt;/code&gt; that takes fewer arguments than &lt;code&gt;calloc&lt;/code&gt;. Just add &lt;code&gt;0&lt;/code&gt; to get zero-initialized memory. The code can be compiled with a C++ compiler without changes.&lt;/p&gt;\n    ","\n&lt;p&gt;Casting is only for C++ not C.In case you are using a C++ compiler you better change it to C compiler.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;The casting of malloc is unnecessary in C but mandatory in C++.&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Casting is unnecessary in C because of:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;void *&lt;/code&gt; is automatically and safely promoted to any other pointer type in the case of C.&lt;/li&gt;\n&lt;li&gt;It can hide an error if you forgot to include &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;. This can cause crashes.&lt;/li&gt;\n&lt;li&gt;If pointers and integers are differently sized, then you&apos;re hiding a warning by casting and might lose bits of your returned address.&lt;/li&gt;\n&lt;li&gt;If the type of the pointer is changed at its declaration, one may also need to change all lines where &lt;code&gt;malloc&lt;/code&gt; is called and cast.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;On the other hand, casting may increase the portability of your program. i.e, it allows a C program or function to compile as C++.&lt;/p&gt;\n    ","\n&lt;p&gt;The concept behind void pointer is that it can be casted to any data type that is why malloc returns void. Also you must be aware of automatic typecasting. So it is not mandatory to cast the pointer though you must do it. It helps in keeping the code clean and helps debugging&lt;/p&gt;\n    ","\n&lt;p&gt;A void pointer is a generic pointer and C supports implicit conversion from a void pointer type to other types, so there is no need of explicitly typecasting it.&lt;/p&gt;\n\n&lt;p&gt;However, if you want the same code work perfectly compatible on a C++ platform, which does not support implicit conversion, you need to do the typecasting, so it all depends on usability.&lt;/p&gt;\n    ","\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;As other stated, it is not needed for C, but for C++.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Including the cast may allow a C program or function to compile as C++.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;In C it is unnecessary, as void * is automatically and safely promoted to any other pointer type.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;But if you cast then, it can hide an error if you forgot to include\n&lt;strong&gt;stdlib.h&lt;/strong&gt;. This can cause crashes (or, worse, not cause a crash\nuntil way later in some totally different part of the code).&lt;/p&gt;\n\n&lt;p&gt;Because &lt;strong&gt;stdlib.h&lt;/strong&gt; contains the prototype for malloc is found. In the\nabsence of a prototype for malloc, the standard requires that the C\ncompiler assumes malloc returns an int. If there is no cast, a\nwarning is issued when this integer is assigned to the pointer;\nhowever, with the cast, this warning is not produced, hiding a bug.&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n    ","\n&lt;p&gt;The main issue with &lt;code&gt;malloc&lt;/code&gt; is to get the &lt;em&gt;right size&lt;/em&gt;.&lt;/p&gt;\n&lt;p&gt;The memory returned form &lt;code&gt;malloc()&lt;/code&gt; is &lt;em&gt;untyped&lt;/em&gt;, and it will not magically gain an &lt;em&gt;effective type&lt;/em&gt; due to a simple cast.&lt;/p&gt;\n&lt;p&gt;I guess that both approaches are fine and the choice should depend on programmer intention.&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;If allocating memory for a &lt;strong&gt;type&lt;/strong&gt;, then use a cast.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;&lt;code&gt;ptr = (T*)malloc(sizeof(T));&lt;/code&gt;&lt;/p&gt;\n&lt;ol start=&quot;2&quot;&gt;\n&lt;li&gt;If allocating memory for a given pointer, then don&apos;t use a cast.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;&lt;code&gt;ptr = malloc(sizeof *ptr);&lt;/code&gt;&lt;/p&gt;\n&lt;h3&gt;Ad 1&lt;/h3&gt;\n&lt;p&gt;The first method assures the correct size by allocating memory for a given type, and then casting it to assure that it is assigned to the right pointer. If incorrect type of &lt;code&gt;ptr&lt;/code&gt; is used then the compiler will issue a warning/error. If the type of &lt;code&gt;ptr&lt;/code&gt; is changed, then the compiler will point the places where the code needs refactoring.&lt;/p&gt;\n&lt;p&gt;Moreover, the first method can be combined into a macro similar to &lt;code&gt;new&lt;/code&gt; operator in C++.&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; NEW(T) ((T*)malloc(sizeof(T)))&lt;/span&gt;\n...\nptr = NEW(T);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Moreover this method works if &lt;code&gt;ptr&lt;/code&gt; is &lt;code&gt;void*&lt;/code&gt;.&lt;/p&gt;\n&lt;h2&gt;Ad 2&lt;/h2&gt;\n&lt;p&gt;The second methods does not care about the types, it assures the correct size by taking it from the pointer&apos;s type. The main advantage of this method is the automatic adjustment of storage size whenever the type of &lt;code&gt;ptr&lt;/code&gt; is changed.\nIt can save some time (or errors) when refactoring.&lt;/p&gt;\n&lt;p&gt;The disadvantage is that the method does not work if &lt;code&gt;ptr&lt;/code&gt; is &lt;code&gt;void*&lt;/code&gt; but it may be perceived as a good thing. And that it does not work with C++ so it should not be used in inlined functions in headers that are going to be used by C++ programs.&lt;/p&gt;\n&lt;p&gt;Personally, I prefer the second option.&lt;/p&gt;\n    ","\n&lt;p&gt;For me, the take home and conclusion here is that casting &lt;code&gt;malloc&lt;/code&gt; in C is totally NOT necessary but if you however cast, it wont affect &lt;code&gt;malloc&lt;/code&gt; as &lt;code&gt;malloc&lt;/code&gt; will still allocate to you your requested blessed memory space.\nAnother take home is the reason or one of the reasons people do casting and this is to enable them compile same program either in C or C++.&lt;/p&gt;\n\n&lt;p&gt;There may be other reasons but other reasons, almost certainly, would land you in serious trouble sooner or later.&lt;/p&gt;\n    "]},"randomTags":[{"name":"dimension","slug":"dimension"},{"name":"dataframe","slug":"dataframe"},{"name":"hammingweight","slug":"hammingweight"},{"name":"python-3.x","slug":"python-3.x"},{"name":"variable-length","slug":"variable-length"},{"name":"unicode","slug":"unicode"},{"name":"immutability","slug":"immutability"},{"name":"preflight","slug":"preflight"},{"name":"collections","slug":"collections"},{"name":"undefined-reference","slug":"undefined-reference"},{"name":"dynamic-memory-allocation","slug":"dynamic-memory-allocation"},{"name":"abi","slug":"abi"},{"name":"firefox","slug":"firefox"},{"name":"computer-science","slug":"computer-science"},{"name":"file-io","slug":"file-io"},{"name":"static-files","slug":"static-files"},{"name":"siblings","slug":"siblings"},{"name":"prop","slug":"prop"},{"name":"z-index","slug":"z-index"},{"name":"benchmarking","slug":"benchmarking"}]},"__N_SSG":true}