{"pageProps":{"data":{"count":1,"rows":[{"id":285,"title":"Why can't I store a value and a reference to that value in the same struct?","slug":"why-can't-i-store-a-value-and-a-reference-to-that-value-in-the-same-struct-1657387506828","postType":"QUESTION","createdAt":"2022-07-09T17:25:06.000Z","updatedAt":"2022-07-09T17:25:06.000Z","tags":[{"id":1742,"name":"lifetime","slug":"lifetime","createdAt":"2022-07-09T17:25:06.000Z","updatedAt":"2022-07-09T17:25:06.000Z","Questions_Tags":{"questionId":285,"tagId":1742}}]}]},"slug":"lifetime","page":"1","answers":{"285":["\n&lt;p&gt;Let&apos;s look at &lt;a href=&quot;https://play.rust-lang.org/?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=c1432ed38048684c7eb306540c182cd0&quot; rel=&quot;noreferrer&quot;&gt;a simple implementation of this&lt;/a&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-rust s-code-block&quot;&gt;&lt;code class=&quot;hljs language-rust&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Parent&lt;/span&gt; {\n    count: &lt;span class=&quot;hljs-type&quot;&gt;u32&lt;/span&gt;,\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Child&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;a&lt;/span&gt;&amp;gt; {\n    parent: &amp;amp;&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;a&lt;/span&gt; Parent,\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Combined&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;a&lt;/span&gt;&amp;gt; {\n    parent: Parent,\n    child: Child&amp;lt;&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;a&lt;/span&gt;&amp;gt;,\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;impl&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;a&lt;/span&gt;&amp;gt; Combined&amp;lt;&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;a&lt;/span&gt;&amp;gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;new&lt;/span&gt;() &lt;span class=&quot;hljs-punctuation&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;Self&lt;/span&gt; {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;parent&lt;/span&gt; = Parent { count: &lt;span class=&quot;hljs-number&quot;&gt;42&lt;/span&gt; };\n        &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;child&lt;/span&gt; = Child { parent: &amp;amp;parent };\n\n        Combined { parent, child }\n    }\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;() {}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This will fail with the error:&lt;/p&gt;\n&lt;pre class=&quot;lang-none s-code-block&quot;&gt;&lt;code&gt;error[E0515]: cannot return value referencing local variable `parent`\n  --&amp;gt; src/main.rs:19:9\n   |\n17 |         let child = Child { parent: &amp;amp;parent };\n   |                                     ------- `parent` is borrowed here\n18 | \n19 |         Combined { parent, child }\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ returns a value referencing data owned by the current function\n\nerror[E0505]: cannot move out of `parent` because it is borrowed\n  --&amp;gt; src/main.rs:19:20\n   |\n14 | impl&amp;lt;&apos;a&amp;gt; Combined&amp;lt;&apos;a&amp;gt; {\n   |      -- lifetime `&apos;a` defined here\n...\n17 |         let child = Child { parent: &amp;amp;parent };\n   |                                     ------- borrow of `parent` occurs here\n18 | \n19 |         Combined { parent, child }\n   |         -----------^^^^^^---------\n   |         |          |\n   |         |          move out of `parent` occurs here\n   |         returning this value requires that `parent` is borrowed for `&apos;a`\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;To completely understand this error, you have to think about how the\nvalues are represented in memory and what happens when you &lt;em&gt;move&lt;/em&gt;\nthose values. Let&apos;s annotate &lt;code&gt;Combined::new&lt;/code&gt; with some hypothetical\nmemory addresses that show where values are located:&lt;/p&gt;\n&lt;pre class=&quot;lang-rust s-code-block&quot;&gt;&lt;code class=&quot;hljs language-rust&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;parent&lt;/span&gt; = Parent { count: &lt;span class=&quot;hljs-number&quot;&gt;42&lt;/span&gt; };\n&lt;span class=&quot;hljs-comment&quot;&gt;// `parent` lives at address 0x1000 and takes up 4 bytes&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// The value of `parent` is 42 &lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;child&lt;/span&gt; = Child { parent: &amp;amp;parent };\n&lt;span class=&quot;hljs-comment&quot;&gt;// `child` lives at address 0x1010 and takes up 4 bytes&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// The value of `child` is 0x1000&lt;/span&gt;\n         \nCombined { parent, child }\n&lt;span class=&quot;hljs-comment&quot;&gt;// The return value lives at address 0x2000 and takes up 8 bytes&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// `parent` is moved to 0x2000&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// `child` is ... ?&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;What should happen to &lt;code&gt;child&lt;/code&gt;? If the value was just moved like &lt;code&gt;parent&lt;/code&gt;\nwas, then it would refer to memory that no longer is guaranteed to\nhave a valid value in it. Any other piece of code is allowed to store\nvalues at memory address 0x1000. Accessing that memory assuming it was\nan integer could lead to crashes and/or security bugs, and is one of\nthe main categories of errors that Rust prevents.&lt;/p&gt;\n&lt;p&gt;This is exactly the problem that &lt;em&gt;lifetimes&lt;/em&gt; prevent. A lifetime is a\nbit of metadata that allows you and the compiler to know how long a\nvalue will be valid at its &lt;strong&gt;current memory location&lt;/strong&gt;. That&apos;s an\nimportant distinction, as it&apos;s a common mistake Rust newcomers make.\nRust lifetimes are &lt;em&gt;not&lt;/em&gt; the time period between when an object is\ncreated and when it is destroyed!&lt;/p&gt;\n&lt;p&gt;As an analogy, think of it this way: During a person&apos;s life, they will\nreside in many different locations, each with a distinct address. A\nRust lifetime is concerned with the address you &lt;em&gt;currently reside at&lt;/em&gt;,\nnot about whenever you will die in the future (although dying also\nchanges your address). Every time you move it&apos;s relevant because your\naddress is no longer valid.&lt;/p&gt;\n&lt;p&gt;It&apos;s also important to note that lifetimes &lt;em&gt;do not&lt;/em&gt; change your code; your\ncode controls the lifetimes, your lifetimes don&apos;t control the code. The\npithy saying is &quot;lifetimes are descriptive, not prescriptive&quot;.&lt;/p&gt;\n&lt;p&gt;Let&apos;s annotate &lt;code&gt;Combined::new&lt;/code&gt; with some line numbers which we will use\nto highlight lifetimes:&lt;/p&gt;\n&lt;pre class=&quot;lang-rust s-code-block&quot;&gt;&lt;code class=&quot;hljs language-rust&quot;&gt;{                                          &lt;span class=&quot;hljs-comment&quot;&gt;// 0&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;parent&lt;/span&gt; = Parent { count: &lt;span class=&quot;hljs-number&quot;&gt;42&lt;/span&gt; };     &lt;span class=&quot;hljs-comment&quot;&gt;// 1&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;child&lt;/span&gt; = Child { parent: &amp;amp;parent }; &lt;span class=&quot;hljs-comment&quot;&gt;// 2&lt;/span&gt;\n                                           &lt;span class=&quot;hljs-comment&quot;&gt;// 3&lt;/span&gt;\n    Combined { parent, child }             &lt;span class=&quot;hljs-comment&quot;&gt;// 4&lt;/span&gt;\n}                                          &lt;span class=&quot;hljs-comment&quot;&gt;// 5&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The &lt;em&gt;concrete lifetime&lt;/em&gt; of &lt;code&gt;parent&lt;/code&gt; is from 1 to 4, inclusive (which I&apos;ll\nrepresent as &lt;code&gt;[1,4]&lt;/code&gt;). The concrete lifetime of &lt;code&gt;child&lt;/code&gt; is &lt;code&gt;[2,4]&lt;/code&gt;, and\nthe concrete lifetime of the return value is &lt;code&gt;[4,5]&lt;/code&gt;. It&apos;s\npossible to have concrete lifetimes that start at zero - that would\nrepresent the lifetime of a parameter to a function or something that\nexisted outside of the block.&lt;/p&gt;\n&lt;p&gt;Note that the lifetime of &lt;code&gt;child&lt;/code&gt; itself is &lt;code&gt;[2,4]&lt;/code&gt;, but that it &lt;strong&gt;refers\nto&lt;/strong&gt; a value with a lifetime of &lt;code&gt;[1,4]&lt;/code&gt;. This is fine as long as the\nreferring value becomes invalid before the referred-to value does. The\nproblem occurs when we try to return &lt;code&gt;child&lt;/code&gt; from the block. This would\n&quot;over-extend&quot; the lifetime beyond its natural length.&lt;/p&gt;\n&lt;p&gt;This new knowledge should explain the first two examples. The third\none requires looking at the implementation of &lt;code&gt;Parent::child&lt;/code&gt;. Chances\nare, it will look something like this:&lt;/p&gt;\n&lt;pre class=&quot;lang-rust s-code-block&quot;&gt;&lt;code class=&quot;hljs language-rust&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Parent&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;child&lt;/span&gt;(&amp;amp;&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;) &lt;span class=&quot;hljs-punctuation&quot;&gt;-&amp;gt;&lt;/span&gt; Child { &lt;span class=&quot;hljs-comment&quot;&gt;/* ... */&lt;/span&gt; }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This uses &lt;em&gt;lifetime elision&lt;/em&gt; to avoid writing explicit &lt;em&gt;generic\nlifetime parameters&lt;/em&gt;. It is equivalent to:&lt;/p&gt;\n&lt;pre class=&quot;lang-rust s-code-block&quot;&gt;&lt;code class=&quot;hljs language-rust&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Parent&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;child&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;a&lt;/span&gt;&amp;gt;(&amp;amp;&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;a&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;) &lt;span class=&quot;hljs-punctuation&quot;&gt;-&amp;gt;&lt;/span&gt; Child&amp;lt;&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;a&lt;/span&gt;&amp;gt; { &lt;span class=&quot;hljs-comment&quot;&gt;/* ... */&lt;/span&gt; }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In both cases, the method says that a &lt;code&gt;Child&lt;/code&gt; structure will be\nreturned that has been parameterized with the concrete lifetime of\n&lt;code&gt;self&lt;/code&gt;. Said another way, the &lt;code&gt;Child&lt;/code&gt; instance contains a reference\nto the &lt;code&gt;Parent&lt;/code&gt; that created it, and thus cannot live longer than that\n&lt;code&gt;Parent&lt;/code&gt; instance.&lt;/p&gt;\n&lt;p&gt;This also lets us recognize that something is really wrong with our\ncreation function:&lt;/p&gt;\n&lt;pre class=&quot;lang-rust s-code-block&quot;&gt;&lt;code class=&quot;hljs language-rust&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;make_combined&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;a&lt;/span&gt;&amp;gt;() &lt;span class=&quot;hljs-punctuation&quot;&gt;-&amp;gt;&lt;/span&gt; Combined&amp;lt;&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;a&lt;/span&gt;&amp;gt; { &lt;span class=&quot;hljs-comment&quot;&gt;/* ... */&lt;/span&gt; }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Although you are more likely to see this written in a different form:&lt;/p&gt;\n&lt;pre class=&quot;lang-rust s-code-block&quot;&gt;&lt;code class=&quot;hljs language-rust&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;impl&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;a&lt;/span&gt;&amp;gt; Combined&amp;lt;&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;a&lt;/span&gt;&amp;gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;new&lt;/span&gt;() &lt;span class=&quot;hljs-punctuation&quot;&gt;-&amp;gt;&lt;/span&gt; Combined&amp;lt;&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;a&lt;/span&gt;&amp;gt; { &lt;span class=&quot;hljs-comment&quot;&gt;/* ... */&lt;/span&gt; }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In both cases, there is no lifetime parameter being provided via an\nargument. This means that the lifetime that &lt;code&gt;Combined&lt;/code&gt; will be\nparameterized with isn&apos;t constrained by anything - it can be whatever\nthe caller wants it to be. This is nonsensical, because the caller\ncould specify the &lt;code&gt;&apos;static&lt;/code&gt; lifetime and there&apos;s no way to meet that\ncondition.&lt;/p&gt;\n&lt;h3&gt;How do I fix it?&lt;/h3&gt;\n&lt;p&gt;The easiest and most recommended solution is to not attempt to put\nthese items in the same structure together. By doing this, your\nstructure nesting will mimic the lifetimes of your code. Place types\nthat own data into a structure together and then provide methods that\nallow you to get references or objects containing references as needed.&lt;/p&gt;\n&lt;p&gt;There is a special case where the lifetime tracking is overzealous:\nwhen you have something placed on the heap. This occurs when you use a\n&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, for example. In this case, the structure that is moved\ncontains a pointer into the heap. The pointed-at value will remain\nstable, but the address of the pointer itself will move. In practice,\nthis doesn&apos;t matter, as you always follow the pointer.&lt;/p&gt;\n&lt;p&gt;Some crates provide ways of representing this case, but they\nrequire that the base address &lt;em&gt;never move&lt;/em&gt;. This rules out mutating\nvectors, which may cause a reallocation and a move of the\nheap-allocated values.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;https://crates.io/crates/rental&quot; rel=&quot;noreferrer&quot;&gt;rental&lt;/a&gt; (no longer maintained or suppported)&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://crates.io/crates/owning_ref&quot; rel=&quot;noreferrer&quot;&gt;owning_ref&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://crates.io/crates/ouroboros&quot; rel=&quot;noreferrer&quot;&gt;ouroboros&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Examples of problems solved with Rental:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/q/47193584/155423&quot;&gt;Is there an owned version of String::chars?&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/q/50496879/155423&quot;&gt;Returning a RWLockReadGuard independently from a method&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/q/51664098/155423&quot;&gt;How can I return an iterator over a locked struct member in Rust?&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/q/40095383/155423&quot;&gt;How to return a reference to a sub-value of a value that is under a mutex?&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/q/43702185/155423&quot;&gt;How do I store a result using Serde Zero-copy deserialization of a Futures-enabled Hyper Chunk?&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/q/49300618/155423&quot;&gt;How to store a reference without having to deal with lifetimes?&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;In other cases, you may wish to move to some type of reference-counting, such as by using &lt;a href=&quot;https://doc.rust-lang.org/std/rc/struct.Rc.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/std/sync/struct.Arc.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n&lt;h3&gt;More information&lt;/h3&gt;\n&lt;blockquote&gt;\n&lt;p&gt;After moving &lt;code&gt;parent&lt;/code&gt; into the struct, why is the compiler not able to get a new reference to &lt;code&gt;parent&lt;/code&gt; and assign it to &lt;code&gt;child&lt;/code&gt; in the struct?&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;While it is theoretically possible to do this, doing so would introduce a large amount of complexity and overhead. Every time that the object is moved, the compiler would need to insert code to &quot;fix up&quot; the reference. This would mean that copying a struct is no longer a very cheap operation that just moves some bits around. It could even mean that code like this is expensive, depending on how good a hypothetical optimizer would be:&lt;/p&gt;\n&lt;pre class=&quot;lang-rust s-code-block&quot;&gt;&lt;code class=&quot;hljs language-rust&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;a&lt;/span&gt; = Object::&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;new&lt;/span&gt;();\n&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;b&lt;/span&gt; = a;\n&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;c&lt;/span&gt; = b;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Instead of forcing this to happen for &lt;em&gt;every&lt;/em&gt; move, the programmer gets to &lt;em&gt;choose&lt;/em&gt; when this will happen by creating methods that will take the appropriate references only when you call them.&lt;/p&gt;\n&lt;h3&gt;A type with a reference to itself&lt;/h3&gt;\n&lt;p&gt;There&apos;s one specific case where you &lt;em&gt;can&lt;/em&gt; create a type with a reference to itself. You need to use something like &lt;code&gt;Option&lt;/code&gt; to make it in two steps though:&lt;/p&gt;\n&lt;pre class=&quot;lang-rust s-code-block&quot;&gt;&lt;code class=&quot;hljs language-rust&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#[derive(Debug)]&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;WhatAboutThis&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;a&lt;/span&gt;&amp;gt; {\n    name: &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt;,\n    nickname: &lt;span class=&quot;hljs-type&quot;&gt;Option&lt;/span&gt;&amp;lt;&amp;amp;&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;a&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;str&lt;/span&gt;&amp;gt;,\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;() {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;mut &lt;/span&gt;&lt;span class=&quot;hljs-variable&quot;&gt;tricky&lt;/span&gt; = WhatAboutThis {\n        name: &lt;span class=&quot;hljs-string&quot;&gt;&quot;Annabelle&quot;&lt;/span&gt;.&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;to_string&lt;/span&gt;(),\n        nickname: &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;,\n    };\n    tricky.nickname = &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;Some&lt;/span&gt;(&amp;amp;tricky.name[..&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;]);\n\n    &lt;span class=&quot;hljs-built_in&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;{:?}&quot;&lt;/span&gt;, tricky);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This does work, in some sense, but the created value is highly restricted - it can &lt;em&gt;never&lt;/em&gt; be moved. Notably, this means it cannot be returned from a function or passed by-value to anything. A constructor function shows the same problem with the lifetimes as above:&lt;/p&gt;\n&lt;pre class=&quot;lang-rust s-code-block&quot;&gt;&lt;code class=&quot;hljs language-rust&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;creator&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;a&lt;/span&gt;&amp;gt;() &lt;span class=&quot;hljs-punctuation&quot;&gt;-&amp;gt;&lt;/span&gt; WhatAboutThis&amp;lt;&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;a&lt;/span&gt;&amp;gt; { &lt;span class=&quot;hljs-comment&quot;&gt;/* ... */&lt;/span&gt; }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;If you try to do this same code with a method, you&apos;ll need the alluring but ultimately useless &lt;code&gt;&amp;amp;&apos;a self&lt;/code&gt;. When that&apos;s involved, this code is even more restricted and you will get borrow-checker errors after the first method call:&lt;/p&gt;\n&lt;pre class=&quot;lang-rust s-code-block&quot;&gt;&lt;code class=&quot;hljs language-rust&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#[derive(Debug)]&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;WhatAboutThis&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;a&lt;/span&gt;&amp;gt; {\n    name: &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt;,\n    nickname: &lt;span class=&quot;hljs-type&quot;&gt;Option&lt;/span&gt;&amp;lt;&amp;amp;&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;a&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;str&lt;/span&gt;&amp;gt;,\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;impl&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;a&lt;/span&gt;&amp;gt; WhatAboutThis&amp;lt;&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;a&lt;/span&gt;&amp;gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;tie_the_knot&lt;/span&gt;(&amp;amp;&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;a&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;) {\n       &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.nickname = &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;Some&lt;/span&gt;(&amp;amp;&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.name[..&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;]); \n    }\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;() {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;mut &lt;/span&gt;&lt;span class=&quot;hljs-variable&quot;&gt;tricky&lt;/span&gt; = WhatAboutThis {\n        name: &lt;span class=&quot;hljs-string&quot;&gt;&quot;Annabelle&quot;&lt;/span&gt;.&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;to_string&lt;/span&gt;(),\n        nickname: &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;,\n    };\n    tricky.&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;tie_the_knot&lt;/span&gt;();\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// cannot borrow `tricky` as immutable because it is also borrowed as mutable&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// println!(&quot;{:?}&quot;, tricky);&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;See also:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/q/31067031/155423&quot;&gt;Cannot borrow as mutable more than once at a time in one code - but can in another very similar&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3&gt;What about &lt;code&gt;Pin&lt;/code&gt;?&lt;/h3&gt;\n&lt;p&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/pin/struct.Pin.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;, stabilized in Rust 1.33, has this &lt;a href=&quot;https://doc.rust-lang.org/std/pin/index.html&quot; rel=&quot;noreferrer&quot;&gt;in the module documentation&lt;/a&gt;:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;A prime example of such a scenario would be building self-referential structs, since moving an object with pointers to itself will invalidate them, which could cause undefined behavior.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;It&apos;s important to note that &quot;self-referential&quot; doesn&apos;t necessarily mean using &lt;em&gt;a reference&lt;/em&gt;. Indeed, the &lt;a href=&quot;https://doc.rust-lang.org/std/pin/index.html#example-self-referential-struct&quot; rel=&quot;noreferrer&quot;&gt;example of a self-referential struct&lt;/a&gt; specifically says (emphasis mine):&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;We cannot inform the compiler about that with a normal reference,\nsince this pattern cannot be described with the usual borrowing rules.\nInstead &lt;strong&gt;we use a raw pointer&lt;/strong&gt;, though one which is known to not be null,\nsince we know it&apos;s pointing at the string.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;The ability to use a raw pointer for this behavior has existed since Rust 1.0. Indeed, owning-ref and rental use raw pointers under the hood.&lt;/p&gt;\n&lt;p&gt;The only thing that &lt;code&gt;Pin&lt;/code&gt; adds to the table is a common way to state that a given value is guaranteed to not move.&lt;/p&gt;\n&lt;p&gt;See also:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/q/49860149/155423&quot;&gt;How to use the Pin struct with self-referential structures?&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;A slightly different issue which causes very similar compiler messages is object lifetime dependency, rather than storing an explicit reference. An example of that is the &lt;a href=&quot;http://alexcrichton.com/ssh2-rs/ssh2/&quot; rel=&quot;noreferrer&quot;&gt;ssh2&lt;/a&gt; library. When developing something bigger than a test project, it is tempting to try to put the &lt;code&gt;Session&lt;/code&gt; and &lt;code&gt;Channel&lt;/code&gt; obtained from that session alongside each other into a struct, hiding the implementation details from the user. However, note that the &lt;a href=&quot;http://alexcrichton.com/ssh2-rs/ssh2/struct.Channel.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; definition has the &lt;code&gt;&apos;sess&lt;/code&gt; lifetime in its type annotation, while &lt;a href=&quot;http://alexcrichton.com/ssh2-rs/ssh2/struct.Session.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;Session&lt;/code&gt;&lt;/a&gt; doesn&apos;t.&lt;/p&gt;\n\n&lt;p&gt;This causes similar compiler errors related to lifetimes.&lt;/p&gt;\n\n&lt;p&gt;One way to solve it in a very simple way is to declare the &lt;code&gt;Session&lt;/code&gt; outside in the caller, and then for annotate the reference within the struct with a lifetime, similar to the answer in &lt;a href=&quot;https://users.rust-lang.org/t/solved-first-issue-with-lifetimes/13243/16&quot; rel=&quot;noreferrer&quot;&gt;this Rust User&apos;s Forum post&lt;/a&gt; talking about the same issue while encapsulating SFTP. This will not look elegant and may not always apply - because now you have two entities to deal with, rather than one that you wanted!&lt;/p&gt;\n\n&lt;p&gt;Turns out the &lt;a href=&quot;https://crates.io/crates/rental&quot; rel=&quot;noreferrer&quot;&gt;rental crate&lt;/a&gt; or the &lt;a href=&quot;https://crates.io/crates/owning_ref&quot; rel=&quot;noreferrer&quot;&gt;owning_ref crate&lt;/a&gt; from the other answer are the solutions for this issue too. Let&apos;s consider the owning_ref, which has the special object for this exact purpose:\n&lt;a href=&quot;http://kimundi.github.io/owning-ref-rs/owning_ref/struct.OwningHandle.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;OwningHandle&lt;/code&gt;&lt;/a&gt;. To avoid the underlying object moving, we allocate it on the heap using a &lt;code&gt;Box&lt;/code&gt;, which gives us the following possible solution:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-rust s-code-block&quot;&gt;&lt;code class=&quot;hljs language-rust&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; ssh2::{Channel, Error, Session};\n&lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; std::net::TcpStream;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; owning_ref::OwningHandle;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;DeviceSSHConnection&lt;/span&gt; {\n    tcp: TcpStream,\n    channel: OwningHandle&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;Box&lt;/span&gt;&amp;lt;Session&amp;gt;, &lt;span class=&quot;hljs-type&quot;&gt;Box&lt;/span&gt;&amp;lt;Channel&amp;lt;&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;static&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;,\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;DeviceSSHConnection&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;new&lt;/span&gt;(targ: &amp;amp;&lt;span class=&quot;hljs-type&quot;&gt;str&lt;/span&gt;, c_user: &amp;amp;&lt;span class=&quot;hljs-type&quot;&gt;str&lt;/span&gt;, c_pass: &amp;amp;&lt;span class=&quot;hljs-type&quot;&gt;str&lt;/span&gt;) &lt;span class=&quot;hljs-punctuation&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;Self&lt;/span&gt; {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; std::net::TcpStream;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;mut &lt;/span&gt;&lt;span class=&quot;hljs-variable&quot;&gt;session&lt;/span&gt; = Session::&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;new&lt;/span&gt;().&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;unwrap&lt;/span&gt;();\n        &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;mut &lt;/span&gt;&lt;span class=&quot;hljs-variable&quot;&gt;tcp&lt;/span&gt; = TcpStream::&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;connect&lt;/span&gt;(targ).&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;unwrap&lt;/span&gt;();\n\n        session.&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;handshake&lt;/span&gt;(&amp;amp;tcp).&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;unwrap&lt;/span&gt;();\n        session.&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;set_timeout&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;5000&lt;/span&gt;);\n        session.&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;userauth_password&lt;/span&gt;(c_user, c_pass).&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;unwrap&lt;/span&gt;();\n\n        &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;mut &lt;/span&gt;&lt;span class=&quot;hljs-variable&quot;&gt;sess&lt;/span&gt; = Box::&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;new&lt;/span&gt;(session);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;mut &lt;/span&gt;&lt;span class=&quot;hljs-variable&quot;&gt;oref&lt;/span&gt; = OwningHandle::&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;new_with_fn&lt;/span&gt;(\n            sess,\n            &lt;span class=&quot;hljs-keyword&quot;&gt;unsafe&lt;/span&gt; { |x| Box::&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;new&lt;/span&gt;((*x).&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;channel_session&lt;/span&gt;().&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;unwrap&lt;/span&gt;()) },\n        );\n\n        oref.&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;shell&lt;/span&gt;().&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;unwrap&lt;/span&gt;();\n        &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;ret&lt;/span&gt; = DeviceSSHConnection {\n            tcp: tcp,\n            channel: oref,\n        };\n        ret\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The result of this code is that we can not use the &lt;code&gt;Session&lt;/code&gt; anymore, but it is stored alongside with the &lt;code&gt;Channel&lt;/code&gt; which we will be using. Because the &lt;code&gt;OwningHandle&lt;/code&gt; object dereferences to &lt;code&gt;Box&lt;/code&gt;, which dereferences to &lt;code&gt;Channel&lt;/code&gt;, when storing it in a struct, we name it as such. &lt;strong&gt;NOTE:&lt;/strong&gt; This is just my understanding. I have a suspicion this may not be correct, since it appears to be quite close to &lt;a href=&quot;https://github.com/Kimundi/owning-ref-rs/issues/27&quot; rel=&quot;noreferrer&quot;&gt;discussion of &lt;code&gt;OwningHandle&lt;/code&gt; unsafety&lt;/a&gt;. &lt;/p&gt;\n\n&lt;p&gt;One curious detail here is that the &lt;code&gt;Session&lt;/code&gt; logically has a similar relationship with &lt;code&gt;TcpStream&lt;/code&gt; as &lt;code&gt;Channel&lt;/code&gt; has to &lt;code&gt;Session&lt;/code&gt;, yet its ownership is not taken and there are no type annotations around doing so. Instead, it is up to the user to take care of this, as the documentation of &lt;a href=&quot;http://alexcrichton.com/ssh2-rs/ssh2/struct.Session.html#method.handshake&quot; rel=&quot;noreferrer&quot;&gt;handshake&lt;/a&gt; method says:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;This session does not take ownership of the socket provided, it is\n  recommended to ensure that the socket persists the lifetime of this\n  session to ensure that communication is correctly performed.&lt;/p&gt;\n  \n  &lt;p&gt;It is also highly recommended that the stream provided is not used\n  concurrently elsewhere for the duration of this session as it may\n  interfere with the protocol.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;So with the &lt;code&gt;TcpStream&lt;/code&gt; usage, is completely up to the programmer to ensure the correctness of the code. With the &lt;code&gt;OwningHandle&lt;/code&gt;, the attention to where the &quot;dangerous magic&quot; happens is drawn using the &lt;code&gt;unsafe {}&lt;/code&gt; block.&lt;/p&gt;\n\n&lt;p&gt;A further and a more high-level discussion of this issue is in this &lt;a href=&quot;https://users.rust-lang.org/t/how-to-write-software-without-self-referential-structs/13819/11&quot; rel=&quot;noreferrer&quot;&gt;Rust User&apos;s Forum thread&lt;/a&gt; - which includes a different example and its solution using the rental crate, which does not contain unsafe blocks.&lt;/p&gt;\n    ","\n&lt;p&gt;I&apos;ve found the &lt;code&gt;Arc&lt;/code&gt; (read-only) or &lt;code&gt;Arc&amp;lt;Mutex&amp;gt;&lt;/code&gt; (read-write with locking) patterns to be sometimes quite useful tradeoff between performance and code complexity (mostly caused by lifetime-annotation).&lt;/p&gt;\n&lt;p&gt;Arc:&lt;/p&gt;\n&lt;pre class=&quot;lang-rust s-code-block&quot;&gt;&lt;code class=&quot;hljs language-rust&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; std::sync::Arc;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Parent&lt;/span&gt; {\n    child: Arc&amp;lt;Child&amp;gt;,\n}\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Child&lt;/span&gt; {\n    value: &lt;span class=&quot;hljs-type&quot;&gt;u32&lt;/span&gt;,\n}\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Combined&lt;/span&gt;(Parent, Arc&amp;lt;Child&amp;gt;);\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;() {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;parent&lt;/span&gt; = Parent { child: Arc::&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;new&lt;/span&gt;(Child { value: &lt;span class=&quot;hljs-number&quot;&gt;42&lt;/span&gt; }) };\n    &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;child&lt;/span&gt; = parent.child.&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;clone&lt;/span&gt;();\n    &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;combined&lt;/span&gt; = &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;Combined&lt;/span&gt;(parent, child.&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;clone&lt;/span&gt;());\n\n    &lt;span class=&quot;hljs-built_in&quot;&gt;assert_eq!&lt;/span&gt;(combined.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.child.value, &lt;span class=&quot;hljs-number&quot;&gt;42&lt;/span&gt;);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;assert_eq!&lt;/span&gt;(child.value, &lt;span class=&quot;hljs-number&quot;&gt;42&lt;/span&gt;);\n    &lt;span class=&quot;hljs-comment&quot;&gt;// combined.0.child.value = 50; // fails, Arc is not DerefMut&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Arc + Mutex:&lt;/p&gt;\n&lt;pre class=&quot;lang-rust s-code-block&quot;&gt;&lt;code class=&quot;hljs language-rust&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; std::sync::{Arc, Mutex};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Child&lt;/span&gt; {\n    value: &lt;span class=&quot;hljs-type&quot;&gt;u32&lt;/span&gt;,\n}\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Parent&lt;/span&gt; {\n    child: Arc&amp;lt;Mutex&amp;lt;Child&amp;gt;&amp;gt;,\n}\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Combined&lt;/span&gt;(Parent, Arc&amp;lt;Mutex&amp;lt;Child&amp;gt;&amp;gt;);\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;() {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;parent&lt;/span&gt; = Parent { child: Arc::&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;new&lt;/span&gt;(Mutex::&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;new&lt;/span&gt;(Child {value: &lt;span class=&quot;hljs-number&quot;&gt;42&lt;/span&gt; }))};\n    &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;child&lt;/span&gt; = parent.child.&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;clone&lt;/span&gt;();\n    &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;combined&lt;/span&gt; = &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;Combined&lt;/span&gt;(parent, child.&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;clone&lt;/span&gt;());\n\n    &lt;span class=&quot;hljs-built_in&quot;&gt;assert_eq!&lt;/span&gt;(combined.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.child.&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;lock&lt;/span&gt;().&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;unwrap&lt;/span&gt;().value, &lt;span class=&quot;hljs-number&quot;&gt;42&lt;/span&gt;);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;assert_eq!&lt;/span&gt;(child.&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;lock&lt;/span&gt;().&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;unwrap&lt;/span&gt;().value, &lt;span class=&quot;hljs-number&quot;&gt;42&lt;/span&gt;);\n    child.&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;lock&lt;/span&gt;().&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;unwrap&lt;/span&gt;().value = &lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;assert_eq!&lt;/span&gt;(combined.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.child.&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;lock&lt;/span&gt;().&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;unwrap&lt;/span&gt;().value, &lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;See also &lt;code&gt;RwLock&lt;/code&gt; (&lt;a href=&quot;https://stackoverflow.com/questions/50704279/when-or-why-should-i-use-a-mutex-over-an-rwlock&quot;&gt;When or why should I use a Mutex over an RwLock?&lt;/a&gt;)&lt;/p&gt;\n    "]},"randomTags":[{"name":"copy-paste","slug":"copy-paste"},{"name":"android-activity","slug":"android-activity"},{"name":"projection","slug":"projection"},{"name":"friendly-url","slug":"friendly-url"},{"name":"generic-list","slug":"generic-list"},{"name":"selenium3","slug":"selenium3"},{"name":"object-literal","slug":"object-literal"},{"name":"pdo","slug":"pdo"},{"name":"variable-length-array","slug":"variable-length-array"},{"name":"hover","slug":"hover"},{"name":"csv","slug":"csv"},{"name":"forward-declaration","slug":"forward-declaration"},{"name":"identity-operator","slug":"identity-operator"},{"name":"layout-manager","slug":"layout-manager"},{"name":"dynamic-memory-allocation","slug":"dynamic-memory-allocation"},{"name":"closures","slug":"closures"},{"name":"tidyr","slug":"tidyr"},{"name":"reflection","slug":"reflection"},{"name":"greatest-n-per-group","slug":"greatest-n-per-group"},{"name":"instantiation","slug":"instantiation"}]},"__N_SSG":true}