{"pageProps":{"data":{"count":1,"rows":[{"id":540,"title":"Templated check for the existence of a class member function?","slug":"templated-check-for-the-existence-of-a-class-member-function-1657388363414","postType":"QUESTION","createdAt":"2022-07-09T17:39:23.000Z","updatedAt":"2022-07-09T17:39:23.000Z","tags":[{"id":2641,"name":"sfinae","slug":"sfinae","createdAt":"2022-07-09T17:39:23.000Z","updatedAt":"2022-07-09T17:39:23.000Z","Questions_Tags":{"questionId":540,"tagId":2641}}]}]},"slug":"sfinae","page":1,"answers":{"540":["\n&lt;p&gt;Yes, with SFINAE you can check if a given class does provide a certain method. Here&apos;s the working code:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Hello&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;helloworld&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; }\n};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Generic&lt;/span&gt; {};    \n\n&lt;span class=&quot;hljs-comment&quot;&gt;// SFINAE test&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;has_helloworld&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; one;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;two&lt;/span&gt; { &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; x[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]; };\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; C&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; one &lt;span class=&quot;hljs-title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;( &lt;span class=&quot;hljs-keyword&quot;&gt;decltype&lt;/span&gt;(&amp;amp;C::helloworld) )&lt;/span&gt; &lt;/span&gt;;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; C&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; two &lt;span class=&quot;hljs-title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(...)&lt;/span&gt;&lt;/span&gt;;    \n\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n    &lt;span class=&quot;hljs-keyword&quot;&gt;enum&lt;/span&gt; { value = &lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;&amp;lt;T&amp;gt;(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)) == &lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;) };\n};\n    \n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;\n&lt;/span&gt;{\n    std::cout &amp;lt;&amp;lt; has_helloworld&amp;lt;Hello&amp;gt;::value &amp;lt;&amp;lt; std::endl;\n    std::cout &amp;lt;&amp;lt; has_helloworld&amp;lt;Generic&amp;gt;::value &amp;lt;&amp;lt; std::endl;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;I&apos;ve just tested it with Linux and gcc 4.1/4.3. I don&apos;t know if it&apos;s portable to other platforms running different compilers.&lt;/p&gt;\n    ","\n&lt;p&gt;This question is old, but with C++11 we got a new way to check for a functions existence (or existence of any non-type member, really), relying on SFINAE again:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;serialize_imp&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(std::ostream&amp;amp; os, T &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;&amp;amp; obj, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;\n    -&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;decltype&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(os &amp;lt;&amp;lt; obj, &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;())&lt;/span&gt;\n&lt;/span&gt;{\n  os &amp;lt;&amp;lt; obj;\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;serialize_imp&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(std::ostream&amp;amp; os, T &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;&amp;amp; obj, &lt;span class=&quot;hljs-type&quot;&gt;long&lt;/span&gt;)&lt;/span&gt;\n    -&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;decltype&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(obj.stream(os), &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;())&lt;/span&gt;\n&lt;/span&gt;{\n  obj.&lt;span class=&quot;hljs-built_in&quot;&gt;stream&lt;/span&gt;(os);\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;serialize&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(std::ostream&amp;amp; os, T &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;&amp;amp; obj)&lt;/span&gt;\n    -&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;decltype&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(serialize_imp(os, obj, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;), &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;())&lt;/span&gt;\n&lt;/span&gt;{\n  &lt;span class=&quot;hljs-built_in&quot;&gt;serialize_imp&lt;/span&gt;(os, obj, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Now onto some explanations. First thing, I use &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2634.html&quot; rel=&quot;noreferrer&quot;&gt;expression SFINAE&lt;/a&gt; to exclude the &lt;code&gt;serialize(_imp)&lt;/code&gt; functions from overload resolution, if the first expression inside &lt;code&gt;decltype&lt;/code&gt; isn&apos;t valid (aka, the function doesn&apos;t exist).&lt;/p&gt;\n\n&lt;p&gt;The &lt;code&gt;void()&lt;/code&gt; is used to make the return type of all those functions &lt;code&gt;void&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;The &lt;code&gt;0&lt;/code&gt; argument is used to prefer the &lt;code&gt;os &amp;lt;&amp;lt; obj&lt;/code&gt; overload if both are available (literal &lt;code&gt;0&lt;/code&gt; is of type &lt;code&gt;int&lt;/code&gt; and as such the first overload is a better match).&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;Now, you probably want a trait to check if a function exists. Luckily, it&apos;s easy to write that. Note, though, that you need to write a trait &lt;em&gt;yourself&lt;/em&gt; for every different function name you might want.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;type_traits&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;sfinae_true&lt;/span&gt; : std::true_type{};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; detail{\n  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; T, &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; A0&amp;gt;\n  &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;test_stream&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;\n      -&amp;gt; sfinae_true&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;decltype&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(std::declval&amp;lt;T&amp;gt;().stream(std::declval&amp;lt;A0&amp;gt;()))&lt;/span&gt;&amp;gt;&lt;/span&gt;;\n  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; A0&amp;gt;\n  &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;test_stream&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;long&lt;/span&gt;)&lt;/span&gt; -&amp;gt; std::false_type&lt;/span&gt;;\n} &lt;span class=&quot;hljs-comment&quot;&gt;// detail::&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;T&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Arg&lt;/span&gt;&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;has_stream&lt;/span&gt; : &lt;span class=&quot;hljs-keyword&quot;&gt;decltype&lt;/span&gt;(detail::&lt;span class=&quot;hljs-built_in&quot;&gt;test_stream&lt;/span&gt;&amp;lt;T, Arg&amp;gt;(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)){};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://coliru.stacked-crooked.com/a/cd139d95d214c5c3&quot; rel=&quot;noreferrer&quot;&gt;Live example.&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;And on to explanations. First, &lt;code&gt;sfinae_true&lt;/code&gt; is a helper type, and it basically amounts to the same as writing &lt;code&gt;decltype(void(std::declval&amp;lt;T&amp;gt;().stream(a0)), std::true_type{})&lt;/code&gt;. The advantage is simply that it&apos;s shorter.&lt;br&gt;\nNext, the &lt;code&gt;struct has_stream : decltype(...)&lt;/code&gt; inherits from either &lt;code&gt;std::true_type&lt;/code&gt; or &lt;code&gt;std::false_type&lt;/code&gt; in the end, depending on whether the &lt;code&gt;decltype&lt;/code&gt; check in &lt;code&gt;test_stream&lt;/code&gt; fails or not.&lt;br&gt;\nLast, &lt;code&gt;std::declval&lt;/code&gt; gives you a &quot;value&quot; of whatever type you pass, without you needing to know how you can construct it. Note that this is only possible inside an unevaluated context, such as &lt;code&gt;decltype&lt;/code&gt;, &lt;code&gt;sizeof&lt;/code&gt; and others.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;Note that &lt;code&gt;decltype&lt;/code&gt; is not necessarily needed, as &lt;code&gt;sizeof&lt;/code&gt; (and all unevaluated contexts) got that enhancement. It&apos;s just that &lt;code&gt;decltype&lt;/code&gt; already delivers a type and as such is just cleaner. Here&apos;s a &lt;code&gt;sizeof&lt;/code&gt; version of one of the overloads:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;serialize_imp&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(std::ostream&amp;amp; os, T &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;&amp;amp; obj, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;,\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;(*)[&lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;((os &amp;lt;&amp;lt; obj),&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)] = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;\n&lt;/span&gt;{\n  os &amp;lt;&amp;lt; obj;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;long&lt;/code&gt; parameters are still there for the same reason. The array pointer is used to provide a context where &lt;code&gt;sizeof&lt;/code&gt; can be used.&lt;/p&gt;\n    ","\n&lt;p&gt;C++ allows &lt;a href=&quot;http://en.wikipedia.org/wiki/SFINAE&quot; rel=&quot;nofollow noreferrer&quot;&gt;SFINAE&lt;/a&gt; to be used for this (notice that with C++11 features this is simplier because it supports extended SFINAE on nearly arbitrary expressions - the below was crafted to work with common C++03 compilers):&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; HAS_MEM_FUNC(func, name)                                        \\\n    template&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typename T, typename Sign&amp;gt;&lt;/span&gt;                                 \\\n    struct name {                                                       \\\n        typedef char yes[1];                                            \\\n        typedef char no [2];                                            \\\n        template &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typename U, U&amp;gt;&lt;/span&gt; struct type_check;                     \\\n        template &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typename _1&amp;gt;&lt;/span&gt; static yes &amp;amp;chk(type_check&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;Sign, &amp;amp;_1::func &amp;gt;&lt;/span&gt; *); \\\n        template &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typename   &amp;gt;&lt;/span&gt; static no  &amp;amp;chk(...);                    \\\n        static bool const value = sizeof(chk&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;T&amp;gt;&lt;/span&gt;(0)) == sizeof(yes);     \\\n    }&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The above template and macro tries to instantiate a template, giving it a member function pointer type, and the actual member function pointer. If the types do not fit, SFINAE causes the template to be ignored. Usage like this:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;HAS_MEM_FUNC&lt;/span&gt;(toString, has_to_string);\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt; &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;\n&lt;span class=&quot;hljs-title&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n   &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(has_to_string&amp;lt;T, std::&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;(T::*)()&amp;gt;::value) {\n      ...\n   } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {\n      ...\n   }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;But note that you cannot just call that &lt;code&gt;toString&lt;/code&gt; function in that &lt;code&gt;if&lt;/code&gt; branch. Since the compiler will check for validity in both branches, that would fail for cases the function doesn&apos;t exist. One way is to use SFINAE once again (&lt;code&gt;enable_if&lt;/code&gt; can be obtained from boost, too):&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; C, &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T = &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; enable_if {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; T type;\n};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;enable_if&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;, T&amp;gt; { };\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;HAS_MEM_FUNC&lt;/span&gt;(toString, has_to_string);\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt; \n&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; enable_if&amp;lt;has_to_string&amp;lt;T, \n                   std::&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;(T::*)()&amp;gt;::value, std::string&amp;gt;::&lt;span class=&quot;hljs-function&quot;&gt;type\n&lt;span class=&quot;hljs-title&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T * t)&lt;/span&gt; &lt;/span&gt;{\n   &lt;span class=&quot;hljs-comment&quot;&gt;/* something when T has toString ... */&lt;/span&gt;\n   &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; t-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;toString&lt;/span&gt;();\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt; \n&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; enable_if&amp;lt;!has_to_string&amp;lt;T, \n                   std::&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;(T::*)()&amp;gt;::value, std::string&amp;gt;::&lt;span class=&quot;hljs-function&quot;&gt;type\n&lt;span class=&quot;hljs-title&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T * t)&lt;/span&gt; &lt;/span&gt;{\n   &lt;span class=&quot;hljs-comment&quot;&gt;/* something when T doesnt have toString ... */&lt;/span&gt;\n   &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;T::toString() does not exist.&quot;&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Have fun using it. The advantage of it is that it also works for overloaded member functions, and also for &lt;code&gt;const&lt;/code&gt; member functions (remember using  &lt;code&gt;std::string(T::*)() const&lt;/code&gt; as the member function pointer type then!).&lt;/p&gt;\n    ","\n&lt;h2&gt;C++20 - &lt;code&gt;requires&lt;/code&gt; expressions&lt;/h2&gt;\n&lt;p&gt;With C++20 come concepts and assorted tools such as &lt;a href=&quot;https://en.cppreference.com/w/cpp/language/constraints&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;requires&lt;/code&gt; expressions&lt;/a&gt; which are a built-in way to check for a function existence. With them you could rewrite your &lt;code&gt;optionalToString&lt;/code&gt; function as follows:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; T&amp;gt;\nstd::string &lt;span class=&quot;hljs-title&quot;&gt;optionalToString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T* obj)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; has_toString = &lt;span class=&quot;hljs-built_in&quot;&gt;requires&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; T&amp;amp; t) {\n        t.&lt;span class=&quot;hljs-built_in&quot;&gt;toString&lt;/span&gt;();\n    };\n\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(has_toString)&lt;/span&gt;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; obj-&amp;gt;&lt;span class=&quot;hljs-title&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;toString not defined&quot;&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2&gt;Pre-C++20 - Detection toolkit&lt;/h2&gt;\n&lt;p&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf&quot; rel=&quot;noreferrer&quot;&gt;N4502&lt;/a&gt; proposes a detection toolkit for inclusion into the C++17 standard library that eventually made it into the library fundamentals TS v2. It most likely won&apos;t ever get into the standard because it has been subsumed by &lt;code&gt;requires&lt;/code&gt; expressions since, but it still solves the problem in a somewhat elegant manner. The toolkit introduces some metafunctions, including &lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/is_detected&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;std::is_detected&lt;/code&gt;&lt;/a&gt; which can be used to easily write type or function detection metafunctions on the top of it. Here is how you could use it:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; toString_t = &lt;span class=&quot;hljs-keyword&quot;&gt;decltype&lt;/span&gt;( std::&lt;span class=&quot;hljs-built_in&quot;&gt;declval&lt;/span&gt;&amp;lt;T&amp;amp;&amp;gt;().&lt;span class=&quot;hljs-built_in&quot;&gt;toString&lt;/span&gt;() );\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; has_toString = std::is_detected_v&amp;lt;toString_t, T&amp;gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Note that the example above is untested. The detection toolkit is not available in standard libraries yet but the proposal contains a full implementation that you can easily copy if you really need it. It plays nice with the C++17 feature &lt;code&gt;if constexpr&lt;/code&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; T&amp;gt;\nstd::string &lt;span class=&quot;hljs-title&quot;&gt;optionalToString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T* obj)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(has_toString&amp;lt;T&amp;gt;)&lt;/span&gt;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; obj-&amp;gt;&lt;span class=&quot;hljs-title&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;toString not defined&quot;&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2&gt;C++14 - Boost.Hana&lt;/h2&gt;\n&lt;p&gt;Boost.Hana apparently builds upon this specific example and provides a solution for C++14 in its documentation, so I&apos;m going to quote it directly:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;[...] Hana provides a &lt;code&gt;is_valid&lt;/code&gt; function that can be combined with C++14 generic lambdas to obtain a much cleaner implementation of the same thing:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; has_toString = hana::&lt;span class=&quot;hljs-built_in&quot;&gt;is_valid&lt;/span&gt;([](&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt;&amp;amp;&amp;amp; obj) -&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;decltype&lt;/span&gt;(obj.&lt;span class=&quot;hljs-built_in&quot;&gt;toString&lt;/span&gt;()) { });\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This leaves us with a function object &lt;code&gt;has_toString&lt;/code&gt; which returns whether the given expression is valid on the argument we pass to it. The result is returned as an &lt;code&gt;IntegralConstant&lt;/code&gt;, so constexpr-ness is not an issue here because the result of the function is represented as a type anyway. Now, in addition to being less verbose (that&apos;s a one liner!), the intent is much clearer. Other benefits are the fact that &lt;code&gt;has_toString&lt;/code&gt; can be passed to higher order algorithms and it can also be defined at function scope, so there is no need to pollute the namespace scope with implementation details.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2&gt;Boost.TTI&lt;/h2&gt;\n&lt;p&gt;Another somewhat idiomatic toolkit to perform such a check - even though less elegant - is &lt;a href=&quot;http://www.boost.org/doc/libs/1_55_0/libs/tti/doc/html/index.html&quot; rel=&quot;noreferrer&quot;&gt;Boost.TTI&lt;/a&gt;, introduced in Boost 1.54.0. For your example, you would have to use the macro &lt;code&gt;BOOST_TTI_HAS_MEMBER_FUNCTION&lt;/code&gt;. Here is how you could use it:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;boost/tti/has_member_function.hpp&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// Generate the metafunction&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;BOOST_TTI_HAS_MEMBER_FUNCTION&lt;/span&gt;(toString)\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// Check whether T has a member function toString&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// which takes no parameter and returns a std::string&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; foo = has_member_function_toString&amp;lt;T, std::string&amp;gt;::value;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Then, you could use the &lt;code&gt;bool&lt;/code&gt; to create a SFINAE check.&lt;/p&gt;\n&lt;p&gt;&lt;em&gt;Explanation&lt;/em&gt;&lt;/p&gt;\n&lt;p&gt;The macro &lt;code&gt;BOOST_TTI_HAS_MEMBER_FUNCTION&lt;/code&gt; generates the metafunction &lt;code&gt;has_member_function_toString&lt;/code&gt; which takes the checked type as its first template parameter. The second template parameter corresponds to the return type of the member function, and the following parameters correspond to the types of the function&apos;s parameters. The member &lt;code&gt;value&lt;/code&gt; contains &lt;code&gt;true&lt;/code&gt; if the class &lt;code&gt;T&lt;/code&gt; has a member function &lt;code&gt;std::string toString()&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;Alternatively, &lt;code&gt;has_member_function_toString&lt;/code&gt; can take a member function pointer as a template parameter. Therefore, it is possible to replace &lt;code&gt;has_member_function_toString&amp;lt;T, std::string&amp;gt;::value&lt;/code&gt; by &lt;code&gt;has_member_function_toString&amp;lt;std::string T::* ()&amp;gt;::value&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;Though this question is two years old, I&apos;ll dare to add my answer. Hopefully it will clarify the previous, indisputably excellent, solution. I took the very helpful answers of Nicola Bonelli and Johannes Schaub and merged them into a solution that is, IMHO, more readable, clear and does not require the &lt;code&gt;typeof&lt;/code&gt; extension:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Type&lt;/span&gt;&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;TypeHasToString&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-comment&quot;&gt;// This type won&apos;t compile if the second template parameter isn&apos;t of type T,&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// so I can put a function pointer type in the first parameter and the function&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// itself in the second thus checking that the function has a specific signature.&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T, T&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;TypeCheck&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; Yes;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;long&lt;/span&gt; No;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// A helper struct to hold the declaration of the function pointer.&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Change it if the function signature changes.&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ToString&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(T::*fptr)&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;\n    };\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; Yes &lt;span class=&quot;hljs-title&quot;&gt;HasToString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(TypeCheck&amp;lt; &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; ToString&amp;lt;T&amp;gt;::fptr, &amp;amp;T::toString &amp;gt;*)&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; No  &lt;span class=&quot;hljs-title&quot;&gt;HasToString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(...)&lt;/span&gt;&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n    &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; value = (&lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;HasToString&lt;/span&gt;&amp;lt;Type&amp;gt;(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)) == &lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;(Yes));\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I checked it with gcc 4.1.2.\nThe credit goes mainly to Nicola Bonelli and Johannes Schaub, so give them a vote up if my answer helps you :)&lt;/p&gt;\n    ","\n&lt;p&gt;A simple solution for C++11:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;optionalToString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T* obj)&lt;/span&gt;\n -&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;decltype&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(  obj-&amp;gt;toString()  )&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;     obj-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;toString&lt;/span&gt;();\n}\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;optionalToString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(...)&lt;/span&gt; -&amp;gt; string\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;toString not defined&quot;&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Update, 3 years later: (and this is untested). To test for the existence, I think this will work:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;test_has_toString_method&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T* obj)&lt;/span&gt;\n -&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;decltype&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(  obj-&amp;gt;toString() , std::true_type{} )&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;     obj-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;toString&lt;/span&gt;();\n}\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;test_has_toString_method&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(...)&lt;/span&gt; -&amp;gt; std::false_type\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;toString not defined&quot;&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Well, this question has a long list of answers already, but I would like to emphasize the comment from Morwenn: there is a proposal for C++17 that makes it really much simpler.  See &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf&quot; rel=&quot;noreferrer&quot; title=&quot;Proposing Standard Library Support for the C++ Detection Idiom, v2&quot;&gt;N4502&lt;/a&gt; for details, but as a self-contained example consider the following.&lt;/p&gt;\n\n&lt;p&gt;This part is the constant part, put it in a header.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// See http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf.&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt;...&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;void_t&lt;/span&gt; = &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// Primary template handles all types not supporting the operation.&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; = &lt;span class=&quot;hljs-type&quot;&gt;void_t&lt;/span&gt;&amp;lt;&amp;gt;&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; detect : std::false_type {};\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// Specialization recognizes/validates only types supporting the archetype.&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T, &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Op&lt;/span&gt;&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;detect&lt;/span&gt;&amp;lt;T, Op, &lt;span class=&quot;hljs-type&quot;&gt;void_t&lt;/span&gt;&amp;lt;Op&amp;lt;T&amp;gt;&amp;gt;&amp;gt; : std::true_type {};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;then there is the variable part, where you specify what you are looking for (a type, a member type, a function, a member function etc.).  In the case of the OP:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; toString_t = &lt;span class=&quot;hljs-keyword&quot;&gt;decltype&lt;/span&gt;(std::&lt;span class=&quot;hljs-built_in&quot;&gt;declval&lt;/span&gt;&amp;lt;T&amp;gt;().&lt;span class=&quot;hljs-built_in&quot;&gt;toString&lt;/span&gt;());\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; has_toString = detect&amp;lt;T, toString_t&amp;gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The following example, taken from &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf&quot; rel=&quot;noreferrer&quot; title=&quot;Proposing Standard Library Support for the C++ Detection Idiom, v2&quot;&gt;N4502&lt;/a&gt;, shows a more elaborate probe:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Archetypal expression for assignment operation.&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;assign_t&lt;/span&gt; = &lt;span class=&quot;hljs-keyword&quot;&gt;decltype&lt;/span&gt;(std::&lt;span class=&quot;hljs-built_in&quot;&gt;declval&lt;/span&gt;&amp;lt;T&amp;amp;&amp;gt;() = std::&lt;span class=&quot;hljs-built_in&quot;&gt;declval&lt;/span&gt;&amp;lt;T &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &amp;amp;&amp;gt;())\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// Trait corresponding to that archetype.&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; is_assignable = detect&amp;lt;T, &lt;span class=&quot;hljs-type&quot;&gt;assign_t&lt;/span&gt;&amp;gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Compared to the other implementations described above, this one is fairly simple: a reduced set of tools (&lt;code&gt;void_t&lt;/code&gt; and &lt;code&gt;detect&lt;/code&gt;) suffices, no need for hairy macros.  Besides, it was reported (see &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf&quot; rel=&quot;noreferrer&quot; title=&quot;Proposing Standard Library Support for the C++ Detection Idiom, v2&quot;&gt;N4502&lt;/a&gt;) that it is measurably more efficient (compile-time and compiler memory consumption) than previous approaches.&lt;/p&gt;\n\n&lt;p&gt;Here is a &lt;a href=&quot;http://coliru.stacked-crooked.com/a/7eae9c76232a2d20&quot; rel=&quot;noreferrer&quot; title=&quot;Detection idiom&quot;&gt;live example&lt;/a&gt;.  It works fine with Clang, but unfortunately, GCC versions before 5.1 followed a different interpretation of the C++11 standard which caused &lt;code&gt;void_t&lt;/code&gt; to not work as expected.  Yakk already provided the work-around: use the following definition of &lt;code&gt;void_t&lt;/code&gt; (&lt;a href=&quot;https://stackoverflow.com/questions/28967003/void-t-in-parameter-list-works-but-not-as-return-type/28967049#28967049&quot;&gt;void_t in parameter list works but not as return type&lt;/a&gt;):&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; __GNUC__ &amp;lt; 5 &amp;amp;&amp;amp; ! defined __clang__&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// https://stackoverflow.com/a/28967049/1353549&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt;...&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;voider&lt;/span&gt;\n{\n  &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; type = &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;;\n};\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt;...Ts&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;void_t&lt;/span&gt; = &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; voider&amp;lt;Ts...&amp;gt;::type;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt;...&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;void_t&lt;/span&gt; = &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;This is what type traits are there for. Unfortunately, they have to be defined manually. In your case, imagine the following:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;response_trait&lt;/span&gt; {\n    &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; has_tostring = &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;;\n};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;response_trait&lt;/span&gt;&amp;lt;your_type_with_tostring&amp;gt; {\n    &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; has_tostring = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;This is a C++11 solution for the general problem if &quot;If I did X, would it compile?&quot;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;type_sink&lt;/span&gt; { &lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; type; }; &lt;span class=&quot;hljs-comment&quot;&gt;// consumes a type, and makes it `void`&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;type_sink_t&lt;/span&gt; = &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; type_sink&amp;lt;T&amp;gt;::type;\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;T&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; has_to_string : std::false_type {}; \\\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;has_to_string&lt;/span&gt;&amp;lt;\n  T,\n  &lt;span class=&quot;hljs-type&quot;&gt;type_sink_t&lt;/span&gt;&amp;lt; &lt;span class=&quot;hljs-keyword&quot;&gt;decltype&lt;/span&gt;( std::&lt;span class=&quot;hljs-built_in&quot;&gt;declval&lt;/span&gt;&amp;lt;T&amp;gt;().&lt;span class=&quot;hljs-built_in&quot;&gt;toString&lt;/span&gt;() ) &amp;gt;\n&amp;gt;: std::true_type {};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Trait &lt;code&gt;has_to_string&lt;/code&gt; such that &lt;code&gt;has_to_string&amp;lt;T&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if and only if &lt;code&gt;T&lt;/code&gt; has a method &lt;code&gt;.toString&lt;/code&gt; that can be invoked with 0 arguments in this context.&lt;/p&gt;\n\n&lt;p&gt;Next, I&apos;d use tag dispatching:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; details {\n  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; T&amp;gt;\n  std::string &lt;span class=&quot;hljs-title&quot;&gt;optionalToString_helper&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T* obj, std::true_type &lt;span class=&quot;hljs-comment&quot;&gt;/*has_to_string*/&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; obj-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;toString&lt;/span&gt;();\n  }\n  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; T&amp;gt;\n  std::string &lt;span class=&quot;hljs-title&quot;&gt;optionalToString_helper&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T* obj, std::false_type &lt;span class=&quot;hljs-comment&quot;&gt;/*has_to_string*/&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;toString not defined&quot;&lt;/span&gt;;\n  }\n}\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; T&amp;gt;\nstd::string &lt;span class=&quot;hljs-title&quot;&gt;optionalToString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T* obj)&lt;/span&gt; &lt;/span&gt;{\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; details::&lt;span class=&quot;hljs-built_in&quot;&gt;optionalToString_helper&lt;/span&gt;( obj, has_to_string&amp;lt;T&amp;gt;{} );\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;which tends to be more maintainable than complex SFINAE expressions.&lt;/p&gt;\n\n&lt;p&gt;You can write these traits with a macro if you find yourself doing it alot, but they are relatively simple (a few lines each) so maybe not worth it:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; MAKE_CODE_TRAIT( TRAIT_NAME, ... ) \\\ntemplate&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;class T, class=void&amp;gt;&lt;/span&gt; struct TRAIT_NAME : std::false_type {}; \\\ntemplate&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;class T&amp;gt;&lt;/span&gt; struct TRAIT_NAME&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt; T, type_sink_t&amp;lt; decltype( __VA_ARGS__ ) &amp;gt;&lt;/span&gt; &amp;gt;: std::true_type {};&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;what the above does is create a macro &lt;code&gt;MAKE_CODE_TRAIT&lt;/code&gt;.  You pass it the name of the trait you want, and some code that can test the type &lt;code&gt;T&lt;/code&gt;.  Thus:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;MAKE_CODE_TRAIT&lt;/span&gt;( has_to_string, std::&lt;span class=&quot;hljs-built_in&quot;&gt;declval&lt;/span&gt;&amp;lt;T&amp;gt;().&lt;span class=&quot;hljs-built_in&quot;&gt;toString&lt;/span&gt;() )\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;creates the above traits class.&lt;/p&gt;\n\n&lt;p&gt;As an aside, the above technique is part of what MS calls &quot;expression SFINAE&quot;, and their 2013 compiler fails pretty hard.&lt;/p&gt;\n\n&lt;p&gt;Note that in C++1y the following syntax is possible:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; T&amp;gt;\nstd::string &lt;span class=&quot;hljs-title&quot;&gt;optionalToString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T* obj)&lt;/span&gt; &lt;/span&gt;{\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;compiled_if&lt;/span&gt;&amp;lt; has_to_string &amp;gt;(*obj, [&amp;amp;](&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt;&amp;amp;&amp;amp; obj) {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; obj.&lt;span class=&quot;hljs-built_in&quot;&gt;toString&lt;/span&gt;();\n  }) *&lt;span class=&quot;hljs-built_in&quot;&gt;compiled_else&lt;/span&gt; ([&amp;amp;]{ \n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;toString not defined&quot;&lt;/span&gt;;\n  });\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;which is an inline compilation conditional branch that abuses lots of C++ features.  Doing so is probably not worth it, as the benefit (of code being inline) is not worth the cost (of next to nobody understanding how it works), but the existence of that above solution may be of interest.&lt;/p&gt;\n    ","\n&lt;p&gt;With C++ 20 you can write the following:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;concept&lt;/span&gt; has_toString = &lt;span class=&quot;hljs-built_in&quot;&gt;requires&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; T&amp;amp; t) {\n    t.&lt;span class=&quot;hljs-built_in&quot;&gt;toString&lt;/span&gt;();\n};\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\nstd::string &lt;span class=&quot;hljs-title&quot;&gt;optionalToString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; T&amp;amp; obj)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(has_toString&amp;lt;T&amp;gt;)&lt;/span&gt;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; obj.&lt;span class=&quot;hljs-title&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;toString not defined&quot;&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Here are some usage snippets:\n*The guts for all this are farther down&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Check for member &lt;code&gt;x&lt;/code&gt; in a given class.  Could be var, func, class, union, or enum:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;CREATE_MEMBER_CHECK&lt;/span&gt;(x);\n&lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; has_x = has_member_x&amp;lt;class_to_check_for_x&amp;gt;::value;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;Check for member function &lt;code&gt;void x()&lt;/code&gt;:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//Func signature MUST have T as template variable here... simpler this way :\\\nCREATE_MEMBER_FUNC_SIG_CHECK(x, void (T::*)(), void__x);&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; has_func_sig_void__x = has_member_func_void__x&amp;lt;class_to_check_for_x&amp;gt;::value;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;Check for member variable &lt;code&gt;x&lt;/code&gt;:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;CREATE_MEMBER_VAR_CHECK&lt;/span&gt;(x);\n&lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; has_var_x = has_member_var_x&amp;lt;class_to_check_for_x&amp;gt;::value;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;Check for member class &lt;code&gt;x&lt;/code&gt;:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;CREATE_MEMBER_CLASS_CHECK&lt;/span&gt;(x);\n&lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; has_class_x = has_member_class_x&amp;lt;class_to_check_for_x&amp;gt;::value;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;Check for member union &lt;code&gt;x&lt;/code&gt;:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;CREATE_MEMBER_UNION_CHECK&lt;/span&gt;(x);\n&lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; has_union_x = has_member_union_x&amp;lt;class_to_check_for_x&amp;gt;::value;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;Check for member enum &lt;code&gt;x&lt;/code&gt;:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;CREATE_MEMBER_ENUM_CHECK&lt;/span&gt;(x);\n&lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; has_enum_x = has_member_enum_x&amp;lt;class_to_check_for_x&amp;gt;::value;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;Check for any member function &lt;code&gt;x&lt;/code&gt; regardless of signature:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;CREATE_MEMBER_CHECK&lt;/span&gt;(x);\n&lt;span class=&quot;hljs-built_in&quot;&gt;CREATE_MEMBER_VAR_CHECK&lt;/span&gt;(x);\n&lt;span class=&quot;hljs-built_in&quot;&gt;CREATE_MEMBER_CLASS_CHECK&lt;/span&gt;(x);\n&lt;span class=&quot;hljs-built_in&quot;&gt;CREATE_MEMBER_UNION_CHECK&lt;/span&gt;(x);\n&lt;span class=&quot;hljs-built_in&quot;&gt;CREATE_MEMBER_ENUM_CHECK&lt;/span&gt;(x);\n&lt;span class=&quot;hljs-built_in&quot;&gt;CREATE_MEMBER_FUNC_CHECK&lt;/span&gt;(x);\n&lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; has_any_func_x = has_member_func_x&amp;lt;class_to_check_for_x&amp;gt;::value;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;OR&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;CREATE_MEMBER_CHECKS&lt;/span&gt;(x);  &lt;span class=&quot;hljs-comment&quot;&gt;//Just stamps out the same macro calls as above.&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; has_any_func_x = has_member_func_x&amp;lt;class_to_check_for_x&amp;gt;::value;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;Details and core:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;/*\n    - Multiple inheritance forces ambiguity of member names.\n    - SFINAE is used to make aliases to member names.\n    - Expression SFINAE is used in just one generic has_member that can accept\n      any alias we pass it.\n*/&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;//Variadic to force ambiguity of class members.  C++11 and up.&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt;... Args&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ambiguate&lt;/span&gt; : &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Args... {};\n\n&lt;span class=&quot;hljs-comment&quot;&gt;//Non-variadic version of the line above.&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;//template &amp;lt;typename A, typename B&amp;gt; struct ambiguate : public A, public B {};&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; A, &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; = &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; got_type : std::false_type {};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; A&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;got_type&lt;/span&gt;&amp;lt;A&amp;gt; : std::true_type {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; A type;\n};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T, T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;sig_check&lt;/span&gt; : std::true_type {};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; Alias, &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; AmbiguitySeed&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;has_member&lt;/span&gt; {\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; C&amp;gt; &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;((&amp;amp;f(&lt;span class=&quot;hljs-keyword&quot;&gt;decltype&lt;/span&gt;(&amp;amp;C::value))))&lt;/span&gt;[1]&lt;/span&gt;;\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; C&amp;gt; &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;((&amp;amp;f(...)))&lt;/span&gt;[2]&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;//Make sure the member name is consistently spelled the same.&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;(\n        (&lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;f&lt;/span&gt;&amp;lt;AmbiguitySeed&amp;gt;(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)) == &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)\n        , &lt;span class=&quot;hljs-string&quot;&gt;&quot;Member name specified in AmbiguitySeed is different from member name specified in Alias, or wrong Alias/AmbiguitySeed has been specified.&quot;&lt;/span&gt;\n    );\n\n    &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; value = &lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;f&lt;/span&gt;&amp;lt;Alias&amp;gt;(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)) == &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;strong&gt;Macros (El Diablo!):&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;CREATE_MEMBER_CHECK:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//Check for any member with given name, whether var, func, class, union, enum.&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; CREATE_MEMBER_CHECK(member)                                         \\\n                                                                            \\\ntemplate&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typename T, typename = std::true_type&amp;gt;&lt;/span&gt;                             \\\nstruct Alias_##member;                                                      \\\n                                                                            \\\ntemplate&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typename T&amp;gt;&lt;/span&gt;                                                        \\\nstruct Alias_##member &amp;lt;                                                     \\\n    T, std::integral_constant&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;bool, got_type&amp;lt;decltype(&amp;amp;T::member)&amp;gt;&lt;/span&gt;::value&amp;gt;  \\\n&amp;gt; { static const decltype(&amp;amp;T::member) value; };                             \\\n                                                                            \\\nstruct AmbiguitySeed_##member { char member; };                             \\\n                                                                            \\\ntemplate&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typename T&amp;gt;&lt;/span&gt;                                                        \\\nstruct has_member_##member {                                                \\\n    static const bool value                                                 \\\n        = has_member&amp;lt;                                                       \\\n            Alias_##member&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;ambiguate&amp;lt;T, AmbiguitySeed_##member&amp;gt;&lt;/span&gt;&amp;gt;            \\\n            , Alias_##member&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;AmbiguitySeed_##member&amp;gt;&lt;/span&gt;                        \\\n        &amp;gt;::value                                                            \\\n    ;                                                                       \\\n}&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;CREATE_MEMBER_VAR_CHECK:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//Check for member variable with given name.&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; CREATE_MEMBER_VAR_CHECK(var_name)                                   \\\n                                                                            \\\ntemplate&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typename T, typename = std::true_type&amp;gt;&lt;/span&gt;                             \\\nstruct has_member_var_##var_name : std::false_type {};                      \\\n                                                                            \\\ntemplate&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typename T&amp;gt;&lt;/span&gt;                                                        \\\nstruct has_member_var_##var_name&amp;lt;                                           \\\n    T                                                                       \\\n    , std::integral_constant&amp;lt;                                               \\\n        bool                                                                \\\n        , !std::is_member_function_pointer&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;decltype(&amp;amp;T::var_name)&amp;gt;&lt;/span&gt;::value   \\\n    &amp;gt;                                                                       \\\n&amp;gt; : std::true_type {}&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;CREATE_MEMBER_FUNC_SIG_CHECK:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//Check for member function with given name AND signature.&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; CREATE_MEMBER_FUNC_SIG_CHECK(func_name, func_sig, templ_postfix)    \\\n                                                                            \\\ntemplate&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typename T, typename = std::true_type&amp;gt;&lt;/span&gt;                             \\\nstruct has_member_func_##templ_postfix : std::false_type {};                \\\n                                                                            \\\ntemplate&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typename T&amp;gt;&lt;/span&gt;                                                        \\\nstruct has_member_func_##templ_postfix&amp;lt;                                     \\\n    T, std::integral_constant&amp;lt;                                              \\\n        bool                                                                \\\n        , sig_check&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;func_sig, &amp;amp;T::func_name&amp;gt;&lt;/span&gt;::value                         \\\n    &amp;gt;                                                                       \\\n&amp;gt; : std::true_type {}&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;CREATE_MEMBER_CLASS_CHECK:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//Check for member class with given name.&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; CREATE_MEMBER_CLASS_CHECK(class_name)               \\\n                                                            \\\ntemplate&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typename T, typename = std::true_type&amp;gt;&lt;/span&gt;             \\\nstruct has_member_class_##class_name : std::false_type {};  \\\n                                                            \\\ntemplate&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typename T&amp;gt;&lt;/span&gt;                                        \\\nstruct has_member_class_##class_name&amp;lt;                       \\\n    T                                                       \\\n    , std::integral_constant&amp;lt;                               \\\n        bool                                                \\\n        , std::is_class&amp;lt;                                    \\\n            typename got_type&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typename T::class_name&amp;gt;&lt;/span&gt;::type \\\n        &amp;gt;::value                                            \\\n    &amp;gt;                                                       \\\n&amp;gt; : std::true_type {}&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;CREATE_MEMBER_UNION_CHECK:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//Check for member union with given name.&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; CREATE_MEMBER_UNION_CHECK(union_name)               \\\n                                                            \\\ntemplate&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typename T, typename = std::true_type&amp;gt;&lt;/span&gt;             \\\nstruct has_member_union_##union_name : std::false_type {};  \\\n                                                            \\\ntemplate&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typename T&amp;gt;&lt;/span&gt;                                        \\\nstruct has_member_union_##union_name&amp;lt;                       \\\n    T                                                       \\\n    , std::integral_constant&amp;lt;                               \\\n        bool                                                \\\n        , std::is_union&amp;lt;                                    \\\n            typename got_type&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typename T::union_name&amp;gt;&lt;/span&gt;::type \\\n        &amp;gt;::value                                            \\\n    &amp;gt;                                                       \\\n&amp;gt; : std::true_type {}&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;CREATE_MEMBER_ENUM_CHECK:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//Check for member enum with given name.&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; CREATE_MEMBER_ENUM_CHECK(enum_name)                 \\\n                                                            \\\ntemplate&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typename T, typename = std::true_type&amp;gt;&lt;/span&gt;             \\\nstruct has_member_enum_##enum_name : std::false_type {};    \\\n                                                            \\\ntemplate&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typename T&amp;gt;&lt;/span&gt;                                        \\\nstruct has_member_enum_##enum_name&amp;lt;                         \\\n    T                                                       \\\n    , std::integral_constant&amp;lt;                               \\\n        bool                                                \\\n        , std::is_enum&amp;lt;                                     \\\n            typename got_type&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typename T::enum_name&amp;gt;&lt;/span&gt;::type  \\\n        &amp;gt;::value                                            \\\n    &amp;gt;                                                       \\\n&amp;gt; : std::true_type {}&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;CREATE_MEMBER_FUNC_CHECK:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//Check for function with given name, any signature.&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; CREATE_MEMBER_FUNC_CHECK(func)          \\\ntemplate&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typename T&amp;gt;&lt;/span&gt;                            \\\nstruct has_member_func_##func {                 \\\n    static const bool value                     \\\n        = has_member_##func&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;T&amp;gt;&lt;/span&gt;::value           \\\n        &amp;amp;&amp;amp; !has_member_var_##func&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;T&amp;gt;&lt;/span&gt;::value     \\\n        &amp;amp;&amp;amp; !has_member_class_##func&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;T&amp;gt;&lt;/span&gt;::value   \\\n        &amp;amp;&amp;amp; !has_member_union_##func&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;T&amp;gt;&lt;/span&gt;::value   \\\n        &amp;amp;&amp;amp; !has_member_enum_##func&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;T&amp;gt;&lt;/span&gt;::value    \\\n    ;                                           \\\n}&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;CREATE_MEMBER_CHECKS:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//Create all the checks for one member.  Does NOT include func sig checks.&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; CREATE_MEMBER_CHECKS(member)    \\\nCREATE_MEMBER_CHECK(member);            \\\nCREATE_MEMBER_VAR_CHECK(member);        \\\nCREATE_MEMBER_CLASS_CHECK(member);      \\\nCREATE_MEMBER_UNION_CHECK(member);      \\\nCREATE_MEMBER_ENUM_CHECK(member);       \\\nCREATE_MEMBER_FUNC_CHECK(member)&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Yet another way to do it in C++17 (inspired by &lt;code&gt;boost:hana&lt;/code&gt;).&lt;/p&gt;\n&lt;p&gt;This solution does not require &lt;code&gt;has_something&amp;lt;T&amp;gt;&lt;/code&gt; SFINAE type traits classes.&lt;/p&gt;\n&lt;h3&gt;Solution&lt;/h3&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;////////////////////////////////////////////&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// has_member implementation&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;////////////////////////////////////////////&lt;/span&gt;\n\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;type_traits&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T, &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; F&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;has_member_impl&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(F&amp;amp;&amp;amp; f)&lt;/span&gt; -&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;decltype&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(f(std::declval&amp;lt;T&amp;gt;()), &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;)&lt;/span&gt;\n&lt;/span&gt;{\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt;&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;has_member_impl&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(...)&lt;/span&gt; &lt;/span&gt;{ &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;; }\n\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; has_member(T, EXPR) \\\n has_member_impl&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;T&amp;gt;&lt;/span&gt;( [](auto&amp;amp;&amp;amp; obj)-&amp;gt;decltype(obj.EXPR){} )&lt;/span&gt;\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;Test&lt;/h3&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;////////////////////////////////////////////&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// Test&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;////////////////////////////////////////////&lt;/span&gt;\n\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Example&lt;/span&gt; {\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; Foo;\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{}\n    &lt;span class=&quot;hljs-function&quot;&gt;std::string &lt;span class=&quot;hljs-title&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello from Example::toString()!&quot;&lt;/span&gt;; }\n};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Example2&lt;/span&gt; {\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; X;\n};\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; T&amp;gt;\nstd::string &lt;span class=&quot;hljs-title&quot;&gt;optionalToString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T* obj)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;constexpr&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(has_member(T, toString()))&lt;/span&gt;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; obj-&amp;gt;&lt;span class=&quot;hljs-title&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;toString not defined&quot;&lt;/span&gt;;\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;has_member&lt;/span&gt;(Example, Foo), \n                  &lt;span class=&quot;hljs-string&quot;&gt;&quot;Example class must have Foo member&quot;&lt;/span&gt;);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;has_member&lt;/span&gt;(Example, &lt;span class=&quot;hljs-built_in&quot;&gt;Bar&lt;/span&gt;()), \n                  &lt;span class=&quot;hljs-string&quot;&gt;&quot;Example class must have Bar() member function&quot;&lt;/span&gt;);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;(!&lt;span class=&quot;hljs-built_in&quot;&gt;has_member&lt;/span&gt;(Example, ZFoo), \n                  &lt;span class=&quot;hljs-string&quot;&gt;&quot;Example class must not have ZFoo member.&quot;&lt;/span&gt;);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;(!&lt;span class=&quot;hljs-built_in&quot;&gt;has_member&lt;/span&gt;(Example, &lt;span class=&quot;hljs-built_in&quot;&gt;ZBar&lt;/span&gt;()), \n                  &lt;span class=&quot;hljs-string&quot;&gt;&quot;Example class must not have ZBar() member function&quot;&lt;/span&gt;);\n\n    Example e1;\n    Example2 e2;\n\n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;e1: &quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;optionalToString&lt;/span&gt;(&amp;amp;e1) &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n&quot;&lt;/span&gt;;\n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;e1: &quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;optionalToString&lt;/span&gt;(&amp;amp;e2) &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n&quot;&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I wrote an answer to this in another thread that (unlike the solutions above) also checks inherited member functions:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1966362/sfinae-to-check-for-inherited-member-functions/8752988#8752988&quot;&gt;SFINAE to check for inherited member functions&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Here are some example from that solution:&lt;/p&gt;\n\n&lt;h2&gt;Example1:&lt;/h2&gt;\n\n&lt;p&gt;We are checking for a member with the following signature: \n&lt;code&gt;T::const_iterator begin() const&lt;/code&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;has_const_begin&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&amp;amp;Yes)&lt;/span&gt;[1]&lt;/span&gt;;\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&amp;amp;No)&lt;/span&gt;[2]&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; U&amp;gt; \n    &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; Yes &lt;span class=&quot;hljs-title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(U &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; * data, \n                    &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; std::enable_if&amp;lt;std::is_same&amp;lt;\n                             &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; U::const_iterator, \n                             &lt;span class=&quot;hljs-keyword&quot;&gt;decltype&lt;/span&gt;(data-&amp;gt;begin())\n                    &amp;gt;::value&amp;gt;::type * = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; No &lt;span class=&quot;hljs-title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(...)&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; value = &lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;(Yes) == &lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;(has_const_begin::&lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;((&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; std::remove_reference&amp;lt;T&amp;gt;::type*)&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;));\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Please notice that it even checks the constness of the method, and works with primitive types, as well. (I mean &lt;code&gt;has_const_begin&amp;lt;int&amp;gt;::value&lt;/code&gt; is false and doesn&apos;t cause a compile-time error.) &lt;/p&gt;\n\n&lt;h2&gt;Example 2&lt;/h2&gt;\n\n&lt;p&gt;Now we are looking for the signature: &lt;code&gt;void foo(MyClass&amp;amp;, unsigned)&lt;/code&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;has_foo&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&amp;amp;Yes)&lt;/span&gt;[1]&lt;/span&gt;;\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&amp;amp;No)&lt;/span&gt;[2]&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; U&amp;gt;\n    &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; Yes &lt;span class=&quot;hljs-title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(U * data, MyClass* arg1 = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,\n                    &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; std::enable_if&amp;lt;std::is_void&amp;lt;\n                             &lt;span class=&quot;hljs-keyword&quot;&gt;decltype&lt;/span&gt;(data-&amp;gt;foo(*arg1, &lt;span class=&quot;hljs-number&quot;&gt;1u&lt;/span&gt;))\n                    &amp;gt;::value&amp;gt;::type * = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; No &lt;span class=&quot;hljs-title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(...)&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; value = &lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;(Yes) == &lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;(has_foo::&lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;((&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; std::remove_reference&amp;lt;T&amp;gt;::type*)&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;));\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Please notice that MyClass doesn&apos;t has to be default constructible or to satisfy any special concept. The technique works with template members, as well.&lt;/p&gt;\n\n&lt;p&gt;I am eagerly waiting opinions regarding this.&lt;/p&gt;\n    ","\n&lt;p&gt;Here is the most concise way I found in C++20, which is very close from your question:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; T&amp;gt;\nstd::string &lt;span class=&quot;hljs-title&quot;&gt;optionalToString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T* obj)&lt;/span&gt;\n&lt;/span&gt;{\n  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;requires&lt;/span&gt; { obj-&amp;gt;toString(); })&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; obj-&amp;gt;&lt;span class=&quot;hljs-title&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;toString not defined&quot;&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;See it live on godbolt: &lt;a href=&quot;https://gcc.godbolt.org/z/5jb1d93Ms&quot; rel=&quot;noreferrer&quot;&gt;https://gcc.godbolt.org/z/5jb1d93Ms&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;The standard C++ solution presented here by litb will not work as expected if the method happens to be defined in a base class. &lt;/p&gt;\n\n&lt;p&gt;For a solution that handles this situation refer to :&lt;/p&gt;\n\n&lt;p&gt;In Russian :\n&lt;a href=&quot;http://www.rsdn.ru/forum/message/2759773.1.aspx&quot; rel=&quot;noreferrer&quot;&gt;http://www.rsdn.ru/forum/message/2759773.1.aspx&lt;/a&gt; &lt;/p&gt;\n\n&lt;p&gt;English Translation by Roman.Perepelitsa : \n&lt;a href=&quot;http://groups.google.com/group/comp.lang.c++.moderated/tree/browse_frm/thread/4f7c7a96f9afbe44/c95a7b4c645e449f?pli=1&quot; rel=&quot;noreferrer&quot;&gt;http://groups.google.com/group/comp.lang.c++.moderated/tree/browse_frm/thread/4f7c7a96f9afbe44/c95a7b4c645e449f?pli=1&lt;/a&gt; &lt;/p&gt;\n\n&lt;p&gt;It is insanely clever. However one issue with this solutiion is that gives compiler errors if the type being tested is one that cannot be used as a base class (e.g. primitive types)&lt;/p&gt;\n\n&lt;p&gt;In Visual Studio, I noticed that if working with method having no arguments, an extra pair of redundant ( )  needs to be inserted around the argments to deduce( )  in the sizeof expression.&lt;/p&gt;\n    ","\n&lt;p&gt;Now this was a &lt;em&gt;nice&lt;/em&gt; little puzzle - great question!&lt;/p&gt;\n\n&lt;p&gt;Here&apos;s an alternative to &lt;a href=&quot;https://stackoverflow.com/questions/257288/possible-for-c-template-to-check-for-a-functions-existence#257382&quot;&gt;Nicola Bonelli&apos;s solution&lt;/a&gt; that does not rely on the non-standard &lt;code&gt;typeof&lt;/code&gt; operator.&lt;/p&gt;\n\n&lt;p&gt;Unfortunately, it does not work on GCC (MinGW) 3.4.5 or Digital Mars 8.42n, but it does work on all versions of MSVC (including VC6) and on Comeau C++.&lt;/p&gt;\n\n&lt;p&gt;The longer comment block has the details on how it works (or is supposed to work).  As it says, I&apos;m not sure which behavior is standards compliant - I&apos;d welcome commentary on that.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;update - 7 Nov 2008:&lt;/p&gt;\n\n&lt;p&gt;It looks like while this code is syntactically correct, the behavior that MSVC and Comeau C++ show does not follow the standard (thanks to &lt;a href=&quot;https://stackoverflow.com/users/4727/leon-timmermans&quot;&gt;Leon Timmermans&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/users/34509/litb&quot;&gt;litb&lt;/a&gt; for pointing me in the right direction).  The C++03 standard says the following:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;14.6.2 Dependent names [temp.dep]&lt;/p&gt;\n  \n  &lt;p&gt;Paragraph 3&lt;/p&gt;\n  \n  &lt;p&gt;In the definition of a class template\n  or a member of a class template, if a\n  base class of the class template\n  depends on a template-parameter, the\n  base class scope is not examined\n  during unqualified name lookup either\n  at the point of definition of the\n  class template or member or during an\n  instantiation of the class template or\n  member.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;So, it looks like that when MSVC or Comeau consider the &lt;code&gt;toString()&lt;/code&gt; member function of &lt;code&gt;T&lt;/code&gt; performing name lookup at the call site in &lt;code&gt;doToString()&lt;/code&gt; when the template is instantiated, that is incorrect (even though it&apos;s actually the behavior I was looking for in this case).&lt;/p&gt;\n\n&lt;p&gt;The behavior of GCC and Digital Mars looks to be correct - in both cases the non-member &lt;code&gt;toString()&lt;/code&gt; function is bound to the call.&lt;/p&gt;\n\n&lt;p&gt;Rats - I thought I might have found a clever solution, instead I uncovered a couple compiler bugs...&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Hello&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-function&quot;&gt;std::string &lt;span class=&quot;hljs-title&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello&quot;&lt;/span&gt;;\n    }\n};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Generic&lt;/span&gt; {};\n\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// the following namespace keeps the toString() method out of&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;//  most everything - except the other stuff in this&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;//  compilation unit&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; {\n    &lt;span class=&quot;hljs-function&quot;&gt;std::string &lt;span class=&quot;hljs-title&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n    &lt;/span&gt;{\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;toString not defined&quot;&lt;/span&gt;;\n    }\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;optionalToStringImpl&lt;/span&gt; : &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; T\n    {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n        &lt;span class=&quot;hljs-function&quot;&gt;std::string &lt;span class=&quot;hljs-title&quot;&gt;doToString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n\n            &lt;span class=&quot;hljs-comment&quot;&gt;// in theory, the name lookup for this call to &lt;/span&gt;\n            &lt;span class=&quot;hljs-comment&quot;&gt;//  toString() should find the toString() in &lt;/span&gt;\n            &lt;span class=&quot;hljs-comment&quot;&gt;//  the base class T if one exists, but if one &lt;/span&gt;\n            &lt;span class=&quot;hljs-comment&quot;&gt;//  doesn&apos;t exist in the base class, it&apos;ll &lt;/span&gt;\n            &lt;span class=&quot;hljs-comment&quot;&gt;//  find the free toString() function in &lt;/span&gt;\n            &lt;span class=&quot;hljs-comment&quot;&gt;//  the private namespace.&lt;/span&gt;\n            &lt;span class=&quot;hljs-comment&quot;&gt;//&lt;/span&gt;\n            &lt;span class=&quot;hljs-comment&quot;&gt;// This theory works for MSVC (all versions&lt;/span&gt;\n            &lt;span class=&quot;hljs-comment&quot;&gt;//  from VC6 to VC9) and Comeau C++, but&lt;/span&gt;\n            &lt;span class=&quot;hljs-comment&quot;&gt;//  does not work with MinGW 3.4.5 or &lt;/span&gt;\n            &lt;span class=&quot;hljs-comment&quot;&gt;//  Digital Mars 8.42n&lt;/span&gt;\n            &lt;span class=&quot;hljs-comment&quot;&gt;//&lt;/span&gt;\n            &lt;span class=&quot;hljs-comment&quot;&gt;// I&apos;m honestly not sure what the standard says &lt;/span&gt;\n            &lt;span class=&quot;hljs-comment&quot;&gt;//  is the correct behavior here - it&apos;s sort &lt;/span&gt;\n            &lt;span class=&quot;hljs-comment&quot;&gt;//  of like ADL (Argument Dependent Lookup - &lt;/span&gt;\n            &lt;span class=&quot;hljs-comment&quot;&gt;//  also known as Koenig Lookup) but without&lt;/span&gt;\n            &lt;span class=&quot;hljs-comment&quot;&gt;//  arguments (except the implied &quot;this&quot; pointer)&lt;/span&gt;\n\n            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;toString&lt;/span&gt;();\n        }\n    };\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-function&quot;&gt;std::string &lt;span class=&quot;hljs-title&quot;&gt;optionalToString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T &amp;amp; obj)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-comment&quot;&gt;// ugly, hacky cast...&lt;/span&gt;\n    optionalToStringImpl&amp;lt;T&amp;gt;* temp = &lt;span class=&quot;hljs-keyword&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;optionalToStringImpl&amp;lt;T&amp;gt;*&amp;gt;( &amp;amp;obj);\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; temp-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;doToString&lt;/span&gt;();\n}\n\n\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;\n&lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;\n&lt;/span&gt;{\n    Hello helloObj;\n    Generic genericObj;\n\n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;optionalToString&lt;/span&gt;( helloObj) &amp;lt;&amp;lt; std::endl;\n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;optionalToString&lt;/span&gt;( genericObj) &amp;lt;&amp;lt; std::endl;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;An example using SFINAE and template partial specialization, by writing a &lt;code&gt;Has_foo&lt;/code&gt; concept check: &lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;type_traits&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;A&lt;/span&gt;{};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;B&lt;/span&gt;{ &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b)&lt;/span&gt;&lt;/span&gt;;};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;C&lt;/span&gt;{&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b)&lt;/span&gt;&lt;/span&gt;;};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;D&lt;/span&gt;{&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;E&lt;/span&gt;: &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; B{};\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// available in C++17 onwards as part of &amp;lt;type_traits&amp;gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt;...&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;void_t&lt;/span&gt; = &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T, &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; = &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; Has_foo: std::false_type{};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt; \n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Has_foo&lt;/span&gt;&amp;lt;T, &lt;span class=&quot;hljs-type&quot;&gt;void_t&lt;/span&gt;&amp;lt;\n    std::&lt;span class=&quot;hljs-type&quot;&gt;enable_if_t&lt;/span&gt;&amp;lt;\n        std::is_same&amp;lt;\n            &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;, \n            &lt;span class=&quot;hljs-keyword&quot;&gt;decltype&lt;/span&gt;(std::&lt;span class=&quot;hljs-built_in&quot;&gt;declval&lt;/span&gt;&amp;lt;T&amp;gt;().&lt;span class=&quot;hljs-built_in&quot;&gt;foo&lt;/span&gt;((&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;)&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;)&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;))\n        &amp;gt;::value\n    &amp;gt;\n&amp;gt;&amp;gt;: std::true_type{};\n\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; Has_foo&amp;lt;A&amp;gt;::value, &lt;span class=&quot;hljs-string&quot;&gt;&quot;A does not have a foo&quot;&lt;/span&gt;);\n&lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;(Has_foo&amp;lt;B&amp;gt;::value, &lt;span class=&quot;hljs-string&quot;&gt;&quot;B has a foo&quot;&lt;/span&gt;);\n&lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; Has_foo&amp;lt;C&amp;gt;::value, &lt;span class=&quot;hljs-string&quot;&gt;&quot;C has a foo with the wrong return. &quot;&lt;/span&gt;);\n&lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; Has_foo&amp;lt;D&amp;gt;::value, &lt;span class=&quot;hljs-string&quot;&gt;&quot;D has a foo with the wrong arguments. &quot;&lt;/span&gt;);\n&lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;(Has_foo&amp;lt;E&amp;gt;::value, &lt;span class=&quot;hljs-string&quot;&gt;&quot;E has a foo since it inherits from B&quot;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;MSVC has the __if_exists and __if_not_exists keywords (&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/x7wy9xh3(VS.80).aspx&quot; rel=&quot;noreferrer&quot;&gt;Doc&lt;/a&gt;). Together with the typeof-SFINAE approach of Nicola I could create a check for GCC and MSVC like the OP looked for.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; Source can be found &lt;a href=&quot;https://github.com/nob13/sfserialization/blob/master/sfserialization/isdefault.h&quot; rel=&quot;noreferrer&quot;&gt;Here&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;I modified the solution provided in &lt;a href=&quot;https://stackoverflow.com/a/264088/2712152&quot;&gt;https://stackoverflow.com/a/264088/2712152&lt;/a&gt; to make it a bit more general. Also since it doesn&apos;t use any of the new C++11 features we can use it with old compilers and should also work with msvc. But the compilers should enable C99 to use this since it uses variadic macros.&lt;/p&gt;\n\n&lt;p&gt;The following macro can be used to check if a particular class has a particular typedef or not.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;/** \n * @class      : HAS_TYPEDEF\n * @brief      : This macro will be used to check if a class has a particular\n * typedef or not.\n * @param typedef_name : Name of Typedef\n * @param name  : Name of struct which is going to be run the test for\n * the given particular typedef specified in typedef_name\n */&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; HAS_TYPEDEF(typedef_name, name)                           \\\n   template &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typename T&amp;gt;&lt;/span&gt;                                          \\\n   struct name {                                                  \\\n      typedef char yes[1];                                        \\\n      typedef char no[2];                                         \\\n      template &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typename U&amp;gt;&lt;/span&gt;                                       \\\n      struct type_check;                                          \\\n      template &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typename _1&amp;gt;&lt;/span&gt;                                      \\\n      static yes&amp;amp; chk(type_check&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typename _1::typedef_name&amp;gt;&lt;/span&gt;*);    \\\n      template &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typename&amp;gt;&lt;/span&gt;                                         \\\n      static no&amp;amp; chk(...);                                        \\\n      static bool const value = sizeof(chk&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;T&amp;gt;&lt;/span&gt;(0)) == sizeof(yes); \\\n   }&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The following macro can be used to check if a particular class has a particular member function or not with any given number of arguments.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;/** \n * @class      : HAS_MEM_FUNC\n * @brief      : This macro will be used to check if a class has a particular\n * member function implemented in the public section or not. \n * @param func : Name of Member Function\n * @param name : Name of struct which is going to be run the test for\n * the given particular member function name specified in func\n * @param return_type: Return type of the member function\n * @param ellipsis(...) : Since this is macro should provide test case for every\n * possible member function we use variadic macros to cover all possibilities\n */&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; HAS_MEM_FUNC(func, name, return_type, ...)                \\\n   template &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typename T&amp;gt;&lt;/span&gt;                                          \\\n   struct name {                                                  \\\n      typedef return_type (T::*Sign)(__VA_ARGS__);                \\\n      typedef char yes[1];                                        \\\n      typedef char no[2];                                         \\\n      template &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typename U, U&amp;gt;&lt;/span&gt;                                    \\\n      struct type_check;                                          \\\n      template &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typename _1&amp;gt;&lt;/span&gt;                                      \\\n      static yes&amp;amp; chk(type_check&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;Sign, &amp;amp;_1::func&amp;gt;&lt;/span&gt;*);              \\\n      template &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;typename&amp;gt;&lt;/span&gt;                                         \\\n      static no&amp;amp; chk(...);                                        \\\n      static bool const value = sizeof(chk&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;T&amp;gt;&lt;/span&gt;(0)) == sizeof(yes); \\\n   }&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;We can use the above 2 macros to perform the checks for has_typedef and has_mem_func as:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;A&lt;/span&gt; {\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n  &lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; check;\n  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;check_function&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{}\n};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;B&lt;/span&gt; {\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; b)&lt;/span&gt; &lt;/span&gt;{}\n  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{}\n};\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;HAS_MEM_FUNC&lt;/span&gt;(check_function, has_check_function, &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;, &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;);\n&lt;span class=&quot;hljs-built_in&quot;&gt;HAS_MEM_FUNC&lt;/span&gt;(hello, hello_check, &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt;);\n&lt;span class=&quot;hljs-built_in&quot;&gt;HAS_MEM_FUNC&lt;/span&gt;(hello, hello_void_check, &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;, &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;);\n&lt;span class=&quot;hljs-built_in&quot;&gt;HAS_TYPEDEF&lt;/span&gt;(check, has_typedef_check);\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n  std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Check Function A:&quot;&lt;/span&gt; &amp;lt;&amp;lt; has_check_function&amp;lt;A&amp;gt;::value &amp;lt;&amp;lt; std::endl;\n  std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Check Function B:&quot;&lt;/span&gt; &amp;lt;&amp;lt; has_check_function&amp;lt;B&amp;gt;::value &amp;lt;&amp;lt; std::endl;\n  std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello Function A:&quot;&lt;/span&gt; &amp;lt;&amp;lt; hello_check&amp;lt;A&amp;gt;::value &amp;lt;&amp;lt; std::endl;\n  std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello Function B:&quot;&lt;/span&gt; &amp;lt;&amp;lt; hello_check&amp;lt;B&amp;gt;::value &amp;lt;&amp;lt; std::endl;\n  std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello void Function A:&quot;&lt;/span&gt; &amp;lt;&amp;lt; hello_void_check&amp;lt;A&amp;gt;::value &amp;lt;&amp;lt; std::endl;\n  std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello void Function B:&quot;&lt;/span&gt; &amp;lt;&amp;lt; hello_void_check&amp;lt;B&amp;gt;::value &amp;lt;&amp;lt; std::endl;\n  std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Check Typedef A:&quot;&lt;/span&gt; &amp;lt;&amp;lt; has_typedef_check&amp;lt;A&amp;gt;::value &amp;lt;&amp;lt; std::endl;\n  std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Check Typedef B:&quot;&lt;/span&gt; &amp;lt;&amp;lt; has_typedef_check&amp;lt;B&amp;gt;::value &amp;lt;&amp;lt; std::endl;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Strange nobody suggested the following nice trick I saw once on this very site :&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;T&lt;/span&gt;&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;has_foo&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;S&lt;/span&gt; { &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(...)&lt;/span&gt;&lt;/span&gt;; };\n    &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;derived&lt;/span&gt; : S, T {};\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; V, V&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;W&lt;/span&gt; {};\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; X&amp;gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt; (&amp;amp;&lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;(W&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;void&lt;/span&gt; (X::*)(), &amp;amp;X::foo&amp;gt; *))[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;];\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt;&amp;gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt; (&amp;amp;&lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;(...))[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;];\n\n    &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; value = &lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;&amp;lt;derived&amp;gt;(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)) == &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You have to make sure T is a class. It seems that ambiguity in the lookup of foo is a substitution failure. I made it work on gcc, not sure if it is standard though.&lt;/p&gt;\n    ","\n&lt;p&gt;The generic template that can be used for checking if some &quot;feature&quot; is supported by the type:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;type_traits&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;TypeChecker&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; Type&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;is_supported&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-comment&quot;&gt;// these structs are used to recognize which version&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// of the two functions was chosen during overload resolution&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;supported&lt;/span&gt; {};\n    &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;not_supported&lt;/span&gt; {};\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// this overload of chk will be ignored by SFINAE principle&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// if TypeChecker&amp;lt;Type_&amp;gt; is invalid type&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; Type_&amp;gt;\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; supported &lt;span class=&quot;hljs-title&quot;&gt;chk&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; std::decay&amp;lt;TypeChecker&amp;lt;Type_&amp;gt;&amp;gt;::type *)&lt;/span&gt;&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// ellipsis has the lowest conversion rank, so this overload will be&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// chosen during overload resolution only if the template overload above is ignored&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; Type_&amp;gt;\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; not_supported &lt;span class=&quot;hljs-title&quot;&gt;chk&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(...)&lt;/span&gt;&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// if the template overload of chk is chosen during&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// overload resolution then the feature is supported&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// if the ellipses overload is chosen the the feature is not supported&lt;/span&gt;\n    &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; value = std::is_same&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;decltype&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;chk&lt;/span&gt;&amp;lt;Type&amp;gt;(&lt;span class=&quot;hljs-literal&quot;&gt;nullptr&lt;/span&gt;)),supported&amp;gt;::value;\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The template that checks whether there is a method &lt;code&gt;foo&lt;/code&gt; that is compatible with signature &lt;code&gt;double(const char*)&lt;/code&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// if T doesn&apos;t have foo method with the signature that allows to compile the bellow&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// expression then instantiating this template is Substitution Failure (SF)&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// which Is Not An Error (INAE) if this happens during overload resolution&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; has_foo = &lt;span class=&quot;hljs-keyword&quot;&gt;decltype&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;double&lt;/span&gt;(std::&lt;span class=&quot;hljs-built_in&quot;&gt;declval&lt;/span&gt;&amp;lt;T&amp;gt;().&lt;span class=&quot;hljs-built_in&quot;&gt;foo&lt;/span&gt;(std::&lt;span class=&quot;hljs-built_in&quot;&gt;declval&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;*&amp;gt;())));\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Examples&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// types that support has_foo&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;struct1&lt;/span&gt; { &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;*)&lt;/span&gt;&lt;/span&gt;; };            &lt;span class=&quot;hljs-comment&quot;&gt;// exact signature match&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;struct2&lt;/span&gt; { &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;    &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; std::string &amp;amp;str)&lt;/span&gt;&lt;/span&gt;; }; &lt;span class=&quot;hljs-comment&quot;&gt;// compatible signature&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;struct3&lt;/span&gt; { &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt;  &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(...)&lt;/span&gt;&lt;/span&gt;; };                    &lt;span class=&quot;hljs-comment&quot;&gt;// compatible ellipsis signature&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;struct4&lt;/span&gt; { &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n                 &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;    &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T t)&lt;/span&gt;&lt;/span&gt;; };                    &lt;span class=&quot;hljs-comment&quot;&gt;// compatible template signature&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// types that do not support has_foo&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;struct5&lt;/span&gt; { &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;        &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;*)&lt;/span&gt;&lt;/span&gt;; }; &lt;span class=&quot;hljs-comment&quot;&gt;// returns void&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;struct6&lt;/span&gt; { &lt;span class=&quot;hljs-function&quot;&gt;std::string &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;*)&lt;/span&gt;&lt;/span&gt;; }; &lt;span class=&quot;hljs-comment&quot;&gt;// std::string can&apos;t be converted to double&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;struct7&lt;/span&gt; { &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt;      &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(      &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *)&lt;/span&gt;&lt;/span&gt;; }; &lt;span class=&quot;hljs-comment&quot;&gt;// const char* can&apos;t be converted to int*&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;struct8&lt;/span&gt; { &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt;      &lt;span class=&quot;hljs-title&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;*)&lt;/span&gt;&lt;/span&gt;; }; &lt;span class=&quot;hljs-comment&quot;&gt;// there is no foo method&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    std::cout &amp;lt;&amp;lt; std::boolalpha;\n\n    std::cout &amp;lt;&amp;lt; is_supported&amp;lt;has_foo, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;    &amp;gt;::value &amp;lt;&amp;lt; std::endl; &lt;span class=&quot;hljs-comment&quot;&gt;// false&lt;/span&gt;\n    std::cout &amp;lt;&amp;lt; is_supported&amp;lt;has_foo, &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; &amp;gt;::value &amp;lt;&amp;lt; std::endl; &lt;span class=&quot;hljs-comment&quot;&gt;// false&lt;/span&gt;\n\n    std::cout &amp;lt;&amp;lt; is_supported&amp;lt;has_foo, struct1&amp;gt;::value &amp;lt;&amp;lt; std::endl; &lt;span class=&quot;hljs-comment&quot;&gt;// true&lt;/span&gt;\n    std::cout &amp;lt;&amp;lt; is_supported&amp;lt;has_foo, struct2&amp;gt;::value &amp;lt;&amp;lt; std::endl; &lt;span class=&quot;hljs-comment&quot;&gt;// true&lt;/span&gt;\n    std::cout &amp;lt;&amp;lt; is_supported&amp;lt;has_foo, struct3&amp;gt;::value &amp;lt;&amp;lt; std::endl; &lt;span class=&quot;hljs-comment&quot;&gt;// true&lt;/span&gt;\n    std::cout &amp;lt;&amp;lt; is_supported&amp;lt;has_foo, struct4&amp;gt;::value &amp;lt;&amp;lt; std::endl; &lt;span class=&quot;hljs-comment&quot;&gt;// true&lt;/span&gt;\n\n    std::cout &amp;lt;&amp;lt; is_supported&amp;lt;has_foo, struct5&amp;gt;::value &amp;lt;&amp;lt; std::endl; &lt;span class=&quot;hljs-comment&quot;&gt;// false&lt;/span&gt;\n    std::cout &amp;lt;&amp;lt; is_supported&amp;lt;has_foo, struct6&amp;gt;::value &amp;lt;&amp;lt; std::endl; &lt;span class=&quot;hljs-comment&quot;&gt;// false&lt;/span&gt;\n    std::cout &amp;lt;&amp;lt; is_supported&amp;lt;has_foo, struct7&amp;gt;::value &amp;lt;&amp;lt; std::endl; &lt;span class=&quot;hljs-comment&quot;&gt;// false&lt;/span&gt;\n    std::cout &amp;lt;&amp;lt; is_supported&amp;lt;has_foo, struct8&amp;gt;::value &amp;lt;&amp;lt; std::endl; &lt;span class=&quot;hljs-comment&quot;&gt;// false&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://coliru.stacked-crooked.com/a/83c6a631ed42cea4&quot; rel=&quot;nofollow&quot;&gt;http://coliru.stacked-crooked.com/a/83c6a631ed42cea4&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;I know that this question is years old, but I think it would useful for people like me to have a more complete updated answer that also works for &lt;code&gt;const&lt;/code&gt; overloaded methods such as &lt;code&gt;std::vector&amp;lt;&amp;gt;::begin&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;Based on that &lt;a href=&quot;https://stackoverflow.com/a/257382/4602726&quot;&gt;answer&lt;/a&gt; and that &lt;a href=&quot;https://stackoverflow.com/a/63818399/4602726&quot;&gt;answer&lt;/a&gt; from my follow up question, here&apos;s a more complete answer. Note that this will only work with C++11 and higher.&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;EmptyClass&lt;/span&gt;{};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;has_begin&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;:\n    &lt;span class=&quot;hljs-built_in&quot;&gt;has_begin&lt;/span&gt;() = &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt;;\n    \n    &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;one&lt;/span&gt; { &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; x[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]; };\n    &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;two&lt;/span&gt; { &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; x[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]; };\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; C&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; one &lt;span class=&quot;hljs-title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;( &lt;span class=&quot;hljs-keyword&quot;&gt;decltype&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;(std::declval&amp;lt;C &amp;amp;&amp;gt;().begin())) * )&lt;/span&gt; &lt;/span&gt;;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; C&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; two &lt;span class=&quot;hljs-title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(...)&lt;/span&gt;&lt;/span&gt;;    \n\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n    &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; value = &lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;&amp;lt;T&amp;gt;(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)) == &lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;(one);\n};\n    \n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;\n&lt;/span&gt;{\n    std::cout &amp;lt;&amp;lt; std::boolalpha;\n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;vector&amp;lt;int&amp;gt;::begin() exists: &quot;&lt;/span&gt; &amp;lt;&amp;lt; has_begin&amp;lt;std::vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;gt;::value &amp;lt;&amp;lt; std::endl;\n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;EmptyClass::begin() exists: &quot;&lt;/span&gt; &amp;lt;&amp;lt; has_begin&amp;lt;EmptyClass&amp;gt;::value &amp;lt;&amp;lt; std::endl;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Or the shorter version:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;EmptyClass&lt;/span&gt;{};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T, &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; = &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; has_begin : std::false_type {};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;has_begin&lt;/span&gt;&amp;lt;T, &lt;span class=&quot;hljs-keyword&quot;&gt;decltype&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;void&lt;/span&gt;(std::&lt;span class=&quot;hljs-built_in&quot;&gt;declval&lt;/span&gt;&amp;lt;T &amp;amp;&amp;gt;().&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;()))&amp;gt; : std::true_type {};\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;\n&lt;/span&gt;{\n    std::cout &amp;lt;&amp;lt; std::boolalpha;\n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;vector&amp;lt;int&amp;gt;::begin() exists: &quot;&lt;/span&gt; &amp;lt;&amp;lt; has_begin&amp;lt;std::vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;gt;::value &amp;lt;&amp;lt; std::endl;\n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;EmptyClass exists: &quot;&lt;/span&gt; &amp;lt;&amp;lt; has_begin&amp;lt;EmptyClass&amp;gt;::value &amp;lt;&amp;lt; std::endl;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Note that here a complete sample call must be provided. This means that if we tested for the &lt;code&gt;resize&lt;/code&gt; method&apos;s existence then we would have put &lt;code&gt;resize(0)&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Deep magic explanation&lt;/strong&gt;:&lt;/p&gt;\n&lt;p&gt;The first answer posted of this question used &lt;code&gt;test( decltype(&amp;amp;C::helloworld) )&lt;/code&gt;; however this is problematic when the method it is testing is ambiguous due const overloading, thus making the substitution attempt fail.&lt;/p&gt;\n&lt;p&gt;To solve this ambiguity we use a void statement which can take any parameters because it is always translated into a &lt;code&gt;noop&lt;/code&gt; and thus the ambiguity is nullified and the call is valid as long as the method exists:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;has_begin&amp;lt;T, &lt;span class=&quot;hljs-keyword&quot;&gt;decltype&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;void&lt;/span&gt;(std::&lt;span class=&quot;hljs-built_in&quot;&gt;declval&lt;/span&gt;&amp;lt;T &amp;amp;&amp;gt;().&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;()))&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Here&apos;s what&apos;s happening in order:\nWe use &lt;code&gt;std::declval&amp;lt;T &amp;amp;&amp;gt;()&lt;/code&gt; to create a callable value for which &lt;code&gt;begin&lt;/code&gt; can then be called. After that the value of &lt;code&gt;begin&lt;/code&gt; is passed as a parameter to a void statement. We then retrieve the type of that void expression using the builtin &lt;code&gt;decltype&lt;/code&gt; so that it can be used as a template type argument. If &lt;code&gt;begin&lt;/code&gt; doesn&apos;t exist then the substitution is invalid and as per SFINAE the other declaration is used instead.&lt;/p&gt;\n    ","\n&lt;p&gt;How about this solution?&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;type_traits&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; U, &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; = &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; hasToString : std::false_type { };\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; U&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;hasToString&lt;/span&gt;&amp;lt;U,\n  &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; std::enable_if&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;bool&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;(&amp;amp;U::toString))&amp;gt;::type\n&amp;gt; : std::true_type { };\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;There are a lot of answers here, but I failed, to find a version, that performs &lt;em&gt;real&lt;/em&gt; method resolution ordering, while not using any of the newer c++ features (only using c++98 features).&lt;br&gt;\nNote: This version is tested and working with vc++2013, g++ 5.2.0 and the onlline compiler.&lt;br&gt;&lt;/p&gt;\n\n&lt;p&gt;So I came up with a version, that only uses sizeof():&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt; T &lt;span class=&quot;hljs-title&quot;&gt;declval&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;fake_void&lt;/span&gt; { };\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt; T &amp;amp;&lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;,(T &amp;amp;,fake_void);\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt; T &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &amp;amp;&lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;,(T &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &amp;amp;,fake_void);\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt; T &lt;span class=&quot;hljs-keyword&quot;&gt;volatile&lt;/span&gt; &amp;amp;&lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;,(T &lt;span class=&quot;hljs-keyword&quot;&gt;volatile&lt;/span&gt; &amp;amp;,fake_void);\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt; T &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;volatile&lt;/span&gt; &amp;amp;&lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;,(T &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;volatile&lt;/span&gt; &amp;amp;,fake_void);\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;yes&lt;/span&gt; { &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; v[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]; };\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;no&lt;/span&gt;  { &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; v[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]; };\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;yes_no&lt;/span&gt;:yes{};\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;yes_no&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;&amp;gt;:no{};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;has_awesome_member&lt;/span&gt; {\n &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; U&amp;gt; &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; yes_no&amp;lt;(&lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;((\n   &lt;span class=&quot;hljs-built_in&quot;&gt;declval&lt;/span&gt;&amp;lt;U&amp;gt;().&lt;span class=&quot;hljs-built_in&quot;&gt;awesome_member&lt;/span&gt;(),&lt;span class=&quot;hljs-built_in&quot;&gt;fake_void&lt;/span&gt;()\n  ))!=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)&amp;gt; &lt;span class=&quot;hljs-built_in&quot;&gt;check&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;);\n &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; no &lt;span class=&quot;hljs-title&quot;&gt;check&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(...)&lt;/span&gt;&lt;/span&gt;;\n &lt;span class=&quot;hljs-keyword&quot;&gt;enum&lt;/span&gt;{value=&lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;check&lt;/span&gt;&amp;lt;T&amp;gt;(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)) == &lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;(yes)};\n};\n\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;foo&lt;/span&gt; { &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;awesome_member&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;; };\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;bar&lt;/span&gt; { };\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;foo_void&lt;/span&gt; { &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;awesome_member&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;; };\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;wrong_params&lt;/span&gt; { &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;awesome_member&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;; };\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;(has_awesome_member&amp;lt;foo&amp;gt;::value,&lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;);\n&lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;(!has_awesome_member&amp;lt;bar&amp;gt;::value,&lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;);\n&lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;(has_awesome_member&amp;lt;foo_void&amp;gt;::value,&lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;);\n&lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;(!has_awesome_member&amp;lt;wrong_params&amp;gt;::value,&lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Live demo (with extended return type checking and vc++2010 workaround): &lt;a href=&quot;http://cpp.sh/5b2vs&quot; rel=&quot;nofollow noreferrer&quot;&gt;http://cpp.sh/5b2vs&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;No source, as I came up with it myself.&lt;/p&gt;\n\n&lt;p&gt;When running the Live demo on the g++ compiler, please note that array sizes of 0 are allowed, meaning that the static_assert used will not trigger a compiler error, even when it fails.&lt;br&gt;\nA commonly used work-around is to replace the &apos;typedef&apos; in the macro with &apos;extern&apos;.&lt;/p&gt;\n    ","\n&lt;p&gt;My take: to universally determine if something is callable without making verbose type traits for each and every one, or using experimental features, or long code:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; Callable, &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt;... Args, &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; = &lt;span class=&quot;hljs-keyword&quot;&gt;decltype&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;declval&lt;/span&gt;&amp;lt;Callable&amp;gt;()(&lt;span class=&quot;hljs-built_in&quot;&gt;declval&lt;/span&gt;&amp;lt;Args&amp;gt;()...))&amp;gt;\nstd::true_type &lt;span class=&quot;hljs-built_in&quot;&gt;isCallableImpl&lt;/span&gt;(Callable, Args...) { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; {}; }\n\n&lt;span class=&quot;hljs-function&quot;&gt;std::false_type &lt;span class=&quot;hljs-title&quot;&gt;isCallableImpl&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(...)&lt;/span&gt; &lt;/span&gt;{ &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; {}; }\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt;... Args, &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; Callable&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;isCallable&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Callable callable)&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;decltype&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;isCallableImpl&lt;/span&gt;(callable, &lt;span class=&quot;hljs-built_in&quot;&gt;declval&lt;/span&gt;&amp;lt;Args&amp;gt;()...)){};\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Usage:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; TO_STRING_TEST = [](&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; in) -&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;decltype&lt;/span&gt;(in.&lt;span class=&quot;hljs-built_in&quot;&gt;toString&lt;/span&gt;()) { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; {}; };\n&lt;span class=&quot;hljs-keyword&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; TO_STRING_WORKS = &lt;span class=&quot;hljs-built_in&quot;&gt;isCallable&lt;/span&gt;&amp;lt;T&amp;gt;(TO_STRING_TEST);\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Here is my version that handles all possible member function overloads with arbitrary arity, including template member functions, possibly with default arguments. It distinguishes 3 mutually exclusive scenarios when making a member function call to some class type, with given arg types: (1) valid, or (2) ambiguous, or (3) non-viable. Example usage:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;HAS_MEM&lt;/span&gt;(bar)\n&lt;span class=&quot;hljs-built_in&quot;&gt;HAS_MEM_FUN_CALL&lt;/span&gt;(bar)\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;test&lt;/span&gt;\n{\n   &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n   &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n   &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;,&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n\n   &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt; &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T &amp;gt;\n   &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; std::enable_if&amp;lt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; std::is_integral&amp;lt;T&amp;gt;::value &amp;gt;::&lt;span class=&quot;hljs-function&quot;&gt;type\n   &lt;span class=&quot;hljs-title&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; T&amp;amp;, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;{}\n\n   &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt; &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T &amp;gt;\n   &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; std::enable_if&amp;lt; std::is_integral&amp;lt;T&amp;gt;::value &amp;gt;::&lt;span class=&quot;hljs-function&quot;&gt;type\n   &lt;span class=&quot;hljs-title&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; std::vector&amp;lt;T&amp;gt;&amp;amp;, T*)&lt;/span&gt;&lt;/span&gt;{}\n\n   &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt; &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T &amp;gt;\n   &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; std::string&amp;amp;, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;{}\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Now you can use it like this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; * argv[])&lt;/span&gt;\n&lt;/span&gt;{\n   &lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;( has_mem_bar&amp;lt;test&amp;gt;::value , &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;);\n\n   &lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;( has_valid_mem_fun_call_bar&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;*,&lt;span class=&quot;hljs-type&quot;&gt;long&lt;/span&gt;)&amp;gt;::value , &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;);\n   &lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;( has_valid_mem_fun_call_bar&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;(std::string&amp;amp;,&lt;span class=&quot;hljs-type&quot;&gt;long&lt;/span&gt;)&amp;gt;::value , &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;);\n\n   &lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;( has_valid_mem_fun_call_bar&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;(std::vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*)&amp;gt;::value , &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;);\n   &lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;( has_no_viable_mem_fun_call_bar&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;(std::vector&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt;&amp;gt;, &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt;*)&amp;gt;::value , &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;);\n\n   &lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;( has_valid_mem_fun_call_bar&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;)&amp;gt;::value , &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;);\n   &lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;( std::is_same&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;,result_of_mem_fun_call_bar&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;)&amp;gt;::type&amp;gt;::value , &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;);\n\n   &lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;( has_valid_mem_fun_call_bar&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;,&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt;)&amp;gt;::value , &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;);\n   &lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;( &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; has_valid_mem_fun_call_bar&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;,&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt;,&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;)&amp;gt;::value , &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;);\n\n   &lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;( &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; has_ambiguous_mem_fun_call_bar&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt;)&amp;gt;::value , &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;);\n   &lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;( has_ambiguous_mem_fun_call_bar&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt;)&amp;gt;::value , &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;);\n\n   &lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;( has_viable_mem_fun_call_bar&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt;)&amp;gt;::value , &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;);\n   &lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;( has_viable_mem_fun_call_bar&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;)&amp;gt;::value , &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;);\n\n   &lt;span class=&quot;hljs-built_in&quot;&gt;static_assert&lt;/span&gt;( has_no_viable_mem_fun_call_bar&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)&amp;gt;::value , &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;);\n\n   &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here is the code, written in c++11, however, you can easily port it (with minor tweaks) to non-c++11 that has typeof extensions (e.g. gcc). You can replace the HAS_MEM macro with your own.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;pragma&lt;/span&gt; once&lt;/span&gt;\n\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; __cplusplus &amp;gt;= 201103&lt;/span&gt;\n\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;utility&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;type_traits&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; HAS_MEM(mem)                                                                                     \\\n                                                                                                     \\\ntemplate &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt; typename T &amp;gt;&lt;/span&gt;                                                                               \\\nstruct has_mem_##mem                                                                                  \\\n{                                                                                                     \\\n  struct yes {};                                                                                     \\\n  struct no  {};                                                                                     \\\n                                                                                                     \\\n  struct ambiguate_seed { char mem; };                                                               \\\n  template &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt; typename U &amp;gt;&lt;/span&gt; struct ambiguate : U, ambiguate_seed {};                                   \\\n                                                                                                     \\\n  template &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt; typename U, typename = decltype(&amp;amp;U::mem) &amp;gt;&lt;/span&gt; static constexpr no  test(int);              \\\n  template &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt; typename                                 &amp;gt;&lt;/span&gt; static constexpr yes test(...);              \\\n                                                                                                     \\\n  static bool constexpr value = std::is_same&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;decltype(test&amp;lt; ambiguate&amp;lt;T&amp;gt;&lt;/span&gt; &amp;gt;(0)),yes&amp;gt;::value ;         \\\n  typedef std::integral_constant&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;bool,value&amp;gt;&lt;/span&gt;    type;                                                \\\n};&lt;/span&gt;\n\n\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; HAS_MEM_FUN_CALL(memfun)                                                                         \\\n                                                                                                     \\\ntemplate &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt; typename Signature &amp;gt;&lt;/span&gt;                                                                       \\\nstruct has_valid_mem_fun_call_##memfun;                                                               \\\n                                                                                                     \\\ntemplate &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt; typename T, typename... Args &amp;gt;&lt;/span&gt;                                                             \\\nstruct has_valid_mem_fun_call_##memfun&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt; T(Args...) &amp;gt;&lt;/span&gt;                                                  \\\n{                                                                                                     \\\n  struct yes {};                                                                                     \\\n  struct no  {};                                                                                     \\\n                                                                                                     \\\n  template &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt; typename U, bool = has_mem_##memfun&amp;lt;U&amp;gt;&lt;/span&gt;::value &amp;gt;                                         \\\n  struct impl                                                                                        \\\n  {                                                                                                  \\\n     template &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt; typename V, typename = decltype(std::declval&amp;lt;V&amp;gt;&lt;/span&gt;().memfun(std::declval&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;Args&amp;gt;&lt;/span&gt;()...)) &amp;gt; \\\n     struct test_result { using type = yes; };                                                       \\\n                                                                                                     \\\n     template &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt; typename V &amp;gt;&lt;/span&gt; static constexpr typename test_result&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;V&amp;gt;&lt;/span&gt;::type test(int);               \\\n     template &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt; typename   &amp;gt;&lt;/span&gt; static constexpr                            no test(...);               \\\n                                                                                                     \\\n     static constexpr bool value = std::is_same&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;decltype(test&amp;lt;U&amp;gt;&lt;/span&gt;(0)),yes&amp;gt;::value;                    \\\n     using type = std::integral_constant&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;bool, value&amp;gt;&lt;/span&gt;;                                               \\\n  };                                                                                                 \\\n                                                                                                     \\\n  template &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt; typename U &amp;gt;&lt;/span&gt;                                                                            \\\n  struct impl&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;U,false&amp;gt;&lt;/span&gt; : std::false_type {};                                                         \\\n                                                                                                     \\\n  static constexpr bool value = impl&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;T&amp;gt;&lt;/span&gt;::value;                                                      \\\n  using type = std::integral_constant&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;bool, value&amp;gt;&lt;/span&gt;;                                                  \\\n};                                                                                                    \\\n                                                                                                     \\\ntemplate &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt; typename Signature &amp;gt;&lt;/span&gt;                                                                       \\\nstruct has_ambiguous_mem_fun_call_##memfun;                                                           \\\n                                                                                                     \\\ntemplate &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt; typename T, typename... Args &amp;gt;&lt;/span&gt;                                                             \\\nstruct has_ambiguous_mem_fun_call_##memfun&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt; T(Args...) &amp;gt;&lt;/span&gt;                                              \\\n{                                                                                                     \\\n  struct ambiguate_seed { void memfun(...); };                                                       \\\n                                                                                                     \\\n  template &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt; class U, bool = has_mem_##memfun&amp;lt;U&amp;gt;&lt;/span&gt;::value &amp;gt;                                            \\\n  struct ambiguate : U, ambiguate_seed                                                               \\\n  {                                                                                                  \\\n    using ambiguate_seed::memfun;                                                                    \\\n    using U::memfun;                                                                                 \\\n  };                                                                                                 \\\n                                                                                                     \\\n  template &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt; class U &amp;gt;&lt;/span&gt;                                                                               \\\n  struct ambiguate&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;U,false&amp;gt;&lt;/span&gt; : ambiguate_seed {};                                                     \\\n                                                                                                     \\\n  static constexpr bool value = not has_valid_mem_fun_call_##memfun&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt; ambiguate&amp;lt;T&amp;gt;&lt;/span&gt;(Args...) &amp;gt;::value; \\\n  using type = std::integral_constant&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;bool, value&amp;gt;&lt;/span&gt;;                                                  \\\n};                                                                                                    \\\n                                                                                                     \\\ntemplate &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt; typename Signature &amp;gt;&lt;/span&gt;                                                                       \\\nstruct has_viable_mem_fun_call_##memfun;                                                              \\\n                                                                                                     \\\ntemplate &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt; typename T, typename... Args &amp;gt;&lt;/span&gt;                                                             \\\nstruct has_viable_mem_fun_call_##memfun&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt; T(Args...) &amp;gt;&lt;/span&gt;                                                 \\\n{                                                                                                     \\\n  static constexpr bool value = has_valid_mem_fun_call_##memfun&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;T(Args...)&amp;gt;&lt;/span&gt;::value                   \\\n                             or has_ambiguous_mem_fun_call_##memfun&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;T(Args...)&amp;gt;&lt;/span&gt;::value;              \\\n  using type = std::integral_constant&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;bool, value&amp;gt;&lt;/span&gt;;                                                  \\\n};                                                                                                    \\\n                                                                                                     \\\ntemplate &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt; typename Signature &amp;gt;&lt;/span&gt;                                                                       \\\nstruct has_no_viable_mem_fun_call_##memfun;                                                           \\\n                                                                                                     \\\ntemplate &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt; typename T, typename... Args &amp;gt;&lt;/span&gt;                                                             \\\nstruct has_no_viable_mem_fun_call_##memfun &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt; T(Args...) &amp;gt;&lt;/span&gt;                                             \\\n{                                                                                                     \\\n  static constexpr bool value = not has_viable_mem_fun_call_##memfun&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;T(Args...)&amp;gt;&lt;/span&gt;::value;             \\\n  using type = std::integral_constant&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;bool, value&amp;gt;&lt;/span&gt;;                                                  \\\n};                                                                                                    \\\n                                                                                                     \\\ntemplate &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt; typename Signature &amp;gt;&lt;/span&gt;                                                                       \\\nstruct result_of_mem_fun_call_##memfun;                                                               \\\n                                                                                                     \\\ntemplate &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt; typename T, typename... Args &amp;gt;&lt;/span&gt;                                                             \\\nstruct result_of_mem_fun_call_##memfun&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt; T(Args...) &amp;gt;&lt;/span&gt;                                                  \\\n{                                                                                                     \\\n  using type = decltype(std::declval&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;T&amp;gt;&lt;/span&gt;().memfun(std::declval&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;Args&amp;gt;&lt;/span&gt;()...));                          \\\n};&lt;/span&gt;\n\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;hr&gt;\n    ","\n&lt;p&gt;You can skip all the metaprogramming in C++14, and just write this using &lt;a href=&quot;http://fit.readthedocs.io/en/latest/include/fit/conditional.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;fit::conditional&lt;/code&gt;&lt;/a&gt; from the &lt;a href=&quot;https://github.com/pfultz2/Fit&quot; rel=&quot;nofollow noreferrer&quot;&gt;Fit&lt;/a&gt; library:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; T&amp;gt;\nstd::string &lt;span class=&quot;hljs-title&quot;&gt;optionalToString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T* x)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; fit::&lt;span class=&quot;hljs-built_in&quot;&gt;conditional&lt;/span&gt;(\n        [](&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt;* obj) -&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;decltype&lt;/span&gt;(obj-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;toString&lt;/span&gt;()) { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; obj-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;toString&lt;/span&gt;(); },\n        [](&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt;*) { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;toString not defined&quot;&lt;/span&gt;; }\n    )(x);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You can also create the function directly from the lambdas as well:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;FIT_STATIC_LAMBDA_FUNCTION&lt;/span&gt;(optionalToString) = fit::&lt;span class=&quot;hljs-built_in&quot;&gt;conditional&lt;/span&gt;(\n    [](&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt;* obj) -&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;decltype&lt;/span&gt;(obj-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;toString&lt;/span&gt;(), std::&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;()) { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; obj-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;toString&lt;/span&gt;(); },\n    [](&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt;*) -&amp;gt; std::string { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;toString not defined&quot;&lt;/span&gt;; }\n);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;However, if you are using a compiler that doesn&apos;t support generic lambdas, you will have to write separate function objects:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;withToString&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; T&amp;gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T* obj)&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; -&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;decltype&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(obj-&amp;gt;toString(), std::string())&lt;/span&gt;\n    &lt;/span&gt;{\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; obj-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;toString&lt;/span&gt;();\n    }\n};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;withoutToString&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; T&amp;gt;\n    std::string &lt;span class=&quot;hljs-title&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T*)&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;\n    &lt;/span&gt;{\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;toString not defined&quot;&lt;/span&gt;;\n    }\n};\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;FIT_STATIC_FUNCTION&lt;/span&gt;(optionalToString) = fit::&lt;span class=&quot;hljs-built_in&quot;&gt;conditional&lt;/span&gt;(\n    &lt;span class=&quot;hljs-built_in&quot;&gt;withToString&lt;/span&gt;(),\n    &lt;span class=&quot;hljs-built_in&quot;&gt;withoutToString&lt;/span&gt;()\n);\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Probably not as good as other examples, but this is what I came up with for C++11. This works for picking overloaded methods.&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt;... Args&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Pack&lt;/span&gt; {};\n\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; Proxy(T) ((T &amp;amp;)(*(int *)(nullptr)))&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; Class, &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; ArgPack, &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; = &lt;span class=&quot;hljs-type&quot;&gt;nullptr_t&lt;/span&gt;&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; HasFoo\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;enum&lt;/span&gt; { value = &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt; };\n};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; Class, &lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt;... Args&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;HasFoo&lt;/span&gt;&amp;lt;\n    Class,\n    Pack&amp;lt;Args...&amp;gt;,\n    &lt;span class=&quot;hljs-keyword&quot;&gt;decltype&lt;/span&gt;((&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)(&lt;span class=&quot;hljs-built_in&quot;&gt;Proxy&lt;/span&gt;(Class).&lt;span class=&quot;hljs-built_in&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;Proxy&lt;/span&gt;(Args)...)), &lt;span class=&quot;hljs-literal&quot;&gt;nullptr&lt;/span&gt;)&amp;gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;enum&lt;/span&gt; { value = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt; };\n};\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Example usage&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Object&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt;         &lt;/span&gt;{ &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; n; }\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; SOME_CONDITION&lt;/span&gt;\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; n, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; c)&lt;/span&gt; &lt;/span&gt;{ &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; n + c; }\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;\n};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; has_foo_int_char&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Dispatcher&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Dispatcher&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;&amp;gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; Object&amp;gt;\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Object &amp;amp;object, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; n, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; c)&lt;/span&gt;\n    &lt;/span&gt;{\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; object.&lt;span class=&quot;hljs-built_in&quot;&gt;foo&lt;/span&gt;(n) + c;\n    }\n};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Dispatcher&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;&amp;gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; Object&amp;gt;\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Object &amp;amp;object, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; n, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; c)&lt;/span&gt;\n    &lt;/span&gt;{\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; object.&lt;span class=&quot;hljs-built_in&quot;&gt;foo&lt;/span&gt;(n, c);\n    }\n};\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;runExample&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; Args = Pack&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;&amp;gt;;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;enum&lt;/span&gt; { has_overload = HasFoo&amp;lt;Object, Args&amp;gt;::value };\n    Object object;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Dispatcher&amp;lt;has_overload&amp;gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;exec&lt;/span&gt;(object, &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Here is an example of the working code.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; toStringFn = &lt;span class=&quot;hljs-keyword&quot;&gt;decltype&lt;/span&gt;(std::&lt;span class=&quot;hljs-built_in&quot;&gt;declval&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; T&amp;gt;().&lt;span class=&quot;hljs-built_in&quot;&gt;toString&lt;/span&gt;());\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;T&lt;/span&gt;, toStringFn&amp;lt;T&amp;gt;* = &lt;span class=&quot;hljs-literal&quot;&gt;nullptr&lt;/span&gt;&amp;gt;\nstd::string &lt;span class=&quot;hljs-built_in&quot;&gt;optionalToString&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; T* obj, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;)\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; obj-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;toString&lt;/span&gt;();\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;T&lt;/span&gt;&amp;gt;\n&lt;span class=&quot;hljs-function&quot;&gt;std::string &lt;span class=&quot;hljs-title&quot;&gt;optionalToString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; T* obj, &lt;span class=&quot;hljs-type&quot;&gt;long&lt;/span&gt;)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;toString not defined&quot;&lt;/span&gt;;\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    A* a;\n    B* b;\n\n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;optionalToString&lt;/span&gt;(a, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) &amp;lt;&amp;lt; std::endl; &lt;span class=&quot;hljs-comment&quot;&gt;// This is A&lt;/span&gt;\n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;optionalToString&lt;/span&gt;(b, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) &amp;lt;&amp;lt; std::endl; &lt;span class=&quot;hljs-comment&quot;&gt;// toString not defined&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;toStringFn&amp;lt;T&amp;gt;* = nullptr&lt;/code&gt; will enable the function which takes extra &lt;code&gt;int&lt;/code&gt; argument which has a priority over function which takes &lt;code&gt;long&lt;/code&gt; when called with &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;You can use the same principle for the functions which returns &lt;code&gt;true&lt;/code&gt; if function is implemented.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;toStringExists&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;long&lt;/span&gt;)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;;\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T, toStringFn&amp;lt;T&amp;gt;* = &lt;span class=&quot;hljs-literal&quot;&gt;nullptr&lt;/span&gt;&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;toStringExists&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;)\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;\n}\n\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    A* a;\n    B* b;\n\n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;toStringExists&lt;/span&gt;&amp;lt;A&amp;gt;(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) &amp;lt;&amp;lt; std::endl; &lt;span class=&quot;hljs-comment&quot;&gt;// true&lt;/span&gt;\n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;toStringExists&lt;/span&gt;&amp;lt;B&amp;gt;(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) &amp;lt;&amp;lt; std::endl; &lt;span class=&quot;hljs-comment&quot;&gt;// false&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I had a similar problem:&lt;/p&gt;\n\n&lt;p&gt;A template class that may be derived from few base classes, some that have a certain member and others that do not.&lt;/p&gt;\n\n&lt;p&gt;I solved it similarly to the &quot;typeof&quot; (Nicola Bonelli&apos;s) answer, but with decltype so it compiles and runs correctly on MSVS:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Generic&lt;/span&gt; {};    \n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;HasMember&lt;/span&gt; \n{\n  &lt;span class=&quot;hljs-built_in&quot;&gt;HasMember&lt;/span&gt;() : _a(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) {};\n  &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; _a;\n};    \n\n&lt;span class=&quot;hljs-comment&quot;&gt;// SFINAE test&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;S&lt;/span&gt; : &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; T\n{\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n  &lt;span class=&quot;hljs-function&quot;&gt;std::string &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(std::string b)&lt;/span&gt;\n  &lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;foo2&lt;/span&gt;&amp;lt;T&amp;gt;(b,&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);\n  }\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt;:\n  &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;std::string &lt;span class=&quot;hljs-title&quot;&gt;foo2&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(std::string b, &lt;span class=&quot;hljs-keyword&quot;&gt;decltype&lt;/span&gt; (T::_a))&lt;/span&gt;\n  &lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; b + std::&lt;span class=&quot;hljs-built_in&quot;&gt;to_string&lt;/span&gt;(T::_a);\n  }\n  &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;std::string &lt;span class=&quot;hljs-title&quot;&gt;foo2&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(std::string b, ...)&lt;/span&gt;\n  &lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; b + &lt;span class=&quot;hljs-string&quot;&gt;&quot;No&quot;&lt;/span&gt;;\n  }\n};\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;\n&lt;/span&gt;{\n  S&amp;lt;HasMember&amp;gt; d1;\n  S&amp;lt;Generic&amp;gt; d2;\n\n  std::cout &amp;lt;&amp;lt; d1.&lt;span class=&quot;hljs-built_in&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;HasMember: &quot;&lt;/span&gt;) &amp;lt;&amp;lt; std::endl;\n  std::cout &amp;lt;&amp;lt; d2.&lt;span class=&quot;hljs-built_in&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Generic: &quot;&lt;/span&gt;) &amp;lt;&amp;lt; std::endl;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    "]},"randomTags":[{"name":"chunks","slug":"chunks"},{"name":"event-loop","slug":"event-loop"},{"name":"selenium","slug":"selenium"},{"name":"c++","slug":"c++"},{"name":"password-protection","slug":"password-protection"},{"name":"hashcode","slug":"hashcode"},{"name":"concatenation","slug":"concatenation"},{"name":"chained-assignment","slug":"chained-assignment"},{"name":"multiline","slug":"multiline"},{"name":"awk","slug":"awk"},{"name":"dynamic-languages","slug":"dynamic-languages"},{"name":"language-features","slug":"language-features"},{"name":"mongodb-query","slug":"mongodb-query"},{"name":"join","slug":"join"},{"name":"sql-server-2005","slug":"sql-server-2005"},{"name":"strcmp","slug":"strcmp"},{"name":"sharedpreferences","slug":"sharedpreferences"},{"name":"pivot","slug":"pivot"},{"name":"std","slug":"std"},{"name":"parameters","slug":"parameters"}]},"__N_SSG":true}