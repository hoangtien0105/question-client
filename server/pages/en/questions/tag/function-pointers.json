{"pageProps":{"data":{"count":1,"rows":[{"id":532,"title":"How do function pointers in C work?","slug":"how-do-function-pointers-in-c-work-1657388332074","postType":"QUESTION","createdAt":"2022-07-09T17:38:52.000Z","updatedAt":"2022-07-09T17:38:52.000Z","tags":[{"id":2614,"name":"function-pointers","slug":"function-pointers","createdAt":"2022-07-09T17:38:52.000Z","updatedAt":"2022-07-09T17:38:52.000Z","Questions_Tags":{"questionId":532,"tagId":2614}}]}]},"slug":"function-pointers","page":1,"answers":{"532":["\n&lt;h1&gt;Function pointers in C&lt;/h1&gt;\n\n&lt;p&gt;Let&apos;s start with a basic function which we will be &lt;em&gt;pointing to&lt;/em&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;addInt&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; n, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; m)&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; n+m;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;First thing, let&apos;s define a pointer to a function which receives 2 &lt;code&gt;int&lt;/code&gt;s and returns an &lt;code&gt;int&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*functionPtr)(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;,&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Now we can safely point to our function:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;functionPtr = &amp;amp;addInt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Now that we have a pointer to the function, let&apos;s use it:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; sum = (*functionPtr)(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;// sum == 5&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Passing the pointer to another function is basically the same:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;add2to3&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*functionPtr)(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;))&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (*functionPtr)(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;We can use function pointers in return values as well (try to keep up, it gets messy):&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// this is a function called functionFactory which receives parameter n&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// and returns a pointer to another function which receives two ints&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// and it returns another int&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*functionFactory(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; n))(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Got parameter %d&quot;&lt;/span&gt;, n);\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*functionPtr)(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;,&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;) = &amp;amp;addInt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; functionPtr;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;But it&apos;s much nicer to use a &lt;code&gt;typedef&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(*myFuncDef)&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;;\n&lt;span class=&quot;hljs-comment&quot;&gt;// note that the typedef name is indeed myFuncDef&lt;/span&gt;\n\nmyFuncDef &lt;span class=&quot;hljs-title function_&quot;&gt;functionFactory&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt; {\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Got parameter %d&quot;&lt;/span&gt;, n);\n    myFuncDef functionPtr = &amp;amp;addInt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; functionPtr;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Function pointers in C can be used to perform object-oriented programming in C.&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;For example, the following lines is written in C:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;String s1 = newString();\ns1-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;set&lt;/span&gt;(s1, &lt;span class=&quot;hljs-string&quot;&gt;&quot;hello&quot;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Yes, the &lt;code&gt;-&amp;gt;&lt;/code&gt; and the lack of a &lt;code&gt;new&lt;/code&gt; operator is a dead give away, but it sure seems to imply that we&apos;re setting the text of some &lt;code&gt;String&lt;/code&gt; class to be &lt;code&gt;&quot;hello&quot;&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;By using function pointers, &lt;strong&gt;it is possible to emulate methods in C&lt;/strong&gt;.&lt;/p&gt;\n\n&lt;p&gt;How is this accomplished?&lt;/p&gt;\n\n&lt;p&gt;The &lt;code&gt;String&lt;/code&gt; class is actually a &lt;code&gt;struct&lt;/code&gt; with a bunch of function pointers which act as a way to simulate methods. The following is a partial declaration of the &lt;code&gt;String&lt;/code&gt; class:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;String_Struct&lt;/span&gt;* &lt;span class=&quot;hljs-title&quot;&gt;String&lt;/span&gt;;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;String_Struct&lt;/span&gt;\n{&lt;/span&gt;\n    &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;* (*get)(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;* self);\n    &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; (*&lt;span class=&quot;hljs-built_in&quot;&gt;set&lt;/span&gt;)(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;* self, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;* value);\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*length)(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;* self);\n};\n\n&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;* &lt;span class=&quot;hljs-title function_&quot;&gt;getString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;* self)&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;setString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;* self, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;* value)&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;lengthString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;* self)&lt;/span&gt;;\n\nString &lt;span class=&quot;hljs-title function_&quot;&gt;newString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;As can be seen, the methods of the &lt;code&gt;String&lt;/code&gt; class are actually function pointers to the declared function. In preparing the instance of the &lt;code&gt;String&lt;/code&gt;, the &lt;code&gt;newString&lt;/code&gt; function is called in order to set up the function pointers to their respective functions:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;String &lt;span class=&quot;hljs-title function_&quot;&gt;newString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n{\n    String self = (String)&lt;span class=&quot;hljs-built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; String_Struct));\n\n    self-&amp;gt;get = &amp;amp;getString;\n    self-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;set&lt;/span&gt; = &amp;amp;setString;\n    self-&amp;gt;length = &amp;amp;lengthString;\n\n    self-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;set&lt;/span&gt;(self, &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;);\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;For example, the &lt;code&gt;getString&lt;/code&gt; function that is called by invoking the &lt;code&gt;get&lt;/code&gt; method is defined as the following:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;* &lt;span class=&quot;hljs-title function_&quot;&gt;getString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;* self_obj)&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ((String)self_obj)-&amp;gt;internal-&amp;gt;value;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;One thing that can be noticed is that there is no concept of an instance of an object and having methods that are actually a part of an object, so a &quot;self object&quot; must be passed in on each invocation. (And the &lt;code&gt;internal&lt;/code&gt; is just a hidden &lt;code&gt;struct&lt;/code&gt; which was omitted from the code listing earlier -- it is a way of performing information hiding, but that is not relevant to function pointers.)&lt;/p&gt;\n\n&lt;p&gt;So, rather than being able to do &lt;code&gt;s1-&amp;gt;set(&quot;hello&quot;);&lt;/code&gt;, one must pass in the object to perform the action on &lt;code&gt;s1-&amp;gt;set(s1, &quot;hello&quot;)&lt;/code&gt;. &lt;/p&gt;\n\n&lt;p&gt;With that minor explanation having to pass in a reference to yourself out of the way, we&apos;ll move to the next part, which is &lt;strong&gt;inheritance in C&lt;/strong&gt;.&lt;/p&gt;\n\n&lt;p&gt;Let&apos;s say we want to make a subclass of &lt;code&gt;String&lt;/code&gt;, say an &lt;code&gt;ImmutableString&lt;/code&gt;. In order to make the string immutable, the &lt;code&gt;set&lt;/code&gt; method will not be accessible, while maintaining access to &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;length&lt;/code&gt;, and force the &quot;constructor&quot; to accept a &lt;code&gt;char*&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ImmutableString_Struct&lt;/span&gt;* &lt;span class=&quot;hljs-title&quot;&gt;ImmutableString&lt;/span&gt;;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ImmutableString_Struct&lt;/span&gt;\n{&lt;/span&gt;\n    String base;\n\n    &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;* (*get)(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;* self);\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*length)(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;* self);\n};\n\nImmutableString &lt;span class=&quot;hljs-title function_&quot;&gt;newImmutableString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;* value)&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Basically, for all subclasses, the available methods are once again function pointers. This time, the declaration for the &lt;code&gt;set&lt;/code&gt; method is not present, therefore, it cannot be called in a &lt;code&gt;ImmutableString&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;As for the implementation of the &lt;code&gt;ImmutableString&lt;/code&gt;, the only relevant code is the &quot;constructor&quot; function, the &lt;code&gt;newImmutableString&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;ImmutableString &lt;span class=&quot;hljs-title function_&quot;&gt;newImmutableString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;* value)&lt;/span&gt;\n{\n    ImmutableString self = (ImmutableString)&lt;span class=&quot;hljs-built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; ImmutableString_Struct));\n\n    self-&amp;gt;base = newString();\n\n    self-&amp;gt;get = self-&amp;gt;base-&amp;gt;get;\n    self-&amp;gt;length = self-&amp;gt;base-&amp;gt;length;\n\n    self-&amp;gt;base-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;set&lt;/span&gt;(self-&amp;gt;base, (&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;*)value);\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In instantiating the &lt;code&gt;ImmutableString&lt;/code&gt;, the function pointers to the &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;length&lt;/code&gt; methods actually refer to the &lt;code&gt;String.get&lt;/code&gt; and &lt;code&gt;String.length&lt;/code&gt; method, by going through the &lt;code&gt;base&lt;/code&gt; variable which is an internally stored &lt;code&gt;String&lt;/code&gt; object.&lt;/p&gt;\n\n&lt;p&gt;The use of a function pointer can achieve inheritance of a method from a superclass.&lt;/p&gt;\n\n&lt;p&gt;We can further continue to &lt;strong&gt;polymorphism in C&lt;/strong&gt;.&lt;/p&gt;\n\n&lt;p&gt;If for example we wanted to change the behavior of the &lt;code&gt;length&lt;/code&gt; method to return &lt;code&gt;0&lt;/code&gt; all the time in the &lt;code&gt;ImmutableString&lt;/code&gt; class for some reason, all that would have to be done is to:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;Add a function that is going to serve as the overriding &lt;code&gt;length&lt;/code&gt; method.&lt;/li&gt;\n&lt;li&gt;Go to the &quot;constructor&quot; and set the function pointer to the overriding &lt;code&gt;length&lt;/code&gt; method.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;Adding an overriding &lt;code&gt;length&lt;/code&gt; method in &lt;code&gt;ImmutableString&lt;/code&gt; may be performed by adding an &lt;code&gt;lengthOverrideMethod&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;lengthOverrideMethod&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;* self)&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Then, the function pointer for the &lt;code&gt;length&lt;/code&gt; method in the constructor is hooked up to the &lt;code&gt;lengthOverrideMethod&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;ImmutableString &lt;span class=&quot;hljs-title function_&quot;&gt;newImmutableString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;* value)&lt;/span&gt;\n{\n    ImmutableString self = (ImmutableString)&lt;span class=&quot;hljs-built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; ImmutableString_Struct));\n\n    self-&amp;gt;base = newString();\n\n    self-&amp;gt;get = self-&amp;gt;base-&amp;gt;get;\n    self-&amp;gt;length = &amp;amp;lengthOverrideMethod;\n\n    self-&amp;gt;base-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;set&lt;/span&gt;(self-&amp;gt;base, (&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;*)value);\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Now, rather than having an identical behavior for the &lt;code&gt;length&lt;/code&gt; method in &lt;code&gt;ImmutableString&lt;/code&gt; class as the &lt;code&gt;String&lt;/code&gt; class, now the &lt;code&gt;length&lt;/code&gt; method will refer to the behavior defined in the &lt;code&gt;lengthOverrideMethod&lt;/code&gt; function.&lt;/p&gt;\n\n&lt;p&gt;I must add a disclaimer that I am still learning how to write with an object-oriented programming style in C, so there probably are points that I didn&apos;t explain well, or may just be off mark in terms of how best to implement OOP in C. But my purpose was to try to illustrate one of many uses of function pointers.&lt;/p&gt;\n\n&lt;p&gt;For more information on how to perform object-oriented programming in C, please refer to the following questions:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/415452/object-orientation-in-c&quot;&gt;Object-Orientation in C?&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/351733/can-you-write-object-oriented-code-in-c&quot;&gt;Can you write object oriented code in C?&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;The guide to getting fired: How to abuse function pointers in GCC on x86 machines by compiling your code by hand:&lt;/p&gt;\n\n&lt;p&gt;These string literals are bytes of 32-bit x86 machine code.  &lt;code&gt;0xC3&lt;/code&gt; is &lt;a href=&quot;http://felixcloutier.com/x86/RET.html&quot; rel=&quot;noreferrer&quot;&gt;an x86 &lt;code&gt;ret&lt;/code&gt; instruction&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;You wouldn&apos;t normally write these by hand, you&apos;d write in assembly language and then use an assembler like &lt;code&gt;nasm&lt;/code&gt; to assemble it into a flat binary which you hexdump into a C string literal.&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;Returns the current value on the EAX register&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; eax = ((&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;(*)())(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\\xc3 &amp;lt;- This returns the value of the EAX register&quot;&lt;/span&gt;))();\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Write a swap function&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, b = &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;;\n((&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;(*)(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*,&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*))&lt;span class=&quot;hljs-string&quot;&gt;&quot;\\x8b\\x44\\x24\\x04\\x8b\\x5c\\x24\\x08\\x8b\\x00\\x8b\\x1b\\x31\\xc3\\x31\\xd8\\x31\\xc3\\x8b\\x4c\\x24\\x04\\x89\\x01\\x8b\\x4c\\x24\\x08\\x89\\x19\\xc3 &amp;lt;- This swaps the values of a and b&quot;&lt;/span&gt;)(&amp;amp;a,&amp;amp;b);\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Write a for-loop counter to 1000, calling some function each time&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;((&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;(*)())&lt;span class=&quot;hljs-string&quot;&gt;&quot;\\x66\\x31\\xc0\\x8b\\x5c\\x24\\x04\\x66\\x40\\x50\\xff\\xd3\\x58\\x66\\x3d\\xe8\\x03\\x75\\xf4\\xc3&quot;&lt;/span&gt;)(&amp;amp;function); &lt;span class=&quot;hljs-comment&quot;&gt;// calls function with 1-&amp;gt;1000&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;You can even write a recursive function that counts to 100&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;* lol = &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\x8b\\x5c\\x24\\x4\\x3d\\xe8\\x3\\x0\\x0\\x7e\\x2\\x31\\xc0\\x83\\xf8\\x64\\x7d\\x6\\x40\\x53\\xff\\xd3\\x5b\\xc3\\xc3 &amp;lt;- Recursively calls the function at address lol.&quot;&lt;/span&gt;;\ni = ((&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;(*)())(lol))(lol);\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;Note that compilers place string literals in the &lt;code&gt;.rodata&lt;/code&gt; section (or &lt;code&gt;.rdata&lt;/code&gt; on Windows), which is linked as part of the text segment (along with code for functions).&lt;/p&gt;\n\n&lt;p&gt;The text segment has Read+Exec permission, so casting string literals to function pointers works without needing &lt;code&gt;mprotect()&lt;/code&gt; or &lt;code&gt;VirtualProtect()&lt;/code&gt; system calls like you&apos;d need for dynamically allocated memory.  (Or &lt;code&gt;gcc -z execstack&lt;/code&gt; links the program with stack + data segment + heap executable, as a quick hack.)&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;To disassemble these, you can compile this to put a label on the bytes, and use a disassembler.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// at global scope&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; swap[] = &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\x8b\\x44\\x24\\x04\\x8b\\x5c\\x24\\x08\\x8b\\x00\\x8b\\x1b\\x31\\xc3\\x31\\xd8\\x31\\xc3\\x8b\\x4c\\x24\\x04\\x89\\x01\\x8b\\x4c\\x24\\x08\\x89\\x19\\xc3 &amp;lt;- This swaps the values of a and b&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Compiling with &lt;code&gt;gcc -c -m32 foo.c&lt;/code&gt; and disassembling with &lt;code&gt;objdump -D -rwC -Mintel&lt;/code&gt;, we can get the assembly, and find out that this code violates the ABI by clobbering EBX (a call-preserved register) and is generally inefficient.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;00000000&lt;/span&gt; &amp;lt;swap&amp;gt;:\n   &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;:   &lt;span class=&quot;hljs-number&quot;&gt;8b&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;44&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;24&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;04&lt;/span&gt;             mov    eax,DWORD PTR [esp+&lt;span class=&quot;hljs-number&quot;&gt;0x4&lt;/span&gt;]   &lt;span class=&quot;hljs-meta&quot;&gt;# load int *a arg from the stack&lt;/span&gt;\n   &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;:   &lt;span class=&quot;hljs-number&quot;&gt;8b&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;c &lt;span class=&quot;hljs-number&quot;&gt;24&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;08&lt;/span&gt;             mov    ebx,DWORD PTR [esp+&lt;span class=&quot;hljs-number&quot;&gt;0x8&lt;/span&gt;]   &lt;span class=&quot;hljs-meta&quot;&gt;# ebx = b&lt;/span&gt;\n   &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;:   &lt;span class=&quot;hljs-number&quot;&gt;8b&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt;                   mov    eax,DWORD PTR [eax]       &lt;span class=&quot;hljs-meta&quot;&gt;# dereference: eax = *a&lt;/span&gt;\n   a:   &lt;span class=&quot;hljs-number&quot;&gt;8b&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1b&lt;/span&gt;                   mov    ebx,DWORD PTR [ebx]\n   c:   &lt;span class=&quot;hljs-number&quot;&gt;31&lt;/span&gt; c3                   xor    ebx,eax                &lt;span class=&quot;hljs-meta&quot;&gt;# pointless xor-swap&lt;/span&gt;\n   e:   &lt;span class=&quot;hljs-number&quot;&gt;31&lt;/span&gt; d8                   xor    eax,ebx                &lt;span class=&quot;hljs-meta&quot;&gt;# instead of just storing with opposite registers&lt;/span&gt;\n  &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;:   &lt;span class=&quot;hljs-number&quot;&gt;31&lt;/span&gt; c3                   xor    ebx,eax\n  &lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;:   &lt;span class=&quot;hljs-number&quot;&gt;8b&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;c &lt;span class=&quot;hljs-number&quot;&gt;24&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;04&lt;/span&gt;             mov    ecx,DWORD PTR [esp+&lt;span class=&quot;hljs-number&quot;&gt;0x4&lt;/span&gt;]  &lt;span class=&quot;hljs-meta&quot;&gt;# reload a from the stack&lt;/span&gt;\n  &lt;span class=&quot;hljs-number&quot;&gt;16&lt;/span&gt;:   &lt;span class=&quot;hljs-number&quot;&gt;89&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;01&lt;/span&gt;                   mov    DWORD PTR [ecx],eax     &lt;span class=&quot;hljs-meta&quot;&gt;# store to *a&lt;/span&gt;\n  &lt;span class=&quot;hljs-number&quot;&gt;18&lt;/span&gt;:   &lt;span class=&quot;hljs-number&quot;&gt;8b&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;c &lt;span class=&quot;hljs-number&quot;&gt;24&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;08&lt;/span&gt;             mov    ecx,DWORD PTR [esp+&lt;span class=&quot;hljs-number&quot;&gt;0x8&lt;/span&gt;]\n  &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;c:   &lt;span class=&quot;hljs-number&quot;&gt;89&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;19&lt;/span&gt;                   mov    DWORD PTR [ecx],ebx\n  &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;e:   c3                      ret    \n\n  not shown: the later bytes are ASCII text documentation\n  they&lt;span class=&quot;hljs-number&quot;&gt;&apos;&lt;/span&gt;re not executed by the CPU because the ret instruction sends execution back to the caller\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This machine code will (probably) work in 32-bit code on Windows, Linux, OS X, and so on: the default calling conventions on all those OSes pass args on the stack instead of more efficiently in registers.  But EBX is call-preserved in all the normal calling conventions, so using it as a scratch register without saving/restoring it can easily make the caller crash.&lt;/p&gt;\n    ","\n&lt;p&gt;One of my favorite uses for function pointers is as cheap and easy iterators - &lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; MAX_COLORS  256&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;\n    &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;* name;\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; red;\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; green;\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; blue;\n} Color;\n\nColor Colors[MAX_COLORS];\n\n\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;eachColor&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; (*fp)(Color *c))&lt;/span&gt; {\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i&amp;lt;MAX_COLORS; i++)\n        (*fp)(&amp;amp;Colors[i]);\n}\n\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;printColor&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Color* c)&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (c-&amp;gt;name)\n        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%s = %i,%i,%i\\n&quot;&lt;/span&gt;, c-&amp;gt;name, c-&amp;gt;red, c-&amp;gt;green, c-&amp;gt;blue);\n}\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n    Colors[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;].name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;red&quot;&lt;/span&gt;;\n    Colors[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;].red=&lt;span class=&quot;hljs-number&quot;&gt;255&lt;/span&gt;;\n    Colors[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;].name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;blue&quot;&lt;/span&gt;;\n    Colors[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;].blue=&lt;span class=&quot;hljs-number&quot;&gt;255&lt;/span&gt;;\n    Colors[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;].name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;black&quot;&lt;/span&gt;;\n\n    eachColor(printColor);\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Function pointers become easy to declare once you have the basic declarators:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;id: &lt;code&gt;ID&lt;/code&gt;: &lt;em&gt;ID is a&lt;/em&gt;&lt;/li&gt;\n&lt;li&gt;Pointer: &lt;code&gt;*D&lt;/code&gt;: &lt;em&gt;D pointer to&lt;/em&gt;&lt;/li&gt;\n&lt;li&gt;Function: &lt;code&gt;D(&amp;lt;parameters&amp;gt;)&lt;/code&gt;: &lt;em&gt;D function taking &lt;code&gt;&amp;lt;&lt;/code&gt;parameters&lt;code&gt;&amp;gt;&lt;/code&gt; returning&lt;/em&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;While D is another declarator built using those same rules. In the end, somewhere, it ends with &lt;code&gt;ID&lt;/code&gt; (see below for an example), which is the name of the declared entity. Let&apos;s try to build a function taking a pointer to a function taking nothing and returning int, and returning a pointer to a function taking a char and returning int. With type-defs it&apos;s like this&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;ReturnFunction&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;)&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;ParameterFunction&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;;\nReturnFunction *&lt;span class=&quot;hljs-title function_&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(ParameterFunction *p)&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;As you see, it&apos;s pretty easy to build it up using typedefs. Without typedefs, it&apos;s not hard either with the above declarator rules, applied consistently. As you see i missed out the part the pointer points to, and the thing the function returns. That&apos;s what appears at the very left of the declaration, and is not of interest: It&apos;s added at the end if one built up the declarator already. Let&apos;s do that. Building it up consistently, first wordy - showing the structure using &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;function taking \n    [pointer to [function taking [&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;] returning [&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;]]] \nreturning\n    [pointer to [function taking [&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;] returning [&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;]]]\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;As you see, one can describe a type completely by appending declarators one after each other. Construction can be done in two ways. One is bottom-up, starting with the very right thing (leaves) and working the way through up to the identifier. The other way is top-down, starting at the identifier, working the way down to the leaves. I&apos;ll show both ways.&lt;/p&gt;\n\n&lt;h2&gt;Bottom Up&lt;/h2&gt;\n\n&lt;p&gt;Construction starts with the thing at the right: The thing returned, which is the function taking char. To keep the declarators distinct, i&apos;m going to number them:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;D1(&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Inserted the char parameter directly, since it&apos;s trivial. Adding a pointer to declarator by replacing &lt;code&gt;D1&lt;/code&gt; by &lt;code&gt;*D2&lt;/code&gt;. Note that we have to wrap parentheses around &lt;code&gt;*D2&lt;/code&gt;. That can be known by looking up the precedence of the &lt;code&gt;*-operator&lt;/code&gt; and the function-call operator &lt;code&gt;()&lt;/code&gt;. Without our parentheses, the compiler would read it as &lt;code&gt;*(D2(char p))&lt;/code&gt;. But that would not be a plain replace of D1 by &lt;code&gt;*D2&lt;/code&gt; anymore, of course. Parentheses are always allowed around declarators. So you don&apos;t make anything wrong if you add too much of them, actually.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;(*D2)(&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Return type is complete! Now, let&apos;s replace &lt;code&gt;D2&lt;/code&gt; by the function declarator &lt;em&gt;function taking &lt;code&gt;&amp;lt;parameters&amp;gt;&lt;/code&gt; returning&lt;/em&gt;, which is &lt;code&gt;D3(&amp;lt;parameters&amp;gt;)&lt;/code&gt; which we are at now. &lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;(*D3(&amp;lt;parameters&amp;gt;))(&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Note that no parentheses are needed, since we &lt;em&gt;want&lt;/em&gt; &lt;code&gt;D3&lt;/code&gt; to be a function-declarator and not a pointer declarator this time. Great, only thing left is the parameters for it. The parameter is done exactly the same as we&apos;ve done the return type, just with &lt;code&gt;char&lt;/code&gt; replaced by &lt;code&gt;void&lt;/code&gt;. So i&apos;ll copy it:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;(*D3(   (*ID1)(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)))(&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I&apos;ve replaced &lt;code&gt;D2&lt;/code&gt; by &lt;code&gt;ID1&lt;/code&gt;, since we are finished with that parameter (it&apos;s already a pointer to a function - no need for another declarator). &lt;code&gt;ID1&lt;/code&gt; will be the name of the parameter. Now, i told above at the end one adds the type which all those declarator modify - the one appearing at the very left of every declaration. For functions, that becomes the return type. For pointers the pointed to type etc... It&apos;s interesting when written down the type, it will appear in the opposite order, at the very right :) Anyway, substituting it yields the complete declaration. Both times &lt;code&gt;int&lt;/code&gt; of course. &lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*ID0(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*ID1)(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)))(&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I&apos;ve called the identifier of the function &lt;code&gt;ID0&lt;/code&gt; in that example. &lt;/p&gt;\n\n&lt;h2&gt;Top Down&lt;/h2&gt;\n\n&lt;p&gt;This starts at the identifier at the very left in the description of the type, wrapping that declarator as we walk our way through the right. Start with &lt;em&gt;function taking &lt;code&gt;&amp;lt;&lt;/code&gt;parameters&lt;code&gt;&amp;gt;&lt;/code&gt; returning&lt;/em&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;ID0(&amp;lt;parameters&amp;gt;)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The next thing in the description (after &quot;returning&quot;) was &lt;em&gt;pointer to&lt;/em&gt;. Let&apos;s incorporate it:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;*ID0(&amp;lt;parameters&amp;gt;)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Then the next thing was &lt;em&gt;functon taking &lt;code&gt;&amp;lt;&lt;/code&gt;parameters&lt;code&gt;&amp;gt;&lt;/code&gt; returning&lt;/em&gt;. The parameter is a simple char, so we put it in right away again, since it&apos;s really trivial.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;(*ID0(&amp;lt;parameters&amp;gt;))(&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Note the parentheses we added, since we again want that the &lt;code&gt;*&lt;/code&gt; binds first, and &lt;em&gt;then&lt;/em&gt; the &lt;code&gt;(char)&lt;/code&gt;. Otherwise it would read &lt;em&gt;function taking &lt;code&gt;&amp;lt;&lt;/code&gt;parameters&lt;code&gt;&amp;gt;&lt;/code&gt; returning function ...&lt;/em&gt;. Noes, functions returning functions aren&apos;t even allowed. &lt;/p&gt;\n\n&lt;p&gt;Now we just need to put &lt;code&gt;&amp;lt;&lt;/code&gt;parameters&lt;code&gt;&amp;gt;&lt;/code&gt;. I will show a short version of the deriveration, since i think you already by now have the idea how to do it.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;pointer to: *ID1\n... function taking &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; returning: (*ID1)(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Just put &lt;code&gt;int&lt;/code&gt; before the declarators like we did with bottom-up, and we are finished&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*ID0(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*ID1)(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)))(&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h2&gt;The nice thing&lt;/h2&gt;\n\n&lt;p&gt;Is bottom-up or top-down better? I&apos;m used to bottom-up, but some people may be more comfortable with top-down. It&apos;s a matter of taste i think. Incidentally, if you apply all the operators in that declaration, you will end up getting an int:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; v = (*ID0(some_function_pointer))(some_char);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;That is a nice property of declarations in C: The declaration asserts that if those operators are used in an expression using the identifier, then it yields the type on the very left. It&apos;s like that for arrays too. &lt;/p&gt;\n\n&lt;p&gt;Hope you liked this little tutorial! Now we can link to this when people wonder about the strange declaration syntax of functions. I tried to put as little C internals as possible. Feel free to edit/fix things in it. &lt;/p&gt;\n    ","\n&lt;h2&gt;Another good use for function pointers:&lt;br&gt;Switching between versions painlessly&lt;/h2&gt;\n\n&lt;p&gt;They&apos;re very handy to use for when you want different functions at different times, or different phases of development. For instance, I&apos;m developing an application on a host computer that has a console, but the final release of the software will be put on an Avnet ZedBoard (which has ports for displays and consoles, but they are not needed/wanted for the final release). So during development, I will use &lt;code&gt;printf&lt;/code&gt; to view status and error messages, but when I&apos;m done, I don&apos;t want anything printed. Here&apos;s what I&apos;ve done:&lt;/p&gt;\n\n&lt;h1&gt;version.h&lt;/h1&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// First, undefine all macros associated with version.h&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;undef&lt;/span&gt; DEBUG_VERSION&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;undef&lt;/span&gt; RELEASE_VERSION&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;undef&lt;/span&gt; INVALID_VERSION&lt;/span&gt;\n\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// Define which version we want to use&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; DEBUG_VERSION       &lt;span class=&quot;hljs-comment&quot;&gt;// The current version&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// #define RELEASE_VERSION  // To be uncommented when finished debugging&lt;/span&gt;\n\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;ifndef&lt;/span&gt; __VERSION_H_      &lt;span class=&quot;hljs-comment&quot;&gt;/* prevent circular inclusions */&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; __VERSION_H_  &lt;span class=&quot;hljs-comment&quot;&gt;/* by using protection macros */&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;board_init&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;;\n    &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;noprintf&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *c, ...)&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// mimic the printf prototype&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// Mimics the printf function prototype. This is what I&apos;ll actually &lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// use to print stuff to the screen&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; (* zprintf)(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;*, ...); \n\n&lt;span class=&quot;hljs-comment&quot;&gt;// If debug version, use printf&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;ifdef&lt;/span&gt; DEBUG_VERSION&lt;/span&gt;\n    &lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// If both debug and release version, error&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;ifdef&lt;/span&gt; DEBUG_VERSION&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;ifdef&lt;/span&gt; RELEASE_VERSION&lt;/span&gt;\n    &lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; INVALID_VERSION&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// If neither debug or release version, error&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;ifndef&lt;/span&gt; DEBUG_VERSION&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;ifndef&lt;/span&gt; RELEASE_VERSION&lt;/span&gt;\n    &lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; INVALID_VERSION&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;ifdef&lt;/span&gt; INVALID_VERSION&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Won&apos;t allow compilation without a valid version define&lt;/span&gt;\n    &lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Invalid version definition&quot;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In &lt;code&gt;version.c&lt;/code&gt; I will define the 2 function prototypes present in &lt;code&gt;version.h&lt;/code&gt;&lt;/p&gt;\n\n&lt;h1&gt;version.c&lt;/h1&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;version.h&quot;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;/*****************************************************************************/&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;/**\n* @name board_init\n*\n* Sets up the application based on the version type defined in version.h.\n* Includes allowing or prohibiting printing to STDOUT.\n*\n* MUST BE CALLED FIRST THING IN MAIN\n*\n* @return    None\n*\n*****************************************************************************/&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;board_init&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Assign the print function to the correct function pointer&lt;/span&gt;\n    &lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;ifdef&lt;/span&gt; DEBUG_VERSION&lt;/span&gt;\n        zprintf = &amp;amp;&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;;\n    &lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;// Defined below this function&lt;/span&gt;\n        zprintf = &amp;amp;noprintf;\n    &lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;\n}\n\n&lt;span class=&quot;hljs-comment&quot;&gt;/*****************************************************************************/&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;/**\n* @name noprintf\n*\n* simply returns with no actions performed\n*\n* @return   None\n*\n*****************************************************************************/&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;noprintf&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;* c, ...)&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;/p&gt;&lt;p&gt;Notice how the function pointer is prototyped in &lt;code&gt;version.h&lt;/code&gt; as &lt;/p&gt;&lt;p&gt;&lt;code&gt;void (* zprintf)(const char *, ...);&lt;/code&gt;&lt;/p&gt;&lt;p&gt;When it is referenced in the application, it will start executing wherever it is pointing, which has yet to be defined.&lt;/p&gt;\n&lt;p&gt;In &lt;code&gt;version.c&lt;/code&gt;, notice in the &lt;code&gt;board_init()&lt;/code&gt;function where &lt;code&gt;zprintf&lt;/code&gt; is assigned a unique function (whose function signature matches) depending on the version that is defined in &lt;code&gt;version.h&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;zprintf = &amp;amp;printf;&lt;/code&gt; zprintf calls printf for debugging purposes&lt;/p&gt;&lt;p&gt;or&lt;/p&gt;&lt;p&gt;&lt;code&gt;zprintf = &amp;amp;noprint;&lt;/code&gt; zprintf just returns and will not run unnecessary code&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n\n&lt;p&gt;Running the code will look like this:&lt;/p&gt;\n\n&lt;h1&gt;mainProg.c&lt;/h1&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;version.h&quot;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Must run board_init(), which assigns the function&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// pointer to an actual function&lt;/span&gt;\n    board_init();\n\n    &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; *ptr = &lt;span class=&quot;hljs-built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;// Allocate 100 bytes of memory&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// malloc returns NULL if unable to allocate the memory.&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (ptr == &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;)\n    {\n        zprintf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Unable to allocate memory\\n&quot;&lt;/span&gt;);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    }\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Other things to do...&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The above code will use &lt;code&gt;printf&lt;/code&gt; if in debug mode, or do nothing if in release mode. This is much easier than going through the entire project and commenting out or deleting code. All that I need to do is change the version in &lt;code&gt;version.h&lt;/code&gt; and the code will do the rest!&lt;/p&gt;\n    ","\n&lt;p&gt;Function pointer is usually defined by &lt;code&gt;typedef&lt;/code&gt;, and used as param &amp;amp; return value.&lt;/p&gt;\n\n&lt;p&gt;Above answers already explained a lot, I just give a full example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; NUM_A 1&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; NUM_B 2&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// define a function pointer type&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(*two_num_operation)&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// an actual standalone function&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b)&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a + b;\n}\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// use function pointer as param,&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;sum_via_pointer&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b, two_num_operation funp)&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (*funp)(a, b);\n}\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// use function pointer as return value,&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; two_num_operation &lt;span class=&quot;hljs-title function_&quot;&gt;get_sum_fun&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &amp;amp;sum;\n}\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// test - use function pointer as variable,&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;test_pointer_as_variable&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n    &lt;span class=&quot;hljs-comment&quot;&gt;// create a pointer to function,&lt;/span&gt;\n    two_num_operation sum_p = &amp;amp;sum;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// call function via pointer&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;pointer as variable:\\t %d + %d = %d\\n&quot;&lt;/span&gt;, NUM_A, NUM_B, (*sum_p)(NUM_A, NUM_B));\n}\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// test - use function pointer as param,&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;test_pointer_as_param&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;pointer as param:\\t %d + %d = %d\\n&quot;&lt;/span&gt;, NUM_A, NUM_B, sum_via_pointer(NUM_A, NUM_B, &amp;amp;sum));\n}\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// test - use function pointer as return value,&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;test_pointer_as_return_value&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;pointer as return value:\\t %d + %d = %d\\n&quot;&lt;/span&gt;, NUM_A, NUM_B, (*get_sum_fun())(NUM_A, NUM_B));\n}\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n    test_pointer_as_variable();\n    test_pointer_as_param();\n    test_pointer_as_return_value();\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Starting from scratch function has Some Memory Address From Where They start executing. In Assembly Language They Are called as (call &quot;function&apos;s memory address&quot;).Now come back to C If function has a memory address then they can be manipulated by Pointers in C.So By the rules of C &lt;/p&gt;\n\n&lt;p&gt;1.First you need to declare a pointer to function \n2.Pass the Address of the  Desired function &lt;/p&gt;\n\n&lt;p&gt;****Note-&amp;gt;the functions should be of same type**** &lt;/p&gt;\n\n&lt;p&gt;This Simple Programme will Illustrate Every Thing.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; (*print)() ;&lt;span class=&quot;hljs-comment&quot;&gt;//Declare a  Function Pointers&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;sayhello&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;;&lt;span class=&quot;hljs-comment&quot;&gt;//Declare The Function Whose Address is to be passed&lt;/span&gt;\n                &lt;span class=&quot;hljs-comment&quot;&gt;//The Functions should Be of Same Type&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n{\n print=sayhello;&lt;span class=&quot;hljs-comment&quot;&gt;//Addressof sayhello is assigned to print&lt;/span&gt;\n print();&lt;span class=&quot;hljs-comment&quot;&gt;//print Does A call To The Function &lt;/span&gt;\n &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;sayhello&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n{\n &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n Hello World&quot;&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;img src=&quot;https://i.stack.imgur.com/L4qpJ.png&quot; alt=&quot;enter image description here&quot;&gt;After That lets See How machine Understands Them.Glimpse of machine instruction of the above programme in 32 bit architecture.&lt;/p&gt;\n\n&lt;p&gt;The red mark area is showing how the address is being exchanged and storing in eax. Then their is a call instruction on eax. eax contains the desired address of the function.&lt;/p&gt;\n    ","\n&lt;p&gt;One of the big uses for function pointers in C is to call a function selected at run-time. For example, the C run-time library has two routines, &lt;a href=&quot;https://en.cppreference.com/w/c/algorithm/qsort&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;qsort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://en.cppreference.com/w/c/algorithm/bsearch&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;bsearch&lt;/code&gt;&lt;/a&gt;, which take a pointer to a function that is called to compare two items being sorted; this allows you to sort or search, respectively, anything, based on any criteria you wish to use. &lt;/p&gt;\n\n&lt;p&gt;A very basic example, if there is one function called &lt;code&gt;print(int x, int y)&lt;/code&gt; which in turn may require to call a function (either &lt;code&gt;add()&lt;/code&gt; or &lt;code&gt;sub()&lt;/code&gt;, which are of the same type) then what we will do, we will add one function pointer argument to the &lt;code&gt;print()&lt;/code&gt; function as shown below:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n{\n   &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;+&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;);\n}\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;sub&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n{\n   &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;-10&lt;/span&gt;);\n}\n\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; y, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*func)())&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;value is: %d\\n&quot;&lt;/span&gt;, (x+y+(*func)()));\n}\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x=&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;, y=&lt;span class=&quot;hljs-number&quot;&gt;200&lt;/span&gt;;\n    print(x,y,add);\n    print(x,y,sub);\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The output is:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;value is: 410&lt;br&gt;\n  value is: 390&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;A function pointer is a variable that contains the address of a function. Since it is a pointer variable though with some restricted properties, you can use it pretty much like you would any other pointer variable in data structures.&lt;/p&gt;\n\n&lt;p&gt;The only exception I can think of is treating the function pointer as pointing to something other than a single value. Doing pointer arithmetic by incrementing or decrementing a function pointer or adding/subtracting an offset to a function pointer isn&apos;t really of any utility as a function pointer only points to a single thing, the entry point of a function.&lt;/p&gt;\n\n&lt;p&gt;The size of a function pointer variable, the number of bytes occupied by the variable, may vary depending on the underlying architecture, e.g. x32 or x64 or whatever.&lt;/p&gt;\n\n&lt;p&gt;The declaration for a function pointer variable needs to specify the same kind of information as a function declaration in order for the C compiler to do the kinds of checks that it normally does. If you don&apos;t specify a parameter list in the declaration/definition of the function pointer, the C compiler will not be able to check the use of parameters. There are cases when this lack of checking can be useful however just remember that a safety net has been removed.&lt;/p&gt;\n\n&lt;p&gt;Some examples:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *pStr)&lt;/span&gt;;    &lt;span class=&quot;hljs-comment&quot;&gt;// declares a function&lt;/span&gt;\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*pFunc)(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *pStr);  &lt;span class=&quot;hljs-comment&quot;&gt;// declares or defines a function pointer&lt;/span&gt;\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*pFunc2) ();                 &lt;span class=&quot;hljs-comment&quot;&gt;// declares or defines a function pointer, no parameter list specified.&lt;/span&gt;\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*pFunc3) (&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;);             &lt;span class=&quot;hljs-comment&quot;&gt;// declares or defines a function pointer, no arguments.&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The first two declararations are somewhat similar in that:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;func&lt;/code&gt; is a function that takes an &lt;code&gt;int&lt;/code&gt; and a &lt;code&gt;char *&lt;/code&gt; and returns an &lt;code&gt;int&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;pFunc&lt;/code&gt; is a function pointer to which is assigned the address of a function that takes an &lt;code&gt;int&lt;/code&gt; and a &lt;code&gt;char *&lt;/code&gt; and returns an &lt;code&gt;int&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;So from the above we could have a source line in which the address of the function &lt;code&gt;func()&lt;/code&gt; is assigned to the function pointer variable &lt;code&gt;pFunc&lt;/code&gt; as in &lt;code&gt;pFunc = func;&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;Notice the syntax used with a function pointer declaration/definition in which parenthesis are used to overcome the natural operator precedence rules.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *&lt;span class=&quot;hljs-title function_&quot;&gt;pfunc&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *pStr)&lt;/span&gt;;    &lt;span class=&quot;hljs-comment&quot;&gt;// declares a function that returns int pointer&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*pFunc)(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *pStr);  &lt;span class=&quot;hljs-comment&quot;&gt;// declares a function pointer that returns an int&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;Several Different Usage Examples&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Some examples of usage of a function pointer:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*pFunc) (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *pStr);    &lt;span class=&quot;hljs-comment&quot;&gt;// declare a simple function pointer variable&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*pFunc[&lt;span class=&quot;hljs-number&quot;&gt;55&lt;/span&gt;])(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *pStr); &lt;span class=&quot;hljs-comment&quot;&gt;// declare an array of 55 function pointers&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (**pFunc)(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *pStr);    &lt;span class=&quot;hljs-comment&quot;&gt;// declare a pointer to a function pointer variable&lt;/span&gt;\n&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;                             &lt;span class=&quot;hljs-comment&quot;&gt;// declare a struct that contains a function pointer&lt;/span&gt;\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x22;\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*pFunc)(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *pStr);\n} thing = {&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, func};                 &lt;span class=&quot;hljs-comment&quot;&gt;// assign values to the struct variable&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; * &lt;span class=&quot;hljs-title function_&quot;&gt;xF&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*p)(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *pStr))&lt;/span&gt;;  &lt;span class=&quot;hljs-comment&quot;&gt;// declare a function that has a function pointer as an argument&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; * (*pxF) (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*p)(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *pStr));  &lt;span class=&quot;hljs-comment&quot;&gt;// declare a function pointer that points to a function that has a function pointer as an argument&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You can use variable length parameter lists in the definition of a function pointer.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b, ...)&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*psum)(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b, ...);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Or you can not specify a parameter list at all. This can be useful but it eliminates the opportunity for the C compiler to perform checks on the argument list provided. &lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;  &lt;span class=&quot;hljs-title function_&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;;      &lt;span class=&quot;hljs-comment&quot;&gt;// nothing specified in the argument list so could be anything or nothing&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*psum)();\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;  &lt;span class=&quot;hljs-title function_&quot;&gt;sum2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;;  &lt;span class=&quot;hljs-comment&quot;&gt;// void specified in the argument list so no parameters when calling this function&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*psum2)(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;C style Casts&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;You can use C style casts with function pointers. However be aware that a C compiler may be lax about checks or provide warnings rather than errors.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *b)&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*psplsum) (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b);\npsplsum = sum;               &lt;span class=&quot;hljs-comment&quot;&gt;// generates a compiler warning&lt;/span&gt;\npsplsum = (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*)(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b)) sum;   &lt;span class=&quot;hljs-comment&quot;&gt;// no compiler warning, cast to function pointer&lt;/span&gt;\npsplsum = (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b)) sum;     &lt;span class=&quot;hljs-comment&quot;&gt;// compiler error of bad cast generated, parenthesis are required.&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;Compare Function Pointer to Equality&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;You can check that a function pointer is equal to a particular function address using an &lt;code&gt;if&lt;/code&gt; statement though I am not sure how useful that would be. Other comparison operators would seem to have even less utility.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;func1&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b)&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a + b;\n}\n\n&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;func2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *c)&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; c[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] + a + b;\n}\n\n&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;func3&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *x)&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a + b;\n}\n\n&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *&lt;span class=&quot;hljs-title function_&quot;&gt;func4&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *c, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*p)())&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (p == func1) {\n        p(a, b);\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (p == func2) {\n        p(a, b, c);      &lt;span class=&quot;hljs-comment&quot;&gt;// warning C4047: &apos;==&apos;: &apos;int (__cdecl *)()&apos; differs in levels of indirection from &apos;char *(__cdecl *)(int,int,char *)&apos;&lt;/span&gt;\n    } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (p == func3) {\n        p(a, b, c);\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; c;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;An Array of Function Pointers&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;And if you want to have an array of function pointers each of the elements of which the argument list has differences then you can define a function pointer with the argument list unspecified (not &lt;code&gt;void&lt;/code&gt; which means no arguments but just unspecified) something like the following though you may see warnings from the C compiler. This also works for a function pointer parameter to a function:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;(*p[])() = {       &lt;span class=&quot;hljs-comment&quot;&gt;// an array of function pointers&lt;/span&gt;\n    func1, func2, func3\n};\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;(**pp)();          &lt;span class=&quot;hljs-comment&quot;&gt;// a pointer to a function pointer&lt;/span&gt;\n\n\np[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;](a, b);\np[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;](a, b, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);\np[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;](a, b);      &lt;span class=&quot;hljs-comment&quot;&gt;// oops, left off the last argument but it compiles anyway.&lt;/span&gt;\n\nfunc4(a, b, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, func1);\nfunc4(a, b, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, func2);  &lt;span class=&quot;hljs-comment&quot;&gt;// warning C4047: &apos;function&apos;: &apos;int (__cdecl *)()&apos; differs in levels of indirection from &apos;char *(__cdecl *)(int,int,char *)&apos;&lt;/span&gt;\nfunc4(a, b, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, func3);\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// iterate over the array elements using an array index&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(p) / &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(p[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]); i++) {\n    func4(a, b, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, p[i]);\n}\n    &lt;span class=&quot;hljs-comment&quot;&gt;// iterate over the array elements using a pointer&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (pp = p; pp &amp;lt; p + &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(p)/&lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(p[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]); pp++) {\n    (*pp)(a, b, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);          &lt;span class=&quot;hljs-comment&quot;&gt;// pointer to a function pointer so must dereference it.&lt;/span&gt;\n    func4(a, b, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, *pp);     &lt;span class=&quot;hljs-comment&quot;&gt;// pointer to a function pointer so must dereference it.&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;C style &lt;code&gt;namespace&lt;/code&gt; Using Global &lt;code&gt;struct&lt;/code&gt; with Function Pointers&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;You can use the &lt;code&gt;static&lt;/code&gt; keyword to specify a function whose name is file scope and then assign this to a global variable as a way of providing something similar to the &lt;code&gt;namespace&lt;/code&gt; functionality of C++.&lt;/p&gt;\n\n&lt;p&gt;In a header file define a struct that will be our namespace along with a global variable that uses it.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;\n   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*func1) (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b);             &lt;span class=&quot;hljs-comment&quot;&gt;// pointer to function that returns an int&lt;/span&gt;\n   &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *(*func2) (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *c);  &lt;span class=&quot;hljs-comment&quot;&gt;// pointer to function that returns a pointer&lt;/span&gt;\n} FuncThings;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; FuncThings FuncThingsGlobal;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Then in the C source file:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;header.h&quot;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// the function names used with these static functions do not need to be the&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// same as the struct member names. It&apos;s just helpful if they are when trying&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// to search for them.&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// the static keyword ensures these names are file scope only and not visible&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// outside of the file.&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;func1&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b)&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a + b;\n}\n\n&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *&lt;span class=&quot;hljs-title function_&quot;&gt;func2&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *c)&lt;/span&gt;\n{\n    c[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = a % &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;; c[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] = b % &lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; c;\n}\n\n&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; FuncThings FuncThingsGlobal = {func1, func2};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This would then be used by specifying the complete name of global struct variable and member name to access the function. The &lt;code&gt;const&lt;/code&gt; modifier is used on the global so that it can not be changed by accident.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; abcd = FuncThingsGlobal.func1 (a, b);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;Application Areas of Function Pointers&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;A DLL library component could do something similar to the C style &lt;code&gt;namespace&lt;/code&gt; approach in which a particular library interface is requested from a factory method in a library interface which supports the creation of a &lt;code&gt;struct&lt;/code&gt; containing function pointers.. This library interface loads the requested DLL version, creates a struct with the necessary function pointers, and then returns the struct to the requesting caller for use.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;\n    HMODULE  hModule;\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*Func1)();\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*Func2)();\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;(*Func3)(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b);\n} LibraryFuncStruct;\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;  LoadLibraryFunc LPCTSTR  dllFileName, LibraryFuncStruct *pStruct)\n{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;  retStatus = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;   &lt;span class=&quot;hljs-comment&quot;&gt;// default is an error detected&lt;/span&gt;\n\n    pStruct-&amp;gt;hModule = LoadLibrary (dllFileName);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (pStruct-&amp;gt;hModule) {\n        pStruct-&amp;gt;Func1 = (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*)()) GetProcAddress (pStruct-&amp;gt;hModule, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Func1&quot;&lt;/span&gt;);\n        pStruct-&amp;gt;Func2 = (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*)()) GetProcAddress (pStruct-&amp;gt;hModule, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Func2&quot;&lt;/span&gt;);\n        pStruct-&amp;gt;Func3 = (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*)(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b)) GetProcAddress(pStruct-&amp;gt;hModule, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Func3&quot;&lt;/span&gt;);\n        retStatus = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    }\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; retStatus;\n}\n\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;FreeLibraryFunc&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(LibraryFuncStruct *pStruct)&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (pStruct-&amp;gt;hModule) FreeLibrary (pStruct-&amp;gt;hModule);\n    pStruct-&amp;gt;hModule = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and this could be used as in:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;LibraryFuncStruct myLib = {&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;};\nLoadLibraryFunc (&lt;span class=&quot;hljs-string&quot;&gt;L&quot;library.dll&quot;&lt;/span&gt;, &amp;amp;myLib);\n&lt;span class=&quot;hljs-comment&quot;&gt;//  ....&lt;/span&gt;\nmyLib.Func1();\n&lt;span class=&quot;hljs-comment&quot;&gt;//  ....&lt;/span&gt;\nFreeLibraryFunc (&amp;amp;myLib);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The same approach can be used to define an abstract hardware layer for code that uses a particular model of the underlying hardware. Function pointers are filled in with hardware specific functions by a factory to provide the hardware specific functionality that implements functions specified in the abstract hardware model. This can be used to provide an abstract hardware layer used by software which calls a factory function in order to get the specific hardware function interface then uses the function pointers provided to perform actions for the underlying hardware without needing to know implementation details about the specific target.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Function Pointers to create Delegates, Handlers, and Callbacks&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;You can use function pointers as a way to delegate some task or functionality. The classic example in C is the comparison delegate function pointer used with the Standard C library functions &lt;code&gt;qsort()&lt;/code&gt; and &lt;code&gt;bsearch()&lt;/code&gt; to provide the collation order for sorting a list of items or performing a binary search over a sorted list of items. The comparison function delegate specifies the collation algorithm used in the sort or the binary search.&lt;/p&gt;\n\n&lt;p&gt;Another use is similar to applying an algorithm to a C++ Standard Template Library container.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; * &lt;span class=&quot;hljs-title function_&quot;&gt;ApplyAlgorithm&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; *pArray, &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; sizeItem, &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; nItems, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*p)(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; *))&lt;/span&gt; {\n    &lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *pList = pArray;\n    &lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *pListEnd = pList + nItems * sizeItem;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; ( ; pList &amp;lt; pListEnd; pList += sizeItem) {\n        p (pList);\n    }\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; pArray;\n}\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;pIncrement&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *pI)&lt;/span&gt; {\n    (*pI)++;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n}\n\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; * &lt;span class=&quot;hljs-title function_&quot;&gt;ApplyFold&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; *pArray, &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; sizeItem, &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; nItems, &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; * pResult, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;(*p)(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; *, &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; *))&lt;/span&gt; {\n    &lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *pList = pArray;\n    &lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *pListEnd = pList + nItems * sizeItem;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (; pList &amp;lt; pListEnd; pList += sizeItem) {\n        p(pList, pResult);\n    }\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; pArray;\n}\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;pSummation&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *pI, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *pSum)&lt;/span&gt; {\n    (*pSum) += *pI;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n}\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// source code and then lets use our function.&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; intList[&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;] = { &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; }, iSum = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n\nApplyAlgorithm(intList, &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;), &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(intList) / &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(intList[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]), pIncrement);\nApplyFold(intList, &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;), &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(intList) / &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(intList[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]), &amp;amp;iSum, pSummation);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Another example is with GUI source code in which a handler for a particular event is registered by providing a function pointer which is actually called when the event happens. The Microsoft MFC framework with its message maps uses something similar to handle Windows messages that are delivered to a window or thread.&lt;/p&gt;\n\n&lt;p&gt;Asynchronous functions that require a callback are similar to an event handler. The user of the asynchronous function calls the asynchronous function to start some action and provides a function pointer which the asynchronous function will call once the action is complete. In this case the event is the asynchronous function completing its task.&lt;/p&gt;\n    ","\n&lt;p&gt;Since function pointers are often typed callbacks, you might want to have a look at &lt;a href=&quot;http://ccan.ozlabs.org/info/typesafe_cb.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;type safe callbacks&lt;/a&gt;. The same applies to entry points, etc of functions that are not callbacks.&lt;/p&gt;\n\n&lt;p&gt;C is quite fickle and forgiving at the same time :)&lt;/p&gt;\n    "]},"randomTags":[{"name":"terminal","slug":"terminal"},{"name":"pandas-explode","slug":"pandas-explode"},{"name":"authentication","slug":"authentication"},{"name":"java","slug":"java"},{"name":"click","slug":"click"},{"name":"r","slug":"r"},{"name":"uniqueidentifier","slug":"uniqueidentifier"},{"name":"dynamic-memory-allocation","slug":"dynamic-memory-allocation"},{"name":"system.in","slug":"system.in"},{"name":"merge","slug":"merge"},{"name":"file-io","slug":"file-io"},{"name":"groupwise-maximum","slug":"groupwise-maximum"},{"name":"kill","slug":"kill"},{"name":"shared-ptr","slug":"shared-ptr"},{"name":"javascript","slug":"javascript"},{"name":"while-loop","slug":"while-loop"},{"name":"if-statement","slug":"if-statement"},{"name":"winforms","slug":"winforms"},{"name":"nosuchelementexception","slug":"nosuchelementexception"},{"name":"plugins","slug":"plugins"}]},"__N_SSG":true}