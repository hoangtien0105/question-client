<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>xhtml tags | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="All questions and solutions for xhtml tags - page 1"/><meta property="og:title" content="xhtml tags | Solutions Checker"/><meta property="og:description" content="All questions and solutions for xhtml tags - page 1"/><meta name="next-head-count" content="15"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-b06815e21c943e0d.js" defer=""></script><script src="/_next/static/chunks/816-14d8d742fae4ce97.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/tag/%5Bslug%5D/page/%5Bpage%5D-ddde2f39b1530ef5.js" defer=""></script><script src="/_next/static/Zo3C7AOWQzKM9qqyzx2hf/_buildManifest.js" defer=""></script><script src="/_next/static/Zo3C7AOWQzKM9qqyzx2hf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/tag/xhtml/page/1#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="pagination-page-wrapper"><span class="pagination-buttons previous bg-stone-500 cursor-not-allowed  hover:bg-stone-500 text-white font-bold py-2 px-4 rounded">Previous</span></div><div class="question my-5"><div class="flex items-center justify-center"><div class="rounded-xl border p-5 shadow-md post-layout-inner bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/regex-match-open-tags-except-xhtml-self-contained-tags-1657384228245">RegEx match open tags except XHTML self-contained tags</a></div></div></div><div class="tags-wrap h-max space-x-8"><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/xhtml">xhtml</a></div></div></div><div><div class="flex items-center justify-between text-slate-500"><div class="flex space-x-4 md:space-x-8"><span class="btn bg-stone-500 cursor-pointer  hover:bg-stone-500 text-white font-bold py-2 px-4 rounded">Show Solution</span></div></div></div></div></div></div><div class="pagination-page-wrapper"><span class="pagination-buttons next bg-stone-500 cursor-not-allowed  hover:bg-stone-500 text-white font-bold py-2 px-4 rounded">Next</span></div><div class="widget"><a href="/questions/tag/function-pointers">function-pointers</a><a href="/questions/tag/overflow">overflow</a><a href="/questions/tag/system-calls">system-calls</a><a href="/questions/tag/sed">sed</a><a href="/questions/tag/http-headers">http-headers</a><a href="/questions/tag/namespaces">namespaces</a><a href="/questions/tag/prototype">prototype</a><a href="/questions/tag/combinations">combinations</a><a href="/questions/tag/c-strings">c-strings</a><a href="/questions/tag/ajax">ajax</a><a href="/questions/tag/postgresql">postgresql</a><a href="/questions/tag/spring-mvc">spring-mvc</a><a href="/questions/tag/split">split</a><a href="/questions/tag/typescript">typescript</a><a href="/questions/tag/openssl">openssl</a><a href="/questions/tag/substring">substring</a><a href="/questions/tag/iframe">iframe</a><a href="/questions/tag/object">object</a><a href="/questions/tag/git-commit">git-commit</a><a href="/questions/tag/c-preprocessor">c-preprocessor</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"count":1,"rows":[{"id":5,"title":"RegEx match open tags except XHTML self-contained tags","slug":"regex-match-open-tags-except-xhtml-self-contained-tags-1657384228245","postType":"QUESTION","createdAt":"2022-07-09T16:30:28.000Z","updatedAt":"2022-07-09T16:30:28.000Z","tags":[{"id":14,"name":"xhtml","slug":"xhtml","createdAt":"2022-07-09T16:30:28.000Z","updatedAt":"2022-07-09T16:30:28.000Z","Questions_Tags":{"questionId":5,"tagId":14}}]}]},"slug":"xhtml","page":"1","answers":{"5":["\n                    \u0026lt;div\u0026gt;\n            \u0026lt;aside class=\u0026quot;s-notice s-notice__info post-notice js-post-notice mb16\u0026quot; role=\u0026quot;status\u0026quot;\u0026gt;\n        \u0026lt;div class=\u0026quot;d-flex fd-column fw-nowrap\u0026quot;\u0026gt;\n            \u0026lt;div class=\u0026quot;d-flex fw-nowrap\u0026quot;\u0026gt;\n                    \u0026lt;div class=\u0026quot;flex--item mr8\u0026quot;\u0026gt;\n                        \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;svg-icon iconLock\u0026quot; width=\u0026quot;18\u0026quot; height=\u0026quot;18\u0026quot; viewBox=\u0026quot;0 0 18 18\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;M16 9a2 2 0 0 0-2-2V6A5 5 0 0 0 4 6v1a2 2 0 0 0-2 2v6c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V9Zm-7 5a2 2 0 1 1 0-4 2 2 0 0 1 0 4Zm3.1-7H5.9V6a3.1 3.1 0 0 1 6.2 0v1Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                    \u0026lt;/div\u0026gt;\n                \u0026lt;div class=\u0026quot;flex--item wmn0 fl1 lh-lg\u0026quot;\u0026gt;\n                    \u0026lt;div class=\u0026quot;flex--item fl1 lh-lg\u0026quot;\u0026gt;\n                        \u0026lt;b\u0026gt;Locked\u0026lt;/b\u0026gt;. There are \u0026lt;a href=\u0026quot;/help/locked-posts\u0026quot;\u0026gt;disputes about this answers content\u0026lt;/a\u0026gt; being resolved at this time. It is not currently accepting new interactions.\n                        \n                    \u0026lt;/div\u0026gt;\n                \u0026lt;/div\u0026gt;\n            \u0026lt;/div\u0026gt;\n        \u0026lt;/div\u0026gt;\n\u0026lt;/aside\u0026gt;\n\n    \u0026lt;/div\u0026gt;\n\n\u0026lt;p\u0026gt;You can\u0026apos;t parse [X]HTML with regex. Because HTML can\u0026apos;t be parsed by regex. Regex is not a tool that can be used to correctly parse HTML. As I have answered in HTML-and-regex questions here so many times before, the use of regex will not allow you to consume HTML. Regular expressions are a tool that is insufficiently sophisticated to understand the constructs employed by HTML. HTML is not a regular language and hence cannot be parsed by regular expressions. Regex queries are not equipped to break down HTML into its meaningful parts. so many times but it is not getting to me. Even enhanced irregular regular expressions as used by Perl are not up to the task of parsing HTML. You will never make me crack. HTML is a language of sufficient complexity that it cannot be parsed by regular expressions. Even Jon Skeet cannot parse HTML using regular expressions. Every time you attempt to parse HTML with regular expressions, the unholy child weeps the blood of virgins, and Russian hackers pwn your webapp. Parsing HTML with regex summons tainted souls into the realm of the living. HTML and regex go together like love, marriage, and ritual infanticide. The \u0026amp;lt;center\u0026amp;gt; cannot hold it is too late. The force of regex and HTML together in the same conceptual space will destroy your mind like so much watery putty. If you parse HTML with regex you are giving in to Them and their blasphemous ways which doom us all to inhuman toil for the One whose Name cannot be expressed in the Basic Multilingual Plane, he comes. HTML-plus-regexp will liquify the nerves of the sentient whilst you observe, your psyche withering in the onslaught of horror. Rege̿̔̉x-based HTML parsers are the cancer that is killing StackOverflow \u0026lt;i\u0026gt;it is too late it is too late we cannot be saved\u0026lt;/i\u0026gt; the transgression of a chi͡ld ensures regex will consume all living tissue (except for HTML which it cannot, as previously prophesied) \u0026lt;i\u0026gt;dear lord help us how can anyone survive this scourge\u0026lt;/i\u0026gt; using regex to parse HTML has doomed humanity to an eternity of dread torture and security holes \u0026lt;i\u0026gt;using rege\u0026lt;/i\u0026gt;x as a tool to process HTML establishes a brea\u0026lt;i\u0026gt;ch between this world\u0026lt;/i\u0026gt; and the dread realm of c͒ͪo͛ͫrrupt entities (like SGML entities, but \u0026lt;i\u0026gt;more corrupt) a mere glimp\u0026lt;/i\u0026gt;se of the world of reg\u0026lt;b\u0026gt;ex parsers for HTML will ins\u0026lt;/b\u0026gt;tantly transport a p\u0026lt;i\u0026gt;rogrammer\u0026apos;s consciousness i\u0026lt;/i\u0026gt;nto a w\u0026lt;i\u0026gt;orl\u0026lt;/i\u0026gt;d of ceaseless screaming, he comes\u0026lt;strike\u0026gt;, the pestilent sl\u0026lt;/strike\u0026gt;ithy regex-infection wil\u0026lt;b\u0026gt;l devour your HT\u0026lt;/b\u0026gt;ML parser, application and existence for all time like Visual Basic only worse \u0026lt;i\u0026gt;he comes he com\u0026lt;/i\u0026gt;es \u0026lt;i\u0026gt;do not fi\u0026lt;/i\u0026gt;ght h\u0026lt;b\u0026gt;e com̡e̶s, ̕h̵i\u0026lt;/b\u0026gt;s un̨ho͞ly radiańcé de\u0026lt;i\u0026gt;stro҉ying all enli̍̈́̂̈́ghtenment, HTML tags \u0026lt;b\u0026gt;lea͠ki̧n͘g fr̶ǫm ̡yo͟ur eye͢s̸ ̛l̕ik͏e liq\u0026lt;/b\u0026gt;uid p\u0026lt;/i\u0026gt;ain, the song of re̸gular expre\u0026lt;strike\u0026gt;ssion parsing \u0026lt;/strike\u0026gt;will exti\u0026lt;i\u0026gt;nguish the voices of mor\u0026lt;b\u0026gt;tal man from the sp\u0026lt;/b\u0026gt;here I can see it can you see ̲͚̖͔̙î̩́t̲͎̩̱͔́̋̀ it is beautiful t\u0026lt;/i\u0026gt;he f\u0026lt;code\u0026gt;inal snuf\u0026lt;/code\u0026gt;fing o\u0026lt;i\u0026gt;f the lie\u0026lt;b\u0026gt;s of Man ALL IS LOŚ͖̩͇̗̪̏̈́T A\u0026lt;/b\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;b\u0026gt;LL IS L\u0026lt;/b\u0026gt;OST th\u0026lt;i\u0026gt;e pon̷y he come\u0026lt;/i\u0026gt;s he c̶̮om\u0026lt;strike\u0026gt;es he co\u0026lt;/strike\u0026gt;\u0026lt;b\u0026gt;\u0026lt;strike\u0026gt;me\u0026lt;/strike\u0026gt;s t\u0026lt;i\u0026gt;he\u0026lt;/i\u0026gt; ich\u0026lt;/b\u0026gt;or permeat\u0026lt;i\u0026gt;es al\u0026lt;/i\u0026gt;l MY FAC\u0026lt;i\u0026gt;E MY FACE h god n\u0026lt;b\u0026gt;o NO NOO̼\u0026lt;/b\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;b\u0026gt;OO N\u0026lt;/b\u0026gt;Θ stop t\u0026lt;i\u0026gt;he an*̶͑̾̾̅ͫ͏̙̤g͇̫͛͆̾ͫ̑͆l͖͉̗̩̳̟̍ͫͥͨ\u0026lt;/i\u0026gt;e̠̅s\u0026lt;code\u0026gt; ͎a̧͈͖r̽̾̈́͒͑e\u0026lt;/code\u0026gt; n\u0026lt;b\u0026gt;ot rè̑ͧ̌aͨl̘̝̙̃ͤ͂̾̆ ZA̡͊͠͝LGΌ ISͮ̂҉̯͈͕̹̘̱ T\u0026lt;/b\u0026gt;O͇̹̺ͅƝ̴ȳ̳ TH̘\u0026lt;b\u0026gt;Ë͖́̉ ͠P̯͍̭O̚N̐Y̡ H̸̡̪̯ͨ͊̽̅̾̎Ȩ̬̩̾͛ͪ̈́̀́͘ ̶̧̨̱̹̭̯ͧ̾ͬC̷̙̲̝͖ͭ̏ͥͮ͟Oͮ͏̮̪̝͍M̲̖͊̒ͪͩͬ̚̚͜Ȇ̴̟̟͙̞ͩ͌͝\u0026lt;/b\u0026gt;S̨̥̫͎̭ͯ̿̔̀ͅ\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;Have you tried using an XML parser instead?\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Moderator\u0026apos;s Note\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This post is locked to prevent inappropriate edits to its content. The post looks exactly as it is supposed to look - there are no problems with its content. Please do not flag it for our attention.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;While \u0026lt;em\u0026gt;arbitrary\u0026lt;/em\u0026gt; HTML with only a regex is impossible, it\u0026apos;s sometimes appropriate to use them for parsing a \u0026lt;em\u0026gt;limited, known\u0026lt;/em\u0026gt; set of HTML.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you have a small set of HTML pages that you want to scrape data from and then stuff into a database, regexes might work fine.  For example, I recently wanted to get the names, parties, and districts of Australian federal Representatives, which I got off of the Parliament\u0026apos;s web site.  This was a limited, one-time job.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Regexes worked just fine for me, and were very fast to set up.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I think the flaw here is that HTML is a \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Context-free_grammar\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Chomsky Type 2 grammar (context free grammar)\u0026lt;/a\u0026gt; and a regular expression is a \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Regular_grammar\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Chomsky Type 3 grammar (regular grammar)\u0026lt;/a\u0026gt;. Since a Type 2 grammar is fundamentally more complex than a Type 3 grammar (see the \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Chomsky_hierarchy\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Chomsky hierarchy\u0026lt;/a\u0026gt;), it is \u0026lt;em\u0026gt;mathematically impossible\u0026lt;/em\u0026gt; to parse XML with a regular expression.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;But many will try, and some will even claim success - but until others find the fault and totally mess you up.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Don\u0026apos;t listen to these guys. You totally \u0026lt;strong\u0026gt;can\u0026lt;/strong\u0026gt; parse context-free grammars with regex if you break the task into smaller pieces. You can generate the correct pattern with a script that does each of these in order: \u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Solve the Halting Problem.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Square a circle.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Work out the Traveling Salesman Problem in O(log n) or less. If it\u0026apos;s any more than that, you\u0026apos;ll run out of RAM and the engine will hang.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The pattern will be pretty big, so make sure you have an algorithm that losslessly compresses random data.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Almost there - just divide the whole thing by zero. Easy-peasy.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;I haven\u0026apos;t quite finished the last part myself, but I know I\u0026apos;m getting close. It keeps throwing \u0026lt;code\u0026gt;CthulhuRlyehWgahnaglFhtagnException\u0026lt;/code\u0026gt;s for some reason, so I\u0026apos;m going to port it to VB 6 and use \u0026lt;code\u0026gt;On Error Resume Next\u0026lt;/code\u0026gt;. I\u0026apos;ll update with the code once I investigate this strange door that just opened in the wall. Hmm.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;P.S. Pierre de Fermat also figured out how to do it, but the margin he was writing in wasn\u0026apos;t big enough for the code.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Disclaimer\u0026lt;/strong\u0026gt;: use a parser if you have the option. That said...\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is the regex I use (!) to match HTML tags:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026amp;lt;(?:\u0026quot;[^\u0026quot;]*\u0026quot;[\u0026apos;\u0026quot;]*|\u0026apos;[^\u0026apos;]*\u0026apos;[\u0026apos;\u0026quot;]*|[^\u0026apos;\u0026quot;\u0026amp;gt;])+\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It may not be perfect, but I ran this code through a \u0026lt;em\u0026gt;lot\u0026lt;/em\u0026gt; of HTML. Note that it even catches strange things like \u0026lt;code\u0026gt;\u0026amp;lt;a name=\u0026quot;badgenerator\u0026quot;\u0026quot;\u0026amp;gt;\u0026lt;/code\u0026gt;, which show up on the web.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I guess to make it not match self contained tags, you\u0026apos;d either want to use \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732395#1732395\u0026quot;\u0026gt;Kobi\u0026lt;/a\u0026gt;\u0026apos;s negative look-behind:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026amp;lt;(?:\u0026quot;[^\u0026quot;]*\u0026quot;[\u0026apos;\u0026quot;]*|\u0026apos;[^\u0026apos;]*\u0026apos;[\u0026apos;\u0026quot;]*|[^\u0026apos;\u0026quot;\u0026amp;gt;])+(?\u0026amp;lt;!/\\s*)\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;or just combine if and if not.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;To downvoters:\u0026lt;/strong\u0026gt; This is working code from an actual product. I doubt anyone reading this page will get the impression that it is socially acceptable to use regexes on HTML. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Caveat\u0026lt;/strong\u0026gt;: I should note that this regex still breaks down in the presence of CDATA blocks, comments, and script and style elements. Good news is, you can get rid of those using a regex...  \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are people that will tell you that the Earth is round (or perhaps that the Earth is an oblate spheroid if they want to use strange words). They are lying.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;There are people that will tell you that Regular Expressions shouldn\u0026apos;t be recursive. They are limiting you. They need to subjugate you, and they do it by keeping you in ignorance.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;You can live in their reality or take the red pill.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Like Lord Marshal (is he a relative of the Marshal .NET class?), I have seen the \u0026lt;strike\u0026gt;Underverse\u0026lt;/strike\u0026gt; Stack Based Regex-Verse and returned with \u0026lt;strike\u0026gt;powers\u0026lt;/strike\u0026gt; knowledge you can\u0026apos;t imagine. Yes, I think there were an Old One or two protecting them, but they were watching football on the TV, so it wasn\u0026apos;t difficult.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I think the XML case is quite simple. The RegEx (in the .NET syntax), deflated and coded in base64 to make it easier to comprehend by your feeble mind, should be something like this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;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\n+r/vD34mUADO1P4/AQAA//8=\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The options to set is \u0026lt;code\u0026gt;RegexOptions.ExplicitCapture\u0026lt;/code\u0026gt;. The capture group you are looking for is \u0026lt;code\u0026gt;ELEMENTNAME\u0026lt;/code\u0026gt;. If the capture group \u0026lt;code\u0026gt;ERROR\u0026lt;/code\u0026gt; is not empty then there was a parsing error and the Regex stopped.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If you have problems reconverting it to a human-readable regex, this should help:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-csharp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;FromBase64\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt; str\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;byte\u0026lt;/span\u0026gt;[] byteArray = Convert.FromBase64String(str);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; msIn = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; MemoryStream(byteArray))\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; msOut = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; MemoryStream()) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; ds = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; DeflateStream(msIn, CompressionMode.Decompress)) {\n            ds.CopyTo(msOut);\n        }\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; Encoding.UTF8.GetString(msOut.ToArray());\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;If you are unsure, no, I\u0026apos;m NOT kidding (but perhaps I\u0026apos;m lying). It WILL work. I\u0026apos;ve built tons of unit tests to test it, and I have even used (part of) the \u0026lt;a href=\u0026quot;http://www.w3.org/XML/Test/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;conformance tests\u0026lt;/a\u0026gt;. It\u0026apos;s a tokenizer, not a full-blown parser, so it will only split the XML into its component tokens. It won\u0026apos;t parse/integrate DTDs.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Oh... if you want the source code of the regex, with some auxiliary methods:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://pastebin.com/hzYazFVb\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;regex to tokenize an xml\u0026lt;/a\u0026gt; or \u0026lt;a href=\u0026quot;https://topaz.github.io/paste/#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\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;the full plain regex\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In shell, you can parse \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/HTML\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;HTML\u0026lt;/a\u0026gt; using \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Sed\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;sed\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://sed.sourceforge.net/grabbag/scripts/turing.sed\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Turing.sed\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Write HTML parser (homework)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;???\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Profit!\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Related (why you shouldn\u0026apos;t use regex match):\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://blog.codinghorror.com/if-you-like-regular-expressions-so-much-why-dont-you-marry-them/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;If You Like Regular Expressions So Much, Why Don\u0026apos;t You Marry Them?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://blog.codinghorror.com/regular-expressions-now-you-have-two-problems/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Regular Expressions: Now You Have Two Problems\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://danlec.com/blog/hacking-stackoverflow-com-s-html-sanitizer\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Hacking stackoverflow.com\u0026apos;s HTML sanitizer\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I agree that the right tool to parse XML and \u0026lt;em\u0026gt;especially HTML\u0026lt;/em\u0026gt; is a parser and not a regular expression engine. However, like others have pointed out, sometimes using a regex is quicker, easier, and gets the job done if you know the data format.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Microsoft actually has a section of \u0026lt;a href=\u0026quot;https://docs.microsoft.com/dotnet/standard/base-types/best-practices\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Best Practices for Regular Expressions in the .NET Framework\u0026lt;/a\u0026gt; and specifically talks about \u0026lt;a href=\u0026quot;https://docs.microsoft.com/dotnet/standard/base-types/best-practices#consider-the-input-source\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Consider[ing] the Input Source\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Regular Expressions do have limitations, but have you considered the following?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The .NET framework is unique when it comes to regular expressions in that it supports \u0026lt;a href=\u0026quot;https://docs.microsoft.com/dotnet/standard/base-types/grouping-constructs-in-regular-expressions#balancing_group_definition\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Balancing Group Definitions\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;See \u0026lt;a href=\u0026quot;https://weblogs.asp.net/whaggard/377025\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Matching Balanced Constructs with .NET Regular Expressions\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;See \u0026lt;a href=\u0026quot;https://docs.microsoft.com/archive/blogs/bclteam/net-regular-expressions-regex-and-balanced-matching-ryan-byington\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;.NET Regular Expressions: Regex and Balanced Matching\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;See Microsoft\u0026apos;s docs on \u0026lt;a href=\u0026quot;https://docs.microsoft.com/dotnet/standard/base-types/grouping-constructs-in-regular-expressions#balancing_group_definition\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Balancing Group Definitions\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;For this reason, I believe you CAN parse XML using regular expressions. Note however, that it \u0026lt;strong\u0026gt;must be valid XML\u0026lt;/strong\u0026gt; (\u0026lt;em\u0026gt;browsers are very forgiving of HTML and allow bad XML syntax inside HTML\u0026lt;/em\u0026gt;). This is possible since the \u0026quot;Balancing Group Definition\u0026quot; will allow the regular expression engine to act as a PDA.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Quote from article 1 cited above:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;.NET Regular Expression Engine\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;As described above properly balanced constructs cannot be described by\n  a regular expression. However, the .NET regular expression engine\n  provides a few constructs that allow balanced constructs to be\n  recognized. \u0026lt;/p\u0026gt;\n  \n  \u0026lt;ul\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;code\u0026gt;(?\u0026amp;lt;group\u0026amp;gt;)\u0026lt;/code\u0026gt; - pushes the captured result on the capture stack with\n  the name group.\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;code\u0026gt;(?\u0026amp;lt;-group\u0026amp;gt;)\u0026lt;/code\u0026gt; - pops the top most capture with the name group off the\n  capture stack.\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;code\u0026gt;(?(group)yes|no)\u0026lt;/code\u0026gt; - matches the yes part if there exists a group\n  with the name group otherwise matches no part.\u0026lt;/li\u0026gt;\n  \u0026lt;/ul\u0026gt;\n  \n  \u0026lt;p\u0026gt;These constructs allow for a .NET regular expression to emulate a\n  restricted PDA by essentially allowing simple versions of the stack\n  operations: push, pop and empty. The simple operations are pretty much\n  equivalent to increment, decrement and compare to zero respectively.\n  This allows for the .NET regular expression engine to recognize a\n  subset of the context-free languages, in particular the ones that only\n  require a simple counter. This in turn allows for the non-traditional\n  .NET regular expressions to recognize individual properly balanced\n  constructs.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Consider the following regular expression:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-none s-code-block\u0026quot;\u0026gt;\u0026lt;code\u0026gt;(?=\u0026amp;lt;ul\\s+id=\u0026quot;matchMe\u0026quot;\\s+type=\u0026quot;square\u0026quot;\\s*\u0026amp;gt;)\n(?\u0026amp;gt;\n   \u0026amp;lt;!-- .*? --\u0026amp;gt;                  |\n   \u0026amp;lt;[^\u0026amp;gt;]*/\u0026amp;gt;                      |\n   (?\u0026amp;lt;opentag\u0026amp;gt;\u0026amp;lt;(?!/)[^\u0026amp;gt;]*[^/]\u0026amp;gt;)  |\n   (?\u0026amp;lt;-opentag\u0026amp;gt;\u0026amp;lt;/[^\u0026amp;gt;]*[^/]\u0026amp;gt;)     |\n   [^\u0026amp;lt;\u0026amp;gt;]*\n)*\n(?(opentag)(?!))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Use the flags:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Singleline\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;IgnorePatternWhitespace (not necessary if you collapse regex and remove all whitespace)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;IgnoreCase (not necessary)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;h2\u0026gt;Regular Expression Explained (inline)\u0026lt;/h2\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-none s-code-block\u0026quot;\u0026gt;\u0026lt;code\u0026gt;(?=\u0026amp;lt;ul\\s+id=\u0026quot;matchMe\u0026quot;\\s+type=\u0026quot;square\u0026quot;\\s*\u0026amp;gt;) # match start with \u0026amp;lt;ul id=\u0026quot;matchMe\u0026quot;...\n(?\u0026amp;gt;                                        # atomic group / don\u0026apos;t backtrack (faster)\n   \u0026amp;lt;!-- .*? --\u0026amp;gt;                 |          # match xml / html comment\n   \u0026amp;lt;[^\u0026amp;gt;]*/\u0026amp;gt;                     |          # self closing tag\n   (?\u0026amp;lt;opentag\u0026amp;gt;\u0026amp;lt;(?!/)[^\u0026amp;gt;]*[^/]\u0026amp;gt;) |          # push opening xml tag\n   (?\u0026amp;lt;-opentag\u0026amp;gt;\u0026amp;lt;/[^\u0026amp;gt;]*[^/]\u0026amp;gt;)    |          # pop closing xml tag\n   [^\u0026amp;lt;\u0026amp;gt;]*                                  # something between tags\n)*                                         # match as many xml tags as possible\n(?(opentag)(?!))                           # ensure no \u0026apos;opentag\u0026apos; groups are on stack\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You can try this at \u0026lt;a href=\u0026quot;http://derekslager.com/blog/posts/2007/09/a-better-dotnet-regular-expression-tester.ashx\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;A Better .NET Regular Expression Tester\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I used the sample source of:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;html\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;body\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;br\u0026lt;/span\u0026gt; /\u0026amp;gt;\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;matchMe\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;square\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;stuff...\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;more stuff\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n          \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n               \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;span\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;still more\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;span\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n               \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n                    \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;Another \u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026amp;amp;gt;\u0026lt;/span\u0026gt;ul\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026amp;amp;lt;\u0026lt;/span\u0026gt;, oh my!\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n                    \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;...\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n               \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n          \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;body\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;html\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This found the match:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;   \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;matchMe\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;square\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;stuff...\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;more stuff\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n          \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n               \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;span\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;still more\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;span\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n               \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n                    \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;Another \u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026amp;amp;gt;\u0026lt;/span\u0026gt;ul\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026amp;amp;lt;\u0026lt;/span\u0026gt;, oh my!\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n                    \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;...\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n               \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n          \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;although it actually came out like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;matchMe\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;square\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;           \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;stuff...\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;           \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;more stuff\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;           \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;               \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;                    \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;span\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;still more\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;span\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;                    \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;                         \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;Another \u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026amp;amp;gt;\u0026lt;/span\u0026gt;ul\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026amp;amp;lt;\u0026lt;/span\u0026gt;, oh my!\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;                         \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;...\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;                    \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;               \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;           \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;li\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;        \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;ul\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Lastly, I really enjoyed Jeff Atwood\u0026apos;s article:  \u0026lt;a href=\u0026quot;https://blog.codinghorror.com/parsing-html-the-cthulhu-way/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Parsing Html The Cthulhu Way\u0026lt;/a\u0026gt;. Funny enough, it cites the answer to this question that currently has over 4k votes.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I suggest using \u0026lt;a href=\u0026quot;http://querypath.org/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;QueryPath\u0026lt;/a\u0026gt; for parsing XML and HTML in PHP.  It\u0026apos;s basically much the same syntax as jQuery, only it\u0026apos;s on the server side.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;While the answers that you can\u0026apos;t parse HTML with regexes are correct, they don\u0026apos;t apply here. The OP just wants to parse one HTML tag with regexes, and that is something that can be done with a regular expression.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The suggested regex is wrong, though:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026amp;lt;([a-z]+) *[^/]*?\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If you add something to the regex, by backtracking it can be forced to match silly things like \u0026lt;code\u0026gt;\u0026amp;lt;a \u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;[^/]\u0026lt;/code\u0026gt; is too permissive. Also note that \u0026lt;code\u0026gt;\u0026amp;lt;space\u0026amp;gt;*[^/]*\u0026lt;/code\u0026gt; is redundant, because the \u0026lt;code\u0026gt;[^/]*\u0026lt;/code\u0026gt; can also match spaces.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;My suggestion would be\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026amp;lt;([a-z]+)[^\u0026amp;gt;]*(?\u0026amp;lt;!/)\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Where \u0026lt;code\u0026gt;(?\u0026amp;lt;! ... )\u0026lt;/code\u0026gt; is (in Perl regexes) the negative look-behind. It reads \u0026quot;a \u0026amp;lt;, then a word, then anything that\u0026apos;s not a \u0026amp;gt;, the last of which may not be a /, followed by \u0026amp;gt;\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note that this allows things like \u0026lt;code\u0026gt;\u0026amp;lt;a/ \u0026amp;gt;\u0026lt;/code\u0026gt; (just like the original regex), so if you want something more restrictive, you need to build a regex to match attribute pairs separated by spaces.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Try:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026amp;lt;([^\\s]+)(\\s[^\u0026amp;gt;]*?)?(?\u0026amp;lt;!/)\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It is similar to yours, but the last \u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt; must not be after a slash, and also accepts \u0026lt;code\u0026gt;h1\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Sun Tzu, an ancient Chinese strategist, general, and philosopher, said:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;It is said that if you know your enemies and know yourself, you can win a hundred battles without a single loss.\n  If you only know yourself, but not your opponent, you may win or may lose.\n  If you know neither yourself nor your enemy, you will always endanger yourself.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;In this case your enemy is HTML and you are either yourself or regex.  You might even be Perl with irregular regex. Know HTML.  Know yourself.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I have composed a haiku describing the nature of HTML.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;HTML has\ncomplexity exceeding\nregular language.\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I have also composed a haiku describing the nature of regex in Perl.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;The regex you seek\nis defined within the phrase\n\u0026amp;lt;([a-zA-Z]+)(?:[^\u0026amp;gt;]*[^/]*)?\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;lt;?php\n$selfClosing = explode(\u0026apos;,\u0026apos;, \u0026apos;area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed\u0026apos;);\n\n$html = \u0026apos;\n\u0026amp;lt;p\u0026amp;gt;\u0026amp;lt;a href=\u0026quot;#\u0026quot;\u0026amp;gt;foo\u0026amp;lt;/a\u0026amp;gt;\u0026amp;lt;/p\u0026amp;gt;\n\u0026amp;lt;hr/\u0026amp;gt;\n\u0026amp;lt;br/\u0026amp;gt;\n\u0026amp;lt;div\u0026amp;gt;name\u0026amp;lt;/div\u0026amp;gt;\u0026apos;;\n\n$dom = new DOMDocument();\n$dom-\u0026amp;gt;loadHTML($html);\n$els = $dom-\u0026amp;gt;getElementsByTagName(\u0026apos;*\u0026apos;);\nforeach ( $els as $el ) {\n    $nodeName = strtolower($el-\u0026amp;gt;nodeName);\n    if ( !in_array( $nodeName, $selfClosing ) ) {\n        var_dump( $nodeName );\n    }\n}\n\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Output:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;string(4) \u0026quot;html\u0026quot;\nstring(4) \u0026quot;body\u0026quot;\nstring(1) \u0026quot;p\u0026quot;\nstring(1) \u0026quot;a\u0026quot;\nstring(3) \u0026quot;div\u0026quot;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Basically just define the element node names that are self closing, load the whole html string into a DOM library, grab all elements, loop through and filter out ones which aren\u0026apos;t self closing and operate on them.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;m sure you already know by now that you shouldn\u0026apos;t use regex for this purpose.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I don\u0026apos;t know your exact need for this, but if you are also using .NET, couldn\u0026apos;t you use \u0026lt;a href=\u0026quot;http://www.codeplex.com/htmlagilitypack\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Html Agility Pack\u0026lt;/a\u0026gt;?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Excerpt:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;It is a .NET code library that allows\n  you to parse \u0026quot;out of the web\u0026quot; HTML\n  files. The parser is very tolerant\n  with \u0026quot;real world\u0026quot; malformed HTML.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You want the first \u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt; not preceded by a \u0026lt;code\u0026gt;/\u0026lt;/code\u0026gt;.  Look \u0026lt;a href=\u0026quot;http://www.regular-expressions.info/lookaround.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt; for details on how to do that.  It\u0026apos;s referred to as negative lookbehind.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However, a naïve implementation of that will end up matching \u0026lt;code\u0026gt;\u0026amp;lt;bar/\u0026amp;gt;\u0026amp;lt;/foo\u0026amp;gt;\u0026lt;/code\u0026gt; in this example document\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;/\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Can you provide a little more information on the problem you\u0026apos;re trying to solve?  Are you iterating through tags programatically?\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The W3C explains parsing in a pseudo regexp form:\u0026lt;br\u0026gt;\n\u0026lt;a href=\u0026quot;http://www.w3.org/TR/REC-xml-names/#ns-using\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;W3C Link\u0026lt;/a\u0026gt;  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Follow the var links for \u0026lt;code\u0026gt;QName\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;S\u0026lt;/code\u0026gt;, and \u0026lt;code\u0026gt;Attribute\u0026lt;/code\u0026gt; to get a clearer picture.\u0026lt;br\u0026gt;\nBased on that you can create a pretty good regexp to handle things like stripping tags.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you need this for PHP:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;a href=\u0026quot;http://www.php.net/manual/en/function.dom-import-simplexml.php\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;PHP DOM\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;http://php.net/manual/en/class.domdocument.php\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;functions\u0026lt;/a\u0026gt; won\u0026apos;t work properly unless it is properly formatted XML. No matter how much better their use is for the rest of mankind.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://simplehtmldom.sourceforge.net/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;simplehtmldom\u0026lt;/a\u0026gt; is good, but I found it a bit buggy, and it is is quite memory heavy [Will crash on large pages.]\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I have never used \u0026lt;a href=\u0026quot;http://querypath.org/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;querypath\u0026lt;/a\u0026gt;, so can\u0026apos;t comment on its usefulness. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Another one to try is my \u0026lt;a href=\u0026quot;http://github.com/siteroller/domparser\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;DOMParser\u0026lt;/a\u0026gt; which is very light on resources and I\u0026apos;ve been using happily for a while. Simple to learn \u0026amp;amp; powerful.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For Python and Java, similar links were posted.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For the downvoters - I only wrote my class when the XML parsers proved unable to withstand real use. Religious downvoting just prevents useful answers from being posted - keep things within perspective of the question, please.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here\u0026apos;s the solution:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;lt;?php\n// here\u0026apos;s the pattern:\n$pattern = \u0026apos;/\u0026amp;lt;(\\w+)(\\s+(\\w+)\\s*\\=\\s*(\\\u0026apos;|\u0026quot;)(.*?)\\\\4\\s*)*\\s*(\\/\u0026amp;gt;|\u0026amp;gt;)/\u0026apos;;\n\n// a string to parse:\n$string = \u0026apos;Hello, try clicking \u0026amp;lt;a href=\u0026quot;#paragraph\u0026quot;\u0026amp;gt;here\u0026amp;lt;/a\u0026amp;gt;\n    \u0026amp;lt;br/\u0026amp;gt;and check out.\u0026amp;lt;hr /\u0026amp;gt;\n    \u0026amp;lt;h2\u0026amp;gt;title\u0026amp;lt;/h2\u0026amp;gt;\n    \u0026amp;lt;a name =\u0026quot;paragraph\u0026quot; rel= \u0026quot;I\\\u0026apos;m an anchor\u0026quot;\u0026amp;gt;\u0026amp;lt;/a\u0026amp;gt;\n    Fine, \u0026amp;lt;span title=\\\u0026apos;highlight the \u0026quot;punch\u0026quot;\\\u0026apos;\u0026amp;gt;thanks\u0026amp;lt;span\u0026amp;gt;.\n    \u0026amp;lt;div class = \u0026quot;clear\u0026quot;\u0026amp;gt;\u0026amp;lt;/div\u0026amp;gt;\n    \u0026amp;lt;br\u0026amp;gt;\u0026apos;;\n\n// let\u0026apos;s get the occurrences:\npreg_match_all($pattern, $string, $matches, PREG_PATTERN_ORDER);\n\n// print the result:\nprint_r($matches[0]);\n?\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;To test it deeply, I entered in the string auto-closing tags like:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026amp;lt;hr /\u0026amp;gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026amp;lt;br/\u0026amp;gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026amp;lt;br\u0026amp;gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;I also entered tags with:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;one attribute\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;more than one attribute\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;attributes which value is bound either into \u0026lt;strong\u0026gt;single quotes\u0026lt;/strong\u0026gt; or into \u0026lt;strong\u0026gt;double quotes\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;attributes containing single quotes when the delimiter is a double quote and vice versa\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026quot;unpretty\u0026quot; attributes with a space before the \u0026quot;=\u0026quot; symbol, after it and both before and after it.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;Should you find something which does not work in the proof of concept above, I am available in analyzing the code to improve my skills.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026amp;lt;EDIT\u0026amp;gt;\u0026lt;/strong\u0026gt;\nI forgot that the question from the user was to avoid the parsing of self-closing tags.\nIn this case the pattern is simpler, turning into this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;$pattern = \u0026apos;/\u0026amp;lt;(\\w+)(\\s+(\\w+)\\s*\\=\\s*(\\\u0026apos;|\u0026quot;)(.*?)\\\\4\\s*)*\\s*\u0026amp;gt;/\u0026apos;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The user @ridgerunner noticed that the pattern does not allow \u0026lt;strong\u0026gt;unquoted attributes\u0026lt;/strong\u0026gt; or \u0026lt;strong\u0026gt;attributes with no value\u0026lt;/strong\u0026gt;. In this case a fine tuning brings us the following pattern:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;$pattern = \u0026apos;/\u0026amp;lt;(\\w+)(\\s+(\\w+)(\\s*\\=\\s*(\\\u0026apos;|\u0026quot;|)(.*?)\\\\5\\s*)?)*\\s*\u0026amp;gt;/\u0026apos;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026amp;lt;/EDIT\u0026amp;gt;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;h1\u0026gt;Understanding the pattern\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;If someone is interested in learning more about the pattern, I provide some line:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;the first sub-expression (\\w+) matches the tag name\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;the second sub-expression contains the pattern of an attribute. It is composed by:\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;one or more whitespaces \\s+\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;the name of the attribute (\\w+)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;zero or more whitespaces \\s* (it is possible or not, leaving blanks here)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;the \u0026quot;=\u0026quot; symbol\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;again, zero or more whitespaces\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;the delimiter of the attribute value, a single or double quote (\u0026apos;|\u0026quot;). In the pattern, the single quote is escaped because it coincides with the PHP string delimiter. This sub-expression is captured with the parentheses so it can be referenced again to parse the closure of the attribute, that\u0026apos;s why it is very important.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;the value of the attribute, matched by \u0026lt;em\u0026gt;almost\u0026lt;/em\u0026gt; anything: (.*?); in this specific syntax, using the \u0026lt;strong\u0026gt;greedy match\u0026lt;/strong\u0026gt; (the question mark after the asterisk) the RegExp engine enables a \u0026quot;look-ahead\u0026quot;-like operator, which matches anything but what follows this sub-expression\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;here comes the fun: the \\4 part is a \u0026lt;strong\u0026gt;backreference operator\u0026lt;/strong\u0026gt;, which refers to a sub-expression defined before in the pattern, in this case, I am referring to the fourth sub-expression, which is the first attribute delimiter found\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;zero or more whitespaces \\s*\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;the attribute sub-expression ends here, with the specification of zero or more possible occurrences, given by the asterisk.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Then, since a tag may end with a whitespace before the \u0026quot;\u0026amp;gt;\u0026quot; symbol, zero or more whitespaces are matched with the \\s* subpattern.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The tag to match may end with a simple \u0026quot;\u0026amp;gt;\u0026quot; symbol, or a possible XHTML closure, which makes use of the slash before it: (/\u0026amp;gt;|\u0026amp;gt;). The slash is, of course, escaped since it coincides with the regular expression delimiter.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;Small tip: to better analyze this code it is necessary looking at the source code generated since I did not provide any HTML special characters escaping.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Whenever I need to quickly extract something from an HTML document, I use Tidy to convert it to XML and then use XPath or XSLT to get what I need.\nIn your case, something like this: \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;//p/a[@href=\u0026apos;foo\u0026apos;]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I used a open source tool called \u0026lt;a href=\u0026quot;http://htmlparser.sourceforge.net/\u0026quot;\u0026gt;HTMLParser\u0026lt;/a\u0026gt; before. It\u0026apos;s designed to parse HTML in various ways and serves the purpose quite well. It can parse HTML as different treenode and you can easily use its API to get attributes out of the node. Check it out and see if this can help you.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I like to parse HTML with regular expressions. I don\u0026apos;t attempt to parse idiot HTML that is deliberately broken. This code is my main parser (Perl edition):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;$_ = join \u0026quot;\u0026quot;,\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;STDIN\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;; tr/\\n\\r \\t/ /s; s/\u0026amp;lt;/\\n\u0026amp;lt;/g; s/\u0026amp;gt;/\u0026amp;gt;\\n/g; s/\\n ?\\n/\\n/g;\ns/^ ?\\n//s; s/ $//s; print\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;It\u0026apos;s called \u0026lt;em\u0026gt;htmlsplit\u0026lt;/em\u0026gt;, splits the HTML into lines, with one tag or chunk of text on each line. The lines can then be processed further with other text tools and scripts, such as \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Grep\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;grep\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Sed\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;sed\u0026lt;/a\u0026gt;, Perl, etc. I\u0026apos;m not even joking :) Enjoy.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;It is simple enough to rejig my slurp-everything-first Perl script into a nice streaming thing, if you wish to process enormous web pages. But it\u0026apos;s not really necessary.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://sam.nipl.net/code/nipl-tools/bin/htmlsplit\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;HTML Split\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;Some better regular expressions:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;/(\u0026amp;lt;.*?\u0026amp;gt;|[^\u0026amp;lt;]+)\\s*/g    # Get tags and text\n/(\\w+)=\u0026quot;(.*?)\u0026quot;/g       # Get attibutes\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;They are good for XML / XHTML.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;With minor variations, it can cope with messy HTML... or convert the HTML -\u0026amp;gt; XHTML first.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;The best way to write regular expressions is in the \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Lex_%28software%29\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Lex\u0026lt;/a\u0026gt; / \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Yacc\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Yacc\u0026lt;/a\u0026gt; style, not as opaque one-liners or commented multi-line monstrosities. I didn\u0026apos;t do that here, yet; these ones barely need it.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are some nice regexes for replacing HTML with BBCode \u0026lt;a href=\u0026quot;http://www.garyshood.com/htmltobb/source.txt\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt;. For all you nay-sayers, note that he\u0026apos;s not trying to fully parse HTML, just to sanitize it. He can probably afford to kill off tags that his simple \u0026quot;parser\u0026quot; can\u0026apos;t understand.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;$store =~ s/http:/http:\\/\\//gi;\n$store =~ s/https:/https:\\/\\//gi;\n$baseurl = $store;\n\nif (!$query-\u0026amp;gt;param(\u0026quot;ascii\u0026quot;)) {\n    $html =~ s/\\s\\s+/\\n/gi;\n    $html =~ s/\u0026amp;lt;pre(.*?)\u0026amp;gt;(.*?)\u0026amp;lt;\\/pre\u0026amp;gt;/\\[code]$2\\[\\/code]/sgmi;\n}\n\n$html =~ s/\\n//gi;\n$html =~ s/\\r\\r//gi;\n$html =~ s/$baseurl//gi;\n$html =~ s/\u0026amp;lt;h[1-7](.*?)\u0026amp;gt;(.*?)\u0026amp;lt;\\/h[1-7]\u0026amp;gt;/\\n\\[b]$2\\[\\/b]\\n/sgmi;\n$html =~ s/\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;p\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;/\\n\\n/gi;\n$html =~ s/\u0026amp;lt;br(.*?)\u0026amp;gt;/\\n/gi;\n$html =~ s/\u0026amp;lt;textarea(.*?)\u0026amp;gt;(.*?)\u0026amp;lt;\\/textarea\u0026amp;gt;/\\[code]$2\\[\\/code]/sgmi;\n$html =~ s/\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;(.*?)\u0026amp;lt;\\/b\u0026amp;gt;/\\[b]$1\\[\\/b]/gi;\n$html =~ s/\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;i\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;(.*?)\u0026amp;lt;\\/i\u0026amp;gt;/\\[i]$1\\[\\/i]/gi;\n$html =~ s/\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;u\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;(.*?)\u0026amp;lt;\\/u\u0026amp;gt;/\\[u]$1\\[\\/u]/gi;\n$html =~ s/\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;em\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;(.*?)\u0026amp;lt;\\/em\u0026amp;gt;/\\[i]$1\\[\\/i]/gi;\n$html =~ s/\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;strong\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;(.*?)\u0026amp;lt;\\/strong\u0026amp;gt;/\\[b]$1\\[\\/b]/gi;\n$html =~ s/\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;cite\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;(.*?)\u0026amp;lt;\\/cite\u0026amp;gt;/\\[i]$1\\[\\/i]/gi;\n$html =~ s/\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;font\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;color\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;(.*?)\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;(.*?)\u0026amp;lt;\\/font\u0026amp;gt;/\\[color=$1]$2\\[\\/color]/sgmi;\n$html =~ s/\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;font\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;color\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;(.*?)\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;(.*?)\u0026amp;lt;\\/font\u0026amp;gt;/\\[color=$1]$2\\[\\/color]/sgmi;\n$html =~ s/\u0026amp;lt;link(.*?)\u0026amp;gt;//gi;\n$html =~ s/\u0026amp;lt;li(.*?)\u0026amp;gt;(.*?)\u0026amp;lt;\\/li\u0026amp;gt;/\\[\\*]$2/gi;\n$html =~ s/\u0026amp;lt;ul(.*?)\u0026amp;gt;/\\[list]/gi;\n$html =~ s/\u0026amp;lt;\\/ul\u0026amp;gt;/\\[\\/list]/gi;\n$html =~ s/\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;div\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;/\\n/gi;\n$html =~ s/\u0026amp;lt;\\/div\u0026amp;gt;/\\n/gi;\n$html =~ s/\u0026amp;lt;td(.*?)\u0026amp;gt;/ /gi;\n$html =~ s/\u0026amp;lt;tr(.*?)\u0026amp;gt;/\\n/gi;\n\n$html =~ s/\u0026amp;lt;img(.*?)src=\u0026quot;(.*?)\u0026quot;(.*?)\u0026amp;gt;/\\[img]$baseurl\\/$2\\[\\/img]/gi;\n$html =~ s/\u0026amp;lt;a(.*?)href=\u0026quot;(.*?)\u0026quot;(.*?)\u0026amp;gt;(.*?)\u0026amp;lt;\\/a\u0026amp;gt;/\\[url=$baseurl\\/$2]$4\\[\\/url]/gi;\n$html =~ s/\\[url=$baseurl\\/http:\\/\\/(.*?)](.*?)\\[\\/url]/\\[url=http:\\/\\/$1]$2\\[\\/url]/gi;\n$html =~ s/\\[img]$baseurl\\/http:\\/\\/(.*?)\\[\\/img]/\\[img]http:\\/\\/$1\\[\\/img]/gi;\n\n$html =~ s/\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;head\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;(.*?)\u0026amp;lt;\\/head\u0026amp;gt;//sgmi;\n$html =~ s/\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;(.*?)\u0026amp;lt;\\/object\u0026amp;gt;//sgmi;\n$html =~ s/\u0026amp;lt;script(.*?)\u0026amp;gt;(.*?)\u0026amp;lt;\\/script\u0026amp;gt;//sgmi;\n$html =~ s/\u0026amp;lt;style(.*?)\u0026amp;gt;(.*?)\u0026amp;lt;\\/style\u0026amp;gt;//sgmi;\n$html =~ s/\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;title\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;(.*?)\u0026amp;lt;\\/title\u0026amp;gt;//sgmi;\n$html =~ s/\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026amp;lt;!--(.*?)--\u0026amp;gt;\u0026lt;/span\u0026gt;/\\n/sgmi;\n\n$html =~ s/\\/\\//\\//gi;\n$html =~ s/http:\\//http:\\/\\//gi;\n$html =~ s/https:\\//https:\\/\\//gi;\n\n$html =~ s/\u0026amp;lt;(?:[^\u0026amp;gt;\u0026apos;\u0026quot;]*|([\u0026apos;\u0026quot;]).*?\\1)*\u0026amp;gt;//gsi;\n$html =~ s/\\r\\r//gi;\n$html =~ s/\\[img]\\//\\[img]/gi;\n$html =~ s/\\[url=\\//\\[url=/gi;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;About the question of the regular expression methods to parse (x)HTML, the answer to all of the ones who spoke about some limits is: you have not been trained enough to rule the force of this powerful weapon, since \u0026lt;strong\u0026gt;nobody\u0026lt;/strong\u0026gt; here spoke about \u0026lt;strong\u0026gt;recursion\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A regular expression-agnostic colleague notified me this discussion, which is not certainly the first on the web about this old and hot topic.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;After reading some posts, the first thing I did was looking for the \u0026quot;?R\u0026quot; string in this thread. The second was to search about \u0026quot;recursion\u0026quot;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;No, holy cow, no match found. Since nobody mentioned the main mechanism a parser is built onto, I was soon aware that nobody got the point.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If an (x)HTML parser needs recursion, a regular expression parser without recursion is not enough for the purpose. It\u0026apos;s a simple construct.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The \u0026lt;strong\u0026gt;black art of regular expressions is hard to master\u0026lt;/strong\u0026gt;, so maybe there are further possibilities we left out while trying and testing our personal solution to capture the whole web in one hand... Well, I am sure about it :)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Here\u0026apos;s the magic pattern:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;$pattern = \u0026quot;/\u0026amp;lt;([\\w]+)([^\u0026amp;gt;]*?)(([\\s]*\\/\u0026amp;gt;)|(\u0026amp;gt;((([^\u0026amp;lt;]*?|\u0026amp;lt;\\!\\-\\-.*?\\-\\-\u0026amp;gt;)|(?R))*)\u0026amp;lt;\\/\\\\1[\\s]*\u0026amp;gt;))/s\u0026quot;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Just try it. It\u0026apos;s written as a PHP string, so the \u0026quot;s\u0026quot; modifier makes classes include newlines.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Here\u0026apos;s a \u0026lt;strong\u0026gt;sample note on the PHP manual\u0026lt;/strong\u0026gt; I wrote in January: \u0026lt;a href=\u0026quot;http://php.net/manual/en/regexp.reference.recursive.php\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Reference\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;(Take care. In that note I wrongly used the \u0026quot;m\u0026quot; modifier; it should be erased, notwithstanding it is discarded by the regular expression engine, since no \u0026lt;code\u0026gt;^\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;$\u0026lt;/code\u0026gt; anchoring was used).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Now, we could speak about the limits of this method from a more informed point of view:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;according to the specific implementation of the regular expression engine, recursion may have a limit in the \u0026lt;strong\u0026gt;number of nested patterns parsed\u0026lt;/strong\u0026gt;, but it depends on the language used\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;although corrupted, (x)HTML does not drive into severe errors. It is not \u0026lt;em\u0026gt;sanitized\u0026lt;/em\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;Anyhow, it is only a regular expression pattern, but it discloses the possibility to develop of a lot of powerful implementations.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I wrote this pattern to power the \u0026lt;em\u0026gt;recursive descent parser\u0026lt;/em\u0026gt; of a template engine I built in my framework, and performances are really great, both in execution times or in memory usage (nothing to do with other template engines which use the same syntax).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026amp;lt;\\s*(\\w+)[^/\u0026amp;gt;]*\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The parts explained:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;\u0026amp;lt;\u0026lt;/code\u0026gt;: Starting character\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;\\s*\u0026lt;/code\u0026gt;: It may have whitespaces before the tag name (ugly, but possible).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;(\\w+)\u0026lt;/code\u0026gt;: tags can contain letters and numbers (h1). Well, \u0026lt;code\u0026gt;\\w\u0026lt;/code\u0026gt; also matches \u0026apos;_\u0026apos;, but it does not hurt I guess. If curious, use ([a-zA-Z0-9]+) instead.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;[^/\u0026amp;gt;]*\u0026lt;/code\u0026gt;: Anything except \u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;/\u0026lt;/code\u0026gt; until closing \u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt;: Closing \u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;UNRELATED\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;And to the fellows, who underestimate regular expressions, saying they are only as powerful as regular languages:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;a\u0026lt;sup\u0026gt;n\u0026lt;/sup\u0026gt;ba\u0026lt;sup\u0026gt;n\u0026lt;/sup\u0026gt;ba\u0026lt;sup\u0026gt;n\u0026lt;/sup\u0026gt; which is not regular and not even context free, can be matched with \u0026lt;code\u0026gt;^(a+)b\\1b\\1$\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Backreferencing \u0026lt;a href=\u0026quot;http://en.wiktionary.org/wiki/FTW\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;FTW\u0026lt;/a\u0026gt;!\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As many people have already pointed out, HTML is not a regular language which can make it very difficult to parse. My solution to this is to turn it into a regular language using a tidy program and then to use an XML parser to consume the results. There are a lot of good options for this. My program is written using Java with the \u0026lt;a href=\u0026quot;http://jtidy.sourceforge.net/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;jtidy\u0026lt;/a\u0026gt; library to turn the HTML into XML and then Jaxen to xpath into the result.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you\u0026apos;re simply trying to find those tags (without ambitions of parsing) try this regular expression:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;/\u0026amp;lt;[^/]*?\u0026amp;gt;/g\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I wrote it in 30 seconds, and tested here:\n\u0026lt;a href=\u0026quot;http://gskinner.com/RegExr/\u0026quot;\u0026gt;http://gskinner.com/RegExr/\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It matches the types of tags you mentioned, while ignoring the types you said you wanted to ignore.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It seems to me you\u0026apos;re trying to match tags without a \u0026quot;/\u0026quot; at the end. Try this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026amp;lt;([a-zA-Z][a-zA-Z0-9]*)[^\u0026amp;gt;]*(?\u0026amp;lt;!/)\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It\u0026apos;s true that when programming it\u0026apos;s usually best to use dedicated parsers and APIs instead of regular expressions when dealing with HTML, especially if accuracy is paramount (e.g., if your processing might have security implications). However, I dont ascribe to a dogmatic view that XML-style markup should never be processed with regular expressions. There are cases when regular expressions are a great tool for the job, such as when making one-time edits in a text editor, fixing broken XML files, or dealing with file formats that look like but arent quite XML. There are some issues to be aware of, but they\u0026apos;re not insurmountable or even necessarily relevant.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A simple regex like \u0026lt;code\u0026gt;\u0026amp;lt;([^\u0026amp;gt;\u0026quot;\u0026apos;]|\u0026quot;[^\u0026quot;]*\u0026quot;|\u0026apos;[^\u0026apos;]*\u0026apos;)*\u0026amp;gt;\u0026lt;/code\u0026gt; is usually good enough, in cases such as those I just mentioned. It\u0026apos;s a naive solution, all things considered, but it does correctly allow unencoded \u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt; symbols in attribute values. If you\u0026apos;re looking for, e.g., a \u0026lt;code\u0026gt;table\u0026lt;/code\u0026gt; tag, you could adapt it as \u0026lt;code\u0026gt;\u0026amp;lt;/?table\\b([^\u0026amp;gt;\u0026quot;\u0026apos;]|\u0026quot;[^\u0026quot;]*\u0026quot;|\u0026apos;[^\u0026apos;]*\u0026apos;)*\u0026amp;gt;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Just to give a sense of what a more \u0026quot;advanced\u0026quot; HTML regex would look like, the following does a fairly respectable job of emulating real-world browser behavior and the HTML5 parsing algorithm:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026amp;lt;/?([A-Za-z][^\\s\u0026amp;gt;/]*)(?:=\\s*(?:\u0026quot;[^\u0026quot;]*\u0026quot;|\u0026apos;[^\u0026apos;]*\u0026apos;|[^\\s\u0026amp;gt;]+)|[^\u0026amp;gt;])*(?:\u0026amp;gt;|$)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The following matches a fairly strict definition of XML tags (although it doesn\u0026apos;t account for the full set of Unicode characters allowed in XML names):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026amp;lt;(?:([_:A-Z][-.:\\w]*)(?:\\s+[_:A-Z][-.:\\w]*\\s*=\\s*(?:\u0026quot;[^\u0026quot;]*\u0026quot;|\u0026apos;[^\u0026apos;]*\u0026apos;))*\\s*/?|/([_:A-Z][-.:\\w]*)\\s*)\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Granted, these don\u0026apos;t account for surrounding context and a few edge cases, but even such things could be dealt with if you really wanted to (e.g., by searching between the matches of another regex).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;At the end of the day, use the most appropriate tool for the job, even in the cases when that tool happens to be a regex.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Although it\u0026apos;s not suitable and effective to use regular expressions for that purpose sometimes regular expressions provide quick solutions for simple match problems and in my view it\u0026apos;s not that horrbile to use regular expressions for trivial works. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There is a \u0026lt;a href=\u0026quot;http://blog.stevenlevithan.com/archives/match-innermost-html-element\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;definitive blog post\u0026lt;/a\u0026gt; about matching innermost HTML elements written by Steven Levithan.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you only want the tag names, it should be possible to do this via a regular expression.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026amp;lt;([a-zA-Z]+)(?:[^\u0026amp;gt;]*[^/] *)?\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;should do what you need. But I think the solution of \u0026quot;moritz\u0026quot; is already fine. I didn\u0026apos;t see it in the beginning.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For all downvoters: In some cases it just makes sense to use a regular expression, because it can be the easiest and quickest solution. I agree that in general you should not parse HTML with regular expressions.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;But regular expressions can be a very powerful tool when you have a subset of HTML where you know the format and you just want to extract some values. I did that hundreds of times and almost always achieved what I wanted.\u0026lt;/p\u0026gt;\n    "]},"randomTags":[{"name":"function-pointers","slug":"function-pointers"},{"name":"overflow","slug":"overflow"},{"name":"system-calls","slug":"system-calls"},{"name":"sed","slug":"sed"},{"name":"http-headers","slug":"http-headers"},{"name":"namespaces","slug":"namespaces"},{"name":"prototype","slug":"prototype"},{"name":"combinations","slug":"combinations"},{"name":"c-strings","slug":"c-strings"},{"name":"ajax","slug":"ajax"},{"name":"postgresql","slug":"postgresql"},{"name":"spring-mvc","slug":"spring-mvc"},{"name":"split","slug":"split"},{"name":"typescript","slug":"typescript"},{"name":"openssl","slug":"openssl"},{"name":"substring","slug":"substring"},{"name":"iframe","slug":"iframe"},{"name":"object","slug":"object"},{"name":"git-commit","slug":"git-commit"},{"name":"c-preprocessor","slug":"c-preprocessor"}]},"__N_SSG":true},"page":"/questions/tag/[slug]/page/[page]","query":{"slug":"xhtml","page":"1"},"buildId":"Zo3C7AOWQzKM9qqyzx2hf","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>