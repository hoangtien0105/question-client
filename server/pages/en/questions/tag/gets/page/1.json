{"pageProps":{"data":{"count":1,"rows":[{"id":86,"title":"Why is the gets function so dangerous that it should not be used?","slug":"why-is-the-gets-function-so-dangerous-that-it-should-not-be-used-1657384544362","postType":"QUESTION","createdAt":"2022-07-09T16:35:44.000Z","updatedAt":"2022-07-09T16:35:44.000Z","tags":[{"id":319,"name":"gets","slug":"gets","createdAt":"2022-07-09T16:35:44.000Z","updatedAt":"2022-07-09T16:35:44.000Z","Questions_Tags":{"questionId":86,"tagId":319}}]}]},"slug":"gets","page":"1","answers":{"86":["\n&lt;p&gt;In order to use &lt;code&gt;gets&lt;/code&gt; safely, you have to know exactly how many characters you will be reading, so that you can make your buffer large enough. You will only know that if you know exactly what data you will be reading.&lt;/p&gt;\n&lt;p&gt;Instead of using &lt;code&gt;gets&lt;/code&gt;, you want to use &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;fgets&lt;/code&gt;&lt;/a&gt;, which has the signature&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;* &lt;span class=&quot;hljs-title function_&quot;&gt;fgets&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; length, FILE * stream)&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;(&lt;code&gt;fgets&lt;/code&gt;, if it reads an entire line, will leave the &lt;code&gt;&apos;\\n&apos;&lt;/code&gt; in the string; you&apos;ll have to deal with that.)&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;gets&lt;/code&gt; remained an official part of the language up to the 1999 ISO C standard, but it was officially removed in the &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf&quot; rel=&quot;noreferrer&quot;&gt;2011 standard&lt;/a&gt;. Most C implementations still support it, but at least gcc issues a warning for any code that uses it.&lt;/p&gt;\n    ","\n&lt;h1&gt;Why is &lt;code&gt;gets()&lt;/code&gt; dangerous&lt;/h1&gt;\n\n&lt;p&gt;The first internet worm (the &lt;a href=&quot;https://en.wikipedia.org/wiki/Morris_worm&quot; rel=&quot;noreferrer&quot;&gt;Morris Internet Worm&lt;/a&gt;) escaped about 30 years ago (1988-11-02), and it used &lt;code&gt;gets()&lt;/code&gt; and a buffer overflow as one of its methods of propagating from system to system. The basic problem is that the function doesn&apos;t know how big the buffer is, so it continues reading until it finds a newline or encounters EOF, and may overflow the bounds of the buffer it was given.&lt;/p&gt;\n\n&lt;p&gt;You should forget you ever heard that &lt;code&gt;gets()&lt;/code&gt; existed.&lt;/p&gt;\n\n&lt;p&gt;The C11 standard ISO/IEC 9899:2011 eliminated &lt;code&gt;gets()&lt;/code&gt; as a standard function, which is A Good Thing (it was formally marked as &apos;obsolescent&apos; and &apos;deprecated&apos; in ISO/IEC 9899:1999/Cor.3:2007  Technical Corrigendum 3 for C99, and then removed in C11).  Sadly, it will remain in libraries for many years (meaning &apos;decades&apos;) for reasons of backwards compatibility. If it were up to me, the implementation of &lt;code&gt;gets()&lt;/code&gt; would become:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *&lt;span class=&quot;hljs-title function_&quot;&gt;gets&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *buffer)&lt;/span&gt;\n{\n    assert(buffer != &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;abort&lt;/span&gt;();\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Given that your code will crash anyway, sooner or later, it is better to head the trouble off sooner rather than later.  I&apos;d be prepared to add an error message: &lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;fputs&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;obsolete and dangerous function gets() called\\n&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-built_in&quot;&gt;stderr&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Modern versions of the Linux compilation system generates warnings if you link &lt;code&gt;gets()&lt;/code&gt;  and also for some other functions that also have security problems (&lt;code&gt;mktemp()&lt;/code&gt;, ).&lt;/p&gt;\n\n&lt;h1&gt;Alternatives to &lt;code&gt;gets()&lt;/code&gt;&lt;/h1&gt;\n\n&lt;h2&gt;fgets()&lt;/h2&gt;\n\n&lt;p&gt;As everyone else said, the canonical alternative to &lt;code&gt;gets()&lt;/code&gt; is &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fgets.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;fgets()&lt;/code&gt;&lt;/a&gt; specifying &lt;code&gt;stdin&lt;/code&gt; as the file stream.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; buffer[BUFSIZ];\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (fgets(buffer, &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(buffer), &lt;span class=&quot;hljs-built_in&quot;&gt;stdin&lt;/span&gt;) != &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)\n{\n    ...process line of data...\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;What no-one else yet mentioned is that &lt;code&gt;gets()&lt;/code&gt; does not include the newline but &lt;code&gt;fgets()&lt;/code&gt; does.  So, you might need to use a wrapper around &lt;code&gt;fgets()&lt;/code&gt; that deletes the newline:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *&lt;span class=&quot;hljs-title function_&quot;&gt;fgets_wrapper&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *buffer, &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; buflen, FILE *fp)&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (fgets(buffer, buflen, fp) != &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)\n    {\n        &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; len = &lt;span class=&quot;hljs-built_in&quot;&gt;strlen&lt;/span&gt;(buffer);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (len &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; buffer[len&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;] == &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;)\n            buffer[len&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;] = &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\0&apos;&lt;/span&gt;;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; buffer;\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Or, better:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *&lt;span class=&quot;hljs-title function_&quot;&gt;fgets_wrapper&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *buffer, &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; buflen, FILE *fp)&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (fgets(buffer, buflen, fp) != &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)\n    {\n        buffer[&lt;span class=&quot;hljs-built_in&quot;&gt;strcspn&lt;/span&gt;(buffer, &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n&quot;&lt;/span&gt;)] = &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\0&apos;&lt;/span&gt;;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; buffer;\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Also, as &lt;a href=&quot;https://stackoverflow.com/users/134633/caf&quot;&gt;caf&lt;/a&gt; points out in a comment and &lt;a href=&quot;https://stackoverflow.com/users/14860/paxdiablo&quot;&gt;paxdiablo&lt;/a&gt; shows in his answer, with &lt;code&gt;fgets()&lt;/code&gt; you might have data left over on a line.  My wrapper code leaves that data to be read next time; you can readily modify it to gobble the rest of the line of data if you prefer:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (len &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; buffer[len&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;] == &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;)\n            buffer[len&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;] = &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\0&apos;&lt;/span&gt;;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;\n        {\n             &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; ch;\n             &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; ((ch = getc(fp)) != EOF &amp;amp;&amp;amp; ch != &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;)\n                 ;\n        }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The residual problem is how to report the three different result states  EOF or error, line read and not truncated, and partial line read but data was truncated.&lt;/p&gt;\n\n&lt;p&gt;This problem doesn&apos;t arise with &lt;code&gt;gets()&lt;/code&gt; because it doesn&apos;t know where your buffer ends and merrily tramples beyond the end, wreaking havoc on your beautifully tended memory layout, often messing up the return stack (a &lt;a href=&quot;https://stackoverflow.com/&quot;&gt;Stack Overflow&lt;/a&gt;) if the buffer is allocated on the stack, or trampling over the control information if the buffer is dynamically allocated, or copying data over other precious global (or module) variables if the buffer is statically allocated.  None of these is a good idea  they epitomize the phrase &apos;undefined behaviour`.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;There is also the &lt;a href=&quot;https://stackoverflow.com/questions/372980/do-you-use-the-tr-24731-safe-functions-in-your-c-code&quot;&gt;TR 24731-1&lt;/a&gt; (Technical Report from the C Standard Committee) which provides safer alternatives to a variety of functions, including &lt;code&gt;gets()&lt;/code&gt;:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;h2&gt;ยง6.5.4.1 The &lt;code&gt;gets_s&lt;/code&gt; function&lt;/h2&gt;\n  \n  &lt;h3&gt;Synopsis&lt;/h3&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; __STDC_WANT_LIB_EXT1__ 1&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *&lt;span class=&quot;hljs-title function_&quot;&gt;gets_s&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *s, &lt;span class=&quot;hljs-type&quot;&gt;rsize_t&lt;/span&gt; n)&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;h3&gt;Runtime-constraints&lt;/h3&gt;\n  \n  &lt;p&gt;&lt;code&gt;s&lt;/code&gt; shall not be a null pointer. &lt;code&gt;n&lt;/code&gt; shall neither be equal to zero nor be greater than\n  RSIZE_MAX. A new-line character, end-of-file, or read error shall occur within reading\n  &lt;code&gt;n-1&lt;/code&gt; characters from &lt;code&gt;stdin&lt;/code&gt;.&lt;sup&gt;25)&lt;/sup&gt;&lt;/p&gt;\n  \n  &lt;p&gt;3 If there is a runtime-constraint violation, &lt;code&gt;s[0]&lt;/code&gt; is set to the null character, and characters\n  are read and discarded from &lt;code&gt;stdin&lt;/code&gt; until a new-line character is read, or end-of-file or a\n  read error occurs.&lt;/p&gt;\n  \n  &lt;h3&gt;Description&lt;/h3&gt;\n  \n  &lt;p&gt;4 The &lt;code&gt;gets_s&lt;/code&gt; function reads at most one less than the number of characters specified by &lt;code&gt;n&lt;/code&gt;\n  from the stream pointed to by &lt;code&gt;stdin&lt;/code&gt;, into the array pointed to by &lt;code&gt;s&lt;/code&gt;. No additional\n  characters are read after a new-line character (which is discarded) or after end-of-file.\n  The discarded new-line character does not count towards number of characters read. A\n  null character is written immediately after the last character read into the array.&lt;/p&gt;\n  \n  &lt;p&gt;5 If end-of-file is encountered and no characters have been read into the array, or if a read\n  error occurs during the operation, then &lt;code&gt;s[0]&lt;/code&gt; is set to the null character, and the other\n  elements of &lt;code&gt;s&lt;/code&gt; take unspecified values.&lt;/p&gt;\n  \n  &lt;h3&gt;Recommended practice&lt;/h3&gt;\n  \n  &lt;p&gt;6 The &lt;code&gt;fgets&lt;/code&gt; function allows properly-written programs to safely process input lines too\n  long to store in the result array. In general this requires that callers of &lt;code&gt;fgets&lt;/code&gt; pay\n  attention to the presence or absence of a new-line character in the result array. Consider\n  using &lt;code&gt;fgets&lt;/code&gt; (along with any needed processing based on new-line characters) instead of\n  &lt;code&gt;gets_s&lt;/code&gt;.&lt;/p&gt;\n  \n  &lt;p&gt;&lt;sup&gt;25)&lt;/sup&gt; The &lt;code&gt;gets_s&lt;/code&gt; function, unlike &lt;code&gt;gets&lt;/code&gt;, makes it a runtime-constraint violation for a line of input to\n  overflow the buffer to store it. Unlike &lt;code&gt;fgets&lt;/code&gt;, &lt;code&gt;gets_s&lt;/code&gt; maintains a one-to-one relationship between\n  input lines and successful calls to &lt;code&gt;gets_s&lt;/code&gt;. Programs that use &lt;code&gt;gets&lt;/code&gt; expect such a relationship.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;The Microsoft Visual Studio compilers implement an approximation to the TR 24731-1 standard, but there are differences between the signatures implemented by Microsoft and those in the TR.&lt;/p&gt;\n\n&lt;p&gt;The C11 standard, ISO/IEC 9899-2011, includes TR24731 in Annex K as an optional part of the library. Unfortunately, it is seldom implemented on Unix-like systems.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;h2&gt;&lt;code&gt;getline()&lt;/code&gt;  POSIX&lt;/h2&gt;\n\n&lt;p&gt;POSIX 2008 also provides a safe alternative to &lt;code&gt;gets()&lt;/code&gt; called &lt;a href=&quot;http://www.opengroup.org/onlinepubs/9699919799/functions/getline.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;getline()&lt;/code&gt;&lt;/a&gt;.  It allocates space for the line dynamically, so you end up needing to free it.  It removes the limitation on line length, therefore. It also returns the length of the data that was read, or &lt;code&gt;-1&lt;/code&gt; (and not &lt;code&gt;EOF&lt;/code&gt;!), which means that null bytes in the input can be handled reliably.  There is also a &apos;choose your own single-character delimiter&apos; variation called &lt;code&gt;getdelim()&lt;/code&gt;; this can be useful if you are dealing with the output from &lt;code&gt;find -print0&lt;/code&gt; where the ends of the file names are marked with an ASCII NUL &lt;code&gt;&apos;\\0&apos;&lt;/code&gt; character, for example.&lt;/p&gt;\n    ","\n&lt;p&gt;Because &lt;code&gt;gets&lt;/code&gt; doesn&apos;t do any kind of check while getting bytes from &lt;em&gt;stdin&lt;/em&gt; and putting them somewhere. A simple example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; array1[] = &lt;span class=&quot;hljs-string&quot;&gt;&quot;12345&quot;&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; array2[] = &lt;span class=&quot;hljs-string&quot;&gt;&quot;67890&quot;&lt;/span&gt;;\n\ngets(array1);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Now, first of all you are allowed to input how many characters you want, &lt;code&gt;gets&lt;/code&gt; won&apos;t care about it. Secondly the bytes over the size of the array in which you put them (in this case &lt;code&gt;array1&lt;/code&gt;) will overwrite whatever they find in memory because &lt;code&gt;gets&lt;/code&gt; will write them. In the previous example this means that if you input &lt;code&gt;&quot;abcdefghijklmnopqrts&quot;&lt;/code&gt; maybe, unpredictably, it will overwrite also &lt;code&gt;array2&lt;/code&gt; or whatever.&lt;/p&gt;\n\n&lt;p&gt;The function is unsafe because it assumes consistent input. &lt;strong&gt;NEVER USE IT!&lt;/strong&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;You should not use &lt;code&gt;gets&lt;/code&gt; since it has no way to stop a buffer overflow. If the user types in more data than can fit in your buffer, you will most likely end up with corruption or worse.&lt;/p&gt;\n\n&lt;p&gt;In fact, ISO have actually taken the step of &lt;em&gt;removing&lt;/em&gt; &lt;code&gt;gets&lt;/code&gt; from the C standard (as of C11, though it was deprecated in C99) which, given how highly they rate backward compatibility, should be an indication of how bad that function was.&lt;/p&gt;\n\n&lt;p&gt;The correct thing to do is to use the &lt;code&gt;fgets&lt;/code&gt; function with the &lt;code&gt;stdin&lt;/code&gt; file handle since you can limit the characters read from the user.&lt;/p&gt;\n\n&lt;p&gt;But this also has its problems such as:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;extra characters entered by the user will be picked up the next time around.&lt;/li&gt;\n&lt;li&gt;there&apos;s no quick notification that the user entered too much data.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;To that end, almost every C coder at some point in their career will write a more useful wrapper around &lt;code&gt;fgets&lt;/code&gt; as well. Here&apos;s mine:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; OK       0&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; NO_INPUT 1&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; TOO_LONG 2&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;getLine&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *prmpt, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *buff, &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; sz)&lt;/span&gt; {\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; ch, extra;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Get line with buffer overrun protection.&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (prmpt != &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;) {\n        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt; (&lt;span class=&quot;hljs-string&quot;&gt;&quot;%s&quot;&lt;/span&gt;, prmpt);\n        fflush (&lt;span class=&quot;hljs-built_in&quot;&gt;stdout&lt;/span&gt;);\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (fgets (buff, sz, &lt;span class=&quot;hljs-built_in&quot;&gt;stdin&lt;/span&gt;) == &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;)\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; NO_INPUT;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// If it was too long, there&apos;ll be no newline. In that case, we flush&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// to end of line so that excess doesn&apos;t affect the next call.&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (buff[&lt;span class=&quot;hljs-built_in&quot;&gt;strlen&lt;/span&gt;(buff)&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;] != &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;) {\n        extra = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (((ch = getchar()) != &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;) &amp;amp;&amp;amp; (ch != EOF))\n            extra = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (extra == &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) ? TOO_LONG : OK;\n    }\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Otherwise remove newline and give string back to caller.&lt;/span&gt;\n    buff[&lt;span class=&quot;hljs-built_in&quot;&gt;strlen&lt;/span&gt;(buff)&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;] = &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\0&apos;&lt;/span&gt;;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; OK;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;with some test code:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Test program for getLine().&lt;/span&gt;\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt; {\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; rc;\n    &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; buff[&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;];\n\n    rc = getLine (&lt;span class=&quot;hljs-string&quot;&gt;&quot;Enter string&amp;gt; &quot;&lt;/span&gt;, buff, &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(buff));\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (rc == NO_INPUT) {\n        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt; (&lt;span class=&quot;hljs-string&quot;&gt;&quot;No input\\n&quot;&lt;/span&gt;);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    }\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (rc == TOO_LONG) {\n        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt; (&lt;span class=&quot;hljs-string&quot;&gt;&quot;Input too long\\n&quot;&lt;/span&gt;);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    }\n\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt; (&lt;span class=&quot;hljs-string&quot;&gt;&quot;OK [%s]\\n&quot;&lt;/span&gt;, buff);\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It provides the same protections as &lt;code&gt;fgets&lt;/code&gt; in that it prevents buffer overflows but it also notifies the caller as to what happened and clears out the excess characters so that they do not affect your next input operation.&lt;/p&gt;\n\n&lt;p&gt;Feel free to use it as you wish, I hereby release it under the &quot;do what you damn well want to&quot; licence :-)&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;a href=&quot;http://www.cplusplus.com/reference/clibrary/cstdio/fgets/&quot; rel=&quot;noreferrer&quot;&gt;fgets&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;To read from the stdin:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;512&lt;/span&gt;];\n\nfgets(&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;), &lt;span class=&quot;hljs-built_in&quot;&gt;stdin&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;/* no buffer overflows here, you&apos;re safe! */&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;You can&apos;t remove API functions without breaking the API. If you would, many applications would no longer compile or run at all.&lt;/p&gt;\n\n&lt;p&gt;This is the reason that &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/functions/gets.html&quot; rel=&quot;noreferrer&quot;&gt;one reference&lt;/a&gt; gives:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Reading a line that overflows the\n  array pointed to by s results in\n  undefined behavior. The use of fgets()\n  is recommended.&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;I read recently, in a &lt;a href=&quot;http://groups.google.com/group/comp.lang.c/msg/7e92710bc5ff2ba8&quot; rel=&quot;noreferrer&quot;&gt;USENET post to &lt;code&gt;comp.lang.c&lt;/code&gt;&lt;/a&gt;, that &lt;code&gt;gets()&lt;/code&gt; is getting removed from the Standard. &lt;strong&gt;WOOHOO&lt;/strong&gt;&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;You&apos;ll be happy to know that the\n  committee just voted (unanimously, as\n  it turns out) to remove gets() from\n  the draft as well.&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;In C11(ISO/IEC 9899:201x), &lt;code&gt;gets()&lt;/code&gt; has been removed. (It&apos;s deprecated in ISO/IEC 9899:1999/Cor.3:2007(E))&lt;/p&gt;\n\n&lt;p&gt;In addition to &lt;code&gt;fgets()&lt;/code&gt;, C11 introduces a new safe alternative &lt;code&gt;gets_s()&lt;/code&gt;:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;h3&gt;C11 K.3.5.4.1 The &lt;code&gt;gets_s&lt;/code&gt; function&lt;/h3&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; __STDC_WANT_LIB_EXT1__ 1&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *&lt;span class=&quot;hljs-title function_&quot;&gt;gets_s&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *s, &lt;span class=&quot;hljs-type&quot;&gt;rsize_t&lt;/span&gt; n)&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;However, in the &lt;em&gt;Recommended practice&lt;/em&gt; section, &lt;code&gt;fgets()&lt;/code&gt; is still preferred.&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;The &lt;code&gt;fgets&lt;/code&gt; function allows properly-written programs to safely process input lines too\n  long to store in the result array. In general this requires that callers of &lt;code&gt;fgets&lt;/code&gt; pay\n  attention to the presence or absence of a new-line character in the result array. Consider\n  using &lt;code&gt;fgets&lt;/code&gt; (along with any needed processing based on new-line characters) instead of\n  &lt;code&gt;gets_s&lt;/code&gt;.&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;&lt;code&gt;gets()&lt;/code&gt; is dangerous because it is possible for the user to crash the program by typing too much into the prompt. It can&apos;t detect the end of available memory, so if you allocate an amount of memory too small for the purpose, it can cause a seg fault and crash. Sometimes it seems very unlikely that a user will type 1000 letters into a prompt meant for a person&apos;s name, but as programmers, we need to make our programs bulletproof. (it may also be a security risk if a user can crash a system program by sending too much data).&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;fgets()&lt;/code&gt; allows you to specify how many characters are taken out of the standard input buffer, so they don&apos;t overrun the variable.&lt;/p&gt;\n    ","\n&lt;p&gt;The C gets function is dangerous and has been a very costly mistake. Tony Hoare singles it out for specific mention in his talk &quot;Null References: The Billion Dollar Mistake&quot;:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare&quot; rel=&quot;nofollow&quot;&gt;http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;The whole hour is worth watching but for his comments view from 30 minutes on with the specific gets criticism around 39 minutes.&lt;/p&gt;\n\n&lt;p&gt;Hopefully this whets your appetite for the whole talk, which draws attention to how we need more formal correctness proofs in languages and how language designers should be blamed for the mistakes in their languages, not the programmer. This seems to have been the whole dubious reason for designers of bad languages to push the blame to programmers in the guise of &apos;programmer freedom&apos;.&lt;/p&gt;\n    ","\n&lt;p&gt;I would like to extend an earnest invitation to any C library maintainers out there who are still including &lt;code&gt;gets&lt;/code&gt; in their libraries &quot;just in case anyone is still depending on it&quot;: Please replace your implementation with the equivalent of&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *&lt;span class=&quot;hljs-title function_&quot;&gt;gets&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *str)&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-built_in&quot;&gt;strcpy&lt;/span&gt;(str, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Never use gets!&quot;&lt;/span&gt;);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; str;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This will help make sure nobody is still depending on it.  Thank you.&lt;/p&gt;\n    ","\n&lt;p&gt;In a few words &lt;code&gt;gets()&lt;/code&gt; (can) be dangerous because the user might input something bigger than what the variable has enough space to store. First answer says about &lt;code&gt;fgets()&lt;/code&gt; and why it is safer.&lt;/p&gt;\n    ","\n&lt;p&gt;Additional info:&lt;/p&gt;\n&lt;p&gt;From &lt;code&gt;man 3 gets&lt;/code&gt; on Linux Ubuntu you&apos;ll see (emphasis added):&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;DESCRIPTION\n       Never use this function.\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;And, from the cppreference.com wiki here (&lt;a href=&quot;https://en.cppreference.com/w/c/io/gets&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://en.cppreference.com/w/c/io/gets&lt;/a&gt;) you&apos;ll see: &lt;code&gt;Notes  Never use gets().&lt;/code&gt;:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;h2&gt;Notes&lt;/h2&gt;\n&lt;p&gt;The &lt;code&gt;gets()&lt;/code&gt; function does not perform bounds checking, therefore this function is extremely vulnerable to buffer-overflow attacks. It cannot be used safely (unless the program runs in an environment which restricts what can appear on &lt;code&gt;stdin&lt;/code&gt;). For this reason, the function has been deprecated in the third corrigendum to the C99 standard and removed altogether in the C11 standard. &lt;code&gt;fgets()&lt;/code&gt; and &lt;code&gt;gets_s()&lt;/code&gt; are the recommended replacements.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Never use &lt;code&gt;gets()&lt;/code&gt;.&lt;/strong&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;As you can see, the function has been deprecated and removed entirely in C11 or later.&lt;/p&gt;\n&lt;p&gt;Use &lt;a href=&quot;https://en.cppreference.com/w/c/io/fgets&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;fgets()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://en.cppreference.com/w/c/io/gets&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;gets_s()&lt;/code&gt;&lt;/a&gt; instead.&lt;/p&gt;\n&lt;p&gt;Here is my demo usage of &lt;code&gt;fgets()&lt;/code&gt;, with full error checking:&lt;/p&gt;\n&lt;p&gt;From &lt;a href=&quot;https://github.com/ElectricRCAircraftGuy/eRCaGuy_hello_world/blob/master/c/read_stdin_fgets_basic_input_from_user.c&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;strong&gt;read_stdin_fgets_basic_input_from_user.c&lt;/strong&gt;&lt;/a&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;errno.h&amp;gt;&lt;/span&gt;   &lt;span class=&quot;hljs-comment&quot;&gt;// `errno`&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;   &lt;span class=&quot;hljs-comment&quot;&gt;// `printf()`, `fgets()`&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;  &lt;span class=&quot;hljs-comment&quot;&gt;// `exit()`&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;  &lt;span class=&quot;hljs-comment&quot;&gt;// `strerror()`&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// int main(int argc, char *argv[])  // alternative prototype&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; buf[&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;];\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// NEVER USE `gets()`! USE `fgets()` BELOW INSTEAD!&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// USE THIS!: `fgets()`: &quot;file get string&quot;, which reads until either EOF is&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// reached, OR a newline (`\\n`) is found, keeping the newline char in&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// `buf`.&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// For `feof()` and `ferror()`, see:&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// 1. https://en.cppreference.com/w/c/io/feof&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// 1. https://en.cppreference.com/w/c/io/ferror&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Enter up to %zu chars: &quot;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(buf) - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;// - 1 to save room&lt;/span&gt;\n                                                        &lt;span class=&quot;hljs-comment&quot;&gt;// for null terminator&lt;/span&gt;\n    &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;* retval = fgets(buf, &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(buf), &lt;span class=&quot;hljs-built_in&quot;&gt;stdin&lt;/span&gt;);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (feof(&lt;span class=&quot;hljs-built_in&quot;&gt;stdin&lt;/span&gt;))\n    {\n        &lt;span class=&quot;hljs-comment&quot;&gt;// Check for `EOF`, which means &quot;End of File was reached&quot;.&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;// - This doesn&apos;t really make sense on `stdin` I think, but it is a good&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;//   check to have when reading from a regular file with `fgets&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;//   ()`. Keep it here regardless, just in case.&lt;/span&gt;\n        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;EOF (End of File) reached.\\n&quot;&lt;/span&gt;);\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (ferror(&lt;span class=&quot;hljs-built_in&quot;&gt;stdin&lt;/span&gt;))\n    {\n        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Error indicator set. IO error when reading from file &quot;&lt;/span&gt;\n               &lt;span class=&quot;hljs-string&quot;&gt;&quot;`stdin`.\\n&quot;&lt;/span&gt;);\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (retval == &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;)\n    {\n        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;ERROR in %s(): fgets() failed; errno = %i: %s\\n&quot;&lt;/span&gt;,\n            __func__, errno, strerror(errno));\n\n        &lt;span class=&quot;hljs-built_in&quot;&gt;exit&lt;/span&gt;(EXIT_FAILURE);\n    }\n\n    &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; num_chars_written = &lt;span class=&quot;hljs-built_in&quot;&gt;strlen&lt;/span&gt;(buf) + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// + 1 for null terminator&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (num_chars_written &amp;gt;= &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(buf))\n    {\n        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Warning: user input may have been truncated! All %zu chars &quot;&lt;/span&gt;\n               &lt;span class=&quot;hljs-string&quot;&gt;&quot;were written into buffer.\\n&quot;&lt;/span&gt;, num_chars_written);\n    }\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;You entered \\&quot;%s\\&quot;.\\n&quot;&lt;/span&gt;, buf);\n\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Sample runs and output:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;eRCaGuy_hello_world/c$ gcc -Wall -Wextra -Werror -O3 -&lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;=c17 read_stdin_fgets_basic_input_from_user.c -o bin/a &amp;amp;&amp;amp; bin/a\nEnter up to &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt; chars: hello world!\nWarning: user input may have been truncated! All &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt; chars were written into buffer.\nYou entered &lt;span class=&quot;hljs-string&quot;&gt;&quot;hello wor&quot;&lt;/span&gt;.\n\neRCaGuy_hello_world/c$ gcc -Wall -Wextra -Werror -O3 -&lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;=c17 read_stdin_fgets_basic_input_from_user.c -o bin/a &amp;amp;&amp;amp; bin/a\nEnter up to &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt; chars: hey\nYou entered &lt;span class=&quot;hljs-string&quot;&gt;&quot;hey\n&quot;&lt;/span&gt;.\n&lt;/code&gt;&lt;/pre&gt;\n    "]},"randomTags":[{"name":"class-table-inheritance","slug":"class-table-inheritance"},{"name":"multithreading","slug":"multithreading"},{"name":"url-parameters","slug":"url-parameters"},{"name":"eof","slug":"eof"},{"name":"raw-types","slug":"raw-types"},{"name":"variadic-functions","slug":"variadic-functions"},{"name":"redirect","slug":"redirect"},{"name":"directory","slug":"directory"},{"name":"jquery-selectors","slug":"jquery-selectors"},{"name":"selenium-webdriver","slug":"selenium-webdriver"},{"name":"syntactic-sugar","slug":"syntactic-sugar"},{"name":"cookies","slug":"cookies"},{"name":"plugins","slug":"plugins"},{"name":"join","slug":"join"},{"name":"http","slug":"http"},{"name":"c++","slug":"c++"},{"name":"string-matching","slug":"string-matching"},{"name":"firebase","slug":"firebase"},{"name":"objective-c","slug":"objective-c"},{"name":"git","slug":"git"}]},"__N_SSG":true}