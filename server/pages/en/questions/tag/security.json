{"pageProps":{"data":{"count":1,"rows":[{"id":4,"title":"How can I prevent SQL injection in PHP?","slug":"how-can-i-prevent-sql-injection-in-php-1657384220094","postType":"QUESTION","createdAt":"2022-07-09T16:30:20.000Z","updatedAt":"2022-07-09T16:30:20.000Z","tags":[{"id":11,"name":"security","slug":"security","createdAt":"2022-07-09T16:30:20.000Z","updatedAt":"2022-07-09T16:30:20.000Z","Questions_Tags":{"questionId":4,"tagId":11}}]}]},"slug":"security","page":1,"answers":{"4":["\n&lt;p&gt;The &lt;em&gt;correct&lt;/em&gt; way to avoid SQL injection attacks, no matter which database you use, is to &lt;strong&gt;separate the data from SQL&lt;/strong&gt;, so that data stays data and will &lt;strong&gt;never be interpreted&lt;/strong&gt; as commands by the SQL parser. It is possible to create an SQL statement with correctly formatted data parts, but if you don&apos;t &lt;em&gt;fully&lt;/em&gt; understand the details, you should always &lt;strong&gt;use prepared statements and parameterized queries.&lt;/strong&gt; These are SQL statements that are sent to and parsed by the database server separately from any parameters. This way it is impossible for an attacker to inject malicious SQL.&lt;/p&gt;\n&lt;p&gt;You basically have two options to achieve this:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;Using &lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot; rel=&quot;noreferrer&quot;&gt;&lt;strong&gt;PDO&lt;/strong&gt;&lt;/a&gt; (for any supported database driver):&lt;/p&gt;\n &lt;pre class=&quot;lang-php s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$pdo&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;prepare&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;SELECT * FROM employees WHERE name = :name&apos;&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;execute&lt;/span&gt;([ &lt;span class=&quot;hljs-string&quot;&gt;&apos;name&apos;&lt;/span&gt; =&amp;gt; &lt;span class=&quot;hljs-variable&quot;&gt;$name&lt;/span&gt; ]);\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;foreach&lt;/span&gt; (&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$row&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Do something with $row&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Using &lt;a href=&quot;http://php.net/manual/en/book.mysqli.php&quot; rel=&quot;noreferrer&quot;&gt;&lt;strong&gt;MySQLi&lt;/strong&gt;&lt;/a&gt; (for MySQL):&lt;/p&gt;\n &lt;pre class=&quot;lang-php s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$dbConnection&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;prepare&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;SELECT * FROM employees WHERE name = ?&apos;&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;bind_param&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;s&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-variable&quot;&gt;$name&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;// &apos;s&apos; specifies the variable type =&amp;gt; &apos;string&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;execute&lt;/span&gt;();\n\n&lt;span class=&quot;hljs-variable&quot;&gt;$result&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;get_result&lt;/span&gt;();\n&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;hljs-variable&quot;&gt;$row&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$result&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;fetch_assoc&lt;/span&gt;()) {\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Do something with $row&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;If you&apos;re connecting to a database other than MySQL, there is a driver-specific second option that you can refer to (for example, &lt;code&gt;pg_prepare()&lt;/code&gt; and &lt;code&gt;pg_execute()&lt;/code&gt; for PostgreSQL). PDO is the universal option.&lt;/p&gt;\n&lt;hr&gt;\n&lt;h2&gt;Correctly setting up the connection&lt;/h2&gt;\n&lt;h4&gt;PDO&lt;/h4&gt;\n&lt;p&gt;Note that when using &lt;strong&gt;PDO&lt;/strong&gt; to access a MySQL database &lt;em&gt;real&lt;/em&gt; prepared statements are &lt;strong&gt;not used by default&lt;/strong&gt;. To fix this you have to disable the emulation of prepared statements. An example of creating a connection using &lt;strong&gt;PDO&lt;/strong&gt; is:&lt;/p&gt;\n&lt;pre class=&quot;lang-php s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$dbConnection&lt;/span&gt; = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;PDO&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;mysql:dbname=dbtest;host=127.0.0.1;charset=utf8mb4&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;user&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;password&apos;&lt;/span&gt;);\n\n&lt;span class=&quot;hljs-variable&quot;&gt;$dbConnection&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;setAttribute&lt;/span&gt;(PDO::&lt;span class=&quot;hljs-variable constant_&quot;&gt;ATTR_EMULATE_PREPARES&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$dbConnection&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;setAttribute&lt;/span&gt;(PDO::&lt;span class=&quot;hljs-variable constant_&quot;&gt;ATTR_ERRMODE&lt;/span&gt;, PDO::&lt;span class=&quot;hljs-variable constant_&quot;&gt;ERRMODE_EXCEPTION&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In the above example, the error mode isn&apos;t strictly necessary, &lt;strong&gt;but it is advised to add it&lt;/strong&gt;. This way PDO will inform you of all MySQL errors by means of throwing the &lt;code&gt;PDOException&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;What is &lt;strong&gt;mandatory&lt;/strong&gt;, however, is the first &lt;code&gt;setAttribute()&lt;/code&gt; line, which tells PDO to disable emulated prepared statements and use &lt;em&gt;real&lt;/em&gt; prepared statements. This makes sure the statement and the values aren&apos;t parsed by PHP before sending it to the MySQL server (giving a possible attacker no chance to inject malicious SQL).&lt;/p&gt;\n&lt;p&gt;Although you can set the &lt;code&gt;charset&lt;/code&gt; in the options of the constructor, it&apos;s important to note that &apos;older&apos; versions of PHP (before 5.3.6) &lt;a href=&quot;http://php.net/manual/en/ref.pdo-mysql.connection.php&quot; rel=&quot;noreferrer&quot;&gt;silently ignored the charset parameter&lt;/a&gt; in the DSN.&lt;/p&gt;\n&lt;h4&gt;Mysqli&lt;/h4&gt;\n&lt;p&gt;For mysqli we have to follow the same routine:&lt;/p&gt;\n&lt;pre class=&quot;lang-php s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;mysqli_report&lt;/span&gt;(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT); &lt;span class=&quot;hljs-comment&quot;&gt;// error reporting&lt;/span&gt;\n&lt;span class=&quot;hljs-variable&quot;&gt;$dbConnection&lt;/span&gt; = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;mysqli&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;127.0.0.1&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;username&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;password&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;test&apos;&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$dbConnection&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;set_charset&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;utf8mb4&apos;&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;// charset&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;hr&gt;\n&lt;h2&gt;Explanation&lt;/h2&gt;\n&lt;p&gt;The SQL statement you pass to &lt;code&gt;prepare&lt;/code&gt; is parsed and compiled by the database server. By specifying parameters (either a &lt;code&gt;?&lt;/code&gt; or a named parameter like &lt;code&gt;:name&lt;/code&gt; in the example above) you tell the database engine where you want to filter on. Then when you call &lt;code&gt;execute&lt;/code&gt;, the prepared statement is combined with the parameter values you specify.&lt;/p&gt;\n&lt;p&gt;The important thing here is that the parameter values are combined with the compiled statement, not an SQL string. SQL injection works by tricking the script into including malicious strings when it creates SQL to send to the database. So by sending the actual SQL separately from the parameters, you limit the risk of ending up with something you didn&apos;t intend.&lt;/p&gt;\n&lt;p&gt;Any parameters you send when using a prepared statement will just be treated as strings (although the database engine may do some optimization so parameters may end up as numbers too, of course). In the example above, if the &lt;code&gt;$name&lt;/code&gt; variable contains &lt;code&gt;&apos;Sarah&apos;; DELETE FROM employees&lt;/code&gt; the result would simply be a search for the string &lt;code&gt;&quot;&apos;Sarah&apos;; DELETE FROM employees&quot;&lt;/code&gt;, and you will not end up with &lt;a href=&quot;http://xkcd.com/327/&quot; rel=&quot;noreferrer&quot;&gt;an empty table&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;Another benefit of using prepared statements is that if you execute the same statement many times in the same session it will only be parsed and compiled once, giving you some speed gains.&lt;/p&gt;\n&lt;p&gt;Oh, and since you asked about how to do it for an insert, here&apos;s an example (using PDO):&lt;/p&gt;\n&lt;pre class=&quot;lang-php s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$preparedStatement&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$db&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;prepare&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;INSERT INTO table (column) VALUES (:column)&apos;&lt;/span&gt;);\n\n&lt;span class=&quot;hljs-variable&quot;&gt;$preparedStatement&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;execute&lt;/span&gt;([ &lt;span class=&quot;hljs-string&quot;&gt;&apos;column&apos;&lt;/span&gt; =&amp;gt; &lt;span class=&quot;hljs-variable&quot;&gt;$unsafeValue&lt;/span&gt; ]);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;hr&gt;\n&lt;h2&gt;Can prepared statements be used for dynamic queries?&lt;/h2&gt;\n&lt;p&gt;While you can still use prepared statements for the query parameters, the structure of the dynamic query itself cannot be parametrized and certain query features cannot be parametrized.&lt;/p&gt;\n&lt;p&gt;For these specific scenarios, the best thing to do is use a whitelist filter that restricts the possible values.&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Value whitelist&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// $dir can only be &apos;DESC&apos;, otherwise it will be &apos;ASC&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;empty&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$dir&lt;/span&gt;) || &lt;span class=&quot;hljs-variable&quot;&gt;$dir&lt;/span&gt; !== &lt;span class=&quot;hljs-string&quot;&gt;&apos;DESC&apos;&lt;/span&gt;) {\n   &lt;span class=&quot;hljs-variable&quot;&gt;$dir&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&apos;ASC&apos;&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;To use the parameterized query, you need to use either Mysqli or PDO. To rewrite your example with mysqli, we would need something like the following.&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;?php&lt;/span&gt;\n&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;mysqli_report&lt;/span&gt;(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);\n&lt;span class=&quot;hljs-variable&quot;&gt;$mysqli&lt;/span&gt; = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;mysqli&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;server&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;username&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;password&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;database_name&quot;&lt;/span&gt;);\n\n&lt;span class=&quot;hljs-variable&quot;&gt;$variable&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$_POST&lt;/span&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&quot;user-input&quot;&lt;/span&gt;];\n&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$mysqli&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;prepare&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;INSERT INTO table (column) VALUES (?)&quot;&lt;/span&gt;);\n&lt;span class=&quot;hljs-comment&quot;&gt;// &quot;s&quot; means the database expects a string&lt;/span&gt;\n&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;bind_param&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;s&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-variable&quot;&gt;$variable&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;execute&lt;/span&gt;();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The key function you&apos;ll want to read up on there would be &lt;a href=&quot;http://php.net/mysqli.prepare&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;mysqli::prepare&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;Also, as others have suggested, you may find it useful/easier to step up a layer of abstraction with something like &lt;a href=&quot;http://php.net/pdo&quot; rel=&quot;noreferrer&quot;&gt;PDO&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;Please note that the case you asked about is a fairly simple one and that more complex cases may require more complex approaches. In particular:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;If you want to alter the structure of the SQL based on user input, parameterized queries are not going to help, and the escaping required is not covered by &lt;code&gt;mysql_real_escape_string&lt;/code&gt;. In this kind of case, you would be better off passing the user&apos;s input through a whitelist to ensure only &apos;safe&apos; values are allowed through.&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;Every answer here covers only part of the problem.\nIn fact, there are &lt;strong&gt;four&lt;/strong&gt; different query parts which we can add to SQL dynamically: -&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;a string&lt;/li&gt;\n&lt;li&gt;a number&lt;/li&gt;\n&lt;li&gt;an identifier&lt;/li&gt;\n&lt;li&gt;a syntax keyword&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;And prepared statements cover only two of them.&lt;/p&gt;\n&lt;p&gt;But sometimes we have to make our query even more dynamic, adding operators or identifiers as well.\nSo, we will need different protection techniques.&lt;/p&gt;\n&lt;p&gt;In general, such a protection approach is based on &lt;em&gt;whitelisting&lt;/em&gt;.&lt;/p&gt;\n&lt;p&gt;In this case, every dynamic parameter should be hardcoded in your script and chosen from that set.\nFor example, to do dynamic ordering:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$orders&lt;/span&gt;  = &lt;span class=&quot;hljs-keyword&quot;&gt;array&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;price&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;qty&quot;&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;// Field names&lt;/span&gt;\n&lt;span class=&quot;hljs-variable&quot;&gt;$key&lt;/span&gt; = &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;array_search&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$_GET&lt;/span&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&apos;sort&apos;&lt;/span&gt;], &lt;span class=&quot;hljs-variable&quot;&gt;$orders&lt;/span&gt;)); &lt;span class=&quot;hljs-comment&quot;&gt;// if we have such a name&lt;/span&gt;\n&lt;span class=&quot;hljs-variable&quot;&gt;$orderby&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$orders&lt;/span&gt;[&lt;span class=&quot;hljs-variable&quot;&gt;$key&lt;/span&gt;]; &lt;span class=&quot;hljs-comment&quot;&gt;// If not, first one will be set automatically. &lt;/span&gt;\n&lt;span class=&quot;hljs-variable&quot;&gt;$query&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&quot;SELECT * FROM `table` ORDER BY &lt;span class=&quot;hljs-subst&quot;&gt;$orderby&lt;/span&gt;&quot;&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// Value is safe&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;To ease the process I wrote a &lt;a href=&quot;https://phpdelusions.net/pdo_examples/order_by&quot; rel=&quot;noreferrer&quot;&gt;whitelist helper function&lt;/a&gt; that does all the job in one line:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$orderby&lt;/span&gt; = &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;white_list&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$_GET&lt;/span&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&apos;orderby&apos;&lt;/span&gt;], &lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;, [&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;price&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;qty&quot;&lt;/span&gt;], &lt;span class=&quot;hljs-string&quot;&gt;&quot;Invalid field name&quot;&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$query&lt;/span&gt;  = &lt;span class=&quot;hljs-string&quot;&gt;&quot;SELECT * FROM `table` ORDER BY `&lt;span class=&quot;hljs-subst&quot;&gt;$orderby&lt;/span&gt;`&quot;&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// sound and safe&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;There is another way to secure identifiers - escaping but I rather stick to whitelisting as a more robust and explicit approach. Yet as long as you have an identifier quoted, you can escape the quote character to make it safe. For example, by default for mysql you have to &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/identifiers.html&quot; rel=&quot;noreferrer&quot;&gt;double the quote character to escape it&lt;/a&gt;. For other other DBMS escaping rules would be different.&lt;/p&gt;\n&lt;p&gt;Still, there is an issue with SQL syntax keywords (such as &lt;code&gt;AND&lt;/code&gt;, &lt;code&gt;DESC&lt;/code&gt; and such), but white-listing seems the only approach in this case.&lt;/p&gt;\n&lt;p&gt;So, a general recommendation may be phrased as&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;Any variable that represents an SQL data literal, (or, to put it simply - an SQL string, or a number) must be added through a prepared statement. No Exceptions.&lt;/li&gt;\n&lt;li&gt;Any other query part, such as an SQL keyword, a table or a field name, or an operator - must be filtered through a white list.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/blockquote&gt;\n&lt;h3&gt;Update&lt;/h3&gt;\n&lt;p&gt;Although there is a general agreement on the best practices regarding SQL injection protection, there are &lt;strong&gt;still many bad practices as well.&lt;/strong&gt; And some of them too deeply rooted in the minds of PHP users. For instance, on this very page there are (although invisible to most visitors) &lt;strong&gt;more than 80 deleted answers&lt;/strong&gt; - all removed by the community due to bad quality or promoting bad and outdated practices. Worse yet, some of the bad answers aren&apos;t deleted, but rather prospering.&lt;/p&gt;\n&lt;p&gt;For example, &lt;a href=&quot;https://stackoverflow.com/a/11802479&quot;&gt;there(1)&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/6381189&quot;&gt;are(2)&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/60195/&quot;&gt;still(3)&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/12426697/&quot;&gt;many(4)&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/21179234&quot;&gt;answers(5)&lt;/a&gt;, including the &lt;a href=&quot;https://stackoverflow.com/a/60442&quot;&gt;second most upvoted answer&lt;/a&gt; suggesting you manual string escaping - an outdated approach that is proven to be insecure.&lt;/p&gt;\n&lt;p&gt;Or there is a slightly better answer that suggests just &lt;a href=&quot;https://stackoverflow.com/a/12710285&quot;&gt;another method of string formatting&lt;/a&gt; and even boasts it as the ultimate panacea. While of course, it is not. This method is no better than regular string formatting, yet it keeps all its drawbacks: it is applicable to strings only and, like any other manual formatting, it&apos;s essentially optional, non-obligatory measure, prone to human error of any sort.&lt;/p&gt;\n&lt;p&gt;I think that all this because of one very old superstition, supported by such authorities like &lt;a href=&quot;https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet#Defense_Option_4:_Escaping_All_User_Supplied_Input&quot; rel=&quot;noreferrer&quot;&gt;OWASP&lt;/a&gt; or &lt;a href=&quot;http://php.net/manual/en/function.mysql-real-escape-string.php#refsect1-function.mysql-real-escape-string-description&quot; rel=&quot;noreferrer&quot;&gt;the PHP manual&lt;/a&gt;, which proclaims equality between whatever &quot;escaping&quot; and protection from SQL injections.&lt;/p&gt;\n&lt;p&gt;Regardless of what PHP manual said for ages, &lt;strong&gt;&lt;code&gt;*_escape_string&lt;/code&gt; by no means makes data safe&lt;/strong&gt; and never has been intended to. Besides being useless for any SQL part other than string, manual escaping is wrong, because it is manual as opposite to automated.&lt;/p&gt;\n&lt;p&gt;And OWASP makes it even worse, stressing on escaping &lt;em&gt;user input&lt;/em&gt; which is an utter nonsense: there should be no such words in the context of injection protection. Every variable is potentially dangerous - no matter the source! Or, in other words - every variable has to be properly formatted to be put into a query - no matter the source again. It&apos;s the destination that matters. The moment a developer starts to separate the sheep from the goats (thinking whether some particular variable is &quot;safe&quot; or not) he/she takes his/her first step towards disaster. Not to mention that even the wording suggests bulk escaping at the entry point, resembling the very magic quotes feature - already despised, deprecated and removed.&lt;/p&gt;\n&lt;p&gt;So, unlike whatever &quot;escaping&quot;, prepared statements &lt;em&gt;is&lt;/em&gt; the measure that indeed protects from SQL injection (when applicable).&lt;/p&gt;\n    ","\n&lt;p&gt;I&apos;d recommend using &lt;a href=&quot;http://ca3.php.net/manual/en/book.pdo.php&quot; rel=&quot;noreferrer&quot;&gt;PDO&lt;/a&gt; (PHP Data Objects) to run parameterized SQL queries. &lt;/p&gt;\n\n&lt;p&gt;Not only does this protect against SQL injection, but it also speeds up queries. &lt;/p&gt;\n\n&lt;p&gt;And by using PDO rather than &lt;code&gt;mysql_&lt;/code&gt;, &lt;code&gt;mysqli_&lt;/code&gt;, and &lt;code&gt;pgsql_&lt;/code&gt; functions, you make your application a little more abstracted from the database, in the rare occurrence that you have to switch database providers.&lt;/p&gt;\n    ","\n&lt;p&gt;Use &lt;code&gt;PDO&lt;/code&gt; and prepared queries.&lt;/p&gt;\n&lt;p&gt;(&lt;code&gt;$conn&lt;/code&gt; is a &lt;code&gt;PDO&lt;/code&gt; object)&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$conn&lt;/span&gt;-&amp;gt;prepare(&lt;span class=&quot;hljs-string&quot;&gt;&quot;INSERT INTO tbl VALUES(:id, :name)&quot;&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt;-&amp;gt;bindValue(&lt;span class=&quot;hljs-string&quot;&gt;&apos;:id&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-variable&quot;&gt;$id&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt;-&amp;gt;bindValue(&lt;span class=&quot;hljs-string&quot;&gt;&apos;:name&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-variable&quot;&gt;$name&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt;-&amp;gt;execute();\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;As you can see, people suggest you use prepared statements at the most. It&apos;s not wrong, but when your query is executed &lt;strong&gt;just once&lt;/strong&gt; per process, there would be a slight performance penalty. &lt;/p&gt;\n\n&lt;p&gt;I was facing this issue, but I think I solved it in &lt;em&gt;very&lt;/em&gt; sophisticated way - the way hackers use to avoid using quotes. I used this in conjunction with emulated prepared statements. I use it to prevent &lt;em&gt;all&lt;/em&gt; kinds of possible SQL injection attacks.&lt;/p&gt;\n\n&lt;h2&gt;My approach:&lt;/h2&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;If you expect input to be integer make sure it&apos;s &lt;strong&gt;&lt;em&gt;really&lt;/em&gt;&lt;/strong&gt; integer. In a variable-type language like PHP it is this &lt;em&gt;very&lt;/em&gt; important. You can use for example this very simple but powerful solution: &lt;code&gt;sprintf(&quot;SELECT 1,2,3 FROM table WHERE 4 = %u&quot;, $input);&lt;/code&gt;  &lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;If you expect anything else from integer &lt;strong&gt;hex it&lt;/strong&gt;. If you hex it, you will perfectly escape all input. In C/C++ there&apos;s a function called &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.0/en/mysql-hex-string.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;mysql_hex_string()&lt;/code&gt;&lt;/a&gt;, in PHP you can use &lt;a href=&quot;http://www.php.net/manual/en/function.bin2hex.php&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;bin2hex()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;Don&apos;t worry about that the escaped string will have a 2x size of its original length because even if you use &lt;code&gt;mysql_real_escape_string&lt;/code&gt;, PHP has to allocate same capacity &lt;code&gt;((2*input_length)+1)&lt;/code&gt;, which is the same.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;This hex method is often used when you transfer binary data, but I see no reason why not use it on all data to prevent SQL injection attacks. Note that you have to prepend data with &lt;code&gt;0x&lt;/code&gt; or use the MySQL function &lt;code&gt;UNHEX&lt;/code&gt; instead.&lt;/p&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;So, for example, the query:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;SELECT&lt;/span&gt; password &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; users &lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; name &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;root&apos;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Will become:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;SELECT&lt;/span&gt; password &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; users &lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; name &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0x726f6f74&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;SELECT&lt;/span&gt; password &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; users &lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; name &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; UNHEX(&lt;span class=&quot;hljs-string&quot;&gt;&apos;726f6f74&apos;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Hex is the perfect escape. No way to inject.&lt;/p&gt;\n\n&lt;h2&gt;Difference between UNHEX function and 0x prefix&lt;/h2&gt;\n\n&lt;p&gt;There was some discussion in comments, so I finally want to make it clear. These two approaches are very similar, but they are a little different in some ways:&lt;/p&gt;\n\n&lt;p&gt;The &lt;code&gt;0x&lt;/code&gt; prefix can only be used for data columns such as &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;block&lt;/code&gt;, &lt;code&gt;binary&lt;/code&gt;, etc.&lt;br&gt;\nAlso, its use is a little complicated if you are about to insert an empty string. You&apos;ll have to entirely replace it with &lt;code&gt;&apos;&apos;&lt;/code&gt;, or you&apos;ll get an error.&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;UNHEX()&lt;/code&gt; works on &lt;strong&gt;any&lt;/strong&gt; column; you do not have to worry about the empty string.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;h2&gt;Hex methods are often used as attacks&lt;/h2&gt;\n\n&lt;p&gt;Note that this hex method is often used as an SQL injection attack where integers are just like strings and escaped just with &lt;code&gt;mysql_real_escape_string&lt;/code&gt;. Then you can avoid the use of quotes.&lt;/p&gt;\n\n&lt;p&gt;For example, if you just do something like this:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;SELECT title FROM article WHERE id = &quot;&lt;/span&gt; . mysql_real_escape_string(&lt;span class=&quot;hljs-variable&quot;&gt;$_GET&lt;/span&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&quot;id&quot;&lt;/span&gt;])\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;an attack can inject you very &lt;em&gt;easily&lt;/em&gt;. Consider the following injected code returned from your script:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;SELECT&lt;/span&gt; ... &lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; id &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;UNION&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;ALL&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;SELECT&lt;/span&gt; table_name &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; information_schema.tables;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and now just extract table structure:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;SELECT&lt;/span&gt; ... &lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; id &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;UNION&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;ALL&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;SELECT&lt;/span&gt; column_name &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; information_schema.column &lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; table_name &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; __0x61727469636c65__;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And then just select whatever data ones want. Isn&apos;t it cool?&lt;/p&gt;\n\n&lt;p&gt;But if the coder of an injectable site would hex it, no injection would be possible because the query would look like this:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;SELECT&lt;/span&gt; ... &lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; id &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; UNHEX(&lt;span class=&quot;hljs-string&quot;&gt;&apos;2d312075...3635&apos;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;blockquote&gt;\n  &lt;p&gt;&lt;strong&gt;Deprecated Warning:&lt;/strong&gt;\n  This answer&apos;s sample code (like the question&apos;s sample code) uses PHP&apos;s &lt;code&gt;MySQL&lt;/code&gt; extension, which was deprecated in PHP 5.5.0 and removed entirely in PHP 7.0.0.&lt;/p&gt;\n  \n  &lt;p&gt;&lt;strong&gt;Security Warning&lt;/strong&gt;: This answer is not in line with security best practices. &lt;a href=&quot;https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide&quot; rel=&quot;noreferrer&quot;&gt;Escaping is inadequate to prevent SQL injection&lt;/a&gt;, use &lt;em&gt;prepared statements&lt;/em&gt; instead. Use the strategy outlined below at your own risk. (Also, &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; was removed in PHP 7.)&lt;/p&gt;\n  \n  &lt;p&gt;&lt;strong&gt;IMPORTANT&lt;/strong&gt;&lt;/p&gt;\n  \n  &lt;p&gt;The best way to prevent SQL Injection is to use &lt;strong&gt;Prepared Statements&lt;/strong&gt; &lt;em&gt;instead of escaping&lt;/em&gt;, as &lt;a href=&quot;https://stackoverflow.com/a/60496/2224584&quot;&gt;the accepted answer&lt;/a&gt; demonstrates. &lt;/p&gt;\n  \n  &lt;p&gt;There are libraries such as &lt;a href=&quot;https://github.com/auraphp/Aura.Sql&quot; rel=&quot;noreferrer&quot;&gt;Aura.Sql&lt;/a&gt; and &lt;a href=&quot;https://github.com/paragonie/easydb&quot; rel=&quot;noreferrer&quot;&gt;EasyDB&lt;/a&gt; that allow developers to use prepared statements easier. To learn more about why prepared statements are better at &lt;a href=&quot;https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide&quot; rel=&quot;noreferrer&quot;&gt;stopping SQL injection&lt;/a&gt;, refer to &lt;a href=&quot;https://stackoverflow.com/a/12118602/2224584&quot;&gt;this &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; bypass&lt;/a&gt; and &lt;a href=&quot;https://kraft.im/2015/05/how-emoji-saved-your-sites-hide/&quot; rel=&quot;noreferrer&quot;&gt;recently fixed Unicode SQL Injection vulnerabilities in WordPress&lt;/a&gt;.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Injection prevention - &lt;a href=&quot;http://php.net/manual/en/function.mysql-real-escape-string.php&quot; rel=&quot;noreferrer&quot;&gt;mysql_real_escape_string()&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;PHP has a specially-made function to prevent these attacks. All you need to do is use the mouthful of a function, &lt;code&gt;mysql_real_escape_string&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;mysql_real_escape_string&lt;/code&gt; takes a string that is going to be used in a MySQL query and return the same string with all SQL injection attempts safely escaped. Basically, it will replace those troublesome quotes(&apos;) a user might enter with a MySQL-safe substitute, an escaped quote \\&apos;.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; you must be connected to the database to use this function!&lt;/p&gt;\n\n&lt;p&gt;// Connect to MySQL&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$name_bad&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&quot;&apos; OR 1&apos;&quot;&lt;/span&gt;; \n\n&lt;span class=&quot;hljs-variable&quot;&gt;$name_bad&lt;/span&gt; = mysql_real_escape_string(&lt;span class=&quot;hljs-variable&quot;&gt;$name_bad&lt;/span&gt;);\n\n&lt;span class=&quot;hljs-variable&quot;&gt;$query_bad&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&quot;SELECT * FROM customers WHERE username = &apos;&lt;span class=&quot;hljs-variable&quot;&gt;$name_bad&lt;/span&gt;&apos;&quot;&lt;/span&gt;;\n&lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Escaped Bad Injection: &amp;lt;br /&amp;gt;&quot;&lt;/span&gt; . &lt;span class=&quot;hljs-variable&quot;&gt;$query_bad&lt;/span&gt; . &lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;br /&amp;gt;&quot;&lt;/span&gt;;\n\n\n&lt;span class=&quot;hljs-variable&quot;&gt;$name_evil&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&quot;&apos;; DELETE FROM customers WHERE 1 or username = &apos;&quot;&lt;/span&gt;; \n\n&lt;span class=&quot;hljs-variable&quot;&gt;$name_evil&lt;/span&gt; = mysql_real_escape_string(&lt;span class=&quot;hljs-variable&quot;&gt;$name_evil&lt;/span&gt;);\n\n&lt;span class=&quot;hljs-variable&quot;&gt;$query_evil&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&quot;SELECT * FROM customers WHERE username = &apos;&lt;span class=&quot;hljs-variable&quot;&gt;$name_evil&lt;/span&gt;&apos;&quot;&lt;/span&gt;;\n&lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Escaped Evil Injection: &amp;lt;br /&amp;gt;&quot;&lt;/span&gt; . &lt;span class=&quot;hljs-variable&quot;&gt;$query_evil&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You can find more details in &lt;em&gt;&lt;a href=&quot;http://www.tizag.com/mysqlTutorial/mysql-php-sql-injection.php&quot; rel=&quot;noreferrer&quot;&gt;MySQL - SQL Injection Prevention&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;\n    ","\n&lt;blockquote&gt;\n&lt;p&gt;&lt;strong&gt;Security Warning&lt;/strong&gt;: This answer is not in line with security best practices. &lt;a href=&quot;https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide&quot; rel=&quot;nofollow noreferrer&quot;&gt;Escaping is inadequate to prevent SQL injection&lt;/a&gt;, use &lt;em&gt;prepared statements&lt;/em&gt; instead. Use the strategy outlined below at your own risk.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;You could do something basic like this:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$safe_variable&lt;/span&gt; = mysqli_real_escape_string(&lt;span class=&quot;hljs-variable&quot;&gt;$_POST&lt;/span&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&quot;user-input&quot;&lt;/span&gt;], &lt;span class=&quot;hljs-variable&quot;&gt;$dbConnection&lt;/span&gt;);\nmysqli_query(&lt;span class=&quot;hljs-variable&quot;&gt;$dbConnection&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;INSERT INTO table (column) VALUES (&apos;&quot;&lt;/span&gt; . &lt;span class=&quot;hljs-variable&quot;&gt;$safe_variable&lt;/span&gt; . &lt;span class=&quot;hljs-string&quot;&gt;&quot;&apos;)&quot;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This won&apos;t solve every problem, but it&apos;s a very good stepping stone. I left out obvious items such as checking the variable&apos;s existence, format (numbers, letters, etc.).&lt;/p&gt;\n    ","\n&lt;p&gt;Whatever you do end up using, make sure that you check your input hasn&apos;t already been mangled by &lt;code&gt;magic_quotes&lt;/code&gt; or some other well-meaning rubbish, and if necessary, run it through &lt;code&gt;stripslashes&lt;/code&gt; or whatever to sanitize it.&lt;/p&gt;\n    ","\n&lt;blockquote&gt;\n  &lt;p&gt;&lt;strong&gt;Deprecated Warning:&lt;/strong&gt;\n  This answer&apos;s sample code (like the question&apos;s sample code) uses PHP&apos;s &lt;code&gt;MySQL&lt;/code&gt; extension, which was deprecated in PHP 5.5.0 and removed entirely in PHP 7.0.0.&lt;/p&gt;\n  \n  &lt;p&gt;&lt;strong&gt;Security Warning&lt;/strong&gt;: This answer is not in line with security best practices. &lt;a href=&quot;https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide&quot; rel=&quot;noreferrer&quot;&gt;Escaping is inadequate to prevent SQL injection&lt;/a&gt;, use &lt;em&gt;prepared statements&lt;/em&gt; instead. Use the strategy outlined below at your own risk. (Also, &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; was removed in PHP 7.)&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Parameterized query AND input validation is the way to go. There are many scenarios under which SQL injection may occur, even though &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; has been used.&lt;/p&gt;\n\n&lt;p&gt;Those examples are vulnerable to SQL injection:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$offset&lt;/span&gt; = &lt;span class=&quot;hljs-keyword&quot;&gt;isset&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$_GET&lt;/span&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&apos;o&apos;&lt;/span&gt;]) ? &lt;span class=&quot;hljs-variable&quot;&gt;$_GET&lt;/span&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&apos;o&apos;&lt;/span&gt;] : &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n&lt;span class=&quot;hljs-variable&quot;&gt;$offset&lt;/span&gt; = &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;mysql_real_escape_string&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$offset&lt;/span&gt;);\n&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;RunQuery&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;SELECT userid, username FROM sql_injection_test LIMIT &lt;span class=&quot;hljs-subst&quot;&gt;$offset&lt;/span&gt;, 10&quot;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$order&lt;/span&gt; = &lt;span class=&quot;hljs-keyword&quot;&gt;isset&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$_GET&lt;/span&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&apos;o&apos;&lt;/span&gt;]) ? &lt;span class=&quot;hljs-variable&quot;&gt;$_GET&lt;/span&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&apos;o&apos;&lt;/span&gt;] : &lt;span class=&quot;hljs-string&quot;&gt;&apos;userid&apos;&lt;/span&gt;;\n&lt;span class=&quot;hljs-variable&quot;&gt;$order&lt;/span&gt; = &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;mysql_real_escape_string&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$order&lt;/span&gt;);\n&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;RunQuery&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;SELECT userid, username FROM sql_injection_test ORDER BY `&lt;span class=&quot;hljs-subst&quot;&gt;$order&lt;/span&gt;`&quot;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In both cases, you can&apos;t use &lt;code&gt;&apos;&lt;/code&gt; to protect the encapsulation.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://www.webappsec.org/projects/articles/091007.txt&quot; rel=&quot;noreferrer&quot;&gt;Source&lt;/a&gt;: &lt;em&gt;The Unexpected SQL Injection (When Escaping Is Not Enough)&lt;/em&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;In my opinion, the best way to generally prevent SQL injection in your PHP application (or any web application, for that matter) is to think about your application&apos;s architecture. If the only way to protect against SQL injection is to remember to use a special method or function that does The Right Thing every time you talk to the database, you are doing it wrong. That way, it&apos;s just a matter of time until you forget to correctly format your query at some point in your code.&lt;/p&gt;\n\n&lt;p&gt;Adopting the MVC pattern and a framework like &lt;a href=&quot;http://cakephp.org/&quot; rel=&quot;noreferrer&quot;&gt;CakePHP&lt;/a&gt; or &lt;a href=&quot;http://codeigniter.com/&quot; rel=&quot;noreferrer&quot;&gt;CodeIgniter&lt;/a&gt; is probably the right way to go: Common tasks like creating secure database queries have been solved and centrally implemented in such frameworks. They help you to organize your web application in a sensible way and make you think more about loading and saving objects than about securely constructing single SQL queries. &lt;/p&gt;\n    ","\n&lt;p&gt;There are many ways of preventing SQL injections and other SQL hacks. You can easily find it on the Internet (Google Search). Of course &lt;strong&gt;PDO is one of the good solutions.&lt;/strong&gt; But I would like to suggest you some good links prevention from SQL injection.&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;a href=&quot;http://www.tizag.com/mysqlTutorial/mysql-php-sql-injection.php&quot; rel=&quot;noreferrer&quot;&gt;What is SQL injection and how to prevent&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://php.net/manual/en/security.database.sql-injection.php&quot; rel=&quot;noreferrer&quot;&gt;PHP manual for SQL injection&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://docs.microsoft.com/en-gb/archive/blogs/brian_swan/whats-the-right-way-to-prevent-sql-injection-in-php-scripts&quot; rel=&quot;noreferrer&quot;&gt;Microsoft explanation of SQL injection and prevention in PHP&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;And some other like &lt;em&gt;&lt;a href=&quot;https://web.archive.org/web/20190221025712/http://www.digifuzz.net/archives/2007/07/preventing-sql-injection-with-php/&quot; rel=&quot;noreferrer&quot;&gt;Preventing SQL injection with MySQL and PHP&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;\n\n&lt;p&gt;Now, &lt;strong&gt;why you do you need to prevent your query from SQL injection?&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;I would like to let you know: Why do we try for preventing SQL injection with a short example below:&lt;/p&gt;\n\n&lt;p&gt;Query for login authentication match:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$query&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;select * from users where email=&apos;&quot;&lt;/span&gt;.&lt;span class=&quot;hljs-variable&quot;&gt;$_POST&lt;/span&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&apos;email&apos;&lt;/span&gt;].&lt;span class=&quot;hljs-string&quot;&gt;&quot;&apos; and password=&apos;&quot;&lt;/span&gt;.&lt;span class=&quot;hljs-variable&quot;&gt;$_POST&lt;/span&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&apos;password&apos;&lt;/span&gt;].&lt;span class=&quot;hljs-string&quot;&gt;&quot;&apos; &quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Now, if someone (a hacker) puts&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-perl&quot;&gt;$_POST[&lt;span class=&quot;hljs-string&quot;&gt;&apos;email&apos;&lt;/span&gt;]= admin@emali.com&lt;span class=&quot;hljs-string&quot;&gt;&apos; OR &apos;&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and password anything....&lt;/p&gt;\n\n&lt;p&gt;The query will be parsed into the system only up to:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-perl&quot;&gt;$query=&lt;span class=&quot;hljs-string&quot;&gt;&quot;select * from users where email=&apos;admin@emali.com&apos; OR &apos;1=1&apos;;\n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The other part will be discarded. So, what will happen? A non-authorized user (hacker) will be able to log in as administrator without having his/her password. Now, he/she can do anything that the administrator/email person can do. See, it&apos;s very dangerous if SQL injection is not prevented.&lt;/p&gt;\n    ","\n&lt;p&gt;I favor &lt;a href=&quot;http://en.wikipedia.org/wiki/Stored_procedure&quot; rel=&quot;noreferrer&quot;&gt;stored procedures&lt;/a&gt; (&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/stored-routines-syntax.html&quot; rel=&quot;noreferrer&quot;&gt;MySQL has had stored procedures support since 5.0&lt;/a&gt;) from a security point of view - the advantages are -&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;Most databases (including &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/stored-routines-privileges.html&quot; rel=&quot;noreferrer&quot;&gt;MySQL&lt;/a&gt;) enable user access to be restricted to executing stored procedures. The fine-grained security access control is useful to prevent escalation of privileges attacks. This prevents compromised applications from being able to run SQL directly against the database.&lt;/li&gt;\n&lt;li&gt;They abstract the raw SQL query from the application so less information of the database structure is available to the application. This makes it harder for people to understand the underlying structure of the database and design suitable attacks.&lt;/li&gt;\n&lt;li&gt;They accept only parameters, so the advantages of parameterized queries are there. Of course - IMO you still need to sanitize your input - especially if you are using dynamic SQL inside the stored procedure.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;The disadvantages are -&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;They (stored procedures) are tough to maintain and tend to multiply very quickly. This makes managing them an issue.&lt;/li&gt;\n&lt;li&gt;They are not very suitable for dynamic queries - if they are built to accept dynamic code as parameters then a lot of the advantages are negated.&lt;/li&gt;\n&lt;/ol&gt;\n    ","\n&lt;p&gt;I think if someone wants to use PHP and MySQL or some other dataBase server:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Think about learning &lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot; rel=&quot;nofollow noreferrer&quot;&gt;PDO&lt;/a&gt; (PHP Data Objects)  it is a database access layer providing a uniform method of access to multiple databases.&lt;/li&gt;\n&lt;li&gt;Think about learning &lt;a href=&quot;http://en.wikipedia.org/wiki/MySQLi&quot; rel=&quot;nofollow noreferrer&quot;&gt;MySQLi&lt;/a&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;hr&gt;\n&lt;p&gt;&lt;strong&gt;Libraries examples:&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;---- &lt;strong&gt;PDO&lt;/strong&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;----- No placeholders - ripe for SQL injection! &lt;strong&gt;It&apos;s bad&lt;/strong&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$request&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$pdoConnection&lt;/span&gt;-&amp;gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;INSERT INTO parents (name, addr, city) values (&lt;span class=&quot;hljs-variable&quot;&gt;$name&lt;/span&gt;, &lt;span class=&quot;hljs-variable&quot;&gt;$addr&lt;/span&gt;, &lt;span class=&quot;hljs-variable&quot;&gt;$city&lt;/span&gt;)&quot;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;----- Unnamed placeholders&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$request&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$pdoConnection&lt;/span&gt;-&amp;gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;INSERT INTO parents (name, addr, city) values (?, ?, ?);\n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;----- Named placeholders&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$request&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$pdoConnection&lt;/span&gt;-&amp;gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;INSERT INTO parents (name, addr, city) value (:name, :addr, :city)&quot;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;--- &lt;strong&gt;MySQLi&lt;/strong&gt;&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-perl&quot;&gt;$request = $mysqliConnection-&amp;gt;prepare(&lt;span class=&quot;hljs-string&quot;&gt;&apos;\n       SELECT * FROM trainers\n       WHERE name = ?\n       AND email = ?\n       AND last_login &amp;gt; ?&apos;&lt;/span&gt;);\n\n    $query-&amp;gt;bind_param(&lt;span class=&quot;hljs-string&quot;&gt;&apos;first_param&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;second_param&apos;&lt;/span&gt;, $mail, &lt;span class=&quot;hljs-keyword&quot;&gt;time&lt;/span&gt;() - &lt;span class=&quot;hljs-number&quot;&gt;3600&lt;/span&gt;);\n    $query-&amp;gt;execute();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;hr&gt;\n&lt;p&gt;&lt;strong&gt;P.S&lt;/strong&gt;:&lt;/p&gt;\n&lt;p&gt;PDO wins this battle with ease. With support for twelve\ndifferent database drivers and named parameters, we can get used to its API. From a security standpoint, both of them are safe as long as the developer uses them the way they are supposed to be used&lt;/p&gt;\n    ","\n&lt;p&gt;If possible, cast the types of your parameters. But it&apos;s only working on simple types like int, bool, and float.&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$unsafe_variable&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$_POST&lt;/span&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&apos;user_id&apos;&lt;/span&gt;];\n\n&lt;span class=&quot;hljs-variable&quot;&gt;$safe_variable&lt;/span&gt; = (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;)&lt;span class=&quot;hljs-variable&quot;&gt;$unsafe_variable&lt;/span&gt; ;\n\n&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;mysqli_query&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$conn&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;INSERT INTO table (column) VALUES (&apos;&quot;&lt;/span&gt; . &lt;span class=&quot;hljs-variable&quot;&gt;$safe_variable&lt;/span&gt; . &lt;span class=&quot;hljs-string&quot;&gt;&quot;&apos;)&quot;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;If you want to take advantage of cache engines, like &lt;a href=&quot;http://en.wikipedia.org/wiki/Redis_%28data_store%29&quot; rel=&quot;noreferrer&quot;&gt;Redis&lt;/a&gt; or &lt;a href=&quot;http://en.wikipedia.org/wiki/Memcached&quot; rel=&quot;noreferrer&quot;&gt;Memcached&lt;/a&gt;, maybe DALMP could be a choice. It uses pure &lt;a href=&quot;http://en.wikipedia.org/wiki/MySQLi&quot; rel=&quot;noreferrer&quot;&gt;MySQLi&lt;/a&gt;. Check this: &lt;a href=&quot;http://dalmp.readthedocs.org/en/latest/database/PExecute.html&quot; rel=&quot;noreferrer&quot;&gt;DALMP Database Abstraction Layer for MySQL using PHP.&lt;/a&gt; &lt;/p&gt;\n\n&lt;p&gt;Also, you can &apos;prepare&apos; your arguments before preparing your query so that you can build dynamic queries and at the end have a fully prepared statements query. &lt;a href=&quot;http://dalmp.readthedocs.org/en/latest/database/Prepare.html&quot; rel=&quot;noreferrer&quot;&gt;DALMP Database Abstraction Layer for MySQL using PHP.&lt;/a&gt; &lt;/p&gt;\n    ","\n&lt;p&gt;For those unsure of how to use PDO (coming from the &lt;code&gt;mysql_&lt;/code&gt; functions), I made a &lt;a href=&quot;https://github.com/Xeoncross/DByte/blob/master/DByte/DB.php&quot; rel=&quot;nofollow noreferrer&quot;&gt;very, very simple PDO wrapper&lt;/a&gt; that is a single file. It exists to show how easy it is to do all the common things applications need to be done. Works with PostgreSQL, MySQL, and SQLite.&lt;/p&gt;\n&lt;p&gt;Basically, read it &lt;a href=&quot;http://php.net/pdo&quot; rel=&quot;nofollow noreferrer&quot;&gt;while you read the manual&lt;/a&gt; to see how to put the PDO functions to use in real life to make it simple to store and retrieve values in the format &lt;strong&gt;you&lt;/strong&gt; want.&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;strong&gt;I want a single column&lt;/strong&gt;&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-ruby&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$count&lt;/span&gt; = &lt;span class=&quot;hljs-variable constant_&quot;&gt;DB&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:column&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;SELECT COUNT(*) FROM `user`&apos;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;I want an array(key =&amp;gt; value) results (i.e. for making a selectbox)&lt;/strong&gt;&lt;/p&gt;\n&lt;pre class=&quot;lang-php s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$pairs&lt;/span&gt; = DB::&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;pairs&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;SELECT `id`, `username` FROM `user`&apos;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;I want a single row result&lt;/strong&gt;&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$user&lt;/span&gt; = DB::&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;row&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;SELECT * FROM `user` WHERE `id` = ?&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;array&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$user_id&lt;/span&gt;));\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;I want an array of results&lt;/strong&gt;&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$banned_users&lt;/span&gt; = DB::&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;fetch&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;SELECT * FROM `user` WHERE `banned` = ?&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;array&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;TRUE&apos;&lt;/span&gt;));\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;blockquote&gt;\n&lt;p&gt;&lt;strong&gt;Security Warning&lt;/strong&gt;: This answer is not in line with security best practices. &lt;a href=&quot;https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide&quot; rel=&quot;nofollow noreferrer&quot;&gt;Escaping is inadequate to prevent SQL injection&lt;/a&gt;, use &lt;em&gt;prepared statements&lt;/em&gt; instead.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;A few guidelines for escaping special characters in SQL statements.&lt;/p&gt;\n&lt;p&gt;Don&apos;t use &lt;a href=&quot;http://www.php.net/manual/en/intro.mysql.php&quot; rel=&quot;nofollow noreferrer&quot;&gt;MySQL&lt;/a&gt;. This extension is deprecated. Use &lt;a href=&quot;http://php.net/manual/en/book.mysqli.php&quot; rel=&quot;nofollow noreferrer&quot;&gt;MySQLi&lt;/a&gt; or &lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot; rel=&quot;nofollow noreferrer&quot;&gt;PDO&lt;/a&gt; instead.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;MySQLi&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;For manually escaping special characters in a string you can use the &lt;a href=&quot;http://www.php.net/manual/en/mysqli.real-escape-string.php&quot; rel=&quot;nofollow noreferrer&quot;&gt;mysqli_real_escape_string&lt;/a&gt; function. The function will not work properly unless the correct character set is set with &lt;a href=&quot;http://www.php.net/manual/en/mysqli.set-charset.php&quot; rel=&quot;nofollow noreferrer&quot;&gt;mysqli_set_charset&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;Example:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$mysqli&lt;/span&gt; = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;mysqli&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;host&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;user&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;password&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;database&apos;&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$mysqli&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;set_charset&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;charset&apos;&lt;/span&gt;);\n\n&lt;span class=&quot;hljs-variable&quot;&gt;$string&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$mysqli&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;real_escape_string&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$string&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$mysqli&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;query&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;INSERT INTO table (column) VALUES (&apos;&lt;span class=&quot;hljs-subst&quot;&gt;$string&lt;/span&gt;&apos;)&quot;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;For automatic escaping of values with prepared statements, use &lt;a href=&quot;http://www.php.net/manual/en/mysqli.prepare.php&quot; rel=&quot;nofollow noreferrer&quot;&gt;mysqli_prepare&lt;/a&gt;, and &lt;a href=&quot;http://www.php.net/manual/en/mysqli-stmt.bind-param.php&quot; rel=&quot;nofollow noreferrer&quot;&gt;mysqli_stmt_bind_param&lt;/a&gt; where types for the corresponding bind variables must be provided for an appropriate conversion:&lt;/p&gt;\n&lt;p&gt;Example:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$mysqli&lt;/span&gt;-&amp;gt;prepare(&lt;span class=&quot;hljs-string&quot;&gt;&quot;INSERT INTO table (column1, column2) VALUES (?,?)&quot;&lt;/span&gt;);\n\n&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt;-&amp;gt;bind_param(&lt;span class=&quot;hljs-string&quot;&gt;&quot;is&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-variable&quot;&gt;$integer&lt;/span&gt;, &lt;span class=&quot;hljs-variable&quot;&gt;$string&lt;/span&gt;);\n\n&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt;-&amp;gt;execute();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;No matter if you use prepared statements or &lt;code&gt;mysqli_real_escape_string&lt;/code&gt;, you always have to know the type of input data you&apos;re working with.&lt;/p&gt;\n&lt;p&gt;So if you use a prepared statement, you must specify the types of the variables for &lt;code&gt;mysqli_stmt_bind_param&lt;/code&gt; function.&lt;/p&gt;\n&lt;p&gt;And the use of &lt;code&gt;mysqli_real_escape_string&lt;/code&gt; is for, as the name says, escaping special characters in a string, so it will not make integers safe. The purpose of this function is to prevent breaking the strings in SQL statements, and the damage to the database that it could cause. &lt;code&gt;mysqli_real_escape_string&lt;/code&gt; is a useful function when used properly, especially when combined with &lt;code&gt;sprintf&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;Example:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$string&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&quot;x&apos; OR name LIKE &apos;%John%&quot;&lt;/span&gt;;\n&lt;span class=&quot;hljs-variable&quot;&gt;$integer&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&apos;5 OR id != 0&apos;&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-variable&quot;&gt;$query&lt;/span&gt; = sprintf( &lt;span class=&quot;hljs-string&quot;&gt;&quot;SELECT id, email, pass, name FROM members WHERE email =&apos;%s&apos; AND id = %d&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-variable&quot;&gt;$mysqli&lt;/span&gt;-&amp;gt;real_escape_string(&lt;span class=&quot;hljs-variable&quot;&gt;$string&lt;/span&gt;), &lt;span class=&quot;hljs-variable&quot;&gt;$integer&lt;/span&gt;);\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$query&lt;/span&gt;;\n// SELECT &lt;span class=&quot;hljs-built_in&quot;&gt;id&lt;/span&gt;, email, pass, name FROM members WHERE email =&lt;span class=&quot;hljs-string&quot;&gt;&apos;x\\&apos;&lt;/span&gt; OR name LIKE \\&lt;span class=&quot;hljs-string&quot;&gt;&apos;%John%&apos;&lt;/span&gt; AND &lt;span class=&quot;hljs-built_in&quot;&gt;id&lt;/span&gt; = 5\n\n&lt;span class=&quot;hljs-variable&quot;&gt;$integer&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&apos;99999999999999999999&apos;&lt;/span&gt;;\n&lt;span class=&quot;hljs-variable&quot;&gt;$query&lt;/span&gt; = sprintf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;SELECT id, email, pass, name FROM members WHERE email =&apos;%s&apos; AND id = %d&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-variable&quot;&gt;$mysqli&lt;/span&gt;-&amp;gt;real_escape_string(&lt;span class=&quot;hljs-variable&quot;&gt;$string&lt;/span&gt;), &lt;span class=&quot;hljs-variable&quot;&gt;$integer&lt;/span&gt;);\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$query&lt;/span&gt;;\n// SELECT &lt;span class=&quot;hljs-built_in&quot;&gt;id&lt;/span&gt;, email, pass, name FROM members WHERE email =&lt;span class=&quot;hljs-string&quot;&gt;&apos;x\\&apos;&lt;/span&gt; OR name LIKE \\&lt;span class=&quot;hljs-string&quot;&gt;&apos;%John%&apos;&lt;/span&gt; AND &lt;span class=&quot;hljs-built_in&quot;&gt;id&lt;/span&gt; = 2147483647\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;blockquote&gt;\n&lt;p&gt;&lt;strong&gt;Security Warning&lt;/strong&gt;: This answer is not in line with security best practices. &lt;a href=&quot;https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide&quot; rel=&quot;nofollow noreferrer&quot;&gt;Escaping is inadequate to prevent SQL injection&lt;/a&gt;, use &lt;em&gt;prepared statements&lt;/em&gt; instead. Use the strategy outlined below at your own risk. (Also, &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; was removed in PHP 7.)&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;: The mysql extension is removed at this time. we recommend using the &lt;em&gt;PDO extension&lt;/em&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Using this PHP function &lt;code&gt;mysql_escape_string()&lt;/code&gt; you can get a good prevention in a fast way.&lt;/p&gt;\n&lt;p&gt;For example:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; users &lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; name &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;&quot;.mysql_escape_string($name_from_html_form).&quot;&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;mysql_escape_string&lt;/code&gt;  Escapes a string for use in a mysql_query&lt;/p&gt;\n&lt;p&gt;For more prevention, you can add at the end ...&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;wHERE&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;   &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt;  LIMIT &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Finally you get:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; users &lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; name &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;&quot;.mysql_escape_string($name_from_html_form).&quot;&apos;&lt;/span&gt; LIMIT &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;The simple alternative to this problem could be solved by granting appropriate permissions in the database itself.\nFor example: if you are using a MySQL database then enter into the database through terminal or the UI provided and just follow this command:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-sql&quot;&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;GRANT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;SELECT&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;INSERT&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;ON&lt;/span&gt; database &lt;span class=&quot;hljs-keyword&quot;&gt;TO&lt;/span&gt; username@&lt;span class=&quot;hljs-string&quot;&gt;&apos;localhost&apos;&lt;/span&gt; IDENTIFIED &lt;span class=&quot;hljs-keyword&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;password&apos;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This will restrict the user to only get confined with the specified query&apos;s only. Remove the delete permission and so the data would never get deleted from the query fired from the PHP page.\nThe second thing to do is to flush the privileges so that the MySQL refreshes the permissions and updates.&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-undefined&quot;&gt;FLUSH PRIVILEGES; \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;more information about &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/flush.html&quot; rel=&quot;noreferrer&quot;&gt;flush&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;To see the current privileges for the user fire the following query.&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; mysql.user &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&apos;username&apos;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Learn more about &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/grant.html&quot; rel=&quot;noreferrer&quot;&gt;GRANT&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;Regarding many useful answers, I hope to add some value to this thread.&lt;/p&gt;\n\n&lt;p&gt;SQL injection is an attack that can be done through user inputs (inputs that filled by a user and then used inside queries). The SQL injection patterns are correct query syntax while we can call it: bad queries for bad reasons, and we assume that there might be a bad person that try to get secret information (bypassing access control) that affect the three principles of security (confidentiality, integrity, and availability).&lt;/p&gt;\n\n&lt;p&gt;Now, our point is to prevent security threats such as SQL injection attacks, the question asking (how to prevent an SQL injection attack using PHP), be more realistic, data filtering or clearing input data is the case when using user-input data inside such query, using PHP or any other programming language is not the case, or as recommended by more people to use modern technology such as prepared statement or any other tools that currently supporting SQL injection prevention, consider that these tools not available anymore? How do you secure your application?&lt;/p&gt;\n\n&lt;p&gt;My approach against SQL injection is: clearing user-input data before sending it to the database (before using it inside any query).&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Data filtering for (converting unsafe data to safe data)&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Consider that &lt;a href=&quot;http://en.wikipedia.org/wiki/PHP#History&quot; rel=&quot;noreferrer&quot;&gt;PDO&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/MySQLi&quot; rel=&quot;noreferrer&quot;&gt;MySQLi&lt;/a&gt; are not available. How can you secure your application? Do you force me to use them? What about other languages other than PHP? I prefer to provide general ideas as it can be used for wider border, not just for a specific language.&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;SQL user (limiting user privilege): most common SQL operations are (SELECT, UPDATE, INSERT), then, why give the UPDATE privilege to a user that does not require it? For example, &lt;strong&gt;login, and search pages&lt;/strong&gt; are only using SELECT, then, why use DB users in these pages with high privileges?&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;&lt;strong&gt;RULE: do not create one database user for all privileges. For all SQL operations, you can create your scheme like (deluser, selectuser, updateuser) as usernames for easy usage.&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;See &lt;a href=&quot;http://en.wikipedia.org/wiki/Principle_of_least_privilege&quot; rel=&quot;noreferrer&quot;&gt;principle of least privilege&lt;/a&gt;.&lt;/p&gt;\n\n&lt;ol start=&quot;2&quot;&gt;\n&lt;li&gt;&lt;p&gt;Data filtering: before building any query user input, it should be validated and filtered. For programmers, it&apos;s important to define some properties for each user-input variables:\n&lt;strong&gt;data type, data pattern, and data length&lt;/strong&gt;. A field that is a number between (x and y) must be exactly validated using the exact rule, and for a field that is a string (text): pattern is the case, for example, a username must contain only some characters, lets say [a-zA-Z0-9_-.]. The length varies between (x and n) where x and n (integers, x &amp;lt;=n).\n&lt;strong&gt;Rule: creating exact filters and validation rules are best practices for me.&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Use other tools: Here, I will also agree with you that a prepared statement (parametrized query) and stored procedures. The disadvantages here is these ways require advanced skills which do not exist for most users. The basic idea here is to distinguish between the SQL query and the data that is used inside. Both approaches can be used even with unsafe data, because the user-input data here does not add anything to the original query, such as (any or x=x).&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;For more information, please read &lt;a href=&quot;https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet&quot; rel=&quot;noreferrer&quot;&gt;OWASP SQL Injection Prevention Cheat Sheet&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;Now, if you are an advanced user, start using this defense as you like, but, for beginners, if they can&apos;t quickly implement a stored procedure and prepared the statement, it&apos;s better to filter input data as much they can.&lt;/p&gt;\n\n&lt;p&gt;Finally, let&apos;s consider that a user sends this text below instead of entering his/her username:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-sql&quot;&gt;[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] &lt;span class=&quot;hljs-keyword&quot;&gt;UNION&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;SELECT&lt;/span&gt; IF(&lt;span class=&quot;hljs-built_in&quot;&gt;SUBSTRING&lt;/span&gt;(Password,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)&lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&apos;2&apos;&lt;/span&gt;,BENCHMARK(&lt;span class=&quot;hljs-number&quot;&gt;100000&lt;/span&gt;,SHA1(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)),&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;User&lt;/span&gt;,Password &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; mysql.user &lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;root&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This input can be checked early without any prepared statement and stored procedures, but to be on the safe side, using them starts after user-data filtering and validation.&lt;/p&gt;\n\n&lt;p&gt;The last point is detecting unexpected behavior which requires more effort and complexity; it&apos;s not recommended for normal web applications.&lt;/p&gt;\n\n&lt;p&gt;Unexpected behavior in the above user input is SELECT, UNION, IF, SUBSTRING, BENCHMARK, SHA, and root. Once these words detected, you can avoid the input.&lt;/p&gt;\n\n&lt;h2&gt;UPDATE 1:&lt;/h2&gt;\n\n&lt;p&gt;A user commented that this post is useless, OK! Here is what &lt;a href=&quot;https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet#Defense_Option_3:_Escaping_All_User_Supplied_Input&quot; rel=&quot;noreferrer&quot;&gt;OWASP.ORG provided&lt;/a&gt;:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Primary defenses: &lt;br&gt;\n   &lt;br&gt;\n      Option #1: Use of Prepared Statements (Parameterized Queries) &lt;br&gt;\n      Option #2: Use of Stored Procedures &lt;br&gt;\n      Option #3: Escaping all User Supplied Input  &lt;br&gt;\n   &lt;br&gt;\n  Additional defenses: &lt;br&gt;\n   &lt;br&gt;\n      Also Enforce: Least Privilege &lt;br&gt;\n      Also Perform: White List Input Validation &lt;br&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;As you may know, claiming an article should be supported by a valid argument, at least by one reference! Otherwise, it&apos;s considered as an attack and a bad claim!&lt;/p&gt;\n\n&lt;h2&gt;Update 2:&lt;/h2&gt;\n\n&lt;p&gt;From the PHP manual, &lt;a href=&quot;http://php.net/manual/en/mysqli.quickstart.prepared-statements.php&quot; rel=&quot;noreferrer&quot;&gt;PHP: Prepared Statements - Manual&lt;/a&gt;:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Escaping and SQL injection &lt;br&gt;&lt;/p&gt;\n  \n  &lt;p&gt;Bound variables will be escaped automatically by the server. The\n  server inserts their escaped values at the appropriate places into the\n  statement template before execution. A hint must be provided to the\n  server for the type of bound variable, to create an appropriate\n  conversion. See the mysqli_stmt_bind_param() function for more\n  information. &lt;br&gt;&lt;/p&gt;\n  \n  &lt;p&gt;The automatic escaping of values within the server is sometimes\n  considered a security feature to prevent SQL injection. The same\n  degree of security can be achieved with non-prepared statements if\n  input values are escaped correctly. &lt;br&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;h2&gt;Update 3:&lt;/h2&gt;\n\n&lt;p&gt;I created test cases for knowing how PDO and MySQLi send the query to the MySQL server when using a prepared statement:&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;PDO:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$user&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&quot;&apos;&apos;1&apos;&apos;&quot;&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// Malicious keyword&lt;/span&gt;\n&lt;span class=&quot;hljs-variable&quot;&gt;$sql&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&apos;SELECT * FROM awa_user WHERE userame =:username&apos;&lt;/span&gt;;\n&lt;span class=&quot;hljs-variable&quot;&gt;$sth&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$dbh&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;prepare&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$sql&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;array&lt;/span&gt;(PDO::&lt;span class=&quot;hljs-variable constant_&quot;&gt;ATTR_CURSOR&lt;/span&gt; =&amp;gt; PDO::&lt;span class=&quot;hljs-variable constant_&quot;&gt;CURSOR_FWDONLY&lt;/span&gt;));\n&lt;span class=&quot;hljs-variable&quot;&gt;$sth&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;execute&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;array&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;:username&apos;&lt;/span&gt; =&amp;gt; &lt;span class=&quot;hljs-variable&quot;&gt;$user&lt;/span&gt;));\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;Query Log:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-sql&quot;&gt;    &lt;span class=&quot;hljs-number&quot;&gt;189&lt;/span&gt; Query &lt;span class=&quot;hljs-keyword&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; awa_user &lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; userame &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&apos;\\&apos;&lt;/span&gt;\\&lt;span class=&quot;hljs-string&quot;&gt;&apos;1\\&apos;&lt;/span&gt;\\&lt;span class=&quot;hljs-string&quot;&gt;&apos;&apos;&lt;/span&gt;\n    &lt;span class=&quot;hljs-number&quot;&gt;189&lt;/span&gt; Quit\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;&lt;strong&gt;MySQLi:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$mysqli&lt;/span&gt;-&amp;gt;prepare(&lt;span class=&quot;hljs-string&quot;&gt;&quot;SELECT * FROM awa_user WHERE username =?&quot;&lt;/span&gt;)) {\n&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt;-&amp;gt;bind_param(&lt;span class=&quot;hljs-string&quot;&gt;&quot;s&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-variable&quot;&gt;$user&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$user&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&quot;&apos;&apos;1&apos;&apos;&quot;&lt;/span&gt;;\n&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt;-&amp;gt;execute();\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;Query Log:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-sql&quot;&gt;    &lt;span class=&quot;hljs-number&quot;&gt;188&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;Prepare&lt;/span&gt;   &lt;span class=&quot;hljs-keyword&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; awa_user &lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; username &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt;?\n    &lt;span class=&quot;hljs-number&quot;&gt;188&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;Execute&lt;/span&gt;   &lt;span class=&quot;hljs-keyword&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; awa_user &lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; username &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&apos;\\&apos;&lt;/span&gt;\\&lt;span class=&quot;hljs-string&quot;&gt;&apos;1\\&apos;&lt;/span&gt;\\&lt;span class=&quot;hljs-string&quot;&gt;&apos;&apos;&lt;/span&gt;\n    &lt;span class=&quot;hljs-number&quot;&gt;188&lt;/span&gt; Quit\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/blockquote&gt;\n\n&lt;h3&gt;It&apos;s clear that a prepared statement is also escaping the data, nothing else.&lt;/h3&gt;\n\n&lt;p&gt;As also mentioned in the above statement,&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;The automatic escaping of values within the server is sometimes considered a security feature to prevent SQL injection. The same degree of security can be achieved with non-prepared statements, if input values are escaped correctly&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Therefore, this proves that data validation such as &lt;code&gt;intval()&lt;/code&gt; is a good idea for integer values before sending any query. In addition, preventing malicious user data before sending the query is &lt;strong&gt;a correct and valid approach&lt;/strong&gt;.&lt;/p&gt;\n\n&lt;p&gt;Please see this question for more detail: &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/18026088/pdo-sends-raw-query-to-mysql-while-mysqli-sends-prepared-query-both-produce-the&quot;&gt;PDO sends raw query to MySQL while Mysqli sends prepared query, both produce the same result&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;References:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;a href=&quot;http://ferruh.mavituna.com/sql-injection-cheatsheet-oku/#UnionInjections&quot; rel=&quot;noreferrer&quot;&gt;SQL Injection Cheat Sheet&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://www.owasp.org/index.php/SQL_Injection&quot; rel=&quot;noreferrer&quot;&gt;SQL Injection&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Information_security&quot; rel=&quot;noreferrer&quot;&gt;Information security&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/security-principles.html&quot; rel=&quot;noreferrer&quot;&gt;Security Principles&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Data_validation&quot; rel=&quot;noreferrer&quot;&gt;Data validation&lt;/a&gt;&lt;/li&gt;\n&lt;/ol&gt;\n    ","\n&lt;blockquote&gt;\n  &lt;p&gt;&lt;strong&gt;Security Warning&lt;/strong&gt;: This answer is not in line with security best practices. &lt;a href=&quot;https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide&quot; rel=&quot;noreferrer&quot;&gt;Escaping is inadequate to prevent SQL injection&lt;/a&gt;, use &lt;em&gt;prepared statements&lt;/em&gt; instead. Use the strategy outlined below at your own risk. (Also, &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; was removed in PHP 7.)&lt;/p&gt;\n  \n  &lt;p&gt;&lt;strong&gt;Deprecated Warning&lt;/strong&gt;: The mysql extension is deprecated at this time. we recommend using the &lt;em&gt;PDO extension&lt;/em&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;I use three different ways to prevent my web application from being vulnerable to SQL injection.&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;Use of &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;, which is a pre-defined function in &lt;a href=&quot;http://en.wikipedia.org/wiki/PHP&quot; rel=&quot;noreferrer&quot;&gt;PHP&lt;/a&gt;, and this code add backslashes to the following characters: &lt;code&gt;\\x00&lt;/code&gt;, &lt;code&gt;\\n&lt;/code&gt;, &lt;code&gt;\\r&lt;/code&gt;, &lt;code&gt;\\&lt;/code&gt;, &lt;code&gt;&apos;&lt;/code&gt;, &lt;code&gt;&quot;&lt;/code&gt; and &lt;code&gt;\\x1a&lt;/code&gt;. Pass the input values as parameters to minimize the chance of SQL injection.&lt;/li&gt;\n&lt;li&gt;The most advanced way is to use PDOs.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;I hope this will help you.&lt;/p&gt;\n\n&lt;p&gt;Consider the following query:&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;$iId = mysql_real_escape_string(&quot;1 OR 1=1&quot;);\n $sSql = &quot;SELECT * FROM table WHERE id = $iId&quot;;&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;mysql_real_escape_string() will not protect here. If you use single quotes (&apos; &apos;) around your variables inside your query is what protects you against this. Here is an solution below for this:&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;$iId = (int) mysql_real_escape_string(&quot;1 OR 1=1&quot;);\n $sSql = &quot;SELECT * FROM table WHERE id = $iId&quot;;&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;This &lt;a href=&quot;https://stackoverflow.com/questions/5741187/sql-injection-that-gets-around-mysql-real-escape-string&quot;&gt;question&lt;/a&gt; has some good answers about this.&lt;/p&gt;\n\n&lt;p&gt;I suggest, using PDO is the best option.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;mysql_real_escape_string()&lt;/code&gt; is deprecated as of PHP 5.5.0. Use either mysqli or PDO.&lt;/p&gt;\n\n&lt;p&gt;An alternative to mysql_real_escape_string() is &lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;mysqli_real_escape_string&lt;/span&gt; ( mysqli &lt;span class=&quot;hljs-variable&quot;&gt;$link&lt;/span&gt; , &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$escapestr&lt;/span&gt; )\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$iId&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$mysqli&lt;/span&gt;-&amp;gt;real_escape_string(&lt;span class=&quot;hljs-string&quot;&gt;&quot;1 OR 1=1&quot;&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$mysqli&lt;/span&gt;-&amp;gt;query(&lt;span class=&quot;hljs-string&quot;&gt;&quot;SELECT * FROM table WHERE id = &lt;span class=&quot;hljs-variable&quot;&gt;$iId&lt;/span&gt;&quot;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;A simple way would be to use a PHP framework like &lt;a href=&quot;http://en.wikipedia.org/wiki/Codeigniter#CodeIgniter&quot; rel=&quot;noreferrer&quot;&gt;CodeIgniter&lt;/a&gt; or &lt;a href=&quot;https://laravel.com/&quot; rel=&quot;noreferrer&quot;&gt;Laravel&lt;/a&gt; which have inbuilt features like filtering and active-record so that you don&apos;t have to worry about these nuances.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Warning: the approach described in this answer only applies to very specific scenarios and isn&apos;t secure since SQL injection attacks do not only rely on being able to inject &lt;code&gt;X=Y&lt;/code&gt;.&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;If the attackers are trying to hack into the form via PHP&apos;s &lt;code&gt;$_GET&lt;/code&gt; variable or with the URL&apos;s query string, you would be able to catch them if they&apos;re not secure.&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;RewriteCond %{QUERY_STRING} ([0-9]+)=([0-9]+)\nRewriteRule ^(.*) ^/track.php\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Because &lt;code&gt;1=1&lt;/code&gt;, &lt;code&gt;2=2&lt;/code&gt;, &lt;code&gt;1=2&lt;/code&gt;, &lt;code&gt;2=1&lt;/code&gt;, &lt;code&gt;1+1=2&lt;/code&gt;, etc... are the common questions to an SQL database of an attacker. Maybe also it&apos;s used by many hacking applications.&lt;/p&gt;\n\n&lt;p&gt;But you must be careful, that you must not rewrite a safe query from your site. The code above is giving you a tip, to rewrite or redirect &lt;em&gt;(it depends on you)&lt;/em&gt; that hacking-specific dynamic query string into a page that will store the attacker&apos;s &lt;a href=&quot;http://en.wikipedia.org/wiki/IP_address&quot; rel=&quot;noreferrer&quot;&gt;IP address&lt;/a&gt;, or EVEN THEIR COOKIES, history, browser, or any other sensitive information, so you can deal with them later by banning their account or contacting authorities.&lt;/p&gt;\n    ","\n&lt;p&gt;A good idea is to use an &lt;a href=&quot;https://en.wikipedia.org/wiki/Object-relational_mapping&quot; rel=&quot;noreferrer&quot;&gt;object-relational mapper&lt;/a&gt; like &lt;a href=&quot;http://j4mie.github.io/idiormandparis/&quot; rel=&quot;noreferrer&quot;&gt;Idiorm&lt;/a&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-rust&quot;&gt;$user = ORM::&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;for_table&lt;/span&gt;(&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;user&lt;/span&gt;&apos;)\n&lt;span class=&quot;hljs-punctuation&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;where_equal&lt;/span&gt;(&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;username&lt;/span&gt;&apos;, &lt;span class=&quot;hljs-symbol&quot;&gt;&apos;j4mie&lt;/span&gt;&apos;)\n&lt;span class=&quot;hljs-punctuation&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;find_one&lt;/span&gt;();\n\n$user&lt;span class=&quot;hljs-punctuation&quot;&gt;-&amp;gt;&lt;/span&gt;first_name = &lt;span class=&quot;hljs-symbol&quot;&gt;&apos;Jamie&lt;/span&gt;&apos;;\n$user&lt;span class=&quot;hljs-punctuation&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;save&lt;/span&gt;();\n\n$tweets = ORM::&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;for_table&lt;/span&gt;(&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;tweet&lt;/span&gt;&apos;)\n    &lt;span class=&quot;hljs-punctuation&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;select&lt;/span&gt;(&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;tweet&lt;/span&gt;.*&apos;)\n    &lt;span class=&quot;hljs-punctuation&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;join&lt;/span&gt;(&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;user&lt;/span&gt;&apos;, &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;array&lt;/span&gt;(\n        &lt;span class=&quot;hljs-symbol&quot;&gt;&apos;user&lt;/span&gt;.id&apos;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;=&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-symbol&quot;&gt;&apos;tweet&lt;/span&gt;.user_id&apos;\n    ))\n    &lt;span class=&quot;hljs-punctuation&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;where_equal&lt;/span&gt;(&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;user&lt;/span&gt;.username&apos;, &lt;span class=&quot;hljs-symbol&quot;&gt;&apos;j4mie&lt;/span&gt;&apos;)\n    &lt;span class=&quot;hljs-punctuation&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;find_many&lt;/span&gt;();\n\n&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;foreach&lt;/span&gt; ($tweets &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; $tweet) {\n    echo $tweet&lt;span class=&quot;hljs-punctuation&quot;&gt;-&amp;gt;&lt;/span&gt;text;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It not only saves you from SQL injections, but from syntax errors too! It also supports collections of models with method chaining to filter or apply actions to multiple results at once and multiple connections.&lt;/p&gt;\n    ","\n&lt;p&gt;There are so many answers for &lt;strong&gt;PHP and MySQL&lt;/strong&gt;, but here is code for &lt;strong&gt;PHP and Oracle&lt;/strong&gt; for preventing SQL injection as well as regular use of oci8 drivers:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$conn&lt;/span&gt; = oci_connect(&lt;span class=&quot;hljs-variable&quot;&gt;$username&lt;/span&gt;, &lt;span class=&quot;hljs-variable&quot;&gt;$password&lt;/span&gt;, &lt;span class=&quot;hljs-variable&quot;&gt;$connection_string&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt; = oci_parse(&lt;span class=&quot;hljs-variable&quot;&gt;$conn&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;UPDATE table SET field = :xx WHERE ID = 123&apos;&lt;/span&gt;);\noci_bind_by_name(&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;:xx&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-variable&quot;&gt;$fieldval&lt;/span&gt;);\noci_execute(&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;blockquote&gt;\n  &lt;p&gt;&lt;strong&gt;Deprecated Warning:&lt;/strong&gt;\n  This answer&apos;s sample code (like the question&apos;s sample code) uses PHP&apos;s &lt;code&gt;MySQL&lt;/code&gt; extension, which was deprecated in PHP 5.5.0 and removed entirely in PHP 7.0.0.&lt;/p&gt;\n  \n  &lt;p&gt;&lt;strong&gt;Security Warning&lt;/strong&gt;: This answer is not in line with security best practices. &lt;a href=&quot;https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide&quot; rel=&quot;noreferrer&quot;&gt;Escaping is inadequate to prevent SQL injection&lt;/a&gt;, use &lt;em&gt;prepared statements&lt;/em&gt; instead. Use the strategy outlined below at your own risk. (Also, &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; was removed in PHP 7.)&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Using &lt;a href=&quot;http://in3.php.net/pdo&quot; rel=&quot;noreferrer&quot;&gt;PDO&lt;/a&gt; and &lt;a href=&quot;http://in3.php.net/mysqli&quot; rel=&quot;noreferrer&quot;&gt;MYSQLi&lt;/a&gt; is a good practice to prevent SQL injections, but if you really want to work with MySQL functions and queries, it would be better to use&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://php.net/manual/en/function.mysql-real-escape-string.php&quot; rel=&quot;noreferrer&quot;&gt;mysql_real_escape_string&lt;/a&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$unsafe_variable&lt;/span&gt; = mysql_real_escape_string(&lt;span class=&quot;hljs-variable&quot;&gt;$_POST&lt;/span&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&apos;user_input&apos;&lt;/span&gt;]);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;There are more abilities to prevent this: like identify - if the input is a string, number, char or array, there are so many inbuilt functions to detect this. Also, it would be better to use these functions to check input data.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://in3.php.net/is_string&quot; rel=&quot;noreferrer&quot;&gt;is_string&lt;/a&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$unsafe_variable&lt;/span&gt; = (is_string(&lt;span class=&quot;hljs-variable&quot;&gt;$_POST&lt;/span&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&apos;user_input&apos;&lt;/span&gt;]) ? &lt;span class=&quot;hljs-variable&quot;&gt;$_POST&lt;/span&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&apos;user_input&apos;&lt;/span&gt;] : &lt;span class=&quot;hljs-string&quot;&gt;&apos;&apos;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://in3.php.net/manual/en/function.is-numeric.php&quot; rel=&quot;noreferrer&quot;&gt;is_numeric&lt;/a&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$unsafe_variable&lt;/span&gt; = (is_numeric(&lt;span class=&quot;hljs-variable&quot;&gt;$_POST&lt;/span&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&apos;user_input&apos;&lt;/span&gt;]) ? &lt;span class=&quot;hljs-variable&quot;&gt;$_POST&lt;/span&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&apos;user_input&apos;&lt;/span&gt;] : &lt;span class=&quot;hljs-string&quot;&gt;&apos;&apos;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And it is so much better to use those functions to check input data with &lt;code&gt;mysql_real_escape_string&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;I&apos;ve written this little function several years ago:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;sqlvprintf&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$query&lt;/span&gt;, &lt;span class=&quot;hljs-variable&quot;&gt;$args&lt;/span&gt;&lt;/span&gt;)\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$DB_LINK&lt;/span&gt;;\n    &lt;span class=&quot;hljs-variable&quot;&gt;$ctr&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n    &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;ensureConnection&lt;/span&gt;(); &lt;span class=&quot;hljs-comment&quot;&gt;// Connect to database if not connected already.&lt;/span&gt;\n    &lt;span class=&quot;hljs-variable&quot;&gt;$values&lt;/span&gt; = &lt;span class=&quot;hljs-keyword&quot;&gt;array&lt;/span&gt;();\n    &lt;span class=&quot;hljs-keyword&quot;&gt;foreach&lt;/span&gt; (&lt;span class=&quot;hljs-variable&quot;&gt;$args&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$value&lt;/span&gt;)\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;is_string&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$value&lt;/span&gt;))\n        {\n            &lt;span class=&quot;hljs-variable&quot;&gt;$value&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&quot;&apos;&quot;&lt;/span&gt; . &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;mysqli_real_escape_string&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$DB_LINK&lt;/span&gt;, &lt;span class=&quot;hljs-variable&quot;&gt;$value&lt;/span&gt;) . &lt;span class=&quot;hljs-string&quot;&gt;&quot;&apos;&quot;&lt;/span&gt;;\n        }\n        &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;is_null&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$value&lt;/span&gt;))\n        {\n            &lt;span class=&quot;hljs-variable&quot;&gt;$value&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&apos;NULL&apos;&lt;/span&gt;;\n        }\n        &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;is_int&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$value&lt;/span&gt;) &amp;amp;&amp;amp; !&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;is_float&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$value&lt;/span&gt;))\n        {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;die&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Only numeric, string, array and NULL arguments allowed in a query. Argument &apos;&lt;/span&gt;.(&lt;span class=&quot;hljs-variable&quot;&gt;$ctr&lt;/span&gt;+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;).&lt;span class=&quot;hljs-string&quot;&gt;&apos; is not a basic type, it\\&apos;s type is &apos;&lt;/span&gt;. &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;gettype&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$value&lt;/span&gt;). &lt;span class=&quot;hljs-string&quot;&gt;&apos;.&apos;&lt;/span&gt;);\n        }\n        &lt;span class=&quot;hljs-variable&quot;&gt;$values&lt;/span&gt;[] = &lt;span class=&quot;hljs-variable&quot;&gt;$value&lt;/span&gt;;\n        &lt;span class=&quot;hljs-variable&quot;&gt;$ctr&lt;/span&gt;++;\n    }\n    &lt;span class=&quot;hljs-variable&quot;&gt;$query&lt;/span&gt; = &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;preg_replace_callback&lt;/span&gt;(\n        &lt;span class=&quot;hljs-string&quot;&gt;&apos;/{(\\\\d+)}/&apos;&lt;/span&gt;, \n        function(&lt;span class=&quot;hljs-variable&quot;&gt;$match&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; ($&lt;span class=&quot;hljs-title&quot;&gt;values&lt;/span&gt;)\n        {\n            &lt;span class=&quot;hljs-title&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-title&quot;&gt;isset&lt;/span&gt;($&lt;span class=&quot;hljs-title&quot;&gt;values&lt;/span&gt;[$&lt;span class=&quot;hljs-title&quot;&gt;match&lt;/span&gt;[1]]))\n            {\n                &lt;span class=&quot;hljs-title&quot;&gt;return&lt;/span&gt; $&lt;span class=&quot;hljs-title&quot;&gt;values&lt;/span&gt;[$&lt;span class=&quot;hljs-title&quot;&gt;match&lt;/span&gt;[1]];\n            }\n            &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;\n            {\n                &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$match&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;];\n            }\n        },\n        &lt;span class=&quot;hljs-variable&quot;&gt;$query&lt;/span&gt;\n    );\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$query&lt;/span&gt;;\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;runEscapedQuery&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$preparedQuery&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;/*, ...*/&lt;/span&gt;&lt;/span&gt;)\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-variable&quot;&gt;$params&lt;/span&gt; = &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;array_slice&lt;/span&gt;(&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;func_get_args&lt;/span&gt;(), &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);\n    &lt;span class=&quot;hljs-variable&quot;&gt;$results&lt;/span&gt; = &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;runQuery&lt;/span&gt;(&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;sqlvprintf&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$preparedQuery&lt;/span&gt;, &lt;span class=&quot;hljs-variable&quot;&gt;$params&lt;/span&gt;)); &lt;span class=&quot;hljs-comment&quot;&gt;// Run query and fetch results.   &lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$results&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This allows running statements in an one-liner C#-ish String.Format like:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;runEscapedQuery(&lt;span class=&quot;hljs-string&quot;&gt;&quot;INSERT INTO Whatever (id, foo, bar) VALUES ({0}, {1}, {2})&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-variable&quot;&gt;$numericVar&lt;/span&gt;, &lt;span class=&quot;hljs-variable&quot;&gt;$stringVar1&lt;/span&gt;, &lt;span class=&quot;hljs-variable&quot;&gt;$stringVar2&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It escapes considering the variable type. If you try to parameterize table, column names, it would fail as it puts every string in quotes which is an invalid syntax.&lt;/p&gt;\n\n&lt;p&gt;SECURITY UPDATE: The previous &lt;code&gt;str_replace&lt;/code&gt; version allowed injections by adding {#} tokens into user data. This &lt;code&gt;preg_replace_callback&lt;/code&gt; version doesn&apos;t cause problems if the replacement contains these tokens.&lt;/p&gt;\n    "]},"randomTags":[{"name":"raw-types","slug":"raw-types"},{"name":"node.js","slug":"node.js"},{"name":"virtual-destructor","slug":"virtual-destructor"},{"name":"http-status-code-301","slug":"http-status-code-301"},{"name":"precision","slug":"precision"},{"name":"listview","slug":"listview"},{"name":"protected","slug":"protected"},{"name":"python","slug":"python"},{"name":"javascript","slug":"javascript"},{"name":"instance-variables","slug":"instance-variables"},{"name":"dynamic-variables","slug":"dynamic-variables"},{"name":"cors","slug":"cors"},{"name":"return-type","slug":"return-type"},{"name":"quoting","slug":"quoting"},{"name":"copy-paste","slug":"copy-paste"},{"name":"object-comparison","slug":"object-comparison"},{"name":"content-script","slug":"content-script"},{"name":"email","slug":"email"},{"name":"utf-8","slug":"utf-8"},{"name":"sleep","slug":"sleep"}]},"__N_SSG":true}