{"pageProps":{"data":{"count":1,"rows":[{"id":140,"title":"What is the strict aliasing rule?","slug":"what-is-the-strict-aliasing-rule-1657384742852","postType":"QUESTION","createdAt":"2022-07-09T16:39:02.000Z","updatedAt":"2022-07-09T16:39:02.000Z","tags":[{"id":511,"name":"strict-aliasing","slug":"strict-aliasing","createdAt":"2022-07-09T16:39:02.000Z","updatedAt":"2022-07-09T16:39:02.000Z","Questions_Tags":{"questionId":140,"tagId":511}}]}]},"slug":"strict-aliasing","page":"1","answers":{"140":["\n&lt;p&gt;A typical situation where you encounter strict aliasing problems is when overlaying a struct (like a device/network msg) onto a buffer of the word size of your system (like a pointer to &lt;code&gt;uint32_t&lt;/code&gt;s or &lt;code&gt;uint16_t&lt;/code&gt;s). When you overlay a struct onto such a buffer, or a buffer onto such a struct through pointer casting you can easily violate strict aliasing rules.&lt;/p&gt;\n&lt;p&gt;So in this kind of setup, if I want to send a message to something I&apos;d have to have two incompatible pointers pointing to the same chunk of memory. I might then naively code something like this:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Msg&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a;\n    &lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b;\n} Msg;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;SendWord&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;uint32_t&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Get a 32-bit buffer from the system&lt;/span&gt;\n    &lt;span class=&quot;hljs-type&quot;&gt;uint32_t&lt;/span&gt;* buff = &lt;span class=&quot;hljs-built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;(Msg));\n    \n    &lt;span class=&quot;hljs-comment&quot;&gt;// Alias that buffer through message&lt;/span&gt;\n    Msg* msg = (Msg*)(buff);\n    \n    &lt;span class=&quot;hljs-comment&quot;&gt;// Send a bunch of messages    &lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;; ++i)\n    {\n        msg-&amp;gt;a = i;\n        msg-&amp;gt;b = i+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n        &lt;span class=&quot;hljs-built_in&quot;&gt;SendWord&lt;/span&gt;(buff[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]);\n        &lt;span class=&quot;hljs-built_in&quot;&gt;SendWord&lt;/span&gt;(buff[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]);   \n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The strict aliasing rule makes this setup illegal: dereferencing a pointer that aliases an object that is not of a &lt;a href=&quot;http://en.cppreference.com/w/c/language/type&quot; rel=&quot;noreferrer&quot;&gt;compatible type&lt;/a&gt; or one of the other types allowed by C 2011 6.5 paragraph 7&lt;sup&gt;1&lt;/sup&gt; is undefined behavior. Unfortunately, you can still code this way, &lt;em&gt;maybe&lt;/em&gt; get some warnings, have it compile fine, only to have weird unexpected behavior when you run the code.&lt;/p&gt;\n&lt;p&gt;(GCC appears somewhat inconsistent in its ability to give aliasing warnings, sometimes giving us a friendly warning and sometimes not.)&lt;/p&gt;\n&lt;p&gt;To see why this behavior is undefined, we have to think about what the strict aliasing rule buys the compiler. Basically, with this rule, it doesn&apos;t have to think about inserting instructions to refresh the contents of &lt;code&gt;buff&lt;/code&gt; every run of the loop. Instead, when optimizing, with some annoyingly unenforced assumptions about aliasing, it can omit those instructions, load &lt;code&gt;buff[0]&lt;/code&gt; and &lt;code&gt;buff[1]&lt;/code&gt; into CPU registers once before the loop is run, and speed up the body of the loop. Before strict aliasing was introduced, the compiler had to live in a state of paranoia that the contents of &lt;code&gt;buff&lt;/code&gt; could change by any preceding memory stores. So to get an extra performance edge, and assuming most people don&apos;t type-pun pointers, the strict aliasing rule was introduced.&lt;/p&gt;\n&lt;p&gt;Keep in mind, if you think the example is contrived, this might even happen if you&apos;re passing a buffer to another function doing the sending for you, if instead you have.&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;SendMessage&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;uint32_t&lt;/span&gt;* buff, &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; size32)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; size32; ++i) \n    {\n        &lt;span class=&quot;hljs-built_in&quot;&gt;SendWord&lt;/span&gt;(buff[i]);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;And rewrote our earlier loop to take advantage of this convenient function&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-erlang&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(int i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;; ++i)&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-title&quot;&gt;msg&lt;/span&gt;-&amp;gt;&lt;/span&gt;a = i;\n    msg-&amp;gt;b = i+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    SendMessage(buff, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The compiler may or may not be able to or smart enough to try to inline SendMessage and it may or may not decide to load or not load buff again. If &lt;code&gt;SendMessage&lt;/code&gt; is part of another API that&apos;s compiled separately, it probably has instructions to load buff&apos;s contents. Then again, maybe you&apos;re in C++ and this is some templated header only implementation that the compiler thinks it can inline. Or maybe it&apos;s just something you wrote in your .c file for your own convenience. Anyway undefined behavior might still ensue. Even when we know some of what&apos;s happening under the hood, it&apos;s still a violation of the rule so no well defined behavior is guaranteed. So just by wrapping in a function that takes our word delimited buffer doesn&apos;t necessarily help.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;So how do I get around this?&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;Use a union. Most compilers support this without complaining about strict aliasing. This is allowed in C99 and explicitly allowed in C11.&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-objectivec&quot;&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;union&lt;/span&gt; {\n      Msg msg;\n      &lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; asBuffer[&lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(Msg)/&lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;)];\n  };\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;You can disable strict aliasing in your compiler (&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc-4.6.1/gcc/Optimize-Options.html#index-fstrict_002daliasing-825&quot; rel=&quot;noreferrer&quot;&gt;f[no-]strict-aliasing&lt;/a&gt; in gcc))&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;You can use &lt;code&gt;char*&lt;/code&gt; for aliasing instead of your system&apos;s word. The rules allow an exception for &lt;code&gt;char*&lt;/code&gt; (including &lt;code&gt;signed char&lt;/code&gt; and &lt;code&gt;unsigned char&lt;/code&gt;). It&apos;s always assumed that &lt;code&gt;char*&lt;/code&gt; aliases other types. However this won&apos;t work the other way: there&apos;s no assumption that your struct aliases a buffer of chars.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;Beginner beware&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;This is only one potential minefield when overlaying two types onto each other. You should also learn about &lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot; rel=&quot;noreferrer&quot;&gt;endianness&lt;/a&gt;, &lt;a href=&quot;http://web.archive.org/web/20170708093042/http://www.cs.umd.edu:80/class/sum2003/cmsc311/Notes/Data/aligned.html&quot; rel=&quot;noreferrer&quot;&gt;word alignment&lt;/a&gt;, and how to deal with alignment issues through &lt;a href=&quot;http://grok2.com/structure_packing.html&quot; rel=&quot;noreferrer&quot;&gt;packing structs&lt;/a&gt; correctly.&lt;/p&gt;\n&lt;h2&gt;Footnote&lt;/h2&gt;\n&lt;p&gt;&lt;sup&gt;1&lt;/sup&gt; The types that C 2011 6.5 7 allows an lvalue to access are:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;a type compatible with the effective type of the object,&lt;/li&gt;\n&lt;li&gt;a qualified version of a type compatible with the effective type of the object,&lt;/li&gt;\n&lt;li&gt;a type that is the signed or unsigned type corresponding to the effective type of the object,&lt;/li&gt;\n&lt;li&gt;a type that is the signed or unsigned type corresponding to a qualified version of the effective type of the object,&lt;/li&gt;\n&lt;li&gt;an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union), or&lt;/li&gt;\n&lt;li&gt;a character type.&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;The best explanation I have found is by Mike Acton, &lt;a href=&quot;http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html&quot; rel=&quot;noreferrer&quot;&gt;Understanding Strict Aliasing&lt;/a&gt;. It&apos;s focused a little on PS3 development, but that&apos;s basically just GCC.&lt;/p&gt;\n\n&lt;p&gt;From the article:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;&quot;Strict aliasing is an assumption, made by the C (or C++) compiler, that dereferencing pointers to objects of different types will never refer to the same memory location (i.e. alias each other.)&quot;&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;So basically if you have an &lt;code&gt;int*&lt;/code&gt; pointing to some memory containing an &lt;code&gt;int&lt;/code&gt; and then you point a &lt;code&gt;float*&lt;/code&gt; to that memory and use it as a &lt;code&gt;float&lt;/code&gt; you break the rule. If your code does not respect this, then the compiler&apos;s optimizer will most likely break your code.&lt;/p&gt;\n\n&lt;p&gt;The exception to the rule is a &lt;code&gt;char*&lt;/code&gt;, which is allowed to point to any type.&lt;/p&gt;\n    ","\n&lt;h2&gt;Note&lt;/h2&gt;\n&lt;p&gt;This is excerpted from my &lt;a href=&quot;https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8&quot; rel=&quot;nofollow noreferrer&quot;&gt;&quot;What is the Strict Aliasing Rule and Why do we care?&quot;&lt;/a&gt; write-up.&lt;/p&gt;\n&lt;h2&gt;What is strict aliasing?&lt;/h2&gt;\n&lt;p&gt;In C and C++ aliasing has to do with what expression types we are allowed to access stored values through. In both C and C++ the standard specifies which expression types are allowed to alias which types. The compiler and optimizer are allowed to assume we follow the aliasing rules strictly, hence the term &lt;em&gt;strict aliasing rule&lt;/em&gt;. If we attempt to access a value using a type not allowed it is classified as &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/ub&quot; rel=&quot;nofollow noreferrer&quot;&gt;undefined behavior&lt;/a&gt; (&lt;strong&gt;UB&lt;/strong&gt;). Once we have undefined behavior all bets are off, the results of our program are no longer reliable.&lt;/p&gt;\n&lt;p&gt;Unfortunately with strict aliasing violations, we will often obtain the results we expect, leaving the possibility the a future version of a compiler with a new optimization will break code we thought was valid. This is undesirable and it is a worthwhile goal to understand the strict aliasing rules and how to avoid violating them.&lt;/p&gt;\n&lt;p&gt;To understand more about why we care, we will discuss issues that come up when violating strict aliasing rules, type punning since common techniques used in type punning often violate strict aliasing rules and how to type pun correctly.&lt;/p&gt;\n&lt;h3&gt;Preliminary examples&lt;/h3&gt;\n&lt;p&gt;Let&apos;s look at some examples, then we can talk about exactly what the standard(s) say, examine some further examples and then see how to avoid strict aliasing and catch violations we missed. Here is an example that should not be surprising (&lt;a href=&quot;https://wandbox.org/permlink/7sCJTAyrifZ0zfFA&quot; rel=&quot;nofollow noreferrer&quot;&gt;live example&lt;/a&gt;):&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *ip = &amp;amp;x;\n\nstd::cout &amp;lt;&amp;lt; *ip &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n&quot;&lt;/span&gt;;\n*ip = &lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;;\nstd::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;We have a &lt;em&gt;int*&lt;/em&gt; pointing to memory occupied by an &lt;em&gt;int&lt;/em&gt; and this is a valid aliasing. The optimizer must assume that assignments through &lt;strong&gt;ip&lt;/strong&gt; could update the value occupied by &lt;strong&gt;x&lt;/strong&gt;.&lt;/p&gt;\n&lt;p&gt;The next example shows aliasing that leads to undefined behavior (&lt;a href=&quot;https://wandbox.org/permlink/8qA8JyJRVHtS9LPf&quot; rel=&quot;nofollow noreferrer&quot;&gt;live example&lt;/a&gt;):&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;( &lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt; *f, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *i )&lt;/span&gt; &lt;/span&gt;{ \n    *i = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    *f = &lt;span class=&quot;hljs-number&quot;&gt;0.f&lt;/span&gt;;\n    \n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; *i;\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n    \n    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n&quot;&lt;/span&gt;;   &lt;span class=&quot;hljs-comment&quot;&gt;// Expect 0&lt;/span&gt;\n    x = &lt;span class=&quot;hljs-built_in&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt;*&amp;gt;(&amp;amp;x), &amp;amp;x);\n    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n&quot;&lt;/span&gt;;   &lt;span class=&quot;hljs-comment&quot;&gt;// Expect 0?&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In the function &lt;strong&gt;foo&lt;/strong&gt; we take an &lt;em&gt;int*&lt;/em&gt; and a &lt;em&gt;float*&lt;/em&gt;, in this example we call &lt;strong&gt;foo&lt;/strong&gt; and set both parameters to point to the same memory location which in this example contains an &lt;em&gt;int&lt;/em&gt;. Note, the &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/reinterpret_cast&quot; rel=&quot;nofollow noreferrer&quot;&gt;reinterpret_cast&lt;/a&gt; is telling the compiler to treat the expression as if it had the type specified by its template parameter. In this case we are telling it to treat the expression &lt;strong&gt;&amp;amp;x&lt;/strong&gt; as if it had type &lt;em&gt;float*&lt;/em&gt;. We may naively expect the result of the second &lt;strong&gt;cout&lt;/strong&gt; to be &lt;strong&gt;0&lt;/strong&gt; but with optimization enabled using &lt;strong&gt;-O2&lt;/strong&gt; both gcc and clang produce the following result:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-undefined&quot;&gt;0\n1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Which may not be expected but is perfectly valid since we have invoked undefined behavior. A &lt;em&gt;float&lt;/em&gt; can not validly alias an &lt;em&gt;int&lt;/em&gt; object. Therefore the optimizer can assume the &lt;em&gt;constant 1&lt;/em&gt; stored when dereferencing &lt;strong&gt;i&lt;/strong&gt; will be the return value since a store through &lt;strong&gt;f&lt;/strong&gt; could not validly affect an &lt;em&gt;int&lt;/em&gt; object. Plugging the code in Compiler Explorer shows this is exactly what is happening(&lt;a href=&quot;https://godbolt.org/g/yNV5aj&quot; rel=&quot;nofollow noreferrer&quot;&gt;live example&lt;/a&gt;):&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-sql&quot;&gt;foo(&lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;hljs-operator&quot;&gt;*&lt;/span&gt;, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;hljs-operator&quot;&gt;*&lt;/span&gt;): # &lt;span class=&quot;hljs-variable&quot;&gt;@foo&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;hljs-operator&quot;&gt;*&lt;/span&gt;, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;hljs-operator&quot;&gt;*&lt;/span&gt;)\nmov dword ptr [rsi], &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\nmov dword ptr [rdi], &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;\nmov eax, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\nret\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The optimizer using &lt;a href=&quot;http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/DDJ/2000/0010/0010d/0010d.htm&quot; rel=&quot;nofollow noreferrer&quot;&gt;Type-Based Alias Analysis (TBAA)&lt;/a&gt; assumes &lt;strong&gt;1&lt;/strong&gt; will be returned and directly moves the constant value into register &lt;strong&gt;eax&lt;/strong&gt; which carries the return value. TBAA uses the languages rules about what types are allowed to alias to optimize loads and stores. In this case TBAA knows that a &lt;em&gt;float&lt;/em&gt; can not alias an &lt;em&gt;int&lt;/em&gt; and optimizes away the load of &lt;strong&gt;i&lt;/strong&gt;.&lt;/p&gt;\n&lt;h2&gt;Now, to the Rule-Book&lt;/h2&gt;\n&lt;p&gt;What exactly does the standard say we are allowed and not allowed to do? The standard language is not straightforward, so for each item I will try to provide code examples that demonstrates the meaning.&lt;/p&gt;\n&lt;h3&gt;What does the C11 standard say?&lt;/h3&gt;\n&lt;p&gt;The &lt;strong&gt;C11&lt;/strong&gt; standard says the following in section &lt;em&gt;6.5 Expressions paragraph 7&lt;/em&gt;:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;An object shall have its stored value accessed only by an lvalue expression that has one of the following types:&lt;sup&gt;88)&lt;/sup&gt;\n a type compatible with the effective type of the object,&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-perl&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;x&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; *p = &amp;amp;&lt;span class=&quot;hljs-keyword&quot;&gt;x&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, *p); &lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;/span&gt; *p gives us an lvalue expression of type &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; which is compatible with &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt; a qualified version of a type compatible with the effective type of the object,&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *p = &amp;amp;x;\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, *p); &lt;span class=&quot;hljs-comment&quot;&gt;// *p gives us an lvalue expression of type const int which is compatible with int&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt; a type that is the signed or unsigned type corresponding to the effective type of the object,&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *p = (&lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*)&amp;amp;x;\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%u\\n&quot;&lt;/span&gt;, *p ); &lt;span class=&quot;hljs-comment&quot;&gt;// *p gives us an lvalue expression of type unsigned int which corresponds to &lt;/span&gt;\n                     &lt;span class=&quot;hljs-comment&quot;&gt;// the effective type of the object&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;a href=&quot;https://twitter.com/shafikyaghmour/status/957702383810658304&quot; rel=&quot;nofollow noreferrer&quot;&gt;gcc/clang has an extension&lt;/a&gt; and &lt;a href=&quot;https://gcc.gnu.org/ml/gcc/2003-10/msg00184.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;also&lt;/a&gt; that allows assigning &lt;em&gt;unsigned int*&lt;/em&gt; to &lt;em&gt;int*&lt;/em&gt; even though they are not compatible types.&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt; a type that is the signed or unsigned type corresponding to a qualified version of the effective type of the object,&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *p = (&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*)&amp;amp;x;\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%u\\n&quot;&lt;/span&gt;, *p ); &lt;span class=&quot;hljs-comment&quot;&gt;// *p gives us an lvalue expression of type const unsigned int which is a unsigned type &lt;/span&gt;\n                     &lt;span class=&quot;hljs-comment&quot;&gt;// that corresponds with to a qualified version of the effective type of the object&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt; an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union), or&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; foo {\n    &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; x;\n};\n    \n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foobar&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; foo *fp, &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; *ip &lt;/span&gt;)&lt;/span&gt;;  &lt;span class=&quot;hljs-comment&quot;&gt;// struct foo is an aggregate that includes int among its members so it&lt;/span&gt;\n                                         &lt;span class=&quot;hljs-comment&quot;&gt;// can alias with *ip&lt;/span&gt;\n\nfoo f;\nfoobar( &amp;amp;f, &amp;amp;f.x );\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt; a character type.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;65&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *p = (&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *)&amp;amp;x;\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%c\\n&quot;&lt;/span&gt;, *p );  &lt;span class=&quot;hljs-comment&quot;&gt;// *p gives us an lvalue expression of type char which is a character type.&lt;/span&gt;\n                      &lt;span class=&quot;hljs-comment&quot;&gt;// The results are not portable due to endianness issues.&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;What the C++17 Draft Standard says&lt;/h3&gt;\n&lt;p&gt;The C++17 draft standard in section &lt;em&gt;[basic.lval] paragraph 11&lt;/em&gt; says:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:&lt;sup&gt;63&lt;/sup&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;(11.1)  the dynamic type of the object,&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; *p = &lt;span class=&quot;hljs-built_in&quot;&gt;malloc&lt;/span&gt;( &lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;) ); &lt;span class=&quot;hljs-comment&quot;&gt;// We have allocated storage but not started the lifetime of an object&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *ip = &lt;span class=&quot;hljs-built_in&quot;&gt;new&lt;/span&gt; (p) &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;{&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;};        &lt;span class=&quot;hljs-comment&quot;&gt;// Placement new changes the dynamic type of the object to int&lt;/span&gt;\nstd::cout &amp;lt;&amp;lt; *ip &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n&quot;&lt;/span&gt;;        &lt;span class=&quot;hljs-comment&quot;&gt;// *ip gives us a glvalue expression of type int which matches the dynamic type &lt;/span&gt;\n                                 &lt;span class=&quot;hljs-comment&quot;&gt;// of the allocated object&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;(11.2)  a cv-qualified version of the dynamic type of the object,&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *cip = &amp;amp;x;\nstd::cout &amp;lt;&amp;lt; *cip &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n&quot;&lt;/span&gt;;  &lt;span class=&quot;hljs-comment&quot;&gt;// *cip gives us a glvalue expression of type const int which is a cv-qualified &lt;/span&gt;\n                            &lt;span class=&quot;hljs-comment&quot;&gt;// version of the dynamic type of x&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;(11.3)  a type similar (as defined in 7.5) to the dynamic type of the object,&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;(11.4)  a type that is the signed or unsigned type corresponding to the dynamic type of the object,&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Both si and ui are signed or unsigned types corresponding to each others dynamic types&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// We can see from this godbolt(https://godbolt.org/g/KowGXB) the optimizer assumes aliasing.&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;signed&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;( &lt;span class=&quot;hljs-type&quot;&gt;signed&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &amp;amp;si, &lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &amp;amp;ui )&lt;/span&gt; &lt;/span&gt;{\n    si = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    ui = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; si;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;(11.5)  a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;signed&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;( &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;signed&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &amp;amp;si1, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &amp;amp;si2)&lt;/span&gt;&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// Hard to show this one assumes aliasing&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;(11.6)  an aggregate or union type that includes one of the aforementioned types among its elements or nonstatic data members (including, recursively, an element or non-static data member of a subaggregate or contained union),&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; foo {\n    &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; x;\n};\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// Compiler Explorer example(https://godbolt.org/g/z2wJTC) shows aliasing assumption&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foobar&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt; foo &amp;amp;fp, &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &amp;amp;ip &lt;/span&gt;)&lt;/span&gt; {\n    fp.x = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    ip = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; fp.x;\n}\n\nfoo f;\nfoobar( f, f.x );\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;(11.7)  a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; foo { &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; x; };\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; bar : &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; foo {};\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foobar&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt; foo &amp;amp;f, bar &amp;amp;b &lt;/span&gt;)&lt;/span&gt; {\n    f.x = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    b.x = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; f.x;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;(11.8)  a char, unsigned char, or std::byte type.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;( std::&lt;span class=&quot;hljs-type&quot;&gt;byte&lt;/span&gt; &amp;amp;b, uint32_t &amp;amp;ui )&lt;/span&gt; {\n    b = static_cast&amp;lt;std::&lt;span class=&quot;hljs-type&quot;&gt;byte&lt;/span&gt;&amp;gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;);\n    ui = &lt;span class=&quot;hljs-number&quot;&gt;0xFFFFFFFF&lt;/span&gt;;\n  \n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; std::to_integer&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;( b );  &lt;span class=&quot;hljs-comment&quot;&gt;// b gives us a glvalue expression of type std::byte which can alias&lt;/span&gt;\n                                       &lt;span class=&quot;hljs-comment&quot;&gt;// an object of type uint32_t&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Worth noting &lt;em&gt;signed char&lt;/em&gt; is not included in the list above, this is a notable difference from &lt;em&gt;C&lt;/em&gt; which says &lt;em&gt;a character type&lt;/em&gt;.&lt;/p&gt;\n&lt;h2&gt;What is Type Punning&lt;/h2&gt;\n&lt;p&gt;We have gotten to this point and we may be wondering, why would we want to alias for? The answer typically is to &lt;em&gt;type pun&lt;/em&gt;, often the methods used violate strict aliasing rules.&lt;/p&gt;\n&lt;p&gt;Sometimes we want to circumvent the type system and interpret an object as a different type. This is called &lt;em&gt;type punning&lt;/em&gt;, to reinterpret a segment of memory as another type. &lt;em&gt;Type punning&lt;/em&gt; is useful for tasks that want access to the underlying representation of an object to view, transport or manipulate. Typical areas we find type punning being used are compilers, serialization, networking code, etc&lt;/p&gt;\n&lt;p&gt;Traditionally this has been accomplished by taking the address of the object, casting it to a pointer of the type we want to reinterpret it as and then accessing the value, or in other words by aliasing. For example:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// In C&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt; *fp = (&lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt;*)&amp;amp;x;  &lt;span class=&quot;hljs-comment&quot;&gt;// Not a valid aliasing&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// In C++&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt; *fp = &lt;span class=&quot;hljs-built_in&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt;*&amp;gt;(&amp;amp;x);  &lt;span class=&quot;hljs-comment&quot;&gt;// Not a valid aliasing&lt;/span&gt;\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;( &lt;span class=&quot;hljs-string&quot;&gt;&quot;%f\\n&quot;&lt;/span&gt;, *fp );\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;As we have seen earlier this is not a valid aliasing, so we are invoking undefined behavior. But traditionally compilers did not take advantage of strict aliasing rules and this type of code usually just worked, developers have unfortunately gotten used to doing things this way. A common alternate method for type punning is through unions, which is valid in C but &lt;em&gt;undefined behavior&lt;/em&gt; in C++ (&lt;a href=&quot;https://wandbox.org/permlink/oOf9bPlcWDYrYqPF&quot; rel=&quot;nofollow noreferrer&quot;&gt;see live example&lt;/a&gt;):&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;u1&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; n;\n    &lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt; f;\n};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;u1&lt;/span&gt; u;\nu.f = &lt;span class=&quot;hljs-number&quot;&gt;1.0f&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;( &lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, u.n );  &lt;span class=&quot;hljs-comment&quot;&gt;// UB in C++ n is not the active member&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This is not valid in C++ and some consider the purpose of unions to be solely for implementing variant types and feel using unions for type punning is an abuse.&lt;/p&gt;\n&lt;h3&gt;How do we Type Pun correctly?&lt;/h3&gt;\n&lt;p&gt;The standard method for &lt;em&gt;type punning&lt;/em&gt; in both C and C++ is &lt;strong&gt;memcpy&lt;/strong&gt;. This may seem a little heavy handed but the optimizer should recognize the use of &lt;strong&gt;memcpy&lt;/strong&gt; for &lt;em&gt;type punning&lt;/em&gt; and optimize it away and generate a register to register move. For example if we know &lt;em&gt;int64_t&lt;/em&gt; is the same size as &lt;em&gt;double&lt;/em&gt;:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;static_assert( &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;( &lt;span class=&quot;hljs-built_in&quot;&gt;double&lt;/span&gt; ) == &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;( int64_t ) );  &lt;span class=&quot;hljs-comment&quot;&gt;// C++17 does not require a message&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;we can use &lt;strong&gt;memcpy&lt;/strong&gt;:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;func1&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;( &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; d )&lt;/span&gt; &lt;/span&gt;{\n    std::&lt;span class=&quot;hljs-type&quot;&gt;int64_t&lt;/span&gt; n;\n    std::&lt;span class=&quot;hljs-built_in&quot;&gt;memcpy&lt;/span&gt;(&amp;amp;n, &amp;amp;d, &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; d);\n    &lt;span class=&quot;hljs-comment&quot;&gt;//...&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;At a sufficient optimization level any decent modern compiler generates identical code to the previously mentioned &lt;strong&gt;reinterpret_cast&lt;/strong&gt; method or &lt;em&gt;union&lt;/em&gt; method for &lt;em&gt;type punning&lt;/em&gt;. Examining the generated code we see it uses just register mov (&lt;a href=&quot;https://godbolt.org/g/BfZGwX&quot; rel=&quot;nofollow noreferrer&quot;&gt;live Compiler Explorer Example&lt;/a&gt;).&lt;/p&gt;\n&lt;h2&gt;C++20 and bit_cast&lt;/h2&gt;\n&lt;p&gt;In C++20 we may gain &lt;strong&gt;bit_cast&lt;/strong&gt; (&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0476r2.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;implementation available in link from proposal&lt;/a&gt;) which gives a simple and safe way to type-pun as well as being usable in a constexpr context.&lt;/p&gt;\n&lt;p&gt;The following is an example of how to use &lt;strong&gt;bit_cast&lt;/strong&gt; to type pun a &lt;em&gt;unsigned int&lt;/em&gt; to &lt;em&gt;float&lt;/em&gt;, (&lt;a href=&quot;https://wandbox.org/permlink/i5l0g4IYuCFgLzzl&quot; rel=&quot;nofollow noreferrer&quot;&gt;see it live&lt;/a&gt;):&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;bit_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt;&amp;gt;(&lt;span class=&quot;hljs-number&quot;&gt;0x447a0000&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n&quot;&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;//assuming sizeof(float) == sizeof(unsigned int)&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In the case where &lt;em&gt;To&lt;/em&gt; and &lt;em&gt;From&lt;/em&gt; types don&apos;t have the same size, it requires us to use an intermediate struct15. We will use a struct containing a &lt;strong&gt;sizeof( unsigned int )&lt;/strong&gt; character array (&lt;em&gt;assumes 4 byte unsigned int&lt;/em&gt;) to be the &lt;em&gt;From&lt;/em&gt; type and &lt;em&gt;unsigned int&lt;/em&gt; as the &lt;em&gt;To&lt;/em&gt; type.:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;uint_chars&lt;/span&gt; {\n    &lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; arr[&lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;( &lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; )] = {};  &lt;span class=&quot;hljs-comment&quot;&gt;// Assume sizeof( unsigned int ) == 4&lt;/span&gt;\n};\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// Assume len is a multiple of 4 &lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;( &lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *p, &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; len )&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; result = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;( &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; index = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; index &amp;lt; len; index += &lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;) ) {\n        uint_chars f;\n        std::&lt;span class=&quot;hljs-built_in&quot;&gt;memcpy&lt;/span&gt;( f.arr, &amp;amp;p[index], &lt;span class=&quot;hljs-built_in&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;));\n        &lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; result = &lt;span class=&quot;hljs-built_in&quot;&gt;bit_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;(f);\n\n        result += &lt;span class=&quot;hljs-built_in&quot;&gt;foo&lt;/span&gt;( result );\n    }\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; result;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;It is unfortunate that we need this intermediate type but that is the current constraint of &lt;strong&gt;bit_cast&lt;/strong&gt;.&lt;/p&gt;\n&lt;h2&gt;Catching Strict Aliasing Violations&lt;/h2&gt;\n&lt;p&gt;We don&apos;t have a lot of good tools for catching strict aliasing in C++, the tools we have will catch some cases of strict aliasing violations and some cases of misaligned loads and stores.&lt;/p&gt;\n&lt;p&gt;gcc using the flag &lt;strong&gt;-fstrict-aliasing&lt;/strong&gt; and &lt;strong&gt;-Wstrict-aliasing&lt;/strong&gt; can catch some cases although not without false positives/negatives. For example the following cases will generate a warning in gcc (&lt;a href=&quot;https://wandbox.org/permlink/cfckjTgwNTYHDIry&quot; rel=&quot;nofollow noreferrer&quot;&gt;see it live&lt;/a&gt;):&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;short&lt;/span&gt; j;\n&lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt; f = &lt;span class=&quot;hljs-number&quot;&gt;1.f&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// Originally not initialized but tis-kernel caught &lt;/span&gt;\n               &lt;span class=&quot;hljs-comment&quot;&gt;// it was being accessed w/ an indeterminate value below&lt;/span&gt;\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%i\\n&quot;&lt;/span&gt;, j = *(&lt;span class=&quot;hljs-built_in&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;short&lt;/span&gt;*&amp;gt;(&amp;amp;a)));\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%i\\n&quot;&lt;/span&gt;, j = *(&lt;span class=&quot;hljs-built_in&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*&amp;gt;(&amp;amp;f)));\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;although it will not catch this additional case (&lt;a href=&quot;https://wandbox.org/permlink/dwd9jhy53AF7a2D0&quot; rel=&quot;nofollow noreferrer&quot;&gt;see it live&lt;/a&gt;):&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *p;\n\np = &amp;amp;a;\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%i\\n&quot;&lt;/span&gt;, j = *(&lt;span class=&quot;hljs-built_in&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;short&lt;/span&gt;*&amp;gt;(p)));\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Although clang allows these flags it apparently does not actually implement the warnings.&lt;/p&gt;\n&lt;p&gt;Another tool we have available to us is ASan which can catch misaligned loads and stores. Although these are not directly strict aliasing violations they are a common result of strict aliasing violations. For example the following cases will generate runtime errors when built with clang using &lt;strong&gt;-fsanitize=address&lt;/strong&gt;&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *x = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;];               &lt;span class=&quot;hljs-comment&quot;&gt;// 8 bytes: [0,7].&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *u = (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*)((&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;*)x + &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;);     &lt;span class=&quot;hljs-comment&quot;&gt;// regardless of alignment of x this will not be an aligned address&lt;/span&gt;\n*u = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;                            &lt;span class=&quot;hljs-comment&quot;&gt;// Access to range [6-9]&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;( &lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, *u );              &lt;span class=&quot;hljs-comment&quot;&gt;// Access to range [6-9]&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The last tool I will recommend is C++ specific and not strictly a tool but a coding practice, don&apos;t allow C-style casts. Both gcc and clang will produce a diagnostic for C-style casts using &lt;strong&gt;-Wold-style-cast&lt;/strong&gt;. This will force any undefined type puns to use reinterpret_cast, in general reinterpret_cast should be a flag for closer code review. It is also easier to search your code base for reinterpret_cast to perform an audit.&lt;/p&gt;\n&lt;p&gt;For C we have all the tools already covered and we also have tis-interpreter, a static analyzer that exhaustively analyzes a program for a large subset of the C language. Given a C version of the earlier example where using &lt;strong&gt;-fstrict-aliasing&lt;/strong&gt; misses one case (&lt;a href=&quot;https://wandbox.org/permlink/ebLBJ17Pg7TsnIgY&quot; rel=&quot;nofollow noreferrer&quot;&gt;see it live&lt;/a&gt;)&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;short&lt;/span&gt; j;\n&lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt; f = &lt;span class=&quot;hljs-number&quot;&gt;1.0&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%i\\n&quot;&lt;/span&gt;, j = *((&lt;span class=&quot;hljs-type&quot;&gt;short&lt;/span&gt;*)&amp;amp;a));\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%i\\n&quot;&lt;/span&gt;, j = *((&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*)&amp;amp;f));\n    \n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *p;\n\np = &amp;amp;a;\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%i\\n&quot;&lt;/span&gt;, j = *((&lt;span class=&quot;hljs-type&quot;&gt;short&lt;/span&gt;*)p));\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;tis-interpeter is able to catch all three, the following example invokes tis-kernel as tis-interpreter (output is edited for brevity):&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;./bin/tis-kernel -sa example1.c \n...\nexample1.c:&lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;:[sa] warning: &lt;span class=&quot;hljs-function&quot;&gt;The &lt;span class=&quot;hljs-title&quot;&gt;pointer&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;short&lt;/span&gt; *&lt;/span&gt;)(&lt;span class=&quot;hljs-params&quot;&gt;&amp;amp; a&lt;/span&gt;) has type &lt;span class=&quot;hljs-built_in&quot;&gt;short&lt;/span&gt; *. It violates strict aliasing\n              rules &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; accessing a cell &lt;span class=&quot;hljs-keyword&quot;&gt;with&lt;/span&gt; effective type &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;.\n...\n\nexample1.c:10:[sa] warning: The &lt;span class=&quot;hljs-title&quot;&gt;pointer&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; *&lt;/span&gt;)(&lt;span class=&quot;hljs-params&quot;&gt;&amp;amp; f&lt;/span&gt;) has type &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; *. It violates strict aliasing rules &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt;\n              accessing a cell &lt;span class=&quot;hljs-keyword&quot;&gt;with&lt;/span&gt; effective type &lt;span class=&quot;hljs-built_in&quot;&gt;float&lt;/span&gt;.\n              Callstack: main\n...\n\nexample1.c:15:[sa] warning: The &lt;span class=&quot;hljs-title&quot;&gt;pointer&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;short&lt;/span&gt; *&lt;/span&gt;)p has type &lt;span class=&quot;hljs-built_in&quot;&gt;short&lt;/span&gt; *. It violates strict aliasing rules &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt;\n              accessing a cell &lt;span class=&quot;hljs-keyword&quot;&gt;with&lt;/span&gt; effective type &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;.\n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Finally there is &lt;a href=&quot;https://www.youtube.com/watch?v=vAXJeN7k32Y&quot; rel=&quot;nofollow noreferrer&quot;&gt;TySan&lt;/a&gt; which is currently in development. This sanitizer adds type checking information in a shadow memory segment and checks accesses to see if they violate aliasing rules. The tool potentially should be able to catch all aliasing violations but may have a large run-time overhead.&lt;/p&gt;\n    ","\n&lt;p&gt;This is the strict aliasing rule, found in section 3.10 of the &lt;strong&gt;C++03&lt;/strong&gt; standard (other answers provide good explanation, but none provided the rule itself):&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;If a program attempts to access the stored value of an object through an lvalue of other than one of the following types the behavior is undefined:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;the dynamic type of the object,&lt;/li&gt;\n&lt;li&gt;a cv-qualified version of the dynamic type of the object,&lt;/li&gt;\n&lt;li&gt;a type that is the signed or unsigned type corresponding to the dynamic type of the object,&lt;/li&gt;\n&lt;li&gt;a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,&lt;/li&gt;\n&lt;li&gt;an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union),&lt;/li&gt;\n&lt;li&gt;a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,&lt;/li&gt;\n&lt;li&gt;a &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt; type.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;strong&gt;C++11&lt;/strong&gt; and &lt;strong&gt;C++14&lt;/strong&gt; wording (changes emphasized):&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;If a program attempts to access the stored value of an object through a &lt;em&gt;glvalue&lt;/em&gt; of other than one of the following types the behavior is undefined:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;the dynamic type of the object,&lt;/li&gt;\n&lt;li&gt;a cv-qualified version of the dynamic type of the object,&lt;/li&gt;\n&lt;li&gt;&lt;em&gt;a type similar (as defined in 4.4) to the dynamic type of the object,&lt;/em&gt;&lt;/li&gt;\n&lt;li&gt;a type that is the signed or unsigned type corresponding to the dynamic type of the object,&lt;/li&gt;\n&lt;li&gt;a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,&lt;/li&gt;\n&lt;li&gt;an aggregate or union type that includes one of the aforementioned types among its &lt;em&gt;elements or non-static data members&lt;/em&gt; (including, recursively, an &lt;em&gt;element or non-static data member&lt;/em&gt; of a subaggregate or contained union),&lt;/li&gt;\n&lt;li&gt;a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,&lt;/li&gt;\n&lt;li&gt;a &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt; type.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Two changes were small: &lt;em&gt;glvalue&lt;/em&gt; instead of &lt;em&gt;lvalue&lt;/em&gt;, and clarification of the aggregate/union case.&lt;/p&gt;\n&lt;p&gt;The third change makes a stronger guarantee (relaxes the strong aliasing rule): The new concept of &lt;em&gt;similar types&lt;/em&gt; that are now safe to alias.&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;Also the &lt;strong&gt;C&lt;/strong&gt; wording (C99; ISO/IEC 9899:1999 6.5/7; the exact same wording is used in ISO/IEC 9899:2011 6.5 7):&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;An object shall have its stored value accessed only by an lvalue\nexpression that has one of the following types &lt;sup&gt; 73) or 88)&lt;/sup&gt;:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;a type compatible with the effective type of the object,&lt;/li&gt;\n&lt;li&gt;a qualied version of a type compatible with the effective type of\nthe object,&lt;/li&gt;\n&lt;li&gt;a type that is the signed or unsigned type corresponding to the\neffective type of the object,&lt;/li&gt;\n&lt;li&gt;a type that is the signed or unsigned type corresponding to a\nqualied version of the effective type of the object,&lt;/li&gt;\n&lt;li&gt;an aggregate or union type that includes one of the aforementioned\ntypes among its members (including, recursively, a member of a\nsubaggregate or contained union), or&lt;/li&gt;\n&lt;li&gt;a character type.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;sup&gt; 73) or 88)&lt;/sup&gt; The intent of this list is to specify those circumstances in which an object may or may not be aliased.&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;Strict aliasing doesn&apos;t refer only to pointers, it affects references as well, I wrote a paper about it for the boost developer wiki and it was so well received that I turned it into a page on my consulting web site.  It explains completely what it is, why it confuses people so much and what to do about it. &lt;a href=&quot;http://dbp-consulting.com/tutorials/StrictAliasing.html&quot;&gt;Strict Aliasing White Paper&lt;/a&gt;.  In particular it explains why unions are risky behavior for C++, and why using memcpy is the only fix portable across both C and C++.  Hope this is helpful.&lt;/p&gt;\n    ","\n&lt;p&gt;As addendum to what Doug T. already wrote, here\nis a simple test case which probably triggers it with gcc :&lt;/p&gt;\n\n&lt;p&gt;check.c&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;check&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;short&lt;/span&gt; *h,&lt;span class=&quot;hljs-type&quot;&gt;long&lt;/span&gt; *k)&lt;/span&gt;\n&lt;/span&gt;{\n    *h=&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;\n    *k=&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (*h == &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;)\n        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;strict aliasing problem\\n&quot;&lt;/span&gt;);\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;long&lt;/span&gt;      k[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;];\n    &lt;span class=&quot;hljs-built_in&quot;&gt;check&lt;/span&gt;((&lt;span class=&quot;hljs-type&quot;&gt;short&lt;/span&gt; *)k,k);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Compile with &lt;code&gt;gcc -O2 -o check check.c&lt;/code&gt; .\nUsually (with most gcc versions I tried) this outputs &quot;strict aliasing problem&quot;, because the compiler assumes that &quot;h&quot; cannot be the same address as &quot;k&quot; in the &quot;check&quot; function. Because of that the compiler optimizes the &lt;code&gt;if (*h == 5)&lt;/code&gt; away and always calls the printf.&lt;/p&gt;\n\n&lt;p&gt;For those who are interested here is the x64 assembler code, produced by gcc 4.6.3, running on ubuntu 12.04.2 for x64:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-perl&quot;&gt;movw    $5, (%rdi)\nmovq    $6, (%rsi)\nmovl    $.LC&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, %edi\njmp puts\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So the if condition is completely gone from the assembler code.&lt;/p&gt;\n    ","\n&lt;p&gt;According to the C89 rationale, the authors of the Standard did not want to require that compilers given code like:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; x;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;double&lt;/span&gt; *p&lt;/span&gt;)&lt;/span&gt;\n{\n  x=&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;\n  *p = &lt;span class=&quot;hljs-number&quot;&gt;1.0&lt;/span&gt;;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; x;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;should be required to reload the value of &lt;code&gt;x&lt;/code&gt; between the assignment and return statement so as to allow for the possibility that &lt;code&gt;p&lt;/code&gt; might point to &lt;code&gt;x&lt;/code&gt;, and the assignment to &lt;code&gt;*p&lt;/code&gt; might consequently alter the value of &lt;code&gt;x&lt;/code&gt;.  The notion that a compiler should be entitled to presume that there won&apos;t be aliasing &lt;em&gt;in situations like the above&lt;/em&gt; was non-controversial.&lt;/p&gt;\n\n&lt;p&gt;Unfortunately, the authors of the C89 wrote their rule in a way that, if read literally, would make even the following function invoke Undefined Behavior:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;\n{\n  &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; S {&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; x;} s;\n  s.x = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;because it uses an lvalue of type &lt;code&gt;int&lt;/code&gt; to access an object of type &lt;code&gt;struct S&lt;/code&gt;, and &lt;code&gt;int&lt;/code&gt; is not among the types that may be used accessing a &lt;code&gt;struct S&lt;/code&gt;.  Because it would be absurd to treat all use of non-character-type members of structs and unions as Undefined Behavior, almost everyone recognizes that there are at least some circumstances where an lvalue of one type may be used to access an object of another type.  Unfortunately, the C Standards Committee has failed to define what those circumstances are.&lt;/p&gt;\n\n&lt;p&gt;Much of the problem is a result of Defect Report #028, which asked about the behavior of a program like:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *ip, &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; *dp)&lt;/span&gt;\n&lt;/span&gt;{\n  *ip = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n  *dp = &lt;span class=&quot;hljs-number&quot;&gt;1.23&lt;/span&gt;;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; *ip;\n}\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;test2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;\n&lt;/span&gt;{\n  &lt;span class=&quot;hljs-keyword&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;U&lt;/span&gt; { &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i; &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; d; } u;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;(&amp;amp;u.i, &amp;amp;u.d);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Defect Report #28 states that the program invokes Undefined Behavior because the action of writing a union member of type &quot;double&quot; and reading one of type &quot;int&quot; invokes Implementation-Defined behavior.  Such reasoning is nonsensical, but forms the basis for the Effective Type rules which needlessly complicate the language while doing nothing to address the original problem.&lt;/p&gt;\n\n&lt;p&gt;The best way to resolve the original problem would probably be to treat the\nfootnote about the purpose of the rule as though it were normative, and made\nthe rule unenforceable except in cases which actually involve conflicting accesses using aliases.  Given something like:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;inc_int&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; *p&lt;/span&gt;)&lt;/span&gt; { *p = &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;; }\n &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;\n {\n   &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; *p;\n   &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; S { &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; x; } s;\n   s.x = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n   p = &amp;amp;s.x;\n   inc_int(p);\n   &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; s.x;\n }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;There&apos;s no conflict within &lt;code&gt;inc_int&lt;/code&gt; because all accesses to the storage accessed through &lt;code&gt;*p&lt;/code&gt; are done with an lvalue of type &lt;code&gt;int&lt;/code&gt;, and there&apos;s no conflict in &lt;code&gt;test&lt;/code&gt; because &lt;code&gt;p&lt;/code&gt; is visibly derived from a &lt;code&gt;struct S&lt;/code&gt;, and by the next time &lt;code&gt;s&lt;/code&gt; is used, all accesses to that storage that will ever be made through &lt;code&gt;p&lt;/code&gt; will have already happened.&lt;/p&gt;\n\n&lt;p&gt;If the code were changed slightly...&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;inc_int&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; *p&lt;/span&gt;)&lt;/span&gt; { *p = &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;; }\n &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;\n {\n   &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; *p;\n   &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; S { &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; x; } s;\n   p = &amp;amp;s.x;\n   s.x = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;  &lt;span class=&quot;hljs-comment&quot;&gt;//  !!*!!&lt;/span&gt;\n   *p += &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n   &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; s.x;\n }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here, there is an aliasing conflict between &lt;code&gt;p&lt;/code&gt; and the access to &lt;code&gt;s.x&lt;/code&gt; on the marked line because at that point in execution another reference exists &lt;em&gt;that will be used to access the same storage&lt;/em&gt;.&lt;/p&gt;\n\n&lt;p&gt;Had Defect Report 028 said the original example invoked UB because of the overlap between the creation and use of the two pointers, that would have made things a lot more clear without having to add &quot;Effective Types&quot; or other such complexity.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Type_punning&quot; rel=&quot;noreferrer&quot;&gt;Type punning&lt;/a&gt; via pointer casts (as opposed to using a union) is a major example of breaking strict aliasing.&lt;/p&gt;\n    ","\n&lt;p&gt;After reading many of the answers, I feel the need to add something:&lt;/p&gt;\n\n&lt;p&gt;Strict aliasing (which I&apos;ll describe in a bit) &lt;strong&gt;is important because&lt;/strong&gt;:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;Memory access can be expensive (performance wise), which is why &lt;strong&gt;data is manipulated in CPU registers&lt;/strong&gt; before being written back to the physical memory.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;If data in two different CPU registers will be written to the same memory space, &lt;strong&gt;we can&apos;t predict which data will &quot;survive&quot;&lt;/strong&gt; when we code in C.&lt;/p&gt;\n\n&lt;p&gt;In assembly, where we code the loading and unloading of CPU registers manually, we will know which data remains intact. But C (thankfully) abstracts this detail away.&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;Since two pointers can point to the same location in the memory, this could result in &lt;strong&gt;complex code that handles possible collisions&lt;/strong&gt;.&lt;/p&gt;\n\n&lt;p&gt;This extra code is slow and &lt;strong&gt;hurts performance&lt;/strong&gt; since it performs extra memory read / write operations which are both slower and (possibly) unnecessary.&lt;/p&gt;\n\n&lt;p&gt;The &lt;strong&gt;Strict aliasing rule allows us to avoid redundant machine code&lt;/strong&gt; in cases in which it &lt;em&gt;should be&lt;/em&gt; safe to assume that two pointers don&apos;t point to the same memory block (see also the &lt;code&gt;restrict&lt;/code&gt; keyword).&lt;/p&gt;\n\n&lt;p&gt;The Strict aliasing states it&apos;s safe to assume that pointers to different types point to different locations in the memory.&lt;/p&gt;\n\n&lt;p&gt;If a compiler notices that two pointers point to different types (for example, an &lt;code&gt;int *&lt;/code&gt; and a &lt;code&gt;float *&lt;/code&gt;), it will assume the memory address is different and it &lt;strong&gt;will not&lt;/strong&gt; protect against memory address collisions, resulting in faster machine code.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;For example&lt;/strong&gt;:&lt;/p&gt;\n\n&lt;p&gt;Lets assume the following function:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;merge_two_ints&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; *a, &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; *b&lt;/span&gt;)&lt;/span&gt; {\n  *b += *a;\n  *a += *b;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In order to handle the case in which &lt;code&gt;a == b&lt;/code&gt; (both pointers point to the same memory), we need to order and test the way we load data from the memory to the CPU registers, so the code might end up like this:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;load &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; from memory.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;add &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;save&lt;/strong&gt; &lt;code&gt;b&lt;/code&gt; and &lt;strong&gt;reload&lt;/strong&gt; &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;(save from CPU register to the memory and load from the memory to the CPU register). &lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;add &lt;code&gt;b&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;save &lt;code&gt;a&lt;/code&gt; (from the CPU register) to the memory.&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;Step 3 is very slow because it needs to access the physical memory. However, it&apos;s required to protect against instances where &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; point to the same memory address.&lt;/p&gt;\n\n&lt;p&gt;Strict aliasing would allow us to prevent this by telling the compiler that these memory addresses are distinctly different (which, in this case, will allow even further optimization which can&apos;t be performed if the pointers share a memory address).&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;This can be told to the compiler in two ways, by using different types to point to. i.e.:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;merge_two_numbers&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; *a, &lt;span class=&quot;hljs-built_in&quot;&gt;long&lt;/span&gt; *b&lt;/span&gt;)&lt;/span&gt; {...}\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Using the &lt;code&gt;restrict&lt;/code&gt; keyword. i.e.:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;merge_two_ints&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; * restrict a, &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; * restrict b&lt;/span&gt;)&lt;/span&gt; {...}\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;Now, by satisfying the Strict Aliasing rule, step 3 can be avoided and the code will run significantly faster.&lt;/p&gt;\n\n&lt;p&gt;In fact, by adding the &lt;code&gt;restrict&lt;/code&gt; keyword, the whole function could be optimized to:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;load &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; from memory.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;add &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;save result both to &lt;code&gt;a&lt;/code&gt; and to &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;This optimization couldn&apos;t have been done before, because of the possible collision (where &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; would be tripled instead of doubled).&lt;/p&gt;\n    ","\n&lt;p&gt;Strict aliasing is not allowing different pointer types to the same data.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html&quot; rel=&quot;noreferrer&quot;&gt;This article&lt;/a&gt; should help you understand the issue in full detail.&lt;/p&gt;\n    ","\n&lt;p&gt;Technically in C++, the strict aliasing rule is probably never applicable.&lt;/p&gt;\n\n&lt;p&gt;Note the definition of indirection (&lt;a href=&quot;http://eel.is/c++draft/expr.unary.op#def:indirection&quot; rel=&quot;nofollow noreferrer&quot;&gt;* operator&lt;/a&gt;):&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;The unary * operator performs indirection: the expression to which it\n  is applied shall be a pointer to an object type, or a pointer to a\n  function type and &lt;strong&gt;the result is an lvalue referring to the object&lt;/strong&gt; or\n  function &lt;strong&gt;to which the expression points&lt;/strong&gt;.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Also from &lt;a href=&quot;http://eel.is/c++draft/basic.lval#1.1&quot; rel=&quot;nofollow noreferrer&quot;&gt;the definition of glvalue&lt;/a&gt;&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;A glvalue is an expression whose evaluation determines the identity of\n  an object, (...snip)&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;So in any well defined program trace, a glvalue refers to an object. &lt;strong&gt;So the so called strict aliasing rule doesn&apos;t apply, ever.&lt;/strong&gt; This may not be what the designers wanted.&lt;/p&gt;\n    "]},"randomTags":[{"name":"datetime","slug":"datetime"},{"name":"hierarchical-data","slug":"hierarchical-data"},{"name":"sfinae","slug":"sfinae"},{"name":"c++-standard-library","slug":"c++-standard-library"},{"name":"intersection","slug":"intersection"},{"name":"mongodb-query","slug":"mongodb-query"},{"name":"list","slug":"list"},{"name":"windows","slug":"windows"},{"name":"variable-length-array","slug":"variable-length-array"},{"name":"replace","slug":"replace"},{"name":"python-3.6","slug":"python-3.6"},{"name":"bash","slug":"bash"},{"name":"instantiation","slug":"instantiation"},{"name":"group-by","slug":"group-by"},{"name":"ecmascript-2017","slug":"ecmascript-2017"},{"name":"dependent-name","slug":"dependent-name"},{"name":"bcrypt","slug":"bcrypt"},{"name":"gprof","slug":"gprof"},{"name":"datediff","slug":"datediff"},{"name":"iec10967","slug":"iec10967"}]},"__N_SSG":true}