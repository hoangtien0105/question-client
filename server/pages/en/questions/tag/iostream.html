<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>iostream tags | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="All questions and solutions for iostream tags"/><meta property="og:title" content="iostream tags | Solution Checker"/><meta property="og:description" content="All questions and solutions for iostream tags"/><meta name="next-head-count" content="19"/><script id="google-analytics" data-nscript="beforeInteractive">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-NXVLL8B');</script><link rel="preload" href="/_next/static/css/c116652e2d6f4ad0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c116652e2d6f4ad0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-862498b6ec7885c3.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/912-9618bcf05da7091d.js" defer=""></script><script src="/_next/static/chunks/596-971e6593fb286f13.js" defer=""></script><script src="/_next/static/chunks/pages/questions/tag/%5Bslug%5D-e6668db30eb0d032.js" defer=""></script><script src="/_next/static/xZs8haGjOP63QuDE0kxeX/_buildManifest.js" defer=""></script><script src="/_next/static/xZs8haGjOP63QuDE0kxeX/_ssgManifest.js" defer=""></script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NXVLL8B"
        height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/tag/iostream#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="pagination-page-wrapper"><span class="pagination-buttons previous bg-stone-500 cursor-not-allowed  hover:bg-stone-500 text-white font-bold py-2 px-4 rounded">Previous</span></div><div class="question my-5"><div class="flex items-center justify-center"><div class="rounded-xl border p-5 shadow-md post-layout-inner bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/why-is-iostream::eof-inside-a-loop-condition-(i.e.-while-(!stream.eof()))-considered-wrong-1657384355427">Why is iostream::eof inside a loop condition (i.e. `while (!stream.eof())`) considered wrong?</a></div></div></div><div class="tags-wrap h-max space-x-8"><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/iostream">iostream</a></div></div></div><div><div class="flex items-center justify-between text-slate-500"><div class="flex space-x-4 md:space-x-8"><span class="btn bg-stone-500 cursor-pointer mt-5  hover:bg-stone-500 text-white font-bold py-2 px-4 rounded">Show Solution</span></div></div></div></div></div></div><div class="pagination-page-wrapper"><span class="pagination-buttons next bg-stone-500 cursor-not-allowed  hover:bg-stone-500 text-white font-bold py-2 px-4 rounded">Next</span></div><div class="widget"><a href="/questions/tag/filtering">filtering</a><a href="/questions/tag/pseudo-element">pseudo-element</a><a href="/questions/tag/string">string</a><a href="/questions/tag/mod-rewrite">mod-rewrite</a><a href="/questions/tag/performance">performance</a><a href="/questions/tag/sql-server">sql-server</a><a href="/questions/tag/cpu-architecture">cpu-architecture</a><a href="/questions/tag/vertical-alignment">vertical-alignment</a><a href="/questions/tag/global-variables">global-variables</a><a href="/questions/tag/sequence">sequence</a><a href="/questions/tag/form-submit">form-submit</a><a href="/questions/tag/linker-errors">linker-errors</a><a href="/questions/tag/text">text</a><a href="/questions/tag/virtual-destructor">virtual-destructor</a><a href="/questions/tag/branch-prediction">branch-prediction</a><a href="/questions/tag/unique">unique</a><a href="/questions/tag/aggregation-framework">aggregation-framework</a><a href="/questions/tag/reactjs">reactjs</a><a href="/questions/tag/match">match</a><a href="/questions/tag/mongodb">mongodb</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"count":1,"rows":[{"id":35,"title":"Why is iostream::eof inside a loop condition (i.e. `while (!stream.eof())`) considered wrong?","slug":"why-is-iostream::eof-inside-a-loop-condition-(i.e.-while-(!stream.eof()))-considered-wrong-1657384355427","postType":"QUESTION","createdAt":"2022-07-09T16:32:35.000Z","updatedAt":"2022-07-09T16:32:35.000Z","tags":[{"id":122,"name":"iostream","slug":"iostream","createdAt":"2022-07-09T16:32:35.000Z","updatedAt":"2022-07-09T16:32:35.000Z","Questions_Tags":{"questionId":35,"tagId":122}}]}]},"slug":"iostream","page":1,"answers":{"35":["\n\u0026lt;p\u0026gt;Because \u0026lt;code\u0026gt;iostream::eof\u0026lt;/code\u0026gt; will only return \u0026lt;code\u0026gt;true\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;after\u0026lt;/em\u0026gt; reading the end of the stream. It does \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; indicate, that the next read will be the end of the stream.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Consider this (and assume then next read will be at the end of the stream):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(!inStream.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;()){\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// yay, not end of stream yet, now read ...\u0026lt;/span\u0026gt;\n  inStream \u0026amp;gt;\u0026amp;gt; data;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// oh crap, now we read the end and *only* now the eof bit will be set (as well as the fail bit)\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// do stuff with (now uninitialized) data\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Against this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(inStream \u0026amp;gt;\u0026amp;gt; data){\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// when we land here, we can be sure that the read was successful.\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// if it wasn\u0026apos;t, the returned stream from operator\u0026amp;gt;\u0026amp;gt; would be converted to false\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// and the loop wouldn\u0026apos;t even be entered\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// do stuff with correctly initialized data (hopefully)\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And on your second question: Because\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;scanf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;...\u0026quot;\u0026lt;/span\u0026gt;,...)!=EOF)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;is the same as\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(!(inStream \u0026amp;gt;\u0026amp;gt; data).\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;())\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and \u0026lt;strong\u0026gt;not\u0026lt;/strong\u0026gt; the same as\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(!inStream.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;())\n    inFile \u0026amp;gt;\u0026amp;gt; data\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Bottom-line top:\u0026lt;/strong\u0026gt;  With proper handling of white-space, the following is how \u0026lt;code\u0026gt;eof\u0026lt;/code\u0026gt; can be used (and even, be more reliable than \u0026lt;code\u0026gt;fail()\u0026lt;/code\u0026gt; for error checking):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( !(in\u0026amp;gt;\u0026amp;gt;std::ws).\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;() ) {  \n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n   in \u0026amp;gt;\u0026amp;gt; data;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ( in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;() ) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* handle with break or throw */\u0026lt;/span\u0026gt;; \n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// now use data\u0026lt;/span\u0026gt;\n}    \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;(\u0026lt;em\u0026gt;Thanks Tony D for the suggestion to highlight the answer. See his comment below for an example to why this is more robust.\u0026lt;/em\u0026gt;)\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;The main argument against using \u0026lt;code\u0026gt;eof()\u0026lt;/code\u0026gt; seems to be missing an important subtlety about the role of white space. My proposition is that, checking \u0026lt;code\u0026gt;eof()\u0026lt;/code\u0026gt; explicitly is not only not \u0026quot;\u0026lt;em\u0026gt;always wrong\u0026lt;/em\u0026gt;\u0026quot; -- which seems to be an overriding opinion in this and similar SO threads --, but with proper handling of white-space, it provides for a cleaner and more reliable error handling, and is the \u0026lt;em\u0026gt;always correct\u0026lt;/em\u0026gt; solution (although, not necessarily the tersest).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To summarize what is being suggested as the \u0026quot;proper\u0026quot; termination and read order is the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(in \u0026amp;gt;\u0026amp;gt; data) {  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; }\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// which is equivalent to \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( !(in \u0026amp;gt;\u0026amp;gt; data).\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;() )  {  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The failure due to read attempt beyond eof is taken as the termination condition.  This means is that there is no easy way to distinguish between a successful stream and one that really fails for reasons other than eof. Take the following streams: \u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;1 2 3 4 5\u0026amp;lt;eof\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;1 2 a 3 4 5\u0026amp;lt;eof\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;a\u0026amp;lt;eof\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;while(in\u0026amp;gt;\u0026amp;gt;data)\u0026lt;/code\u0026gt; terminates with a set \u0026lt;code\u0026gt;failbit\u0026lt;/code\u0026gt; for \u0026lt;em\u0026gt;all\u0026lt;/em\u0026gt; three input. In the first and third, \u0026lt;code\u0026gt;eofbit\u0026lt;/code\u0026gt; is also set. So past the loop one needs very ugly extra logic to distinguish a proper input (1st) from improper ones (2nd and 3rd).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Whereas, take the following: \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( !in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;() ) \n{  \n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n   in \u0026amp;gt;\u0026amp;gt; data;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ( in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;() ) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* handle with break or throw */\u0026lt;/span\u0026gt;; \n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// now use data\u0026lt;/span\u0026gt;\n}    \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here, \u0026lt;code\u0026gt;in.fail()\u0026lt;/code\u0026gt; verifies that as long as there is something to read, it is the correct one. It\u0026apos;s purpose is not a mere while-loop terminator. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So far so good, but what happens if there is trailing space in the stream -- what sounds like the major concern against \u0026lt;code\u0026gt;eof()\u0026lt;/code\u0026gt; as terminator?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;We don\u0026apos;t need to surrender our error handling; just eat up the white-space:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( !in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;() ) \n{  \n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n   in \u0026amp;gt;\u0026amp;gt; data \u0026amp;gt;\u0026amp;gt; ws; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// eat whitespace with std::ws\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ( in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;() ) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* handle with break or throw */\u0026lt;/span\u0026gt;; \n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// now use data\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;std::ws\u0026lt;/code\u0026gt; skips any potential (zero or more) trailing space in the stream while setting the \u0026lt;code\u0026gt;eofbit\u0026lt;/code\u0026gt;, and \u0026lt;strong\u0026gt;not the \u0026lt;code\u0026gt;failbit\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;.  So, \u0026lt;code\u0026gt;in.fail()\u0026lt;/code\u0026gt; works as expected, as long as there is at least one data to read. If all-blank streams are also acceptable, then the correct form is:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( !(in\u0026amp;gt;\u0026amp;gt;ws).\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;() ) \n{  \n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n   in \u0026amp;gt;\u0026amp;gt; data; \n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ( in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;() ) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* handle with break or throw */\u0026lt;/span\u0026gt;; \n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* this will never fire if the eof is reached cleanly */\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// now use data\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Summary:\u0026lt;/strong\u0026gt; A properly constructed \u0026lt;code\u0026gt;while(!eof)\u0026lt;/code\u0026gt; is not only possible and not wrong, but allows data to be localized within scope, and provides a cleaner separation of error checking from business as usual.  That being said, \u0026lt;code\u0026gt;while(!fail)\u0026lt;/code\u0026gt; is inarguably a more common and terse idiom, and may be preferred in simple (single data per read type of) scenarios. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Because if programmers don\u0026apos;t write \u0026lt;code\u0026gt;while(stream \u0026amp;gt;\u0026amp;gt; n)\u0026lt;/code\u0026gt;, they possibly write this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(!stream.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;())\n{\n    stream \u0026amp;gt;\u0026amp;gt; n;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//some work on n;\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here the problem is, you cannot do \u0026lt;code\u0026gt;some work on n\u0026lt;/code\u0026gt; without first checking if the stream read was successful, because if it was unsuccessful, your \u0026lt;code\u0026gt;some work on n\u0026lt;/code\u0026gt; would produce undesired result.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The whole point is that, \u0026lt;code\u0026gt;eofbit\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;badbit\u0026lt;/code\u0026gt;, or \u0026lt;code\u0026gt;failbit\u0026lt;/code\u0026gt; are set \u0026lt;strong\u0026gt;after an attempt is made to read from the stream.\u0026lt;/strong\u0026gt; So if \u0026lt;code\u0026gt;stream \u0026amp;gt;\u0026amp;gt; n\u0026lt;/code\u0026gt; fails, then \u0026lt;code\u0026gt;eofbit\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;badbit\u0026lt;/code\u0026gt;, or \u0026lt;code\u0026gt;failbit\u0026lt;/code\u0026gt; is set immediately, so its more idiomatic if you write \u0026lt;code\u0026gt;while (stream \u0026amp;gt;\u0026amp;gt; n)\u0026lt;/code\u0026gt;, because the returned object \u0026lt;code\u0026gt;stream\u0026lt;/code\u0026gt; converts to \u0026lt;code\u0026gt;false\u0026lt;/code\u0026gt; if there was some failure in reading from the stream and consequently the loop stops. And it converts to \u0026lt;code\u0026gt;true\u0026lt;/code\u0026gt; if the read was successful and the loop continues.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The other answers have explained why the logic is wrong in \u0026lt;code\u0026gt;while (!stream.eof())\u0026lt;/code\u0026gt; and how to fix it. I want to focus on something different:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;why is checking for eof explicitly using \u0026lt;code\u0026gt;iostream::eof\u0026lt;/code\u0026gt; wrong?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;In general terms, checking for \u0026lt;code\u0026gt;eof\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;only\u0026lt;/em\u0026gt; is wrong because stream extraction (\u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt;) can fail without hitting the end of the file. If you have e.g. \u0026lt;code\u0026gt;int n; cin \u0026amp;gt;\u0026amp;gt; n;\u0026lt;/code\u0026gt; and the stream contains \u0026lt;code\u0026gt;hello\u0026lt;/code\u0026gt;, then \u0026lt;code\u0026gt;h\u0026lt;/code\u0026gt; is not a valid digit, so extraction will fail without reaching the end of the input.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This issue, combined with the general logic error of checking the stream state \u0026lt;em\u0026gt;before\u0026lt;/em\u0026gt; attempting to read from it, which means for N input items the loop will run N+1 times, leads to the following symptoms:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If the stream is empty, the loop will run once. \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; will fail (there is no input to be read) and all variables that were supposed to be set (by \u0026lt;code\u0026gt;stream \u0026amp;gt;\u0026amp;gt; x\u0026lt;/code\u0026gt;) are actually uninitialized. This leads to garbage data being processed, which can manifest as nonsensical results (often huge numbers).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;(If your standard library conforms to C++11, things are a bit different now: A failed \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; now sets numeric variables to \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt; instead of leaving them uninitialized (except for \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt;s).)\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If the stream is not empty, the loop will run again after the last valid input. Since in the last iteration all \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; operations fail, variables are likely to keep their value from the previous iteration. This can manifest as \u0026quot;the last line is printed twice\u0026quot; or \u0026quot;the last input record is processed twice\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;(This should manifest a bit differently since C++11 (see above): Now you get a \u0026quot;phantom record\u0026quot; of zeroes instead of a repeated last line.)\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If the stream contains malformed data but you only check for \u0026lt;code\u0026gt;.eof\u0026lt;/code\u0026gt;, you end up with an infinite loop. \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; will fail to extract any data from the stream, so the loop spins in place without ever reaching the end.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;To recap: The solution is to test the success of the \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; operation itself, not to use a separate \u0026lt;code\u0026gt;.eof()\u0026lt;/code\u0026gt; method: \u0026lt;code\u0026gt;while (stream \u0026amp;gt;\u0026amp;gt; n \u0026amp;gt;\u0026amp;gt; m) { ... }\u0026lt;/code\u0026gt;, just as in C you test the success of the \u0026lt;code\u0026gt;scanf\u0026lt;/code\u0026gt; call itself: \u0026lt;code\u0026gt;while (scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;amp;n, \u0026amp;amp;m) == 2) { ... }\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The important thing to remember is that, \u0026lt;code\u0026gt;inFile.eof()\u0026lt;/code\u0026gt; doesnt become \u0026lt;code\u0026gt;True\u0026lt;/code\u0026gt; until \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;after\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; an attempted read fails, because youve reached the end of the file. So, in this example, youll get an error.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (!inFile.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;()){\n    inFile \u0026amp;gt;\u0026amp;gt; x;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;process\u0026lt;/span\u0026gt;(x);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The way to make this loop correct, is to combine reading and checking into a single operation, like so\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (inFile \u0026amp;gt;\u0026amp;gt; x)\u0026amp;nbsp;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;process\u0026lt;/span\u0026gt;(x);\u0026amp;nbsp;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;By convention, \u0026lt;code\u0026gt;operator\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; returns the stream we read from, and a Boolean test on a stream returns \u0026lt;code\u0026gt;False\u0026lt;/code\u0026gt; when the stream fails (such as reaching end of file).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;So this gives us the correct sequence :\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;read\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;test whether the read succeeds\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;if and only if the test succeeds, process what weve read\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;If you happen to encounter some \u0026lt;em\u0026gt;other\u0026lt;/em\u0026gt; problem that prevents you from reading from the file correctly, you will not be able to reach \u0026lt;code\u0026gt;eof()\u0026lt;/code\u0026gt; as such. For example, lets look at something like this\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x;\u0026amp;nbsp;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (!inFile.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;()) {\u0026amp;nbsp;\n    inFile \u0026amp;gt;\u0026amp;gt; x;\u0026amp;nbsp;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;process\u0026lt;/span\u0026gt;(x);\n}\u0026amp;nbsp;\n    \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Let us trace through the working of the above code, with an example\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Assume the contents of the file are \u0026lt;code\u0026gt;\u0026apos;1\u0026apos;, \u0026apos;2\u0026apos;, \u0026apos;3\u0026apos;, \u0026apos;a\u0026apos;, \u0026apos;b\u0026apos;\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The loop will read the 1, 2, and 3 correctly.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Then itll get to \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;When it tries to extract \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; as an int, itll fail.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The stream is now in a failed state, until or unless we \u0026lt;code\u0026gt;clear\u0026lt;/code\u0026gt; the stream, all attempts at reading from it will fail.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;But, when we test for eof(), itll return \u0026lt;code\u0026gt;False\u0026lt;/code\u0026gt;, because were not at the end of the file, because theres still \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; waiting to be read.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The loop will keep trying to read from the file, and fail every time, so it \u0026lt;strong\u0026gt;never\u0026lt;/strong\u0026gt; reaches the end of the file.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;So, the loop above will run forever.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;But, if we use a loop like this, we will get the required output.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (inFile \u0026amp;gt;\u0026amp;gt; x)\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;process\u0026lt;/span\u0026gt;(x);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In this case, the stream will convert to \u0026lt;code\u0026gt;False\u0026lt;/code\u0026gt; not only in case of end of file, but also in case of a failed conversion, such as the \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; that we cant read as an integer.\u0026lt;/p\u0026gt;\n    "]},"randomTags":[{"name":"filtering","slug":"filtering"},{"name":"pseudo-element","slug":"pseudo-element"},{"name":"string","slug":"string"},{"name":"mod-rewrite","slug":"mod-rewrite"},{"name":"performance","slug":"performance"},{"name":"sql-server","slug":"sql-server"},{"name":"cpu-architecture","slug":"cpu-architecture"},{"name":"vertical-alignment","slug":"vertical-alignment"},{"name":"global-variables","slug":"global-variables"},{"name":"sequence","slug":"sequence"},{"name":"form-submit","slug":"form-submit"},{"name":"linker-errors","slug":"linker-errors"},{"name":"text","slug":"text"},{"name":"virtual-destructor","slug":"virtual-destructor"},{"name":"branch-prediction","slug":"branch-prediction"},{"name":"unique","slug":"unique"},{"name":"aggregation-framework","slug":"aggregation-framework"},{"name":"reactjs","slug":"reactjs"},{"name":"match","slug":"match"},{"name":"mongodb","slug":"mongodb"}]},"__N_SSG":true},"page":"/questions/tag/[slug]","query":{"slug":"iostream"},"buildId":"xZs8haGjOP63QuDE0kxeX","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>