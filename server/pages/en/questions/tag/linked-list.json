{"pageProps":{"data":{"count":1,"rows":[{"id":474,"title":"When to use LinkedList over ArrayList in Java?","slug":"when-to-use-linkedlist-over-arraylist-in-java-1657388107480","postType":"QUESTION","createdAt":"2022-07-09T17:35:07.000Z","updatedAt":"2022-07-09T17:35:07.000Z","tags":[{"id":2405,"name":"linked-list","slug":"linked-list","createdAt":"2022-07-09T17:35:07.000Z","updatedAt":"2022-07-09T17:35:07.000Z","Questions_Tags":{"questionId":474,"tagId":2405}}]}]},"slug":"linked-list","page":1,"answers":{"474":["\n&lt;p&gt;&lt;strong&gt;Summary&lt;/strong&gt; &lt;code&gt;ArrayList&lt;/code&gt; with &lt;code&gt;ArrayDeque&lt;/code&gt; are preferable in &lt;em&gt;many&lt;/em&gt; more use-cases than &lt;code&gt;LinkedList&lt;/code&gt;. If you&apos;re not sure&amp;nbsp; just start with &lt;code&gt;ArrayList&lt;/code&gt;.&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;TLDR, in &lt;code&gt;ArrayList&lt;/code&gt; accessing an element takes constant time [O(1)] and adding an element takes O(n) time [worst case]. In &lt;code&gt;LinkedList&lt;/code&gt; inserting an element takes O(n) time and accessing also takes O(n) time but &lt;code&gt;LinkedList&lt;/code&gt; uses more memory than &lt;code&gt;ArrayList&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;LinkedList&lt;/code&gt; and &lt;code&gt;ArrayList&lt;/code&gt; are two different implementations of the List interface. &lt;code&gt;LinkedList&lt;/code&gt; implements it with a doubly-linked list. &lt;code&gt;ArrayList&lt;/code&gt; implements it with a dynamically re-sizing array.&lt;/p&gt;\n&lt;p&gt;As with standard linked list and array operations, the various methods will have different algorithmic runtimes.&lt;/p&gt;\n&lt;p&gt;For &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/LinkedList.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;get(int index)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/4&lt;/em&gt; steps on average), but &lt;em&gt;O(1)&lt;/em&gt; when &lt;code&gt;index = 0&lt;/code&gt; or &lt;code&gt;index = list.size() - 1&lt;/code&gt; (in this case, you can also use &lt;code&gt;getFirst()&lt;/code&gt; and &lt;code&gt;getLast()&lt;/code&gt;). &lt;strong&gt;One of the main benefits of&lt;/strong&gt; &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;add(int index, E element)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/4&lt;/em&gt; steps on average), but &lt;em&gt;O(1)&lt;/em&gt; when &lt;code&gt;index = 0&lt;/code&gt; or &lt;code&gt;index = list.size() - 1&lt;/code&gt; (in this case, you can also use &lt;code&gt;addFirst()&lt;/code&gt; and &lt;code&gt;addLast()&lt;/code&gt;/&lt;code&gt;add()&lt;/code&gt;). &lt;strong&gt;One of the main benefits of&lt;/strong&gt; &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;remove(int index)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/4&lt;/em&gt; steps on average), but &lt;em&gt;O(1)&lt;/em&gt; when &lt;code&gt;index = 0&lt;/code&gt; or &lt;code&gt;index = list.size() - 1&lt;/code&gt; (in this case, you can also use &lt;code&gt;removeFirst()&lt;/code&gt; and &lt;code&gt;removeLast()&lt;/code&gt;). &lt;strong&gt;One of the main benefits of&lt;/strong&gt; &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;Iterator.remove()&lt;/code&gt; is &lt;em&gt;O(1)&lt;/em&gt;. &lt;strong&gt;One of the main benefits of&lt;/strong&gt; &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;ListIterator.add(E element)&lt;/code&gt; is &lt;em&gt;O(1)&lt;/em&gt;. &lt;strong&gt;One of the main benefits of&lt;/strong&gt; &lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;sup&gt;Note: Many of the operations need &lt;em&gt;n/4&lt;/em&gt; steps on average, &lt;em&gt;constant&lt;/em&gt; number of steps in the best case (e.g. index = 0), and &lt;em&gt;n/2&lt;/em&gt; steps in worst case (middle of list)&lt;/sup&gt;&lt;/p&gt;\n&lt;p&gt;For &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ArrayList.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;get(int index)&lt;/code&gt; is &lt;em&gt;O(1)&lt;/em&gt;. &lt;strong&gt;Main benefit of&lt;/strong&gt; &lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;add(E element)&lt;/code&gt; is &lt;em&gt;O(1)&lt;/em&gt; amortized, but &lt;em&gt;O(n)&lt;/em&gt; worst-case since the array must be resized and copied&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;add(int index, E element)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/2&lt;/em&gt; steps on average)&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;remove(int index)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/2&lt;/em&gt; steps on average)&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;Iterator.remove()&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/2&lt;/em&gt; steps on average)&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;ListIterator.add(E element)&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; (with &lt;em&gt;n/2&lt;/em&gt; steps on average)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;sup&gt;Note: Many of the operations need &lt;em&gt;n/2&lt;/em&gt; steps on average, &lt;em&gt;constant&lt;/em&gt; number of steps in the best case (end of list), &lt;em&gt;n&lt;/em&gt; steps in the worst case (start of list)&lt;/sup&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;LinkedList&amp;lt;E&amp;gt;&lt;/code&gt; allows for constant-time insertions or removals &lt;em&gt;using iterators&lt;/em&gt;, but only sequential access of elements. In other words, you can walk the list forwards or backwards, but finding a position in the list takes time proportional to the size of the list. Javadoc says &lt;em&gt;&quot;operations that index into the list will traverse the list from the beginning or the end, whichever is closer&quot;&lt;/em&gt;, so those methods are &lt;em&gt;O(n)&lt;/em&gt; (&lt;em&gt;n/4&lt;/em&gt; steps) on average, though &lt;em&gt;O(1)&lt;/em&gt; for &lt;code&gt;index = 0&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt;, on the other hand, allow fast random read access, so you can grab any element in constant time. But adding or removing from anywhere but the end requires shifting all the latter elements over, either to make an opening or fill the gap. Also, if you add more elements than the capacity of the underlying array, a new array (1.5 times the size) is allocated, and the old array is copied to the new one, so adding to an &lt;code&gt;ArrayList&lt;/code&gt; is &lt;em&gt;O(n)&lt;/em&gt; in the worst case but constant on average.&lt;/p&gt;\n&lt;p&gt;So depending on the operations you intend to do, you should choose the implementations accordingly. Iterating over either kind of List is practically equally cheap. (Iterating over an &lt;code&gt;ArrayList&lt;/code&gt; is technically faster, but unless you&apos;re doing something really performance-sensitive, you shouldn&apos;t worry about this -- they&apos;re both constants.)&lt;/p&gt;\n&lt;p&gt;The main benefits of using a &lt;code&gt;LinkedList&lt;/code&gt; arise when you re-use existing iterators to insert and remove elements. These operations can then be done in &lt;em&gt;O(1)&lt;/em&gt; by changing the list locally only. In an array list, the remainder of the array needs to be &lt;em&gt;moved&lt;/em&gt; (i.e. copied). On the other side, seeking in a &lt;code&gt;LinkedList&lt;/code&gt; means following the links in &lt;em&gt;O(n)&lt;/em&gt; (&lt;em&gt;n/2&lt;/em&gt; steps) for worst case, whereas in an &lt;code&gt;ArrayList&lt;/code&gt; the desired position can be computed mathematically and accessed in &lt;em&gt;O(1)&lt;/em&gt;.&lt;/p&gt;\n&lt;p&gt;Another benefit of using a &lt;code&gt;LinkedList&lt;/code&gt; arises when you add or remove from the head of the list, since those operations are &lt;em&gt;O(1)&lt;/em&gt;, while they are &lt;em&gt;O(n)&lt;/em&gt; for &lt;code&gt;ArrayList&lt;/code&gt;. Note that &lt;code&gt;ArrayDeque&lt;/code&gt; may be a good alternative to &lt;code&gt;LinkedList&lt;/code&gt; for adding and removing from the head, but it is not a &lt;code&gt;List&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;Also, if you have large lists, keep in mind that memory usage is also different. Each element of a &lt;code&gt;LinkedList&lt;/code&gt; has more overhead since pointers to the next and previous elements are also stored. &lt;code&gt;ArrayLists&lt;/code&gt; don&apos;t have this overhead. However, &lt;code&gt;ArrayLists&lt;/code&gt; take up as much memory as is allocated for the capacity, regardless of whether elements have actually been added.&lt;/p&gt;\n&lt;p&gt;The default initial capacity of an &lt;code&gt;ArrayList&lt;/code&gt; is pretty small (10 from Java 1.4 - 1.8). But since the underlying implementation is an array, the array must be resized if you add a lot of elements. To avoid the high cost of resizing when you know you&apos;re going to add a lot of elements, construct the &lt;code&gt;ArrayList&lt;/code&gt; with a higher initial capacity.&lt;/p&gt;\n&lt;p&gt;If the data structures perspective is used to understand the two structures, a LinkedList is basically a sequential data structure which contains a head Node. The Node is a wrapper for two components : a value of type T [accepted through generics] and another reference to the Node linked to it. So, we can assert it is a recursive data structure (a Node contains another Node which has another Node and so on...). Addition of elements takes linear time in LinkedList as stated above.&lt;/p&gt;\n&lt;p&gt;An ArrayList is a growable array. It is just like a regular array. Under the hood, when an element is added, and the ArrayList is already full to capacity, it creates another array with a size which is greater than previous size. The elements are then copied from previous array to new one and the elements that are to be added are also placed at the specified indices.&lt;/p&gt;\n    ","\n&lt;p&gt;Thus far, nobody seems to have addressed the memory footprint of each of these lists besides the general consensus that a &lt;code&gt;LinkedList&lt;/code&gt; is &quot;lots more&quot; than an &lt;code&gt;ArrayList&lt;/code&gt; so I did some number crunching to demonstrate exactly how much both lists take up for N null references.&lt;/p&gt;\n\n&lt;p&gt;Since references are either 32 or 64 bits (even when null) on their relative systems, I have included 4 sets of data for 32 and 64 bit &lt;code&gt;LinkedLists&lt;/code&gt; and &lt;code&gt;ArrayLists&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The sizes shown for the &lt;code&gt;ArrayList&lt;/code&gt; lines are for &lt;em&gt;trimmed lists&lt;/em&gt; - In practice, the capacity of the backing array in an &lt;code&gt;ArrayList&lt;/code&gt; is generally larger than its current element count.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Note 2:&lt;/strong&gt; &lt;em&gt;(thanks BeeOnRope)&lt;/em&gt; As CompressedOops is default now from mid JDK6 and up, the values below for 64-bit machines will basically match their 32-bit counterparts, unless of course you specifically turn it off.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/f83xDyz.png&quot; alt=&quot;Graph of LinkedList and ArrayList No. of Elements x Bytes&quot;&gt;&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;The result clearly shows that &lt;code&gt;LinkedList&lt;/code&gt; is a whole lot more than &lt;code&gt;ArrayList&lt;/code&gt;, especially with a very high element count. If memory is a factor, steer clear of &lt;code&gt;LinkedLists&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;The formulas I used follow, let me know if I have done anything wrong and I will fix it up. &apos;b&apos; is either 4 or 8 for 32 or 64 bit systems, and &apos;n&apos; is the number of elements. Note the reason for the mods is because all objects in java will take up a multiple of 8 bytes space regardless of whether it is all used or not.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;ArrayList:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;ArrayList object header + size integer + modCount integer + array reference + (array oject header + b * n) + MOD(array oject, 8) + MOD(ArrayList object, 8) == 8 + 4 + 4 + b + (12 + b * n) + MOD(12 + b * n, 8) + MOD(8 + 4 + 4 + b + (12 + b * n) + MOD(12 + b * n, 8), 8)&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;LinkedList:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;LinkedList object header + size integer + modCount integer + reference to header + reference to footer + (node object overhead + reference to previous element + reference to next element + reference to element) * n) + MOD(node object, 8) * n + MOD(LinkedList object, 8) == 8 + 4 + 4 + 2 * b + (8 + 3 * b) * n + MOD(8 + 3 * b, 8) * n + MOD(8 + 4 + 4 + 2 * b + (8 + 3 * b) * n + MOD(8 + 3 * b, 8) * n, 8)&lt;/code&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;code&gt;ArrayList&lt;/code&gt; is what you want. &lt;code&gt;LinkedList&lt;/code&gt; is almost always a (performance) bug.&lt;/p&gt;\n&lt;p&gt;Why &lt;code&gt;LinkedList&lt;/code&gt; sucks:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;It uses lots of small memory objects, and therefore impacts performance across the process.&lt;/li&gt;\n&lt;li&gt;Lots of small objects are bad for cache-locality.&lt;/li&gt;\n&lt;li&gt;Any indexed operation requires a traversal, i.e. has O(n) performance. This is not obvious in the source code, leading to algorithms O(n) slower than if &lt;code&gt;ArrayList&lt;/code&gt; was used.&lt;/li&gt;\n&lt;li&gt;Getting good performance is tricky.&lt;/li&gt;\n&lt;li&gt;Even when big-O performance is the same as &lt;code&gt;ArrayList&lt;/code&gt;, it is probably going to be significantly slower anyway.&lt;/li&gt;\n&lt;li&gt;It&apos;s jarring to see &lt;code&gt;LinkedList&lt;/code&gt; in source because it is probably the wrong choice.&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;Algorithm           ArrayList   LinkedList\nseek front            &lt;span class=&quot;hljs-title function_&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;         O(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)\nseek back             &lt;span class=&quot;hljs-title function_&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;         O(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)\nseek to index         &lt;span class=&quot;hljs-title function_&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;         O(N)\ninsert at front       &lt;span class=&quot;hljs-title function_&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(N)&lt;/span&gt;         O(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)\ninsert at back        &lt;span class=&quot;hljs-title function_&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;         O(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)\ninsert after an item  &lt;span class=&quot;hljs-title function_&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(N)&lt;/span&gt;         O(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;a href=&quot;https://web.archive.org/web/20180729155145/http://leepoint.net/algorithms/big-oh/bigoh.html&quot; rel=&quot;noreferrer&quot;&gt;Algorithms: Big-Oh Notation&lt;/a&gt; (archived)&lt;/p&gt;\n&lt;p&gt;ArrayLists are good for write-once-read-many or appenders, but bad at add/remove from the front or middle.&lt;/p&gt;\n    ","\n&lt;p&gt;As someone who has been doing operational performance engineering on very large scale SOA web services for about a decade, I would prefer the behavior of LinkedList over ArrayList.  While the steady-state throughput of LinkedList is worse and therefore might lead to buying more hardware -- the behavior of ArrayList under pressure could lead to apps in a cluster expanding their arrays in near synchronicity and for large array sizes could lead to lack of responsiveness in the app and an outage, while under pressure, which is catastrophic behavior.&lt;/p&gt;\n&lt;p&gt;Similarly, you can get better throughput in an app from the default throughput tenured garbage collector, but once you get java apps with 10GB heaps you can wind up locking up the app for 25 seconds during a Full GCs which causes timeouts and failures in SOA apps and blows your SLAs if it occurs too often.  Even though the CMS collector takes more resources and does not achieve the same raw throughput, it is a much better choice because it has more predictable and smaller latency.&lt;/p&gt;\n&lt;p&gt;ArrayList is only a better choice for performance if all you mean by performance is throughput and you can ignore latency.  In my experience at my job I cannot ignore worst-case latency.&lt;/p&gt;\n&lt;p&gt;Update (Aug 27, 2021 -- 10 years later):  This answer (my most historically upvoted answer on SO as well) is very likely wrong (for reasons outlined in the comments below).  I&apos;d like to add that ArrayList will optimize for sequential reading of memory and minimize cache-line and TLB misses, etc.  The copying overhead when the array grows past the bounds is likely inconsequential by comparison (and can be done by efficient CPU operations).  This answer is also probably getting worse over time given hardware trends.  The only situations where a LinkedList might make sense would be something highly contrived where you had thousands of Lists any one of which might grow to be GB-sized, but where no good guess could be made at allocation-time of the List and setting them all to GB-sized would blow up the heap.  And if you found some problem like that, then it really does call for reengineering whatever your solution is (and I don&apos;t like to lightly suggest reengineering old code because I myself maintain piles and piles of old code, but that&apos;d be a very good case of where the original design has simply run out of runway and does need to be chucked).  I&apos;ll still leave my decades-old poor opinion up there for you to read though.  Simple, logical and pretty wrong.&lt;/p&gt;\n    ","\n&lt;p&gt;Yeah, I know, this is an ancient question, but I&apos;ll throw in my two cents:&lt;/p&gt;\n\n&lt;p&gt;LinkedList is &lt;em&gt;almost always&lt;/em&gt; the wrong choice, performance-wise.  There are some very specific algorithms where a LinkedList is called for, but those are very, very rare and the algorithm will usually specifically depend on LinkedList&apos;s ability to insert and delete elements in the middle of the list relatively quickly, once you&apos;ve navigated there with a ListIterator.&lt;/p&gt;\n\n&lt;p&gt;There is one common use case in which LinkedList outperforms ArrayList: that of a queue.  However, if your goal is performance, instead of LinkedList you should also consider using an ArrayBlockingQueue (if you can determine an upper bound on your queue size ahead of time, and can afford to allocate all the memory up front), or this &lt;a href=&quot;http://www.javaspecialists.eu/archive/Issue027.html&quot; rel=&quot;noreferrer&quot;&gt;CircularArrayList implementation&lt;/a&gt;.  (Yes, it&apos;s from 2001, so you&apos;ll need to generify it, but I got comparable performance ratios to what&apos;s quoted in the article just now in a recent JVM)&lt;/p&gt;\n    ","\n&lt;p&gt;Joshua Bloch, the author of LinkedList:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Does anyone actually use LinkedList?  I wrote it, and I never use it.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Link: &lt;a href=&quot;https://twitter.com/joshbloch/status/583813919019573248&quot; rel=&quot;noreferrer&quot;&gt;https://twitter.com/joshbloch/status/583813919019573248&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;I&apos;m sorry for the answer not being as informative as the other answers, but I thought it would be the most self-explanatory if not revealing.&lt;/p&gt;\n    ","\n&lt;p&gt;It&apos;s an efficiency question. &lt;code&gt;LinkedList&lt;/code&gt; is fast for adding and deleting elements, but slow to access a specific element. &lt;code&gt;ArrayList&lt;/code&gt; is fast for accessing a specific element but can be slow to add to either end, and especially slow to delete in the middle.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://web.archive.org/web/20090204031044/http://www.javafaq.nu/java-article1111.html&quot; rel=&quot;noreferrer&quot;&gt;Array vs ArrayList vs LinkedList vs Vector&lt;/a&gt; goes more in depth, as does \n&lt;a href=&quot;http://en.wikipedia.org/wiki/Linked_list&quot; rel=&quot;noreferrer&quot;&gt;Linked List&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;Correct or Incorrect: Please execute test locally and decide for yourself!&lt;/p&gt;\n\n&lt;p&gt;Edit/Remove is faster in &lt;code&gt;LinkedList&lt;/code&gt; than &lt;code&gt;ArrayList&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;ArrayList&lt;/code&gt;, backed by &lt;code&gt;Array&lt;/code&gt;, which needs to be double the size, is worse in large volume application.&lt;/p&gt;\n\n&lt;p&gt;Below is the unit test result for each operation.Timing is given in Nanoseconds.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;Operation                       ArrayList                      LinkedList  \n\n&lt;span class=&quot;hljs-title function_&quot;&gt;AddAll&lt;/span&gt;   &lt;span class=&quot;hljs-params&quot;&gt;(Insert)&lt;/span&gt;               &lt;span class=&quot;hljs-number&quot;&gt;101&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;16719&lt;/span&gt;                      &lt;span class=&quot;hljs-number&quot;&gt;2623&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;29291&lt;/span&gt; \n\nAdd      (Insert-Sequentially)  &lt;span class=&quot;hljs-number&quot;&gt;152&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;46840&lt;/span&gt;                      &lt;span class=&quot;hljs-number&quot;&gt;966&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;62216&lt;/span&gt;\n\nAdd      (insert-randomly)      &lt;span class=&quot;hljs-number&quot;&gt;36527&lt;/span&gt;                          &lt;span class=&quot;hljs-number&quot;&gt;29193&lt;/span&gt;\n\nremove   (Delete)               &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;56&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;9095&lt;/span&gt;                     &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;45&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4904&lt;/span&gt;\n\ncontains (Search)               &lt;span class=&quot;hljs-number&quot;&gt;186&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;704&lt;/span&gt;                     &lt;span class=&quot;hljs-number&quot;&gt;189&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;64&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;981&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;Here&apos;s the code:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.junit.Assert;\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.junit.Test;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.util.*;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ArrayListVsLinkedList&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;MAX&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;500000&lt;/span&gt;;\n    String[] strings = maxArray();\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;////////////// ADD ALL ////////////////////////////////////////&lt;/span&gt;\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Test&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;arrayListAddAll&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n        &lt;span class=&quot;hljs-type&quot;&gt;Watch&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;watch&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Watch&lt;/span&gt;();\n        List&amp;lt;String&amp;gt; stringList = Arrays.asList(strings);\n        List&amp;lt;String&amp;gt; arrayList = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ArrayList&lt;/span&gt;&amp;lt;String&amp;gt;(MAX);\n\n        watch.start();\n        arrayList.addAll(stringList);\n        watch.totalTime(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Array List addAll() = &quot;&lt;/span&gt;);&lt;span class=&quot;hljs-comment&quot;&gt;//101,16719 Nanoseconds&lt;/span&gt;\n    }\n\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Test&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;linkedListAddAll&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; Exception {\n        &lt;span class=&quot;hljs-type&quot;&gt;Watch&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;watch&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Watch&lt;/span&gt;();\n        List&amp;lt;String&amp;gt; stringList = Arrays.asList(strings);\n\n        watch.start();\n        List&amp;lt;String&amp;gt; linkedList = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;LinkedList&lt;/span&gt;&amp;lt;String&amp;gt;();\n        linkedList.addAll(stringList);\n        watch.totalTime(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Linked List addAll() = &quot;&lt;/span&gt;);  &lt;span class=&quot;hljs-comment&quot;&gt;//2623,29291 Nanoseconds&lt;/span&gt;\n    }\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;//Note: ArrayList is 26 time faster here than LinkedList for addAll()&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;///////////////// INSERT /////////////////////////////////////////////&lt;/span&gt;\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Test&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;arrayListAdd&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n        &lt;span class=&quot;hljs-type&quot;&gt;Watch&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;watch&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Watch&lt;/span&gt;();\n        List&amp;lt;String&amp;gt; arrayList = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ArrayList&lt;/span&gt;&amp;lt;String&amp;gt;(MAX);\n\n        watch.start();\n        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (String string : strings)\n            arrayList.add(string);\n        watch.totalTime(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Array List add() = &quot;&lt;/span&gt;);&lt;span class=&quot;hljs-comment&quot;&gt;//152,46840 Nanoseconds&lt;/span&gt;\n    }\n\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Test&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;linkedListAdd&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n        &lt;span class=&quot;hljs-type&quot;&gt;Watch&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;watch&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Watch&lt;/span&gt;();\n\n        List&amp;lt;String&amp;gt; linkedList = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;LinkedList&lt;/span&gt;&amp;lt;String&amp;gt;();\n        watch.start();\n        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (String string : strings)\n            linkedList.add(string);\n        watch.totalTime(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Linked List add() = &quot;&lt;/span&gt;);  &lt;span class=&quot;hljs-comment&quot;&gt;//966,62216 Nanoseconds&lt;/span&gt;\n    }\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;//Note: ArrayList is 9 times faster than LinkedList for add sequentially&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;/////////////////// INSERT IN BETWEEN ///////////////////////////////////////&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Test&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;arrayListInsertOne&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n        &lt;span class=&quot;hljs-type&quot;&gt;Watch&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;watch&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Watch&lt;/span&gt;();\n        List&amp;lt;String&amp;gt; stringList = Arrays.asList(strings);\n        List&amp;lt;String&amp;gt; arrayList = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ArrayList&lt;/span&gt;&amp;lt;String&amp;gt;(MAX + MAX / &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;);\n        arrayList.addAll(stringList);\n\n        &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;insertString0&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; getString(&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;, MAX / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;);\n        &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;insertString1&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; getString(&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;, MAX / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;);\n        &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;insertString2&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; getString(&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;, MAX / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;);\n        &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;insertString3&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; getString(&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;, MAX / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;hljs-number&quot;&gt;40&lt;/span&gt;);\n\n        watch.start();\n\n        arrayList.add(insertString0);\n        arrayList.add(insertString1);\n        arrayList.add(insertString2);\n        arrayList.add(insertString3);\n\n        watch.totalTime(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Array List add() = &quot;&lt;/span&gt;);&lt;span class=&quot;hljs-comment&quot;&gt;//36527&lt;/span&gt;\n    }\n\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Test&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;linkedListInsertOne&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n        &lt;span class=&quot;hljs-type&quot;&gt;Watch&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;watch&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Watch&lt;/span&gt;();\n        List&amp;lt;String&amp;gt; stringList = Arrays.asList(strings);\n        List&amp;lt;String&amp;gt; linkedList = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;LinkedList&lt;/span&gt;&amp;lt;String&amp;gt;();\n        linkedList.addAll(stringList);\n\n        &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;insertString0&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; getString(&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;, MAX / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;);\n        &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;insertString1&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; getString(&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;, MAX / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;);\n        &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;insertString2&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; getString(&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;, MAX / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;);\n        &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;insertString3&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; getString(&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;, MAX / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;hljs-number&quot;&gt;40&lt;/span&gt;);\n\n        watch.start();\n\n        linkedList.add(insertString0);\n        linkedList.add(insertString1);\n        linkedList.add(insertString2);\n        linkedList.add(insertString3);\n\n        watch.totalTime(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Linked List add = &quot;&lt;/span&gt;);&lt;span class=&quot;hljs-comment&quot;&gt;//29193&lt;/span&gt;\n    }\n\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;//Note: LinkedList is 3000 nanosecond faster than ArrayList for insert randomly.&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;////////////////// DELETE //////////////////////////////////////////////////////&lt;/span&gt;\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Test&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;arrayListRemove&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; Exception {\n        &lt;span class=&quot;hljs-type&quot;&gt;Watch&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;watch&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Watch&lt;/span&gt;();\n        List&amp;lt;String&amp;gt; stringList = Arrays.asList(strings);\n        List&amp;lt;String&amp;gt; arrayList = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ArrayList&lt;/span&gt;&amp;lt;String&amp;gt;(MAX);\n\n        arrayList.addAll(stringList);\n        &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;searchString0&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; getString(&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;, MAX / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;);\n        &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;searchString1&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; getString(&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;, MAX / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;);\n\n        watch.start();\n        arrayList.remove(searchString0);\n        arrayList.remove(searchString1);\n        watch.totalTime(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Array List remove() = &quot;&lt;/span&gt;);&lt;span class=&quot;hljs-comment&quot;&gt;//20,56,9095 Nanoseconds&lt;/span&gt;\n    }\n\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Test&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;linkedListRemove&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; Exception {\n        &lt;span class=&quot;hljs-type&quot;&gt;Watch&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;watch&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Watch&lt;/span&gt;();\n        List&amp;lt;String&amp;gt; linkedList = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;LinkedList&lt;/span&gt;&amp;lt;String&amp;gt;();\n        linkedList.addAll(Arrays.asList(strings));\n\n        &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;searchString0&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; getString(&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;, MAX / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;);\n        &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;searchString1&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; getString(&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;, MAX / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;);\n\n        watch.start();\n        linkedList.remove(searchString0);\n        linkedList.remove(searchString1);\n        watch.totalTime(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Linked List remove = &quot;&lt;/span&gt;);&lt;span class=&quot;hljs-comment&quot;&gt;//20,45,4904 Nanoseconds&lt;/span&gt;\n    }\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;//Note: LinkedList is 10 millisecond faster than ArrayList while removing item.&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;///////////////////// SEARCH ///////////////////////////////////////////&lt;/span&gt;\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Test&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;arrayListSearch&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; Exception {\n        &lt;span class=&quot;hljs-type&quot;&gt;Watch&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;watch&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Watch&lt;/span&gt;();\n        List&amp;lt;String&amp;gt; stringList = Arrays.asList(strings);\n        List&amp;lt;String&amp;gt; arrayList = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ArrayList&lt;/span&gt;&amp;lt;String&amp;gt;(MAX);\n\n        arrayList.addAll(stringList);\n        &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;searchString0&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; getString(&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;, MAX / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;);\n        &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;searchString1&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; getString(&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;, MAX / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;);\n\n        watch.start();\n        arrayList.contains(searchString0);\n        arrayList.contains(searchString1);\n        watch.totalTime(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Array List addAll() time = &quot;&lt;/span&gt;);&lt;span class=&quot;hljs-comment&quot;&gt;//186,15,704&lt;/span&gt;\n    }\n\n    &lt;span class=&quot;hljs-meta&quot;&gt;@Test&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;linkedListSearch&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; Exception {\n        &lt;span class=&quot;hljs-type&quot;&gt;Watch&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;watch&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Watch&lt;/span&gt;();\n        List&amp;lt;String&amp;gt; linkedList = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;LinkedList&lt;/span&gt;&amp;lt;String&amp;gt;();\n        linkedList.addAll(Arrays.asList(strings));\n\n        &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;searchString0&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; getString(&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;, MAX / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;);\n        &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;searchString1&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; getString(&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;, MAX / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;);\n\n        watch.start();\n        linkedList.contains(searchString0);\n        linkedList.contains(searchString1);\n        watch.totalTime(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Linked List addAll() time = &quot;&lt;/span&gt;);&lt;span class=&quot;hljs-comment&quot;&gt;//189,64,981&lt;/span&gt;\n    }\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;//Note: Linked List is 500 Milliseconds faster than ArrayList&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Watch&lt;/span&gt; {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;long&lt;/span&gt; startTime;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;long&lt;/span&gt; endTime;\n\n        &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n            startTime = System.nanoTime();\n        }\n\n        &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;stop&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n            endTime = System.nanoTime();\n        }\n\n        &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;totalTime&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String s)&lt;/span&gt; {\n            stop();\n            System.out.println(s + (endTime - startTime));\n        }\n    }\n\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; String[] maxArray() {\n        String[] strings = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;String&lt;/span&gt;[MAX];\n        &lt;span class=&quot;hljs-type&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; Boolean.TRUE;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; MAX; i++) {\n            strings[i] = getString(result, i);\n            result = !result;\n        }\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; strings;\n    }\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; String &lt;span class=&quot;hljs-title function_&quot;&gt;getString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Boolean result, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i)&lt;/span&gt; {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; String.valueOf(result) + i + String.valueOf(!result);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;&lt;code&gt;ArrayList&lt;/code&gt; is essentially an array. &lt;code&gt;LinkedList&lt;/code&gt; is implemented as a double linked list. &lt;/p&gt;\n\n&lt;p&gt;The &lt;code&gt;get&lt;/code&gt; is pretty clear. O(1) for &lt;code&gt;ArrayList&lt;/code&gt;, because &lt;code&gt;ArrayList&lt;/code&gt; allow random access by using index. O(n) for &lt;code&gt;LinkedList&lt;/code&gt;, because it needs to find the index first. Note: there are different versions of &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;remove&lt;/code&gt;. &lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;LinkedList&lt;/code&gt; is faster in add and remove, but slower in get. In brief, &lt;code&gt;LinkedList&lt;/code&gt; should be preferred if: &lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;there are no large number of random access of element &lt;/li&gt;\n&lt;li&gt;there are a large number of add/remove operations&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;=== &lt;strong&gt;ArrayList&lt;/strong&gt; ===&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;add(E e)      \n\n&lt;ul&gt;\n&lt;li&gt;add at the end of ArrayList&lt;/li&gt;\n&lt;li&gt;require memory resizing cost.  &lt;/li&gt;\n&lt;li&gt;O(n) worst, O(1) amortized&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;li&gt;add(int index, E element) \n\n&lt;ul&gt;\n&lt;li&gt;add to a specific index position&lt;/li&gt;\n&lt;li&gt;require shifting &amp;amp; possible memory resizing cost&lt;/li&gt;\n&lt;li&gt;O(n)&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;li&gt;remove(int index)\n\n&lt;ul&gt;\n&lt;li&gt;remove a specified element&lt;/li&gt;\n&lt;li&gt;require shifting &amp;amp; possible memory resizing cost&lt;/li&gt;\n&lt;li&gt;O(n)&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;li&gt;remove(Object o) \n\n&lt;ul&gt;\n&lt;li&gt;remove the first occurrence of the specified element from this list&lt;/li&gt;\n&lt;li&gt;need to search the element first, and then shifting &amp;amp; possible memory resizing cost&lt;/li&gt;\n&lt;li&gt;O(n)&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;=== &lt;strong&gt;LinkedList&lt;/strong&gt; ===&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;add(E e)&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;add to the end of the list&lt;/li&gt;\n&lt;li&gt;O(1)&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;add(int index, E element)&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;insert at specified position&lt;/li&gt;\n&lt;li&gt;need to find the position first&lt;/li&gt;\n&lt;li&gt;O(n)&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;li&gt;remove()\n\n&lt;ul&gt;\n&lt;li&gt;remove first element of the list&lt;/li&gt;\n&lt;li&gt;O(1)&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;li&gt;remove(int index)\n\n&lt;ul&gt;\n&lt;li&gt;remove element with specified index&lt;/li&gt;\n&lt;li&gt;need to find the element first&lt;/li&gt;\n&lt;li&gt;O(n)&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;li&gt;remove(Object o)\n\n&lt;ul&gt;\n&lt;li&gt;remove the first occurrence of the specified element&lt;/li&gt;\n&lt;li&gt;need to find the element first&lt;/li&gt;\n&lt;li&gt;O(n)&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Here is a figure from &lt;a href=&quot;http://www.programcreek.com/2013/03/arraylist-vs-linkedlist-vs-vector/&quot; rel=&quot;noreferrer&quot;&gt;programcreek.com&lt;/a&gt; (&lt;code&gt;add&lt;/code&gt; and &lt;code&gt;remove&lt;/code&gt; are the first type, i.e., add an element at the end of the list and remove the element at the specified position in the list.):&lt;/p&gt;\n\n&lt;p&gt;&lt;img src=&quot;https://i.stack.imgur.com/pdKaZ.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt; due to modern computer architecture, &lt;code&gt;ArrayList&lt;/code&gt; will be significantly more efficient for nearly any possible use-case - and therefore &lt;code&gt;LinkedList&lt;/code&gt; should be avoided except some very unique and extreme cases.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;In theory, LinkedList has an O(1) for the &lt;code&gt;add(E element)&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;Also adding an element in the mid of a list should be very efficient.&lt;/p&gt;\n\n&lt;p&gt;Practice is very different, as LinkedList is a &lt;strong&gt;Cache Hostile&lt;/strong&gt; Data structure. From performance POV - there are very little cases where &lt;code&gt;LinkedList&lt;/code&gt; could be better performing than the &lt;em&gt;Cache-friendly&lt;/em&gt; &lt;code&gt;ArrayList&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;Here are results of a benchmark testing inserting elements in random locations. As you can see - the array list if much more efficient, although in theory each insert in the middle of the list will require &quot;move&quot; the &lt;em&gt;n&lt;/em&gt; later elements of the array (lower values are better):&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/edAd8.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/edAd8.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Working on a later generation hardware (bigger, more efficient caches) - the results are even more conclusive:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/XtdBP.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/XtdBP.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;LinkedList takes much more time to accomplish the same job. &lt;a href=&quot;https://kjellkod.wordpress.com/2012/08/08/java-galore-linkedlist-vs-arraylist-vs-dynamicintarray/&quot; rel=&quot;noreferrer&quot;&gt;source&lt;/a&gt; &lt;a href=&quot;https://ideone.com/JOJ05&quot; rel=&quot;noreferrer&quot;&gt;Source Code&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;There are two main reasons for this:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Mainly&lt;/strong&gt; - that the nodes of the &lt;code&gt;LinkedList&lt;/code&gt; are scattered randomly across the memory. RAM (&quot;Random Access Memory&quot;) isn&apos;t really random and blocks of memory need to be fetched to cache. This operation takes time, and when such fetches happen frequently - the memory pages in the cache need to be replaced all the time -&amp;gt; Cache misses -&amp;gt; Cache is not efficient.\n&lt;code&gt;ArrayList&lt;/code&gt; elements are stored on continuous memory - which is exactly what the modern CPU architecture is optimizing for.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Secondary&lt;/strong&gt; &lt;code&gt;LinkedList&lt;/code&gt; required to hold back/forward pointers, which means 3 times the memory consumption per value stored compared to &lt;code&gt;ArrayList&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://github.com/apache/orc/blob/master/java/core/src/java/org/apache/orc/impl/DynamicIntArray.java&quot; rel=&quot;noreferrer&quot;&gt;DynamicIntArray&lt;/a&gt;, btw, is a custom ArrayList implementation holding &lt;code&gt;Int&lt;/code&gt; (primitive type) and not Objects - hence all data is really stored adjacently - hence even more efficient.&lt;/p&gt;\n\n&lt;p&gt;A key elements to remember is that the cost of fetching memory block, is more significant than the cost accessing a single memory cell. That&apos;s why reader 1MB of sequential memory is up to x400 times faster than reading this amount of data from different blocks of memory:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;Latency Comparison &lt;span class=&quot;hljs-title function_&quot;&gt;Numbers&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(~&lt;span class=&quot;hljs-number&quot;&gt;2012&lt;/span&gt;)&lt;/span&gt;\n----------------------------------\nL1 cache reference                           &lt;span class=&quot;hljs-number&quot;&gt;0.5&lt;/span&gt; ns\nBranch mispredict                            &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;   ns\nL2 cache reference                           &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;   ns                      14x L1 cache\nMutex lock/unlock                           &lt;span class=&quot;hljs-number&quot;&gt;25&lt;/span&gt;   ns\nMain memory reference                      &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;   ns                      20x L2 cache, 200x L1 cache\nCompress 1K bytes with Zippy             &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;000&lt;/span&gt;   ns        &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; us\nSend 1K bytes over &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; Gbps network       &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;000&lt;/span&gt;   ns       &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt; us\nRead 4K randomly from SSD*             &lt;span class=&quot;hljs-number&quot;&gt;150&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;000&lt;/span&gt;   ns      &lt;span class=&quot;hljs-number&quot;&gt;150&lt;/span&gt; us          ~1GB/sec SSD\nRead &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; MB sequentially from memory     &lt;span class=&quot;hljs-number&quot;&gt;250&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;000&lt;/span&gt;   ns      &lt;span class=&quot;hljs-number&quot;&gt;250&lt;/span&gt; us\nRound trip within same datacenter      &lt;span class=&quot;hljs-number&quot;&gt;500&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;000&lt;/span&gt;   ns      &lt;span class=&quot;hljs-number&quot;&gt;500&lt;/span&gt; us\nRead &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; MB sequentially from SSD*     &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;000&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;000&lt;/span&gt;   ns    &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;000&lt;/span&gt; us    &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; ms  ~1GB/sec SSD, 4X memory\nDisk seek                           &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;000&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;000&lt;/span&gt;   ns   &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;000&lt;/span&gt; us   &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt; ms  20x datacenter roundtrip\nRead &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; MB sequentially from disk    &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;000&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;000&lt;/span&gt;   ns   &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;000&lt;/span&gt; us   &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt; ms  80x memory, 20X SSD\nSend packet CA-&amp;gt;Netherlands-&amp;gt;CA    &lt;span class=&quot;hljs-number&quot;&gt;150&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;000&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;000&lt;/span&gt;   ns  &lt;span class=&quot;hljs-number&quot;&gt;150&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;000&lt;/span&gt; us  &lt;span class=&quot;hljs-number&quot;&gt;150&lt;/span&gt; ms\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Source: &lt;a href=&quot;https://gist.github.com/jboner/2841832&quot; rel=&quot;noreferrer&quot;&gt;Latency Numbers Every Programmer Should Know&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Just to make the point even clearer, please check the benchmark of adding elements to the beginning of the list. This is a use-case where, in-theory, the &lt;code&gt;LinkedList&lt;/code&gt; should really shine, and &lt;code&gt;ArrayList&lt;/code&gt; should present poor or even worse-case results:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/2EygL.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/2EygL.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Note: this is a benchmark of the C++ Std lib, but my previous experience shown the C++ and Java results are very similar. &lt;a href=&quot;https://ideone.com/DDEJF&quot; rel=&quot;noreferrer&quot;&gt;Source Code&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Copying a sequential bulk of memory is an operation optimized by the modern CPUs - changing theory and actually making, again, &lt;code&gt;ArrayList&lt;/code&gt;/&lt;code&gt;Vector&lt;/code&gt; much more efficient&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;Credits: All benchmarks posted here are created by &lt;a href=&quot;https://www.linkedin.com/in/kjellkod/&quot; rel=&quot;noreferrer&quot;&gt;Kjell Hedstrm&lt;/a&gt;. Even more data can be found on &lt;a href=&quot;https://kjellkod.wordpress.com/&quot; rel=&quot;noreferrer&quot;&gt;his blog&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;code&gt;ArrayList&lt;/code&gt; is randomly accessible, while &lt;code&gt;LinkedList&lt;/code&gt; is really cheap to expand and remove elements from. For most cases, &lt;code&gt;ArrayList&lt;/code&gt; is fine.&lt;/p&gt;\n\n&lt;p&gt;Unless you&apos;ve created large lists and measured a bottleneck, you&apos;ll probably never need to worry about the difference.&lt;/p&gt;\n    ","\n&lt;p&gt;If your code has &lt;code&gt;add(0)&lt;/code&gt; and &lt;code&gt;remove(0)&lt;/code&gt;, use a &lt;code&gt;LinkedList&lt;/code&gt; and it&apos;s prettier &lt;code&gt;addFirst()&lt;/code&gt; and &lt;code&gt;removeFirst()&lt;/code&gt; methods. Otherwise, use &lt;code&gt;ArrayList&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;And of course, &lt;a href=&quot;https://github.com/google/guava&quot; rel=&quot;noreferrer&quot;&gt;Guava&lt;/a&gt;&apos;s &lt;a href=&quot;https://google.github.io/guava/releases/21.0/api/docs/com/google/common/collect/ImmutableList.html&quot; rel=&quot;noreferrer&quot;&gt;ImmutableList&lt;/a&gt; is your best friend.&lt;/p&gt;\n    ","\n&lt;p&gt;I usually use one over the other based on the time complexities of the operations that I&apos;d perform on that particular List.                                                                  &lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;|---------------------|---------------------|--------------------|------------|\n|      Operation      |     ArrayList       |     LinkedList     |   Winner   |\n|---------------------|---------------------|--------------------|------------|\n|     get(index)      |       O(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)          |         O(n)       | ArrayList  |\n|                     |                     |  n/&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; steps in avg  |            |\n|---------------------|---------------------|--------------------|------------|\n|      add(E)         |       O(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)          |         O(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)       | LinkedList |\n|                     |---------------------|--------------------|            |\n|                     | O(n) in worst &lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt;  |                    |            |\n|---------------------|---------------------|--------------------|------------|\n|    add(index, E)    |       O(n)          |         O(n)       | LinkedList |\n|                     |     n/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; steps       |      n/&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; steps     |            |\n|                     |---------------------|--------------------|            |\n|                     |                     |  O(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;hljs-type&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; |            |\n|---------------------|---------------------|--------------------|------------|\n|  remove(index, E)   |       O(n)          |         O(n)       | LinkedList |\n|                     |---------------------|--------------------|            |\n|                     |     n/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; steps       |      n/&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; steps     |            |\n|---------------------|---------------------|--------------------|------------|\n|  Iterator.remove()  |       O(n)          |         O(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)       | LinkedList |\n|  ListIterator.add() |                     |                    |            |\n|---------------------|---------------------|--------------------|------------|\n\n\n|--------------------------------------|-----------------------------------|\n|              ArrayList               |            LinkedList             |\n|--------------------------------------|-----------------------------------|\n|     Allows fast read access          |   Retrieving element takes &lt;span class=&quot;hljs-title function_&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(n)&lt;/span&gt;   |\n|--------------------------------------|-----------------------------------|\n|   Adding an element require shifting | o(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) [but traversing takes time]  |\n|       all the later elements         |                                   |\n|--------------------------------------|-----------------------------------|\n|   To add more elements than capacity |\n|    &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;array&lt;/span&gt; need to be allocated    |\n|--------------------------------------|\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Let&apos;s compare LinkedList and ArrayList w.r.t. below parameters:&lt;/p&gt;\n\n&lt;h2&gt;1. Implementation&lt;/h2&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;&lt;em&gt;ArrayList&lt;/em&gt; is the resizable array implementation of list interface , while &lt;/p&gt;\n  \n  &lt;p&gt;&lt;em&gt;LinkedList&lt;/em&gt; is the Doubly-linked list implementation of the list interface.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;hr&gt;\n\n&lt;h2&gt;2. Performance&lt;/h2&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;h3&gt;get(int index) or search operation&lt;/h3&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;&lt;em&gt;ArrayList&lt;/em&gt; get(int index) operation runs in constant time i.e O(1)  while &lt;/p&gt;\n  \n  &lt;p&gt;&lt;em&gt;LinkedList&lt;/em&gt; get(int index) operation run time is O(n) .&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;The reason behind &lt;em&gt;ArrayList&lt;/em&gt; being faster than LinkedList is that ArrayList uses an index based system for its elements as it internally uses an array data structure, on the other hand,&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;LinkedList&lt;/em&gt; does not provide index-based access for its elements as it iterates either from the beginning or end (whichever is closer) to retrieve the node at the specified element index.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;h3&gt;insert() or add(Object) operation&lt;/h3&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Insertions in &lt;em&gt;LinkedList&lt;/em&gt; are generally fast as compare to ArrayList. In LinkedList adding or insertion is O(1) operation . &lt;/p&gt;\n  \n  &lt;p&gt;While in &lt;em&gt;ArrayList&lt;/em&gt;, if the array is the full i.e worst case,  there is an extra cost of resizing array and copying elements to the new array, which makes runtime of add operation in ArrayList O(n), otherwise it is O(1).&lt;/p&gt;\n&lt;/blockquote&gt;&lt;/li&gt;\n&lt;li&gt;&lt;h3&gt;remove(int) operation&lt;/h3&gt;\n\n&lt;p&gt;Remove operation in LinkedList is generally the same as ArrayList i.e. O(n).&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;In &lt;em&gt;LinkedList&lt;/em&gt;, there are two overloaded remove methods. one is remove() without any parameter which removes the head of the list and runs in constant time O(1). The other overloaded remove method in LinkedList is remove(int) or remove(Object) which removes the Object or int passed as a parameter. This method traverses the LinkedList until it found the Object and unlink it from the original list. Hence this method runtime is O(n). &lt;/p&gt;\n  \n  &lt;p&gt;While in &lt;em&gt;ArrayList&lt;/em&gt; remove(int) method involves copying elements from the old array to new updated array, hence its runtime is O(n).&lt;/p&gt;\n&lt;/blockquote&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;hr&gt;\n\n&lt;h2&gt;3. Reverse  Iterator&lt;/h2&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;&lt;em&gt;LinkedList&lt;/em&gt; can be iterated in reverse direction using descendingIterator() while &lt;/p&gt;\n  \n  &lt;p&gt;there is no descendingIterator() in &lt;em&gt;ArrayList&lt;/em&gt; , so we need to write our own code to iterate over the ArrayList in reverse direction.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;hr&gt;\n\n&lt;h2&gt;4. Initial Capacity&lt;/h2&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;If the constructor  is not overloaded, then &lt;em&gt;ArrayList&lt;/em&gt; creates an empty list of initial capacity 10, while &lt;/p&gt;\n  \n  &lt;p&gt;&lt;em&gt;LinkedList&lt;/em&gt;  only constructs the empty list without any initial capacity.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;hr&gt;\n\n&lt;h2&gt;5. Memory Overhead&lt;/h2&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Memory overhead in &lt;em&gt;LinkedList&lt;/em&gt; is more as compared to ArrayList as a node in LinkedList needs to maintain the addresses of the next and previous node. While &lt;/p&gt;\n  \n  &lt;p&gt;In &lt;em&gt;ArrayList&lt;/em&gt;  each index only holds the actual object(data).&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://javahungry.blogspot.com/2015/04/difference-between-arraylist-and-linkedlist-in-java-example.html&quot; rel=&quot;noreferrer&quot;&gt;Source&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;I know this is an old post, but I honestly can&apos;t believe nobody mentioned that &lt;code&gt;LinkedList&lt;/code&gt; implements &lt;code&gt;Deque&lt;/code&gt;.  Just look at the methods in &lt;code&gt;Deque&lt;/code&gt; (and &lt;code&gt;Queue&lt;/code&gt;); if you want a fair comparison, try running &lt;code&gt;LinkedList&lt;/code&gt; against &lt;code&gt;ArrayDeque&lt;/code&gt; and do a feature-for-feature comparison. &lt;/p&gt;\n    ","\n&lt;p&gt;Here is the Big-O notation in both &lt;code&gt;ArrayList&lt;/code&gt; and &lt;code&gt;LinkedList&lt;/code&gt; and also &lt;code&gt;CopyOnWrite-ArrayList&lt;/code&gt;:&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;ArrayList&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;get                 &lt;span class=&quot;hljs-title function_&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;\nadd                 &lt;span class=&quot;hljs-title function_&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;\ncontains            &lt;span class=&quot;hljs-title function_&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(n)&lt;/span&gt;\nnext                &lt;span class=&quot;hljs-title function_&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;\nremove              &lt;span class=&quot;hljs-title function_&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(n)&lt;/span&gt;\niterator.remove     &lt;span class=&quot;hljs-title function_&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(n)&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;LinkedList&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;get                 &lt;span class=&quot;hljs-title function_&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(n)&lt;/span&gt;\nadd                 &lt;span class=&quot;hljs-title function_&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;\ncontains            &lt;span class=&quot;hljs-title function_&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(n)&lt;/span&gt;\nnext                &lt;span class=&quot;hljs-title function_&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;\nremove              &lt;span class=&quot;hljs-title function_&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;\niterator.remove     &lt;span class=&quot;hljs-title function_&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;CopyOnWrite-ArrayList&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;get                 &lt;span class=&quot;hljs-title function_&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;\nadd                 &lt;span class=&quot;hljs-title function_&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(n)&lt;/span&gt;\ncontains            &lt;span class=&quot;hljs-title function_&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(n)&lt;/span&gt;\nnext                &lt;span class=&quot;hljs-title function_&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;\nremove              &lt;span class=&quot;hljs-title function_&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(n)&lt;/span&gt;\niterator.remove     &lt;span class=&quot;hljs-title function_&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(n)&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Based on these you have to decide what to choose. :)&lt;/p&gt;\n    ","\n&lt;p&gt;In addition to the other good arguments above, you should notice &lt;code&gt;ArrayList&lt;/code&gt; implements &lt;code&gt;RandomAccess&lt;/code&gt; interface, while &lt;code&gt;LinkedList&lt;/code&gt; implements &lt;code&gt;Queue&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;So, somehow they address slightly different problems, with difference of efficiency and behavior (see their list of methods).&lt;/p&gt;\n    ","\n&lt;p&gt;It depends upon what operations you will be doing more on the List.&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;ArrayList&lt;/code&gt; is faster to access an indexed value. It is much worse when inserting or deleting objects.&lt;/p&gt;\n\n&lt;p&gt;To find out more, read any article that talks about the difference between arrays and linked lists.&lt;/p&gt;\n    ","\n&lt;p&gt;See &lt;a href=&quot;http://download.oracle.com/javase/tutorial/collections/implementations/list.html&quot; rel=&quot;noreferrer&quot;&gt;the Java Tutorials - List Implementations&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;An array list is essentially an array with methods to add items etc. (and you should use a generic list instead). It is a collection of items which can be accessed through an indexer  (for example [0]). It implies a progression from one item to the next.&lt;/p&gt;\n\n&lt;p&gt;A linked list specifies a progression from one item to the next (Item a -&amp;gt; item b).  You can get the same effect with an array list, but a linked list absolutely says what item is supposed to follow the previous one. &lt;/p&gt;\n    ","\n&lt;p&gt;An important feature of a linked list (which I didn&apos;t read in another answer) is the concatenation of two lists. With an array this is O(n) (+ overhead of some reallocations) with a linked list this is only O(1) or O(2) ;-)&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Important&lt;/strong&gt;: For Java its &lt;code&gt;LinkedList&lt;/code&gt; this is not true! See &lt;a href=&quot;https://stackoverflow.com/q/2494031/587642&quot;&gt;Is there a fast concat method for linked list in Java?&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;ArrayList and LinkedList have their own pros and cons.&lt;/p&gt;\n\n&lt;p&gt;ArrayList uses contiguous memory address compared to LinkedList which uses pointers toward the next node. So when you want to look up an element in an ArrayList is faster than doing n iterations with LinkedList.&lt;/p&gt;\n\n&lt;p&gt;On the other hand, insertion and deletion in a LinkedList are much easier because you just have to change the pointers whereas an ArrayList implies the use of shift operation for any insertion or deletion.&lt;/p&gt;\n\n&lt;p&gt;If you have frequent retrieval operations in your app use an ArrayList. If you have frequent insertion and deletion use a LinkedList. &lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;1) Underlying Data Structure&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;The first difference between ArrayList and LinkedList comes with the fact that ArrayList is backed by Array while LinkedList is backed by LinkedList. This will lead to further differences in performance.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;2) LinkedList implements Deque&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;Another difference between ArrayList and LinkedList is that apart from the List interface, LinkedList also implements Deque interface, which provides first in first out operations for &lt;code&gt;add()&lt;/code&gt; and &lt;code&gt;poll()&lt;/code&gt; and several other Deque functions. 3) Adding elements in ArrayList Adding element in ArrayList is O(1) operation if it doesn&apos;t trigger re-size of Array, in which case it becomes O(log(n)), On the other hand, appending an element in LinkedList is O(1) operation, as it doesn&apos;t require any navigation.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;4) Removing an element from a position&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;In order to remove an element from a particular index e.g. by calling &lt;code&gt;remove(index)&lt;/code&gt;, ArrayList performs a copy operation which makes it close to O(n) while LinkedList needs to traverse to that point which also makes it O(n/2), as it can traverse from either direction based upon proximity.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;5) Iterating over ArrayList or LinkedList&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;Iteration is the O(n) operation for both LinkedList and ArrayList where n is a number of an element.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;6) Retrieving element from a position&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;The &lt;code&gt;get(index)&lt;/code&gt; operation is O(1) in ArrayList while its O(n/2) in LinkedList, as it needs to traverse till that entry. Though, in Big O notation O(n/2) is just O(n) because we ignore constants there.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;7) Memory&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;LinkedList uses a wrapper object, Entry, which is a static nested class for storing data and two nodes next and previous while ArrayList just stores data in Array.&lt;/p&gt;\n&lt;p&gt;So memory requirement seems less in the case of ArrayList than LinkedList except for the case where Array performs the re-size operation when it copies content from one Array to another.&lt;/p&gt;\n&lt;p&gt;If Array is large enough it may take a lot of memory at that point and trigger Garbage collection, which can slow response time.&lt;/p&gt;\n&lt;p&gt;From all the above differences between ArrayList vs LinkedList, It looks ArrayList is the better choice than LinkedList in almost all cases, except when you do a frequent &lt;code&gt;add()&lt;/code&gt; operation than &lt;code&gt;remove()&lt;/code&gt;, or &lt;code&gt;get()&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;It&apos;s easier to modify a linked list than ArrayList, especially if you are adding or removing elements from start or end because linked list internally keeps references of those positions and they are accessible in O(1) time.&lt;/p&gt;\n&lt;p&gt;In other words, you don&apos;t need to traverse through the linked list to reach the position where you want to add elements, in that case, addition becomes O(n) operation. For example, inserting or deleting an element in the middle of a linked list.&lt;/p&gt;\n&lt;p&gt;In my opinion, use ArrayList over LinkedList for most of the practical purpose in Java.&lt;/p&gt;\n    ","\n&lt;p&gt;I have read the responses, but there is one scenario where I always use a LinkedList over an ArrayList that I want to share to hear opinions:&lt;/p&gt;\n\n&lt;p&gt;Every time I had a method that returns a list of data obtained from a DB I always use a LinkedList.&lt;/p&gt;\n\n&lt;p&gt;My rationale was that because it is impossible to know exactly how many results am I getting, there will be not memory wasted (as in ArrayList with the difference between the capacity and actual number of elements), and there would be no time wasted trying to duplicate the capacity.&lt;/p&gt;\n\n&lt;p&gt;As far a ArrayList, I agree that at least you should always use the constructor with the initial capacity, to minimize the duplication of the arrays as much as possible.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;code&gt;ArrayList&lt;/code&gt; and &lt;code&gt;LinkedList&lt;/code&gt; both implements &lt;code&gt;List interface&lt;/code&gt;  and their methods and results are almost identical. However there are few differences between them which make one better over another depending on the requirement.&lt;/p&gt;\n\n&lt;h2&gt;ArrayList Vs LinkedList&lt;/h2&gt;\n\n&lt;p&gt;1) &lt;code&gt;Search:&lt;/code&gt; &lt;code&gt;ArrayList&lt;/code&gt; search operation is pretty fast compared to the &lt;code&gt;LinkedList&lt;/code&gt; search operation. &lt;code&gt;get(int index)&lt;/code&gt; in &lt;code&gt;ArrayList&lt;/code&gt; gives the performance of &lt;code&gt;O(1)&lt;/code&gt; while &lt;code&gt;LinkedList&lt;/code&gt; performance is &lt;code&gt;O(n)&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;Reason:&lt;/code&gt; &lt;code&gt;ArrayList&lt;/code&gt; maintains index based system for its elements as it uses array data structure implicitly which makes it faster for searching an element in the list. On the other side &lt;code&gt;LinkedList&lt;/code&gt; implements doubly linked list which requires the traversal through all the elements for searching an element.&lt;/p&gt;\n\n&lt;p&gt;2) &lt;code&gt;Deletion:&lt;/code&gt; &lt;code&gt;LinkedList&lt;/code&gt; remove operation gives &lt;code&gt;O(1)&lt;/code&gt; performance while &lt;code&gt;ArrayList&lt;/code&gt; gives variable performance: &lt;code&gt;O(n)&lt;/code&gt; in worst case (while removing first element) and &lt;code&gt;O(1)&lt;/code&gt; in best case (While removing last element).&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Conclusion: LinkedList element deletion is faster compared to\n  ArrayList.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Reason: LinkedLists each element maintains two pointers (addresses) which points to the both neighbor elements in the list. Hence removal only requires change in the pointer location in the two neighbor nodes (elements) of the node which is going to be removed. While In ArrayList all the elements need to be shifted to fill out the space created by removed element.&lt;/p&gt;\n\n&lt;p&gt;3) &lt;code&gt;Inserts Performance:&lt;/code&gt; &lt;code&gt;LinkedList&lt;/code&gt; add method gives &lt;code&gt;O(1)&lt;/code&gt; performance while &lt;code&gt;ArrayList&lt;/code&gt; gives &lt;code&gt;O(n)&lt;/code&gt; in worst case. Reason is same as explained for remove.&lt;/p&gt;\n\n&lt;p&gt;4) &lt;code&gt;Memory Overhead:&lt;/code&gt; &lt;code&gt;ArrayList&lt;/code&gt; maintains indexes and element data while &lt;code&gt;LinkedList&lt;/code&gt; maintains element data and two pointers for neighbor nodes &lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;hence the memory consumption is high in LinkedList comparatively.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;h2&gt;There are few similarities between these classes which are as follows:&lt;/h2&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Both ArrayList and LinkedList are implementation of List interface.&lt;/li&gt;\n&lt;li&gt;They both maintain the elements insertion order which means while displaying ArrayList and LinkedList elements the result set would be having the same order in which the elements got inserted into the List.&lt;/li&gt;\n&lt;li&gt;Both these classes are non-synchronized and can be made synchronized explicitly by using Collections.synchronizedList method.&lt;/li&gt;\n&lt;li&gt;The &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;listIterator&lt;/code&gt; returned by these classes are &lt;code&gt;fail-fast&lt;/code&gt; (if list is structurally modified at any time after the iterator is created, in any way except through the &lt;code&gt;iterators&lt;/code&gt; own remove or add methods, the iterator will &lt;code&gt;throw&lt;/code&gt; a &lt;code&gt;ConcurrentModificationException&lt;/code&gt;).&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;h2&gt;When to use LinkedList and when to use ArrayList?&lt;/h2&gt;\n\n&lt;ul&gt;\n&lt;li&gt;As explained above the insert and remove operations give good performance &lt;code&gt;(O(1))&lt;/code&gt; in &lt;code&gt;LinkedList&lt;/code&gt; compared to &lt;code&gt;ArrayList(O(n))&lt;/code&gt;.\n\n&lt;blockquote&gt;\n  &lt;p&gt;Hence if there is a requirement of frequent addition and deletion in application then LinkedList is a best choice.&lt;/p&gt;\n&lt;/blockquote&gt;&lt;/li&gt;\n&lt;li&gt;Search (&lt;code&gt;get method&lt;/code&gt;) operations are fast in &lt;code&gt;Arraylist (O(1))&lt;/code&gt; but not in &lt;code&gt;LinkedList (O(n))&lt;/code&gt; \n\n&lt;blockquote&gt;\n  &lt;p&gt;so If there are less add and remove operations and more search operations requirement, ArrayList would be your best bet.&lt;/p&gt;\n&lt;/blockquote&gt;&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;Operation get(i) in ArrayList is faster than LinkedList, because:&lt;br&gt;\n&lt;strong&gt;ArrayList:&lt;/strong&gt; Resizable-array implementation of the List interface&lt;br&gt;\n&lt;strong&gt;LinkedList:&lt;/strong&gt; Doubly-linked list implementation of the List and Deque interfaces&lt;/p&gt;\n\n&lt;p&gt;Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index. &lt;/p&gt;\n    ","\n&lt;p&gt;One of the tests I saw on here only conducts the test once.  But what I have noticed is that you need to run these tests many times and eventually their times will converge.  Basically the JVM needs to warm up.  For my particular use case I needed to add/remove items to a list that grows to about 500 items.  In my tests &lt;code&gt;LinkedList&lt;/code&gt; came out faster, with &lt;code&gt;LinkedList&lt;/code&gt; coming in around 50,000 NS and &lt;code&gt;ArrayList&lt;/code&gt; coming in at around 90,000 NS... give or take.  See the code below.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; {\n    List&amp;lt;Long&amp;gt; times = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;ArrayList&lt;/span&gt;&amp;lt;&amp;gt;();\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;; i++) {\n        times.add(doIt());\n    }\n    System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;avg = &quot;&lt;/span&gt; + (times.stream().mapToLong(x -&amp;gt; x).average()));\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;doIt&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n    &lt;span class=&quot;hljs-type&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; System.nanoTime();\n    List&amp;lt;Object&amp;gt; list = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;LinkedList&lt;/span&gt;&amp;lt;&amp;gt;();\n    &lt;span class=&quot;hljs-comment&quot;&gt;//uncomment line below to test with ArrayList&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;//list = new ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;500&lt;/span&gt;; i++) {\n        list.add(i);\n    }\n\n    &lt;span class=&quot;hljs-type&quot;&gt;Iterator&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; list.iterator();\n    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (it.hasNext()) {\n        it.next();\n        it.remove();\n    }\n    &lt;span class=&quot;hljs-type&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; System.nanoTime();\n    &lt;span class=&quot;hljs-type&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;diff&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; end - start;\n    &lt;span class=&quot;hljs-comment&quot;&gt;//uncomment to see the JVM warmup and get faster for the first few iterations&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;//System.out.println(diff)&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; diff;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Both &lt;code&gt;remove()&lt;/code&gt; and &lt;code&gt;insert()&lt;/code&gt; have a runtime efficiency of O(n) for both ArrayLists and LinkedLists. However, the reason behind the linear processing time comes from two very different reasons:&lt;/p&gt;\n&lt;p&gt;In an ArrayList, you get to the element in O(1), but actually removing or inserting something makes it O(n) because all the following elements need to be changed.&lt;/p&gt;\n&lt;p&gt;In a LinkedList, it takes O(n) to actually get to the desired element, because we have to start at the very beginning until we reach the desired index. Actually removing or inserting is constant, because we only have to change 1 reference for &lt;code&gt;remove()&lt;/code&gt; and 2 references for &lt;code&gt;insert()&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;Which of the two is faster for inserting and removing depends on where it happens. If we are closer to the beginning the LinkedList will be faster, because we have to go through relatively few elements. If we are closer to the end an ArrayList will be faster, because we get there in constant time and only have to change the few remaining elements that follow it. When done precisely in the middle the LinkedList will be faster because going through n elements is quicker than moving n values.&lt;/p&gt;\n&lt;p&gt;Bonus: While there is no way of making these two methods O(1) for an ArrayList, there actually is a way to do this in LinkedLists. Let&apos;s say we want to go through the entire List removing and inserting elements on our way. Usually, you would start from the very beginning for each element using the LinkedList, we could also &quot;save&quot; the current element we&apos;re working on with an Iterator. With the help of the Iterator, we get an O(1) efficiency for &lt;code&gt;remove()&lt;/code&gt; and &lt;code&gt;insert()&lt;/code&gt; when working in a LinkedList. Making it the only performance benefit I&apos;m aware of where a LinkedList is always better than an ArrayList.&lt;/p&gt;\n    ","\n&lt;p&gt;ArrayList extends AbstractList and implements the List Interface. ArrayList is dynamic array.&lt;br&gt;It can be said that it was basically created to overcome the drawbacks of arrays&lt;br&gt;&lt;br&gt;\nThe LinkedList class extends AbstractSequentialList and implements List,Deque, and Queue interface.\n&lt;br&gt;Performance&lt;br&gt;\n&lt;code&gt;arraylist.get()&lt;/code&gt; is  O(1) whereas &lt;code&gt;linkedlist.get()&lt;/code&gt; is O(n) &lt;br&gt;\n&lt;code&gt;arraylist.add()&lt;/code&gt; is  O(1) and &lt;code&gt;linkedlist.add()&lt;/code&gt; is 0(1)&lt;br&gt;\n&lt;code&gt;arraylist.contains()&lt;/code&gt; is O(n) and&lt;code&gt;linkedlist.contains()&lt;/code&gt; is O(n) &lt;br&gt;\n&lt;code&gt;arraylist.next()&lt;/code&gt; is O(1) and &lt;code&gt;linkedlist.next()&lt;/code&gt; is O(1)&lt;br&gt;\n&lt;code&gt;arraylist.remove()&lt;/code&gt; is O(n) whereas &lt;code&gt;linkedlist.remove()&lt;/code&gt; is O(1)&lt;br&gt;\nIn arraylist&lt;br&gt;&lt;code&gt;iterator.remove()&lt;/code&gt; is O(n)&lt;br&gt; whereas In linkedlist &lt;br&gt;&lt;code&gt;iterator.remove()&lt;/code&gt;is O(1) &lt;/p&gt;\n    "]},"randomTags":[{"name":"aspect-ratio","slug":"aspect-ratio"},{"name":"non-greedy","slug":"non-greedy"},{"name":"repr","slug":"repr"},{"name":"chained-assignment","slug":"chained-assignment"},{"name":"winforms","slug":"winforms"},{"name":"terminology","slug":"terminology"},{"name":"events","slug":"events"},{"name":"jvm","slug":"jvm"},{"name":"asynchronous","slug":"asynchronous"},{"name":"nullpointerexception","slug":"nullpointerexception"},{"name":"mobile","slug":"mobile"},{"name":"java.util.scanner","slug":"java.util.scanner"},{"name":"batch-file","slug":"batch-file"},{"name":"count","slug":"count"},{"name":"same-origin-policy","slug":"same-origin-policy"},{"name":"http-redirect","slug":"http-redirect"},{"name":"dimension","slug":"dimension"},{"name":"error-reporting","slug":"error-reporting"},{"name":"uiviewcontroller","slug":"uiviewcontroller"},{"name":"angularfire2","slug":"angularfire2"}]},"__N_SSG":true}