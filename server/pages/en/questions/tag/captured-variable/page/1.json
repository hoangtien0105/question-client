{"pageProps":{"data":{"count":1,"rows":[{"id":343,"title":"Captured variable in a loop in C#","slug":"captured-variable-in-a-loop-in-c-1657387696779","postType":"QUESTION","createdAt":"2022-07-09T17:28:16.000Z","updatedAt":"2022-07-09T17:28:16.000Z","tags":[{"id":1947,"name":"captured-variable","slug":"captured-variable","createdAt":"2022-07-09T17:28:16.000Z","updatedAt":"2022-07-09T17:28:16.000Z","Questions_Tags":{"questionId":343,"tagId":1947}}]}]},"slug":"captured-variable","page":"1","answers":{"343":["\n&lt;p&gt;Yes - take a copy of the variable inside the loop:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (variable &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;)\n{\n    &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; copy = variable;\n    actions.Add(() =&amp;gt; copy * &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;);\n    ++ variable;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You can think of it as if the C# compiler creates a &quot;new&quot; local variable every time it hits the variable declaration. In fact it&apos;ll create appropriate new closure objects, and it gets complicated (in terms of implementation) if you refer to variables in multiple scopes, but it works :)&lt;/p&gt;\n\n&lt;p&gt;Note that a more common occurrence of this problem is using &lt;code&gt;for&lt;/code&gt; or &lt;code&gt;foreach&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;; i++) &lt;span class=&quot;hljs-comment&quot;&gt;// Just one variable&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;foreach&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; x &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; foo) &lt;span class=&quot;hljs-comment&quot;&gt;// And again, despite how it reads out loud&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;See section 7.14.4.2 of the C# 3.0 spec for more details of this, and my &lt;a href=&quot;http://csharpindepth.com/Articles/Chapter5/Closures.aspx&quot; rel=&quot;noreferrer&quot;&gt;article on closures&lt;/a&gt; has more examples too.&lt;/p&gt;\n\n&lt;p&gt;Note that as of the C# 5 compiler and beyond (even when specifying an earlier version of C#), the behavior of &lt;code&gt;foreach&lt;/code&gt; changed so you no longer need to make local copy. See &lt;a href=&quot;https://stackoverflow.com/questions/8898925/is-there-a-reason-for-cs-reuse-of-the-variable-in-a-foreach/8899347#8899347&quot;&gt;this answer&lt;/a&gt; for more details.&lt;/p&gt;\n    ","\n&lt;p&gt;I believe what you are experiencing is something known as Closure &lt;a href=&quot;http://en.wikipedia.org/wiki/Closure_(computer_science)&quot; rel=&quot;noreferrer&quot;&gt;http://en.wikipedia.org/wiki/Closure_(computer_science)&lt;/a&gt;. Your lamba has a reference to a variable which is scoped outside the function itself. Your lamba is not interpreted until you invoke it and once it is it will get the value the variable has at execution time.&lt;/p&gt;\n    ","\n&lt;p&gt;Behind the scenes, the compiler is generating a class that represents the closure for your method call. It uses that single instance of the closure class for each iteration of the loop. The code looks something like this, which makes it easier to see why the bug happens:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Main&lt;/span&gt;()&lt;/span&gt;\n{\n    List&amp;lt;Func&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;gt; actions = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; List&amp;lt;Func&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;gt;();\n\n    &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; variable = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; closure = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; CompilerGeneratedClosure();\n\n    Func&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;&amp;gt; anonymousMethodAction = &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (closure.variable &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;)\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(anonymousMethodAction == &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;)\n            anonymousMethodAction = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Func&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;&amp;gt;(closure.YourAnonymousMethod);\n\n        &lt;span class=&quot;hljs-comment&quot;&gt;//we&apos;re re-adding the same function &lt;/span&gt;\n        actions.Add(anonymousMethodAction);\n\n        ++closure.variable;\n    }\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;foreach&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; act &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; actions)\n    {\n        Console.WriteLine(act.Invoke());\n    }\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;CompilerGeneratedClosure&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; variable;\n\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;YourAnonymousMethod&lt;/span&gt;()&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.variable * &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This isn&apos;t actually the compiled code from your sample, but I&apos;ve examined my own code and this looks very much like what the compiler would actually generate.&lt;/p&gt;\n    ","\n&lt;p&gt;The way around this is to store the value you need in a proxy variable, and have that variable get captured.&lt;/p&gt;\n\n&lt;p&gt;I.E.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;( variable &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; )\n{\n    &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; copy = variable;\n    actions.Add( () =&amp;gt; copy * &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; );\n    ++variable;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;h1&gt;This has nothing to do with loops. &lt;/h1&gt;\n\n&lt;p&gt;This behavior is triggered because you use a lambda expression &lt;code&gt;() =&amp;gt; variable * 2&lt;/code&gt; where the outer scoped &lt;code&gt;variable&lt;/code&gt; not actually defined in the lambda&apos;s inner scope. &lt;/p&gt;\n\n&lt;p&gt;Lambda expressions (in C#3+, as well as anonymous methods in C#2) still create actual methods. Passing variables to these methods involve some dilemmas (pass by value? pass by reference? C# goes with by reference - but this opens another problem where the reference can outlive the actual variable). What C# does to resolve all these dilemmas is to create a new helper class (&quot;closure&quot;) with fields corresponding to the local variables used in the lambda expressions, and methods corresponding to the actual lambda methods. Any changes to &lt;code&gt;variable&lt;/code&gt; in your code is actually translated to change in that &lt;code&gt;ClosureClass.variable&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;So your while loop keeps updating the &lt;code&gt;ClosureClass.variable&lt;/code&gt; until it reaches 10, then you for loops executes the actions, which all operate on the same &lt;code&gt;ClosureClass.variable&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;To get your expected result, you need to create a separation between the loop variable, and the variable that is being closured. You can do this by introducing another variable, i.e.:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;List&amp;lt;Func&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;gt; actions = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; List&amp;lt;Func&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;gt;();\n&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; variable = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (variable &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;)\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; t = variable; &lt;span class=&quot;hljs-comment&quot;&gt;// now t will be closured (i.e. replaced by a field in the new class)&lt;/span&gt;\n    actions.Add(() =&amp;gt; t * &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;);\n    ++variable; &lt;span class=&quot;hljs-comment&quot;&gt;// changing variable won&apos;t affect the closured variable t&lt;/span&gt;\n}\n&lt;span class=&quot;hljs-keyword&quot;&gt;foreach&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; act &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; actions)\n{\n    Console.WriteLine(act.Invoke());\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You could also move the closure to another method to create this separation:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;List&amp;lt;Func&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;gt; actions = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; List&amp;lt;Func&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;gt;();\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; variable = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (variable &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;)\n{\n    actions.Add(Mult(variable));\n    ++variable;\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;foreach&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; act &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; actions)\n{\n    Console.WriteLine(act.Invoke());\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You can implement Mult as a lambda expression (implicit closure) &lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; Func&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;Mult&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; i&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; () =&amp;gt; i * &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or with an actual helper class:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Helper&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; _i;\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Helper&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; i&lt;/span&gt;)&lt;/span&gt;\n    {\n        _i = i;\n    }\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Method&lt;/span&gt;()&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; _i * &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;\n    }\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; Func&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;Mult&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; i&lt;/span&gt;)&lt;/span&gt;\n{\n    Helper help = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Helper(i);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; help.Method;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In any case, &lt;strong&gt;&quot;Closures&quot; are NOT a concept related to loops&lt;/strong&gt;, but rather to anonymous methods / lambda expressions use of local scoped variables - although some incautious use of loops demonstrate closures traps.&lt;/p&gt;\n    ","\n&lt;p&gt;Yes you need to scope &lt;code&gt;variable&lt;/code&gt; within the loop and pass it to the lambda that way:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;List&amp;lt;Func&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;gt; actions = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; List&amp;lt;Func&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;gt;();\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; variable = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (variable &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;)\n{\n    &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; variable1 = variable;\n    actions.Add(() =&amp;gt; variable1 * &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;);\n    ++variable;\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;foreach&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; act &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; actions)\n{\n    Console.WriteLine(act.Invoke());\n}\n\nConsole.ReadLine();\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;The same situation is happening in multi-threading (C#, &lt;a href=&quot;http://en.wikipedia.org/wiki/.NET_Framework&quot; rel=&quot;nofollow&quot;&gt;.NET&lt;/a&gt; 4.0].&lt;/p&gt;\n\n&lt;p&gt;See the following code:&lt;/p&gt;\n\n&lt;p&gt;Purpose is to print 1,2,3,4,5 in order.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; counter = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; counter &amp;lt;= &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;; counter++)\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Thread (() =&amp;gt; Console.Write (counter)).Start();\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The output is interesting! (It might be like 21334...)&lt;/p&gt;\n\n&lt;p&gt;The only solution is to use local variables.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; counter = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; counter &amp;lt;= &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;; counter++)\n{\n    &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; localVar= counter;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Thread (() =&amp;gt; Console.Write (localVar)).Start();\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; n=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; n &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;; n++) &lt;span class=&quot;hljs-comment&quot;&gt;//forloop syntax&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;foreach&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; item &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; foo) &lt;span class=&quot;hljs-keyword&quot;&gt;foreach&lt;/span&gt; syntax\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;It is called the closure problem,\nsimply use a copy variable, and it&apos;s done.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;List&amp;lt;Func&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;gt; actions = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; List&amp;lt;Func&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;gt;();\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; variable = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (variable &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;)\n{\n    &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; i = variable;\n    actions.Add(() =&amp;gt; i * &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;);\n    ++ variable;\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;foreach&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; act &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; actions)\n{\n    Console.WriteLine(act.Invoke());\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Since no one here directly quoted &lt;a href=&quot;https://ecma-international.org/publications/files/ECMA-ST/ECMA-334.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;ECMA-334&lt;/a&gt;:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;10.4.4.10 For statements &lt;/p&gt;\n  \n  &lt;p&gt;Definite assignment checking for a for-statement of the form:&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;-initializer; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;-condition; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;-iterator) embedded-statement\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;is done as if the statement were written:&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;-initializer;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;-condition) {\n        embedded-statement;\n    LLoop: &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;-iterator;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Further on in the spec,&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;12.16.6.3 Instantiation of local variables&lt;/p&gt;\n  \n  &lt;p&gt;A local variable is considered to be instantiated when execution enters the scope of the variable. &lt;/p&gt;\n  \n  &lt;p&gt;[Example: For example, when the following method is invoked, the local variable &lt;code&gt;x&lt;/code&gt; is instantiated and initialized three timesonce for each iteration of the loop.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;F&lt;/span&gt;()&lt;/span&gt; {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;; i++) {\n    &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; x = i * &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    ...\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;However, moving the declaration of &lt;code&gt;x&lt;/code&gt; outside the loop results in a single instantiation of &lt;code&gt;x&lt;/code&gt;:&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;F&lt;/span&gt;()&lt;/span&gt; {\n  &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; x;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;; i++) {\n    x = i * &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    ...\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;end example]&lt;/p&gt;\n  \n  &lt;p&gt;When not captured, there is no way to observe exactly how often a local variable is instantiatedbecause the lifetimes of the instantiations are disjoint, it is possible for each instantation to simply use the same storage location. However, when an anonymous function captures a local variable, the effects of instantiation become apparent.&lt;/p&gt;\n  \n  &lt;p&gt;[Example: The example &lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; System;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;delegate&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;D&lt;/span&gt;()&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Test&lt;/span&gt;{\n  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; D[] &lt;span class=&quot;hljs-title&quot;&gt;F&lt;/span&gt;()&lt;/span&gt; {\n    D[] result = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; D[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;];\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;; i++) {\n      &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; x = i * &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n      result[i] = () =&amp;gt; { Console.WriteLine(x); };\n    }\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; result;\n  }\n  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Main&lt;/span&gt;()&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;foreach&lt;/span&gt; (&lt;span class=&quot;hljs-function&quot;&gt;D d &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;F&lt;/span&gt;()) &lt;span class=&quot;hljs-title&quot;&gt;d&lt;/span&gt;()&lt;/span&gt;;\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;produces the output:&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;However, when the declaration of &lt;code&gt;x&lt;/code&gt; is moved outside the loop:&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; D[] &lt;span class=&quot;hljs-title&quot;&gt;F&lt;/span&gt;()&lt;/span&gt; {\n  D[] result = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; D[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;];\n  &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; x;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;; i++) {\n    x = i * &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    result[i] = () =&amp;gt; { Console.WriteLine(x); };\n  }\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; result;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;the output is:&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Note that the compiler is permitted (but not required) to optimize the three instantiations into a single delegate instance (§11.7.2).&lt;/p&gt;\n  \n  &lt;p&gt;If a for-loop declares an iteration variable, that variable itself is considered to be declared outside of the loop. \n  [Example: Thus, if the example is changed to capture the iteration variable itself:&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; D[] &lt;span class=&quot;hljs-title&quot;&gt;F&lt;/span&gt;()&lt;/span&gt; {\n  D[] result = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; D[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;];\n  &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;; i++) {\n    result[i] = () =&amp;gt; { Console.WriteLine(i); };\n  }\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; result;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;only one instance of the iteration variable is captured, which produces the output:&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;end example]&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Oh yea, I guess it should be mentioned that in C++ this problem doesn&apos;t occur because you can choose if the variable is captured by value or by reference (see: &lt;a href=&quot;https://en.cppreference.com/w/cpp/language/lambda#Lambda_capture&quot; rel=&quot;nofollow noreferrer&quot;&gt;Lambda capture&lt;/a&gt;).&lt;/p&gt;\n    "]},"randomTags":[{"name":"return-value","slug":"return-value"},{"name":"pecs","slug":"pecs"},{"name":"http-get","slug":"http-get"},{"name":"hover","slug":"hover"},{"name":"heredoc","slug":"heredoc"},{"name":"google-maps","slug":"google-maps"},{"name":"reserved-words","slug":"reserved-words"},{"name":"autolayout","slug":"autolayout"},{"name":"swing","slug":"swing"},{"name":"persistent-storage","slug":"persistent-storage"},{"name":"file","slug":"file"},{"name":"prop","slug":"prop"},{"name":"cmd","slug":"cmd"},{"name":"jsp","slug":"jsp"},{"name":"event-delegation","slug":"event-delegation"},{"name":"authentication","slug":"authentication"},{"name":"magic-methods","slug":"magic-methods"},{"name":"mod-rewrite","slug":"mod-rewrite"},{"name":"jsf-2","slug":"jsf-2"},{"name":"input","slug":"input"}]},"__N_SSG":true}