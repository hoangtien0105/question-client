{"pageProps":{"data":{"count":1,"rows":[{"id":585,"title":"What is the difference between #include <filename> and #include \"filename\"?","slug":"what-is-the-difference-between-include-lessfilenamegreater-and-include-\"filename\"-1657388489547","postType":"QUESTION","createdAt":"2022-07-09T17:41:29.000Z","updatedAt":"2022-07-09T17:41:29.000Z","tags":[{"id":2792,"name":"header-files","slug":"header-files","createdAt":"2022-07-09T17:41:29.000Z","updatedAt":"2022-07-09T17:41:29.000Z","Questions_Tags":{"questionId":585,"tagId":2792}}]}]},"slug":"header-files","page":1,"answers":{"585":["\n&lt;p&gt;What differs is the location in which the preprocessor searches for the included file.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;&lt;code&gt;#include &amp;lt;filename&amp;gt;&lt;/code&gt; &amp;nbsp; The preprocessor searches in an implementation dependent manner, normally in search directories pre-designated by the compiler/IDE. This method is normally used to include standard library header files.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;code&gt;#include &quot;filename&quot;&lt;/code&gt; &amp;nbsp; The preprocessor searches first in the same directory as the file containing the directive, and then follows the search path used for the &lt;code&gt;#include &amp;lt;filename&amp;gt;&lt;/code&gt; form. This method is normally used to include programmer-defined header files.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;A more complete description is available in the GCC &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/cpp/Search-Path.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;documentation on search paths&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;The only way to know is to read your implementation&apos;s documentation.&lt;/p&gt;\n\n&lt;p&gt;In &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf#page=182&quot; rel=&quot;noreferrer&quot;&gt;the C standard&lt;/a&gt;, section 6.10.2, paragraphs 2 to 4 state:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;ul&gt;\n  &lt;li&gt;&lt;p&gt;A preprocessing directive of the form&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;h-char-sequence&amp;gt;&lt;/span&gt; new-&lt;span class=&quot;hljs-keyword&quot;&gt;line&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;p&gt;searches a sequence of implementation-defined places for a &lt;strong&gt;header&lt;/strong&gt; identified uniquely by the specified sequence between the &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; delimiters, and causes the replacement of that directive by the entire contents of the &lt;strong&gt;header&lt;/strong&gt;. How the places are specified or the header identified is implementation-defined.&lt;/p&gt;&lt;/li&gt;\n  &lt;li&gt;&lt;p&gt;A preprocessing directive of the form&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;q-char-sequence&quot;&lt;/span&gt; new-&lt;span class=&quot;hljs-keyword&quot;&gt;line&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;p&gt;causes the replacement of that directive by the entire contents of the &lt;strong&gt;source file&lt;/strong&gt; identified by the specified sequence between the &lt;code&gt;&quot;&lt;/code&gt; delimiters. The named &lt;strong&gt;source file&lt;/strong&gt; is searched for in an implementation-defined manner. If this search is not supported, or if the search fails, the directive is reprocessed as if it read&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;h-char-sequence&amp;gt;&lt;/span&gt; new-&lt;span class=&quot;hljs-keyword&quot;&gt;line&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;p&gt;with the identical contained sequence (including &lt;code&gt;&amp;gt;&lt;/code&gt; characters, if any) from the original\n  directive.&lt;/p&gt;&lt;/li&gt;\n  &lt;li&gt;&lt;p&gt;A preprocessing directive of the form&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; pp-tokens new-&lt;span class=&quot;hljs-keyword&quot;&gt;line&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;p&gt;(that does not match one of the two previous forms) is permitted. The preprocessing tokens after &lt;code&gt;include&lt;/code&gt; in the directive are processed just as in normal text. (Each identifier currently defined as a macro name is replaced by its replacement list of preprocessing tokens.) The directive resulting after all replacements shall match one of the two previous forms. The method by which a sequence of preprocessing tokens between a &lt;code&gt;&amp;lt;&lt;/code&gt; and a &lt;code&gt;&amp;gt;&lt;/code&gt; preprocessing token pair or a pair of &lt;code&gt;&quot;&lt;/code&gt; characters is combined into a single header name preprocessing token is implementation-defined.&lt;/p&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n  \n  &lt;h3&gt;Definitions:&lt;/h3&gt;\n  \n  &lt;ul&gt;\n  &lt;li&gt;&lt;p&gt;h-char: any member of the source character set except the new-line character and &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;\n  &lt;li&gt;&lt;p&gt;q-char: any member of the source character set except the new-line character and &lt;code&gt;&quot;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;The sequence of characters between &amp;lt; and &amp;gt; uniquely refer to a header, which isn&apos;t necessarily a file. Implementations are pretty much free to use the character sequence as they wish. (Mostly, however, just treat it as a file name and do a search in the &lt;em&gt;include path&lt;/em&gt;, as the other posts state.)&lt;/p&gt;\n\n&lt;p&gt;If the &lt;code&gt;#include &quot;file&quot;&lt;/code&gt; form is used, the implementation first looks for a file of the given name, if supported. If not (supported), or if the search fails, the implementation behaves as though the other (&lt;code&gt;#include &amp;lt;file&amp;gt;&lt;/code&gt;) form was used.&lt;/p&gt;\n\n&lt;p&gt;Also, a third form exists and is used when the &lt;code&gt;#include&lt;/code&gt; directive doesn&apos;t match either of the forms above. In this form, some basic preprocessing (such as macro expansion) is done on the &quot;operands&quot; of the &lt;code&gt;#include&lt;/code&gt; directive, and the result is expected to match one of the two other forms.&lt;/p&gt;\n    ","\n&lt;p&gt;Some good answers here make references to the C standard but forgot the POSIX standard, especially the specific behavior of the &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/utilities/c99.html&quot;&gt;c99 (e.g. C compiler)&lt;/a&gt; command.&lt;/p&gt;\n\n&lt;p&gt;According to &lt;a href=&quot;https://www2.opengroup.org/ogsys/catalog/C138&quot;&gt;The Open Group Base Specifications Issue 7&lt;/a&gt;,&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;&lt;strong&gt;-I&lt;/strong&gt;  &lt;em&gt;directory&lt;/em&gt;&lt;/p&gt;\n  \n  &lt;p&gt;Change the algorithm for searching for headers whose names are not absolute pathnames to look in the directory named by the &lt;em&gt;directory&lt;/em&gt; pathname before looking in the usual places. Thus, headers whose names are enclosed in double-quotes ( &quot;&quot; ) shall be searched for first in the directory of the file with the &lt;strong&gt;#include&lt;/strong&gt; line, then in directories named in &lt;strong&gt;-I&lt;/strong&gt; options, and last in the usual places. For headers whose names are enclosed in angle brackets ( &quot;&amp;lt;&amp;gt;&quot; ), the header shall be searched for only in directories named in &lt;strong&gt;-I&lt;/strong&gt; options and then in the usual places. Directories named in &lt;strong&gt;-I&lt;/strong&gt; options shall be searched in the order specified. Implementations shall support at least ten instances of this option in a single &lt;em&gt;c99&lt;/em&gt; command invocation.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;So, in a POSIX compliant environment, with a POSIX compliant C compiler, &lt;code&gt;#include &quot;file.h&quot;&lt;/code&gt; is likely going to search for &lt;code&gt;./file.h&lt;/code&gt; first, where &lt;code&gt;.&lt;/code&gt; is the directory where is the file with the &lt;code&gt;#include&lt;/code&gt; statement, while &lt;code&gt;#include &amp;lt;file.h&amp;gt;&lt;/code&gt;, is likely going to search for &lt;code&gt;/usr/include/file.h&lt;/code&gt; first, where &lt;code&gt;/usr/include&lt;/code&gt; is your system defined &lt;em&gt;usual places&lt;/em&gt; for headers (it&apos;s seems not defined by POSIX).&lt;/p&gt;\n    ","\n&lt;p&gt;The exact behavior of the preprocessor varies between compilers. The following answer applies for GCC and several other compilers.&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;#include &amp;lt;file.h&amp;gt;&lt;/code&gt; tells the compiler to search for the header in its &quot;includes&quot; directory, e.g. for MinGW the compiler would search for &lt;code&gt;file.h&lt;/code&gt; in C:\\MinGW\\include\\ or wherever your compiler is installed.&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;#include &quot;file&quot;&lt;/code&gt; tells the compiler to search the current directory (i.e. the directory in which the source file resides) for &lt;code&gt;file&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;You can use the &lt;code&gt;-I&lt;/code&gt; flag for GCC to tell it that, when it encounters an include with angled brackets, it should also search for headers in the directory after &lt;code&gt;-I&lt;/code&gt;. GCC will treat the directory after the flag as if it were the &lt;code&gt;includes&lt;/code&gt; directory.&lt;/p&gt;\n&lt;p&gt;For instance, if you have a file called &lt;code&gt;myheader.h&lt;/code&gt; in your own directory, you could say &lt;code&gt;#include &amp;lt;myheader.h&amp;gt;&lt;/code&gt; if you called GCC with the flag &lt;code&gt;-I .&lt;/code&gt; (indicating that it should search for includes in the current directory.)&lt;/p&gt;\n&lt;p&gt;Without the &lt;code&gt;-I&lt;/code&gt; flag, you will have to use &lt;code&gt;#include &quot;myheader.h&quot;&lt;/code&gt; to include the file, or move &lt;code&gt;myheader.h&lt;/code&gt; to the &lt;code&gt;include&lt;/code&gt; directory of your compiler.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html&quot; rel=&quot;noreferrer&quot;&gt;GCC documentation says&lt;/a&gt; the following about the difference between the two:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Both user and system header files are included using the preprocessing     directive &lt;strong&gt;&lt;code&gt;#include&lt;/code&gt;&lt;/strong&gt;. It has two variants:&lt;/p&gt;\n  \n  &lt;blockquote&gt;\n    &lt;p&gt;&lt;strong&gt;&lt;code&gt;#include &amp;lt;file&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;\n    \n    &lt;p&gt;This variant is used for system header files. It searches for a file named file in a standard list of system directories. You can prepend directories to this list with the &lt;code&gt;-I&lt;/code&gt; option (see &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/cpp/Invocation.html#Invocation&quot; rel=&quot;noreferrer&quot;&gt;Invocation&lt;/a&gt;).&lt;/p&gt;\n    \n    &lt;p&gt;&lt;strong&gt;&lt;code&gt;#include &quot;file&quot;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;\n    \n    &lt;p&gt;This variant is used for header files of your own program. It searches for a file named file first in the directory containing the current file, then in the quote directories and then the same directories used for &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt;. You can prepend directories to the list of quote directories with the &lt;code&gt;-iquote&lt;/code&gt; option.\n    The argument of &lt;code&gt;#include&lt;/code&gt;, whether delimited with quote marks or angle brackets, behaves like a string constant in that comments are not recognized, and macro names are not expanded. Thus, &lt;code&gt;#include &amp;lt;x/*y&amp;gt;&lt;/code&gt; specifies inclusion of a system header file named &lt;code&gt;x/*y&lt;/code&gt;.&lt;/p&gt;\n    \n    &lt;p&gt;However, if backslashes occur within file, they are considered ordinary text characters, not escape characters. None of the character escape sequences appropriate to string constants in C are processed. Thus,&lt;code&gt;#include &quot;x\\n\\\\y&quot;&lt;/code&gt;specifies a filename containing three backslashes. (Some systems interpret \\ as a pathname separator. All of these also interpret &lt;code&gt;/&lt;/code&gt; the same way. It is most portable to use only &lt;code&gt;/&lt;/code&gt;.)&lt;/p&gt;\n    \n    &lt;p&gt;It is an error if there is anything (other than comments) on the line after the file name.&lt;/p&gt;\n  &lt;/blockquote&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;It does:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;mypath/myfile&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;short&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; ./mypath/myfile\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;with &lt;code&gt;.&lt;/code&gt; being either the directory of the file where the &lt;code&gt;#include&lt;/code&gt; is contained in, and/or the current working directory of the compiler, and/or the &lt;code&gt;default_include_paths&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;and&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&amp;lt;mypath/myfile&amp;gt; is short &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; &amp;lt;defaultincludepaths&amp;gt;/mypath/myfile\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;If &lt;code&gt;./&lt;/code&gt; is in &lt;code&gt;&amp;lt;default_include_paths&amp;gt;&lt;/code&gt;, then it doesn&apos;t make a difference.&lt;/p&gt;\n\n&lt;p&gt;If &lt;code&gt;mypath/myfile&lt;/code&gt; is in another include directory, the behavior is undefined.&lt;/p&gt;\n    ","\n&lt;p&gt;The &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; include tells the preprocessor to search in &lt;code&gt;-I&lt;/code&gt; directories and in predefined directories &lt;strong&gt;first&lt;/strong&gt;, then in the .c file&apos;s directory. The &lt;code&gt;&quot;file&quot;&lt;/code&gt; include tells the preprocessor to search the source file&apos;s directory &lt;strong&gt;first&lt;/strong&gt;, and then revert to &lt;code&gt;-I&lt;/code&gt; and predefined. All destinations are searched anyway, only the order of search is different.&lt;/p&gt;\n\n&lt;p&gt;The 2011 standard mostly discusses the include files in &quot;16.2 Source file inclusion&quot;.&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;2 A preprocessing directive of the form&lt;/p&gt;\n  \n  &lt;p&gt;&lt;code&gt;# include &amp;lt;h-char-sequence&amp;gt; new-line&lt;/code&gt;&lt;/p&gt;\n  \n  &lt;p&gt;searches a sequence of implementation-defined places for a header identified uniquely by the\n  specified sequence between the &amp;lt; and &amp;gt; delimiters, and causes the\n  replacement of that directive by the entire contents of the header.\n  How the places are specified or the header identified is\n  implementation-defined.&lt;/p&gt;\n  \n  &lt;p&gt;3 A preprocessing directive of the form&lt;/p&gt;\n  \n  &lt;p&gt;&lt;code&gt;# include &quot;q-char-sequence&quot; new-line&lt;/code&gt;&lt;/p&gt;\n  \n  &lt;p&gt;causes the replacement of that directive by the entire contents of the source file identified by the\n  specified sequence between the &quot; delimiters. The named source file is\n  searched for in an implementation-defined manner. If this search is\n  not supported, or if the search fails, the directive is reprocessed as\n  if it read&lt;/p&gt;\n  \n  &lt;p&gt;&lt;code&gt;# include &amp;lt;h-char-sequence&amp;gt; new-line&lt;/code&gt;&lt;/p&gt;\n  \n  &lt;p&gt;with the identical contained sequence (including &amp;gt; characters, if any) from the original directive.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Note that &lt;code&gt;&quot;xxx&quot;&lt;/code&gt; form degrades to &lt;code&gt;&amp;lt;xxx&amp;gt;&lt;/code&gt; form if the file is not found. The rest is implementation-defined.&lt;/p&gt;\n    ","\n&lt;p&gt;By the standard - yes, they are different:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;ul&gt;\n  &lt;li&gt;&lt;p&gt;A preprocessing directive of the form&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;h-char-sequence&amp;gt;&lt;/span&gt; new-&lt;span class=&quot;hljs-keyword&quot;&gt;line&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;p&gt;searches a sequence of implementation-defined places for a header identified uniquely by the specified sequence between the &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; delimiters, and causes the replacement of that directive by the entire contents of the header. How the places are specified or the header identified is implementation-defined.&lt;/p&gt;&lt;/li&gt;\n  &lt;li&gt;&lt;p&gt;A preprocessing directive of the form&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;q-char-sequence&quot;&lt;/span&gt; new-&lt;span class=&quot;hljs-keyword&quot;&gt;line&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;p&gt;causes the replacement of that directive by the entire contents of the source file identified by the specified sequence between the &lt;code&gt;&quot;&lt;/code&gt; delimiters. The named source file is searched for in an implementation-defined manner. If this search is not supported, or if the search fails, the directive is reprocessed as if it read&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;h-char-sequence&amp;gt;&lt;/span&gt; new-&lt;span class=&quot;hljs-keyword&quot;&gt;line&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;p&gt;with the identical contained sequence (including &lt;code&gt;&amp;gt;&lt;/code&gt; characters, if any) from the original\n  directive.&lt;/p&gt;&lt;/li&gt;\n  &lt;li&gt;&lt;p&gt;A preprocessing directive of the form&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; pp-tokens new-&lt;span class=&quot;hljs-keyword&quot;&gt;line&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;p&gt;(that does not match one of the two previous forms) is permitted. The preprocessing tokens after &lt;code&gt;include&lt;/code&gt; in the directive are processed just as in normal text. (Each identifier currently defined as a macro name is replaced by its replacement list of preprocessing tokens.) The directive resulting after all replacements shall match one of the two previous forms. The method by which a sequence of preprocessing tokens between a &lt;code&gt;&amp;lt;&lt;/code&gt; and a &lt;code&gt;&amp;gt;&lt;/code&gt; preprocessing token pair or a pair of &lt;code&gt;&quot;&lt;/code&gt; characters is combined into a single header name preprocessing token is implementation-defined.&lt;/p&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n  \n  &lt;h3&gt;Definitions:&lt;/h3&gt;\n  \n  &lt;ul&gt;\n  &lt;li&gt;&lt;p&gt;h-char: any member of the source character set except the new-line character and &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;\n  &lt;li&gt;&lt;p&gt;q-char: any member of the source character set except the new-line character and &lt;code&gt;&quot;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Note that the standard does not tell any relation between the implementation-defined manners. The first form searches in one implementation-defined way, and the other in a (possibly other) implementation-defined way. The standard also specifies that certain include files shall be present (for example, &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt;).&lt;/p&gt;\n\n&lt;p&gt;Formally you&apos;d have to read the manual for your compiler, however normally (by tradition) the &lt;code&gt;#include &quot;...&quot;&lt;/code&gt; form searches the directory of the file in which the &lt;code&gt;#include&lt;/code&gt; was found first, and then the directories that the &lt;code&gt;#include &amp;lt;...&amp;gt;&lt;/code&gt; form searches (the include path, eg system headers).&lt;/p&gt;\n    ","\n&lt;p&gt;At least for GCC version &amp;lt;= 3.0, the angle-bracket form does not generate a dependency between the included file and the including one.&lt;/p&gt;\n\n&lt;p&gt;So if you want to generate dependency rules (using the GCC -M option for exemple), you must use the quoted form for the files that should be included in the dependency tree.&lt;/p&gt;\n\n&lt;p&gt;(See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Invocation.html&quot; rel=&quot;noreferrer&quot;&gt;http://gcc.gnu.org/onlinedocs/cpp/Invocation.html&lt;/a&gt; )&lt;/p&gt;\n    ","\n&lt;p&gt;Thanks for the great answers, esp. Adam Stelmaszczyk and piCookie, and aib.&lt;/p&gt;\n&lt;p&gt;Like many programmers, I have used the informal convention of using the &lt;code&gt;&quot;myApp.hpp&quot;&lt;/code&gt; form for application specific files, and the &lt;code&gt;&amp;lt;libHeader.hpp&amp;gt;&lt;/code&gt; form for library and compiler system files, i.e. files specified in &lt;code&gt;/I&lt;/code&gt; and the &lt;code&gt;INCLUDE&lt;/code&gt; environment variable, for years thinking that was the standard.&lt;/p&gt;\n&lt;p&gt;However, the C standard states that the search order is implementation specific, which can make portability complicated.  To make matters worse, we use jam, which automagically figures out where the include files are.  You can use relative or absolute paths for your include files. i.e.&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;../../MyProgDir/SourceDir1/someFile.hpp&quot;&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Older versions of MSVS required double backslashes (\\\\), but now that&apos;s not required. I don&apos;t know when it changed. Just use forward slashes for compatibility with &apos;nix (Windows will accept that).&lt;/p&gt;\n&lt;p&gt;If you are &lt;em&gt;really&lt;/em&gt; worried about it, use &lt;code&gt;&quot;./myHeader.h&quot;&lt;/code&gt; for an include file in the same directory as the source code (my current, very large project has some duplicate include file names scattered about--really a configuration management problem).&lt;/p&gt;\n&lt;p&gt;Here&apos;s the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/36k2cdd4.aspx&quot; rel=&quot;noreferrer&quot;&gt;MSDN explanation&lt;/a&gt; copied here for your convenience).&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;strong&gt;Quoted form&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;The preprocessor searches for include files in this order:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;In the same directory as the file that contains the #include statement.&lt;/li&gt;\n&lt;li&gt;In the directories of the currently opened include files, in the reverse order in which&lt;br&gt;\nthey were opened. The search begins in the directory of the parent include file and&lt;br&gt;\ncontinues upward through the directories of any grandparent include files.&lt;/li&gt;\n&lt;li&gt;Along the path that&apos;s specified by each &lt;code&gt;/I&lt;/code&gt; compiler option.&lt;/li&gt;\n&lt;li&gt;Along the paths that are specified by the &lt;code&gt;INCLUDE&lt;/code&gt; environment variable.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;&lt;strong&gt;Angle-bracket form&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;The preprocessor searches for include files in this order:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Along the path that&apos;s specified by each &lt;code&gt;/I&lt;/code&gt; compiler option.&lt;/li&gt;\n&lt;li&gt;When compiling occurs on the command line, along the paths that are specified by the &lt;code&gt;INCLUDE&lt;/code&gt; environment variable.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;For &lt;code&gt;#include &quot;&quot;&lt;/code&gt; a compiler normally searches the folder of the file which contains that include and then the other folders. For &lt;code&gt;#include &amp;lt;&amp;gt;&lt;/code&gt; the compiler does not search the current file&apos;s folder.&lt;/p&gt;\n    ","\n&lt;p&gt;When you use &lt;code&gt;#include &amp;lt;filename&amp;gt;&lt;/code&gt;, the pre-processor looking for the file in directory of C\\C++ header files (stdio.h\\cstdio, string, vector, etc.). But, when you use &lt;code&gt;#include &quot;filename&quot;&lt;/code&gt; first, the pre-processor is looking for the file in the current directory, and if it doesn&apos;t here - the pre-processor will look for it in the directory of C\\C++ header files.&lt;/p&gt;\n    ","\n&lt;p&gt;An #include with angle brackets will search an &quot;implementation-dependent list of places&quot; (which is a very complicated way of saying &quot;system headers&quot;) for the file to be included.&lt;/p&gt;\n\n&lt;p&gt;An #include with quotes will just search for a file (and, &quot;in an implementation-dependent manner&quot;, bleh). Which means, in normal English, it will try to apply the path/filename that you toss at it and will not prepend a system path or tamper with it otherwise.&lt;/p&gt;\n\n&lt;p&gt;Also, if #include &quot;&quot; fails, it is re-read as #include &amp;lt;&amp;gt; by the standard.&lt;/p&gt;\n\n&lt;p&gt;The &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html&quot; rel=&quot;noreferrer&quot;&gt;gcc documentation&lt;/a&gt; has a (compiler specific) description which although being specific to gcc and not the standard, is a lot easier to understand than the attorney-style talk of the ISO standards.&lt;/p&gt;\n    ","\n&lt;p&gt;Many of the answers here focus on the paths the compiler will search in order to find the file. While this is what most compilers do, a conforming compiler is allowed to be preprogrammed with the effects of the standard headers, and to treat, say, &lt;code&gt;#include &amp;lt;list&amp;gt;&lt;/code&gt; as a switch, and it need not exist as a file at all.&lt;/p&gt;\n\n&lt;p&gt;This is not purely hypothetical. There is at least one compiler that work that way. Using &lt;code&gt;#include &amp;lt;xxx&amp;gt;&lt;/code&gt; only with standard headers is recommended.&lt;/p&gt;\n    ","\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;&lt;code&gt;#include &amp;lt;&amp;gt;&lt;/code&gt; is for predefined header files&lt;/strong&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;If the header file is predefined then you would simply write the header file name in angular brackets, and it would look like this (assuming we have a predefined header file name iostream):&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;&lt;code&gt;#include &quot; &quot;&lt;/code&gt; is for header files the programmer defines&lt;/strong&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;If you (the programmer) wrote your own header file then you would write the header file name in quotes. So, suppose you wrote a header file called &lt;code&gt;myfile.h&lt;/code&gt;, then this is an example of how you would use the include directive to include that file:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;myfile.h&quot;&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;filename&quot;&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;// User defined header&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;filename&amp;gt;&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;// Standard library header.&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Example:&lt;/p&gt;\n\n&lt;p&gt;The filename here is &lt;code&gt;Seller.h&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;ifndef&lt;/span&gt; SELLER_H     &lt;span class=&quot;hljs-comment&quot;&gt;// Header guard&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; SELLER_H     &lt;span class=&quot;hljs-comment&quot;&gt;// Header guard&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iomanip&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Seller&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;:\n        &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; name[&lt;span class=&quot;hljs-number&quot;&gt;31&lt;/span&gt;];\n        &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; sales_total;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:\n        &lt;span class=&quot;hljs-built_in&quot;&gt;Seller&lt;/span&gt;();\n        &lt;span class=&quot;hljs-built_in&quot;&gt;Seller&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;[], &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt;);\n        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;*&lt;span class=&quot;hljs-title&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In the class implementation (for example, &lt;code&gt;Seller.cpp&lt;/code&gt;, and in other files that will use the file &lt;code&gt;Seller.h&lt;/code&gt;), the header defined by the user should now be included, as follows:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Seller.h&quot;&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;abc.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;is used to include standard library files. So the compiler will check in the locations where standard library headers are residing.&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;xyz.h&quot;&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;will tell the compiler to include user-defined header files. So the compiler will check for these header files in the current folder or &lt;code&gt;-I&lt;/code&gt; defined folders.&lt;/p&gt;\n    ","\n&lt;p&gt;In C++, include a file in two ways:&lt;/p&gt;\n\n&lt;p&gt;The first one is #include  which tells the preprocessor to look for the file in the predefined default location.\nThis location is often an INCLUDE environment variable that denotes the path to include files.&lt;/p&gt;\n\n&lt;p&gt;And the second type is #include &quot;filename&quot; which tells the preprocessor to look for the file in the current directory first, then look for it in the predefined locations user have set up.&lt;/p&gt;\n    ","\n&lt;p&gt;The &lt;code&gt;#include &amp;lt;filename&amp;gt;&lt;/code&gt; is used when a system file is being referred to. That is a header file that can be found at system default locations like &lt;code&gt;/usr/include&lt;/code&gt; or &lt;code&gt;/usr/local/include&lt;/code&gt;. For your own files that needs to be included in another program you have to use the &lt;code&gt;#include &quot;filename&quot;&lt;/code&gt; syntax.&lt;/p&gt;\n    ","\n&lt;h2&gt;Form 1 - #include &amp;lt; xxx &amp;gt;&lt;/h2&gt;\n&lt;p&gt;First, looks for the presence of header file in the current directory from where directive is invoked. If not found, then it searches in the preconfigured list of standard system directories.&lt;/p&gt;\n&lt;h2&gt;Form 2 - #include &quot;xxx&quot;&lt;/h2&gt;\n&lt;p&gt;This looks for the presence of header file in the current directory from where directive is invoked.&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;The exact search directory list depends on the target system, how GCC is configured, and where it is installed.\nYou can find the search directory list of your GCC compiler by running it with -v option.&lt;/p&gt;\n&lt;p&gt;You can add additional directories to the search path by using - I&lt;em&gt;dir&lt;/em&gt;, which causes dir to be searched after the current directory (for the quote form of the directive) and ahead of the standard system directories.&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;Basically, the form &quot;xxx&quot; is nothing but search in current directory; if not found falling back the form &lt;/p&gt;\n    ","\n&lt;p&gt;The simple general rule is to use angled brackets to include header files that come with the compiler. Use double quotes to include any other header files. Most compilers do it this way.&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;a href=&quot;http://www.learncpp.com/cpp-tutorial/19-header-files/&quot; rel=&quot;nofollow&quot;&gt;1.9  Header files&lt;/a&gt;&lt;/em&gt; explains in more detail about pre-processor directives. If you are a novice programmer, that page should help you understand all that. I learned it from here, and I have been following it at work.&lt;/p&gt;\n    ","\n&lt;code&gt;#include &amp;lt;filename&amp;gt;&lt;/code&gt;\n&lt;p&gt;is used when you want to use the header file of the C/C++ system or compiler libraries. These libraries can be stdio.h, string.h, math.h, etc.&lt;/p&gt;\n&lt;code&gt;#include &quot;path-to-file/filename&quot;&lt;/code&gt;\n&lt;p&gt;is used when you want to use your own custom header file which is in your project folder or somewhere else.&lt;/p&gt;\n&lt;p&gt;For more information about preprocessors and header. Read &lt;em&gt;&lt;a href=&quot;http://www.tutorialspoint.com/cprogramming/c_preprocessors.htm&quot; rel=&quot;noreferrer&quot;&gt;C - Preprocessors&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;\n    ","\n&lt;blockquote&gt;\n  &lt;p&gt;the &quot; &amp;lt; filename &amp;gt; &quot; searches in standard C library locations&lt;/p&gt;\n  \n  &lt;p&gt;whereas &quot;filename&quot; searches in the current directory as well.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Ideally, you would use &amp;lt;...&amp;gt; for standard C libraries and &quot;...&quot; for libraries that you write and are present in the current directory.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;&lt;code&gt;#include &amp;lt;filename&amp;gt;&lt;/code&gt;&lt;/strong&gt;  &lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;The preprocessor searches in an implementation-dependent manner. It tells the compiler to search directory where system header files are held. &lt;/li&gt;\n&lt;li&gt;This method usually use to find standard header files.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;code&gt;#include &quot;filename&quot;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;This tell compiler to search header files where program is running. If it was failed it behave like &lt;code&gt;#include &amp;lt;filename&amp;gt;&lt;/code&gt; and search that header file at where system header files stored.&lt;/li&gt;\n&lt;li&gt;This method usually used for identify user defined header files(header files which are created by user). There for don&apos;t use this if you want to call standard library because it takes more compiling time than &lt;code&gt;#include &amp;lt;filename&amp;gt;&lt;/code&gt;.&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;In general the difference is where the preprocessor searches for the header file:&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;#include is a preprocessor directive to include header file. Both #include are used to add or include header file in the program, but first is to include system header files and later one for user defined header files.&lt;/strong&gt;&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;strong&gt;#include &amp;lt;filename&amp;gt;&lt;/strong&gt; is used to include the system library header file in the program, means the C/C++ preprocessor will search for the filename where the C library files are stored or predefined system header files are stored.&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;#include &quot;filename&quot;&lt;/strong&gt; is used to include user defined header file in the program, means the C/C++ preprocessor will search for the filename in the current directory the program is in and then follows the search path used for the #include &amp;lt;filename&amp;gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;Check the gcc docs &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-3.2.1/gcc/Include-Files-and-VMS.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;gcc include files&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;file&amp;gt;&lt;/span&gt; &lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Includes a file where the default include directory is.&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;file&quot;&lt;/span&gt; &lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Includes a file in the current directory in which it was compiled. Double quotes can specify a full file path to a different location as well.&lt;/p&gt;\n    ","\n&lt;p&gt;To see the search order on your system using gcc, based on current configuration , you can execute the following command.  You can find more detail on this command &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/cpp/Search-Path.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;cpp -v /dev/null -o /dev/null&lt;/code&gt;&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Apple LLVM version 10.0.0 (clang-1000.10.44.2) &lt;br&gt;\n  Target: x86_64-apple-darwin18.0.0 &lt;br&gt;\n  Thread model: posix InstalledDir: Library/Developer/CommandLineTools/usr/bin&lt;br&gt;\n  &quot;/Library/Developer/CommandLineTools/usr/bin/clang&quot; -cc1 -triple\n  x86_64-apple-macosx10.14.0 -Wdeprecated-objc-isa-usage\n  -Werror=deprecated-objc-isa-usage -E -disable-free -disable-llvm-verifier -discard-value-names -main-file-name null -mrelocation-model pic -pic-level 2 -mthread-model posix -mdisable-fp-elim -fno-strict-return -masm-verbose -munwind-tables -target-cpu penryn -dwarf-column-info -debugger-tuning=lldb -target-linker-version 409.12 -v -resource-dir /Library/Developer/CommandLineTools/usr/lib/clang/10.0.0 -isysroot\n  /Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk\n  -I/usr/local/include -fdebug-compilation-dir /Users/hogstrom -ferror-limit 19 -fmessage-length 80 -stack-protector 1 -fblocks -fencode-extended-block-signature -fobjc-runtime=macosx-10.14.0 -fmax-type-align=16 -fdiagnostics-show-option -fcolor-diagnostics -traditional-cpp -o - -x c /dev/null &lt;br&gt;\n  clang -cc1 version 10.0.0 (clang-1000.10.44.2) default target x86_64-apple-darwin18.0.0 ignoring\n  nonexistent directory &quot;/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/local/include&quot;\n  ignoring nonexistent directory &quot;/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/Library/Frameworks&quot;&lt;br&gt;\n  &lt;strong&gt;#include &quot;...&quot; search starts here:&lt;/strong&gt;&lt;br&gt;\n  &lt;strong&gt;#include &amp;lt;...&amp;gt; search starts here:&lt;/strong&gt;&lt;br&gt;\n  &lt;strong&gt;/usr/local/include&lt;/strong&gt;  &lt;br&gt;\n  &lt;strong&gt;/Library/Developer/CommandLineTools/usr/lib/clang/10.0.0/include&lt;/strong&gt; &lt;br&gt;\n  &lt;strong&gt;/Library/Developer/CommandLineTools/usr/include&lt;/strong&gt; &lt;br&gt; \n  &lt;strong&gt;/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include&lt;/strong&gt; &lt;br&gt;\n  &lt;strong&gt;/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/System/Library/Frameworks&lt;/strong&gt; (framework directory)&lt;br&gt;\n   End of search list.&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;&lt;code&gt;&quot;&quot;&lt;/code&gt; will search &lt;code&gt;./&lt;/code&gt; first. Then search the default include path.\nYou can use command like this to print the default include path:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-css&quot;&gt;gcc -v -o &lt;span class=&quot;hljs-selector-tag&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.c&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Here are some examples to make thing more clear:\nthe code a.c works&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// a.c&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;stdio.h&quot;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n        &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;;\n        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;a = %d\\n&quot;&lt;/span&gt;, a);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;the code of b.c works too&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// b.c&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n        &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;;\n        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;a = %d\\n&quot;&lt;/span&gt;, a);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;but when I create a new file named &lt;code&gt;stdio.h&lt;/code&gt; in current directory&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// stdio.h&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n{\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;a.c&lt;/code&gt; will generate compile error, but &lt;code&gt;b.c&lt;/code&gt; still works&lt;/p&gt;\n&lt;p&gt;and &quot;&quot;, &amp;lt;&amp;gt; can be used together with the same file name. since the search path priority is different.\nso &lt;code&gt;d.c&lt;/code&gt; also works&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// d.c&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;stdio.h&quot;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n{\n        &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n\n        a = foo();\n\n        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;a=%d\\n&quot;&lt;/span&gt;, a);\n\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;The implementation-defined warnings generated by the compiler can (and will) treat system libraries differently than program libraries.&lt;/p&gt;\n&lt;p&gt;So&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;#include &amp;lt;myFilename&amp;gt;&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;-- which in effect declares that myFilename is in the system library location -- may well (and probably will) hide dead code and unused variable warnings etc, that would show up when you use:&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;#include &quot;myFilename&quot;&lt;/code&gt;&lt;/p&gt;\n    "]},"randomTags":[{"name":"uiviewcontroller","slug":"uiviewcontroller"},{"name":"most-vexing-parse","slug":"most-vexing-parse"},{"name":"aggregation-framework","slug":"aggregation-framework"},{"name":"email","slug":"email"},{"name":"siblings","slug":"siblings"},{"name":"vba","slug":"vba"},{"name":"spring","slug":"spring"},{"name":"chained-assignment","slug":"chained-assignment"},{"name":"shallow-copy","slug":"shallow-copy"},{"name":"keyword","slug":"keyword"},{"name":"shuffle","slug":"shuffle"},{"name":"unicode","slug":"unicode"},{"name":"utc","slug":"utc"},{"name":"object-slicing","slug":"object-slicing"},{"name":"return","slug":"return"},{"name":"protractor","slug":"protractor"},{"name":"default-constructor","slug":"default-constructor"},{"name":"overflow","slug":"overflow"},{"name":"json","slug":"json"},{"name":"full-outer-join","slug":"full-outer-join"}]},"__N_SSG":true}